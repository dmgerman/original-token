multiline_comment|/*&n; * bios32.c - PCI BIOS functions for Alpha systems not using BIOS&n; *&t;      emulation code.&n; *&n; * Written by Dave Rusling (david.rusling@reo.mts.dec.com)&n; *&n; * Adapted to 64-bit kernel and then rewritten by David Mosberger&n; * (davidm@cs.arizona.edu)&n; *&n; * For more information, please consult&n; *&n; * PCI BIOS Specification Revision&n; * PCI Local Bus Specification&n; * PCI System Design Guide&n; *&n; * PCI Special Interest Group&n; * M/S HF3-15A&n; * 5200 N.E. Elam Young Parkway&n; * Hillsboro, Oregon 97124-6497&n; * +1 (503) 696-2000&n; * +1 (800) 433-5177&n; *&n; * Manuals are $25 each or $50 for all three, plus $7 shipping&n; * within the United States, $35 abroad.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#if 0
macro_line|# define DBG_DEVS(args)&t;&t;printk args
macro_line|#else
DECL|macro|DBG_DEVS
macro_line|# define DBG_DEVS(args)
macro_line|#endif
macro_line|#ifndef CONFIG_PCI
DECL|function|pcibios_present
r_int
id|pcibios_present
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_pciconfig_read
id|asmlinkage
r_int
id|sys_pciconfig_read
c_func
(paren
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_pciconfig_write
id|asmlinkage
r_int
id|sys_pciconfig_write
c_func
(paren
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#else /* CONFIG_PCI */
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/hwrpb.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|KB
mdefine_line|#define KB&t;&t;1024
DECL|macro|MB
mdefine_line|#define MB&t;&t;(1024*KB)
DECL|macro|GB
mdefine_line|#define GB&t;&t;(1024*MB)
DECL|macro|MAJOR_REV
mdefine_line|#define MAJOR_REV&t;0
DECL|macro|MINOR_REV
mdefine_line|#define MINOR_REV&t;3
multiline_comment|/*&n; * Align VAL to ALIGN, which must be a power of two.&n; */
DECL|macro|ALIGN
mdefine_line|#define ALIGN(val,align)&t;(((val) + ((align) - 1)) &amp; ~((align) - 1))
multiline_comment|/*&n; * Temporary internal macro.  If this 0, then do not write to any of&n; * the PCI registers, merely read them (i.e., use configuration as&n; * determined by SRM).  The SRM seem do be doing a less than perfect&n; * job in configuring PCI devices, so for now we do it ourselves.&n; * Reconfiguring PCI devices breaks console (RPB) callbacks, but&n; * those don&squot;t work properly with 64 bit addresses anyways.&n; *&n; * The accepted convention seems to be that the console (POST&n; * software) should fully configure boot devices and configure the&n; * interrupt routing of *all* devices.  In particular, the base&n; * addresses of non-boot devices need not be initialized.  For&n; * example, on the AXPpci33 board, the base address a #9 GXE PCI&n; * graphics card reads as zero (this may, however, be due to a bug in&n; * the graphics card---there have been some rumor that the #9 BIOS&n; * incorrectly resets that address to 0...).&n; */
DECL|macro|PCI_MODIFY
mdefine_line|#define PCI_MODIFY&t;&t;1
r_extern
r_struct
id|hwrpb_struct
op_star
id|hwrpb
suffix:semicolon
multiline_comment|/* Forward declarations for some extra fixup routines for specific hardware. */
macro_line|#ifdef CONFIG_ALPHA_PC164
r_static
r_int
id|SMCInit
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ALPHA_MIATA
r_static
r_int
id|es1888_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if PCI_MODIFY
multiline_comment|/*&n; * NOTE: we can&squot;t just blindly use 64K for machines with EISA busses; they&n; * may also have PCI-PCI bridges present, and then we&squot;d configure the bridge&n; * incorrectly&n; *&n; * Also, we start at 0x8000 or 0x9000, in hopes to get all devices&squot;&n; * IO space areas allocated *before* 0xC000; this is because certain&n; * BIOSes (Millennium for one) use PCI Config space &quot;mechanism #2&quot;&n; * accesses to probe the bus. If a device&squot;s registers appear at 0xC000,&n; * it may see an INx/OUTx at that address during BIOS emulation of the&n; * VGA BIOS, and some cards, notably Adaptec 2940UW, take mortal offense.&n; */
macro_line|#if defined(CONFIG_ALPHA_EISA)
DECL|variable|io_base
r_static
r_int
r_int
id|io_base
op_assign
l_int|0x9000
suffix:semicolon
multiline_comment|/* start above 8th slot */
macro_line|#else
DECL|variable|io_base
r_static
r_int
r_int
id|io_base
op_assign
l_int|0x8000
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_ALPHA_XL)
multiline_comment|/*&n; * An XL is AVANTI (APECS) family, *but* it has only 27 bits of ISA address&n; * that get passed through the PCI&lt;-&gt;ISA bridge chip. Although this causes&n; * us to set the PCI-&gt;Mem window bases lower than normal, we still allocate&n; * PCI bus devices&squot; memory addresses *below* the low DMA mapping window,&n; * and hope they fit below 64Mb (to avoid conflicts), and so that they can&n; * be accessed via SPARSE space.&n; *&n; * We accept the risk that a broken Myrinet card will be put into a true XL&n; * and thus can more easily run into the problem described below.&n; */
DECL|variable|mem_base
r_static
r_int
r_int
id|mem_base
op_assign
l_int|16
op_star
id|MB
op_plus
l_int|2
op_star
id|MB
suffix:semicolon
multiline_comment|/* 16M to 64M-1 is avail */
macro_line|#elif defined(CONFIG_ALPHA_LCA) || defined(CONFIG_ALPHA_APECS)
multiline_comment|/*&n; * We try to make this address *always* have more than 1 bit set.&n; * this is so that devices like the broken Myrinet card will always have&n; * a PCI memory address that will never match a IDSEL address in&n; * PCI Config space, which can cause problems with early rev cards.&n; *&n; * However, APECS and LCA have only 34 bits for physical addresses, thus&n; * limiting PCI bus memory addresses for SPARSE access to be less than 128Mb.&n; */
DECL|variable|mem_base
r_static
r_int
r_int
id|mem_base
op_assign
l_int|64
op_star
id|MB
op_plus
l_int|2
op_star
id|MB
suffix:semicolon
macro_line|#else
multiline_comment|/*&n; * We try to make this address *always* have more than 1 bit set.&n; * this is so that devices like the broken Myrinet card will always have&n; * a PCI memory address that will never match a IDSEL address in&n; * PCI Config space, which can cause problems with early rev cards.&n; *&n; * Because CIA and PYXIS and T2 have more bits for physical addresses,&n; * they support an expanded range of SPARSE memory addresses.&n; */
DECL|variable|mem_base
r_static
r_int
r_int
id|mem_base
op_assign
l_int|128
op_star
id|MB
op_plus
l_int|16
op_star
id|MB
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Disable PCI device DEV so that it does not respond to I/O or memory&n; * accesses.&n; */
DECL|function|disable_dev
r_static
r_void
id|disable_dev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
macro_line|#if defined(CONFIG_ALPHA_EISA)
multiline_comment|/*&n;&t; * HACK: the PCI-to-EISA bridge does not seem to identify&n;&t; *       itself as a bridge... :-(&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
l_int|0x8086
op_logical_and
id|dev-&gt;device
op_eq
l_int|0x0482
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;disable_dev: ignoring PCEB...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|bus
op_assign
id|dev-&gt;bus
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/* hack, turn it off first... */
id|cmd
op_and_assign
(paren
op_complement
id|PCI_COMMAND_IO
op_amp
op_complement
id|PCI_COMMAND_MEMORY
op_amp
op_complement
id|PCI_COMMAND_MASTER
)paren
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Layout memory and I/O for a device:&n; */
DECL|macro|MAX
mdefine_line|#define MAX(val1, val2) ((val1) &gt; (val2) ? val1 : val2)
DECL|function|layout_dev
r_static
r_void
id|layout_dev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|base
comma
id|mask
comma
id|size
comma
id|reg
suffix:semicolon
r_int
r_int
id|alignto
suffix:semicolon
multiline_comment|/*&n;&t; * HACK: the PCI-to-EISA bridge does not seem to identify&n;&t; *       itself as a bridge... :-(&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_INTEL_82375
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: ignoring PCEB...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bus
op_assign
id|dev-&gt;bus
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
id|PCI_BASE_ADDRESS_0
suffix:semicolon
id|reg
op_le
id|PCI_BASE_ADDRESS_5
suffix:semicolon
id|reg
op_add_assign
l_int|4
)paren
(brace
multiline_comment|/*&n;&t;&t; * Figure out how much space and of what type this&n;&t;&t; * device wants.&n;&t;&t; */
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
op_amp
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
multiline_comment|/* this base-address register is unused */
id|dev-&gt;base_address
(braket
(paren
id|reg
op_minus
id|PCI_BASE_ADDRESS_0
)paren
op_rshift
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We&squot;ve read the base address register back after&n;&t;&t; * writing all ones and so now we must decode it.&n;&t;&t; */
r_if
c_cond
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * I/O space base address register.&n;&t;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|mask
op_assign
(paren
op_complement
id|base
op_lshift
l_int|1
)paren
op_or
l_int|0x1
suffix:semicolon
id|size
op_assign
(paren
id|mask
op_amp
id|base
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Aligning to 0x800 rather than the minimum base of&n;&t;&t;&t; * 0x400 is an attempt to avoid having devices in &n;&t;&t;&t; * any 0x?C?? range, which is where the de4x5 driver&n;&t;&t;&t; * probes for EISA cards.&n;&t;&t;&t; *&n;&t;&t;&t; * Adaptecs, especially, resent such intrusions.&n;&t;&t;&t; */
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x800
comma
id|size
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
id|alignto
)paren
suffix:semicolon
id|io_base
op_assign
id|base
op_plus
id|size
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
id|base
op_or
l_int|0x1
)paren
suffix:semicolon
id|dev-&gt;base_address
(braket
(paren
id|reg
op_minus
id|PCI_BASE_ADDRESS_0
)paren
op_rshift
l_int|2
)braket
op_assign
id|base
op_or
l_int|0x1
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: dev 0x%x IO @ 0x%x (0x%x)&bslash;n&quot;
comma
id|dev-&gt;device
comma
id|base
comma
id|size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|type
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Memory space base address register.&n;&t;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
id|type
op_assign
id|base
op_amp
id|PCI_BASE_ADDRESS_MEM_TYPE_MASK
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|mask
op_assign
(paren
op_complement
id|base
op_lshift
l_int|1
)paren
op_or
l_int|0x1
suffix:semicolon
id|size
op_assign
(paren
id|mask
op_amp
id|base
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_32
suffix:colon
r_break
suffix:semicolon
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_64
suffix:colon
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: &quot;
l_string|&quot;ignoring 64-bit device in &quot;
l_string|&quot;slot %d, function %d: &bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
suffix:semicolon
id|reg
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip extra 4 bytes */
r_continue
suffix:semicolon
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_1M
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Allocating memory below 1MB is *very*&n;&t;&t;&t;&t; * tricky, as there may be all kinds of&n;&t;&t;&t;&t; * ISA devices lurking that we don&squot;t know&n;&t;&t;&t;&t; * about.  For now, we just cross fingers&n;&t;&t;&t;&t; * and hope nobody tries to do this on an&n;&t;&t;&t;&t; * Alpha (or that the console has set it&n;&t;&t;&t;&t; * up properly).&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: slot %d, function %d&quot;
l_string|&quot; requests memory below 1MB---don&squot;t&quot;
l_string|&quot; know how to do that.&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * The following holds at least for the Low Cost&n;&t;&t;&t; * Alpha implementation of the PCI interface:&n;&t;&t;&t; *&n;&t;&t;&t; * In sparse memory address space, the first&n;&t;&t;&t; * octant (16MB) of every 128MB segment is&n;&t;&t;&t; * aliased to the the very first 16MB of the&n;&t;&t;&t; * address space (i.e., it aliases the ISA&n;&t;&t;&t; * memory address space).  Thus, we try to&n;&t;&t;&t; * avoid allocating PCI devices in that range.&n;&t;&t;&t; * Can be allocated in 2nd-7th octant only.&n;&t;&t;&t; * Devices that need more than 112MB of&n;&t;&t;&t; * address space must be accessed through&n;&t;&t;&t; * dense memory space only!&n;&t;&t;&t; */
multiline_comment|/* align to multiple of size of minimum base */
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x1000
comma
id|size
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
id|alignto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|7
op_star
l_int|16
op_star
id|MB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: slot %d, function %d&quot;
l_string|&quot; requests 0x%x bytes of contiguous&quot;
l_string|&quot; address space---don&squot;t use sparse&quot;
l_string|&quot; memory accesses on this device!!&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
(paren
id|base
op_div
(paren
l_int|16
op_star
id|MB
)paren
)paren
op_amp
l_int|0x7
)paren
op_eq
l_int|0
)paren
(brace
id|base
op_and_assign
op_complement
(paren
l_int|128
op_star
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|base
op_add_assign
l_int|16
op_star
id|MB
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|base
comma
id|alignto
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_div
(paren
l_int|128
op_star
id|MB
)paren
op_ne
(paren
id|base
op_plus
id|size
)paren
op_div
(paren
l_int|128
op_star
id|MB
)paren
)paren
(brace
id|base
op_and_assign
op_complement
(paren
l_int|128
op_star
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|base
op_add_assign
(paren
l_int|128
op_plus
l_int|16
)paren
op_star
id|MB
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|base
comma
id|alignto
)paren
suffix:semicolon
)brace
)brace
id|mem_base
op_assign
id|base
op_plus
id|size
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
id|base
)paren
suffix:semicolon
id|dev-&gt;base_address
(braket
(paren
id|reg
op_minus
id|PCI_BASE_ADDRESS_0
)paren
op_rshift
l_int|2
)braket
op_assign
id|base
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: dev 0x%x MEM @ 0x%x (0x%x)&bslash;n&quot;
comma
id|dev-&gt;device
comma
id|base
comma
id|size
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Enable device: */
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_STORAGE_IDE
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
multiline_comment|/*&n;&t;&t; * All of these (may) have I/O scattered all around&n;&t;&t; * and may not use i/o-base address registers at all.&n;&t;&t; * So we just have to always enable I/O to these&n;&t;&t; * devices.&n;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
)brace
id|pcibios_write_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|cmd
op_or
id|PCI_COMMAND_MASTER
)paren
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: bus %d slot %d VID 0x%x DID 0x%x&quot;
l_string|&quot; class 0x%x cmd 0 x%x&bslash;n&quot;
comma
id|bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|dev
op_member_access_from_pointer
r_class
comma
id|cmd
op_or
id|PCI_COMMAND_MASTER
)paren
)paren
suffix:semicolon
)brace
DECL|function|layout_bus
r_static
r_void
id|layout_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_int
r_int
id|l
comma
id|tio
comma
id|bio
comma
id|tmem
comma
id|bmem
suffix:semicolon
r_struct
id|pci_bus
op_star
id|child
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus-&gt;devices
op_logical_and
op_logical_neg
id|bus-&gt;children
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Align the current bases on appropriate boundaries (4K for&n;&t; * IO and 1MB for memory).&n;&t; */
id|bio
op_assign
id|io_base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
l_int|4
op_star
id|KB
)paren
suffix:semicolon
id|bmem
op_assign
id|mem_base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
l_int|1
op_star
id|MB
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There are times when the PCI devices have already been&n;&t; * setup (e.g., by MILO or SRM).  In these cases there is a&n;&t; * window during which two devices may have an overlapping&n;&t; * address range.  To avoid this causing trouble, we first&n;&t; * turn off the I/O and memory address decoders for all PCI&n;&t; * devices.  They&squot;ll be re-enabled only once all address&n;&t; * decoders are programmed consistently.&n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|bus-&gt;devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_BRIDGE_PCMCIA
)paren
)paren
(brace
id|disable_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allocate space to each device:&n;&t; */
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d devices&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|bus-&gt;devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_BRIDGE_PCMCIA
)paren
)paren
(brace
id|layout_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Recursively allocate space for all of the sub-buses:&n;&t; */
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d children&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|child
op_assign
id|bus-&gt;children
suffix:semicolon
id|child
suffix:semicolon
id|child
op_assign
id|child-&gt;next
)paren
(brace
id|layout_bus
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Align the current bases on 4K and 1MB boundaries:&n;&t; */
id|tio
op_assign
id|io_base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
l_int|4
op_star
id|KB
)paren
suffix:semicolon
id|tmem
op_assign
id|mem_base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
l_int|1
op_star
id|MB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
r_struct
id|pci_dev
op_star
id|bridge
op_assign
id|bus-&gt;self
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up the top and bottom of the PCI I/O segment&n;&t;&t; * for this bus.&n;&t;&t; */
id|pcibios_read_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x1c
comma
op_amp
id|l
)paren
suffix:semicolon
id|l
op_and_assign
l_int|0xffff0000
suffix:semicolon
id|l
op_or_assign
(paren
(paren
id|bio
op_rshift
l_int|8
)paren
op_amp
l_int|0x00f0
)paren
op_or
(paren
(paren
id|tio
op_minus
l_int|1
)paren
op_amp
l_int|0xf000
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x1c
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up the top and bottom of the  PCI Memory segment&n;&t;&t; * for this bus.&n;&t;&t; */
id|l
op_assign
(paren
(paren
id|bmem
op_amp
l_int|0xfff00000
)paren
op_rshift
l_int|16
)paren
op_or
(paren
(paren
id|tmem
op_minus
l_int|1
)paren
op_amp
l_int|0xfff00000
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x20
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Turn off downstream PF memory address range:&n;&t;&t; */
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x24
comma
l_int|0x0000ffff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Tell bridge that there is an ISA bus in the system:&n;&t;&t; */
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x3c
comma
l_int|0x00040000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear status bits, enable I/O (for downstream I/O),&n;&t;&t; * turn on master enable (for upstream I/O), turn on&n;&t;&t; * memory enable (for downstream memory), turn on&n;&t;&t; * master enable (for upstream memory and I/O).&n;&t;&t; */
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x4
comma
l_int|0xffff0007
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* !PCI_MODIFY */
multiline_comment|/*&n; * Given the vendor and device ids, find the n&squot;th instance of that device&n; * in the system.  &n; */
DECL|function|pcibios_find_device
r_int
id|pcibios_find_device
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|device_id
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|bus
comma
r_int
r_char
op_star
id|devfn
)paren
(brace
r_int
r_int
id|curr
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|vendor
op_logical_and
id|dev-&gt;device
op_eq
id|device_id
)paren
(brace
r_if
c_cond
(paren
id|curr
op_eq
id|index
)paren
(brace
op_star
id|devfn
op_assign
id|dev-&gt;devfn
suffix:semicolon
op_star
id|bus
op_assign
id|dev-&gt;bus-&gt;number
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
op_increment
id|curr
suffix:semicolon
)brace
)brace
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
multiline_comment|/*&n; * Given the class, find the n&squot;th instance of that device&n; * in the system.&n; */
DECL|function|pcibios_find_class
r_int
id|pcibios_find_class
(paren
r_int
r_int
id|class_code
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|bus
comma
r_int
r_char
op_star
id|devfn
)paren
(brace
r_int
r_int
id|curr
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_eq
id|class_code
)paren
(brace
r_if
c_cond
(paren
id|curr
op_eq
id|index
)paren
(brace
op_star
id|devfn
op_assign
id|dev-&gt;devfn
suffix:semicolon
op_star
id|bus
op_assign
id|dev-&gt;bus-&gt;number
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
op_increment
id|curr
suffix:semicolon
)brace
)brace
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
DECL|function|pcibios_present
r_int
id|pcibios_present
c_func
(paren
r_void
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pcibios_init
r_int
r_int
id|pcibios_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Alpha PCI BIOS32 revision %x.%02x&bslash;n&quot;
comma
id|MAJOR_REV
comma
id|MINOR_REV
)paren
suffix:semicolon
macro_line|#if !PCI_MODIFY
id|printk
c_func
(paren
l_string|&quot;...NOT modifying existing (SRM) PCI configuration&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * The SRM console *disables* the IDE interface, this code ensures it&squot;s&n; * enabled.&n; *&n; * This code bangs on a control register of the 87312 Super I/O chip&n; * that implements parallel port/serial ports/IDE/FDI.  Depending on&n; * the motherboard, the Super I/O chip can be configured through a&n; * pair of registers that are located either at I/O ports 0x26e/0x26f&n; * or 0x398/0x399.  Unfortunately, autodetecting which base address is&n; * in use works only once (right after a reset).  The Super I/O chip&n; * has the additional quirk that configuration register data must be&n; * written twice (I believe this is a safety feature to prevent&n; * accidental modification---fun, isn&squot;t it?).&n; */
DECL|function|enable_ide
r_static
r_inline
r_void
id|enable_ide
c_func
(paren
r_int
id|ide_base
)paren
(brace
r_int
id|data
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ide_base
)paren
suffix:semicolon
multiline_comment|/* set the index register for reg #0 */
id|data
op_assign
id|inb
c_func
(paren
id|ide_base
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* read the current contents */
id|outb
c_func
(paren
l_int|0
comma
id|ide_base
)paren
suffix:semicolon
multiline_comment|/* set the index register for reg #0 */
id|outb
c_func
(paren
id|data
op_or
l_int|0x40
comma
id|ide_base
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* turn on IDE */
id|outb
c_func
(paren
id|data
op_or
l_int|0x40
comma
id|ide_base
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* turn on IDE, really! */
)brace
multiline_comment|/* &n; * A small note about bridges and interrupts.    The DECchip 21050 (and later)&n; * adheres to the PCI-PCI bridge specification.   This says that the&n; * interrupts on the other side of a bridge are swizzled in the following&n; * manner:&n; *&n; * Dev    Interrupt   Interrupt &n; *        Pin on      Pin on &n; *        Device      Connector&n; *&n; *   4    A           A&n; *        B           B&n; *        C           C&n; *        D           D&n; * &n; *   5    A           B&n; *        B           C&n; *        C           D&n; *        D           A&n; *&n; *   6    A           C&n; *        B           D&n; *        C           A&n; *        D           B&n; *&n; *   7    A           D&n; *        B           A&n; *        C           B&n; *        D           C&n; *&n; *   Where A = pin 1, B = pin 2 and so on and pin=0 = default = A.&n; *   Thus, each swizzle is ((pin-1) + (device#-4)) % 4&n; *&n; *   The following code is somewhat simplistic as it assumes only one bridge.&n; *   I will fix it later (david.rusling@reo.mts.dec.com).&n; */
r_static
r_inline
r_int
r_char
DECL|function|bridge_swizzle
id|bridge_swizzle
c_func
(paren
r_int
r_char
id|pin
comma
r_int
r_int
id|slot
)paren
(brace
multiline_comment|/* swizzle */
r_return
(paren
(paren
(paren
id|pin
op_minus
l_int|1
)paren
op_plus
id|slot
)paren
op_mod
l_int|4
)paren
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Most evaluation boards share most of the fixup code, which is isolated&n; * here.  This function is declared &quot;inline&quot; as only one platform will ever&n; * be selected in any given kernel.  If that platform doesn&squot;t need this code,&n; * we don&squot;t want it around as dead code.&n; */
r_static
r_inline
r_void
DECL|function|common_fixup
id|common_fixup
c_func
(paren
r_int
id|min_idsel
comma
r_int
id|max_idsel
comma
r_int
id|irqs_per_slot
comma
r_char
id|irq_tab
(braket
id|max_idsel
op_minus
id|min_idsel
op_plus
l_int|1
)braket
(braket
id|irqs_per_slot
)braket
comma
r_int
id|ide_base
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_int
r_char
id|pin
suffix:semicolon
r_int
r_char
id|slot
suffix:semicolon
multiline_comment|/*&n;&t; * Go through all devices, fixing up irqs as we see fit:&n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
multiline_comment|/* PCEB (PCI to EISA bridge) does not identify&n;&t;&t;        itself as a bridge... :-P */
op_logical_and
op_logical_neg
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_INTEL_82375
)paren
)paren
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_BRIDGE_PCMCIA
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This device is not on the primary bus, we need&n;&t;&t;&t; * to figure out which interrupt pin it will come&n;&t;&t;&t; * in on.   We know which slot it will come in on&n;&t;&t;&t; * &squot;cos that slot is where the bridge is.   Each&n;&t;&t;&t; * time the interrupt line passes through a PCI-PCI&n;&t;&t;&t; * bridge we must apply the swizzle function (see&n;&t;&t;&t; * the inline static routine above).&n;&t;&t;&t; */
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;number
op_ne
l_int|0
)paren
(brace
r_struct
id|pci_dev
op_star
id|curr
op_assign
id|dev
suffix:semicolon
multiline_comment|/* read the pin and do the PCI-PCI bridge&n;&t;&t;&t;&t;   interrupt pin swizzle */
id|pcibios_read_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin
)paren
suffix:semicolon
multiline_comment|/* cope with 0 */
r_if
c_cond
(paren
id|pin
op_eq
l_int|0
)paren
id|pin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* follow the chain of bridges, swizzling&n;&t;&t;&t;&t;   as we go */
macro_line|#if defined(CONFIG_ALPHA_MIATA)
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
op_plus
l_int|5
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;MIATA: bus 1 slot %d pin %d&quot;
l_string|&quot; irq %d min_idsel %d&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|pin
comma
id|irq_tab
(braket
id|slot
op_minus
id|min_idsel
)braket
(braket
id|pin
)braket
comma
id|min_idsel
)paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_NORITAKE)
multiline_comment|/* WAG Alert! */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
op_plus
l_int|14
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;NORITAKE: bus 1 slot %d pin %d&quot;
l_string|&quot; irq %d min_idsel %d&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|pin
comma
id|irq_tab
(braket
id|slot
op_minus
id|min_idsel
)braket
(braket
id|pin
)braket
comma
id|min_idsel
)paren
)paren
suffix:semicolon
macro_line|#else
r_do
(brace
multiline_comment|/* swizzle */
id|pin
op_assign
id|bridge_swizzle
c_func
(paren
id|pin
comma
id|PCI_SLOT
c_func
(paren
id|curr-&gt;devfn
)paren
)paren
suffix:semicolon
multiline_comment|/* move up the chain of bridges */
id|curr
op_assign
id|curr-&gt;bus-&gt;self
suffix:semicolon
)brace
r_while
c_loop
(paren
id|curr-&gt;bus-&gt;self
)paren
suffix:semicolon
multiline_comment|/* The slot is the slot of the last bridge. */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|curr-&gt;devfn
)paren
suffix:semicolon
macro_line|#endif /* MIATA */
)brace
r_else
(brace
multiline_comment|/* work out the slot */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
suffix:semicolon
multiline_comment|/* read the pin */
id|pcibios_read_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_tab
(braket
id|slot
op_minus
id|min_idsel
)braket
(braket
id|pin
)braket
op_ne
op_minus
l_int|1
)paren
id|dev-&gt;irq
op_assign
id|irq_tab
(braket
id|slot
op_minus
id|min_idsel
)braket
(braket
id|pin
)braket
suffix:semicolon
macro_line|#if PCI_MODIFY
multiline_comment|/* tell the device: */
id|pcibios_write_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_LINE
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;common_fixup: bus %d slot 0x%x&quot;
l_string|&quot; VID 0x%x DID 0x%x&bslash;n&quot;
l_string|&quot;              int_slot 0x%x pin 0x%x&quot;
l_string|&quot; pirq 0x%x&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|slot
comma
id|pin
comma
id|dev-&gt;irq
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * if it&squot;s a VGA, enable its BIOS ROM at C0000&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_DISPLAY_VGA
)paren
(brace
id|pcibios_write_config_dword
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_ROM_ADDRESS
comma
l_int|0x000c0000
op_or
id|PCI_ROM_ADDRESS_ENABLE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * if it&squot;s a SCSI, disable its BIOS ROM&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_SCSI
)paren
(brace
id|pcibios_write_config_dword
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_ROM_ADDRESS
comma
l_int|0x0000000
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ide_base
)paren
(brace
id|enable_ide
c_func
(paren
id|ide_base
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The EB66+ is very similar to the EB66 except that it does not have&n; * the on-board NCR and Tulip chips.  In the code below, I have used&n; * slot number to refer to the id select line and *not* the slot&n; * number used in the EB66+ documentation.  However, in the table,&n; * I&squot;ve given the slot number, the id select line and the Jxx number&n; * that&squot;s printed on the board.  The interrupt pins from the PCI slots&n; * are wired into 3 interrupt summary registers at 0x804, 0x805 and&n; * 0x806 ISA.&n; *&n; * In the table, -1 means don&squot;t assign an IRQ number.  This is usually&n; * because it is the Saturn IO (SIO) PCI/ISA Bridge Chip.&n; */
DECL|function|eb66p_fixup
r_static
r_inline
r_void
id|eb66p_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|5
)braket
(braket
l_int|5
)braket
op_assign
(brace
(brace
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|9
comma
l_int|16
op_plus
l_int|13
)brace
comma
multiline_comment|/* IdSel 6,  slot 0, J25 */
(brace
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|14
)brace
comma
multiline_comment|/* IdSel 7,  slot 1, J26 */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 8,  SIO         */
(brace
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|7
comma
l_int|16
op_plus
l_int|11
comma
l_int|16
op_plus
l_int|15
)brace
comma
multiline_comment|/* IdSel 9,  slot 2, J27 */
(brace
l_int|16
op_plus
l_int|3
comma
l_int|16
op_plus
l_int|3
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|6
)brace
multiline_comment|/* IdSel 10, slot 3, J28 */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|6
comma
l_int|10
comma
l_int|5
comma
id|irq_tab
comma
l_int|0x398
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The PC164 has 19 PCI interrupts, four from each of the four PCI&n; * slots, the SIO, PCI/IDE, and USB.&n; * &n; * Each of the interrupts can be individually masked. This is&n; * accomplished by setting the appropriate bit in the mask register.&n; * A bit is set by writing a &quot;1&quot; to the desired position in the mask&n; * register and cleared by writing a &quot;0&quot;. There are 3 mask registers&n; * located at ISA address 804h, 805h and 806h.&n; * &n; * An I/O read at ISA address 804h, 805h, 806h will return the&n; * state of the 11 PCI interrupts and not the state of the MASKED&n; * interrupts.&n; * &n; * Note: A write to I/O 804h, 805h, and 806h the mask register will be&n; * updated.&n; * &n; * &n; * &t;&t;&t;&t;ISA DATA&lt;7:0&gt;&n; * ISA     +--------------------------------------------------------------+&n; * ADDRESS |   7   |   6   |   5   |   4   |   3   |   2  |   1   |   0   |&n; *         +==============================================================+&n; * 0x804   | INTB0 |  USB  |  IDE  |  SIO  | INTA3 |INTA2 | INTA1 | INTA0 |&n; *         +--------------------------------------------------------------+&n; * 0x805   | INTD0 | INTC3 | INTC2 | INTC1 | INTC0 |INTB3 | INTB2 | INTB1 |&n; *         +--------------------------------------------------------------+&n; * 0x806   | Rsrv  | Rsrv  | Rsrv  | Rsrv  | Rsrv  |INTD3 | INTD2 | INTD1 |&n; *         +--------------------------------------------------------------+&n; *         * Rsrv = reserved bits&n; *         Note: The mask register is write-only.&n; * &n; * IdSel&t;&n; *   5&t; 32 bit PCI option slot 2&n; *   6&t; 64 bit PCI option slot 0&n; *   7&t; 64 bit PCI option slot 1&n; *   8&t; Saturn I/O&n; *   9&t; 32 bit PCI option slot 3&n; *  10&t; USB&n; *  11&t; IDE&n; * &n; */
macro_line|#ifdef CONFIG_ALPHA_PC164
DECL|function|alphapc164_fixup
r_static
r_inline
r_void
id|alphapc164_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|7
)braket
(braket
l_int|5
)braket
op_assign
(brace
multiline_comment|/*INT   INTA  INTB   INTC   INTD */
(brace
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|9
comma
l_int|16
op_plus
l_int|13
comma
l_int|16
op_plus
l_int|17
)brace
comma
multiline_comment|/* IdSel  5, slot 2, J20 */
(brace
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|7
comma
l_int|16
op_plus
l_int|11
comma
l_int|16
op_plus
l_int|15
)brace
comma
multiline_comment|/* IdSel  6, slot 0, J29 */
(brace
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|16
)brace
comma
multiline_comment|/* IdSel  7, slot 1, J26 */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel  8, SIO */
(brace
l_int|16
op_plus
l_int|3
comma
l_int|16
op_plus
l_int|3
comma
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|14
comma
l_int|16
op_plus
l_int|18
)brace
comma
multiline_comment|/* IdSel  9, slot 3, J19 */
(brace
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
)brace
comma
multiline_comment|/* IdSel 10, USB */
(brace
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|5
)brace
multiline_comment|/* IdSel 11, IDE */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|5
comma
l_int|11
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
id|SMCInit
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * The AlphaPC64 is very similar to the EB66+ except that its slots&n; * are numbered differently.  In the code below, I have used slot&n; * number to refer to the id select line and *not* the slot number&n; * used in the AlphaPC64 documentation.  However, in the table, I&squot;ve&n; * given the slot number, the id select line and the Jxx number that&squot;s&n; * printed on the board.  The interrupt pins from the PCI slots are&n; * wired into 3 interrupt summary registers at 0x804, 0x805 and 0x806&n; * ISA.&n; *&n; * In the table, -1 means don&squot;t assign an IRQ number.  This is usually&n; * because it is the Saturn IO (SIO) PCI/ISA Bridge Chip.&n; */
DECL|function|cabriolet_fixup
r_static
r_inline
r_void
id|cabriolet_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|5
)braket
(braket
l_int|5
)braket
op_assign
(brace
(brace
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|7
comma
l_int|16
op_plus
l_int|11
comma
l_int|16
op_plus
l_int|15
)brace
comma
multiline_comment|/* IdSel 5,  slot 2, J21 */
(brace
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|9
comma
l_int|16
op_plus
l_int|13
)brace
comma
multiline_comment|/* IdSel 6,  slot 0, J19 */
(brace
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|14
)brace
comma
multiline_comment|/* IdSel 7,  slot 1, J20 */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 8,  SIO         */
(brace
l_int|16
op_plus
l_int|3
comma
l_int|16
op_plus
l_int|3
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|16
)brace
multiline_comment|/* IdSel 9,  slot 3, J22 */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|5
comma
l_int|9
comma
l_int|5
comma
id|irq_tab
comma
l_int|0x398
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup configuration for EB66/EB64+ boards.&n; *&n; * Both these boards use the same interrupt summary scheme.  There are&n; * two 8 bit external summary registers as follows:&n; *&n; * Summary @ 0x26:&n; * Bit      Meaning&n; * 0        Interrupt Line A from slot 0&n; * 1        Interrupt Line A from slot 1&n; * 2        Interrupt Line B from slot 0&n; * 3        Interrupt Line B from slot 1&n; * 4        Interrupt Line C from slot 0&n; * 5        Interrupt line from the two ISA PICs&n; * 6        Tulip (slot &n; * 7        NCR SCSI&n; *&n; * Summary @ 0x27&n; * Bit      Meaning&n; * 0        Interrupt Line C from slot 1&n; * 1        Interrupt Line D from slot 0&n; * 2        Interrupt Line D from slot 1&n; * 3        RAZ&n; * 4        RAZ&n; * 5        RAZ&n; * 6        RAZ&n; * 7        RAZ&n; *&n; * The device to slot mapping looks like:&n; *&n; * Slot     Device&n; *  5       NCR SCSI controller&n; *  6       PCI on board slot 0&n; *  7       PCI on board slot 1&n; *  8       Intel SIO PCI-ISA bridge chip&n; *  9       Tulip - DECchip 21040 ethernet controller&n; *   &n; *&n; * This two layered interrupt approach means that we allocate IRQ 16 and &n; * above for PCI interrupts.  The IRQ relates to which bit the interrupt&n; * comes in on.  This makes interrupt processing much easier.&n; */
DECL|function|eb66_and_eb64p_fixup
r_static
r_inline
r_void
id|eb66_and_eb64p_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|5
)braket
(braket
l_int|5
)braket
op_assign
(brace
(brace
l_int|16
op_plus
l_int|7
comma
l_int|16
op_plus
l_int|7
comma
l_int|16
op_plus
l_int|7
comma
l_int|16
op_plus
l_int|7
comma
l_int|16
op_plus
l_int|7
)brace
comma
multiline_comment|/* IdSel 5,  slot ?, ?? */
(brace
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|9
)brace
comma
multiline_comment|/* IdSel 6,  slot ?, ?? */
(brace
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|3
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|10
)brace
comma
multiline_comment|/* IdSel 7,  slot ?, ?? */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 8,  SIO */
(brace
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
)brace
comma
multiline_comment|/* IdSel 9,  TULIP */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|5
comma
l_int|9
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup configuration for MIKASA (NORITAKE is different)&n; *&n; * Summary @ 0x536:&n; * Bit      Meaning&n; * 0        Interrupt Line A from slot 0&n; * 1        Interrupt Line B from slot 0&n; * 2        Interrupt Line C from slot 0&n; * 3        Interrupt Line D from slot 0&n; * 4        Interrupt Line A from slot 1&n; * 5        Interrupt line B from slot 1&n; * 6        Interrupt Line C from slot 1&n; * 7        Interrupt Line D from slot 1&n; * 8        Interrupt Line A from slot 2&n; * 9        Interrupt Line B from slot 2&n; *10        Interrupt Line C from slot 2&n; *11        Interrupt Line D from slot 2&n; *12        NCR 810 SCSI&n; *13        Power Supply Fail&n; *14        Temperature Warn&n; *15        Reserved&n; *&n; * The device to slot mapping looks like:&n; *&n; * Slot     Device&n; *  6       NCR SCSI controller&n; *  7       Intel PCI-EISA bridge chip&n; * 11       PCI on board slot 0&n; * 12       PCI on board slot 1&n; * 13       PCI on board slot 2&n; *   &n; *&n; * This two layered interrupt approach means that we allocate IRQ 16 and &n; * above for PCI interrupts.  The IRQ relates to which bit the interrupt&n; * comes in on.  This makes interrupt processing much easier.&n; */
DECL|function|mikasa_fixup
r_static
r_inline
r_void
id|mikasa_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|8
)braket
(braket
l_int|5
)braket
op_assign
(brace
multiline_comment|/*INT    INTA   INTB   INTC   INTD */
(brace
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
)brace
comma
multiline_comment|/* IdSel 17,  SCSI */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 18,  PCEB */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 19,  ???? */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 20,  ???? */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 21,  ???? */
(brace
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|3
)brace
comma
multiline_comment|/* IdSel 22,  slot 0 */
(brace
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|7
)brace
comma
multiline_comment|/* IdSel 23,  slot 1 */
(brace
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|9
comma
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|11
)brace
comma
multiline_comment|/* IdSel 24,  slot 2 */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|6
comma
l_int|13
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup configuration for NORITAKE (MIKASA is different)&n; *&n; * Summary @ 0x542, summary register #1:&n; * Bit      Meaning&n; * 0        All valid ints from summary regs 2 &amp; 3&n; * 1        QLOGIC ISP1020A SCSI&n; * 2        Interrupt Line A from slot 0&n; * 3        Interrupt Line B from slot 0&n; * 4        Interrupt Line A from slot 1&n; * 5        Interrupt line B from slot 1&n; * 6        Interrupt Line A from slot 2&n; * 7        Interrupt Line B from slot 2&n; * 8        Interrupt Line A from slot 3&n; * 9        Interrupt Line B from slot 3&n; *10        Interrupt Line A from slot 4&n; *11        Interrupt Line B from slot 4&n; *12        Interrupt Line A from slot 5&n; *13        Interrupt Line B from slot 5&n; *14        Interrupt Line A from slot 6&n; *15        Interrupt Line B from slot 6&n; *&n; * Summary @ 0x544, summary register #2:&n; * Bit      Meaning&n; * 0        OR of all unmasked ints in SR #2&n; * 1        OR of secondary bus ints&n; * 2        Interrupt Line C from slot 0&n; * 3        Interrupt Line D from slot 0&n; * 4        Interrupt Line C from slot 1&n; * 5        Interrupt line D from slot 1&n; * 6        Interrupt Line C from slot 2&n; * 7        Interrupt Line D from slot 2&n; * 8        Interrupt Line C from slot 3&n; * 9        Interrupt Line D from slot 3&n; *10        Interrupt Line C from slot 4&n; *11        Interrupt Line D from slot 4&n; *12        Interrupt Line C from slot 5&n; *13        Interrupt Line D from slot 5&n; *14        Interrupt Line C from slot 6&n; *15        Interrupt Line D from slot 6&n; *&n; * The device to slot mapping looks like:&n; *&n; * Slot     Device&n; *  7       Intel PCI-EISA bridge chip&n; *  8       DEC PCI-PCI bridge chip&n; * 11       PCI on board slot 0&n; * 12       PCI on board slot 1&n; * 13       PCI on board slot 2&n; *   &n; *&n; * This two layered interrupt approach means that we allocate IRQ 16 and &n; * above for PCI interrupts.  The IRQ relates to which bit the interrupt&n; * comes in on.  This makes interrupt processing much easier.&n; */
DECL|function|noritake_fixup
r_static
r_inline
r_void
id|noritake_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|13
)braket
(braket
l_int|5
)braket
op_assign
(brace
multiline_comment|/*INT    INTA   INTB   INTC   INTD */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 18,  PCEB */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 19,  PPB  */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 20,  ???? */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 21,  ???? */
(brace
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|3
comma
l_int|32
op_plus
l_int|2
comma
l_int|32
op_plus
l_int|3
)brace
comma
multiline_comment|/* IdSel 22,  slot 0 */
(brace
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|5
comma
l_int|32
op_plus
l_int|4
comma
l_int|32
op_plus
l_int|5
)brace
comma
multiline_comment|/* IdSel 23,  slot 1 */
(brace
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|7
comma
l_int|32
op_plus
l_int|6
comma
l_int|32
op_plus
l_int|7
)brace
comma
multiline_comment|/* IdSel 24,  slot 2 */
multiline_comment|/* The following are actually on bus 1, across the bridge */
(brace
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|1
)brace
comma
multiline_comment|/* IdSel 16,  QLOGIC */
(brace
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|9
comma
l_int|32
op_plus
l_int|8
comma
l_int|32
op_plus
l_int|9
)brace
comma
multiline_comment|/* IdSel 17,  slot 3 */
(brace
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|11
comma
l_int|32
op_plus
l_int|10
comma
l_int|32
op_plus
l_int|11
)brace
comma
multiline_comment|/* IdSel 18,  slot 4 */
(brace
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|13
comma
l_int|32
op_plus
l_int|12
comma
l_int|32
op_plus
l_int|13
)brace
comma
multiline_comment|/* IdSel 19,  slot 5 */
(brace
l_int|16
op_plus
l_int|14
comma
l_int|16
op_plus
l_int|14
comma
l_int|16
op_plus
l_int|15
comma
l_int|32
op_plus
l_int|14
comma
l_int|32
op_plus
l_int|15
)brace
comma
multiline_comment|/* IdSel 20,  slot 6 */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|7
comma
l_int|18
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup configuration for ALCOR&n; *&n; * Summary @ GRU_INT_REQ:&n; * Bit      Meaning&n; * 0        Interrupt Line A from slot 2&n; * 1        Interrupt Line B from slot 2&n; * 2        Interrupt Line C from slot 2&n; * 3        Interrupt Line D from slot 2&n; * 4        Interrupt Line A from slot 1&n; * 5        Interrupt line B from slot 1&n; * 6        Interrupt Line C from slot 1&n; * 7        Interrupt Line D from slot 1&n; * 8        Interrupt Line A from slot 0&n; * 9        Interrupt Line B from slot 0&n; *10        Interrupt Line C from slot 0&n; *11        Interrupt Line D from slot 0&n; *12        Interrupt Line A from slot 4&n; *13        Interrupt Line B from slot 4&n; *14        Interrupt Line C from slot 4&n; *15        Interrupt Line D from slot 4&n; *16        Interrupt Line D from slot 3&n; *17        Interrupt Line D from slot 3&n; *18        Interrupt Line D from slot 3&n; *19        Interrupt Line D from slot 3&n; *20-30     Reserved&n; *31        EISA interrupt&n; *&n; * The device to slot mapping looks like:&n; *&n; * Slot     Device&n; *  7       PCI on board slot 0&n; *  8       PCI on board slot 3&n; *  9       PCI on board slot 4&n; * 10       PCEB (PCI-EISA bridge)&n; * 11       PCI on board slot 2&n; * 12       PCI on board slot 1&n; *   &n; *&n; * This two layered interrupt approach means that we allocate IRQ 16 and &n; * above for PCI interrupts.  The IRQ relates to which bit the interrupt&n; * comes in on.  This makes interrupt processing much easier.&n; */
DECL|function|alcor_fixup
r_static
r_inline
r_void
id|alcor_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|6
)braket
(braket
l_int|5
)braket
op_assign
(brace
multiline_comment|/*INT    INTA   INTB   INTC   INTD */
(brace
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|9
comma
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|11
)brace
comma
multiline_comment|/* IdSel 18,  slot 0 */
(brace
l_int|16
op_plus
l_int|16
comma
l_int|16
op_plus
l_int|16
comma
l_int|16
op_plus
l_int|17
comma
l_int|16
op_plus
l_int|18
comma
l_int|16
op_plus
l_int|19
)brace
comma
multiline_comment|/* IdSel 19,  slot 3 */
(brace
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|13
comma
l_int|16
op_plus
l_int|14
comma
l_int|16
op_plus
l_int|15
)brace
comma
multiline_comment|/* IdSel 20,  slot 4 */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 21,  PCEB   */
(brace
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|3
)brace
comma
multiline_comment|/* IdSel 22,  slot 2 */
(brace
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|7
)brace
comma
multiline_comment|/* IdSel 23,  slot 1 */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|7
comma
l_int|12
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup configuration for ALPHA XLT (EV5/EV56)&n; *&n; * Summary @ GRU_INT_REQ:&n; * Bit      Meaning&n; * 0        Interrupt Line A from slot 2&n; * 1        Interrupt Line B from slot 2&n; * 2        Interrupt Line C from slot 2&n; * 3        Interrupt Line D from slot 2&n; * 4        Interrupt Line A from slot 1&n; * 5        Interrupt line B from slot 1&n; * 6        Interrupt Line C from slot 1&n; * 7        Interrupt Line D from slot 1&n; * 8        Interrupt Line A from slot 0&n; * 9        Interrupt Line B from slot 0&n; *10        Interrupt Line C from slot 0&n; *11        Interrupt Line D from slot 0&n; *12        NCR810 SCSI in slot 9&n; *13        DC-21040 (TULIP) in slot 6&n; *14-19     Reserved&n; *20-23     Jumpers (interrupt)&n; *24-27     Module revision&n; *28-30     Reserved&n; *31        EISA interrupt&n; *&n; * The device to slot mapping looks like:&n; *&n; * Slot     Device&n; *  6       TULIP&n; *  7       PCI on board slot 0&n; *  8       none&n; *  9       SCSI&n; * 10       PCI-ISA bridge&n; * 11       PCI on board slot 2&n; * 12       PCI on board slot 1&n; *   &n; *&n; * This two layered interrupt approach means that we allocate IRQ 16 and &n; * above for PCI interrupts.  The IRQ relates to which bit the interrupt&n; * comes in on.  This makes interrupt processing much easier.&n; */
DECL|function|xlt_fixup
r_static
r_inline
r_void
id|xlt_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|7
)braket
(braket
l_int|5
)braket
op_assign
(brace
multiline_comment|/*INT    INTA   INTB   INTC   INTD */
(brace
l_int|16
op_plus
l_int|13
comma
l_int|16
op_plus
l_int|13
comma
l_int|16
op_plus
l_int|13
comma
l_int|16
op_plus
l_int|13
comma
l_int|16
op_plus
l_int|13
)brace
comma
multiline_comment|/* IdSel 17,  TULIP  */
(brace
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|9
comma
l_int|16
op_plus
l_int|10
comma
l_int|16
op_plus
l_int|11
)brace
comma
multiline_comment|/* IdSel 18,  slot 0 */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 19,  none   */
(brace
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
)brace
comma
multiline_comment|/* IdSel 20,  SCSI   */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 21,  SIO    */
(brace
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|0
comma
l_int|16
op_plus
l_int|1
comma
l_int|16
op_plus
l_int|2
comma
l_int|16
op_plus
l_int|3
)brace
comma
multiline_comment|/* IdSel 22,  slot 2 */
(brace
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|4
comma
l_int|16
op_plus
l_int|5
comma
l_int|16
op_plus
l_int|6
comma
l_int|16
op_plus
l_int|7
)brace
comma
multiline_comment|/* IdSel 23,  slot 1 */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|6
comma
l_int|12
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup configuration for ALPHA SABLE (2100) - 2100A is different ??&n; *&n; * Summary Registers (536/53a/53c):&n; * Bit      Meaning&n; *-----------------&n; * 0        PCI slot 0&n; * 1        NCR810 (builtin)&n; * 2        TULIP (builtin)&n; * 3        mouse&n; * 4        PCI slot 1&n; * 5        PCI slot 2&n; * 6        keyboard&n; * 7        floppy&n; * 8        COM2&n; * 9        parallel port&n; *10        EISA irq 3&n; *11        EISA irq 4&n; *12        EISA irq 5&n; *13        EISA irq 6&n; *14        EISA irq 7&n; *15        COM1&n; *16        EISA irq 9&n; *17        EISA irq 10&n; *18        EISA irq 11&n; *19        EISA irq 12&n; *20        EISA irq 13&n; *21        EISA irq 14&n; *22        NC&n; *23        IIC&n; *&n; * The device to slot mapping looks like:&n; *&n; * Slot     Device&n; *  0       TULIP&n; *  1       SCSI&n; *  2       PCI-EISA bridge&n; *  3       none&n; *  4       none&n; *  5       none&n; *  6       PCI on board slot 0&n; *  7       PCI on board slot 1&n; *  8       PCI on board slot 2&n; *   &n; *&n; * This two layered interrupt approach means that we allocate IRQ 16 and &n; * above for PCI interrupts.  The IRQ relates to which bit the interrupt&n; * comes in on.  This makes interrupt processing much easier.&n; */
multiline_comment|/* NOTE: the IRQ assignments below are arbitrary, but need to be consistent&n;   with the values in the sable_irq_to_mask[] and sable_mask_to_irq[] tables&n;   in irq.c&n; */
DECL|function|sable_fixup
r_static
r_inline
r_void
id|sable_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|9
)braket
(braket
l_int|5
)braket
op_assign
(brace
multiline_comment|/*INT    INTA   INTB   INTC   INTD */
(brace
l_int|32
op_plus
l_int|0
comma
l_int|32
op_plus
l_int|0
comma
l_int|32
op_plus
l_int|0
comma
l_int|32
op_plus
l_int|0
comma
l_int|32
op_plus
l_int|0
)brace
comma
multiline_comment|/* IdSel 0,  TULIP  */
(brace
l_int|32
op_plus
l_int|1
comma
l_int|32
op_plus
l_int|1
comma
l_int|32
op_plus
l_int|1
comma
l_int|32
op_plus
l_int|1
comma
l_int|32
op_plus
l_int|1
)brace
comma
multiline_comment|/* IdSel 1,  SCSI   */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 2,  SIO   */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 3,  none   */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 4,  none   */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 5,  none   */
(brace
l_int|32
op_plus
l_int|2
comma
l_int|32
op_plus
l_int|2
comma
l_int|32
op_plus
l_int|2
comma
l_int|32
op_plus
l_int|2
comma
l_int|32
op_plus
l_int|2
)brace
comma
multiline_comment|/* IdSel 6,  slot 0 */
(brace
l_int|32
op_plus
l_int|3
comma
l_int|32
op_plus
l_int|3
comma
l_int|32
op_plus
l_int|3
comma
l_int|32
op_plus
l_int|3
comma
l_int|32
op_plus
l_int|3
)brace
comma
multiline_comment|/* IdSel 7,  slot 1 */
(brace
l_int|32
op_plus
l_int|4
comma
l_int|32
op_plus
l_int|4
comma
l_int|32
op_plus
l_int|4
comma
l_int|32
op_plus
l_int|4
comma
l_int|32
op_plus
l_int|4
)brace
comma
multiline_comment|/* IdSel 8,  slot 2 */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|0
comma
l_int|8
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup configuration for MIATA (EV56+PYXIS)&n; *&n; * Summary @ PYXIS_INT_REQ:&n; * Bit      Meaning&n; * 0        Fan Fault&n; * 1        NMI&n; * 2        Halt/Reset switch&n; * 3        none&n; * 4        CID0 (Riser ID)&n; * 5        CID1 (Riser ID)&n; * 6        Interval timer&n; * 7        PCI-ISA Bridge&n; * 8        Ethernet&n; * 9        EIDE (deprecated, ISA 14/15 used)&n; *10        none&n; *11        USB&n; *12        Interrupt Line A from slot 4&n; *13        Interrupt Line B from slot 4&n; *14        Interrupt Line C from slot 4&n; *15        Interrupt Line D from slot 4&n; *16        Interrupt Line A from slot 5&n; *17        Interrupt line B from slot 5&n; *18        Interrupt Line C from slot 5&n; *19        Interrupt Line D from slot 5&n; *20        Interrupt Line A from slot 1&n; *21        Interrupt Line B from slot 1&n; *22        Interrupt Line C from slot 1&n; *23        Interrupt Line D from slot 1&n; *24        Interrupt Line A from slot 2&n; *25        Interrupt Line B from slot 2&n; *26        Interrupt Line C from slot 2&n; *27        Interrupt Line D from slot 2&n; *27        Interrupt Line A from slot 3&n; *29        Interrupt Line B from slot 3&n; *30        Interrupt Line C from slot 3&n; *31        Interrupt Line D from slot 3&n; *&n; * The device to slot mapping looks like:&n; *&n; * Slot     Device&n; *  3       DC21142 Ethernet&n; *  4       EIDE CMD646&n; *  5       none&n; *  6       USB&n; *  7       PCI-ISA bridge&n; *  8       PCI-PCI Bridge      (SBU Riser)&n; *  9       none&n; * 10       none&n; * 11       PCI on board slot 4 (SBU Riser)&n; * 12       PCI on board slot 5 (SBU Riser)&n; *&n; *  These are behind the bridge, so I&squot;m not sure what to do...&n; *&n; * 13       PCI on board slot 1 (SBU Riser)&n; * 14       PCI on board slot 2 (SBU Riser)&n; * 15       PCI on board slot 3 (SBU Riser)&n; *   &n; *&n; * This two layered interrupt approach means that we allocate IRQ 16 and &n; * above for PCI interrupts.  The IRQ relates to which bit the interrupt&n; * comes in on.  This makes interrupt processing much easier.&n; */
macro_line|#ifdef CONFIG_ALPHA_MIATA
DECL|function|miata_fixup
r_static
r_inline
r_void
id|miata_fixup
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|irq_tab
(braket
l_int|18
)braket
(braket
l_int|5
)braket
op_assign
(brace
multiline_comment|/*INT    INTA   INTB   INTC   INTD */
(brace
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
comma
l_int|16
op_plus
l_int|8
)brace
comma
multiline_comment|/* IdSel 14,  DC21142  */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 15,  EIDE   */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 16,  none   */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 17,  none   */
multiline_comment|/*&t;&t;{16+11, 16+11, 16+11, 16+11, 16+11},*/
multiline_comment|/* IdSel 17,  USB ??  */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 18,  PCI-ISA */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 19,  PCI-PCI */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 20,  none    */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 21,  none    */
(brace
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|12
comma
l_int|16
op_plus
l_int|13
comma
l_int|16
op_plus
l_int|14
comma
l_int|16
op_plus
l_int|15
)brace
comma
multiline_comment|/* IdSel 22,  slot 4 */
(brace
l_int|16
op_plus
l_int|16
comma
l_int|16
op_plus
l_int|16
comma
l_int|16
op_plus
l_int|17
comma
l_int|16
op_plus
l_int|18
comma
l_int|16
op_plus
l_int|19
)brace
comma
multiline_comment|/* IdSel 23,  slot 5 */
multiline_comment|/* The following are actually on bus 1, across the bridge */
(brace
l_int|16
op_plus
l_int|20
comma
l_int|16
op_plus
l_int|20
comma
l_int|16
op_plus
l_int|21
comma
l_int|16
op_plus
l_int|22
comma
l_int|16
op_plus
l_int|23
)brace
comma
multiline_comment|/* IdSel 24,  slot 1 */
(brace
l_int|16
op_plus
l_int|24
comma
l_int|16
op_plus
l_int|24
comma
l_int|16
op_plus
l_int|25
comma
l_int|16
op_plus
l_int|26
comma
l_int|16
op_plus
l_int|27
)brace
comma
multiline_comment|/* IdSel 25,  slot 2 */
(brace
l_int|16
op_plus
l_int|28
comma
l_int|16
op_plus
l_int|28
comma
l_int|16
op_plus
l_int|29
comma
l_int|16
op_plus
l_int|30
comma
l_int|16
op_plus
l_int|31
)brace
comma
multiline_comment|/* IdSel 26,  slot 3 */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 27,  none    */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 28,  none    */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 29,  none    */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 30,  none    */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* IdSel 31,  PCI-PCI */
)brace
suffix:semicolon
id|common_fixup
c_func
(paren
l_int|3
comma
l_int|20
comma
l_int|5
comma
id|irq_tab
comma
l_int|0
)paren
suffix:semicolon
id|es1888_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Fixup configuration for all boards that route the PCI interrupts&n; * through the SIO PCI/ISA bridge.  This includes Noname (AXPpci33),&n; * Avanti (AlphaStation) and Kenetics&squot;s Platform 2000.&n; */
DECL|function|sio_fixup
r_static
r_inline
r_void
id|sio_fixup
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
multiline_comment|/*&n;&t; * The Noname board has 5 PCI slots with each of the 4&n;&t; * interrupt pins routed to different pins on the PCI/ISA&n;&t; * bridge (PIRQ0-PIRQ3).  The table below is based on&n;&t; * information available at:&n;&t; *&n;&t; *   http://ftp.digital.com/pub/DEC/axppci/ref_interrupts.txt&n;&t; *&n;&t; * I have no information on the Avanti interrupt routing, but&n;&t; * the routing seems to be identical to the Noname except&n;&t; * that the Avanti has an additional slot whose routing I&squot;m&n;&t; * unsure of.&n;&t; *&n;&t; * pirq_tab[0] is a fake entry to deal with old PCI boards&n;&t; * that have the interrupt pin number hardwired to 0 (meaning&n;&t; * that they use the default INTA line, if they are interrupt&n;&t; * driven at all).&n;&t; */
r_static
r_const
r_char
id|pirq_tab
(braket
)braket
(braket
l_int|5
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_ALPHA_P2K
(brace
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel  6 (53c810) */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel  7 (SIO: PCI/ISA bridge) */
(brace
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* idsel  8 (slot A) */
(brace
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|0
comma
l_int|1
)brace
comma
multiline_comment|/* idsel  9 (slot B) */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel 10 (unused) */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel 11 (unused) */
(brace
l_int|3
comma
l_int|3
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel 12 (CMD0646) */
macro_line|#else
(brace
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
)brace
comma
multiline_comment|/* idsel  6 (53c810) */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel  7 (SIO: PCI/ISA bridge) */
(brace
l_int|2
comma
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel  8 (Noname hack: slot closest to ISA) */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel  9 (unused) */
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
comma
multiline_comment|/* idsel 10 (unused) */
(brace
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* idsel 11 KN25_PCI_SLOT0 */
(brace
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|2
comma
l_int|1
)brace
comma
multiline_comment|/* idsel 12 KN25_PCI_SLOT1 */
(brace
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|2
)brace
comma
multiline_comment|/* idsel 13 KN25_PCI_SLOT2 */
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* idsel 14 AS255 TULIP */
macro_line|#endif
)brace
suffix:semicolon
r_const
r_int
id|pirq_tab_len
op_assign
r_sizeof
(paren
id|pirq_tab
)paren
op_div
r_sizeof
(paren
id|pirq_tab
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * route_tab selects irq routing in PCI/ISA bridge so that:&n;&t; *&t;&t;PIRQ0 -&gt; irq 15&n;&t; *&t;&t;PIRQ1 -&gt; irq  9&n;&t; *&t;&t;PIRQ2 -&gt; irq 10&n;&t; *&t;&t;PIRQ3 -&gt; irq 11&n;&t; *&n;&t; * This probably ought to be configurable via MILO.  For&n;&t; * example, sound boards seem to like using IRQ 9.&n;&t; */
macro_line|#if defined(CONFIG_ALPHA_BOOK1)
multiline_comment|/* for the AlphaBook1, NCR810 SCSI is 14, PCMCIA controller is 15 */
r_const
r_int
r_int
id|route_tab
op_assign
l_int|0x0e0f0a0a
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_NONAME)
multiline_comment|/*&n;&t; * For UDB, the only available PCI slot must not map to IRQ 9,&n;&t; *  since that&squot;s the builtin MSS sound chip. That PCI slot&n;&t; *  will map to PIRQ1 (for INTA at least), so we give it IRQ 15&n;&t; *  instead.&n;&t; *&n;&t; * Unfortunately we have to do this for NONAME as well, since&n;&t; *  they are co-indicated when the platform type &quot;Noname&quot; is&n;&t; *  selected... :-(&n;&t; */
r_const
r_int
r_int
id|route_tab
op_assign
l_int|0x0b0a0f09
suffix:semicolon
macro_line|#else
r_const
r_int
r_int
id|route_tab
op_assign
l_int|0x0b0a090f
suffix:semicolon
macro_line|#endif
r_int
r_int
id|level_bits
suffix:semicolon
r_int
r_char
id|pin
comma
id|slot
suffix:semicolon
r_int
id|pirq
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
l_int|0
comma
id|PCI_DEVFN
c_func
(paren
l_int|7
comma
l_int|0
)paren
comma
l_int|0x60
comma
id|route_tab
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go through all devices, fixing up irqs as we see fit:&n;&t; */
id|level_bits
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_eq
id|PCI_BASE_CLASS_BRIDGE
)paren
op_logical_and
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_ne
id|PCI_CLASS_BRIDGE_PCMCIA
)paren
)paren
r_continue
suffix:semicolon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;number
op_ne
l_int|0
)paren
(brace
r_struct
id|pci_dev
op_star
id|curr
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * read the pin and do the PCI-PCI bridge&n;&t;&t;&t; * interrupt pin swizzle&n;&t;&t;&t; */
id|pcibios_read_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin
)paren
suffix:semicolon
multiline_comment|/* cope with 0 */
r_if
c_cond
(paren
id|pin
op_eq
l_int|0
)paren
id|pin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* follow the chain of bridges, swizzling as we go */
r_do
(brace
multiline_comment|/* swizzle */
id|pin
op_assign
id|bridge_swizzle
c_func
(paren
id|pin
comma
id|PCI_SLOT
c_func
(paren
id|curr-&gt;devfn
)paren
)paren
suffix:semicolon
multiline_comment|/* move up the chain of bridges */
id|curr
op_assign
id|curr-&gt;bus-&gt;self
suffix:semicolon
)brace
r_while
c_loop
(paren
id|curr-&gt;bus-&gt;self
)paren
suffix:semicolon
multiline_comment|/* The slot is the slot of the last bridge. */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|curr-&gt;devfn
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* work out the slot */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
suffix:semicolon
multiline_comment|/* read the pin */
id|pcibios_read_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slot
OL
l_int|6
op_logical_or
id|slot
op_ge
l_int|6
op_plus
id|pirq_tab_len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bios32.sio_fixup: &quot;
l_string|&quot;weird, found device %04x:%04x in&quot;
l_string|&quot; non-existent slot %d!!&bslash;n&quot;
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|slot
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pirq
op_assign
id|pirq_tab
(braket
id|slot
op_minus
l_int|6
)braket
(braket
id|pin
)braket
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;sio_fixup: bus %d  slot 0x%x  VID 0x%x  DID 0x%x&bslash;n&quot;
l_string|&quot;           int_slot 0x%x  pin 0x%x  pirq 0x%x&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|slot
comma
id|pin
comma
id|pirq
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if it&squot;s a VGA, enable its BIOS ROM at C0000&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_DISPLAY_VGA
)paren
(brace
id|pcibios_write_config_dword
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_ROM_ADDRESS
comma
l_int|0x000c0000
op_or
id|PCI_ROM_ADDRESS_ENABLE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
)paren
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
r_continue
suffix:semicolon
multiline_comment|/* for now, displays get no IRQ */
)brace
r_if
c_cond
(paren
id|pirq
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bios32.sio_fixup: &quot;
l_string|&quot;weird, device %04x:%04x coming in on&quot;
l_string|&quot; slot %d has no irq line!!&bslash;n&quot;
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|slot
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dev-&gt;irq
op_assign
(paren
id|route_tab
op_rshift
(paren
l_int|8
op_star
id|pirq
)paren
)paren
op_amp
l_int|0xff
suffix:semicolon
macro_line|#ifndef CONFIG_ALPHA_BOOK1
multiline_comment|/* do not set *ANY* level triggers for AlphaBook1 */
multiline_comment|/* must set the PCI IRQs to level triggered */
id|level_bits
op_or_assign
(paren
l_int|1
op_lshift
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif /* !CONFIG_ALPHA_BOOK1 */
macro_line|#if PCI_MODIFY
multiline_comment|/* tell the device: */
id|pcibios_write_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_LINE
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ALPHA_BOOK1
multiline_comment|/*&n;                 * On the AlphaBook1, the PCMCIA chip (Cirrus 6729)&n;                 * is sensitive to PCI bus bursts, so we must DISABLE&n;                 * burst mode for the NCR 8xx SCSI... :-(&n;&t;&t; *&n;&t;&t; * Note that the NCR810 SCSI driver must preserve the&n;&t;&t; * setting of the bit in order for this to work.  At the&n;&t;&t; * moment (2.0.29), ncr53c8xx.c does NOT do this, but&n;&t;&t; * 53c7,8xx.c DOES.&n;                 */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_NCR
op_logical_and
(paren
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_NCR_53C810
op_logical_or
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_NCR_53C815
op_logical_or
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_NCR_53C820
op_logical_or
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_NCR_53C825
)paren
)paren
(brace
r_int
r_int
id|io_port
suffix:semicolon
r_int
r_char
id|ctest4
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|io_port
)paren
suffix:semicolon
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|ctest4
op_assign
id|inb
c_func
(paren
id|io_port
op_plus
l_int|0x21
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctest4
op_amp
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AlphaBook1 NCR init: setting&quot;
l_string|&quot; burst disable&bslash;n&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ctest4
op_or
l_int|0x80
comma
id|io_port
op_plus
l_int|0x21
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_ALPHA_BOOK1 */
)brace
multiline_comment|/* end for-devs */
multiline_comment|/*&n;&t; * Now, make all PCI interrupts level sensitive.  Notice:&n;&t; * these registers must be accessed byte-wise.  inw()/outw()&n;&t; * don&squot;t work.&n;&t; *&n;&t; * Make sure to turn off any level bits set for IRQs 9,10,11,15,&n;&t; *  so that the only bits getting set are for devices actually found.&n;&t; * Note that we do preserve the remainder of the bits, which we hope&n;&t; *  will be set correctly by ARC/SRM.&n;&t; *&n;&t; * Note: we at least preserve any level-set bits on AlphaBook1&n;&t; */
id|level_bits
op_or_assign
(paren
(paren
id|inb
c_func
(paren
l_int|0x4d0
)paren
op_or
(paren
id|inb
c_func
(paren
l_int|0x4d1
)paren
op_lshift
l_int|8
)paren
)paren
op_amp
l_int|0x71ff
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|level_bits
op_rshift
l_int|0
)paren
op_amp
l_int|0xff
comma
l_int|0x4d0
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|level_bits
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
l_int|0x4d1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ALPHA_BOOK1
(brace
r_int
r_char
id|orig
comma
id|config
suffix:semicolon
multiline_comment|/* On the AlphaBook1, make sure that register PR1&n;&t;&t;   indicates 1Mb mem */
id|outb
c_func
(paren
l_int|0x0f
comma
l_int|0x3ce
)paren
suffix:semicolon
id|orig
op_assign
id|inb
c_func
(paren
l_int|0x3cf
)paren
suffix:semicolon
multiline_comment|/* read PR5  */
id|outb
c_func
(paren
l_int|0x0f
comma
l_int|0x3ce
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x05
comma
l_int|0x3cf
)paren
suffix:semicolon
multiline_comment|/* unlock PR0-4 */
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0x3ce
)paren
suffix:semicolon
id|config
op_assign
id|inb
c_func
(paren
l_int|0x3cf
)paren
suffix:semicolon
multiline_comment|/* read PR1 */
r_if
c_cond
(paren
(paren
id|config
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AlphaBook1 VGA init: setting 1Mb memory&bslash;n&quot;
)paren
suffix:semicolon
id|config
op_or_assign
l_int|0xc0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0x3ce
)paren
suffix:semicolon
id|outb
c_func
(paren
id|config
comma
l_int|0x3cf
)paren
suffix:semicolon
multiline_comment|/* write PR1 */
)brace
id|outb
c_func
(paren
l_int|0x0f
comma
l_int|0x3ce
)paren
suffix:semicolon
id|outb
c_func
(paren
id|orig
comma
l_int|0x3cf
)paren
suffix:semicolon
multiline_comment|/* (re)lock PR0-4 */
)brace
macro_line|#endif /* CONFIG_ALPHA_BOOK1 */
macro_line|#ifndef CONFIG_ALPHA_BOOK1
multiline_comment|/* Do not do IDE init for AlphaBook1 */
id|enable_ide
c_func
(paren
l_int|0x26e
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_TGA_CONSOLE
r_extern
r_void
id|tga_console_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_TGA_CONSOLE */
DECL|function|pcibios_fixup
r_int
r_int
id|pcibios_fixup
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
macro_line|#if PCI_MODIFY
multiline_comment|/*&n;&t; * Scan the tree, allocating PCI memory and I/O space.&n;&t; */
id|layout_bus
c_func
(paren
op_amp
id|pci_root
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Now is the time to do all those dirty little deeds...&n;&t; */
macro_line|#if defined(CONFIG_ALPHA_NONAME) || defined(CONFIG_ALPHA_AVANTI) || &bslash;&n;    defined(CONFIG_ALPHA_P2K)
id|sio_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_CABRIOLET) || defined(CONFIG_ALPHA_EB164)
id|cabriolet_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_PC164)
id|alphapc164_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_EB66P)
id|eb66p_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_EB66)
id|eb66_and_eb64p_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_EB64P)
id|eb66_and_eb64p_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_MIKASA)
id|mikasa_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_ALCOR)
id|alcor_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_XLT)
id|xlt_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_SABLE)
id|sable_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_MIATA)
id|miata_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#elif defined(CONFIG_ALPHA_NORITAKE)
id|noritake_fixup
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
macro_line|# error &quot;You must tell me what kind of platform you want.&quot;
macro_line|#endif
macro_line|#ifndef CONFIG_ABSTRACT_CONSOLE
macro_line|#ifdef CONFIG_TGA_CONSOLE
id|tga_console_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|sys_pciconfig_read
id|asmlinkage
r_int
id|sys_pciconfig_read
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|ubyte
suffix:semicolon
r_int
r_int
id|ushort
suffix:semicolon
r_int
r_int
id|uint
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|1
suffix:colon
id|err
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|ubyte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
id|ubyte
op_assign
l_int|0xff
suffix:semicolon
id|put_user
c_func
(paren
id|ubyte
comma
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|err
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|ushort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
id|ushort
op_assign
l_int|0xffff
suffix:semicolon
id|put_user
c_func
(paren
id|ushort
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|err
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|uint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
id|uint
op_assign
l_int|0xffffffff
suffix:semicolon
id|put_user
c_func
(paren
id|uint
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_pciconfig_write
id|asmlinkage
r_int
id|sys_pciconfig_write
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|ubyte
suffix:semicolon
r_int
r_int
id|ushort
suffix:semicolon
r_int
r_int
id|uint
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|1
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|ubyte
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|err
op_assign
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|ubyte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|ushort
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|err
op_assign
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|ushort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|uint
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|err
op_assign
id|pcibios_write_config_dword
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|uint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ALPHA_PC164
multiline_comment|/* device &quot;activate&quot; register contents */
DECL|macro|DEVICE_ON
mdefine_line|#define DEVICE_ON&t;&t;1
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF&t;&t;0
multiline_comment|/* configuration on/off keys */
DECL|macro|CONFIG_ON_KEY
mdefine_line|#define CONFIG_ON_KEY&t;&t;0x55
DECL|macro|CONFIG_OFF_KEY
mdefine_line|#define CONFIG_OFF_KEY&t;&t;0xaa
multiline_comment|/* configuration space device definitions */
DECL|macro|FDC
mdefine_line|#define FDC&t;&t;&t;0
DECL|macro|IDE1
mdefine_line|#define IDE1&t;&t;&t;1
DECL|macro|IDE2
mdefine_line|#define IDE2&t;&t;&t;2
DECL|macro|PARP
mdefine_line|#define PARP&t;&t;&t;3
DECL|macro|SER1
mdefine_line|#define SER1&t;&t;&t;4
DECL|macro|SER2
mdefine_line|#define SER2&t;&t;&t;5
DECL|macro|RTCL
mdefine_line|#define RTCL&t;&t;&t;6
DECL|macro|KYBD
mdefine_line|#define KYBD&t;&t;&t;7
DECL|macro|AUXIO
mdefine_line|#define AUXIO&t;&t;&t;8
multiline_comment|/* Chip register offsets from base */
DECL|macro|CONFIG_CONTROL
mdefine_line|#define CONFIG_CONTROL&t;&t;0x02
DECL|macro|INDEX_ADDRESS
mdefine_line|#define INDEX_ADDRESS&t;&t;0x03
DECL|macro|LOGICAL_DEVICE_NUMBER
mdefine_line|#define LOGICAL_DEVICE_NUMBER&t;0x07
DECL|macro|DEVICE_ID
mdefine_line|#define DEVICE_ID&t;&t;0x20
DECL|macro|DEVICE_REV
mdefine_line|#define DEVICE_REV&t;&t;0x21
DECL|macro|POWER_CONTROL
mdefine_line|#define POWER_CONTROL&t;&t;0x22
DECL|macro|POWER_MGMT
mdefine_line|#define POWER_MGMT&t;&t;0x23
DECL|macro|OSC
mdefine_line|#define OSC&t;&t;&t;0x24
DECL|macro|ACTIVATE
mdefine_line|#define ACTIVATE&t;&t;0x30
DECL|macro|ADDR_HI
mdefine_line|#define ADDR_HI&t;&t;&t;0x60
DECL|macro|ADDR_LO
mdefine_line|#define ADDR_LO&t;&t;&t;0x61
DECL|macro|INTERRUPT_SEL
mdefine_line|#define INTERRUPT_SEL&t;&t;0x70
DECL|macro|INTERRUPT_SEL_2
mdefine_line|#define INTERRUPT_SEL_2&t;&t;0x72 /* KYBD/MOUS only */
DECL|macro|DMA_CHANNEL_SEL
mdefine_line|#define DMA_CHANNEL_SEL&t;&t;0x74 /* FDC/PARP only */
DECL|macro|FDD_MODE_REGISTER
mdefine_line|#define FDD_MODE_REGISTER&t;0x90
DECL|macro|FDD_OPTION_REGISTER
mdefine_line|#define FDD_OPTION_REGISTER&t;0x91
multiline_comment|/* values that we read back that are expected ... */
DECL|macro|VALID_DEVICE_ID
mdefine_line|#define VALID_DEVICE_ID&t;&t;2
multiline_comment|/* default device addresses */
DECL|macro|KYBD_INTERRUPT
mdefine_line|#define KYBD_INTERRUPT&t;&t;1
DECL|macro|MOUS_INTERRUPT
mdefine_line|#define MOUS_INTERRUPT&t;&t;12
DECL|macro|COM2_BASE
mdefine_line|#define COM2_BASE&t;&t;0x2f8
DECL|macro|COM2_INTERRUPT
mdefine_line|#define COM2_INTERRUPT&t;&t;3
DECL|macro|COM1_BASE
mdefine_line|#define COM1_BASE&t;&t;0x3f8
DECL|macro|COM1_INTERRUPT
mdefine_line|#define COM1_INTERRUPT&t;&t;4
DECL|macro|PARP_BASE
mdefine_line|#define PARP_BASE&t;&t;0x3bc
DECL|macro|PARP_INTERRUPT
mdefine_line|#define PARP_INTERRUPT&t;&t;7
DECL|macro|SMC_DEBUG
mdefine_line|#define SMC_DEBUG 0
DECL|function|SMCConfigState
r_static
r_int
r_int
id|SMCConfigState
c_func
(paren
r_int
r_int
id|baseAddr
)paren
(brace
r_int
r_char
id|devId
suffix:semicolon
r_int
r_char
id|devRev
suffix:semicolon
r_int
r_int
id|configPort
suffix:semicolon
r_int
r_int
id|indexPort
suffix:semicolon
r_int
r_int
id|dataPort
suffix:semicolon
id|configPort
op_assign
id|indexPort
op_assign
id|baseAddr
suffix:semicolon
id|dataPort
op_assign
id|configPort
op_plus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
id|CONFIG_ON_KEY
comma
id|configPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|CONFIG_ON_KEY
comma
id|configPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DEVICE_ID
comma
id|indexPort
)paren
suffix:semicolon
id|devId
op_assign
id|inb
c_func
(paren
id|dataPort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devId
op_eq
id|VALID_DEVICE_ID
)paren
(brace
id|outb
c_func
(paren
id|DEVICE_REV
comma
id|indexPort
)paren
suffix:semicolon
id|devRev
op_assign
id|inb
c_func
(paren
id|dataPort
)paren
suffix:semicolon
)brace
r_else
(brace
id|baseAddr
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|baseAddr
suffix:semicolon
)brace
DECL|function|SMCRunState
r_static
r_void
id|SMCRunState
c_func
(paren
r_int
r_int
id|baseAddr
)paren
(brace
id|outb
c_func
(paren
id|CONFIG_OFF_KEY
comma
id|baseAddr
)paren
suffix:semicolon
)brace
DECL|function|SMCDetectUltraIO
r_static
r_int
r_int
id|SMCDetectUltraIO
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|baseAddr
suffix:semicolon
id|baseAddr
op_assign
l_int|0x3F0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|baseAddr
op_assign
id|SMCConfigState
c_func
(paren
id|baseAddr
)paren
)paren
op_eq
l_int|0x3F0
)paren
(brace
r_return
id|baseAddr
suffix:semicolon
)brace
id|baseAddr
op_assign
l_int|0x370
suffix:semicolon
r_if
c_cond
(paren
(paren
id|baseAddr
op_assign
id|SMCConfigState
c_func
(paren
id|baseAddr
)paren
)paren
op_eq
l_int|0x370
)paren
(brace
r_return
id|baseAddr
suffix:semicolon
)brace
r_return
(paren
r_int
r_int
)paren
l_int|0
suffix:semicolon
)brace
DECL|function|SMCEnableDevice
r_static
r_void
id|SMCEnableDevice
c_func
(paren
r_int
r_int
id|baseAddr
comma
r_int
r_int
id|device
comma
r_int
r_int
id|portaddr
comma
r_int
r_int
id|interrupt
)paren
(brace
r_int
r_int
id|indexPort
suffix:semicolon
r_int
r_int
id|dataPort
suffix:semicolon
id|indexPort
op_assign
id|baseAddr
suffix:semicolon
id|dataPort
op_assign
id|baseAddr
op_plus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
id|LOGICAL_DEVICE_NUMBER
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|device
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ADDR_LO
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|portaddr
op_amp
l_int|0xFF
)paren
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ADDR_HI
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|portaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|INTERRUPT_SEL
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|interrupt
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACTIVATE
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DEVICE_ON
comma
id|dataPort
)paren
suffix:semicolon
)brace
DECL|function|SMCEnableKYBD
r_static
r_void
id|SMCEnableKYBD
c_func
(paren
r_int
r_int
id|baseAddr
)paren
(brace
r_int
r_int
id|indexPort
suffix:semicolon
r_int
r_int
id|dataPort
suffix:semicolon
id|indexPort
op_assign
id|baseAddr
suffix:semicolon
id|dataPort
op_assign
id|baseAddr
op_plus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
id|LOGICAL_DEVICE_NUMBER
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|KYBD
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|INTERRUPT_SEL
comma
id|indexPort
)paren
suffix:semicolon
multiline_comment|/* Primary interrupt select */
id|outb
c_func
(paren
id|KYBD_INTERRUPT
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|INTERRUPT_SEL_2
comma
id|indexPort
)paren
suffix:semicolon
multiline_comment|/* Secondary interrupt select */
id|outb
c_func
(paren
id|MOUS_INTERRUPT
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACTIVATE
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DEVICE_ON
comma
id|dataPort
)paren
suffix:semicolon
)brace
DECL|function|SMCEnableFDC
r_static
r_void
id|SMCEnableFDC
c_func
(paren
r_int
r_int
id|baseAddr
)paren
(brace
r_int
r_int
id|indexPort
suffix:semicolon
r_int
r_int
id|dataPort
suffix:semicolon
r_int
r_char
id|oldValue
suffix:semicolon
id|indexPort
op_assign
id|baseAddr
suffix:semicolon
id|dataPort
op_assign
id|baseAddr
op_plus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
id|LOGICAL_DEVICE_NUMBER
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|FDC
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|FDD_MODE_REGISTER
comma
id|indexPort
)paren
suffix:semicolon
id|oldValue
op_assign
id|inb
c_func
(paren
id|dataPort
)paren
suffix:semicolon
id|oldValue
op_or_assign
l_int|0x0E
suffix:semicolon
multiline_comment|/* Enable burst mode */
id|outb
c_func
(paren
id|oldValue
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|INTERRUPT_SEL
comma
id|indexPort
)paren
suffix:semicolon
multiline_comment|/* Primary interrupt select */
id|outb
c_func
(paren
l_int|0x06
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DMA_CHANNEL_SEL
comma
id|indexPort
)paren
suffix:semicolon
multiline_comment|/* DMA channel select */
id|outb
c_func
(paren
l_int|0x02
comma
id|dataPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACTIVATE
comma
id|indexPort
)paren
suffix:semicolon
id|outb
c_func
(paren
id|DEVICE_ON
comma
id|dataPort
)paren
suffix:semicolon
)brace
macro_line|#if SMC_DEBUG
DECL|function|SMCReportDeviceStatus
r_static
r_void
id|SMCReportDeviceStatus
c_func
(paren
r_int
r_int
id|baseAddr
)paren
(brace
r_int
r_int
id|indexPort
suffix:semicolon
r_int
r_int
id|dataPort
suffix:semicolon
r_int
r_char
id|currentControl
suffix:semicolon
id|indexPort
op_assign
id|baseAddr
suffix:semicolon
id|dataPort
op_assign
id|baseAddr
op_plus
l_int|1
suffix:semicolon
id|outb
c_func
(paren
id|POWER_CONTROL
comma
id|indexPort
)paren
suffix:semicolon
id|currentControl
op_assign
id|inb
c_func
(paren
id|dataPort
)paren
suffix:semicolon
id|printk
c_func
(paren
id|currentControl
op_amp
(paren
l_int|1
op_lshift
id|FDC
)paren
ques
c_cond
l_string|&quot;&bslash;t+FDC Enabled&bslash;n&quot;
suffix:colon
l_string|&quot;&bslash;t-FDC Disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|currentControl
op_amp
(paren
l_int|1
op_lshift
id|IDE1
)paren
ques
c_cond
l_string|&quot;&bslash;t+IDE1 Enabled&bslash;n&quot;
suffix:colon
l_string|&quot;&bslash;t-IDE1 Disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|currentControl
op_amp
(paren
l_int|1
op_lshift
id|IDE2
)paren
ques
c_cond
l_string|&quot;&bslash;t+IDE2 Enabled&bslash;n&quot;
suffix:colon
l_string|&quot;&bslash;t-IDE2 Disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|currentControl
op_amp
(paren
l_int|1
op_lshift
id|PARP
)paren
ques
c_cond
l_string|&quot;&bslash;t+PARP Enabled&bslash;n&quot;
suffix:colon
l_string|&quot;&bslash;t-PARP Disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|currentControl
op_amp
(paren
l_int|1
op_lshift
id|SER1
)paren
ques
c_cond
l_string|&quot;&bslash;t+SER1 Enabled&bslash;n&quot;
suffix:colon
l_string|&quot;&bslash;t-SER1 Disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|currentControl
op_amp
(paren
l_int|1
op_lshift
id|SER2
)paren
ques
c_cond
l_string|&quot;&bslash;t+SER2 Enabled&bslash;n&quot;
suffix:colon
l_string|&quot;&bslash;t-SER2 Disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|SMCInit
r_static
r_int
id|SMCInit
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|SMCUltraBase
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SMCUltraBase
op_assign
id|SMCDetectUltraIO
c_func
(paren
)paren
)paren
op_ne
l_int|0UL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMC FDC37C93X Ultra I/O Controller found @ 0x%lx&bslash;n&quot;
comma
id|SMCUltraBase
)paren
suffix:semicolon
macro_line|#if SMC_DEBUG
id|SMCReportDeviceStatus
c_func
(paren
id|SMCUltraBase
)paren
suffix:semicolon
macro_line|#endif
id|SMCEnableDevice
c_func
(paren
id|SMCUltraBase
comma
id|SER1
comma
id|COM1_BASE
comma
id|COM1_INTERRUPT
)paren
suffix:semicolon
id|SMCEnableDevice
c_func
(paren
id|SMCUltraBase
comma
id|SER2
comma
id|COM2_BASE
comma
id|COM2_INTERRUPT
)paren
suffix:semicolon
id|SMCEnableDevice
c_func
(paren
id|SMCUltraBase
comma
id|PARP
comma
id|PARP_BASE
comma
id|PARP_INTERRUPT
)paren
suffix:semicolon
multiline_comment|/* On PC164, IDE on the SMC is not enabled;&n;&t;&t;   CMD646 (PCI) on MB */
id|SMCEnableKYBD
c_func
(paren
id|SMCUltraBase
)paren
suffix:semicolon
id|SMCEnableFDC
c_func
(paren
id|SMCUltraBase
)paren
suffix:semicolon
macro_line|#if SMC_DEBUG
id|SMCReportDeviceStatus
c_func
(paren
id|SMCUltraBase
)paren
suffix:semicolon
macro_line|#endif
id|SMCRunState
c_func
(paren
id|SMCUltraBase
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SMC_DEBUG
id|printk
c_func
(paren
l_string|&quot;No SMC FDC37C93X Ultra I/O Controller found&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_ALPHA_PC164 */
macro_line|#ifdef CONFIG_ALPHA_MIATA
multiline_comment|/*&n; * Init the built-in ES1888 sound chip (SB16 compatible)&n; */
DECL|function|es1888_init
r_static
r_int
id|es1888_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Sequence of IO reads to init the audio controller */
id|inb
c_func
(paren
l_int|0x0229
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x0229
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x0229
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x022b
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x0229
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x022b
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x0229
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x0229
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x022b
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x0229
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x0220
)paren
suffix:semicolon
multiline_comment|/* This sets the base address to 0x220 */
multiline_comment|/* Sequence to set DMA channels */
id|outb
c_func
(paren
l_int|0x01
comma
l_int|0x0226
)paren
suffix:semicolon
multiline_comment|/* reset */
id|inb
c_func
(paren
l_int|0x0226
)paren
suffix:semicolon
multiline_comment|/* pause */
id|outb
c_func
(paren
l_int|0x00
comma
l_int|0x0226
)paren
suffix:semicolon
multiline_comment|/* release reset */
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
l_int|0x022e
)paren
op_amp
l_int|0x80
)paren
)paren
multiline_comment|/* wait for bit 7 to assert*/
r_continue
suffix:semicolon
id|inb
c_func
(paren
l_int|0x022a
)paren
suffix:semicolon
multiline_comment|/* pause */
id|outb
c_func
(paren
l_int|0xc6
comma
l_int|0x022c
)paren
suffix:semicolon
multiline_comment|/* enable extended mode */
r_while
c_loop
(paren
id|inb
c_func
(paren
l_int|0x022c
)paren
op_amp
l_int|0x80
)paren
multiline_comment|/* wait for bit 7 to deassert */
r_continue
suffix:semicolon
id|outb
c_func
(paren
l_int|0xb1
comma
l_int|0x022c
)paren
suffix:semicolon
multiline_comment|/* setup for write to Interrupt CR */
r_while
c_loop
(paren
id|inb
c_func
(paren
l_int|0x022c
)paren
op_amp
l_int|0x80
)paren
multiline_comment|/* wait for bit 7 to deassert */
r_continue
suffix:semicolon
id|outb
c_func
(paren
l_int|0x14
comma
l_int|0x022c
)paren
suffix:semicolon
multiline_comment|/* set IRQ 5 */
r_while
c_loop
(paren
id|inb
c_func
(paren
l_int|0x022c
)paren
op_amp
l_int|0x80
)paren
multiline_comment|/* wait for bit 7 to deassert */
r_continue
suffix:semicolon
id|outb
c_func
(paren
l_int|0xb2
comma
l_int|0x022c
)paren
suffix:semicolon
multiline_comment|/* setup for write to DMA CR */
r_while
c_loop
(paren
id|inb
c_func
(paren
l_int|0x022c
)paren
op_amp
l_int|0x80
)paren
multiline_comment|/* wait for bit 7 to deassert */
r_continue
suffix:semicolon
id|outb
c_func
(paren
l_int|0x18
comma
l_int|0x022c
)paren
suffix:semicolon
multiline_comment|/* set DMA channel 1 */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ALPHA_MIATA */
macro_line|#endif /* CONFIG_PCI */
eof
