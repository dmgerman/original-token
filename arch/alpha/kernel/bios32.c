multiline_comment|/*&n; * bios32.c - PCI BIOS functions for Alpha systems not using BIOS&n; *&t;      emulation code.&n; *&n; * Written by Dave Rusling (david.rusling@reo.mts.dec.com)&n; *&n; * Adapted to 64-bit kernel and then rewritten by David Mosberger&n; * (davidm@cs.arizona.edu)&n; *&n; * For more information, please consult&n; *&n; * PCI BIOS Specification Revision&n; * PCI Local Bus Specification&n; * PCI System Design Guide&n; *&n; * PCI Special Interest Group&n; * M/S HF3-15A&n; * 5200 N.E. Elam Young Parkway&n; * Hillsboro, Oregon 97124-6497&n; * +1 (503) 696-2000&n; * +1 (800) 433-5177&n; *&n; * Manuals are $25 each or $50 for all three, plus $7 shipping&n; * within the United States, $35 abroad.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;proto.h&quot;
macro_line|#include &quot;bios32.h&quot;
DECL|macro|DEBUG_DEVS
mdefine_line|#define DEBUG_DEVS 0
DECL|macro|DEBUG_HOSE
mdefine_line|#define DEBUG_HOSE 0
macro_line|#if DEBUG_DEVS
DECL|macro|DBG_DEVS
macro_line|# define DBG_DEVS(args)&t;&t;printk args
macro_line|#else
DECL|macro|DBG_DEVS
macro_line|# define DBG_DEVS(args)
macro_line|#endif
macro_line|#if DEBUG_HOSE
DECL|macro|DBG_HOSE
macro_line|# define DBG_HOSE(args)&t;&t;printk args
macro_line|#else
DECL|macro|DBG_HOSE
macro_line|# define DBG_HOSE(args)
macro_line|#endif
macro_line|#ifndef CONFIG_PCI
DECL|function|sys_pciconfig_read
id|asmlinkage
r_int
id|sys_pciconfig_read
c_func
(paren
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_pciconfig_write
id|asmlinkage
r_int
id|sys_pciconfig_write
c_func
(paren
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|reset_for_srm
r_void
id|reset_for_srm
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#else /* CONFIG_PCI */
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; * PCI public interfaces.&n; */
DECL|macro|MAJOR_REV
mdefine_line|#define MAJOR_REV&t;0
DECL|macro|MINOR_REV
mdefine_line|#define MINOR_REV&t;4&t;/* minor revision 4, add multi-PCI handling */
DECL|variable|bus2hose
r_struct
id|linux_hose_info
op_star
id|bus2hose
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|hose_head
DECL|variable|hose_tail
r_struct
id|linux_hose_info
op_star
id|hose_head
comma
op_star
op_star
id|hose_tail
op_assign
op_amp
id|hose_head
suffix:semicolon
DECL|variable|hose_count
r_int
id|hose_count
suffix:semicolon
DECL|variable|pci_probe_enabled
r_int
id|pci_probe_enabled
suffix:semicolon
r_static
r_void
id|layout_hoses
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
DECL|function|pcibios_present
id|pcibios_present
c_func
(paren
r_void
)paren
(brace
r_return
id|alpha_mv.hose_read_config_byte
op_ne
l_int|NULL
suffix:semicolon
)brace
r_void
id|__init
DECL|function|pcibios_init
id|pcibios_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Alpha PCI BIOS32 revision %d.%02d&bslash;n&quot;
comma
id|MAJOR_REV
comma
id|MINOR_REV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alpha_use_srm_setup
)paren
id|printk
c_func
(paren
l_string|&quot;   NOT modifying existing (SRM) PCI configuration&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_char
op_star
id|__init
DECL|function|pcibios_setup
id|pcibios_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|str
suffix:semicolon
)brace
r_void
id|__init
DECL|function|pcibios_fixup
id|pcibios_fixup
c_func
(paren
r_void
)paren
(brace
id|alpha_mv
dot
id|pci_fixup
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|pcibios_fixup_bus
id|pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
)brace
r_int
DECL|function|pcibios_read_config_byte
id|pcibios_read_config_byte
(paren
id|u8
id|bus
comma
id|u8
id|dev
comma
id|u8
id|where
comma
id|u8
op_star
id|value
)paren
(brace
r_int
id|r
op_assign
id|PCIBIOS_FUNC_NOT_SUPPORTED
suffix:semicolon
op_star
id|value
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|alpha_mv.hose_read_config_byte
)paren
(brace
id|r
op_assign
(paren
id|alpha_mv.hose_read_config_byte
(paren
id|bus
comma
id|dev
comma
id|where
comma
id|value
comma
id|bus2hose
(braket
id|bus
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
r_int
DECL|function|pcibios_read_config_word
id|pcibios_read_config_word
(paren
id|u8
id|bus
comma
id|u8
id|dev
comma
id|u8
id|where
comma
id|u16
op_star
id|value
)paren
(brace
r_int
id|r
op_assign
id|PCIBIOS_FUNC_NOT_SUPPORTED
suffix:semicolon
op_star
id|value
op_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|alpha_mv.hose_read_config_word
)paren
(brace
id|r
op_assign
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|where
op_amp
l_int|1
)paren
)paren
id|r
op_assign
(paren
id|alpha_mv.hose_read_config_word
(paren
id|bus
comma
id|dev
comma
id|where
comma
id|value
comma
id|bus2hose
(braket
id|bus
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
r_int
DECL|function|pcibios_read_config_dword
id|pcibios_read_config_dword
(paren
id|u8
id|bus
comma
id|u8
id|dev
comma
id|u8
id|where
comma
id|u32
op_star
id|value
)paren
(brace
r_int
id|r
op_assign
id|PCIBIOS_FUNC_NOT_SUPPORTED
suffix:semicolon
op_star
id|value
op_assign
l_int|0xffffffff
suffix:semicolon
r_if
c_cond
(paren
id|alpha_mv.hose_read_config_dword
)paren
(brace
id|r
op_assign
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|where
op_amp
l_int|3
)paren
)paren
id|r
op_assign
(paren
id|alpha_mv.hose_read_config_dword
(paren
id|bus
comma
id|dev
comma
id|where
comma
id|value
comma
id|bus2hose
(braket
id|bus
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
r_int
DECL|function|pcibios_write_config_byte
id|pcibios_write_config_byte
(paren
id|u8
id|bus
comma
id|u8
id|dev
comma
id|u8
id|where
comma
id|u8
id|value
)paren
(brace
r_int
id|r
op_assign
id|PCIBIOS_FUNC_NOT_SUPPORTED
suffix:semicolon
r_if
c_cond
(paren
id|alpha_mv.hose_write_config_byte
)paren
(brace
id|r
op_assign
(paren
id|alpha_mv.hose_write_config_byte
(paren
id|bus
comma
id|dev
comma
id|where
comma
id|value
comma
id|bus2hose
(braket
id|bus
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
r_int
DECL|function|pcibios_write_config_word
id|pcibios_write_config_word
(paren
id|u8
id|bus
comma
id|u8
id|dev
comma
id|u8
id|where
comma
id|u16
id|value
)paren
(brace
r_int
id|r
op_assign
id|PCIBIOS_FUNC_NOT_SUPPORTED
suffix:semicolon
r_if
c_cond
(paren
id|alpha_mv.hose_write_config_word
)paren
(brace
id|r
op_assign
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|where
op_amp
l_int|1
)paren
)paren
id|r
op_assign
(paren
id|alpha_mv.hose_write_config_word
(paren
id|bus
comma
id|dev
comma
id|where
comma
id|value
comma
id|bus2hose
(braket
id|bus
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
r_int
DECL|function|pcibios_write_config_dword
id|pcibios_write_config_dword
(paren
id|u8
id|bus
comma
id|u8
id|dev
comma
id|u8
id|where
comma
id|u32
id|value
)paren
(brace
r_int
id|r
op_assign
id|PCIBIOS_FUNC_NOT_SUPPORTED
suffix:semicolon
r_if
c_cond
(paren
id|alpha_mv.hose_write_config_dword
)paren
(brace
id|r
op_assign
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|where
op_amp
l_int|3
)paren
)paren
id|r
op_assign
(paren
id|alpha_mv.hose_write_config_dword
(paren
id|bus
comma
id|dev
comma
id|where
comma
id|value
comma
id|bus2hose
(braket
id|bus
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_pciconfig_read
id|sys_pciconfig_read
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|ubyte
suffix:semicolon
r_int
r_int
id|ushort
suffix:semicolon
r_int
r_int
id|uint
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|1
suffix:colon
id|err
op_assign
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|ubyte
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ubyte
comma
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|err
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|ushort
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ushort
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|err
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|uint
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|uint
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_pciconfig_write
id|sys_pciconfig_write
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|ubyte
suffix:semicolon
r_int
r_int
id|ushort
suffix:semicolon
r_int
r_int
id|uint
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|1
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|ubyte
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|err
op_assign
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|ubyte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|ushort
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|err
op_assign
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|ushort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|uint
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|err
op_assign
id|pcibios_write_config_dword
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|uint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PCIBIOS_SUCCESSFUL
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Gory details start here...&n; */
multiline_comment|/*&n; * Align VAL to ALIGN, which must be a power of two.&n; */
DECL|macro|ALIGN
mdefine_line|#define ALIGN(val,align)&t;(((val) + ((align) - 1)) &amp; ~((align) - 1))
multiline_comment|/* &n; * The following structure records initial configuration of devices&n; * so that we can reset them on shutdown and so enable clean reboots&n; * on SRM.  It is more trouble than it iw worth to conditionalize this.&n; */
DECL|struct|srm_irq_reset
r_struct
id|srm_irq_reset
(brace
DECL|member|next
r_struct
id|srm_irq_reset
op_star
id|next
suffix:semicolon
DECL|member|dev
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
DECL|member|irq
id|u8
id|irq
suffix:semicolon
DECL|variable|srm_irq_resets
)brace
op_star
id|srm_irq_resets
suffix:semicolon
DECL|struct|srm_io_reset
r_struct
id|srm_io_reset
(brace
DECL|member|next
r_struct
id|srm_io_reset
op_star
id|next
suffix:semicolon
DECL|member|dev
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
DECL|member|io
id|u32
id|io
suffix:semicolon
DECL|member|reg
id|u8
id|reg
suffix:semicolon
DECL|variable|srm_io_resets
)brace
op_star
id|srm_io_resets
suffix:semicolon
multiline_comment|/* Apply the collected reset modifications.  */
r_void
DECL|function|reset_for_srm
id|reset_for_srm
c_func
(paren
r_void
)paren
(brace
r_struct
id|srm_irq_reset
op_star
id|qreset
suffix:semicolon
r_struct
id|srm_io_reset
op_star
id|ireset
suffix:semicolon
multiline_comment|/* Reset any IRQs that we changed.  */
r_for
c_loop
(paren
id|qreset
op_assign
id|srm_irq_resets
suffix:semicolon
id|qreset
suffix:semicolon
id|qreset
op_assign
id|qreset-&gt;next
)paren
(brace
id|pcibios_write_config_byte
c_func
(paren
id|qreset-&gt;dev-&gt;bus-&gt;number
comma
id|qreset-&gt;dev-&gt;devfn
comma
id|PCI_INTERRUPT_LINE
comma
id|qreset-&gt;irq
)paren
suffix:semicolon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;reset_for_srm: bus %d slot 0x%x &quot;
l_string|&quot;SRM IRQ 0x%x changed back from 0x%x&bslash;n&quot;
comma
id|qreset-&gt;dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|qreset-&gt;dev-&gt;devfn
)paren
comma
id|qreset-&gt;irq
comma
id|qreset-&gt;dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Reset any IO addresses that we changed.  */
r_for
c_loop
(paren
id|ireset
op_assign
id|srm_io_resets
suffix:semicolon
id|ireset
suffix:semicolon
id|ireset
op_assign
id|ireset-&gt;next
)paren
(brace
id|pcibios_write_config_dword
c_func
(paren
id|ireset-&gt;dev-&gt;bus-&gt;number
comma
id|ireset-&gt;dev-&gt;devfn
comma
id|ireset-&gt;reg
comma
id|ireset-&gt;io
)paren
suffix:semicolon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;reset_for_srm: bus %d slot 0x%x &quot;
l_string|&quot;SRM MEM/IO restored to 0x%x&bslash;n&quot;
comma
id|ireset-&gt;dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|ireset-&gt;dev-&gt;devfn
)paren
comma
id|ireset-&gt;io
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_static
r_void
DECL|function|new_irq_reset
id|new_irq_reset
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|u8
id|irq
)paren
(brace
r_struct
id|srm_irq_reset
op_star
id|n
suffix:semicolon
id|n
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|n
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|n-&gt;next
op_assign
id|srm_irq_resets
suffix:semicolon
id|n-&gt;dev
op_assign
id|dev
suffix:semicolon
id|n-&gt;irq
op_assign
id|irq
suffix:semicolon
id|srm_irq_resets
op_assign
id|n
suffix:semicolon
)brace
r_static
r_void
DECL|function|new_io_reset
id|new_io_reset
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|u8
id|reg
comma
id|u32
id|io
)paren
(brace
r_struct
id|srm_io_reset
op_star
id|n
suffix:semicolon
id|n
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|n
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|n-&gt;next
op_assign
id|srm_io_resets
suffix:semicolon
id|n-&gt;dev
op_assign
id|dev
suffix:semicolon
id|n-&gt;reg
op_assign
id|reg
suffix:semicolon
id|n-&gt;io
op_assign
id|io
suffix:semicolon
id|srm_io_resets
op_assign
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable PCI device DEV so that it does not respond to I/O or memory&n; * accesses.&n; */
r_static
r_void
id|__init
DECL|function|disable_dev
id|disable_dev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t; * HACK: the PCI-to-EISA bridge does not seem to identify&n;&t; *       itself as a bridge... :-(&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_INTEL_82375
)paren
(brace
id|dev
op_member_access_from_pointer
r_class
op_assign
id|PCI_CLASS_BRIDGE_EISA
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;disable_dev: ignoring PCEB...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_INTEL_82378
)paren
(brace
id|dev
op_member_access_from_pointer
r_class
op_assign
id|PCI_CLASS_BRIDGE_ISA
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;disable_dev: ignoring SIO...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t have code that will init the CYPRESS bridge correctly&n;&t; * so we do the next best thing, and depend on the previous&n;&t; * console code to do the right thing, and ignore it here... :-&bslash;&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CONTAQ
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_CONTAQ_82C693
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;disable_dev: ignoring CYPRESS bridge...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if DEBUG_DEVS &amp;&amp; 0
multiline_comment|/* Worse HACK: Don&squot;t disable the video card, so I can see where&n;&t;   it is *really* falling over.  */
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;disable_dev: ignoring video card %04x:%04x&bslash;n&quot;
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;disable_dev: disabling %04x:%04x&bslash;n&quot;
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
)paren
)paren
suffix:semicolon
id|bus
op_assign
id|dev-&gt;bus
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/* hack, turn it off first... */
id|cmd
op_and_assign
(paren
op_complement
id|PCI_COMMAND_IO
op_amp
op_complement
id|PCI_COMMAND_MEMORY
op_amp
op_complement
id|PCI_COMMAND_MASTER
)paren
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Layout memory and I/O for a device:&n; */
DECL|macro|MAX
mdefine_line|#define MAX(val1, val2) ((val1) &gt; (val2) ? (val1) : (val2))
DECL|variable|io_base
r_static
r_int
r_int
id|io_base
suffix:semicolon
DECL|variable|mem_base
r_static
r_int
r_int
id|mem_base
suffix:semicolon
r_static
r_void
id|__init
DECL|function|layout_dev
id|layout_dev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|base
comma
id|mask
comma
id|size
comma
id|off
comma
id|idx
suffix:semicolon
r_int
r_int
id|orig_base
suffix:semicolon
r_int
r_int
id|alignto
suffix:semicolon
r_int
r_int
id|handle
suffix:semicolon
multiline_comment|/*&n;&t; * HACK: the PCI-to-EISA bridge does not seem to identify&n;&t; *       itself as a bridge... :-(&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_INTEL_82375
)paren
(brace
id|dev
op_member_access_from_pointer
r_class
op_assign
id|PCI_CLASS_BRIDGE_EISA
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: ignoring PCEB...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_INTEL_82378
)paren
(brace
id|dev
op_member_access_from_pointer
r_class
op_assign
id|PCI_CLASS_BRIDGE_ISA
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: ignoring SIO...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CONTAQ
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_CONTAQ_82C693
op_logical_and
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_BRIDGE_ISA
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: ignoring CYPRESS bridge...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bus
op_assign
id|dev-&gt;bus
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
op_le
l_int|5
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|off
op_assign
id|PCI_BASE_ADDRESS_0
op_plus
l_int|4
op_star
id|idx
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Figure out how much space and of what type this&n;&t;&t; * device wants.&n;&t;&t; */
id|pcibios_read_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|off
comma
op_amp
id|orig_base
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|off
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|off
comma
op_amp
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
multiline_comment|/* This base-address register is unused.  */
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: slot %d fn %d off 0x%x base 0x%x&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|off
comma
id|base
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We&squot;ve read the base address register back after&n;&t;&t; * writing all ones and so now we must decode it.&n;&t;&t; */
r_if
c_cond
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * I/O space base address register.&n;&t;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|mask
op_assign
(paren
op_complement
id|base
op_lshift
l_int|1
)paren
op_or
l_int|0x1
suffix:semicolon
id|size
op_assign
(paren
id|mask
op_amp
id|base
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* We don&squot;t want to disturb normal IDE functions, so&n;&t;&t;&t;   we don&squot;t touch the first two I/O ports on the&n;&t;&t;&t;   Cypress.  */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CONTAQ
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_CONTAQ_82C693
op_logical_and
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_BRIDGE_ISA
op_logical_and
id|idx
OL
l_int|2
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Aligning to 0x800 rather than the minimum base of&n;&t;&t;&t; * 0x400 is an attempt to avoid having devices in &n;&t;&t;&t; * any 0x?C?? range, which is where the de4x5 driver&n;&t;&t;&t; * probes for EISA cards.&n;&t;&t;&t; *&n;&t;&t;&t; * Adaptecs, especially, resent such intrusions.&n;&t;&t;&t; */
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x800
comma
id|size
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
id|alignto
)paren
suffix:semicolon
id|io_base
op_assign
id|base
op_plus
id|size
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|off
comma
id|base
op_or
l_int|0x1
)paren
suffix:semicolon
id|new_io_reset
c_func
(paren
id|dev
comma
id|off
comma
id|orig_base
)paren
suffix:semicolon
id|handle
op_assign
id|PCI_HANDLE
c_func
(paren
id|bus-&gt;number
)paren
op_or
id|base
op_or
l_int|1
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
id|handle
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_assign
id|handle
op_amp
op_complement
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: dev 0x%x IO @ 0x%lx (0x%x)&bslash;n&quot;
comma
id|dev-&gt;device
comma
id|handle
comma
id|size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|type
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Memory space base address register.&n;&t;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
id|type
op_assign
id|base
op_amp
id|PCI_BASE_ADDRESS_MEM_TYPE_MASK
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|mask
op_assign
(paren
op_complement
id|base
op_lshift
l_int|1
)paren
op_or
l_int|0x1
suffix:semicolon
id|size
op_assign
(paren
id|mask
op_amp
id|base
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_32
suffix:colon
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_64
suffix:colon
r_break
suffix:semicolon
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_1M
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Allocating memory below 1MB is *very*&n;&t;&t;&t;&t; * tricky, as there may be all kinds of&n;&t;&t;&t;&t; * ISA devices lurking that we don&squot;t know&n;&t;&t;&t;&t; * about.  For now, we just cross fingers&n;&t;&t;&t;&t; * and hope nobody tries to do this on an&n;&t;&t;&t;&t; * Alpha (or that the console has set it&n;&t;&t;&t;&t; * up properly).&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: slot %d, function %d&quot;
l_string|&quot; requests memory below 1MB---don&squot;t&quot;
l_string|&quot; know how to do that.&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * The following holds at least for the Low Cost&n;&t;&t;&t; * Alpha implementation of the PCI interface:&n;&t;&t;&t; *&n;&t;&t;&t; * In sparse memory address space, the first&n;&t;&t;&t; * octant (16MB) of every 128MB segment is&n;&t;&t;&t; * aliased to the very first 16 MB of the&n;&t;&t;&t; * address space (i.e., it aliases the ISA&n;&t;&t;&t; * memory address space).  Thus, we try to&n;&t;&t;&t; * avoid allocating PCI devices in that range.&n;&t;&t;&t; * Can be allocated in 2nd-7th octant only.&n;&t;&t;&t; * Devices that need more than 112MB of&n;&t;&t;&t; * address space must be accessed through&n;&t;&t;&t; * dense memory space only!&n;&t;&t;&t; */
multiline_comment|/* align to multiple of size of minimum base */
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x1000
comma
id|size
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
id|alignto
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|7
op_star
l_int|16
op_star
id|MB
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: slot %d, function %d&quot;
l_string|&quot; requests 0x%x bytes of contiguous&quot;
l_string|&quot; address space---don&squot;t use sparse&quot;
l_string|&quot; memory accesses on this device!!&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
(paren
id|base
op_div
(paren
l_int|16
op_star
id|MB
)paren
)paren
op_amp
l_int|0x7
)paren
op_eq
l_int|0
)paren
(brace
id|base
op_and_assign
op_complement
(paren
l_int|128
op_star
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|base
op_add_assign
l_int|16
op_star
id|MB
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|base
comma
id|alignto
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_div
(paren
l_int|128
op_star
id|MB
)paren
op_ne
(paren
id|base
op_plus
id|size
)paren
op_div
(paren
l_int|128
op_star
id|MB
)paren
)paren
(brace
id|base
op_and_assign
op_complement
(paren
l_int|128
op_star
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|base
op_add_assign
(paren
l_int|128
op_plus
l_int|16
)paren
op_star
id|MB
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|base
comma
id|alignto
)paren
suffix:semicolon
)brace
)brace
id|mem_base
op_assign
id|base
op_plus
id|size
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|off
comma
id|base
)paren
suffix:semicolon
id|new_io_reset
c_func
(paren
id|dev
comma
id|off
comma
id|orig_base
)paren
suffix:semicolon
id|handle
op_assign
id|PCI_HANDLE
c_func
(paren
id|bus-&gt;number
)paren
op_or
id|base
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_assign
id|handle
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|start
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_assign
id|handle
op_amp
op_complement
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Currently for 64-bit cards, we simply do the usual&n;&t;&t;&t; * for setup of the first register (low) of the pair,&n;&t;&t;&t; * and then clear out the second (high) register, as&n;&t;&t;&t; * we are not yet able to do 64-bit addresses, and&n;&t;&t;&t; * setting the high register to 0 allows 32-bit SAC&n;&t;&t;&t; * addresses to be used.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|PCI_BASE_ADDRESS_MEM_TYPE_64
)paren
(brace
r_int
r_int
id|orig_base2
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|off
op_plus
l_int|4
comma
op_amp
id|orig_base2
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|orig_base2
)paren
(brace
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|off
op_plus
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|new_io_reset
(paren
id|dev
comma
id|off
op_plus
l_int|4
comma
id|orig_base2
)paren
suffix:semicolon
)brace
multiline_comment|/* Bypass hi reg in the loop.  */
id|dev-&gt;resource
(braket
op_increment
id|idx
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|end
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;resource
(braket
id|idx
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: &quot;
l_string|&quot;handling 64-bit device in &quot;
l_string|&quot;slot %d, function %d: &bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
suffix:semicolon
)brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: dev 0x%x MEM @ 0x%lx (0x%x)&bslash;n&quot;
comma
id|dev-&gt;device
comma
id|handle
comma
id|size
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Enable device: */
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_STORAGE_IDE
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
multiline_comment|/*&n;&t;&t; * All of these (may) have I/O scattered all around&n;&t;&t; * and may not use i/o-base address registers at all.&n;&t;&t; * So we just have to always enable I/O to these&n;&t;&t; * devices.&n;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
)brace
id|pcibios_write_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|cmd
op_or
id|PCI_COMMAND_MASTER
)paren
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: bus %d slot %d VID 0x%x DID 0x%x&quot;
l_string|&quot; class 0x%x cmd 0 x%x&bslash;n&quot;
comma
id|bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|dev
op_member_access_from_pointer
r_class
comma
id|cmd
op_or
id|PCI_COMMAND_MASTER
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|layout_bus
id|layout_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_int
r_int
id|l
comma
id|tio
comma
id|bio
comma
id|tmem
comma
id|bmem
suffix:semicolon
r_struct
id|pci_bus
op_star
id|child
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_int
id|found_vga
op_assign
l_int|0
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus-&gt;devices
op_logical_and
op_logical_neg
id|bus-&gt;children
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Align the current bases on appropriate boundaries (4K for&n;&t; * IO and 1MB for memory).&n;&t; */
id|bio
op_assign
id|io_base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
l_int|4
op_star
id|KB
)paren
suffix:semicolon
id|bmem
op_assign
id|mem_base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
l_int|1
op_star
id|MB
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There are times when the PCI devices have already been&n;&t; * setup (e.g., by MILO or SRM).  In these cases there is a&n;&t; * window during which two devices may have an overlapping&n;&t; * address range.  To avoid this causing trouble, we first&n;&t; * turn off the I/O and memory address decoders for all PCI&n;&t; * devices.  They&squot;ll be re-enabled only once all address&n;&t; * decoders are programmed consistently.&n;&t; */
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: disable_dev for bus %d&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|bus-&gt;devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_BRIDGE_PCMCIA
)paren
)paren
(brace
id|disable_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allocate space to each device:&n;&t; */
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d devices&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|bus-&gt;devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
op_logical_or
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_BRIDGE_PCMCIA
)paren
)paren
(brace
id|layout_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_DISPLAY_VGA
)paren
id|found_vga
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Recursively allocate space for all of the sub-buses:&n;&t; */
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d children&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|child
op_assign
id|bus-&gt;children
suffix:semicolon
id|child
suffix:semicolon
id|child
op_assign
id|child-&gt;next
)paren
(brace
id|found_vga
op_add_assign
id|layout_bus
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Align the current bases on 4K and 1MB boundaries:&n;&t; */
id|tio
op_assign
id|io_base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
l_int|4
op_star
id|KB
)paren
suffix:semicolon
id|tmem
op_assign
id|mem_base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
l_int|1
op_star
id|MB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
r_struct
id|pci_dev
op_star
id|bridge
op_assign
id|bus-&gt;self
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: config bus %d bridge&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up the top and bottom of the PCI I/O segment&n;&t;&t; * for this bus.&n;&t;&t; */
id|pcibios_read_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_IO_BASE
comma
op_amp
id|l
)paren
suffix:semicolon
id|l
op_and_assign
l_int|0xffff0000
suffix:semicolon
id|l
op_or_assign
(paren
(paren
id|bio
op_rshift
l_int|8
)paren
op_amp
l_int|0x00f0
)paren
op_or
(paren
(paren
id|tio
op_minus
l_int|1
)paren
op_amp
l_int|0xf000
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_IO_BASE
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear out the upper 16 bits of IO base/limit.&n;&t;&t; * Clear out the upper 32 bits of PREF base/limit.&n;&t;&t; */
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_IO_BASE_UPPER16
comma
l_int|0
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_PREF_BASE_UPPER32
comma
l_int|0
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_PREF_LIMIT_UPPER32
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up the top and bottom of the PCI Memory segment&n;&t;&t; * for this bus.&n;&t;&t; */
id|l
op_assign
(paren
(paren
id|bmem
op_amp
l_int|0xfff00000
)paren
op_rshift
l_int|16
)paren
op_or
(paren
(paren
id|tmem
op_minus
l_int|1
)paren
op_amp
l_int|0xfff00000
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_MEMORY_BASE
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Turn off downstream PF memory address range, unless&n;&t;&t; * there is a VGA behind this bridge, in which case, we&n;&t;&t; * enable the PREFETCH range to include BIOS ROM at C0000.&n;&t;&t; *&n;&t;&t; * NOTE: this is a bit of a hack, done with PREFETCH for&n;&t;&t; * simplicity, rather than having to add it into the above&n;&t;&t; * non-PREFETCH range, which could then be bigger than we want.&n;&t;&t; * We might assume that we could relocate the BIOS ROM, but&n;&t;&t; * that would depend on having it found by those who need it&n;&t;&t; * (the DEC BIOS emulator would find it, but I do not know&n;&t;&t; * about the Xservers). So, we do it this way for now... ;-}&n;&t;&t; */
id|l
op_assign
(paren
id|found_vga
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x0000ffff
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_PREF_MEMORY_BASE
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Tell bridge that there is an ISA bus in the system,&n;&t;&t; * and (possibly) a VGA as well.&n;&t;&t; */
id|l
op_assign
(paren
id|found_vga
)paren
ques
c_cond
l_int|0x0c
suffix:colon
l_int|0x04
suffix:semicolon
id|pcibios_write_config_byte
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_BRIDGE_CONTROL
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear status bits,&n;&t;&t; * turn on I/O    enable (for downstream I/O),&n;&t;&t; * turn on memory enable (for downstream memory),&n;&t;&t; * turn on master enable (for upstream memory and I/O).&n;&t;&t; */
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
id|PCI_COMMAND
comma
l_int|0xffff0007
)paren
suffix:semicolon
)brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: bus %d finished&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_return
id|found_vga
suffix:semicolon
)brace
r_void
id|__init
DECL|function|layout_all_busses
id|layout_all_busses
c_func
(paren
r_int
r_int
id|default_io_base
comma
r_int
r_int
id|default_mem_base
)paren
(brace
r_struct
id|pci_bus
op_star
id|cur
suffix:semicolon
id|layout_hoses
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the tree, allocating PCI memory and I/O space.&n;&t; */
multiline_comment|/*&n;&t; * Sigh; check_region() will need changing to accept a PCI_HANDLE,&n;&t; * if we allocate I/O space addresses on a per-bus basis.&n;&t; * For now, make the I/O bases unique across all busses, so&n;&t; * that check_region() will not get confused... ;-}&n;&t; */
id|io_base
op_assign
id|default_io_base
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
op_amp
id|pci_root
suffix:semicolon
id|cur
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
id|mem_base
op_assign
id|default_mem_base
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_all_busses: calling layout_bus()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|layout_bus
c_func
(paren
id|cur
)paren
suffix:semicolon
)brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_all_busses: done.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The SRM console *disables* the IDE interface, this code ensures it&squot;s&n; * enabled.&n; *&n; * This code bangs on a control register of the 87312 Super I/O chip&n; * that implements parallel port/serial ports/IDE/FDI.  Depending on&n; * the motherboard, the Super I/O chip can be configured through a&n; * pair of registers that are located either at I/O ports 0x26e/0x26f&n; * or 0x398/0x399.  Unfortunately, autodetecting which base address is&n; * in use works only once (right after a reset).  The Super I/O chip&n; * has the additional quirk that configuration register data must be&n; * written twice (I believe this is a safety feature to prevent&n; * accidental modification---fun, isn&squot;t it?).&n; */
r_void
id|__init
DECL|function|enable_ide
id|enable_ide
c_func
(paren
r_int
id|ide_base
)paren
(brace
r_int
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ide_base
)paren
suffix:semicolon
multiline_comment|/* set the index register for reg #0 */
id|data
op_assign
id|inb
c_func
(paren
id|ide_base
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* read the current contents */
id|outb
c_func
(paren
l_int|0
comma
id|ide_base
)paren
suffix:semicolon
multiline_comment|/* set the index register for reg #0 */
id|outb
c_func
(paren
id|data
op_or
l_int|0x40
comma
id|ide_base
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* turn on IDE */
id|outb
c_func
(paren
id|data
op_or
l_int|0x40
comma
id|ide_base
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* turn on IDE, really! */
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Look for mis-configured devices&squot; I/O space addresses behind bridges.  */
r_static
r_void
DECL|function|check_behind_io
id|check_behind_io
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
op_assign
id|dev-&gt;bus
suffix:semicolon
r_int
r_int
id|reg
comma
id|orig_base
comma
id|new_base
comma
id|found_one
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
id|PCI_BASE_ADDRESS_0
suffix:semicolon
id|reg
op_le
id|PCI_BASE_ADDRESS_5
suffix:semicolon
id|reg
op_add_assign
l_int|4
)paren
(brace
multiline_comment|/* Read the current setting, check for I/O space and &gt;= 64K */
id|pcibios_read_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
op_amp
id|orig_base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|orig_base
op_logical_or
op_logical_neg
(paren
id|orig_base
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* unused or non-IO */
r_if
c_cond
(paren
id|orig_base
OL
l_int|64
op_star
l_int|1024
)paren
(brace
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;check_behind_io: ALREADY OK! bus %d slot %d base 0x%x&bslash;n&quot;
comma
id|bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|orig_base
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|orig_base
op_amp
op_complement
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* OK! */
id|orig_base
op_assign
l_int|0x12001
suffix:semicolon
multiline_comment|/* HACK! FIXME!! */
)brace
multiline_comment|/* HACK ALERT! for now, just subtract 32K from the&n;&t;&t;   original address, which should give us addresses&n;&t;&t;   in the range 0x8000 and up */
id|new_base
op_assign
id|orig_base
op_minus
l_int|0x8000
suffix:semicolon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;check_behind_io: ALERT! bus %d slot %d old 0x%x new 0x%x&bslash;n&quot;
comma
id|bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|orig_base
comma
id|new_base
)paren
suffix:semicolon
macro_line|#endif
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
id|new_base
)paren
suffix:semicolon
id|new_io_reset
c_func
(paren
id|dev
comma
id|reg
comma
id|orig_base
)paren
suffix:semicolon
id|found_one
op_increment
suffix:semicolon
)brace
multiline_comment|/* If any were modified, gotta hack the bridge IO limits too. */
r_if
c_cond
(paren
id|found_one
)paren
(brace
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
r_struct
id|pci_dev
op_star
id|bridge
op_assign
id|bus-&gt;self
suffix:semicolon
r_int
r_int
id|l
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set up the top and bottom of the PCI I/O segment&n;&t;&t;&t; * for this bus.&n;&t;&t;&t; */
id|pcibios_read_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x1c
comma
op_amp
id|l
)paren
suffix:semicolon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;check_behind_io: ALERT! bus %d slot %d oldLIM 0x%x&bslash;n&quot;
comma
id|bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|bridge-&gt;devfn
)paren
comma
id|l
)paren
suffix:semicolon
macro_line|#endif
id|l
op_assign
(paren
id|l
op_amp
l_int|0xffff0000U
)paren
op_or
l_int|0xf080U
suffix:semicolon
multiline_comment|/* give it ALL */
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x1c
comma
id|l
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x3c
comma
l_int|0x00040000
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bridge-&gt;bus-&gt;number
comma
id|bridge-&gt;devfn
comma
l_int|0x4
comma
l_int|0xffff0007
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;check_behind_io: WARNING! bus-&gt;self NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Most boards share most of the fixup code, which is isolated here.&n; */
r_void
id|__init
DECL|function|common_pci_fixup
id|common_pci_fixup
c_func
(paren
r_int
(paren
op_star
id|map_irq
)paren
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|slot
comma
r_int
id|pin
)paren
comma
r_int
(paren
op_star
id|swizzle
)paren
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
op_star
id|pin
)paren
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
id|u8
id|pin
comma
id|slot
comma
id|irq_orig
suffix:semicolon
r_int
id|irq
suffix:semicolon
multiline_comment|/*&n;&t; * Go through all devices, fixing up irqs as we see fit.&n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_eq
id|PCI_BASE_CLASS_BRIDGE
)paren
op_logical_and
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_ne
id|PCI_CLASS_BRIDGE_PCMCIA
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We don&squot;t have code that will init the CYPRESS bridge&n;&t;&t; * correctly so we do the next best thing, and depend on&n;&t;&t; * the previous console code to do the right thing, and&n;&t;&t; * ignore it here... :-&bslash;&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CONTAQ
op_logical_and
id|dev-&gt;device
op_eq
id|PCI_DEVICE_ID_CONTAQ_82C693
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;common_pci_fixup: ignoring CYPRESS bridge...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This device is not on the primary bus, we need&n;&t;&t; * to figure out which interrupt pin it will come&n;&t;&t; * in on.   We know which slot it will come in on&n;&t;&t; * &squot;cos that slot is where the bridge is.   Each&n;&t;&t; * time the interrupt line passes through a PCI-PCI&n;&t;&t; * bridge we must apply the swizzle function (see&n;&t;&t; * the inline static routine above).&n;&t;&t; */
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|pin
)paren
suffix:semicolon
multiline_comment|/* Cope with 0 and illegal. */
r_if
c_cond
(paren
id|pin
op_eq
l_int|0
op_logical_or
id|pin
OG
l_int|4
)paren
id|pin
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DEV_IS_ON_PRIMARY
c_func
(paren
id|dev
)paren
)paren
(brace
multiline_comment|/* Follow the chain of bridges, swizzling as we go.  */
r_int
id|spill
op_assign
id|pin
suffix:semicolon
id|slot
op_assign
(paren
op_star
id|swizzle
)paren
(paren
id|dev
comma
op_amp
id|spill
)paren
suffix:semicolon
id|pin
op_assign
id|spill
suffix:semicolon
multiline_comment|/* Must make sure that SRM didn&squot;t screw up&n;&t;&t;&t;   and allocate an address &gt; 64K for I/O&n;&t;&t;&t;   space behind a PCI-PCI bridge. */
r_if
c_cond
(paren
id|alpha_use_srm_setup
)paren
id|check_behind_io
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Just a device on a primary bus.  */
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
suffix:semicolon
)brace
id|irq
op_assign
(paren
op_star
id|map_irq
)paren
(paren
id|dev
comma
id|slot
comma
id|pin
)paren
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;common_pci_fixup: bus %d slot %d &quot;
l_string|&quot;pin %d irq %d&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|slot
comma
id|pin
comma
id|irq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
op_minus
l_int|1
)paren
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|alpha_using_srm
)paren
(brace
multiline_comment|/* Read the original SRM-set IRQ and tell. */
id|pcibios_read_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq_orig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_orig
op_ne
id|dev-&gt;irq
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;common_pci_fixup: bus %d &quot;
l_string|&quot;slot 0x%x SRM IRQ 0x%x &quot;
l_string|&quot;changed to 0x%x&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|irq_orig
comma
id|dev-&gt;irq
)paren
)paren
suffix:semicolon
id|new_irq_reset
c_func
(paren
id|dev
comma
id|irq_orig
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Always tell the device, so the driver knows what is&n;&t;&t;   the real IRQ to use; the device does not use it. */
id|pcibios_write_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_LINE
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;common_pci_fixup: bus %d slot 0x%x&quot;
l_string|&quot; VID 0x%x DID 0x%x&bslash;n&quot;
l_string|&quot;              int_slot 0x%x pin 0x%x&quot;
l_string|&quot; pirq 0x%x&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|slot
comma
id|pin
comma
id|dev-&gt;irq
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s a VGA, enable its BIOS ROM at C0000.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_DISPLAY_VGA
)paren
(brace
multiline_comment|/* But if its a Cirrus 543x/544x DISABLE it,&n;&t;&t;&t;   since enabling ROM disables the memory... */
r_if
c_cond
(paren
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_CIRRUS
)paren
op_logical_and
(paren
id|dev-&gt;device
op_ge
l_int|0x00a0
)paren
op_logical_and
(paren
id|dev-&gt;device
op_le
l_int|0x00ac
)paren
)paren
(brace
id|pcibios_write_config_dword
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_ROM_ADDRESS
comma
l_int|0x00000000
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcibios_write_config_dword
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_ROM_ADDRESS
comma
l_int|0x000c0000
op_or
id|PCI_ROM_ADDRESS_ENABLE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If it&squot;s a SCSI, disable its BIOS ROM.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_STORAGE_SCSI
)paren
(brace
id|pcibios_write_config_dword
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_ROM_ADDRESS
comma
l_int|0x0000000
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Most Alphas have straight-forward swizzling needs.  */
r_int
id|__init
DECL|function|common_swizzle
id|common_swizzle
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
op_star
id|pinp
)paren
(brace
r_int
id|pin
op_assign
op_star
id|pinp
suffix:semicolon
r_do
(brace
id|pin
op_assign
id|bridge_swizzle
c_func
(paren
id|pin
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
suffix:semicolon
multiline_comment|/* Move up the chain of bridges. */
id|dev
op_assign
id|dev-&gt;bus-&gt;self
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dev-&gt;bus-&gt;self
)paren
suffix:semicolon
op_star
id|pinp
op_assign
id|pin
suffix:semicolon
multiline_comment|/* The slot is the slot of the last bridge. */
r_return
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On multiple bus machines, in order to cope with a somewhat deficient&n; * API, we must map the 8-bit bus identifier so that it is unique across&n; * multiple interfaces (hoses).  At the same time we do this, chain the&n; * other hoses off of pci_root so that they will be found during normal&n; * PCI probing and layout.&n; */
DECL|macro|PRIMARY
mdefine_line|#define PRIMARY(b)&t;((b)&amp;0xff)
DECL|macro|SECONDARY
mdefine_line|#define SECONDARY(b)&t;(((b)&gt;&gt;8)&amp;0xff)
DECL|macro|SUBORDINATE
mdefine_line|#define SUBORDINATE(b)&t;(((b)&gt;&gt;16)&amp;0xff)
r_static
r_int
id|__init
DECL|function|hose_scan_bridges
id|hose_scan_bridges
c_func
(paren
r_struct
id|linux_hose_info
op_star
id|hose
comma
r_int
r_char
id|bus
)paren
(brace
r_int
r_int
id|devfn
comma
id|l
comma
r_class
suffix:semicolon
r_int
r_char
id|hdr_type
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|devfn
op_assign
l_int|0
suffix:semicolon
id|devfn
OL
l_int|0xff
suffix:semicolon
op_increment
id|devfn
)paren
(brace
r_if
c_cond
(paren
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
op_eq
l_int|0
)paren
(brace
id|alpha_mv
dot
id|hose_read_config_byte
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|hdr_type
comma
id|hose
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|hdr_type
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* not a multi-function device */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Check if there is anything here. */
id|alpha_mv
dot
id|hose_read_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|l
comma
id|hose
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0xffffffff
op_logical_or
id|l
op_eq
l_int|0x00000000
)paren
(brace
id|hdr_type
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* See if this is a bridge device. */
id|alpha_mv
dot
id|hose_read_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_CLASS_REVISION
comma
op_amp
r_class
comma
id|hose
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_class
op_rshift
l_int|16
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
(brace
r_int
r_int
id|busses
suffix:semicolon
id|found
op_increment
suffix:semicolon
id|alpha_mv
dot
id|hose_read_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_PRIMARY_BUS
comma
op_amp
id|busses
comma
id|hose
)paren
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;hose_scan_bridges: hose %d bus %d &quot;
l_string|&quot;slot %d busses 0x%x&bslash;n&quot;
comma
id|hose-&gt;pci_hose_index
comma
id|bus
comma
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
comma
id|busses
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Do something with first_busno and last_busno&n;&t;&t;&t; */
r_if
c_cond
(paren
id|hose-&gt;pci_first_busno
OG
id|PRIMARY
c_func
(paren
id|busses
)paren
)paren
(brace
id|hose-&gt;pci_first_busno
op_assign
id|PRIMARY
c_func
(paren
id|busses
)paren
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;hose_scan_bridges: hose %d bus %d &quot;
l_string|&quot;slot %d change first to %d&bslash;n&quot;
comma
id|hose-&gt;pci_hose_index
comma
id|bus
comma
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
comma
id|PRIMARY
c_func
(paren
id|busses
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hose-&gt;pci_last_busno
OL
id|SUBORDINATE
c_func
(paren
id|busses
)paren
)paren
(brace
id|hose-&gt;pci_last_busno
op_assign
id|SUBORDINATE
c_func
(paren
id|busses
)paren
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;hose_scan_bridges: hose %d bus %d &quot;
l_string|&quot;slot %d change last to %d&bslash;n&quot;
comma
id|hose-&gt;pci_hose_index
comma
id|bus
comma
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
comma
id|SUBORDINATE
c_func
(paren
id|busses
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Now scan everything underneath the bridge.&n;&t;&t;&t; */
id|hose_scan_bridges
c_func
(paren
id|hose
comma
id|SECONDARY
c_func
(paren
id|busses
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|found
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|hose_reconfigure_bridges
id|hose_reconfigure_bridges
c_func
(paren
r_struct
id|linux_hose_info
op_star
id|hose
comma
r_int
r_char
id|bus
)paren
(brace
r_int
r_int
id|devfn
comma
id|l
comma
r_class
suffix:semicolon
r_int
r_char
id|hdr_type
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|devfn
op_assign
l_int|0
suffix:semicolon
id|devfn
OL
l_int|0xff
suffix:semicolon
op_increment
id|devfn
)paren
(brace
r_if
c_cond
(paren
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
op_eq
l_int|0
)paren
(brace
id|alpha_mv
dot
id|hose_read_config_byte
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|hdr_type
comma
id|hose
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|hdr_type
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* not a multi-function device */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Check if there is anything here. */
id|alpha_mv
dot
id|hose_read_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|l
comma
id|hose
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0xffffffff
op_logical_or
id|l
op_eq
l_int|0x00000000
)paren
(brace
id|hdr_type
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* See if this is a bridge device. */
id|alpha_mv
dot
id|hose_read_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_CLASS_REVISION
comma
op_amp
r_class
comma
id|hose
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_class
op_rshift
l_int|16
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
(brace
r_int
r_int
id|busses
suffix:semicolon
id|alpha_mv
dot
id|hose_read_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_PRIMARY_BUS
comma
op_amp
id|busses
comma
id|hose
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * First reconfigure everything underneath the bridge.&n;&t;&t;&t; */
id|hose_reconfigure_bridges
c_func
(paren
id|hose
comma
(paren
id|busses
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Unconfigure this bridges bus numbers,&n;&t;&t;&t; * pci_scan_bus() will fix this up properly.&n;&t;&t;&t; */
id|busses
op_and_assign
l_int|0xff000000
suffix:semicolon
id|alpha_mv
dot
id|hose_write_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_PRIMARY_BUS
comma
id|busses
comma
id|hose
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|__init
DECL|function|hose_fixup_busno
id|hose_fixup_busno
c_func
(paren
r_struct
id|linux_hose_info
op_star
id|hose
comma
r_int
r_char
id|bus
)paren
(brace
r_int
id|nbus
suffix:semicolon
multiline_comment|/*&n;&t; * First, scan for all bridge devices underneath this hose,&n;&t; * to determine the first and last busnos.&n;&t; */
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;hose_fixup_busno: before hose_scan_bridges()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hose_scan_bridges
c_func
(paren
id|hose
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* none found, exit */
id|hose-&gt;pci_first_busno
op_assign
id|bus
suffix:semicolon
id|hose-&gt;pci_last_busno
op_assign
id|bus
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Reconfigure all bridge devices underneath this hose.&n;&t;&t; */
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;hose_fixup_busno: before hose_reconfigure_bridges&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|hose_reconfigure_bridges
c_func
(paren
id|hose
comma
id|hose-&gt;pci_first_busno
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now reconfigure the hose to it&squot;s new bus number and set up&n;&t; * our bus2hose mapping for this hose.&n;&t; */
id|nbus
op_assign
id|hose-&gt;pci_last_busno
op_minus
id|hose-&gt;pci_first_busno
suffix:semicolon
id|hose-&gt;pci_first_busno
op_assign
id|bus
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;hose_fixup_busno: hose %d startbus %d nbus %d&bslash;n&quot;
comma
id|hose-&gt;pci_hose_index
comma
id|bus
comma
id|nbus
)paren
)paren
suffix:semicolon
r_do
(brace
id|bus2hose
(braket
id|bus
op_increment
)braket
op_assign
id|hose
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nbus
op_decrement
OG
l_int|0
)paren
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;hose_fixup_busno: returning...&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|layout_one_hose
id|layout_one_hose
c_func
(paren
r_struct
id|linux_hose_info
op_star
id|hose
)paren
(brace
r_static
r_struct
id|pci_bus
op_star
id|pchain
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pbus
op_assign
op_amp
id|hose-&gt;pci_bus
suffix:semicolon
r_static
r_int
r_char
id|busno
op_assign
l_int|0
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;layout_one_hose: entry&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hoses include child PCI bridges in bus-range property,&n;&t; * but we don&squot;t scan each of those ourselves, Linux generic PCI&n;&t; * probing code will find child bridges and link them into this&n;&t; * hose&squot;s root PCI device hierarchy.&n;&t; */
id|pbus-&gt;number
op_assign
id|pbus-&gt;secondary
op_assign
id|busno
suffix:semicolon
id|pbus-&gt;sysdata
op_assign
id|hose
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;layout_one_hose: before hose_fixup_busno()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|hose_fixup_busno
c_func
(paren
id|hose
comma
id|busno
)paren
suffix:semicolon
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;layout_one_hose: before pci_scan_bus()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pbus-&gt;subordinate
op_assign
id|pci_scan_bus
c_func
(paren
id|pbus
)paren
suffix:semicolon
multiline_comment|/* the original! */
multiline_comment|/*&n;&t; * Set the maximum subordinate bus of this hose.&n;&t; */
id|hose-&gt;pci_last_busno
op_assign
id|pbus-&gt;subordinate
suffix:semicolon
macro_line|#if 0
id|alpha_mv
dot
id|hose_write_config_byte
c_func
(paren
id|busno
comma
l_int|0
comma
l_int|0x41
comma
id|hose-&gt;pci_last_busno
comma
id|hose
)paren
suffix:semicolon
macro_line|#endif
id|busno
op_assign
id|pbus-&gt;subordinate
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Fixup the chain of primary PCI busses.&n;&t; */
r_if
c_cond
(paren
id|pchain
)paren
(brace
id|pchain-&gt;next
op_assign
op_amp
id|hose-&gt;pci_bus
suffix:semicolon
id|pchain
op_assign
id|pchain-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|pchain
op_assign
op_amp
id|pci_root
suffix:semicolon
id|memcpy
c_func
(paren
id|pchain
comma
op_amp
id|hose-&gt;pci_bus
comma
r_sizeof
(paren
id|pci_root
)paren
)paren
suffix:semicolon
)brace
id|DBG_HOSE
c_func
(paren
(paren
l_string|&quot;layout_one_hose: returning...&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|layout_hoses
id|layout_hoses
c_func
(paren
r_void
)paren
(brace
r_struct
id|linux_hose_info
op_star
id|hose
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* On multiple bus machines, we play games with pci_root in order&n;&t;   that all of the busses are probed as part of the normal PCI&n;&t;   setup.  The existance of the busses was determined in init_arch.  */
r_if
c_cond
(paren
id|hose_head
)paren
(brace
multiline_comment|/* Multi-bus machines did not yet wish to allow bus&n;&t;&t;   accesses.  We now do our own thing after the normal&n;&t;&t;   pci_scan_bus is over.  This mechanism is relatively&n;&t;&t;   broken but will be fixed later.  */
id|pci_probe_enabled
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|hose
op_assign
id|hose_head
suffix:semicolon
id|hose
suffix:semicolon
id|hose
op_assign
id|hose-&gt;next
)paren
id|layout_one_hose
c_func
(paren
id|hose
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* For the benefit of single-bus machines, emulate a&n;&t;&t;   multi-bus machine to the (limited) extent necessary. &n;&t;&t;   Init all bus2hose entries to point to a dummy.  */
id|hose
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hose
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hose
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|hose
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
op_increment
id|i
)paren
id|bus2hose
(braket
id|i
)braket
op_assign
id|hose
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_PCI */
eof
