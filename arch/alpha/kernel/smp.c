multiline_comment|/*&n; *&t;linux/arch/alpha/kernel/smp.c&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/hwrpb.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;asm/unistd.h&gt;
macro_line|#include &quot;proto.h&quot;
macro_line|#include &quot;irq_impl.h&quot;
DECL|macro|DEBUG_SMP
mdefine_line|#define DEBUG_SMP 0
macro_line|#if DEBUG_SMP
DECL|macro|DBGS
mdefine_line|#define DBGS(args)&t;printk args
macro_line|#else
DECL|macro|DBGS
mdefine_line|#define DBGS(args)
macro_line|#endif
multiline_comment|/* A collection of per-processor data.  */
DECL|variable|cpu_data
r_struct
id|cpuinfo_alpha
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* A collection of single bit ipi messages.  */
r_static
r_struct
(brace
DECL|member|____cacheline_aligned
r_int
r_int
id|bits
id|____cacheline_aligned
suffix:semicolon
DECL|variable|__cacheline_aligned
)brace
id|ipi_data
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
DECL|enum|ipi_message_type
r_enum
id|ipi_message_type
(brace
DECL|enumerator|IPI_RESCHEDULE
id|IPI_RESCHEDULE
comma
DECL|enumerator|IPI_CALL_FUNC
id|IPI_CALL_FUNC
comma
DECL|enumerator|IPI_CPU_STOP
id|IPI_CPU_STOP
comma
)brace
suffix:semicolon
DECL|variable|kernel_flag
id|spinlock_t
id|kernel_flag
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Set to a secondary&squot;s cpuid when it comes online.  */
DECL|variable|smp_secondary_alive
r_static
r_int
r_int
id|smp_secondary_alive
suffix:semicolon
multiline_comment|/* Which cpus ids came online.  */
DECL|variable|cpu_present_mask
r_int
r_int
id|cpu_present_mask
suffix:semicolon
multiline_comment|/* cpus reported in the hwrpb */
DECL|variable|__initdata
r_static
r_int
r_int
id|hwrpb_cpu_present_mask
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|max_cpus
r_static
r_int
id|max_cpus
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Command-line limitation.  */
DECL|variable|smp_num_probed
r_int
id|smp_num_probed
suffix:semicolon
multiline_comment|/* Internal processor count */
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number that came online.  */
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
suffix:semicolon
multiline_comment|/* True once the per process idle is forked. */
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
DECL|variable|__cpu_number_map
r_int
id|__cpu_number_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|__cpu_logical_map
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entInt
c_func
(paren
r_void
)paren
suffix:semicolon
"&f;"
DECL|function|nosmp
r_static
r_int
id|__init
id|nosmp
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|max_cpus
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nosmp&quot;
comma
id|nosmp
)paren
suffix:semicolon
DECL|function|maxcpus
r_static
r_int
id|__init
id|maxcpus
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|max_cpus
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;maxcpus&quot;
comma
id|maxcpus
)paren
suffix:semicolon
multiline_comment|/*&n; * Called by both boot and secondaries to move global data into&n; *  per-processor storage.&n; */
r_static
r_inline
r_void
id|__init
DECL|function|smp_store_cpu_info
id|smp_store_cpu_info
c_func
(paren
r_int
id|cpuid
)paren
(brace
id|cpu_data
(braket
id|cpuid
)braket
dot
id|loops_per_jiffy
op_assign
id|loops_per_jiffy
suffix:semicolon
id|cpu_data
(braket
id|cpuid
)braket
dot
id|last_asn
op_assign
id|ASN_FIRST_VERSION
suffix:semicolon
id|cpu_data
(braket
id|cpuid
)braket
dot
id|need_new_asn
op_assign
l_int|0
suffix:semicolon
id|cpu_data
(braket
id|cpuid
)braket
dot
id|asn_lock
op_assign
l_int|0
suffix:semicolon
id|local_irq_count
c_func
(paren
id|cpuid
)paren
op_assign
l_int|0
suffix:semicolon
id|local_bh_count
c_func
(paren
id|cpuid
)paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Ideally sets up per-cpu profiling hooks.  Doesn&squot;t do much now...&n; */
r_static
r_inline
r_void
id|__init
DECL|function|smp_setup_percpu_timer
id|smp_setup_percpu_timer
c_func
(paren
r_int
id|cpuid
)paren
(brace
id|cpu_data
(braket
id|cpuid
)braket
dot
id|prof_counter
op_assign
l_int|1
suffix:semicolon
id|cpu_data
(braket
id|cpuid
)braket
dot
id|prof_multiplier
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Where secondaries begin a life of C.&n; */
r_void
id|__init
DECL|function|smp_callin
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;CALLIN %d state 0x%lx&bslash;n&quot;
comma
id|cpuid
comma
id|current-&gt;state
)paren
)paren
suffix:semicolon
multiline_comment|/* Turn on machine checks.  */
id|wrmces
c_func
(paren
l_int|7
)paren
suffix:semicolon
multiline_comment|/* Set trap vectors.  */
id|trap_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set interrupt vector.  */
id|wrent
c_func
(paren
id|entInt
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Setup the scheduler for this processor.  */
id|init_idle
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ??? This should be in init_idle.  */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
multiline_comment|/* Get our local ticker going. */
id|smp_setup_percpu_timer
c_func
(paren
id|cpuid
)paren
suffix:semicolon
multiline_comment|/* Must have completely accurate bogos.  */
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
multiline_comment|/* Allow master to continue. */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|smp_secondary_alive
op_assign
id|cpuid
suffix:semicolon
multiline_comment|/* Wait for the go code.  */
r_while
c_loop
(paren
op_logical_neg
id|smp_threads_ready
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;smp_callin: commencing CPU %d current %p&bslash;n&quot;
comma
id|cpuid
comma
id|current
)paren
)paren
suffix:semicolon
multiline_comment|/* Do nothing.  */
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Rough estimation for SMP scheduling, this is the number of cycles it&n; * takes for a fully memory-limited process to flush the SMP-local cache.&n; *&n; * We are not told how much cache there is, so we have to guess.&n; */
r_static
r_void
id|__init
DECL|function|smp_tune_scheduling
id|smp_tune_scheduling
(paren
r_void
)paren
(brace
r_struct
id|percpu_struct
op_star
id|cpu
suffix:semicolon
r_int
r_int
id|on_chip_cache
suffix:semicolon
r_int
r_int
id|freq
suffix:semicolon
id|cpu
op_assign
(paren
r_struct
id|percpu_struct
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|hwrpb
op_plus
id|hwrpb-&gt;processor_offset
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cpu-&gt;type
)paren
(brace
r_case
id|EV45_CPU
suffix:colon
id|on_chip_cache
op_assign
l_int|16
op_plus
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EV5_CPU
suffix:colon
r_case
id|EV56_CPU
suffix:colon
id|on_chip_cache
op_assign
l_int|8
op_plus
l_int|8
op_plus
l_int|96
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCA56_CPU
suffix:colon
id|on_chip_cache
op_assign
l_int|16
op_plus
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EV6_CPU
suffix:colon
id|on_chip_cache
op_assign
l_int|64
op_plus
l_int|64
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|on_chip_cache
op_assign
l_int|8
op_plus
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
id|freq
op_assign
id|hwrpb-&gt;cycle_freq
ques
c_cond
suffix:colon
id|est_cycle_freq
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Magic estimation stolen from x86 port.  */
id|cacheflush_time
op_assign
id|freq
op_div
l_int|1024L
op_star
id|on_chip_cache
op_div
l_int|5000L
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using heuristic of %d cycles.&bslash;n&quot;
comma
id|cacheflush_time
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Magic value to force potential preemption of other CPUs.  */
id|cacheflush_time
op_assign
id|INT_MAX
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using heuristic of %d cycles.&bslash;n&quot;
comma
id|cacheflush_time
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Send a message to a secondary&squot;s console.  &quot;START&quot; is one such&n; * interesting message.  ;-)&n; */
r_static
r_void
DECL|function|send_secondary_console_msg
id|send_secondary_console_msg
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|cpuid
)paren
(brace
r_struct
id|percpu_struct
op_star
id|cpu
suffix:semicolon
r_register
r_char
op_star
id|cp1
comma
op_star
id|cp2
suffix:semicolon
r_int
r_int
id|cpumask
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|timeout
suffix:semicolon
id|cpu
op_assign
(paren
r_struct
id|percpu_struct
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|hwrpb
op_plus
id|hwrpb-&gt;processor_offset
op_plus
id|cpuid
op_star
id|hwrpb-&gt;processor_size
)paren
suffix:semicolon
id|cpumask
op_assign
(paren
l_int|1L
op_lshift
id|cpuid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwrpb-&gt;txrdy
op_amp
id|cpumask
)paren
r_goto
id|delay1
suffix:semicolon
id|ready1
suffix:colon
id|cp2
op_assign
id|str
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|cp2
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|cpu-&gt;ipc_buffer
(braket
l_int|0
)braket
op_assign
id|len
suffix:semicolon
id|cp1
op_assign
(paren
r_char
op_star
)paren
op_amp
id|cpu-&gt;ipc_buffer
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|cp1
comma
id|cp2
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* atomic test and set */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|cpuid
comma
op_amp
id|hwrpb-&gt;rxrdy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwrpb-&gt;txrdy
op_amp
id|cpumask
)paren
r_goto
id|delay2
suffix:semicolon
id|ready2
suffix:colon
r_return
suffix:semicolon
id|delay1
suffix:colon
multiline_comment|/* Wait one second.  Note that jiffies aren&squot;t ticking yet.  */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|100000
suffix:semicolon
id|timeout
OG
l_int|0
suffix:semicolon
op_decrement
id|timeout
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwrpb-&gt;txrdy
op_amp
id|cpumask
)paren
)paren
r_goto
id|ready1
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_goto
id|timeout
suffix:semicolon
id|delay2
suffix:colon
multiline_comment|/* Wait one second.  */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|100000
suffix:semicolon
id|timeout
OG
l_int|0
suffix:semicolon
op_decrement
id|timeout
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwrpb-&gt;txrdy
op_amp
id|cpumask
)paren
)paren
r_goto
id|ready2
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_goto
id|timeout
suffix:semicolon
id|timeout
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Processor %x not ready&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * A secondary console wants to send a message.  Receive it.&n; */
r_static
r_void
DECL|function|recv_secondary_console_msg
id|recv_secondary_console_msg
c_func
(paren
r_void
)paren
(brace
r_int
id|mycpu
comma
id|i
comma
id|cnt
suffix:semicolon
r_int
r_int
id|txrdy
op_assign
id|hwrpb-&gt;txrdy
suffix:semicolon
r_char
op_star
id|cp1
comma
op_star
id|cp2
comma
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_struct
id|percpu_struct
op_star
id|cpu
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;recv_secondary_console_msg: TXRDY 0x%lx.&bslash;n&quot;
comma
id|txrdy
)paren
)paren
suffix:semicolon
id|mycpu
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|txrdy
op_amp
(paren
l_int|1L
op_lshift
id|i
)paren
)paren
)paren
r_continue
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;recv_secondary_console_msg: &quot;
l_string|&quot;TXRDY contains CPU %d.&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
id|cpu
op_assign
(paren
r_struct
id|percpu_struct
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|hwrpb
op_plus
id|hwrpb-&gt;processor_offset
op_plus
id|i
op_star
id|hwrpb-&gt;processor_size
)paren
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;recv_secondary_console_msg: on %d from %d&quot;
l_string|&quot; HALT_REASON 0x%lx FLAGS 0x%lx&bslash;n&quot;
comma
id|mycpu
comma
id|i
comma
id|cpu-&gt;halt_reason
comma
id|cpu-&gt;flags
)paren
)paren
suffix:semicolon
id|cnt
op_assign
id|cpu-&gt;ipc_buffer
(braket
l_int|0
)braket
op_rshift
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
op_logical_or
id|cnt
op_ge
l_int|80
)paren
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;&lt;&lt;&lt; BOGUS MSG &gt;&gt;&gt;&quot;
)paren
suffix:semicolon
r_else
(brace
id|cp1
op_assign
(paren
r_char
op_star
)paren
op_amp
id|cpu-&gt;ipc_buffer
(braket
l_int|11
)braket
suffix:semicolon
id|cp2
op_assign
id|buf
suffix:semicolon
id|strcpy
c_func
(paren
id|cp2
comma
id|cp1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cp2
op_assign
id|strchr
c_func
(paren
id|cp2
comma
l_char|&squot;&bslash;r&squot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
op_star
id|cp2
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_if
c_cond
(paren
id|cp2
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|cp2
(braket
l_int|1
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
)brace
id|DBGS
c_func
(paren
(paren
id|KERN_INFO
l_string|&quot;recv_secondary_console_msg: on %d &quot;
l_string|&quot;message is &squot;%s&squot;&bslash;n&quot;
comma
id|mycpu
comma
id|buf
)paren
)paren
suffix:semicolon
)brace
id|hwrpb-&gt;txrdy
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Convince the console to have a secondary cpu begin execution.&n; */
r_static
r_int
id|__init
DECL|function|secondary_cpu_start
id|secondary_cpu_start
c_func
(paren
r_int
id|cpuid
comma
r_struct
id|task_struct
op_star
id|idle
)paren
(brace
r_struct
id|percpu_struct
op_star
id|cpu
suffix:semicolon
r_struct
id|pcb_struct
op_star
id|hwpcb
suffix:semicolon
r_int
id|timeout
suffix:semicolon
id|cpu
op_assign
(paren
r_struct
id|percpu_struct
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|hwrpb
op_plus
id|hwrpb-&gt;processor_offset
op_plus
id|cpuid
op_star
id|hwrpb-&gt;processor_size
)paren
suffix:semicolon
id|hwpcb
op_assign
(paren
r_struct
id|pcb_struct
op_star
)paren
id|cpu-&gt;hwpcb
suffix:semicolon
multiline_comment|/* Initialize the CPU&squot;s HWPCB to something just good enough for&n;&t;   us to get started.  Immediately after starting, we&squot;ll swpctx&n;&t;   to the target idle task&squot;s ptb.  Reuse the stack in the mean&n;&t;   time.  Precalculate the target PCBB.  */
id|hwpcb-&gt;ksp
op_assign
(paren
r_int
r_int
)paren
id|idle
op_plus
r_sizeof
(paren
r_union
id|task_union
)paren
op_minus
l_int|16
suffix:semicolon
id|hwpcb-&gt;usp
op_assign
l_int|0
suffix:semicolon
id|hwpcb-&gt;ptbr
op_assign
id|idle-&gt;thread.ptbr
suffix:semicolon
id|hwpcb-&gt;pcc
op_assign
l_int|0
suffix:semicolon
id|hwpcb-&gt;asn
op_assign
l_int|0
suffix:semicolon
id|hwpcb-&gt;unique
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|idle-&gt;thread
)paren
suffix:semicolon
id|hwpcb-&gt;flags
op_assign
id|idle-&gt;thread.pal_flags
suffix:semicolon
id|hwpcb-&gt;res1
op_assign
id|hwpcb-&gt;res2
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
id|DBGS
c_func
(paren
(paren
l_string|&quot;KSP 0x%lx PTBR 0x%lx VPTBR 0x%lx UNIQUE 0x%lx&bslash;n&quot;
comma
id|hwpcb-&gt;ksp
comma
id|hwpcb-&gt;ptbr
comma
id|hwrpb-&gt;vptb
comma
id|hwcpb-&gt;unique
)paren
)paren
suffix:semicolon
macro_line|#endif
id|DBGS
c_func
(paren
(paren
l_string|&quot;Starting secondary cpu %d: state 0x%lx pal_flags 0x%lx&bslash;n&quot;
comma
id|cpuid
comma
id|idle-&gt;state
comma
id|idle-&gt;thread.pal_flags
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup HWRPB fields that SRM uses to activate secondary CPU */
id|hwrpb-&gt;CPU_restart
op_assign
id|__smp_callin
suffix:semicolon
id|hwrpb-&gt;CPU_restart_data
op_assign
(paren
r_int
r_int
)paren
id|__smp_callin
suffix:semicolon
multiline_comment|/* Recalculate and update the HWRPB checksum */
id|hwrpb_update_checksum
c_func
(paren
id|hwrpb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send a &quot;start&quot; command to the specified processor.&n;&t; */
multiline_comment|/* SRM III 3.4.1.3 */
id|cpu-&gt;flags
op_or_assign
l_int|0x22
suffix:semicolon
multiline_comment|/* turn on Context Valid and Restart Capable */
id|cpu-&gt;flags
op_and_assign
op_complement
l_int|1
suffix:semicolon
multiline_comment|/* turn off Bootstrap In Progress */
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|send_secondary_console_msg
c_func
(paren
l_string|&quot;START&bslash;r&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
multiline_comment|/* Wait 1 second for an ACK from the console.  Note that jiffies &n;&t;   aren&squot;t ticking yet.  */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|100000
suffix:semicolon
id|timeout
OG
l_int|0
suffix:semicolon
id|timeout
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|cpu-&gt;flags
op_amp
l_int|1
)paren
r_goto
id|started
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SMP: Processor %d failed to start.&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|started
suffix:colon
id|DBGS
c_func
(paren
(paren
l_string|&quot;secondary_cpu_start: SUCCESS for CPU %d!!!&bslash;n&quot;
comma
id|cpuid
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fork_by_hand
r_static
r_int
id|__init
id|fork_by_hand
c_func
(paren
r_void
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t care about the regs settings since&n;&t; * we&squot;ll never reschedule the forked task.&n;&t; */
r_return
id|do_fork
c_func
(paren
id|CLONE_VM
op_or
id|CLONE_PID
comma
l_int|0
comma
op_amp
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Bring one cpu online.&n; */
r_static
r_int
id|__init
DECL|function|smp_boot_one_cpu
id|smp_boot_one_cpu
c_func
(paren
r_int
id|cpuid
comma
r_int
id|cpunum
)paren
(brace
r_struct
id|task_struct
op_star
id|idle
suffix:semicolon
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Cook up an idler for this guy.  Note that the address we give&n;&t;   to kernel_thread is irrelevant -- it&squot;s going to start where&n;&t;   HWRPB.CPU_restart says to start.  But this gets all the other&n;&t;   task-y sort of data structures set up like we wish.  */
multiline_comment|/*&n;&t; * We can&squot;t use kernel_thread since we must avoid to&n;&t; * reschedule the child.&n;&t; */
r_if
c_cond
(paren
id|fork_by_hand
c_func
(paren
)paren
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;failed fork for CPU %d&quot;
comma
id|cpuid
)paren
suffix:semicolon
id|idle
op_assign
id|init_task.prev_task
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idle
)paren
id|panic
c_func
(paren
l_string|&quot;No idle process for CPU %d&quot;
comma
id|cpuid
)paren
suffix:semicolon
id|idle-&gt;processor
op_assign
id|cpuid
suffix:semicolon
id|__cpu_logical_map
(braket
id|cpunum
)braket
op_assign
id|cpuid
suffix:semicolon
id|__cpu_number_map
(braket
id|cpuid
)braket
op_assign
id|cpunum
suffix:semicolon
id|idle-&gt;has_cpu
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we schedule the first task manually */
id|del_from_runqueue
c_func
(paren
id|idle
)paren
suffix:semicolon
id|unhash_process
c_func
(paren
id|idle
)paren
suffix:semicolon
id|init_tasks
(braket
id|cpunum
)braket
op_assign
id|idle
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;smp_boot_one_cpu: CPU %d state 0x%lx flags 0x%lx&bslash;n&quot;
comma
id|cpuid
comma
id|idle-&gt;state
comma
id|idle-&gt;flags
)paren
)paren
suffix:semicolon
multiline_comment|/* The secondary will change this once it is happy.  Note that&n;&t;   secondary_cpu_start contains the necessary memory barrier.  */
id|smp_secondary_alive
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Whirrr, whirrr, whirrrrrrrrr... */
r_if
c_cond
(paren
id|secondary_cpu_start
c_func
(paren
id|cpuid
comma
id|idle
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We&squot;ve been acked by the console; wait one second for the task&n;&t;   to start up for real.  Note that jiffies aren&squot;t ticking yet.  */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|100000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|smp_secondary_alive
op_ne
op_minus
l_int|1
)paren
r_goto
id|alive
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* we must invalidate our stuff as we failed to boot the CPU */
id|__cpu_logical_map
(braket
id|cpunum
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|__cpu_number_map
(braket
id|cpuid
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* the idle task is local to us so free it as we don&squot;t use it */
id|free_task_struct
c_func
(paren
id|idle
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SMP: Processor %d is stuck.&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|alive
suffix:colon
multiline_comment|/* Another &quot;Red Snapper&quot;. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from setup_arch.  Detect an SMP system and which processors&n; * are present.&n; */
r_void
id|__init
DECL|function|setup_smp
id|setup_smp
c_func
(paren
r_void
)paren
(brace
r_struct
id|percpu_struct
op_star
id|cpubase
comma
op_star
id|cpu
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpuid
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;SMP: Booting off cpu %d instead of 0?&bslash;n&quot;
comma
id|boot_cpuid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwrpb-&gt;nr_processors
OG
l_int|1
)paren
(brace
r_int
id|boot_cpu_palrev
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;setup_smp: nr_processors %ld&bslash;n&quot;
comma
id|hwrpb-&gt;nr_processors
)paren
)paren
suffix:semicolon
id|cpubase
op_assign
(paren
r_struct
id|percpu_struct
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|hwrpb
op_plus
id|hwrpb-&gt;processor_offset
)paren
suffix:semicolon
id|boot_cpu_palrev
op_assign
id|cpubase-&gt;pal_revision
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hwrpb-&gt;nr_processors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu
op_assign
(paren
r_struct
id|percpu_struct
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|cpubase
op_plus
id|i
op_star
id|hwrpb-&gt;processor_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cpu-&gt;flags
op_amp
l_int|0x1cc
)paren
op_eq
l_int|0x1cc
)paren
(brace
id|smp_num_probed
op_increment
suffix:semicolon
multiline_comment|/* Assume here that &quot;whami&quot; == index */
id|hwrpb_cpu_present_mask
op_or_assign
(paren
l_int|1L
op_lshift
id|i
)paren
suffix:semicolon
id|cpu-&gt;pal_revision
op_assign
id|boot_cpu_palrev
suffix:semicolon
)brace
id|DBGS
c_func
(paren
(paren
l_string|&quot;setup_smp: CPU %d: flags 0x%lx type 0x%lx&bslash;n&quot;
comma
id|i
comma
id|cpu-&gt;flags
comma
id|cpu-&gt;type
)paren
)paren
suffix:semicolon
id|DBGS
c_func
(paren
(paren
l_string|&quot;setup_smp: CPU %d: PAL rev 0x%lx&bslash;n&quot;
comma
id|i
comma
id|cpu-&gt;pal_revision
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|smp_num_probed
op_assign
l_int|1
suffix:semicolon
id|hwrpb_cpu_present_mask
op_assign
(paren
l_int|1L
op_lshift
id|boot_cpuid
)paren
suffix:semicolon
)brace
id|cpu_present_mask
op_assign
l_int|1L
op_lshift
id|boot_cpuid
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SMP: %d CPUs probed -- cpu_present_mask = %lx&bslash;n&quot;
comma
id|smp_num_probed
comma
id|hwrpb_cpu_present_mask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by smp_init bring all the secondaries online and hold them.&n; */
r_void
id|__init
DECL|function|smp_boot_cpus
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu_count
comma
id|i
suffix:semicolon
r_int
r_int
id|bogosum
suffix:semicolon
multiline_comment|/* Take care of some initial bookkeeping.  */
id|memset
c_func
(paren
id|__cpu_number_map
comma
op_minus
l_int|1
comma
r_sizeof
(paren
id|__cpu_number_map
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|__cpu_logical_map
comma
op_minus
l_int|1
comma
r_sizeof
(paren
id|__cpu_logical_map
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ipi_data
comma
l_int|0
comma
r_sizeof
(paren
id|ipi_data
)paren
)paren
suffix:semicolon
id|__cpu_number_map
(braket
id|boot_cpuid
)braket
op_assign
l_int|0
suffix:semicolon
id|__cpu_logical_map
(braket
l_int|0
)braket
op_assign
id|boot_cpuid
suffix:semicolon
id|current-&gt;processor
op_assign
id|boot_cpuid
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|boot_cpuid
)paren
suffix:semicolon
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
id|smp_setup_percpu_timer
c_func
(paren
id|boot_cpuid
)paren
suffix:semicolon
id|init_idle
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ??? This should be in init_idle.  */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
multiline_comment|/* Nothing to do on a UP box, or when told not to.  */
r_if
c_cond
(paren
id|smp_num_probed
op_eq
l_int|1
op_logical_or
id|max_cpus
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SMP mode deactivated.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SMP starting up secondaries.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_count
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|boot_cpuid
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|hwrpb_cpu_present_mask
op_rshift
id|i
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|smp_boot_one_cpu
c_func
(paren
id|i
comma
id|cpu_count
)paren
)paren
r_continue
suffix:semicolon
id|cpu_present_mask
op_or_assign
l_int|1L
op_lshift
id|i
suffix:semicolon
id|cpu_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_count
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SMP: Only one lonely processor alive.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_mask
op_amp
(paren
l_int|1L
op_lshift
id|i
)paren
)paren
id|bogosum
op_add_assign
id|cpu_data
(braket
id|i
)braket
dot
id|loops_per_jiffy
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SMP: Total of %d processors activated &quot;
l_string|&quot;(%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpu_count
comma
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|smp_num_cpus
op_assign
id|cpu_count
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by smp_init to release the blocking online cpus once they &n; * are all started.&n; */
r_void
id|__init
DECL|function|smp_commence
id|smp_commence
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* smp_init sets smp_threads_ready -- that&squot;s enough.  */
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
"&f;"
r_void
DECL|function|smp_percpu_timer_interrupt
id|smp_percpu_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|user
op_assign
id|user_mode
c_func
(paren
id|regs
)paren
suffix:semicolon
r_struct
id|cpuinfo_alpha
op_star
id|data
op_assign
op_amp
id|cpu_data
(braket
id|cpu
)braket
suffix:semicolon
multiline_comment|/* Record kernel PC.  */
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
id|alpha_do_profile
c_func
(paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|data-&gt;prof_counter
)paren
(brace
multiline_comment|/* We need to make like a normal interrupt -- otherwise&n;&t;&t;   timer interrupts ignore the global interrupt lock,&n;&t;&t;   which would be a Bad Thing.  */
id|irq_enter
c_func
(paren
id|cpu
comma
id|RTC_IRQ
)paren
suffix:semicolon
id|update_process_times
c_func
(paren
id|user
)paren
suffix:semicolon
id|data-&gt;prof_counter
op_assign
id|data-&gt;prof_multiplier
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
id|RTC_IRQ
)paren
suffix:semicolon
)brace
)brace
r_int
id|__init
DECL|function|setup_profiling_timer
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
"&f;"
r_static
r_void
DECL|function|send_ipi_message
id|send_ipi_message
c_func
(paren
r_int
r_int
id|to_whom
comma
r_enum
id|ipi_message_type
id|operation
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* Reduce the number of memory barriers by doing two loops,&n;&t;   one to set the bits, one to invoke the interrupts.  */
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Order out-of-band data and bit setting. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|i
comma
id|j
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|to_whom
op_amp
id|j
)paren
id|set_bit
c_func
(paren
id|operation
comma
op_amp
id|ipi_data
(braket
id|i
)braket
dot
id|bits
)paren
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Order bit setting and interrupt. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|i
comma
id|j
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|to_whom
op_amp
id|j
)paren
id|wripir
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Structure and data for smp_call_function.  This is designed to &n;   minimize static memory requirements.  Plus it looks cleaner.  */
DECL|struct|smp_call_struct
r_struct
id|smp_call_struct
(brace
DECL|member|func
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
suffix:semicolon
DECL|member|info
r_void
op_star
id|info
suffix:semicolon
DECL|member|wait
r_int
id|wait
suffix:semicolon
DECL|member|unstarted_count
id|atomic_t
id|unstarted_count
suffix:semicolon
DECL|member|unfinished_count
id|atomic_t
id|unfinished_count
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|smp_call_function_data
r_static
r_struct
id|smp_call_struct
op_star
id|smp_call_function_data
suffix:semicolon
multiline_comment|/* Atomicly drop data into a shared pointer.  The pointer is free if&n;   it is initially locked.  If retry, spin until free.  */
r_static
r_inline
r_int
DECL|function|pointer_lock
id|pointer_lock
(paren
r_void
op_star
id|lock
comma
r_void
op_star
id|data
comma
r_int
id|retry
)paren
(brace
r_void
op_star
id|old
comma
op_star
id|tmp
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|again
suffix:colon
multiline_comment|/* Compare and swap with zero.  */
id|asm
r_volatile
(paren
l_string|&quot;1:&t;ldq_l&t;%0,%1&bslash;n&quot;
l_string|&quot;&t;mov&t;%3,%2&bslash;n&quot;
l_string|&quot;&t;bne&t;%0,2f&bslash;n&quot;
l_string|&quot;&t;stq_c&t;%2,%1&bslash;n&quot;
l_string|&quot;&t;beq&t;%2,1b&bslash;n&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|old
)paren
comma
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_void
op_star
op_star
)paren
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|data
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_while
c_loop
(paren
op_star
(paren
r_void
op_star
op_star
)paren
id|lock
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
r_void
DECL|function|handle_ipi
id|handle_ipi
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
op_star
id|pending_ipis
op_assign
op_amp
id|ipi_data
(braket
id|this_cpu
)braket
dot
id|bits
suffix:semicolon
r_int
r_int
id|ops
suffix:semicolon
macro_line|#if 0
id|DBGS
c_func
(paren
(paren
l_string|&quot;handle_ipi: on CPU %d ops 0x%lx PC 0x%lx&bslash;n&quot;
comma
id|this_cpu
comma
op_star
id|pending_ipis
comma
id|regs-&gt;pc
)paren
)paren
suffix:semicolon
macro_line|#endif
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Order interrupt and bit testing. */
r_while
c_loop
(paren
(paren
id|ops
op_assign
id|xchg
c_func
(paren
id|pending_ipis
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Order bit clearing and data access. */
r_do
(brace
r_int
r_int
id|which
suffix:semicolon
id|which
op_assign
id|ops
op_amp
op_minus
id|ops
suffix:semicolon
id|ops
op_and_assign
op_complement
id|which
suffix:semicolon
id|which
op_assign
id|ffz
c_func
(paren
op_complement
id|which
)paren
suffix:semicolon
r_if
c_cond
(paren
id|which
op_eq
id|IPI_RESCHEDULE
)paren
(brace
multiline_comment|/* Reschedule callback.  Everything to be done&n;&t;&t;&t;   is done by the interrupt return path.  */
)brace
r_else
r_if
c_cond
(paren
id|which
op_eq
id|IPI_CALL_FUNC
)paren
(brace
r_struct
id|smp_call_struct
op_star
id|data
suffix:semicolon
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
suffix:semicolon
r_void
op_star
id|info
suffix:semicolon
r_int
id|wait
suffix:semicolon
id|data
op_assign
id|smp_call_function_data
suffix:semicolon
id|func
op_assign
id|data-&gt;func
suffix:semicolon
id|info
op_assign
id|data-&gt;info
suffix:semicolon
id|wait
op_assign
id|data-&gt;wait
suffix:semicolon
multiline_comment|/* Notify the sending CPU that the data has been&n;&t;&t;&t;   received, and execution is about to begin.  */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_dec
(paren
op_amp
id|data-&gt;unstarted_count
)paren
suffix:semicolon
multiline_comment|/* At this point the structure may be gone unless&n;&t;&t;&t;   wait is true.  */
(paren
op_star
id|func
)paren
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Notify the sending CPU that the task is done.  */
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|atomic_dec
(paren
op_amp
id|data-&gt;unfinished_count
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|which
op_eq
id|IPI_CPU_STOP
)paren
(brace
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Unknown IPI on CPU %d: %lu&bslash;n&quot;
comma
id|this_cpu
comma
id|which
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|ops
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Order data access and bit testing. */
)brace
id|cpu_data
(braket
id|this_cpu
)braket
dot
id|ipi_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|hwrpb-&gt;txrdy
)paren
id|recv_secondary_console_msg
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|smp_send_reschedule
id|smp_send_reschedule
c_func
(paren
r_int
id|cpu
)paren
(brace
macro_line|#if DEBUG_IPI_MSG
r_if
c_cond
(paren
id|cpu
op_eq
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;smp_send_reschedule: Sending IPI to self.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|send_ipi_message
c_func
(paren
l_int|1L
op_lshift
id|cpu
comma
id|IPI_RESCHEDULE
)paren
suffix:semicolon
)brace
r_void
DECL|function|smp_send_stop
id|smp_send_stop
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|to_whom
op_assign
id|cpu_present_mask
op_xor
(paren
l_int|1L
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG_IPI_MSG
r_if
c_cond
(paren
id|hard_smp_processor_id
c_func
(paren
)paren
op_ne
id|boot_cpu_id
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;smp_send_stop: Not on boot cpu.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|send_ipi_message
c_func
(paren
id|to_whom
comma
id|IPI_CPU_STOP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Run a function on all other CPUs.&n; *  &lt;func&gt;&t;The function to run. This must be fast and non-blocking.&n; *  &lt;info&gt;&t;An arbitrary pointer to pass to the function.&n; *  &lt;retry&gt;&t;If true, keep retrying until ready.&n; *  &lt;wait&gt;&t;If true, wait until function has completed on other CPUs.&n; *  [RETURNS]   0 on success, else a negative status code.&n; *&n; * Does not return until remote CPUs are nearly ready to execute &lt;func&gt;&n; * or are or have executed.&n; */
r_int
DECL|function|smp_call_function
id|smp_call_function
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|retry
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|to_whom
op_assign
id|cpu_present_mask
op_xor
(paren
l_int|1L
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_struct
id|smp_call_struct
id|data
suffix:semicolon
r_int
id|timeout
suffix:semicolon
id|data.func
op_assign
id|func
suffix:semicolon
id|data.info
op_assign
id|info
suffix:semicolon
id|data.wait
op_assign
id|wait
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|data.unstarted_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|data.unfinished_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Aquire the smp_call_function_data mutex.  */
r_if
c_cond
(paren
id|pointer_lock
c_func
(paren
op_amp
id|smp_call_function_data
comma
op_amp
id|data
comma
id|retry
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Send a message to all other CPUs.  */
id|send_ipi_message
c_func
(paren
id|to_whom
comma
id|IPI_CALL_FUNC
)paren
suffix:semicolon
multiline_comment|/* Wait for a minimal response.  */
id|timeout
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
(paren
op_amp
id|data.unstarted_count
)paren
OG
l_int|0
op_logical_and
id|time_before
(paren
id|jiffies
comma
id|timeout
)paren
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We either got one or timed out -- clear the lock.  */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|smp_call_function_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
id|data.unstarted_count
)paren
OG
l_int|0
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
multiline_comment|/* Wait for a complete response, if needed.  */
r_if
c_cond
(paren
id|wait
)paren
(brace
r_while
c_loop
(paren
id|atomic_read
(paren
op_amp
id|data.unfinished_count
)paren
OG
l_int|0
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ipi_imb
id|ipi_imb
c_func
(paren
r_void
op_star
id|ignored
)paren
(brace
id|imb
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|smp_imb
id|smp_imb
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Must wait other processors to flush their icache before continue. */
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|ipi_imb
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;smp_imb: timed out&bslash;n&quot;
)paren
suffix:semicolon
id|imb
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ipi_flush_tlb_all
id|ipi_flush_tlb_all
c_func
(paren
r_void
op_star
id|ignored
)paren
(brace
id|tbia
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|flush_tlb_all
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Although we don&squot;t have any data to pass, we do want to&n;&t;   synchronize with the other processors.  */
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|ipi_flush_tlb_all
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;flush_tlb_all: timed out&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tbia
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|asn_locked
mdefine_line|#define asn_locked() (cpu_data[smp_processor_id()].asn_lock)
r_static
r_void
DECL|function|ipi_flush_tlb_mm
id|ipi_flush_tlb_mm
c_func
(paren
r_void
op_star
id|x
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
(paren
r_struct
id|mm_struct
op_star
)paren
id|x
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
op_logical_neg
id|asn_locked
c_func
(paren
)paren
)paren
id|flush_tlb_current
c_func
(paren
id|mm
)paren
suffix:semicolon
r_else
id|flush_tlb_other
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_void
DECL|function|flush_tlb_mm
id|flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
)paren
(brace
id|flush_tlb_current
c_func
(paren
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_le
l_int|1
)paren
(brace
r_int
id|i
comma
id|cpu
comma
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu
op_assign
id|cpu_logical_map
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|this_cpu
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
(braket
id|cpu
)braket
)paren
id|mm-&gt;context
(braket
id|cpu
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|ipi_flush_tlb_mm
comma
id|mm
comma
l_int|1
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;flush_tlb_mm: timed out&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|struct|flush_tlb_page_struct
r_struct
id|flush_tlb_page_struct
(brace
DECL|member|vma
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
DECL|member|mm
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
DECL|function|ipi_flush_tlb_page
id|ipi_flush_tlb_page
c_func
(paren
r_void
op_star
id|x
)paren
(brace
r_struct
id|flush_tlb_page_struct
op_star
id|data
op_assign
(paren
r_struct
id|flush_tlb_page_struct
op_star
)paren
id|x
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|data-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
op_logical_neg
id|asn_locked
c_func
(paren
)paren
)paren
id|flush_tlb_current_page
c_func
(paren
id|mm
comma
id|data-&gt;vma
comma
id|data-&gt;addr
)paren
suffix:semicolon
r_else
id|flush_tlb_other
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_void
DECL|function|flush_tlb_page
id|flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|flush_tlb_page_struct
id|data
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
)paren
(brace
id|flush_tlb_current_page
c_func
(paren
id|mm
comma
id|vma
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_le
l_int|1
)paren
(brace
r_int
id|i
comma
id|cpu
comma
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu
op_assign
id|cpu_logical_map
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|this_cpu
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
(braket
id|cpu
)braket
)paren
id|mm-&gt;context
(braket
id|cpu
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
id|data.vma
op_assign
id|vma
suffix:semicolon
id|data.mm
op_assign
id|mm
suffix:semicolon
id|data.addr
op_assign
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|ipi_flush_tlb_page
comma
op_amp
id|data
comma
l_int|1
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;flush_tlb_page: timed out&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|flush_tlb_range
id|flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
multiline_comment|/* On the Alpha we always flush the whole user tlb.  */
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ipi_flush_icache_page
id|ipi_flush_icache_page
c_func
(paren
r_void
op_star
id|x
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
(paren
r_struct
id|mm_struct
op_star
)paren
id|x
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
op_logical_neg
id|asn_locked
c_func
(paren
)paren
)paren
id|__load_new_mm_context
c_func
(paren
id|mm
)paren
suffix:semicolon
r_else
id|flush_tlb_other
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_void
DECL|function|flush_icache_page
id|flush_icache_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
)paren
(brace
id|__load_new_mm_context
c_func
(paren
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_le
l_int|1
)paren
(brace
r_int
id|i
comma
id|cpu
comma
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu
op_assign
id|cpu_logical_map
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
id|this_cpu
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
(braket
id|cpu
)braket
)paren
id|mm-&gt;context
(braket
id|cpu
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|ipi_flush_icache_page
comma
id|mm
comma
l_int|1
comma
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;flush_icache_page: timed out&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
"&f;"
r_int
DECL|function|smp_info
id|smp_info
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;cpus active&bslash;t&bslash;t: %d&bslash;n&quot;
l_string|&quot;cpu active mask&bslash;t&bslash;t: %016lx&bslash;n&quot;
comma
id|smp_num_cpus
comma
id|cpu_present_mask
)paren
suffix:semicolon
)brace
"&f;"
macro_line|#if DEBUG_SPINLOCK
r_void
DECL|function|spin_unlock
id|spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|lock-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|lock-&gt;on_cpu
op_assign
op_minus
l_int|1
suffix:semicolon
id|lock-&gt;previous
op_assign
l_int|NULL
suffix:semicolon
id|lock-&gt;task
op_assign
l_int|NULL
suffix:semicolon
id|lock-&gt;base_file
op_assign
l_string|&quot;none&quot;
suffix:semicolon
id|lock-&gt;line_no
op_assign
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|debug_spin_lock
id|debug_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_const
r_char
op_star
id|base_file
comma
r_int
id|line_no
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_int
id|stuck
suffix:semicolon
r_void
op_star
id|inline_pc
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|started
op_assign
id|jiffies
suffix:semicolon
r_int
id|printed
op_assign
l_int|0
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|stuck
op_assign
l_int|1L
op_lshift
l_int|28
suffix:semicolon
id|try_again
suffix:colon
multiline_comment|/* Use sub-sections to put the actual loop at the end&n;&t;   of this object file&squot;s text section so as to perfect&n;&t;   branch prediction.  */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%0,%1&bslash;n&quot;
l_string|&quot;&t;subq&t;%2,1,%2&bslash;n&quot;
l_string|&quot;&t;blbs&t;%0,2f&bslash;n&quot;
l_string|&quot;&t;or&t;%0,1,%0&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%0,%1&bslash;n&quot;
l_string|&quot;&t;beq&t;%0,3f&bslash;n&quot;
l_string|&quot;4:&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;2:&t;ldl&t;%0,%1&bslash;n&quot;
l_string|&quot;&t;subq&t;%2,1,%2&bslash;n&quot;
l_string|&quot;3:&t;blt&t;%2,4b&bslash;n&quot;
l_string|&quot;&t;blbs&t;%0,2b&bslash;n&quot;
l_string|&quot;&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
id|lock-&gt;lock
)paren
comma
l_string|&quot;=r&quot;
(paren
id|stuck
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|lock-&gt;lock
)paren
comma
l_string|&quot;2&quot;
(paren
id|stuck
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuck
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s:%d spinlock stuck in %s at %p(%d)&quot;
l_string|&quot; owner %s at %p(%d) %s:%d&bslash;n&quot;
comma
id|base_file
comma
id|line_no
comma
id|current-&gt;comm
comma
id|inline_pc
comma
id|cpu
comma
id|lock-&gt;task-&gt;comm
comma
id|lock-&gt;previous
comma
id|lock-&gt;on_cpu
comma
id|lock-&gt;base_file
comma
id|lock-&gt;line_no
)paren
suffix:semicolon
id|stuck
op_assign
l_int|1L
op_lshift
l_int|36
suffix:semicolon
id|printed
op_assign
l_int|1
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
multiline_comment|/* Exiting.  Got the lock.  */
id|lock-&gt;on_cpu
op_assign
id|cpu
suffix:semicolon
id|lock-&gt;previous
op_assign
id|inline_pc
suffix:semicolon
id|lock-&gt;task
op_assign
id|current
suffix:semicolon
id|lock-&gt;base_file
op_assign
id|base_file
suffix:semicolon
id|lock-&gt;line_no
op_assign
id|line_no
suffix:semicolon
r_if
c_cond
(paren
id|printed
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s:%d spinlock grabbed in %s at %p(%d) %ld ticks&bslash;n&quot;
comma
id|base_file
comma
id|line_no
comma
id|current-&gt;comm
comma
id|inline_pc
comma
id|cpu
comma
id|jiffies
op_minus
id|started
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|debug_spin_trylock
id|debug_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_const
r_char
op_star
id|base_file
comma
r_int
id|line_no
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
id|lock
)paren
)paren
)paren
(brace
id|lock-&gt;on_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|lock-&gt;previous
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|lock-&gt;task
op_assign
id|current
suffix:semicolon
)brace
r_else
(brace
id|lock-&gt;base_file
op_assign
id|base_file
suffix:semicolon
id|lock-&gt;line_no
op_assign
id|line_no
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_SPINLOCK */
"&f;"
macro_line|#if DEBUG_RWLOCK
DECL|function|write_lock
r_void
id|write_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_int
id|regx
comma
id|regy
suffix:semicolon
r_int
id|stuck_lock
comma
id|stuck_reader
suffix:semicolon
r_void
op_star
id|inline_pc
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|try_again
suffix:colon
id|stuck_lock
op_assign
l_int|1
op_lshift
l_int|26
suffix:semicolon
id|stuck_reader
op_assign
l_int|1
op_lshift
l_int|26
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;blbs&t;%1,6f&bslash;n&quot;
l_string|&quot;&t;blt&t;%1,8f&bslash;n&quot;
l_string|&quot;&t;mov&t;1,%1&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;%1,6f&bslash;n&quot;
l_string|&quot;4:&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;6:&t;blt&t;%3,4b&t;# debug&bslash;n&quot;
l_string|&quot;&t;subl&t;%3,1,%3&t;# debug&bslash;n&quot;
l_string|&quot;&t;ldl&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;blbs&t;%1,6b&bslash;n&quot;
l_string|&quot;8:&t;blt&t;%4,4b&t;# debug&bslash;n&quot;
l_string|&quot;&t;subl&t;%4,1,%4&t;# debug&bslash;n&quot;
l_string|&quot;&t;ldl&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;blt&t;%1,8b&bslash;n&quot;
l_string|&quot;&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_volatile
r_int
op_star
)paren
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regx
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regy
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|stuck_lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|stuck_reader
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
op_star
(paren
r_volatile
r_int
op_star
)paren
id|lock
)paren
comma
l_string|&quot;3&quot;
(paren
id|stuck_lock
)paren
comma
l_string|&quot;4&quot;
(paren
id|stuck_reader
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuck_lock
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;write_lock stuck at %p&bslash;n&quot;
comma
id|inline_pc
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuck_reader
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;write_lock stuck on readers at %p&bslash;n&quot;
comma
id|inline_pc
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
)brace
DECL|function|read_lock
r_void
id|read_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_int
id|regx
suffix:semicolon
r_int
id|stuck_lock
suffix:semicolon
r_void
op_star
id|inline_pc
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|try_again
suffix:colon
id|stuck_lock
op_assign
l_int|1
op_lshift
l_int|26
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%1,%0;&quot;
l_string|&quot;&t;blbs&t;%1,6f;&quot;
l_string|&quot;&t;subl&t;%1,2,%1;&quot;
l_string|&quot;&t;stl_c&t;%1,%0;&quot;
l_string|&quot;&t;beq&t;%1,6f;&quot;
l_string|&quot;4:&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;6:&t;ldl&t;%1,%0;&quot;
l_string|&quot;&t;blt&t;%2,4b&t;# debug&bslash;n&quot;
l_string|&quot;&t;subl&t;%2,1,%2&t;# debug&bslash;n&quot;
l_string|&quot;&t;blbs&t;%1,6b;&quot;
l_string|&quot;&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_volatile
r_int
op_star
)paren
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regx
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|stuck_lock
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
op_star
(paren
r_volatile
r_int
op_star
)paren
id|lock
)paren
comma
l_string|&quot;2&quot;
(paren
id|stuck_lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuck_lock
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;read_lock stuck at %p&bslash;n&quot;
comma
id|inline_pc
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG_RWLOCK */
eof
