multiline_comment|/*&n; * kernel/traps.c&n; *&n; * (C) Copyright 1994 Linus Torvalds&n; */
multiline_comment|/*&n; * This file initializes the trap entry points&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
DECL|function|die_if_kernel
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|sp
suffix:semicolon
r_int
r_int
op_star
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;ps
op_amp
l_int|8
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d): %s %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
)paren
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
)paren
(paren
id|regs
op_plus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pc = %lx ps = %04lx&bslash;n&quot;
comma
id|regs-&gt;pc
comma
id|regs-&gt;ps
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rp = %lx sp = %lx&bslash;n&quot;
comma
id|regs-&gt;r26
comma
id|sp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r0=%lx r1=%lx r2=%lx r3=%lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r8=%lx&bslash;n&quot;
comma
id|regs-&gt;r8
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r16=%lx r17=%lx r18=%lx r19=%lx&bslash;n&quot;
comma
id|regs-&gt;r16
comma
id|regs-&gt;r17
comma
id|regs-&gt;r18
comma
id|regs-&gt;r19
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r20=%lx r21=%lx r22=%lx r23=%lx&bslash;n&quot;
comma
id|regs-&gt;r20
comma
id|regs-&gt;r21
comma
id|regs-&gt;r22
comma
id|regs-&gt;r23
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r24=%lx r25=%lx r26=%lx r27=%lx&bslash;n&quot;
comma
id|regs-&gt;r24
comma
id|regs-&gt;r25
comma
id|regs-&gt;r26
comma
id|regs-&gt;r27
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r28=%lx r29=%lx r30=%lx&bslash;n&quot;
comma
id|regs-&gt;r28
comma
id|regs-&gt;gp
comma
id|sp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Code:&quot;
)paren
suffix:semicolon
id|pc
op_assign
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c%08x%c&quot;
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&lt;&squot;
comma
id|pc
(braket
id|i
)braket
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000000000
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* pause */
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_entArith
id|asmlinkage
r_void
id|do_entArith
c_func
(paren
r_int
r_int
id|summary
comma
r_int
r_int
id|write_mask
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Arithmetic trap: %02lx %016lx&bslash;n&quot;
comma
id|summary
comma
id|write_mask
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Arithmetic fault&quot;
comma
op_amp
id|regs
comma
l_int|0
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|do_entIF
id|asmlinkage
r_void
id|do_entIF
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_extern
r_int
id|ptrace_cancel_bpt
(paren
r_struct
id|task_struct
op_star
id|who
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Instruction fault&quot;
comma
op_amp
id|regs
comma
id|type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* breakpoint */
r_if
c_cond
(paren
id|ptrace_cancel_bpt
c_func
(paren
id|current
)paren
)paren
(brace
id|regs.pc
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to former bpt */
)brace
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* bugcheck */
r_case
l_int|2
suffix:colon
multiline_comment|/* gentrap */
r_case
l_int|3
suffix:colon
multiline_comment|/* FEN fault */
r_case
l_int|4
suffix:colon
multiline_comment|/* opDEC */
id|send_sig
c_func
(paren
id|SIGILL
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;do_entIF: unexpected instruction-fault type&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * entUna has a different register layout to be reasonably simple. It&n; * needs access to all the integer registers (the kernel doesn&squot;t use&n; * fp-regs), and it needs to have them in order for simpler access.&n; *&n; * Due to the non-standard register layout (and because we don&squot;t want&n; * to handle floating-point regs), user-mode unaligned accesses are&n; * handled separately by do_entUnaUser below.&n; *&n; * Oh, btw, we don&squot;t handle the &quot;gp&quot; register correctly, but if we fault&n; * on a gp-register unaligned load/store, something is _very_ wrong&n; * in the kernel anyway..&n; */
DECL|struct|allregs
r_struct
id|allregs
(brace
DECL|member|regs
r_int
r_int
id|regs
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|ps
DECL|member|pc
DECL|member|gp
DECL|member|a0
DECL|member|a1
DECL|member|a2
r_int
r_int
id|ps
comma
id|pc
comma
id|gp
comma
id|a0
comma
id|a1
comma
id|a2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|unaligned_stat
r_struct
id|unaligned_stat
(brace
DECL|member|count
DECL|member|va
DECL|member|pc
r_int
r_int
id|count
comma
id|va
comma
id|pc
suffix:semicolon
DECL|variable|unaligned
)brace
id|unaligned
suffix:semicolon
DECL|function|do_entUna
id|asmlinkage
r_void
id|do_entUna
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|allregs
id|regs
)paren
(brace
r_static
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|cnt
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;Unaligned trap at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|regs.pc
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
op_increment
id|unaligned.count
suffix:semicolon
id|unaligned.va
op_assign
(paren
r_int
r_int
)paren
id|va
op_minus
l_int|4
suffix:semicolon
id|unaligned.pc
op_assign
id|regs.pc
suffix:semicolon
multiline_comment|/* $16-$18 are PAL-saved, and are offset by 19 entries */
r_if
c_cond
(paren
id|reg
op_ge
l_int|16
op_logical_and
id|reg
op_le
l_int|18
)paren
id|reg
op_add_assign
l_int|19
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x28
suffix:colon
multiline_comment|/* ldl */
op_star
(paren
id|reg
op_plus
id|regs.regs
)paren
op_assign
(paren
r_int
)paren
id|ldl_u
c_func
(paren
id|va
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x29
suffix:colon
multiline_comment|/* ldq */
op_star
(paren
id|reg
op_plus
id|regs.regs
)paren
op_assign
id|ldq_u
c_func
(paren
id|va
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x2c
suffix:colon
multiline_comment|/* stl */
id|stl_u
c_func
(paren
op_star
(paren
id|reg
op_plus
id|regs.regs
)paren
comma
id|va
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x2d
suffix:colon
multiline_comment|/* stq */
id|stq_u
c_func
(paren
op_star
(paren
id|reg
op_plus
id|regs.regs
)paren
comma
id|va
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Bad unaligned kernel access at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|regs.pc
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle user-level unaligned fault.  For now, simply send a&n; * SIGSEGV---there should be little reason for users not wanting to&n; * fix their code instead.  Notice that we have the regular kernel&n; * stack layout here, so finding the appropriate registers is a little&n; * more difficult than in the kernel case.  Also, we&squot;d need to do&n; * a &quot;verify_area()&quot; before accessing memory on behalf of the user.&n; */
DECL|function|do_entUnaUser
id|asmlinkage
r_void
id|do_entUnaUser
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
id|regs.pc
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to faulting insn */
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * DEC means people to use the &quot;retsys&quot; instruction for return from&n; * a system call, but they are clearly misguided about this. We use&n; * &quot;rti&quot; in all cases, and fill in the stack with the return values.&n; * That should make signal handling etc much cleaner.&n; *&n; * Even more horribly, DEC doesn&squot;t allow system calls from kernel mode.&n; * &quot;Security&quot; features letting the user do something the kernel can&squot;t&n; * are a thinko. DEC palcode is strange. The PAL-code designers probably&n; * got terminally tainted by VMS at some point.&n; */
DECL|function|do_entSys
id|asmlinkage
r_int
id|do_entSys
c_func
(paren
r_int
r_int
id|a0
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_if
c_cond
(paren
id|regs.r0
op_ne
l_int|112
)paren
id|printk
c_func
(paren
l_string|&quot;&lt;sc %ld(%lx,%lx,%lx)&gt;&quot;
comma
id|regs.r0
comma
id|a0
comma
id|a1
comma
id|a2
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_extern
id|asmlinkage
r_void
id|entMM
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entIF
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entArith
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entUna
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entSys
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|trap_init
r_void
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|gptr
suffix:semicolon
multiline_comment|/*&n;&t; * Tell PAL-code what global pointer we want in the kernel..&n;&t; */
id|__asm__
c_func
(paren
l_string|&quot;br %0,___tmp&bslash;n&quot;
l_string|&quot;___tmp:&bslash;tldgp %0,0(%0)&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|gptr
)paren
)paren
suffix:semicolon
id|wrkgp
c_func
(paren
id|gptr
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entArith
comma
l_int|1
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entMM
comma
l_int|2
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entIF
comma
l_int|3
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entUna
comma
l_int|4
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entSys
comma
l_int|5
)paren
suffix:semicolon
)brace
eof
