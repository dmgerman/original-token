multiline_comment|/*&n; * kernel/traps.c&n; *&n; * (C) Copyright 1994 Linus Torvalds&n; */
multiline_comment|/*&n; * This file initializes the trap entry points&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;asm/gentrap.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
DECL|function|die_if_kernel
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|sp
suffix:semicolon
r_int
r_int
op_star
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;ps
op_amp
l_int|8
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d): %s %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
)paren
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
)paren
(paren
id|regs
op_plus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pc = [&lt;%lx&gt;] ps = %04lx&bslash;n&quot;
comma
id|regs-&gt;pc
comma
id|regs-&gt;ps
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rp = [&lt;%lx&gt;] sp = %lx&bslash;n&quot;
comma
id|regs-&gt;r26
comma
id|sp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r0=%lx r1=%lx r2=%lx r3=%lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r8=%lx&bslash;n&quot;
comma
id|regs-&gt;r8
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r16=%lx r17=%lx r18=%lx r19=%lx&bslash;n&quot;
comma
id|regs-&gt;r16
comma
id|regs-&gt;r17
comma
id|regs-&gt;r18
comma
id|regs-&gt;r19
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r20=%lx r21=%lx r22=%lx r23=%lx&bslash;n&quot;
comma
id|regs-&gt;r20
comma
id|regs-&gt;r21
comma
id|regs-&gt;r22
comma
id|regs-&gt;r23
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r24=%lx r25=%lx r26=%lx r27=%lx&bslash;n&quot;
comma
id|regs-&gt;r24
comma
id|regs-&gt;r25
comma
id|regs-&gt;r26
comma
id|regs-&gt;r27
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r28=%lx r29=%lx r30=%lx&bslash;n&quot;
comma
id|regs-&gt;r28
comma
id|regs-&gt;gp
comma
id|sp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Code:&quot;
)paren
suffix:semicolon
id|pc
op_assign
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c%08x%c&quot;
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&lt;&squot;
comma
id|pc
(braket
id|i
)braket
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|do_entArith
id|asmlinkage
r_void
id|do_entArith
c_func
(paren
r_int
r_int
id|summary
comma
r_int
r_int
id|write_mask
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_if
c_cond
(paren
(paren
id|summary
op_amp
l_int|1
)paren
)paren
(brace
r_extern
r_int
id|alpha_fp_emul_imprecise
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|write_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Software-completion summary bit is set, so try to&n;&t;&t; * emulate the instruction.&n;&t;&t; */
r_if
c_cond
(paren
id|alpha_fp_emul_imprecise
c_func
(paren
op_amp
id|regs
comma
id|write_mask
)paren
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* emulation was successful */
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;%s: arithmetic trap at %016lx: %02lx %016lx&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|regs.pc
comma
id|summary
comma
id|write_mask
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Arithmetic fault&quot;
comma
op_amp
id|regs
comma
l_int|0
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|do_entIF
id|asmlinkage
r_void
id|do_entIF
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_extern
r_int
id|ptrace_cancel_bpt
(paren
r_struct
id|task_struct
op_star
id|who
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Instruction fault&quot;
comma
op_amp
id|regs
comma
id|type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* breakpoint */
r_if
c_cond
(paren
id|ptrace_cancel_bpt
c_func
(paren
id|current
)paren
)paren
(brace
id|regs.pc
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to former bpt */
)brace
id|force_sig
c_func
(paren
id|SIGTRAP
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* gentrap */
multiline_comment|/*&n;&t;&t; * The exception code should be passed on to the signal&n;&t;&t; * handler as the second argument.  Linux doesn&squot;t do that&n;&t;&t; * yet (also notice that Linux *always* behaves like&n;&t;&t; * DEC Unix with SA_SIGINFO off; see DEC Unix man page&n;&t;&t; * for sigaction(2)).&n;&t;&t; */
r_switch
c_cond
(paren
(paren
r_int
)paren
id|regs.r16
)paren
(brace
r_case
id|GEN_INTOVF
suffix:colon
r_case
id|GEN_INTDIV
suffix:colon
r_case
id|GEN_FLTOVF
suffix:colon
r_case
id|GEN_FLTDIV
suffix:colon
r_case
id|GEN_FLTUND
suffix:colon
r_case
id|GEN_FLTINV
suffix:colon
r_case
id|GEN_FLTINE
suffix:colon
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_DECOVF
suffix:colon
r_case
id|GEN_DECDIV
suffix:colon
r_case
id|GEN_DECINV
suffix:colon
r_case
id|GEN_ROPRAND
suffix:colon
r_case
id|GEN_ASSERTERR
suffix:colon
r_case
id|GEN_NULPTRERR
suffix:colon
r_case
id|GEN_STKOVF
suffix:colon
r_case
id|GEN_STRLENERR
suffix:colon
r_case
id|GEN_SUBSTRERR
suffix:colon
r_case
id|GEN_RANGERR
suffix:colon
r_case
id|GEN_SUBRNG
suffix:colon
r_case
id|GEN_SUBRNG1
suffix:colon
r_case
id|GEN_SUBRNG2
suffix:colon
r_case
id|GEN_SUBRNG3
suffix:colon
r_case
id|GEN_SUBRNG4
suffix:colon
r_case
id|GEN_SUBRNG5
suffix:colon
r_case
id|GEN_SUBRNG6
suffix:colon
r_case
id|GEN_SUBRNG7
suffix:colon
id|force_sig
c_func
(paren
id|SIGILL
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* bugcheck */
r_case
l_int|3
suffix:colon
multiline_comment|/* FEN fault */
id|force_sig
c_func
(paren
id|SIGILL
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* opDEC */
macro_line|#ifdef CONFIG_ALPHA_NEED_ROUNDING_EMULATION
(brace
r_extern
r_int
id|alpha_fp_emul
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
r_int
r_int
id|opcode
suffix:semicolon
multiline_comment|/* get opcode of faulting instruction: */
id|get_user
c_func
(paren
id|opcode
comma
(paren
id|__u32
op_star
)paren
(paren
id|regs.pc
op_minus
l_int|4
)paren
)paren
suffix:semicolon
id|opcode
op_rshift_assign
l_int|26
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0x16
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * It&squot;s a FLTI instruction, emulate it&n;&t;&t;&t;&t; * (we don&squot;t do no stinkin&squot; VAX fp...)&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|alpha_fp_emul
c_func
(paren
id|regs.pc
op_minus
l_int|4
)paren
)paren
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
id|force_sig
c_func
(paren
id|SIGILL
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;do_entIF: unexpected instruction-fault type&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * entUna has a different register layout to be reasonably simple. It&n; * needs access to all the integer registers (the kernel doesn&squot;t use&n; * fp-regs), and it needs to have them in order for simpler access.&n; *&n; * Due to the non-standard register layout (and because we don&squot;t want&n; * to handle floating-point regs), user-mode unaligned accesses are&n; * handled separately by do_entUnaUser below.&n; *&n; * Oh, btw, we don&squot;t handle the &quot;gp&quot; register correctly, but if we fault&n; * on a gp-register unaligned load/store, something is _very_ wrong&n; * in the kernel anyway..&n; */
DECL|struct|allregs
r_struct
id|allregs
(brace
DECL|member|regs
r_int
r_int
id|regs
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|ps
DECL|member|pc
DECL|member|gp
DECL|member|a0
DECL|member|a1
DECL|member|a2
r_int
r_int
id|ps
comma
id|pc
comma
id|gp
comma
id|a0
comma
id|a1
comma
id|a2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|unaligned_stat
r_struct
id|unaligned_stat
(brace
DECL|member|count
DECL|member|va
DECL|member|pc
r_int
r_int
id|count
comma
id|va
comma
id|pc
suffix:semicolon
DECL|variable|unaligned
)brace
id|unaligned
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Macro for exception fixup code to access integer registers.  */
DECL|macro|una_reg
mdefine_line|#define una_reg(r)  (regs.regs[(r) &gt;= 16 &amp;&amp; (r) &lt;= 18 ? (r)+19 : (r)])
DECL|function|do_entUna
id|asmlinkage
r_void
id|do_entUna
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|allregs
id|regs
)paren
(brace
r_static
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|last_time
op_assign
l_int|0
suffix:semicolon
r_int
id|error
comma
id|tmp1
comma
id|tmp2
comma
id|tmp3
comma
id|tmp4
suffix:semicolon
r_int
r_int
id|pc
op_assign
id|regs.pc
op_minus
l_int|4
suffix:semicolon
r_int
id|fixup
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_ge
l_int|5
op_logical_and
id|jiffies
op_minus
id|last_time
OG
l_int|5
op_star
id|HZ
)paren
(brace
id|cnt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|cnt
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kernel: unaligned trap at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|pc
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
)brace
id|last_time
op_assign
id|jiffies
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|count
op_increment
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|va
op_assign
(paren
r_int
r_int
)paren
id|va
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* We don&squot;t want to use the generic get/put unaligned macros as&n;&t;   we want to trap exceptions.  Only if we actually get an&n;&t;   exception will we decide whether we should have caught it.  */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
macro_line|#ifdef __HAVE_CPU_BWX
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* ldwu */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,1(%3)&bslash;n&quot;
l_string|&quot;&t;extwl %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extwh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.text&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
r_case
l_int|0x28
suffix:colon
multiline_comment|/* ldl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,3(%3)&bslash;n&quot;
l_string|&quot;&t;extll %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extlh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.text&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
(paren
r_int
)paren
(paren
id|tmp1
op_or
id|tmp2
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x29
suffix:colon
multiline_comment|/* ldq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,7(%3)&bslash;n&quot;
l_string|&quot;&t;extql %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extqh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.text&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* Note that the store sequences do not indicate that they change&n;&t;   memory because it _should_ be affecting nothing in this context.&n;&t;   (Otherwise we have other, much larger, problems.)  */
macro_line|#ifdef __HAVE_CPU_BWX
r_case
l_int|0x0d
suffix:colon
multiline_comment|/* stw */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inswh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;inswl %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskwh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskwl %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.text&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
r_case
l_int|0x2c
suffix:colon
multiline_comment|/* stl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inslh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insll %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;msklh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskll %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.text&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x2d
suffix:colon
multiline_comment|/* stq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;insqh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insql %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskqh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskql %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&bslash;t&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.text&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Bad unaligned kernel access at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|pc
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
r_return
suffix:semicolon
id|got_exception
suffix:colon
multiline_comment|/* Ok, we caught the exception, but we don&squot;t want it.  Is there&n;&t;   someone to pass it along to?  */
r_if
c_cond
(paren
(paren
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|pc
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|newpc
suffix:semicolon
id|newpc
op_assign
id|fixup_exception
c_func
(paren
id|una_reg
comma
id|fixup
comma
id|pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Forwarding unaligned exception at %lx (%lx)&bslash;n&quot;
comma
id|pc
comma
id|newpc
)paren
suffix:semicolon
(paren
op_amp
id|regs
)paren
op_member_access_from_pointer
id|pc
op_assign
id|newpc
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Yikes!  No one to forward the exception to.  */
id|printk
c_func
(paren
l_string|&quot;%s: unhandled unaligned exception at pc=%lx ra=%lx&quot;
l_string|&quot; (bad address = %p)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|pc
comma
id|una_reg
c_func
(paren
l_int|26
)paren
comma
id|va
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an s-floating point value in memory format to the&n; * corresponding value in register format.  The exponent&n; * needs to be remapped to preserve non-finite values&n; * (infinities, not-a-numbers, denormals).&n; */
DECL|function|s_mem_to_reg
r_static
r_inline
r_int
r_int
id|s_mem_to_reg
(paren
r_int
r_int
id|s_mem
)paren
(brace
r_int
r_int
id|frac
op_assign
(paren
id|s_mem
op_rshift
l_int|0
)paren
op_amp
l_int|0x7fffff
suffix:semicolon
r_int
r_int
id|sign
op_assign
(paren
id|s_mem
op_rshift
l_int|31
)paren
op_amp
l_int|0x1
suffix:semicolon
r_int
r_int
id|exp_msb
op_assign
(paren
id|s_mem
op_rshift
l_int|30
)paren
op_amp
l_int|0x1
suffix:semicolon
r_int
r_int
id|exp_low
op_assign
(paren
id|s_mem
op_rshift
l_int|23
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_int
r_int
id|exp
suffix:semicolon
id|exp
op_assign
(paren
id|exp_msb
op_lshift
l_int|10
)paren
op_or
id|exp_low
suffix:semicolon
multiline_comment|/* common case */
r_if
c_cond
(paren
id|exp_msb
)paren
(brace
r_if
c_cond
(paren
id|exp_low
op_eq
l_int|0x7f
)paren
(brace
id|exp
op_assign
l_int|0x3ff
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|exp_low
op_eq
l_int|0x00
)paren
(brace
id|exp
op_assign
l_int|0x000
suffix:semicolon
)brace
r_else
(brace
id|exp
op_or_assign
(paren
l_int|0x7
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|sign
op_lshift
l_int|63
)paren
op_or
(paren
id|exp
op_lshift
l_int|52
)paren
op_or
(paren
id|frac
op_lshift
l_int|29
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an s-floating point value in register format to the&n; * corresponding value in memory format.&n; */
DECL|function|s_reg_to_mem
r_static
r_inline
r_int
r_int
id|s_reg_to_mem
(paren
r_int
r_int
id|s_reg
)paren
(brace
r_return
(paren
(paren
id|s_reg
op_rshift
l_int|62
)paren
op_lshift
l_int|30
)paren
op_or
(paren
(paren
id|s_reg
op_lshift
l_int|5
)paren
op_rshift
l_int|34
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle user-level unaligned fault.  Handling user-level unaligned&n; * faults is *extremely* slow and produces nasty messages.  A user&n; * program *should* fix unaligned faults ASAP.&n; *&n; * Notice that we have (almost) the regular kernel stack layout here,&n; * so finding the appropriate registers is a little more difficult&n; * than in the kernel case.&n; *&n; * Finally, we handle regular integer load/stores only.  In&n; * particular, load-linked/store-conditionally and floating point&n; * load/stores are not supported.  The former make no sense with&n; * unaligned faults (they are guaranteed to fail) and I don&squot;t think&n; * the latter will occur in any decent program.&n; *&n; * Sigh. We *do* have to handle some FP operations, because GCC will&n; * uses them as temporary storage for integer memory to memory copies.&n; * However, we need to deal with stt/ldt and sts/lds only.&n; */
DECL|function|do_entUnaUser
id|asmlinkage
r_void
id|do_entUnaUser
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|frame
)paren
(brace
r_int
id|dir
comma
id|size
suffix:semicolon
r_int
r_int
op_star
id|reg_addr
comma
op_star
id|pc_addr
comma
id|usp
comma
id|zero
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|last_time
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|alpha_write_fp_reg
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|val
)paren
suffix:semicolon
r_extern
r_int
r_int
id|alpha_read_fp_reg
(paren
r_int
r_int
id|reg
)paren
suffix:semicolon
id|pc_addr
op_assign
id|frame
op_plus
l_int|7
op_plus
l_int|20
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* pc in PAL frame */
r_if
c_cond
(paren
id|cnt
op_ge
l_int|5
op_logical_and
id|jiffies
op_minus
id|last_time
OG
l_int|5
op_star
id|HZ
)paren
(brace
id|cnt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|cnt
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d): unaligned trap at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
op_star
id|pc_addr
op_minus
l_int|4
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
)brace
id|last_time
op_assign
id|jiffies
suffix:semicolon
op_increment
id|unaligned
(braket
l_int|1
)braket
dot
id|count
suffix:semicolon
id|unaligned
(braket
l_int|1
)braket
dot
id|va
op_assign
(paren
r_int
r_int
)paren
id|va
op_minus
l_int|4
suffix:semicolon
id|unaligned
(braket
l_int|1
)braket
dot
id|pc
op_assign
op_star
id|pc_addr
suffix:semicolon
id|dir
op_assign
id|VERIFY_READ
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x4
)paren
(brace
multiline_comment|/* it&squot;s a stl, stq, stt, or sts */
id|dir
op_assign
id|VERIFY_WRITE
suffix:semicolon
)brace
id|size
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x1
)paren
(brace
multiline_comment|/* it&squot;s a quadword op */
id|size
op_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|dir
comma
id|va
comma
id|size
)paren
)paren
(brace
op_star
id|pc_addr
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to faulting insn */
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reg_addr
op_assign
id|frame
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_ge
l_int|0x28
)paren
(brace
multiline_comment|/* it&squot;s an integer load/store */
r_switch
c_cond
(paren
id|reg
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
r_case
l_int|6
suffix:colon
r_case
l_int|7
suffix:colon
r_case
l_int|8
suffix:colon
multiline_comment|/* v0-t7 in SAVE_ALL frame */
id|reg_addr
op_add_assign
l_int|7
op_plus
id|reg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
r_case
l_int|10
suffix:colon
r_case
l_int|11
suffix:colon
r_case
l_int|12
suffix:colon
r_case
l_int|13
suffix:colon
r_case
l_int|14
suffix:colon
r_case
l_int|15
suffix:colon
multiline_comment|/* s0-s6 in entUna frame */
id|reg_addr
op_add_assign
(paren
id|reg
op_minus
l_int|9
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
r_case
l_int|17
suffix:colon
r_case
l_int|18
suffix:colon
multiline_comment|/* a0-a2 in PAL frame */
id|reg_addr
op_add_assign
l_int|7
op_plus
l_int|20
op_plus
l_int|3
op_plus
(paren
id|reg
op_minus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19
suffix:colon
r_case
l_int|20
suffix:colon
r_case
l_int|21
suffix:colon
r_case
l_int|22
suffix:colon
r_case
l_int|23
suffix:colon
r_case
l_int|24
suffix:colon
r_case
l_int|25
suffix:colon
r_case
l_int|26
suffix:colon
r_case
l_int|27
suffix:colon
r_case
l_int|28
suffix:colon
multiline_comment|/* a3-at in SAVE_ALL frame */
id|reg_addr
op_add_assign
l_int|7
op_plus
l_int|9
op_plus
(paren
id|reg
op_minus
l_int|19
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|29
suffix:colon
multiline_comment|/* gp in PAL frame */
id|reg_addr
op_add_assign
l_int|7
op_plus
l_int|20
op_plus
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|30
suffix:colon
multiline_comment|/* usp in PAL regs */
id|usp
op_assign
id|rdusp
c_func
(paren
)paren
suffix:semicolon
id|reg_addr
op_assign
op_amp
id|usp
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|31
suffix:colon
multiline_comment|/* zero &quot;register&quot; */
id|reg_addr
op_assign
op_amp
id|zero
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x22
suffix:colon
multiline_comment|/* lds */
id|alpha_write_fp_reg
c_func
(paren
id|reg
comma
id|s_mem_to_reg
c_func
(paren
id|get_unaligned
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|va
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x26
suffix:colon
multiline_comment|/* sts */
id|put_unaligned
c_func
(paren
id|s_reg_to_mem
c_func
(paren
id|alpha_read_fp_reg
c_func
(paren
id|reg
)paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x23
suffix:colon
multiline_comment|/* ldt */
id|alpha_write_fp_reg
c_func
(paren
id|reg
comma
id|get_unaligned
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|va
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x27
suffix:colon
multiline_comment|/* stt */
id|put_unaligned
c_func
(paren
id|alpha_read_fp_reg
c_func
(paren
id|reg
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x28
suffix:colon
multiline_comment|/* ldl */
op_star
id|reg_addr
op_assign
id|get_unaligned
c_func
(paren
(paren
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2c
suffix:colon
multiline_comment|/* stl */
id|put_unaligned
c_func
(paren
op_star
id|reg_addr
comma
(paren
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x29
suffix:colon
multiline_comment|/* ldq */
op_star
id|reg_addr
op_assign
id|get_unaligned
c_func
(paren
(paren
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2d
suffix:colon
multiline_comment|/* stq */
id|put_unaligned
c_func
(paren
op_star
id|reg_addr
comma
(paren
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|pc_addr
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to faulting insn */
id|force_sig
c_func
(paren
id|SIGBUS
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opcode
op_ge
l_int|0x28
op_logical_and
id|reg
op_eq
l_int|30
op_logical_and
id|dir
op_eq
id|VERIFY_WRITE
)paren
(brace
id|wrusp
c_func
(paren
id|usp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * DEC means people to use the &quot;retsys&quot; instruction for return from&n; * a system call, but they are clearly misguided about this. We use&n; * &quot;rti&quot; in all cases, and fill in the stack with the return values.&n; * That should make signal handling etc much cleaner.&n; *&n; * Even more horribly, DEC doesn&squot;t allow system calls from kernel mode.&n; * &quot;Security&quot; features letting the user do something the kernel can&squot;t&n; * are a thinko. DEC palcode is strange. The PAL-code designers probably&n; * got terminally tainted by VMS at some point.&n; */
DECL|function|do_entSys
id|asmlinkage
r_int
id|do_entSys
c_func
(paren
r_int
r_int
id|a0
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_if
c_cond
(paren
id|regs.r0
op_ne
l_int|112
)paren
id|printk
c_func
(paren
l_string|&quot;&lt;sc %ld(%lx,%lx,%lx)&gt;&quot;
comma
id|regs.r0
comma
id|a0
comma
id|a1
comma
id|a2
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_extern
id|asmlinkage
r_void
id|entMM
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entIF
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entArith
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entUna
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|entSys
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|trap_init
r_void
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|gptr
suffix:semicolon
multiline_comment|/*&n;&t; * Tell PAL-code what global pointer we want in the kernel..&n;&t; */
id|__asm__
c_func
(paren
l_string|&quot;br %0,___tmp&bslash;n&quot;
l_string|&quot;___tmp:&bslash;tldgp %0,0(%0)&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|gptr
)paren
)paren
suffix:semicolon
id|wrkgp
c_func
(paren
id|gptr
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entArith
comma
l_int|1
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entMM
comma
l_int|2
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entIF
comma
l_int|3
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entUna
comma
l_int|4
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entSys
comma
l_int|5
)paren
suffix:semicolon
)brace
eof
