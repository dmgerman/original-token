multiline_comment|/*&n; * arch/alpha/kernel/traps.c&n; *&n; * (C) Copyright 1994 Linus Torvalds&n; */
multiline_comment|/*&n; * This file initializes the trap entry points&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/gentrap.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/sysinfo.h&gt;
macro_line|#include &quot;proto.h&quot;
r_void
DECL|function|dik_show_regs
id|dik_show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
op_star
id|r9_15
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pc = [&lt;%016lx&gt;]  ra = [&lt;%016lx&gt;]  ps = %04lx&bslash;n&quot;
comma
id|regs-&gt;pc
comma
id|regs-&gt;r26
comma
id|regs-&gt;ps
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;v0 = %016lx  t0 = %016lx  t1 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t2 = %016lx  t3 = %016lx  t4 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r3
comma
id|regs-&gt;r4
comma
id|regs-&gt;r5
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t5 = %016lx  t6 = %016lx  t7 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r6
comma
id|regs-&gt;r7
comma
id|regs-&gt;r8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r9_15
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;s0 = %016lx  s1 = %016lx  s2 = %016lx&bslash;n&quot;
comma
id|r9_15
(braket
l_int|9
)braket
comma
id|r9_15
(braket
l_int|10
)braket
comma
id|r9_15
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;s3 = %016lx  s4 = %016lx  s5 = %016lx&bslash;n&quot;
comma
id|r9_15
(braket
l_int|12
)braket
comma
id|r9_15
(braket
l_int|13
)braket
comma
id|r9_15
(braket
l_int|14
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;s6 = %016lx&bslash;n&quot;
comma
id|r9_15
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;a0 = %016lx  a1 = %016lx  a2 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r16
comma
id|regs-&gt;r17
comma
id|regs-&gt;r18
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;a3 = %016lx  a4 = %016lx  a5 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r19
comma
id|regs-&gt;r20
comma
id|regs-&gt;r21
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t8 = %016lx  t9 = %016lx  t10= %016lx&bslash;n&quot;
comma
id|regs-&gt;r22
comma
id|regs-&gt;r23
comma
id|regs-&gt;r24
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t11= %016lx  pv = %016lx  at = %016lx&bslash;n&quot;
comma
id|regs-&gt;r25
comma
id|regs-&gt;r27
comma
id|regs-&gt;r28
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;gp = %016lx  sp = %p&bslash;n&quot;
comma
id|regs-&gt;gp
comma
id|regs
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
id|__halt
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|ireg_name
r_static
r_char
op_star
id|ireg_name
(braket
)braket
op_assign
(brace
l_string|&quot;v0&quot;
comma
l_string|&quot;t0&quot;
comma
l_string|&quot;t1&quot;
comma
l_string|&quot;t2&quot;
comma
l_string|&quot;t3&quot;
comma
l_string|&quot;t4&quot;
comma
l_string|&quot;t5&quot;
comma
l_string|&quot;t6&quot;
comma
l_string|&quot;t7&quot;
comma
l_string|&quot;s0&quot;
comma
l_string|&quot;s1&quot;
comma
l_string|&quot;s2&quot;
comma
l_string|&quot;s3&quot;
comma
l_string|&quot;s4&quot;
comma
l_string|&quot;s5&quot;
comma
l_string|&quot;s6&quot;
comma
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
comma
l_string|&quot;a2&quot;
comma
l_string|&quot;a3&quot;
comma
l_string|&quot;a4&quot;
comma
l_string|&quot;a5&quot;
comma
l_string|&quot;t8&quot;
comma
l_string|&quot;t9&quot;
comma
l_string|&quot;t10&quot;
comma
l_string|&quot;t11&quot;
comma
l_string|&quot;ra&quot;
comma
l_string|&quot;pv&quot;
comma
l_string|&quot;at&quot;
comma
l_string|&quot;gp&quot;
comma
l_string|&quot;sp&quot;
comma
l_string|&quot;zero&quot;
)brace
suffix:semicolon
DECL|variable|inst_name
r_static
r_char
op_star
id|inst_name
(braket
)braket
op_assign
(brace
l_string|&quot;call_pal&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;lda&quot;
comma
l_string|&quot;ldah&quot;
comma
l_string|&quot;ldbu&quot;
comma
l_string|&quot;ldq_u&quot;
comma
l_string|&quot;ldwu&quot;
comma
l_string|&quot;stw&quot;
comma
l_string|&quot;stb&quot;
comma
l_string|&quot;stq_u&quot;
comma
l_string|&quot;ALU&quot;
comma
l_string|&quot;ALU&quot;
comma
l_string|&quot;ALU&quot;
comma
l_string|&quot;ALU&quot;
comma
l_string|&quot;SQRT&quot;
comma
l_string|&quot;FVAX&quot;
comma
l_string|&quot;FIEEE&quot;
comma
l_string|&quot;FLOAT&quot;
comma
l_string|&quot;MISC&quot;
comma
l_string|&quot;PAL19&quot;
comma
l_string|&quot;JMP&quot;
comma
l_string|&quot;PAL1B&quot;
comma
l_string|&quot;GRAPH&quot;
comma
l_string|&quot;PAL1D&quot;
comma
l_string|&quot;PAL1E&quot;
comma
l_string|&quot;PAL1F&quot;
comma
l_string|&quot;ldf&quot;
comma
l_string|&quot;ldg&quot;
comma
l_string|&quot;lds&quot;
comma
l_string|&quot;ldt&quot;
comma
l_string|&quot;stf&quot;
comma
l_string|&quot;stg&quot;
comma
l_string|&quot;sts&quot;
comma
l_string|&quot;stt&quot;
comma
l_string|&quot;ldl&quot;
comma
l_string|&quot;ldq&quot;
comma
l_string|&quot;ldl_l&quot;
comma
l_string|&quot;ldq_l&quot;
comma
l_string|&quot;stl&quot;
comma
l_string|&quot;stq&quot;
comma
l_string|&quot;stl_c&quot;
comma
l_string|&quot;stq_c&quot;
comma
l_string|&quot;br&quot;
comma
l_string|&quot;fbeq&quot;
comma
l_string|&quot;fblt&quot;
comma
l_string|&quot;fble&quot;
comma
l_string|&quot;bsr&quot;
comma
l_string|&quot;fbne&quot;
comma
l_string|&quot;fbge&quot;
comma
l_string|&quot;fbgt&quot;
l_string|&quot;blbc&quot;
comma
l_string|&quot;beq&quot;
comma
l_string|&quot;blt&quot;
comma
l_string|&quot;ble&quot;
comma
l_string|&quot;blbs&quot;
comma
l_string|&quot;bne&quot;
comma
l_string|&quot;bge&quot;
comma
l_string|&quot;bgt&quot;
)brace
suffix:semicolon
DECL|variable|jump_name
r_static
r_char
op_star
id|jump_name
(braket
)braket
op_assign
(brace
l_string|&quot;jmp&quot;
comma
l_string|&quot;jsr&quot;
comma
l_string|&quot;ret&quot;
comma
l_string|&quot;jsr_coroutine&quot;
)brace
suffix:semicolon
DECL|member|func
DECL|member|text
DECL|typedef|alist
r_typedef
r_struct
(brace
r_int
id|func
suffix:semicolon
r_char
op_star
id|text
suffix:semicolon
)brace
id|alist
suffix:semicolon
DECL|variable|inta_name
r_static
id|alist
id|inta_name
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_string|&quot;addl&quot;
)brace
comma
(brace
l_int|2
comma
l_string|&quot;s4addl&quot;
)brace
comma
(brace
l_int|9
comma
l_string|&quot;subl&quot;
)brace
comma
(brace
l_int|0xb
comma
l_string|&quot;s4subl&quot;
)brace
comma
(brace
l_int|0xf
comma
l_string|&quot;cmpbge&quot;
)brace
comma
(brace
l_int|0x12
comma
l_string|&quot;s8addl&quot;
)brace
comma
(brace
l_int|0x1b
comma
l_string|&quot;s8subl&quot;
)brace
comma
(brace
l_int|0x1d
comma
l_string|&quot;cmpult&quot;
)brace
comma
(brace
l_int|0x20
comma
l_string|&quot;addq&quot;
)brace
comma
(brace
l_int|0x22
comma
l_string|&quot;s4addq&quot;
)brace
comma
(brace
l_int|0x29
comma
l_string|&quot;subq&quot;
)brace
comma
(brace
l_int|0x2b
comma
l_string|&quot;s4subq&quot;
)brace
comma
(brace
l_int|0x2d
comma
l_string|&quot;cmpeq&quot;
)brace
comma
(brace
l_int|0x32
comma
l_string|&quot;s8addq&quot;
)brace
comma
(brace
l_int|0x3b
comma
l_string|&quot;s8subq&quot;
)brace
comma
(brace
l_int|0x3d
comma
l_string|&quot;cmpule&quot;
)brace
comma
(brace
l_int|0x40
comma
l_string|&quot;addl/v&quot;
)brace
comma
(brace
l_int|0x49
comma
l_string|&quot;subl/v&quot;
)brace
comma
(brace
l_int|0x4d
comma
l_string|&quot;cmplt&quot;
)brace
comma
(brace
l_int|0x60
comma
l_string|&quot;addq/v&quot;
)brace
comma
(brace
l_int|0x69
comma
l_string|&quot;subq/v&quot;
)brace
comma
(brace
l_int|0x6d
comma
l_string|&quot;cmple&quot;
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|intl_name
r_static
id|alist
id|intl_name
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_string|&quot;and&quot;
)brace
comma
(brace
l_int|8
comma
l_string|&quot;andnot&quot;
)brace
comma
(brace
l_int|0x14
comma
l_string|&quot;cmovlbs&quot;
)brace
comma
(brace
l_int|0x16
comma
l_string|&quot;cmovlbc&quot;
)brace
comma
(brace
l_int|0x20
comma
l_string|&quot;or&quot;
)brace
comma
(brace
l_int|0x24
comma
l_string|&quot;cmoveq&quot;
)brace
comma
(brace
l_int|0x26
comma
l_string|&quot;cmovne&quot;
)brace
comma
(brace
l_int|0x28
comma
l_string|&quot;ornot&quot;
)brace
comma
(brace
l_int|0x40
comma
l_string|&quot;xor&quot;
)brace
comma
(brace
l_int|0x44
comma
l_string|&quot;cmovlt&quot;
)brace
comma
(brace
l_int|0x46
comma
l_string|&quot;cmovge&quot;
)brace
comma
(brace
l_int|0x48
comma
l_string|&quot;eqv&quot;
)brace
comma
(brace
l_int|0x61
comma
l_string|&quot;amask&quot;
)brace
comma
(brace
l_int|0x64
comma
l_string|&quot;cmovle&quot;
)brace
comma
(brace
l_int|0x66
comma
l_string|&quot;cmovgt&quot;
)brace
comma
(brace
l_int|0x6c
comma
l_string|&quot;implver&quot;
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|ints_name
r_static
id|alist
id|ints_name
(braket
)braket
op_assign
(brace
(brace
l_int|2
comma
l_string|&quot;mskbl&quot;
)brace
comma
(brace
l_int|6
comma
l_string|&quot;extbl&quot;
)brace
comma
(brace
l_int|0xb
comma
l_string|&quot;insbl&quot;
)brace
comma
(brace
l_int|0x12
comma
l_string|&quot;mskwl&quot;
)brace
comma
(brace
l_int|0x16
comma
l_string|&quot;extwl&quot;
)brace
comma
(brace
l_int|0x1b
comma
l_string|&quot;inswl&quot;
)brace
comma
(brace
l_int|0x22
comma
l_string|&quot;mskll&quot;
)brace
comma
(brace
l_int|0x26
comma
l_string|&quot;extll&quot;
)brace
comma
(brace
l_int|0x2b
comma
l_string|&quot;insll&quot;
)brace
comma
(brace
l_int|0x30
comma
l_string|&quot;zap&quot;
)brace
comma
(brace
l_int|0x31
comma
l_string|&quot;zapnot&quot;
)brace
comma
(brace
l_int|0x32
comma
l_string|&quot;mskql&quot;
)brace
comma
(brace
l_int|0x34
comma
l_string|&quot;srl&quot;
)brace
comma
(brace
l_int|0x36
comma
l_string|&quot;extql&quot;
)brace
comma
(brace
l_int|0x39
comma
l_string|&quot;sll&quot;
)brace
comma
(brace
l_int|0x3b
comma
l_string|&quot;insql&quot;
)brace
comma
(brace
l_int|0x3c
comma
l_string|&quot;sra&quot;
)brace
comma
(brace
l_int|0x52
comma
l_string|&quot;mskwh&quot;
)brace
comma
(brace
l_int|0x57
comma
l_string|&quot;inswh&quot;
)brace
comma
(brace
l_int|0x5a
comma
l_string|&quot;extwh&quot;
)brace
comma
(brace
l_int|0x62
comma
l_string|&quot;msklh&quot;
)brace
comma
(brace
l_int|0x67
comma
l_string|&quot;inslh&quot;
)brace
comma
(brace
l_int|0x6a
comma
l_string|&quot;extlh&quot;
)brace
comma
(brace
l_int|0x72
comma
l_string|&quot;mskqh&quot;
)brace
comma
(brace
l_int|0x77
comma
l_string|&quot;insqh&quot;
)brace
comma
(brace
l_int|0x7a
comma
l_string|&quot;extqh&quot;
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|intm_name
r_static
id|alist
id|intm_name
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_string|&quot;mull&quot;
)brace
comma
(brace
l_int|0x20
comma
l_string|&quot;mulq&quot;
)brace
comma
(brace
l_int|0x30
comma
l_string|&quot;umulh&quot;
)brace
comma
(brace
l_int|0x40
comma
l_string|&quot;mull/v&quot;
)brace
comma
(brace
l_int|0x60
comma
l_string|&quot;mulq/v&quot;
)brace
comma
(brace
op_minus
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|int_name
r_static
id|alist
op_star
id|int_name
(braket
)braket
op_assign
(brace
id|inta_name
comma
id|intl_name
comma
id|ints_name
comma
id|intm_name
)brace
suffix:semicolon
r_static
r_char
op_star
DECL|function|assoc
id|assoc
c_func
(paren
r_int
id|fcode
comma
id|alist
op_star
id|a
)paren
(brace
r_while
c_loop
(paren
(paren
id|fcode
op_ne
id|a-&gt;func
)paren
op_logical_and
(paren
id|a-&gt;func
op_ne
op_minus
l_int|1
)paren
)paren
op_increment
id|a
suffix:semicolon
r_return
id|a-&gt;text
suffix:semicolon
)brace
r_static
r_char
op_star
DECL|function|iname
id|iname
c_func
(paren
r_int
r_int
id|instr
)paren
(brace
r_int
id|opcode
op_assign
id|instr
op_rshift
l_int|26
suffix:semicolon
r_char
op_star
id|name
op_assign
id|inst_name
(braket
id|opcode
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
r_case
l_int|0x11
suffix:colon
r_case
l_int|0x12
suffix:colon
r_case
l_int|0x13
suffix:colon
(brace
r_char
op_star
id|specific_name
op_assign
id|assoc
c_func
(paren
(paren
id|instr
op_rshift
l_int|5
)paren
op_amp
l_int|0x3f
comma
id|int_name
(braket
id|opcode
op_minus
l_int|0x10
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|specific_name
)paren
id|name
op_assign
id|specific_name
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|0x1a
suffix:colon
id|name
op_assign
id|jump_name
(braket
(paren
id|instr
op_rshift
l_int|14
)paren
op_amp
l_int|3
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|name
suffix:semicolon
)brace
DECL|enumerator|NOT_INST
DECL|enumerator|PAL
DECL|enumerator|BRANCH
DECL|enumerator|MEMORY
DECL|enumerator|JUMP
DECL|enumerator|OPERATE
DECL|enumerator|FOPERATE
DECL|enumerator|MISC
r_static
r_enum
(brace
id|NOT_INST
comma
id|PAL
comma
id|BRANCH
comma
id|MEMORY
comma
id|JUMP
comma
id|OPERATE
comma
id|FOPERATE
comma
id|MISC
)brace
DECL|function|iformat
id|iformat
c_func
(paren
r_int
id|opcode
)paren
(brace
r_if
c_cond
(paren
id|opcode
op_ge
l_int|0x30
)paren
r_return
id|BRANCH
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_ge
l_int|0x20
)paren
r_return
id|MEMORY
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0
)paren
r_return
id|PAL
suffix:semicolon
r_if
c_cond
(paren
id|opcode
OL
l_int|8
)paren
r_return
id|NOT_INST
suffix:semicolon
r_if
c_cond
(paren
id|opcode
OL
l_int|0x10
)paren
r_return
id|MEMORY
suffix:semicolon
r_if
c_cond
(paren
id|opcode
OL
l_int|0x14
)paren
r_return
id|OPERATE
suffix:semicolon
r_if
c_cond
(paren
id|opcode
OL
l_int|0x18
)paren
r_return
id|FOPERATE
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x18
suffix:colon
r_return
id|MISC
suffix:semicolon
r_case
l_int|0x1A
suffix:colon
r_return
id|JUMP
suffix:semicolon
r_case
l_int|0x1C
suffix:colon
r_return
id|OPERATE
suffix:semicolon
r_default
suffix:colon
r_return
id|NOT_INST
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The purpose here is to provide useful clues about a kernel crash, so&n; * less likely instructions, e.g. floating point, aren&squot;t fully decoded.&n; */
r_static
r_void
DECL|function|disassemble
id|disassemble
c_func
(paren
r_int
r_int
id|instr
)paren
(brace
r_int
id|optype
op_assign
id|instr
op_rshift
l_int|26
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
comma
op_star
id|s
op_assign
id|buf
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%08x  %s &quot;
comma
id|instr
comma
id|iname
c_func
(paren
id|instr
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|iformat
c_func
(paren
id|optype
)paren
)paren
(brace
r_default
suffix:colon
r_case
id|NOT_INST
suffix:colon
r_case
id|MISC
suffix:colon
r_break
suffix:semicolon
r_case
id|PAL
suffix:colon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%d&quot;
comma
id|instr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRANCH
suffix:colon
(brace
r_int
id|reg
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|offset
op_assign
id|instr
op_amp
l_int|0x1fffff
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
l_int|0x100000
)paren
id|offset
op_sub_assign
l_int|0x200000
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|optype
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|optype
op_ge
l_int|0x38
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|optype
op_ne
l_int|0x30
)paren
op_logical_or
(paren
id|reg
op_ne
l_int|0x1f
)paren
)paren
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s,&quot;
comma
id|ireg_name
(braket
id|reg
)braket
)paren
suffix:semicolon
)brace
r_else
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;f%d,&quot;
comma
id|reg
)paren
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;.%+d&quot;
comma
(paren
id|offset
op_plus
l_int|1
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MEMORY
suffix:colon
(brace
r_int
id|addr_reg
op_assign
(paren
id|instr
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|value_reg
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|offset
op_assign
id|instr
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
l_int|0x8000
)paren
id|offset
op_sub_assign
l_int|0x10000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|optype
op_ge
l_int|0x20
)paren
op_logical_and
(paren
id|optype
OL
l_int|0x28
)paren
)paren
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;f%d&quot;
comma
id|value_reg
)paren
suffix:semicolon
r_else
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s&quot;
comma
id|ireg_name
(braket
id|value_reg
)braket
)paren
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;,%d(%s)&quot;
comma
id|offset
comma
id|ireg_name
(braket
id|addr_reg
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|JUMP
suffix:colon
(brace
r_int
id|target_reg
op_assign
(paren
id|instr
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|return_reg
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s,&quot;
comma
id|ireg_name
(braket
id|return_reg
)braket
)paren
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;(%s)&quot;
comma
id|ireg_name
(braket
id|target_reg
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|OPERATE
suffix:colon
(brace
r_int
id|areg
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|breg
op_assign
(paren
id|instr
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|creg
op_assign
id|instr
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|litflag
op_assign
id|instr
op_amp
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:semicolon
r_int
id|lit
op_assign
(paren
id|instr
op_rshift
l_int|13
)paren
op_amp
l_int|0xff
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s,&quot;
comma
id|ireg_name
(braket
id|areg
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|litflag
)paren
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%d&quot;
comma
id|lit
)paren
suffix:semicolon
r_else
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;%s&quot;
comma
id|ireg_name
(braket
id|breg
)braket
)paren
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;,%s&quot;
comma
id|ireg_name
(braket
id|creg
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|FOPERATE
suffix:colon
(brace
r_int
id|areg
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|breg
op_assign
(paren
id|instr
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_int
id|creg
op_assign
id|instr
op_amp
l_int|0x1f
suffix:semicolon
id|s
op_add_assign
id|sprintf
c_func
(paren
id|s
comma
l_string|&quot;f%d,f%d,f%d&quot;
comma
id|areg
comma
id|breg
comma
id|creg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|buf
(braket
id|s
op_minus
id|buf
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dik_show_code
id|dik_show_code
c_func
(paren
r_int
r_int
op_star
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Code:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|6
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|insn
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|insn
comma
id|pc
op_plus
id|i
)paren
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;*&squot;
)paren
suffix:semicolon
id|disassemble
c_func
(paren
id|insn
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dik_show_trace
id|dik_show_trace
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Trace:&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|0x1ff8
op_amp
(paren
r_int
r_int
)paren
id|sp
)paren
(brace
r_extern
r_int
r_int
id|_stext
comma
id|_etext
suffix:semicolon
r_int
r_int
id|tmp
op_assign
op_star
id|sp
suffix:semicolon
id|sp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Assume that only the low 24-bits of a kernel text address&n;&t;&t; * is interesting.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%6x%c&quot;
comma
(paren
r_int
)paren
id|tmp
op_amp
l_int|0xffffff
comma
(paren
op_increment
id|i
op_mod
l_int|11
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ...&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_void
DECL|function|die_if_kernel
id|die_if_kernel
c_func
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
comma
r_int
r_int
op_star
id|r9_15
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;ps
op_amp
l_int|8
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printk
c_func
(paren
l_string|&quot;CPU %d &quot;
comma
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s(%d): %s %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
)paren
suffix:semicolon
id|dik_show_regs
c_func
(paren
id|regs
comma
id|r9_15
)paren
suffix:semicolon
id|dik_show_code
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
id|dik_show_trace
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|regs
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
(paren
l_int|1UL
op_lshift
l_int|63
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;die_if_kernel recursion detected.&bslash;n&quot;
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|current-&gt;thread.flags
op_or_assign
(paren
l_int|1UL
op_lshift
l_int|63
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_MATHEMU
DECL|function|dummy_emul
r_static
r_int
id|dummy_emul
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|alpha_fp_emul_imprecise
r_int
(paren
op_star
id|alpha_fp_emul_imprecise
)paren
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|writemask
)paren
op_assign
(paren
r_void
op_star
)paren
id|dummy_emul
suffix:semicolon
DECL|variable|alpha_fp_emul
r_int
(paren
op_star
id|alpha_fp_emul
)paren
(paren
r_int
r_int
id|pc
)paren
op_assign
(paren
r_void
op_star
)paren
id|dummy_emul
suffix:semicolon
macro_line|#else
r_int
id|alpha_fp_emul_imprecise
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|writemask
)paren
suffix:semicolon
r_int
id|alpha_fp_emul
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
macro_line|#endif
id|asmlinkage
r_void
DECL|function|do_entArith
id|do_entArith
c_func
(paren
r_int
r_int
id|summary
comma
r_int
r_int
id|write_mask
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_if
c_cond
(paren
id|summary
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Software-completion summary bit is set, so try to&n;&t;&t;   emulate the instruction.  */
r_if
c_cond
(paren
op_logical_neg
id|amask
c_func
(paren
id|AMASK_PRECISE_TRAP
)paren
)paren
(brace
multiline_comment|/* 21264 (except pass 1) has precise exceptions.  */
r_if
c_cond
(paren
id|alpha_fp_emul
c_func
(paren
id|regs.pc
op_minus
l_int|4
)paren
)paren
r_return
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|alpha_fp_emul_imprecise
c_func
(paren
op_amp
id|regs
comma
id|write_mask
)paren
)paren
r_return
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;%s: arithmetic trap at %016lx: %02lx %016lx&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|regs.pc
comma
id|summary
comma
id|write_mask
)paren
suffix:semicolon
macro_line|#endif
id|die_if_kernel
c_func
(paren
l_string|&quot;Arithmetic fault&quot;
comma
op_amp
id|regs
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
id|asmlinkage
r_void
DECL|function|do_entIF
id|do_entIF
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
id|die_if_kernel
c_func
(paren
(paren
id|type
op_eq
l_int|1
ques
c_cond
l_string|&quot;Kernel Bug&quot;
suffix:colon
l_string|&quot;Instruction fault&quot;
)paren
comma
op_amp
id|regs
comma
id|type
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* breakpoint */
r_if
c_cond
(paren
id|ptrace_cancel_bpt
c_func
(paren
id|current
)paren
)paren
(brace
id|regs.pc
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to former bpt */
)brace
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* bugcheck */
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* gentrap */
multiline_comment|/*&n;&t;&t; * The exception code should be passed on to the signal&n;&t;&t; * handler as the second argument.  Linux doesn&squot;t do that&n;&t;&t; * yet (also notice that Linux *always* behaves like&n;&t;&t; * DEC Unix with SA_SIGINFO off; see DEC Unix man page&n;&t;&t; * for sigaction(2)).&n;&t;&t; */
r_switch
c_cond
(paren
(paren
r_int
)paren
id|regs.r16
)paren
(brace
r_case
id|GEN_INTOVF
suffix:colon
r_case
id|GEN_INTDIV
suffix:colon
r_case
id|GEN_FLTOVF
suffix:colon
r_case
id|GEN_FLTDIV
suffix:colon
r_case
id|GEN_FLTUND
suffix:colon
r_case
id|GEN_FLTINV
suffix:colon
r_case
id|GEN_FLTINE
suffix:colon
r_case
id|GEN_ROPRAND
suffix:colon
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_DECOVF
suffix:colon
r_case
id|GEN_DECDIV
suffix:colon
r_case
id|GEN_DECINV
suffix:colon
r_case
id|GEN_ASSERTERR
suffix:colon
r_case
id|GEN_NULPTRERR
suffix:colon
r_case
id|GEN_STKOVF
suffix:colon
r_case
id|GEN_STRLENERR
suffix:colon
r_case
id|GEN_SUBSTRERR
suffix:colon
r_case
id|GEN_RANGERR
suffix:colon
r_case
id|GEN_SUBRNG
suffix:colon
r_case
id|GEN_SUBRNG1
suffix:colon
r_case
id|GEN_SUBRNG2
suffix:colon
r_case
id|GEN_SUBRNG3
suffix:colon
r_case
id|GEN_SUBRNG4
suffix:colon
r_case
id|GEN_SUBRNG5
suffix:colon
r_case
id|GEN_SUBRNG6
suffix:colon
r_case
id|GEN_SUBRNG7
suffix:colon
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* FEN fault */
id|send_sig
c_func
(paren
id|SIGILL
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* opDEC */
r_if
c_cond
(paren
id|implver
c_func
(paren
)paren
op_eq
id|IMPLVER_EV4
)paren
(brace
multiline_comment|/* EV4 does not implement anything except normal&n;&t;&t;&t;   rounding.  Everything else will come here as&n;&t;&t;&t;   an illegal instruction.  Emulate them.  */
r_if
c_cond
(paren
id|alpha_fp_emul
c_func
(paren
id|regs.pc
op_minus
l_int|4
)paren
)paren
r_return
suffix:semicolon
)brace
id|send_sig
c_func
(paren
id|SIGILL
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;do_entIF: unexpected instruction-fault type&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* There is an ifdef in the PALcode in MILO that enables a &n;   &quot;kernel debugging entry point&quot; as an unprivilaged call_pal.&n;&n;   We don&squot;t want to have anything to do with it, but unfortunately&n;   several versions of MILO included in distributions have it enabled,&n;   and if we don&squot;t put something on the entry point we&squot;ll oops.  */
id|asmlinkage
r_void
DECL|function|do_entDbg
id|do_entDbg
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
id|die_if_kernel
c_func
(paren
l_string|&quot;Instruction fault&quot;
comma
op_amp
id|regs
comma
id|type
comma
l_int|0
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGILL
comma
id|current
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * entUna has a different register layout to be reasonably simple. It&n; * needs access to all the integer registers (the kernel doesn&squot;t use&n; * fp-regs), and it needs to have them in order for simpler access.&n; *&n; * Due to the non-standard register layout (and because we don&squot;t want&n; * to handle floating-point regs), user-mode unaligned accesses are&n; * handled separately by do_entUnaUser below.&n; *&n; * Oh, btw, we don&squot;t handle the &quot;gp&quot; register correctly, but if we fault&n; * on a gp-register unaligned load/store, something is _very_ wrong&n; * in the kernel anyway..&n; */
DECL|struct|allregs
r_struct
id|allregs
(brace
DECL|member|regs
r_int
r_int
id|regs
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|ps
DECL|member|pc
DECL|member|gp
DECL|member|a0
DECL|member|a1
DECL|member|a2
r_int
r_int
id|ps
comma
id|pc
comma
id|gp
comma
id|a0
comma
id|a1
comma
id|a2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|unaligned_stat
r_struct
id|unaligned_stat
(brace
DECL|member|count
DECL|member|va
DECL|member|pc
r_int
r_int
id|count
comma
id|va
comma
id|pc
suffix:semicolon
DECL|variable|unaligned
)brace
id|unaligned
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Macro for exception fixup code to access integer registers.  */
DECL|macro|una_reg
mdefine_line|#define una_reg(r)  (regs.regs[(r) &gt;= 16 &amp;&amp; (r) &lt;= 18 ? (r)+19 : (r)])
id|asmlinkage
r_void
DECL|function|do_entUna
id|do_entUna
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|allregs
id|regs
)paren
(brace
r_int
id|error
comma
id|tmp1
comma
id|tmp2
comma
id|tmp3
comma
id|tmp4
suffix:semicolon
r_int
r_int
id|pc
op_assign
id|regs.pc
op_minus
l_int|4
suffix:semicolon
r_int
id|fixup
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|count
op_increment
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|va
op_assign
(paren
r_int
r_int
)paren
id|va
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* We don&squot;t want to use the generic get/put unaligned macros as&n;&t;   we want to trap exceptions.  Only if we actually get an&n;&t;   exception will we decide whether we should have caught it.  */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* ldwu */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,1(%3)&bslash;n&quot;
l_string|&quot;&t;extwl %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extwh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x28
suffix:colon
multiline_comment|/* ldl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,3(%3)&bslash;n&quot;
l_string|&quot;&t;extll %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extlh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
(paren
r_int
)paren
(paren
id|tmp1
op_or
id|tmp2
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x29
suffix:colon
multiline_comment|/* ldq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,7(%3)&bslash;n&quot;
l_string|&quot;&t;extql %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extqh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* Note that the store sequences do not indicate that they change&n;&t;   memory because it _should_ be affecting nothing in this context.&n;&t;   (Otherwise we have other, much larger, problems.)  */
r_case
l_int|0x0d
suffix:colon
multiline_comment|/* stw */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inswh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;inswl %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskwh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskwl %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x2c
suffix:colon
multiline_comment|/* stl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inslh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insll %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;msklh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskll %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x2d
suffix:colon
multiline_comment|/* stq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;insqh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insql %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskqh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskql %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&bslash;t&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bad unaligned kernel access at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|pc
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
id|got_exception
suffix:colon
multiline_comment|/* Ok, we caught the exception, but we don&squot;t want it.  Is there&n;&t;   someone to pass it along to?  */
r_if
c_cond
(paren
(paren
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|pc
comma
id|regs.gp
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|newpc
suffix:semicolon
id|newpc
op_assign
id|fixup_exception
c_func
(paren
id|una_reg
comma
id|fixup
comma
id|pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Forwarding unaligned exception at %lx (%lx)&bslash;n&quot;
comma
id|pc
comma
id|newpc
)paren
suffix:semicolon
(paren
op_amp
id|regs
)paren
op_member_access_from_pointer
id|pc
op_assign
id|newpc
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Yikes!  No one to forward the exception to.&n;&t; * Since the registers are in a weird format, dump them ourselves.&n; &t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d): unhandled unaligned exception&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pc = [&lt;%016lx&gt;]  ra = [&lt;%016lx&gt;]  ps = %04lx&bslash;n&quot;
comma
id|pc
comma
id|una_reg
c_func
(paren
l_int|26
)paren
comma
id|regs.ps
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r0 = %016lx  r1 = %016lx  r2 = %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|0
)paren
comma
id|una_reg
c_func
(paren
l_int|1
)paren
comma
id|una_reg
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r3 = %016lx  r4 = %016lx  r5 = %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|3
)paren
comma
id|una_reg
c_func
(paren
l_int|4
)paren
comma
id|una_reg
c_func
(paren
l_int|5
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r6 = %016lx  r7 = %016lx  r8 = %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|6
)paren
comma
id|una_reg
c_func
(paren
l_int|7
)paren
comma
id|una_reg
c_func
(paren
l_int|8
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r9 = %016lx  r10= %016lx  r11= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|9
)paren
comma
id|una_reg
c_func
(paren
l_int|10
)paren
comma
id|una_reg
c_func
(paren
l_int|11
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r12= %016lx  r13= %016lx  r14= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|12
)paren
comma
id|una_reg
c_func
(paren
l_int|13
)paren
comma
id|una_reg
c_func
(paren
l_int|14
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r15= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|15
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r16= %016lx  r17= %016lx  r18= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|16
)paren
comma
id|una_reg
c_func
(paren
l_int|17
)paren
comma
id|una_reg
c_func
(paren
l_int|18
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r19= %016lx  r20= %016lx  r21= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|19
)paren
comma
id|una_reg
c_func
(paren
l_int|20
)paren
comma
id|una_reg
c_func
(paren
l_int|21
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r22= %016lx  r23= %016lx  r24= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|22
)paren
comma
id|una_reg
c_func
(paren
l_int|23
)paren
comma
id|una_reg
c_func
(paren
l_int|24
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r25= %016lx  r27= %016lx  r28= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|25
)paren
comma
id|una_reg
c_func
(paren
l_int|27
)paren
comma
id|una_reg
c_func
(paren
l_int|28
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;gp = %016lx  sp = %p&bslash;n&quot;
comma
id|regs.gp
comma
op_amp
id|regs
op_plus
l_int|1
)paren
suffix:semicolon
id|dik_show_code
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|pc
)paren
suffix:semicolon
id|dik_show_trace
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|regs
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
(paren
l_int|1UL
op_lshift
l_int|63
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;die_if_kernel recursion detected.&bslash;n&quot;
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|current-&gt;thread.flags
op_or_assign
(paren
l_int|1UL
op_lshift
l_int|63
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an s-floating point value in memory format to the&n; * corresponding value in register format.  The exponent&n; * needs to be remapped to preserve non-finite values&n; * (infinities, not-a-numbers, denormals).&n; */
r_static
r_inline
r_int
r_int
DECL|function|s_mem_to_reg
id|s_mem_to_reg
(paren
r_int
r_int
id|s_mem
)paren
(brace
r_int
r_int
id|frac
op_assign
(paren
id|s_mem
op_rshift
l_int|0
)paren
op_amp
l_int|0x7fffff
suffix:semicolon
r_int
r_int
id|sign
op_assign
(paren
id|s_mem
op_rshift
l_int|31
)paren
op_amp
l_int|0x1
suffix:semicolon
r_int
r_int
id|exp_msb
op_assign
(paren
id|s_mem
op_rshift
l_int|30
)paren
op_amp
l_int|0x1
suffix:semicolon
r_int
r_int
id|exp_low
op_assign
(paren
id|s_mem
op_rshift
l_int|23
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_int
r_int
id|exp
suffix:semicolon
id|exp
op_assign
(paren
id|exp_msb
op_lshift
l_int|10
)paren
op_or
id|exp_low
suffix:semicolon
multiline_comment|/* common case */
r_if
c_cond
(paren
id|exp_msb
)paren
(brace
r_if
c_cond
(paren
id|exp_low
op_eq
l_int|0x7f
)paren
(brace
id|exp
op_assign
l_int|0x7ff
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|exp_low
op_eq
l_int|0x00
)paren
(brace
id|exp
op_assign
l_int|0x000
suffix:semicolon
)brace
r_else
(brace
id|exp
op_or_assign
(paren
l_int|0x7
op_lshift
l_int|7
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|sign
op_lshift
l_int|63
)paren
op_or
(paren
id|exp
op_lshift
l_int|52
)paren
op_or
(paren
id|frac
op_lshift
l_int|29
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an s-floating point value in register format to the&n; * corresponding value in memory format.&n; */
r_static
r_inline
r_int
r_int
DECL|function|s_reg_to_mem
id|s_reg_to_mem
(paren
r_int
r_int
id|s_reg
)paren
(brace
r_return
(paren
(paren
id|s_reg
op_rshift
l_int|62
)paren
op_lshift
l_int|30
)paren
op_or
(paren
(paren
id|s_reg
op_lshift
l_int|5
)paren
op_rshift
l_int|34
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle user-level unaligned fault.  Handling user-level unaligned&n; * faults is *extremely* slow and produces nasty messages.  A user&n; * program *should* fix unaligned faults ASAP.&n; *&n; * Notice that we have (almost) the regular kernel stack layout here,&n; * so finding the appropriate registers is a little more difficult&n; * than in the kernel case.&n; *&n; * Finally, we handle regular integer load/stores only.  In&n; * particular, load-linked/store-conditionally and floating point&n; * load/stores are not supported.  The former make no sense with&n; * unaligned faults (they are guaranteed to fail) and I don&squot;t think&n; * the latter will occur in any decent program.&n; *&n; * Sigh. We *do* have to handle some FP operations, because GCC will&n; * uses them as temporary storage for integer memory to memory copies.&n; * However, we need to deal with stt/ldt and sts/lds only.&n; */
DECL|macro|OP_INT_MASK
mdefine_line|#define OP_INT_MASK&t;( 1L &lt;&lt; 0x28 | 1L &lt;&lt; 0x2c   /* ldl stl */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x29 | 1L &lt;&lt; 0x2d   /* ldq stq */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x0c | 1L &lt;&lt; 0x0d   /* ldwu stw */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x0a | 1L &lt;&lt; 0x0e ) /* ldbu stb */
DECL|macro|OP_WRITE_MASK
mdefine_line|#define OP_WRITE_MASK&t;( 1L &lt;&lt; 0x26 | 1L &lt;&lt; 0x27   /* sts stt */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x2c | 1L &lt;&lt; 0x2d   /* stl stq */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x0d | 1L &lt;&lt; 0x0e ) /* stw stb */
DECL|macro|R
mdefine_line|#define R(x)&t;((size_t) &amp;((struct pt_regs *)0)-&gt;x)
DECL|variable|unauser_reg_offsets
r_static
r_int
id|unauser_reg_offsets
(braket
l_int|32
)braket
op_assign
(brace
id|R
c_func
(paren
id|r0
)paren
comma
id|R
c_func
(paren
id|r1
)paren
comma
id|R
c_func
(paren
id|r2
)paren
comma
id|R
c_func
(paren
id|r3
)paren
comma
id|R
c_func
(paren
id|r4
)paren
comma
id|R
c_func
(paren
id|r5
)paren
comma
id|R
c_func
(paren
id|r6
)paren
comma
id|R
c_func
(paren
id|r7
)paren
comma
id|R
c_func
(paren
id|r8
)paren
comma
multiline_comment|/* r9 ... r15 are stored in front of regs.  */
op_minus
l_int|56
comma
op_minus
l_int|48
comma
op_minus
l_int|40
comma
op_minus
l_int|32
comma
op_minus
l_int|24
comma
op_minus
l_int|16
comma
op_minus
l_int|8
comma
id|R
c_func
(paren
id|r16
)paren
comma
id|R
c_func
(paren
id|r17
)paren
comma
id|R
c_func
(paren
id|r18
)paren
comma
id|R
c_func
(paren
id|r19
)paren
comma
id|R
c_func
(paren
id|r20
)paren
comma
id|R
c_func
(paren
id|r21
)paren
comma
id|R
c_func
(paren
id|r22
)paren
comma
id|R
c_func
(paren
id|r23
)paren
comma
id|R
c_func
(paren
id|r24
)paren
comma
id|R
c_func
(paren
id|r25
)paren
comma
id|R
c_func
(paren
id|r26
)paren
comma
id|R
c_func
(paren
id|r27
)paren
comma
id|R
c_func
(paren
id|r28
)paren
comma
id|R
c_func
(paren
id|gp
)paren
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|macro|R
macro_line|#undef R
id|asmlinkage
r_void
DECL|function|do_entUnaUser
id|do_entUnaUser
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_static
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|last_time
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tmp1
comma
id|tmp2
comma
id|tmp3
comma
id|tmp4
suffix:semicolon
r_int
r_int
id|fake_reg
comma
op_star
id|reg_addr
op_assign
op_amp
id|fake_reg
suffix:semicolon
r_int
r_int
id|uac_bits
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* Check the UAC bits to decide what the user wants us to do&n;&t;   with the unaliged access.  */
id|uac_bits
op_assign
(paren
id|current-&gt;thread.flags
op_rshift
id|UAC_SHIFT
)paren
op_amp
id|UAC_BITMASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|uac_bits
op_amp
id|UAC_NOPRINT
)paren
)paren
(brace
r_if
c_cond
(paren
id|cnt
op_ge
l_int|5
op_logical_and
id|jiffies
op_minus
id|last_time
OG
l_int|5
op_star
id|HZ
)paren
(brace
id|cnt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|cnt
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d): unaligned trap at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|regs-&gt;pc
op_minus
l_int|4
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
)brace
id|last_time
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uac_bits
op_amp
id|UAC_SIGBUS
)paren
(brace
r_goto
id|give_sigbus
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uac_bits
op_amp
id|UAC_NOFIX
)paren
(brace
multiline_comment|/* Not sure why you&squot;d want to use this, but... */
r_return
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t bother reading ds in the access check since we already&n;&t;   know that this came from the user.  Also rely on the fact that&n;&t;   the page at TASK_SIZE is unmapped and so can&squot;t be touched anyway. */
r_if
c_cond
(paren
op_logical_neg
id|__access_ok
c_func
(paren
(paren
r_int
r_int
)paren
id|va
comma
l_int|0
comma
id|USER_DS
)paren
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_increment
id|unaligned
(braket
l_int|1
)braket
dot
id|count
suffix:semicolon
id|unaligned
(braket
l_int|1
)braket
dot
id|va
op_assign
(paren
r_int
r_int
)paren
id|va
suffix:semicolon
id|unaligned
(braket
l_int|1
)braket
dot
id|pc
op_assign
id|regs-&gt;pc
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1L
op_lshift
id|opcode
)paren
op_amp
id|OP_INT_MASK
)paren
(brace
multiline_comment|/* it&squot;s an integer load/store */
r_if
c_cond
(paren
id|reg
OL
l_int|30
)paren
(brace
id|reg_addr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|regs
op_plus
id|unauser_reg_offsets
(braket
id|reg
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reg
op_eq
l_int|30
)paren
(brace
multiline_comment|/* usp in PAL regs */
id|fake_reg
op_assign
id|rdusp
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* zero &quot;register&quot; */
id|fake_reg
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* We don&squot;t want to use the generic get/put unaligned macros as&n;&t;   we want to trap exceptions.  Only if we actually get an&n;&t;   exception will we decide whether we should have caught it.  */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* ldwu */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,1(%3)&bslash;n&quot;
l_string|&quot;&t;extwl %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extwh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_star
id|reg_addr
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x22
suffix:colon
multiline_comment|/* lds */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,3(%3)&bslash;n&quot;
l_string|&quot;&t;extll %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extlh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
id|alpha_write_fp_reg
c_func
(paren
id|reg
comma
id|s_mem_to_reg
c_func
(paren
(paren
r_int
)paren
(paren
id|tmp1
op_or
id|tmp2
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x23
suffix:colon
multiline_comment|/* ldt */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,7(%3)&bslash;n&quot;
l_string|&quot;&t;extql %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extqh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
id|alpha_write_fp_reg
c_func
(paren
id|reg
comma
id|tmp1
op_or
id|tmp2
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x28
suffix:colon
multiline_comment|/* ldl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,3(%3)&bslash;n&quot;
l_string|&quot;&t;extll %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extlh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_star
id|reg_addr
op_assign
(paren
r_int
)paren
(paren
id|tmp1
op_or
id|tmp2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x29
suffix:colon
multiline_comment|/* ldq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,7(%3)&bslash;n&quot;
l_string|&quot;&t;extql %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extqh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_star
id|reg_addr
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note that the store sequences do not indicate that they change&n;&t;   memory because it _should_ be affecting nothing in this context.&n;&t;   (Otherwise we have other, much larger, problems.)  */
r_case
l_int|0x0d
suffix:colon
multiline_comment|/* stw */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inswh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;inswl %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskwh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskwl %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
op_star
id|reg_addr
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x26
suffix:colon
multiline_comment|/* sts */
id|fake_reg
op_assign
id|s_reg_to_mem
c_func
(paren
id|alpha_read_fp_reg
c_func
(paren
id|reg
)paren
)paren
suffix:semicolon
multiline_comment|/* FALLTHRU */
r_case
l_int|0x2c
suffix:colon
multiline_comment|/* stl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inslh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insll %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;msklh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskll %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
op_star
id|reg_addr
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x27
suffix:colon
multiline_comment|/* stt */
id|fake_reg
op_assign
id|alpha_read_fp_reg
c_func
(paren
id|reg
)paren
suffix:semicolon
multiline_comment|/* FALLTHRU */
r_case
l_int|0x2d
suffix:colon
multiline_comment|/* stq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;insqh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insql %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskqh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskql %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&bslash;t&quot;
l_string|&quot;&t;.gprel32 1b&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 2b&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 3b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.gprel32 4b&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
op_star
id|reg_addr
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* What instruction were you trying to use, exactly?  */
r_goto
id|give_sigbus
suffix:semicolon
)brace
multiline_comment|/* Only integer loads should get here; everyone else returns early. */
r_if
c_cond
(paren
id|reg
op_eq
l_int|30
)paren
id|wrusp
c_func
(paren
id|fake_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
id|give_sigsegv
suffix:colon
id|regs-&gt;pc
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to faulting insn */
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
id|give_sigbus
suffix:colon
id|regs-&gt;pc
op_sub_assign
l_int|4
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGBUS
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Unimplemented system calls.&n; */
id|asmlinkage
r_int
DECL|function|alpha_ni_syscall
id|alpha_ni_syscall
c_func
(paren
r_int
r_int
id|a0
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
multiline_comment|/* We only get here for OSF system calls, minus #112;&n;&t;   the rest go to sys_ni_syscall.  */
id|printk
c_func
(paren
l_string|&quot;&lt;sc %ld(%lx,%lx,%lx)&gt;&quot;
comma
id|regs.r0
comma
id|a0
comma
id|a1
comma
id|a2
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_void
DECL|function|trap_init
id|trap_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Tell PAL-code what global pointer we want in the kernel.  */
r_register
r_int
r_int
id|gptr
id|__asm__
c_func
(paren
l_string|&quot;$29&quot;
)paren
suffix:semicolon
id|wrkgp
c_func
(paren
id|gptr
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entArith
comma
l_int|1
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entMM
comma
l_int|2
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entIF
comma
l_int|3
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entUna
comma
l_int|4
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entSys
comma
l_int|5
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entDbg
comma
l_int|6
)paren
suffix:semicolon
)brace
eof
