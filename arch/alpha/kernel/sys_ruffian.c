multiline_comment|/*&n; *&t;linux/arch/alpha/kernel/sys_ruffian.c&n; *&n; *&t;Copyright (C) 1995 David A Rusling&n; *&t;Copyright (C) 1996 Jay A Estabrook&n; *&t;Copyright (C) 1998 Richard Henderson&n; *&n; * Code supporting the RUFFIAN.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/core_pyxis.h&gt;
macro_line|#include &quot;proto.h&quot;
macro_line|#include &quot;irq.h&quot;
macro_line|#include &quot;bios32.h&quot;
macro_line|#include &quot;machvec.h&quot;
r_static
r_void
DECL|function|ruffian_update_irq_hw
id|ruffian_update_irq_hw
c_func
(paren
r_int
r_int
id|irq
comma
r_int
r_int
id|mask
comma
r_int
id|unmask_p
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ge
l_int|16
)paren
(brace
multiline_comment|/* Note inverted sense of mask bits: */
multiline_comment|/* Make CERTAIN none of the bogus ints get enabled... */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_MASK
op_assign
op_complement
(paren
(paren
r_int
)paren
id|mask
op_rshift
l_int|16
)paren
op_amp
l_int|0x00000000ffffffbfUL
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ... and read it back to make sure it got written.  */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_MASK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq
op_ge
l_int|8
)paren
id|outb
c_func
(paren
id|mask
op_rshift
l_int|8
comma
l_int|0xA1
)paren
suffix:semicolon
multiline_comment|/* ISA PIC2 */
r_else
id|outb
c_func
(paren
id|mask
comma
l_int|0x21
)paren
suffix:semicolon
multiline_comment|/* ISA PIC1 */
)brace
r_static
r_void
DECL|function|ruffian_ack_irq
id|ruffian_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
OL
l_int|16
)paren
(brace
multiline_comment|/* Ack PYXIS ISA interrupt.  */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
op_assign
l_int|1L
op_lshift
l_int|7
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ... and read it back to make sure it got written.  */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
l_int|7
)paren
(brace
id|outb
c_func
(paren
l_int|0x20
comma
l_int|0xa0
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x20
comma
l_int|0x20
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Ack PYXIS PCI interrupt.  */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
op_assign
(paren
l_int|1UL
op_lshift
(paren
id|irq
op_minus
l_int|16
)paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ... and read it back to make sure it got written.  */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ruffian_device_interrupt
id|ruffian_device_interrupt
c_func
(paren
r_int
r_int
id|vector
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|pld
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* Read the interrupt summary register of PYXIS */
id|pld
op_assign
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
suffix:semicolon
multiline_comment|/* For now, AND off any bits we are not interested in:&n;&t; * HALT (2), timer (6), ISA Bridge (7), 21142 (8)&n;&t; * then all the PCI slots/INTXs (12-31) &n;&t; * flash(5) :DWH:&n;&t; */
id|pld
op_and_assign
l_int|0x00000000ffffff9fUL
suffix:semicolon
multiline_comment|/* was ffff7f */
multiline_comment|/*&n;&t; * Now for every possible bit set, work through them and call&n;&t; * the appropriate interrupt handler.&n;&t; */
r_while
c_loop
(paren
id|pld
)paren
(brace
id|i
op_assign
id|ffz
c_func
(paren
op_complement
id|pld
)paren
suffix:semicolon
id|pld
op_and_assign
id|pld
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* clear least bit set */
r_if
c_cond
(paren
id|i
op_eq
l_int|7
)paren
(brace
multiline_comment|/* if ISA int */
multiline_comment|/* Ruffian does not have the RTC connected to &n;&t;&t;&t;   the CPU timer interrupt.  Instead, it uses the&n;&t;&t;&t;   PIT connected to IRQ 0.  So we must detect that&n;&t;&t;&t;   and route that specifically to where we expected&n;&t;&t;&t;   to find the timer interrupt come in.  */
multiline_comment|/* Copy this code from isa_device_interrupt because&n;&t;&t;&t;   we need to hook into int 0 for the timer.  I&n;&t;&t;&t;   refuse to soil device_interrupt with ifdefs.  */
multiline_comment|/* Generate a PCI interrupt acknowledge cycle.&n;&t;&t;&t;   The PIC will respond with the interrupt&n;&t;&t;&t;   vector of the highest priority interrupt&n;&t;&t;&t;   that is pending.  The PALcode sets up the&n;&t;&t;&t;   interrupts vectors such that irq level L&n;&t;&t;&t;   generates vector L.  */
r_int
r_int
id|j
op_assign
op_star
(paren
id|vuip
)paren
id|PYXIS_IACK_SC
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|7
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
l_int|0x20
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* It&squot;s only a passive release... */
)brace
r_else
r_if
c_cond
(paren
id|j
op_eq
l_int|0
)paren
(brace
id|handle_irq
c_func
(paren
id|TIMER_IRQ
comma
op_minus
l_int|1
comma
id|regs
)paren
suffix:semicolon
id|ruffian_ack_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|handle_irq
c_func
(paren
id|j
comma
id|j
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* if not an ISA int */
id|handle_irq
c_func
(paren
l_int|16
op_plus
id|i
comma
l_int|16
op_plus
id|i
comma
id|regs
)paren
suffix:semicolon
)brace
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
op_assign
l_int|1UL
op_lshift
id|i
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
suffix:semicolon
multiline_comment|/* read to force the write */
)brace
)brace
r_static
r_void
id|__init
DECL|function|ruffian_init_irq
id|ruffian_init_irq
c_func
(paren
r_void
)paren
(brace
id|STANDARD_INIT_IRQ_PROLOG
suffix:semicolon
multiline_comment|/* Invert 6&amp;7 for i82371 */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_HILO
op_assign
l_int|0x000000c0UL
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_CNFG
op_assign
l_int|0x00002064UL
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* all clear */
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_MASK
op_assign
l_int|0x00000000UL
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|PYXIS_INT_REQ
op_assign
l_int|0xffffffffUL
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x11
comma
l_int|0xA0
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x08
comma
l_int|0xA1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x02
comma
l_int|0xA1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
l_int|0xA1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xFF
comma
l_int|0xA1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x11
comma
l_int|0x20
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
l_int|0x21
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x04
comma
l_int|0x21
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
l_int|0x21
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xFF
comma
l_int|0x21
)paren
suffix:semicolon
multiline_comment|/* Send -INTA pulses to clear any pending interrupts ...*/
op_star
(paren
id|vuip
)paren
id|PYXIS_IACK_SC
suffix:semicolon
multiline_comment|/* Finish writing the 82C59A PIC Operation Control Words */
id|outb
c_func
(paren
l_int|0x20
comma
l_int|0xA0
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* Turn on the interrupt controller, the timer interrupt  */
id|enable_irq
c_func
(paren
l_int|16
op_plus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* enable ISA PIC cascade */
id|enable_irq
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* enable timer */
id|enable_irq
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* enable 2nd PIC cascade */
)brace
multiline_comment|/*&n; * For RUFFIAN, we do not want to make any modifications to the PCI&n; * setup.  But we may need to do some kind of init.&n; */
r_static
r_void
id|__init
DECL|function|ruffian_pci_fixup
id|ruffian_pci_fixup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* layout_all_busses(DEFAULT_IO_BASE, DEFAULT_MEM_BASE); */
)brace
macro_line|#ifdef BUILDING_FOR_MILO
multiline_comment|/*&n; * The DeskStation Ruffian motherboard firmware does not place&n; * the memory size in the PALimpure area.  Therefore, we use&n; * the Bank Configuration Registers in PYXIS to obtain the size.&n; */
r_static
r_int
r_int
id|__init
DECL|function|ruffian_get_bank_size
id|ruffian_get_bank_size
c_func
(paren
r_int
r_int
id|offset
)paren
(brace
r_int
r_int
id|bank_addr
comma
id|bank
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Valid offsets are: 0x800, 0x840 and 0x880&n;&t;   since Ruffian only uses three banks.  */
id|bank_addr
op_assign
(paren
r_int
r_int
)paren
id|PYXIS_MCR
op_plus
id|offset
suffix:semicolon
id|bank
op_assign
op_star
(paren
id|vulp
)paren
id|bank_addr
suffix:semicolon
multiline_comment|/* Check BANK_ENABLE */
r_if
c_cond
(paren
id|bank
op_amp
l_int|0x01
)paren
(brace
r_static
r_int
r_int
id|size
(braket
)braket
id|__initlocaldata
op_assign
(brace
l_int|0x40000000UL
comma
multiline_comment|/* 0x00,   1G */
l_int|0x20000000UL
comma
multiline_comment|/* 0x02, 512M */
l_int|0x10000000UL
comma
multiline_comment|/* 0x04, 256M */
l_int|0x08000000UL
comma
multiline_comment|/* 0x06, 128M */
l_int|0x04000000UL
comma
multiline_comment|/* 0x08,  64M */
l_int|0x02000000UL
comma
multiline_comment|/* 0x0a,  32M */
l_int|0x01000000UL
comma
multiline_comment|/* 0x0c,  16M */
l_int|0x00800000UL
comma
multiline_comment|/* 0x0e,   8M */
l_int|0x80000000UL
comma
multiline_comment|/* 0x10,   2G */
)brace
suffix:semicolon
id|bank
op_assign
(paren
id|bank
op_amp
l_int|0x1e
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bank
OL
r_sizeof
(paren
id|size
)paren
op_div
r_sizeof
(paren
op_star
id|size
)paren
)paren
id|ret
op_assign
id|size
(braket
id|bank
)braket
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* BUILDING_FOR_MILO */
r_static
r_void
id|__init
DECL|function|ruffian_init_arch
id|ruffian_init_arch
c_func
(paren
r_int
r_int
op_star
id|mem_start
comma
r_int
r_int
op_star
id|mem_end
)paren
(brace
multiline_comment|/* FIXME: What do we do with ruffian_get_bank_size above?  */
id|pyxis_enable_errors
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pyxis_srm_window_setup
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ruffian_init_arch: Skipping window register rewrites.&quot;
l_string|&quot;&bslash;n... Trust DeskStation firmware!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pyxis_finish_init_arch
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ruffian_init_pit
id|ruffian_init_pit
(paren
r_void
)paren
(brace
multiline_comment|/* Ruffian depends on the system timer established in MILO! */
id|request_region
c_func
(paren
l_int|0x70
comma
l_int|0x10
comma
l_string|&quot;timer&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xb6
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* pit counter 2: speaker */
id|outb
c_func
(paren
l_int|0x31
comma
l_int|0x42
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x13
comma
l_int|0x42
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ruffian_kill_arch
id|ruffian_kill_arch
(paren
r_int
id|mode
comma
r_char
op_star
id|reboot_cmd
)paren
(brace
macro_line|#if 0
multiline_comment|/* this only causes re-entry to ARCSBIOS */
multiline_comment|/* Perhaps this works for other PYXIS as well?  */
op_star
(paren
id|vuip
)paren
id|PYXIS_RESET
op_assign
l_int|0x0000dead
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|generic_kill_arch
c_func
(paren
id|mode
comma
id|reboot_cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The System Vector&n; */
DECL|variable|__initmv
r_struct
id|alpha_machine_vector
id|ruffian_mv
id|__initmv
op_assign
(brace
id|vector_name
suffix:colon
l_string|&quot;Ruffian&quot;
comma
id|DO_EV5_MMU
comma
id|DO_DEFAULT_RTC
comma
multiline_comment|/* For the moment, do not use BWIO on RUFFIAN.  */
id|IO
c_func
(paren
id|PYXIS
comma
id|pyxis
comma
id|pyxis
)paren
comma
id|DO_PYXIS_BUS
comma
id|machine_check
suffix:colon
id|pyxis_machine_check
comma
id|max_dma_address
suffix:colon
id|ALPHA_RUFFIAN_MAX_DMA_ADDRESS
comma
id|nr_irqs
suffix:colon
l_int|48
comma
id|irq_probe_mask
suffix:colon
id|RUFFIAN_PROBE_MASK
comma
id|update_irq_hw
suffix:colon
id|ruffian_update_irq_hw
comma
id|ack_irq
suffix:colon
id|ruffian_ack_irq
comma
id|device_interrupt
suffix:colon
id|ruffian_device_interrupt
comma
id|init_arch
suffix:colon
id|ruffian_init_arch
comma
id|init_irq
suffix:colon
id|ruffian_init_irq
comma
id|init_pit
suffix:colon
id|ruffian_init_pit
comma
id|pci_fixup
suffix:colon
id|ruffian_pci_fixup
comma
id|kill_arch
suffix:colon
id|ruffian_kill_arch
comma
)brace
suffix:semicolon
id|ALIAS_MV
c_func
(paren
id|ruffian
)paren
eof
