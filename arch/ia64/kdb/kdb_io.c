multiline_comment|/*&n; * Kernel Debugger Console I/O handler&n; *&n; * Copyright (C) 1999 Silicon Graphics, Inc.&n; * Copyright (C) Scott Lurndal (slurn@engr.sgi.com)&n; * Copyright (C) Scott Foehner (sfoehner@engr.sgi.com)&n; * Copyright (C) Srinivasa Thirumalachar (sprasad@engr.sgi.com)&n; *&n; * Written March 1999 by Scott Lurndal at Silicon Graphics, Inc.&n; *&n; * Modifications from:&n; *&t;Chuck Fleckenstein&t;&t;1999/07/20&n; *&t;&t;Move kdb_info struct declaration to this file&n; *&t;&t;for cases where serial support is not compiled into&n; *&t;&t;the kernel.&n; *&n; *&t;Masahiro Adegawa&t;&t;1999/07/20&n; *&t;&t;Handle some peculiarities of japanese 86/106&n; *&t;&t;keyboards.&n; *&n; *&t;marc@mucom.co.il&t;&t;1999/07/20&n; *&t;&t;Catch buffer overflow for serial input.&n; *&n; *      Scott Foehner  &n; *              Port to ia64&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;pc_keyb.h&quot;
DECL|variable|kdb_port
r_int
id|kdb_port
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This module contains code to read characters from the keyboard or a serial&n; * port.&n; * &n; * It is used by the kernel debugger, and is polled, not interrupt driven.&n; *&n; */
multiline_comment|/*&n; * send:  Send a byte to the keyboard controller.  Used primarily to &n; * &t;  alter LED settings.&n; */
r_static
r_void
DECL|function|kdb_kbdsend
id|kdb_kbdsend
c_func
(paren
r_int
r_char
id|byte
)paren
(brace
r_while
c_loop
(paren
id|inb
c_func
(paren
id|KBD_STATUS_REG
)paren
op_amp
id|KBD_STAT_IBF
)paren
suffix:semicolon
id|outb
c_func
(paren
id|KBD_DATA_REG
comma
id|byte
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|kdb_kbdsetled
id|kdb_kbdsetled
c_func
(paren
r_int
id|leds
)paren
(brace
id|kdb_kbdsend
c_func
(paren
id|KBD_CMD_SET_LEDS
)paren
suffix:semicolon
id|kdb_kbdsend
c_func
(paren
(paren
r_int
r_char
)paren
id|leds
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|console_read
id|console_read
(paren
r_char
op_star
id|buffer
comma
r_int
id|bufsize
)paren
(brace
r_struct
id|console
op_star
id|in
suffix:semicolon
r_struct
id|console
op_star
id|out
suffix:semicolon
r_char
op_star
id|cp
comma
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|in
op_assign
id|console_drivers
suffix:semicolon
id|in
suffix:semicolon
id|in
op_assign
id|in-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|in-&gt;flags
op_amp
id|CON_ENABLED
)paren
op_logical_and
(paren
id|in-&gt;read
op_logical_or
id|in-&gt;wait_key
)paren
)paren
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|out
op_assign
id|console_drivers
suffix:semicolon
id|out
suffix:semicolon
id|out
op_assign
id|out-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|out-&gt;flags
op_amp
id|CON_ENABLED
)paren
op_logical_and
id|out-&gt;write
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|in-&gt;read
op_logical_and
op_logical_neg
id|in-&gt;wait_key
)paren
op_logical_or
op_logical_neg
id|out-&gt;write
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;kdb_io: can&squot;t do console i/o!&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in-&gt;read
)paren
(brace
multiline_comment|/* this is untested... */
(paren
op_star
id|in-&gt;read
)paren
(paren
id|in
comma
id|buffer
comma
id|bufsize
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bufsize
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* leave room for CR &amp; NUL terminator */
id|cp
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ch
op_assign
(paren
op_star
id|in-&gt;wait_key
)paren
(paren
id|in
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|cp
OG
id|buffer
)paren
(brace
op_decrement
id|cp
comma
op_increment
id|bufsize
suffix:semicolon
(paren
op_star
id|out-&gt;write
)paren
(paren
id|out
comma
l_string|&quot;&bslash;b &bslash;b&quot;
comma
l_int|3
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;025&squot;
suffix:colon
r_while
c_loop
(paren
id|cp
OG
id|buffer
)paren
(brace
op_decrement
id|cp
comma
op_increment
id|bufsize
suffix:semicolon
(paren
op_star
id|out-&gt;write
)paren
(paren
id|out
comma
l_string|&quot;&bslash;b &bslash;b&quot;
comma
l_int|3
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
(paren
op_star
id|out-&gt;write
)paren
(paren
id|out
comma
l_string|&quot;&bslash;r&bslash;n&quot;
comma
l_int|2
)paren
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|bufsize
OG
l_int|0
)paren
(brace
(paren
op_star
id|out-&gt;write
)paren
(paren
id|out
comma
op_amp
id|ch
comma
l_int|1
)paren
suffix:semicolon
op_decrement
id|bufsize
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_char
op_star
DECL|function|kdb_getscancode
id|kdb_getscancode
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|bufsize
)paren
(brace
multiline_comment|/*&n;&t; * XXX Shouldn&squot;t kdb _always_ use console based I/O?  That&squot;s what the console&n;&t; * abstraction is for, after all... ---davidm&n;&t; */
macro_line|#ifdef CONFIG_IA64_HP_SIM
r_extern
id|spinlock_t
id|console_lock
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|console_lock
comma
id|flags
)paren
suffix:semicolon
id|console_read
c_func
(paren
id|buffer
comma
id|bufsize
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|console_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
macro_line|#else /* !CONFIG_IA64_HP_SIM */
r_char
op_star
id|cp
op_assign
id|buffer
suffix:semicolon
r_int
id|scancode
comma
id|scanstatus
suffix:semicolon
r_static
r_int
id|shift_lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CAPS LOCK state (0-off, 1-on) */
r_static
r_int
id|shift_key
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Shift next keypress */
r_static
r_int
id|ctrl_key
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|leds
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Num lock */
id|u_short
id|keychar
suffix:semicolon
r_extern
id|u_short
id|plain_map
(braket
)braket
comma
id|shift_map
(braket
)braket
comma
id|ctrl_map
(braket
)braket
suffix:semicolon
id|bufsize
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* Reserve space for newline and null byte */
multiline_comment|/*&n;&t; * If we came in via a serial console, we allow that to&n;&t; * be the input window for kdb.&n;&t; */
r_if
c_cond
(paren
id|kdb_port
op_ne
l_int|0
)paren
(brace
r_char
id|ch
suffix:semicolon
r_int
id|status
suffix:semicolon
mdefine_line|#define serial_inp(info, offset) inb((info) + (offset))
mdefine_line|#define serial_out(info, offset, v) outb((v), (info) + (offset))
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
(paren
id|status
op_assign
id|serial_inp
c_func
(paren
id|kdb_port
comma
id|UART_LSR
)paren
)paren
op_amp
id|UART_LSR_DR
)paren
(brace
id|readchar
suffix:colon
id|ch
op_assign
id|serial_inp
c_func
(paren
id|kdb_port
comma
id|UART_RX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_int|8
)paren
(brace
multiline_comment|/* BS */
r_if
c_cond
(paren
id|cp
OG
id|buffer
)paren
(brace
op_decrement
id|cp
comma
id|bufsize
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c %c&quot;
comma
l_int|0x08
comma
l_int|0x08
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|serial_out
c_func
(paren
id|kdb_port
comma
id|UART_TX
comma
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_int|13
)paren
(brace
multiline_comment|/* CR */
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|serial_out
c_func
(paren
id|kdb_port
comma
id|UART_TX
comma
l_int|10
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Discard excess characters&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bufsize
OG
l_int|0
)paren
(brace
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
id|bufsize
op_decrement
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
(paren
id|status
op_assign
id|serial_inp
c_func
(paren
id|kdb_port
comma
id|UART_LSR
)paren
)paren
op_amp
id|UART_LSR_DR
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Wait for a valid scancode&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|KBD_STATUS_REG
)paren
op_amp
id|KBD_STAT_OBF
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fetch the scancode&n;&t;&t; */
id|scancode
op_assign
id|inb
c_func
(paren
id|KBD_DATA_REG
)paren
suffix:semicolon
id|scanstatus
op_assign
id|inb
c_func
(paren
id|KBD_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ignore mouse events.&n;&t;&t; */
r_if
c_cond
(paren
id|scanstatus
op_amp
id|KBD_STAT_MOUSE_OBF
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ignore release, trigger on make&n;&t;&t; * (except for shift keys, where we want to &n;&t;&t; *  keep the shift state so long as the key is&n;&t;&t; *  held down).&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|scancode
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x2a
)paren
op_logical_or
(paren
(paren
id|scancode
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x36
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Next key may use shift table&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|scancode
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
id|shift_key
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|shift_key
op_assign
l_int|0
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scancode
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x1d
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Left ctrl key&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|scancode
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
id|ctrl_key
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ctrl_key
op_assign
l_int|0
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scancode
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|scancode
op_and_assign
l_int|0x7f
suffix:semicolon
multiline_comment|/*&n;&t; &t; * Translate scancode&n;&t;&t; */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x3a
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Toggle caps lock&n;&t;&t;&t; */
id|shift_lock
op_xor_assign
l_int|1
suffix:semicolon
id|leds
op_xor_assign
l_int|0x4
suffix:semicolon
multiline_comment|/* toggle caps lock led */
id|kdb_kbdsetled
c_func
(paren
id|leds
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x0e
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Backspace&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cp
OG
id|buffer
)paren
(brace
op_decrement
id|cp
comma
id|bufsize
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * XXX - erase character on screen&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%c %c&quot;
comma
l_int|0x08
comma
l_int|0x08
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xe0
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For Japanese 86/106 keyboards &n;&t;&t; * &t;See comment in drivers/char/pc_keyb.c.&n;&t;&t; * &t;- Masahiro Adegawa&n;&t;&t; */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x73
)paren
(brace
id|scancode
op_assign
l_int|0x59
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x7d
)paren
(brace
id|scancode
op_assign
l_int|0x7c
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|shift_lock
op_logical_and
op_logical_neg
id|shift_key
)paren
(brace
id|keychar
op_assign
id|plain_map
(braket
id|scancode
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|shift_lock
op_logical_or
id|shift_key
)paren
(brace
id|keychar
op_assign
id|shift_map
(braket
id|scancode
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ctrl_key
)paren
(brace
id|keychar
op_assign
id|ctrl_map
(braket
id|scancode
)braket
suffix:semicolon
)brace
r_else
(brace
id|keychar
op_assign
l_int|0x0020
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unknown state/scancode (%d)&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scancode
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x1c
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * enter key.  All done.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * echo the character.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|keychar
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufsize
)paren
(brace
op_decrement
id|bufsize
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|keychar
op_amp
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
multiline_comment|/* White space for parser */
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* String termination */
macro_line|#if defined(NOTNOW)
id|cp
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;char 0x%x&bslash;n&quot;
comma
op_star
id|cp
op_increment
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|buffer
suffix:semicolon
macro_line|#endif /* !CONFIG_IA64_HP_SIM */
)brace
eof
