multiline_comment|/*&n; * Minimalist Kernel Debugger&n; *&n; * Copyright (C) 1999 Silicon Graphics, Inc.&n; * Copyright (C) Scott Lurndal (slurn@engr.sgi.com)&n; * Copyright (C) Scott Foehner (sfoehner@engr.sgi.com)&n; * Copyright (C) Srinivasa Thirumalachar (sprasad@engr.sgi.com)&n; * Copyright (C) David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; *&n; * Written March 1999 by Scott Lurndal at Silicon Graphics, Inc.&n; *&n; * Modifications from:&n; *      Richard Bass                    1999/07/20&n; *              Many bug fixes and enhancements.&n; *      Scott Foehner&n; *              Port to ia64&n; *      Srinivasa Thirumalachar&n; *              RSE support for ia64&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kdb.h&gt;
macro_line|#include &lt;linux/stddef.h&gt; 
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/kdbsupport.h&gt;
macro_line|#include &lt;asm/rse.h&gt;
r_extern
id|kdb_state_t
id|kdb_state
suffix:semicolon
DECL|variable|dbregs
id|k_machreg_t
id|dbregs
(braket
id|KDB_DBREGS
)braket
suffix:semicolon
r_static
r_int
id|__init
DECL|function|kdb_setup
id|kdb_setup
(paren
r_char
op_star
id|str
)paren
(brace
id|kdb_flags
op_or_assign
id|KDB_FLAG_EARLYKDB
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;kdb&quot;
comma
id|kdb_setup
)paren
suffix:semicolon
r_static
r_int
DECL|function|kdb_ia64_sir
id|kdb_ia64_sir
(paren
r_int
id|argc
comma
r_const
r_char
op_star
op_star
id|argv
comma
r_const
r_char
op_star
op_star
id|envp
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u64
id|lid
comma
id|tpr
comma
id|lrr0
comma
id|lrr1
comma
id|itv
comma
id|pmv
comma
id|cmcv
suffix:semicolon
id|asm
(paren
l_string|&quot;mov %0=cr.lid&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lid
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;mov %0=cr.tpr&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tpr
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;mov %0=cr.lrr0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lrr0
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;mov %0=cr.lrr1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lrr1
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;lid=0x%lx, tpr=0x%lx, lrr0=0x%lx, llr1=0x%lx&bslash;n&quot;
comma
id|lid
comma
id|tpr
comma
id|lrr0
comma
id|lrr1
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;mov %0=cr.itv&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|itv
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;mov %0=cr.pmv&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pmv
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;mov %0=cr.cmcv&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cmcv
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;itv=0x%lx, pmv=0x%lx, cmcv=0x%lx&bslash;n&quot;
comma
id|itv
comma
id|pmv
comma
id|cmcv
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;irr=0x%016lx,0x%016lx,0x%016lx,0x%016lx&bslash;n&quot;
comma
id|ia64_get_irr0
c_func
(paren
)paren
comma
id|ia64_get_irr1
c_func
(paren
)paren
comma
id|ia64_get_irr2
c_func
(paren
)paren
comma
id|ia64_get_irr3
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
id|__init
DECL|function|kdb_init
id|kdb_init
(paren
r_void
)paren
(brace
r_extern
r_void
id|kdb_inittab
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
id|kdb_inittab
c_func
(paren
)paren
suffix:semicolon
id|kdb_initbptab
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|kdb_disinit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|kdb_printf
c_func
(paren
l_string|&quot;kdb version %d.%d by Scott Lurndal. &quot;
"&bslash;"
l_string|&quot;Copyright SGI, All Rights Reserved&bslash;n&quot;
comma
id|KDB_MAJOR_VERSION
comma
id|KDB_MINOR_VERSION
)paren
suffix:semicolon
multiline_comment|/* Enable debug registers */
id|__asm__
(paren
l_string|&quot;mov %0=psr&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|reg
)paren
)paren
suffix:semicolon
id|reg
op_or_assign
id|IA64_PSR_DB
suffix:semicolon
id|__asm__
(paren
l_string|&quot;mov psr.l=%0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|reg
)paren
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Init kdb state */
id|kdb_state.bkpt_handling_state
op_assign
id|BKPTSTATE_NOT_HANDLED
suffix:semicolon
id|kdb_register
c_func
(paren
l_string|&quot;irr&quot;
comma
id|kdb_ia64_sir
comma
l_string|&quot;&quot;
comma
l_string|&quot;Show interrupt registers&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbprintf&n; * kdbgetword&n; * kdb_getstr&n; */
r_char
op_star
DECL|function|kbd_getstr
id|kbd_getstr
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|bufsize
comma
r_char
op_star
id|prompt
)paren
(brace
r_extern
r_char
op_star
id|kdb_getscancode
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_SMP)
id|kdb_printf
c_func
(paren
id|prompt
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#else
id|kdb_printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|prompt
)paren
suffix:semicolon
macro_line|#endif
r_return
id|kdb_getscancode
c_func
(paren
id|buffer
comma
id|bufsize
)paren
suffix:semicolon
)brace
r_int
DECL|function|kdb_printf
id|kdb_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
id|va_list
id|ap
suffix:semicolon
r_int
id|diag
suffix:semicolon
r_int
id|linecount
suffix:semicolon
id|diag
op_assign
id|kdbgetintenv
c_func
(paren
l_string|&quot;LINES&quot;
comma
op_amp
id|linecount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diag
)paren
id|linecount
op_assign
l_int|22
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|buffer
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|buffer
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
op_ne
l_int|NULL
)paren
(brace
id|kdb_nextline
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kdb_nextline
op_eq
id|linecount
)paren
(brace
r_char
id|buf1
(braket
l_int|16
)braket
suffix:semicolon
r_char
id|buf2
(braket
l_int|32
)braket
suffix:semicolon
r_extern
r_char
op_star
id|kdb_getscancode
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_char
op_star
id|moreprompt
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Pause until cr.&n;&t;&t; */
id|moreprompt
op_assign
id|kdbgetenv
c_func
(paren
l_string|&quot;MOREPROMPT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|moreprompt
op_eq
l_int|NULL
)paren
(brace
id|moreprompt
op_assign
l_string|&quot;more&gt; &quot;
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SMP)
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|moreprompt
comma
l_char|&squot;%&squot;
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|buf2
comma
id|moreprompt
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|moreprompt
op_assign
id|buf2
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
id|moreprompt
)paren
suffix:semicolon
(paren
r_void
)paren
id|kdb_getscancode
c_func
(paren
id|buf1
comma
r_sizeof
(paren
id|buf1
)paren
)paren
suffix:semicolon
id|kdb_nextline
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buf1
(braket
l_int|0
)braket
op_eq
l_char|&squot;q&squot;
)paren
op_logical_or
(paren
id|buf1
(braket
l_int|0
)braket
op_eq
l_char|&squot;Q&squot;
)paren
)paren
(brace
id|kdb_longjmp
c_func
(paren
op_amp
id|kdbjmpbuf
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;
r_return
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|kdbgetword
id|kdbgetword
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|width
)paren
(brace
multiline_comment|/*&n;&t; * This function checks the address for validity.  Any address&n;&t; * in the range PAGE_OFFSET to high_memory is legal, any address&n;&t; * which maps to a vmalloc region is legal, and any address which&n;&t; * is a user address, we use get_user() to verify validity.&n;&t; */
r_if
c_cond
(paren
id|addr
OL
id|PAGE_OFFSET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Usermode address.&n;&t;&t; */
r_int
r_int
id|diag
suffix:semicolon
r_int
r_int
id|ulval
suffix:semicolon
r_switch
c_cond
(paren
id|width
)paren
(brace
r_case
l_int|8
suffix:colon
(brace
r_int
r_int
op_star
id|lp
suffix:semicolon
id|lp
op_assign
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
id|diag
op_assign
id|get_user
c_func
(paren
id|ulval
comma
id|lp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|4
suffix:colon
(brace
r_int
r_int
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
id|diag
op_assign
id|get_user
c_func
(paren
id|ulval
comma
id|ip
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
(brace
r_int
r_int
op_star
id|sp
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
id|diag
op_assign
id|get_user
c_func
(paren
id|ulval
comma
id|sp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
(brace
r_int
r_char
op_star
id|cp
suffix:semicolon
id|cp
op_assign
(paren
r_int
r_char
op_star
)paren
id|addr
suffix:semicolon
id|diag
op_assign
id|get_user
c_func
(paren
id|ulval
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;kdbgetword: Bad width&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0L
suffix:semicolon
)brace
r_if
c_cond
(paren
id|diag
)paren
(brace
r_if
c_cond
(paren
(paren
id|kdb_flags
op_amp
id|KDB_FLAG_SUPRESS
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kdb: Bad user address 0x%lx&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
id|kdb_flags
op_or_assign
id|KDB_FLAG_SUPRESS
suffix:semicolon
)brace
r_return
l_int|0L
suffix:semicolon
)brace
id|kdb_flags
op_and_assign
op_complement
id|KDB_FLAG_SUPRESS
suffix:semicolon
r_return
id|ulval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
OG
(paren
r_int
r_int
)paren
id|high_memory
)paren
(brace
r_extern
r_int
id|kdb_vmlist_check
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kdb_vmlist_check
c_func
(paren
id|addr
comma
id|addr
op_plus
id|width
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Would appear to be an illegal kernel address; &n;&t;&t;&t; * Print a message once, and don&squot;t print again until&n;&t;&t;&t; * a legal address is used.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|kdb_flags
op_amp
id|KDB_FLAG_SUPRESS
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kdb: Bad kernel address 0x%lx&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
id|kdb_flags
op_or_assign
id|KDB_FLAG_SUPRESS
suffix:semicolon
)brace
r_return
l_int|0L
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * A good address.  Reset error flag.&n;&t; */
id|kdb_flags
op_and_assign
op_complement
id|KDB_FLAG_SUPRESS
suffix:semicolon
r_switch
c_cond
(paren
id|width
)paren
(brace
r_case
l_int|8
suffix:colon
(brace
r_int
r_int
op_star
id|lp
suffix:semicolon
id|lp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|addr
)paren
suffix:semicolon
r_return
op_star
id|lp
suffix:semicolon
)brace
r_case
l_int|4
suffix:colon
(brace
r_int
r_int
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|addr
)paren
suffix:semicolon
r_return
op_star
id|ip
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
(brace
r_int
r_int
op_star
id|sp
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|addr
)paren
suffix:semicolon
r_return
op_star
id|sp
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
(brace
r_int
r_char
op_star
id|cp
suffix:semicolon
id|cp
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|addr
)paren
suffix:semicolon
r_return
op_star
id|cp
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;kdbgetword: Bad width&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0L
suffix:semicolon
)brace
multiline_comment|/*&n; * Start of breakpoint management routines&n; */
multiline_comment|/*&n; * Arg: bp structure&n; */
r_int
DECL|function|kdb_allocdbreg
id|kdb_allocdbreg
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For inst bkpt, just return. No hw reg alloc to be done. */
r_if
c_cond
(paren
id|bp-&gt;bp_mode
op_eq
id|BKPTMODE_INST
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bp-&gt;bp_mode
op_eq
id|BKPTMODE_DATAW
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|KDB_DBREGS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dbregs
(braket
id|i
)braket
op_eq
l_int|0xffffffff
)paren
(brace
id|dbregs
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|kdb_freedbreg
id|kdb_freedbreg
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;bp_mode
op_eq
id|BKPTMODE_DATAW
)paren
id|dbregs
(braket
id|bp-&gt;bp_reg
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_void
DECL|function|kdb_initdbregs
id|kdb_initdbregs
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|KDB_DBREGS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dbregs
(braket
id|i
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
)brace
r_int
DECL|function|kdbinstalltrap
id|kdbinstalltrap
c_func
(paren
r_int
id|type
comma
id|handler_t
id|newh
comma
id|handler_t
op_star
id|oldh
)paren
(brace
multiline_comment|/*&n;&t; * Usurp INTn.  XXX - TBD.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|install_instbkpt
id|install_instbkpt
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
(paren
r_int
r_int
op_star
)paren
id|bp-&gt;bp_addr
suffix:semicolon
id|bundle_t
op_star
id|bundle
op_assign
(paren
id|bundle_t
op_star
)paren
id|bp-&gt;bp_longinst
suffix:semicolon
multiline_comment|/* save current bundle */
op_star
id|bundle
op_assign
op_star
(paren
id|bundle_t
op_star
)paren
id|addr
suffix:semicolon
multiline_comment|/* Set the break point! */
(paren
(paren
id|bundle_t
op_star
)paren
id|addr
)paren
op_member_access_from_pointer
id|lform.low8
op_assign
(paren
(paren
(paren
(paren
id|bundle_t
op_star
)paren
id|addr
)paren
op_member_access_from_pointer
id|lform.low8
op_amp
op_complement
id|INST_SLOT0_MASK
)paren
op_or
id|BREAK_INSTR
)paren
suffix:semicolon
multiline_comment|/* set flag */
id|bp-&gt;bp_instvalid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flush icache as it is stale now */
id|ia64_flush_icache_page
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
macro_line|#ifdef KDB_DEBUG
id|kdb_printf
(paren
l_string|&quot;[0x%016lx]: install 0x%016lx with 0x%016lx&bslash;n&quot;
comma
id|addr
comma
id|bundle-&gt;lform.low8
comma
id|addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|install_databkpt
id|install_databkpt
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_int
r_int
id|dbreg_addr
op_assign
id|bp-&gt;bp_reg
op_star
l_int|2
suffix:semicolon
r_int
r_int
id|dbreg_cond
op_assign
id|dbreg_addr
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|value
op_assign
l_int|0x8fffffffffffffff
suffix:semicolon
r_int
r_int
id|addr
op_assign
(paren
r_int
r_int
)paren
id|bp-&gt;bp_addr
suffix:semicolon
id|__asm__
(paren
l_string|&quot;mov dbr[%0]=%1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|dbreg_cond
)paren
comma
l_string|&quot;r&quot;
(paren
id|value
)paren
)paren
suffix:semicolon
singleline_comment|//&t;__asm__ (&quot;movl %0,%%db0&bslash;n&bslash;t&quot;::&quot;r&quot;(contents));
id|__asm__
(paren
l_string|&quot;mov dbr[%0]=%1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|dbreg_addr
)paren
comma
l_string|&quot;r&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef KDB_DEBUG
id|kdb_printf
c_func
(paren
l_string|&quot;installed dbkpt at 0x%016lx&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|kdbinstalldbreg
id|kdbinstalldbreg
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;bp_mode
op_eq
id|BKPTMODE_INST
)paren
(brace
r_return
id|install_instbkpt
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bp-&gt;bp_mode
op_eq
id|BKPTMODE_DATAW
)paren
(brace
r_return
id|install_databkpt
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|remove_instbkpt
id|remove_instbkpt
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
(paren
r_int
r_int
op_star
)paren
id|bp-&gt;bp_addr
suffix:semicolon
id|bundle_t
op_star
id|bundle
op_assign
(paren
id|bundle_t
op_star
)paren
id|bp-&gt;bp_longinst
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;bp_instvalid
)paren
multiline_comment|/* Nothing to remove. If we just alloced the bkpt&n;&t; * but never resumed, the bp_inst will not be valid. */
r_return
suffix:semicolon
macro_line|#ifdef KDB_DEBUG
id|kdb_printf
(paren
l_string|&quot;[0x%016lx]: remove 0x%016lx with 0x%016lx&bslash;n&quot;
comma
id|addr
comma
id|addr
(braket
l_int|0
)braket
comma
id|bundle-&gt;lform.low8
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* restore current bundle */
op_star
(paren
id|bundle_t
op_star
)paren
id|addr
op_assign
op_star
id|bundle
suffix:semicolon
multiline_comment|/* reset the flag */
id|bp-&gt;bp_instvalid
op_assign
l_int|0
suffix:semicolon
id|ia64_flush_icache_page
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
)brace
r_void
DECL|function|remove_databkpt
id|remove_databkpt
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_int
id|regnum
op_assign
id|bp-&gt;bp_reg
suffix:semicolon
r_int
r_int
id|dbreg_addr
op_assign
id|regnum
op_star
l_int|2
suffix:semicolon
r_int
r_int
id|dbreg_cond
op_assign
id|dbreg_addr
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|value
op_assign
l_int|0x0fffffffffffffff
suffix:semicolon
id|__asm__
(paren
l_string|&quot;mov dbr[%0]=%1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|dbreg_cond
)paren
comma
l_string|&quot;r&quot;
(paren
id|value
)paren
)paren
suffix:semicolon
singleline_comment|//&t;__asm__ (&quot;movl %0,%%db0&bslash;n&bslash;t&quot;::&quot;r&quot;(contents));
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef KDB_DEBUG
id|kdb_printf
c_func
(paren
l_string|&quot;removed dbkpt at 0x%016lx&bslash;n&quot;
comma
id|bp-&gt;bp_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|kdbremovedbreg
id|kdbremovedbreg
c_func
(paren
id|kdb_bp_t
op_star
id|bp
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;bp_mode
op_eq
id|BKPTMODE_INST
)paren
(brace
id|remove_instbkpt
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bp-&gt;bp_mode
op_eq
id|BKPTMODE_DATAW
)paren
(brace
id|remove_databkpt
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
id|k_machreg_t
DECL|function|kdb_getdr6
id|kdb_getdr6
c_func
(paren
r_void
)paren
(brace
r_return
id|kdb_getdr
c_func
(paren
l_int|6
)paren
suffix:semicolon
)brace
id|k_machreg_t
DECL|function|kdb_getdr7
id|kdb_getdr7
c_func
(paren
r_void
)paren
(brace
r_return
id|kdb_getdr
c_func
(paren
l_int|7
)paren
suffix:semicolon
)brace
id|k_machreg_t
DECL|function|kdb_getdr
id|kdb_getdr
c_func
(paren
r_int
id|regnum
)paren
(brace
id|k_machreg_t
id|contents
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|reg
op_assign
(paren
r_int
r_int
)paren
id|regnum
suffix:semicolon
id|__asm__
(paren
l_string|&quot;mov %0=ibr[%1]&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|contents
)paren
comma
l_string|&quot;r&quot;
(paren
id|reg
)paren
)paren
suffix:semicolon
singleline_comment|//        __asm__ (&quot;mov ibr[%0]=%1&quot;::&quot;r&quot;(dbreg_cond),&quot;r&quot;(value));&t;
r_return
id|contents
suffix:semicolon
)brace
id|k_machreg_t
DECL|function|kdb_getcr
id|kdb_getcr
c_func
(paren
r_int
id|regnum
)paren
(brace
id|k_machreg_t
id|contents
op_assign
l_int|0
suffix:semicolon
r_return
id|contents
suffix:semicolon
)brace
r_void
DECL|function|kdb_putdr6
id|kdb_putdr6
c_func
(paren
id|k_machreg_t
id|contents
)paren
(brace
id|kdb_putdr
c_func
(paren
l_int|6
comma
id|contents
)paren
suffix:semicolon
)brace
r_void
DECL|function|kdb_putdr7
id|kdb_putdr7
c_func
(paren
id|k_machreg_t
id|contents
)paren
(brace
id|kdb_putdr
c_func
(paren
l_int|7
comma
id|contents
)paren
suffix:semicolon
)brace
r_void
DECL|function|kdb_putdr
id|kdb_putdr
c_func
(paren
r_int
id|regnum
comma
id|k_machreg_t
id|contents
)paren
(brace
)brace
r_void
DECL|function|get_fault_regs
id|get_fault_regs
c_func
(paren
id|fault_regs_t
op_star
id|fr
)paren
(brace
id|fr-&gt;ifa
op_assign
l_int|0
suffix:semicolon
id|fr-&gt;isr
op_assign
l_int|0
suffix:semicolon
id|__asm__
(paren
l_string|&quot;rsm psr.ic;;&quot;
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|__asm__
(paren
l_string|&quot;mov %0=cr.ifa&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|fr-&gt;ifa
)paren
)paren
suffix:semicolon
id|__asm__
(paren
l_string|&quot;mov %0=cr.isr&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|fr-&gt;isr
)paren
)paren
suffix:semicolon
id|__asm__
(paren
l_string|&quot;ssm psr.ic;;&quot;
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * kdb_db_trap&n; *&n; * &t;Perform breakpoint processing upon entry to the&n; *&t;processor debugger fault.   Determine and print&n; *&t;the active breakpoint.&n; *&n; * Parameters:&n; *&t;ef&t;Exception frame containing machine register state&n; *&t;reason&t;Why did we enter kdb - fault or break&n; * Outputs:&n; *&t;None.&n; * Returns:&n; *&t;0&t;Standard instruction or data breakpoint encountered&n; *&t;1&t;Single Step fault (&squot;ss&squot; command)&n; *&t;2&t;Single Step fault, caller should continue (&squot;ssb&squot; command)&n; * Locking:&n; *&t;None.&n; * Remarks:&n; *&t;Yup, there be goto&squot;s here.&n; */
r_int
DECL|function|kdb_db_trap
id|kdb_db_trap
c_func
(paren
r_struct
id|pt_regs
op_star
id|ef
comma
r_int
id|reason
)paren
(brace
r_int
id|i
comma
id|rv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Trying very hard to not change the interface to kdb.&n;&t; * So, eventhough we have these values in the fault function&n;&t; * it is not passed in but read again.&n;&t; */
id|fault_regs_t
id|faultregs
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_eq
id|KDB_REASON_FLTDBG
)paren
id|get_fault_regs
c_func
(paren
op_amp
id|faultregs
)paren
suffix:semicolon
multiline_comment|/* NOTE : XXX: This has to be done only for data bkpts */
multiline_comment|/* Prevent it from continuously faulting */
id|ef-&gt;cr_ipsr
op_or_assign
l_int|0x0000002000000000
suffix:semicolon
r_if
c_cond
(paren
id|ef-&gt;cr_ipsr
op_amp
l_int|0x0000010000000000
)paren
(brace
multiline_comment|/* single step */
id|ef-&gt;cr_ipsr
op_and_assign
l_int|0xfffffeffffffffff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|kdb_state.bkpt_handling_state
op_eq
id|BKPTSTATE_HANDLED
)paren
op_logical_and
(paren
id|kdb_state.cmd_given
op_eq
id|CMDGIVEN_GO
)paren
)paren
suffix:semicolon
r_else
id|kdb_printf
c_func
(paren
l_string|&quot;SS trap at 0x%lx&bslash;n&quot;
comma
id|ef-&gt;cr_iip
op_plus
id|ia64_psr
c_func
(paren
id|ef
)paren
op_member_access_from_pointer
id|ri
)paren
suffix:semicolon
id|rv
op_assign
l_int|1
suffix:semicolon
id|kdb_state.reason_for_entry
op_assign
id|ENTRYREASON_SSTEP
suffix:semicolon
r_goto
id|handled
suffix:semicolon
)brace
r_else
id|kdb_state.reason_for_entry
op_assign
id|ENTRYREASON_GO
suffix:semicolon
multiline_comment|/*&n;         * Determine which breakpoint was encountered.&n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|KDB_MAXBPT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|breakpoints
(braket
id|i
)braket
dot
id|bp_enabled
)paren
op_logical_and
(paren
(paren
id|breakpoints
(braket
id|i
)braket
dot
id|bp_addr
op_eq
id|ef-&gt;cr_iip
)paren
op_logical_or
(paren
(paren
id|faultregs.ifa
)paren
op_logical_and
(paren
id|breakpoints
(braket
id|i
)braket
dot
id|bp_addr
op_eq
id|faultregs.ifa
)paren
)paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Hit this breakpoint.  Remove it while we are&n;                         * handling hit to avoid recursion. XXX ??&n;                         */
r_if
c_cond
(paren
id|breakpoints
(braket
id|i
)braket
dot
id|bp_addr
op_eq
id|faultregs.ifa
)paren
id|kdb_printf
c_func
(paren
l_string|&quot;Data breakpoint #%d for 0x%lx at 0x%lx&bslash;n&quot;
comma
id|i
comma
id|breakpoints
(braket
id|i
)braket
dot
id|bp_addr
comma
id|ef-&gt;cr_iip
op_plus
id|ia64_psr
c_func
(paren
id|ef
)paren
op_member_access_from_pointer
id|ri
)paren
suffix:semicolon
r_else
id|kdb_printf
c_func
(paren
l_string|&quot;%s breakpoint #%d at 0x%lx&bslash;n&quot;
comma
id|rwtypes
(braket
l_int|0
)braket
comma
id|i
comma
id|breakpoints
(braket
id|i
)braket
dot
id|bp_addr
)paren
suffix:semicolon
multiline_comment|/*&n;                         * For an instruction breakpoint, disassemble&n;                         * the current instruction.&n;                         */
macro_line|#if 0
r_if
c_cond
(paren
id|rw
op_eq
l_int|0
)paren
(brace
id|kdb_id1
c_func
(paren
id|ef-&gt;eip
)paren
suffix:semicolon
)brace
macro_line|#endif
r_goto
id|handled
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|unknown
suffix:colon
macro_line|#endif
id|kdb_printf
c_func
(paren
l_string|&quot;Unknown breakpoint.  Should forward. &bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Need a flag for this. The skip should be done XXX&n;&t; * when a go or single step command is done for this session.&n;&t; * For now it is here.&n; &t; */
id|ia64_increment_ip
c_func
(paren
id|ef
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
id|handled
suffix:colon
multiline_comment|/* We are here after handling a break inst/data bkpt */
r_if
c_cond
(paren
id|kdb_state.bkpt_handling_state
op_eq
id|BKPTSTATE_NOT_HANDLED
)paren
(brace
id|kdb_state.bkpt_handling_state
op_assign
id|BKPTSTATE_HANDLED
suffix:semicolon
r_if
c_cond
(paren
id|kdb_state.reason_for_entry
op_eq
id|ENTRYREASON_GO
)paren
(brace
id|kdb_setsinglestep
c_func
(paren
id|ef
)paren
suffix:semicolon
id|kdb_state.kdb_action
op_assign
id|ACTION_NOBPINSTALL
suffix:semicolon
multiline_comment|/* We dont want bp install just this once */
id|kdb_state.cmd_given
op_assign
id|CMDGIVEN_UNKNOWN
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|kdb_state.bkpt_handling_state
op_eq
id|BKPTSTATE_HANDLED
)paren
(brace
id|kdb_state.bkpt_handling_state
op_assign
id|BKPTSTATE_NOT_HANDLED
suffix:semicolon
r_if
c_cond
(paren
id|kdb_state.reason_for_entry
op_eq
id|ENTRYREASON_SSTEP
)paren
(brace
r_if
c_cond
(paren
id|kdb_state.cmd_given
op_eq
id|CMDGIVEN_GO
)paren
id|kdb_state.kdb_action
op_assign
id|ACTION_NOPROMPT
suffix:semicolon
id|kdb_state.cmd_given
op_assign
id|CMDGIVEN_UNKNOWN
suffix:semicolon
)brace
)brace
r_else
id|kdb_printf
c_func
(paren
l_string|&quot;Unknown value of bkpt state&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
r_void
DECL|function|kdb_setsinglestep
id|kdb_setsinglestep
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|regs-&gt;cr_ipsr
op_or_assign
l_int|0x0000010000000000
suffix:semicolon
macro_line|#if 0
id|regs-&gt;eflags
op_or_assign
id|EF_TF
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Symbol table functions.&n; */
multiline_comment|/*&n; * kdbgetsym&n; *&n; *&t;Return the symbol table entry for the given symbol&n; *&n; * Parameters:&n; * &t;symname&t;Character string containing symbol name&n; * Outputs:&n; * Returns:&n; *&t;NULL&t;Symbol doesn&squot;t exist&n; *&t;ksp&t;Pointer to symbol table entry&n; * Locking:&n; *&t;None.&n; * Remarks:&n; */
id|__ksymtab_t
op_star
DECL|function|kdbgetsym
id|kdbgetsym
c_func
(paren
r_const
r_char
op_star
id|symname
)paren
(brace
id|__ksymtab_t
op_star
id|ksp
op_assign
id|__kdbsymtab
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|symname
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|__kdbsymtabsize
suffix:semicolon
id|i
op_increment
comma
id|ksp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ksp-&gt;name
op_logical_and
(paren
id|strcmp
c_func
(paren
id|ksp-&gt;name
comma
id|symname
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_return
id|ksp
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbgetsymval&n; *&n; *&t;Return the address of the given symbol.&n; *&n; * Parameters:&n; * &t;symname&t;Character string containing symbol name&n; * Outputs:&n; * Returns:&n; *&t;0&t;Symbol name is NULL&n; *&t;addr&t;Address corresponding to symname&n; * Locking:&n; *&t;None.&n; * Remarks:&n; */
r_int
r_int
DECL|function|kdbgetsymval
id|kdbgetsymval
c_func
(paren
r_const
r_char
op_star
id|symname
)paren
(brace
id|__ksymtab_t
op_star
id|ksp
op_assign
id|kdbgetsym
c_func
(paren
id|symname
)paren
suffix:semicolon
r_return
(paren
id|ksp
ques
c_cond
id|ksp-&gt;value
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbaddmodsym&n; *&n; *&t;Add a symbol to the kernel debugger symbol table.  Called when&n; *&t;a new module is loaded into the kernel.&n; *&n; * Parameters:&n; * &t;symname&t;Character string containing symbol name&n; *&t;value&t;Value of symbol&n; * Outputs:&n; * Returns:&n; *&t;0&t;Successfully added to table.&n; *&t;1&t;Duplicate symbol&n; *&t;2&t;Symbol table full&n; * Locking:&n; *&t;None.&n; * Remarks:&n; */
r_int
DECL|function|kdbaddmodsym
id|kdbaddmodsym
c_func
(paren
r_char
op_star
id|symname
comma
r_int
r_int
id|value
)paren
(brace
multiline_comment|/*&n;&t; * Check for duplicate symbols.&n;&t; */
r_if
c_cond
(paren
id|kdbgetsym
c_func
(paren
id|symname
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kdb: Attempt to register duplicate symbol &squot;%s&squot; @ 0x%lx&bslash;n&quot;
comma
id|symname
comma
id|value
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__kdbsymtabsize
OL
id|__kdbmaxsymtabsize
)paren
(brace
id|__ksymtab_t
op_star
id|ksp
op_assign
op_amp
id|__kdbsymtab
(braket
id|__kdbsymtabsize
op_increment
)braket
suffix:semicolon
id|ksp-&gt;name
op_assign
id|symname
suffix:semicolon
id|ksp-&gt;value
op_assign
id|value
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No room left in kernel symbol table.&n;&t; */
(brace
r_static
r_int
id|__kdbwarn
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|__kdbwarn
op_eq
l_int|0
)paren
(brace
id|__kdbwarn
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;kdb: Exceeded symbol table size.  Increase CONFIG_KDB_SYMTAB_SIZE in kernel configuration&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbdelmodsym&n; *&n; *&t;Add a symbol to the kernel debugger symbol table.  Called when&n; *&t;a new module is loaded into the kernel.&n; *&n; * Parameters:&n; * &t;symname&t;Character string containing symbol name&n; *&t;value&t;Value of symbol&n; * Outputs:&n; * Returns:&n; *&t;0&t;Successfully added to table.&n; *&t;1&t;Symbol not found&n; * Locking:&n; *&t;None.&n; * Remarks:&n; */
r_int
DECL|function|kdbdelmodsym
id|kdbdelmodsym
c_func
(paren
r_const
r_char
op_star
id|symname
)paren
(brace
id|__ksymtab_t
op_star
id|ksp
comma
op_star
id|endksp
suffix:semicolon
r_if
c_cond
(paren
id|symname
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Search for the symbol.  If found, move &n;&t; * all successive symbols down one position&n;&t; * in the symbol table to avoid leaving holes.&n;&t; */
id|endksp
op_assign
op_amp
id|__kdbsymtab
(braket
id|__kdbsymtabsize
)braket
suffix:semicolon
r_for
c_loop
(paren
id|ksp
op_assign
id|__kdbsymtab
suffix:semicolon
id|ksp
OL
id|endksp
suffix:semicolon
id|ksp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ksp-&gt;name
op_logical_and
(paren
id|strcmp
c_func
(paren
id|ksp-&gt;name
comma
id|symname
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|endksp
op_decrement
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|ksp
OL
id|endksp
suffix:semicolon
id|ksp
op_increment
)paren
(brace
op_star
id|ksp
op_assign
op_star
(paren
id|ksp
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|__kdbsymtabsize
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbnearsym&n; *&n; *&t;Return the name of the symbol with the nearest address&n; *&t;less than &squot;addr&squot;.&n; *&n; * Parameters:&n; * &t;addr&t;Address to check for symbol near&n; * Outputs:&n; * Returns:&n; *&t;NULL&t;No symbol with address less than &squot;addr&squot;&n; *&t;symbol&t;Returns the actual name of the symbol.&n; * Locking:&n; *&t;None.&n; * Remarks:&n; */
r_char
op_star
DECL|function|kdbnearsym
id|kdbnearsym
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|__ksymtab_t
op_star
id|ksp
op_assign
id|__kdbsymtab
suffix:semicolon
id|__ksymtab_t
op_star
id|kpp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|__kdbsymtabsize
suffix:semicolon
id|i
op_increment
comma
id|ksp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ksp-&gt;name
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
id|ksp-&gt;value
)paren
(brace
id|kpp
op_assign
id|ksp
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
OG
id|ksp-&gt;value
)paren
(brace
r_if
c_cond
(paren
(paren
id|kpp
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|ksp-&gt;value
OG
id|kpp-&gt;value
)paren
)paren
(brace
id|kpp
op_assign
id|ksp
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If more than 128k away, don&squot;t bother.&n;&t; */
r_if
c_cond
(paren
(paren
id|kpp
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|addr
op_minus
id|kpp-&gt;value
)paren
OG
l_int|0x20000
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|kpp-&gt;name
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbgetregcontents&n; *&n; *&t;Return the contents of the register specified by the &n; *&t;input string argument.   Return an error if the string&n; *&t;does not match a machine register.&n; *&n; *&t;The following pseudo register names are supported:&n; *&t;   &amp;regs&t; - Prints address of exception frame&n; *&t;   kesp&t;&t; - Prints kernel stack pointer at time of fault&n; * &t;   sstk&t;&t; - Prints switch stack for ia64&n; *&t;   %&lt;regname&gt;&t; - Uses the value of the registers at the &n; *&t;&t;&t;   last time the user process entered kernel&n; *&t;&t;&t;   mode, instead of the registers at the time&n; *&t;&t;&t;   kdb was entered.&n; *&n; * Parameters:&n; *&t;regname&t;&t;Pointer to string naming register&n; *&t;regs&t;&t;Pointer to structure containing registers.&n; * Outputs:&n; *&t;*contents&t;Pointer to unsigned long to recieve register contents&n; * Returns:&n; *&t;0&t;&t;Success&n; *&t;KDB_BADREG&t;Invalid register name&n; * Locking:&n; * &t;None.&n; * Remarks:&n; *&n; * &t;Note that this function is really machine independent.   The kdb&n; *&t;register list is not, however.&n; */
DECL|struct|kdbregs
r_static
r_struct
id|kdbregs
(brace
DECL|member|reg_name
r_char
op_star
id|reg_name
suffix:semicolon
DECL|member|reg_offset
r_int
id|reg_offset
suffix:semicolon
DECL|variable|kdbreglist
)brace
id|kdbreglist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot; psr&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|cr_ipsr
)paren
)brace
comma
(brace
l_string|&quot; ifs&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|cr_ifs
)paren
)brace
comma
(brace
l_string|&quot;  ip&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|cr_iip
)paren
)brace
comma
(brace
l_string|&quot;unat&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|ar_unat
)paren
)brace
comma
(brace
l_string|&quot; pfs&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|ar_pfs
)paren
)brace
comma
(brace
l_string|&quot; rsc&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|ar_rsc
)paren
)brace
comma
(brace
l_string|&quot;rnat&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|ar_rnat
)paren
)brace
comma
(brace
l_string|&quot;bsps&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|ar_bspstore
)paren
)brace
comma
(brace
l_string|&quot;  pr&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|pr
)paren
)brace
comma
(brace
l_string|&quot;ldrs&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|loadrs
)paren
)brace
comma
(brace
l_string|&quot; ccv&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|ar_ccv
)paren
)brace
comma
(brace
l_string|&quot;fpsr&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|ar_fpsr
)paren
)brace
comma
(brace
l_string|&quot;  b0&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|b0
)paren
)brace
comma
(brace
l_string|&quot;  b6&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|b6
)paren
)brace
comma
(brace
l_string|&quot;  b7&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|b7
)paren
)brace
comma
(brace
l_string|&quot;  r1&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r1
)paren
)brace
comma
(brace
l_string|&quot;  r2&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r2
)paren
)brace
comma
(brace
l_string|&quot;  r3&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r3
)paren
)brace
comma
(brace
l_string|&quot;  r8&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r8
)paren
)brace
comma
(brace
l_string|&quot;  r9&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r9
)paren
)brace
comma
(brace
l_string|&quot; r10&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r10
)paren
)brace
comma
(brace
l_string|&quot; r11&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r11
)paren
)brace
comma
(brace
l_string|&quot; r12&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r12
)paren
)brace
comma
(brace
l_string|&quot; r13&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r13
)paren
)brace
comma
(brace
l_string|&quot; r14&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r14
)paren
)brace
comma
(brace
l_string|&quot; r15&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r15
)paren
)brace
comma
(brace
l_string|&quot; r16&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r16
)paren
)brace
comma
(brace
l_string|&quot; r17&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r17
)paren
)brace
comma
(brace
l_string|&quot; r18&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r18
)paren
)brace
comma
(brace
l_string|&quot; r19&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r19
)paren
)brace
comma
(brace
l_string|&quot; r20&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r20
)paren
)brace
comma
(brace
l_string|&quot; r21&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r21
)paren
)brace
comma
(brace
l_string|&quot; r22&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r22
)paren
)brace
comma
(brace
l_string|&quot; r23&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r23
)paren
)brace
comma
(brace
l_string|&quot; r24&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r24
)paren
)brace
comma
(brace
l_string|&quot; r25&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r25
)paren
)brace
comma
(brace
l_string|&quot; r26&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r26
)paren
)brace
comma
(brace
l_string|&quot; r27&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r27
)paren
)brace
comma
(brace
l_string|&quot; r28&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r28
)paren
)brace
comma
(brace
l_string|&quot; r29&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r29
)paren
)brace
comma
(brace
l_string|&quot; r30&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r30
)paren
)brace
comma
(brace
l_string|&quot; r31&quot;
comma
m_offsetof
(paren
r_struct
id|pt_regs
comma
id|r31
)paren
)brace
comma
)brace
suffix:semicolon
DECL|variable|nkdbreglist
r_static
r_const
r_int
id|nkdbreglist
op_assign
r_sizeof
(paren
id|kdbreglist
)paren
op_div
r_sizeof
(paren
r_struct
id|kdbregs
)paren
suffix:semicolon
r_int
DECL|function|kdbgetregcontents
id|kdbgetregcontents
c_func
(paren
r_const
r_char
op_star
id|regname
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
op_star
id|contents
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|regname
comma
l_string|&quot;&amp;regs&quot;
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|contents
op_assign
(paren
r_int
r_int
)paren
id|regs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|regname
comma
l_string|&quot;sstk&quot;
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|contents
op_assign
(paren
r_int
r_int
)paren
id|getprsregs
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|regname
comma
l_string|&quot;isr&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|fault_regs_t
id|fr
suffix:semicolon
id|get_fault_regs
c_func
(paren
op_amp
id|fr
)paren
suffix:semicolon
op_star
id|contents
op_assign
id|fr.isr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* XXX need to verify this */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|regname
comma
l_string|&quot;kesp&quot;
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|contents
op_assign
(paren
r_int
r_int
)paren
id|regs
op_plus
r_sizeof
(paren
r_struct
id|pt_regs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|regname
(braket
l_int|0
)braket
op_eq
l_char|&squot;%&squot;
)paren
(brace
multiline_comment|/* User registers:  %%e[a-c]x, etc */
id|regname
op_increment
suffix:semicolon
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|current-&gt;thread.ksp
op_minus
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nkdbreglist
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|kdbreglist
(braket
id|i
)braket
dot
id|reg_name
comma
id|regname
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|nkdbreglist
)paren
(brace
multiline_comment|/* Lets check the rse maybe */
r_if
c_cond
(paren
id|regname
(braket
l_int|0
)braket
op_eq
l_char|&squot;r&squot;
)paren
r_if
c_cond
(paren
id|show_cur_stack_frame
c_func
(paren
id|regs
comma
id|simple_strtoul
c_func
(paren
id|regname
op_plus
l_int|1
comma
l_int|0
comma
l_int|0
)paren
op_minus
l_int|31
comma
id|contents
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|KDB_BADREG
suffix:semicolon
)brace
op_star
id|contents
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|regs
op_plus
id|kdbreglist
(braket
id|i
)braket
dot
id|reg_offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbsetregcontents&n; *&n; *&t;Set the contents of the register specified by the &n; *&t;input string argument.   Return an error if the string&n; *&t;does not match a machine register.&n; *&n; *&t;Supports modification of user-mode registers via&n; *&t;%&lt;register-name&gt;&n; *&n; * Parameters:&n; *&t;regname&t;&t;Pointer to string naming register&n; *&t;regs&t;&t;Pointer to structure containing registers.&n; *&t;contents&t;Unsigned long containing new register contents&n; * Outputs:&n; * Returns:&n; *&t;0&t;&t;Success&n; *&t;KDB_BADREG&t;Invalid register name&n; * Locking:&n; * &t;None.&n; * Remarks:&n; */
r_int
DECL|function|kdbsetregcontents
id|kdbsetregcontents
c_func
(paren
r_const
r_char
op_star
id|regname
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|contents
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|regname
(braket
l_int|0
)braket
op_eq
l_char|&squot;%&squot;
)paren
(brace
id|regname
op_increment
suffix:semicolon
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|current-&gt;thread.ksp
op_minus
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nkdbreglist
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strnicmp
c_func
(paren
id|kdbreglist
(braket
id|i
)braket
dot
id|reg_name
comma
id|regname
comma
id|strlen
c_func
(paren
id|regname
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_eq
id|nkdbreglist
)paren
op_logical_or
(paren
id|strlen
c_func
(paren
id|kdbreglist
(braket
id|i
)braket
dot
id|reg_name
)paren
op_ne
id|strlen
c_func
(paren
id|regname
)paren
)paren
)paren
(brace
r_return
id|KDB_BADREG
suffix:semicolon
)brace
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|regs
op_plus
id|kdbreglist
(braket
id|i
)braket
dot
id|reg_offset
)paren
op_assign
id|contents
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * kdbdumpregs&n; *&n; *&t;Dump the specified register set to the display.&n; *&n; * Parameters:&n; *&t;regs&t;&t;Pointer to structure containing registers.&n; *&t;type&t;&t;Character string identifying register set to dump&n; *&t;extra&t;&t;string further identifying register (optional)&n; * Outputs:&n; * Returns:&n; *&t;0&t;&t;Success&n; * Locking:&n; * &t;None.&n; * Remarks:&n; *&t;This function will dump the general register set if the type&n; *&t;argument is NULL (struct pt_regs).   The alternate register &n; *&t;set types supported by this function:&n; *&n; *&t;d &t;&t;Debug registers&n; *&t;c&t;&t;Control registers&n; *&t;u&t;&t;User registers at most recent entry to kernel&n; * Following not yet implemented:&n; *&t;m&t;&t;Model Specific Registers (extra defines register #)&n; *&t;r&t;&t;Memory Type Range Registers (extra defines register)&n; *&n; *&t;For now, all registers are covered as follows:&n; *&n; * &t;rd &t;&t;- dumps all regs&n; *&t;rd&t;%isr&t;- current interrupt status reg, read freshly&n; *&t;rd&t;s&t;- valid stacked regs&n; * &t;rd &t;%sstk&t;- gets switch stack addr. dump memory and search&n; *&t;rd&t;d&t;- debug regs, may not be too useful&n; *&n; *&t;ARs&t;&t;TB Done&n; *&t;Interrupt regs &t;TB Done ??&n; *&t;OTHERS&t;&t;TB Decided ??&n; *&n; *&t;Intel wish list&n; *&t;These will be implemented later - Srinivasa&n; *&n; *      type        action&n; *      ----        ------&n; *      g           dump all General static registers&n; *      s           dump all general Stacked registers&n; *      f           dump all Floating Point registers&n; *      p           dump all Predicate registers&n; *      b           dump all Branch registers&n; *      a           dump all Application registers&n; *      c           dump all Control registers&n; *&n; */
r_int
DECL|function|kdbdumpregs
id|kdbdumpregs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|extra
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_logical_and
(paren
id|type
(braket
l_int|0
)braket
op_eq
l_char|&squot;u&squot;
)paren
)paren
(brace
id|type
op_assign
l_int|NULL
suffix:semicolon
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|current-&gt;thread.ksp
op_minus
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nkdbreglist
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kdb_printf
c_func
(paren
l_string|&quot;%s: 0x%16.16lx  &quot;
comma
id|kdbreglist
(braket
id|i
)braket
dot
id|reg_name
comma
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|regs
op_plus
id|kdbreglist
(braket
id|i
)braket
dot
id|reg_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_increment
id|count
op_mod
l_int|3
)paren
op_eq
l_int|0
)paren
id|kdb_printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kdb_printf
c_func
(paren
l_string|&quot;&amp;regs = 0x%16.16lx&bslash;n&quot;
comma
id|regs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|type
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|kdb_printf
c_func
(paren
l_string|&quot;idr%d: 0x%16.16lx  idr%d: 0x%16.16lx&bslash;n&quot;
comma
id|i
comma
id|kdb_getdr
c_func
(paren
id|i
)paren
comma
id|i
op_plus
l_int|1
comma
id|kdb_getdr
c_func
(paren
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_case
l_char|&squot;c&squot;
suffix:colon
(brace
r_int
r_int
id|cr
(braket
l_int|5
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cr
(braket
id|i
)braket
op_assign
id|kdb_getcr
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|kdb_printf
c_func
(paren
l_string|&quot;cr0 = 0x%8.8x  cr1 = 0x%8.8x  cr2 = 0x%8.8x  cr3 = 0x%8.8x&bslash;ncr4 = 0x%8.8x&bslash;n&quot;
comma
id|cr
(braket
l_int|0
)braket
comma
id|cr
(braket
l_int|1
)braket
comma
id|cr
(braket
l_int|2
)braket
comma
id|cr
(braket
l_int|3
)braket
comma
id|cr
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_case
l_char|&squot;m&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
(brace
id|show_cur_stack_frame
c_func
(paren
id|regs
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
l_char|&squot;%&squot;
suffix:colon
(brace
r_int
r_int
id|contents
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kdbgetregcontents
c_func
(paren
id|type
op_plus
l_int|1
comma
id|regs
comma
op_amp
id|contents
)paren
)paren
id|kdb_printf
c_func
(paren
l_string|&quot;%s = 0x%16.16lx&bslash;n&quot;
comma
id|type
op_plus
l_int|1
comma
id|contents
)paren
suffix:semicolon
r_else
id|kdb_printf
c_func
(paren
l_string|&quot;diag: Invalid register %s&bslash;n&quot;
comma
id|type
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
id|KDB_BADREG
suffix:semicolon
)brace
multiline_comment|/* NOTREACHED */
r_return
l_int|0
suffix:semicolon
)brace
id|k_machreg_t
DECL|function|kdb_getpc
id|kdb_getpc
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|regs-&gt;cr_iip
op_plus
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|ri
suffix:semicolon
)brace
r_int
DECL|function|kdb_setpc
id|kdb_setpc
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|k_machreg_t
id|newpc
)paren
(brace
id|regs-&gt;cr_iip
op_assign
id|newpc
op_amp
op_complement
l_int|0xf
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|ri
op_assign
id|newpc
op_amp
l_int|0x3
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|kdb_disableint
id|kdb_disableint
c_func
(paren
id|kdbintstate_t
op_star
id|state
)paren
(brace
r_int
op_star
id|fp
op_assign
(paren
r_int
op_star
)paren
id|state
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|fp
op_assign
id|flags
suffix:semicolon
)brace
r_void
DECL|function|kdb_restoreint
id|kdb_restoreint
c_func
(paren
id|kdbintstate_t
op_star
id|state
)paren
(brace
r_int
id|flags
op_assign
op_star
(paren
r_int
op_star
)paren
id|state
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_int
DECL|function|kdb_putword
id|kdb_putword
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|contents
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|addr
op_assign
id|contents
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|kdb_getcurrentframe
id|kdb_getcurrentframe
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#if 0
id|regs-&gt;xcs
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_KDB_FRAMEPTR)
id|asm
r_volatile
(paren
l_string|&quot;movl %%ebp,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|regs-&gt;ebp
)paren
)paren
suffix:semicolon
macro_line|#endif
id|asm
r_volatile
(paren
l_string|&quot;movl %%esp,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|regs-&gt;esp
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|show_cur_stack_frame
id|show_cur_stack_frame
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|regno
comma
r_int
r_int
op_star
id|contents
)paren
(brace
r_int
id|sof
op_assign
id|regs-&gt;cr_ifs
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|7
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* size of frame */
r_int
r_int
id|i
suffix:semicolon
r_int
id|j
suffix:semicolon
r_struct
id|switch_stack
op_star
id|prs_regs
op_assign
id|getprsregs
c_func
(paren
id|regs
)paren
suffix:semicolon
r_int
r_int
op_star
id|sofptr
op_assign
(paren
id|prs_regs
ques
c_cond
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|prs_regs-&gt;ar_bspstore
comma
op_minus
id|sof
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sofptr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to display Current Stack Frame&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|regno
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|sof
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
comma
id|j
op_increment
)paren
(brace
multiline_comment|/* remember to skip the nat collection dword */
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|sofptr
op_rshift
l_int|3
)paren
op_amp
(paren
(paren
(paren
l_int|1
op_lshift
l_int|6
)paren
op_minus
l_int|1
)paren
)paren
)paren
op_eq
(paren
(paren
l_int|1
op_lshift
l_int|6
)paren
op_minus
l_int|1
)paren
)paren
id|sofptr
op_increment
suffix:semicolon
multiline_comment|/* return the value in the reg if regno is non zero */
r_if
c_cond
(paren
id|regno
)paren
(brace
r_if
c_cond
(paren
(paren
id|j
op_plus
l_int|1
)paren
op_eq
id|regno
)paren
(brace
r_if
c_cond
(paren
id|contents
)paren
op_star
id|contents
op_assign
op_star
id|sofptr
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sofptr
op_increment
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; r%d: %016lx &quot;
comma
l_int|32
op_plus
id|j
comma
op_star
id|sofptr
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|j
op_plus
l_int|1
)paren
op_mod
l_int|3
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|regno
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
multiline_comment|/* bogus rse number */
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
