multiline_comment|/*&n; * TLB support routines.&n; *&n; * Copyright (C) 1998, 1999 Hewlett-Packard Co&n; * Copyright (C) 1998, 1999 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/pal.h&gt;
DECL|macro|SUPPORTED_PGBITS
mdefine_line|#define SUPPORTED_PGBITS (&t;&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_256M |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_64M  |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_16M  |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_4M   |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_1M   |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_256K |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_64K  |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_16K  |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_8K   |&t;&t;&bslash;&n;&t;&t;1 &lt;&lt; _PAGE_SIZE_4K )
r_static
r_void
id|wrap_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
DECL|variable|ia64_next_context
r_int
r_int
id|ia64_next_context
op_assign
(paren
l_int|1UL
op_lshift
id|IA64_HW_CONTEXT_BITS
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;  * Put everything in a struct so we avoid the global offset table whenever&n;  * possible.&n;  */
DECL|variable|ia64_ptce_info
id|ia64_ptce_info_t
id|ia64_ptce_info
suffix:semicolon
multiline_comment|/*&n; * Seralize usage of ptc.g &n; */
DECL|variable|ptcg_lock
id|spinlock_t
id|ptcg_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* see &lt;asm/pgtable.h&gt; */
macro_line|#if defined(CONFIG_SMP) &amp;&amp; !defined(CONFIG_ITANIUM_PTCG)
macro_line|#include &lt;linux/irq.h&gt;
DECL|variable|flush_end
DECL|variable|flush_start
DECL|variable|flush_nbits
DECL|variable|flush_rid
r_int
r_int
id|flush_end
comma
id|flush_start
comma
id|flush_nbits
comma
id|flush_rid
suffix:semicolon
DECL|variable|flush_cpu_count
id|atomic_t
id|flush_cpu_count
suffix:semicolon
multiline_comment|/*&n; * flush_tlb_no_ptcg is called with ptcg_lock locked&n; */
r_static
r_inline
r_void
DECL|function|flush_tlb_no_ptcg
id|flush_tlb_no_ptcg
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_int
id|nbits
)paren
(brace
r_extern
r_void
id|smp_send_flush_tlb
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|saved_tpr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Some times this is called with interrupts disabled and causes&n;&t; * dead-lock; to avoid this we enable interrupt and raise the TPR&n;&t; * to enable ONLY IPI.&n;&t; */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|IA64_PSR_I
)paren
)paren
(brace
id|saved_tpr
op_assign
id|ia64_get_tpr
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|ia64_set_tpr
c_func
(paren
id|IPI_IRQ
op_minus
l_int|16
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|ptcg_lock
)paren
suffix:semicolon
id|flush_rid
op_assign
id|ia64_get_rr
c_func
(paren
id|start
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|flush_start
op_assign
id|start
suffix:semicolon
id|flush_end
op_assign
id|end
suffix:semicolon
id|flush_nbits
op_assign
id|nbits
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|flush_cpu_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
id|smp_send_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Purge local TLB entries. ALAT invalidation is done in ia64_leave_kernel.&n;&t; */
r_do
(brace
id|asm
r_volatile
(paren
l_string|&quot;ptc.l %0,%1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|start
)paren
comma
l_string|&quot;r&quot;
(paren
id|nbits
op_lshift
l_int|2
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|start
op_add_assign
(paren
l_int|1UL
op_lshift
id|nbits
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
OL
id|end
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* srlz.i implies srlz.d */
multiline_comment|/*&n;&t; * Wait for other CPUs to finish purging entries.&n;&t; */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|flush_cpu_count
)paren
)paren
(brace
multiline_comment|/* Nothing */
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|IA64_PSR_I
)paren
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|ia64_set_tpr
c_func
(paren
id|saved_tpr
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SMP &amp;&amp; !CONFIG_ITANIUM_PTCG */
r_void
DECL|function|get_new_mmu_context
id|get_new_mmu_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
(paren
id|ia64_next_context
op_amp
id|IA64_HW_CONTEXT_MASK
)paren
op_eq
l_int|0
)paren
(brace
id|wrap_context
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
id|mm-&gt;context
op_assign
id|ia64_next_context
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * This is where we handle the case where (ia64_next_context &amp;&n; * IA64_HW_CONTEXT_MASK) == 0.  Whenever this happens, we need to&n; * flush the entire TLB and skip over region id number 0, which is&n; * used by the kernel.&n; */
r_static
r_void
DECL|function|wrap_context
id|wrap_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
multiline_comment|/*&n;&t; * We wrapped back to the first region id so we nuke the TLB&n;&t; * so we can switch to the next generation of region ids.&n;&t; */
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ia64_next_context
op_increment
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Oops, we&squot;ve used up all 64 bits of the context&n;&t;&t; * space---walk through task table to ensure we don&squot;t&n;&t;&t; * get tricked into using an old context.  If this&n;&t;&t; * happens, the machine has been running for a long,&n;&t;&t; * long time!&n;&t;&t; */
id|ia64_next_context
op_assign
(paren
l_int|1UL
op_lshift
id|IA64_HW_CONTEXT_BITS
)paren
op_plus
l_int|1
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
(paren
id|task
)paren
(brace
r_if
c_cond
(paren
id|task-&gt;mm
op_eq
id|mm
)paren
r_continue
suffix:semicolon
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|__flush_tlb_all
id|__flush_tlb_all
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|flags
comma
id|count0
comma
id|count1
comma
id|stride0
comma
id|stride1
comma
id|addr
op_assign
id|ia64_ptce_info.base
suffix:semicolon
id|count0
op_assign
id|ia64_ptce_info.count
(braket
l_int|0
)braket
suffix:semicolon
id|count1
op_assign
id|ia64_ptce_info.count
(braket
l_int|1
)braket
suffix:semicolon
id|stride0
op_assign
id|ia64_ptce_info.stride
(braket
l_int|0
)braket
suffix:semicolon
id|stride1
op_assign
id|ia64_ptce_info.stride
(braket
l_int|1
)braket
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count0
suffix:semicolon
op_increment
id|i
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count1
suffix:semicolon
op_increment
id|j
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;ptc.e %0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
id|addr
op_add_assign
id|stride1
suffix:semicolon
)brace
id|addr
op_add_assign
id|stride0
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* srlz.i implies srlz.d */
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|flush_tlb_range
id|flush_tlb_range
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
r_int
r_int
id|nbits
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_ne
id|current-&gt;active_mm
)paren
(brace
multiline_comment|/* this doesn&squot;t happen often, if at all, so it&squot;s not worth optimizing for... */
id|mm-&gt;context
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nbits
op_assign
id|ia64_fls
c_func
(paren
id|size
op_plus
l_int|0xfff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
l_int|1UL
op_lshift
id|nbits
)paren
op_amp
id|SUPPORTED_PGBITS
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|nbits
OG
id|_PAGE_SIZE_256M
)paren
id|nbits
op_assign
id|_PAGE_SIZE_256M
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t;&t; * Some page sizes are not implemented in the&n;&t;&t;&t; * IA-64 arch, so if we get asked to clear an&n;&t;&t;&t; * unsupported page size, round up to the&n;&t;&t;&t; * nearest page size.  Note that we depend on&n;&t;&t;&t; * the fact that if page size N is not&n;&t;&t;&t; * implemented, 2*N _is_ implemented.&n;&t;&t;&t; */
op_increment
id|nbits
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
l_int|1UL
op_lshift
id|nbits
)paren
op_amp
id|SUPPORTED_PGBITS
)paren
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;flush_tlb_range: BUG: nbits=%lu&bslash;n&quot;
comma
id|nbits
)paren
suffix:semicolon
)brace
id|start
op_and_assign
op_complement
(paren
(paren
l_int|1UL
op_lshift
id|nbits
)paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_SMP) &amp;&amp; !defined(CONFIG_ITANIUM_PTCG)
id|flush_tlb_no_ptcg
c_func
(paren
id|start
comma
id|end
comma
id|nbits
)paren
suffix:semicolon
macro_line|#else
id|spin_lock
c_func
(paren
op_amp
id|ptcg_lock
)paren
suffix:semicolon
r_do
(brace
macro_line|# ifdef CONFIG_SMP
multiline_comment|/*&n;&t;&t; * Flush ALAT entries also.&n;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;ptc.ga %0,%1;;srlz.i;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|start
)paren
comma
l_string|&quot;r&quot;
(paren
id|nbits
op_lshift
l_int|2
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
macro_line|# else
id|asm
r_volatile
(paren
l_string|&quot;ptc.l %0,%1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|start
)paren
comma
l_string|&quot;r&quot;
(paren
id|nbits
op_lshift
l_int|2
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
macro_line|# endif
id|start
op_add_assign
(paren
l_int|1UL
op_lshift
id|nbits
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
OL
id|end
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP &amp;&amp; !defined(CONFIG_ITANIUM_PTCG) */
id|spin_unlock
c_func
(paren
op_amp
id|ptcg_lock
)paren
suffix:semicolon
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* srlz.i implies srlz.d */
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|ia64_tlb_init
id|ia64_tlb_init
(paren
r_void
)paren
(brace
id|ia64_get_ptce
c_func
(paren
op_amp
id|ia64_ptce_info
)paren
suffix:semicolon
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* nuke left overs from bootstrapping... */
)brace
eof
