multiline_comment|/*&n; * This file contains the code to configure and read/write the ia64 performance&n; * monitoring stuff.&n; *&n; * Originaly Written by Ganesh Venkitachalam, IBM Corp.&n; * Modifications by David Mosberger-Tang, Hewlett-Packard Co.&n; * Copyright (C) 1999 Ganesh Venkitachalam &lt;venkitac@us.ibm.com&gt;&n; * Copyright (C) 1999 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pal.h&gt;
multiline_comment|/* Long blurb on how this works: &n; * We set dcr.pp, psr.pp, and the appropriate pmc control values with&n; * this.  Notice that we go about modifying _each_ task&squot;s pt_regs to&n; * set cr_ipsr.pp.  This will start counting when &quot;current&quot; does an&n; * _rfi_. Also, since each task&squot;s cr_ipsr.pp, and cr_ipsr is inherited&n; * across forks, we do _not_ need additional code on context&n; * switches. On stopping of the counters we dont need to go about&n; * changing every task&squot;s cr_ipsr back to where it wuz, because we can&n; * just set pmc[0]=1. But we do it anyways becuase we will probably&n; * add thread specific accounting later.&n; *&n; * The obvious problem with this is that on SMP systems, it is a bit&n; * of work (when someone wants to do it:-)) - it would be easier if we&n; * just added code to the context-switch path, but if we wanted to support&n; * per-thread accounting, the context-switch path might be long unless &n; * we introduce a flag in the task_struct. Right now, the following code &n; * will NOT work correctly on MP (for more than one reason:-)).&n; *&n; * The short answer is that to make this work on SMP,  we would need &n; * to lock the run queue to ensure no context switches, send &n; * an IPI to each processor, and in that IPI handler, set processor regs,&n; * and just modify the psr bit of only the _current_ thread, since we have &n; * modified the psr bit correctly in the kernel stack for every process &n; * which is not running. Also, we need pmd arrays per-processor, and &n; * the READ_PMD command will need to get values off of other processors. &n; * IPIs are the answer, irrespective of what the question is. Might &n; * crash on SMP systems without the lock_kernel().&n; */
macro_line|#ifdef CONFIG_PERFMON
DECL|macro|MAX_PERF_COUNTER
mdefine_line|#define MAX_PERF_COUNTER&t;4&t;/* true for Itanium, at least */
DECL|macro|PMU_FIRST_COUNTER
mdefine_line|#define PMU_FIRST_COUNTER&t;4&t;/* first generic counter */
DECL|macro|WRITE_PMCS_AND_START
mdefine_line|#define WRITE_PMCS_AND_START&t;0xa0
DECL|macro|WRITE_PMCS
mdefine_line|#define WRITE_PMCS&t;&t;0xa1
DECL|macro|READ_PMDS
mdefine_line|#define READ_PMDS&t;&t;0xa2
DECL|macro|STOP_PMCS
mdefine_line|#define STOP_PMCS&t;&t;0xa3
multiline_comment|/*&n; * this structure needs to be enhanced&n; */
r_typedef
r_struct
(brace
DECL|member|pmu_reg_data
r_int
r_int
id|pmu_reg_data
suffix:semicolon
multiline_comment|/* generic PMD register */
DECL|member|pmu_reg_num
r_int
r_int
id|pmu_reg_num
suffix:semicolon
multiline_comment|/* which register number */
DECL|typedef|perfmon_reg_t
)brace
id|perfmon_reg_t
suffix:semicolon
multiline_comment|/*&n; * This structure is initialize at boot time and contains&n; * a description of the PMU main characteristic as indicated&n; * by PAL&n; */
r_typedef
r_struct
(brace
DECL|member|perf_ovfl_val
r_int
r_int
id|perf_ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for generic counters */
DECL|member|max_pmc
r_int
r_int
id|max_pmc
suffix:semicolon
multiline_comment|/* highest PMC */
DECL|member|max_pmd
r_int
r_int
id|max_pmd
suffix:semicolon
multiline_comment|/* highest PMD */
DECL|member|max_counters
r_int
r_int
id|max_counters
suffix:semicolon
multiline_comment|/* number of generic counter pairs (PMC/PMD) */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
multiline_comment|/* XXX will go static when ptrace() is cleaned */
DECL|variable|perf_ovfl_val
r_int
r_int
id|perf_ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for generic counters */
DECL|variable|pmu_conf
r_static
id|pmu_config_t
id|pmu_conf
suffix:semicolon
multiline_comment|/*&n; * could optimize to avoid cache conflicts in SMP&n; */
DECL|variable|pmds
r_int
r_int
id|pmds
(braket
id|NR_CPUS
)braket
(braket
id|MAX_PERF_COUNTER
)braket
suffix:semicolon
id|asmlinkage
r_int
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|cmd
comma
r_int
id|count
comma
r_void
op_star
id|ptr
comma
r_int
id|arg4
comma
r_int
id|arg5
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
id|perfmon_reg_t
id|tmp
comma
op_star
id|cptr
op_assign
id|ptr
suffix:semicolon
r_int
r_int
id|cnum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|WRITE_PMCS
suffix:colon
multiline_comment|/* Writes to PMC&squot;s and clears PMDs */
r_case
id|WRITE_PMCS_AND_START
suffix:colon
multiline_comment|/* Also starts counting */
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|cptr
comma
r_sizeof
(paren
r_struct
id|perfmon_reg_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|cptr
op_increment
)paren
(brace
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|cptr
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX need to check validity of pmu_reg_num and perhaps data!! */
r_if
c_cond
(paren
id|tmp.pmu_reg_num
OG
id|pmu_conf.max_pmc
op_logical_or
id|tmp.pmu_reg_num
op_eq
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|tmp.pmu_reg_num
comma
id|tmp.pmu_reg_data
)paren
suffix:semicolon
multiline_comment|/* to go away */
r_if
c_cond
(paren
id|tmp.pmu_reg_num
op_ge
id|PMU_FIRST_COUNTER
op_logical_and
id|tmp.pmu_reg_num
OL
id|PMU_FIRST_COUNTER
op_plus
id|pmu_conf.max_counters
)paren
(brace
id|ia64_set_pmd
c_func
(paren
id|tmp.pmu_reg_num
comma
l_int|0
)paren
suffix:semicolon
id|pmds
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
(braket
id|tmp.pmu_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; setting PMC/PMD[%ld] es=0x%lx pmd[%ld]=%lx&bslash;n&quot;
comma
id|tmp.pmu_reg_num
comma
(paren
id|tmp.pmu_reg_data
op_rshift
l_int|8
)paren
op_amp
l_int|0x7f
comma
id|tmp.pmu_reg_num
comma
id|ia64_get_pmd
c_func
(paren
id|tmp.pmu_reg_num
)paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; setting PMC[%ld]=0x%lx&bslash;n&quot;
comma
id|tmp.pmu_reg_num
comma
id|tmp.pmu_reg_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|WRITE_PMCS_AND_START
)paren
(brace
macro_line|#if 0
multiline_comment|/* irrelevant with user monitors */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_or_assign
id|IA64_DCR_PP
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* will start monitoring right after rfi */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * mark the state as valid.&n;&t;&t; * this will trigger save/restore at context switch&n;&t;&t; */
id|current-&gt;thread.flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_PMDS
suffix:colon
r_if
c_cond
(paren
id|count
op_le
l_int|0
op_logical_or
id|count
OG
id|MAX_PERF_COUNTER
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|cptr
comma
r_sizeof
(paren
r_struct
id|perfmon_reg_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* This looks shady, but IMHO this will work fine. This is  &n;&t;&t; * the sequence that I could come up with to avoid races&n;&t;&t; * with the interrupt handler. See explanation in the &n;&t;&t; * following comment.&n;&t;&t; */
macro_line|#if 0
multiline_comment|/* irrelevant with user monitors */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rsm psr.pp&bslash;n&quot;
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_and_assign
op_complement
id|IA64_DCR_PP
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * We cannot write to pmc[0] to stop counting here, as&n;&t;&t; * that particular instruction might cause an overflow&n;&t;&t; * and the mask in pmc[0] might get lost. I&squot;m _not_ &n;&t;&t; * sure of the hardware behavior here. So we stop&n;&t;&t; * counting by psr.pp = 0. And we reset dcr.pp to&n;&t;&t; * prevent an interrupt from mucking up psr.pp in the&n;&t;&t; * meanwhile. Perfmon interrupts are pended, hence the&n;&t;&t; * above code should be ok if one of the above instructions &n;&t;&t; * caused overflows, i.e the interrupt should get serviced&n;&t;&t; * when we re-enabled interrupts. When I muck with dcr, &n;&t;&t; * is the irq_save/restore needed?&n;&t;&t; */
multiline_comment|/* XXX: This needs to change to read more than just the counters */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|cnum
op_increment
comma
id|cptr
op_increment
)paren
(brace
id|tmp.pmu_reg_data
op_assign
(paren
id|pmds
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
(braket
id|i
)braket
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
id|tmp.pmu_reg_num
op_assign
id|cnum
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|cptr
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* irrelevant with user monitors */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ssm psr.pp&quot;
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_or_assign
id|IA64_DCR_PP
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|STOP_PMCS
suffix:colon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PERF_COUNTER
suffix:semicolon
op_increment
id|i
)paren
id|ia64_set_pmc
c_func
(paren
l_int|4
op_plus
id|i
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* irrelevant with user monitors */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_and_assign
op_complement
id|IA64_DCR_PP
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|current-&gt;thread.flags
op_and_assign
op_complement
(paren
id|IA64_THREAD_PM_VALID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|update_counters
id|update_counters
(paren
r_void
)paren
(brace
r_int
r_int
id|mask
comma
id|i
comma
id|cnum
comma
id|val
suffix:semicolon
id|mask
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
op_rshift
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|cnum
op_increment
comma
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
id|val
op_assign
id|mask
op_amp
l_int|0x1
ques
c_cond
id|pmu_conf.perf_ovfl_val
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; PMD%ld overflowed pmd=%lx pmod=%lx&bslash;n&quot;
comma
id|cnum
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
comma
id|pmds
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* since we got an interrupt, might as well clear every pmd. */
id|val
op_add_assign
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; adding val=%lx to pmod[%ld]=%lx &bslash;n&quot;
comma
id|val
comma
id|i
comma
id|pmds
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
id|pmds
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
(braket
id|i
)braket
op_add_assign
id|val
suffix:semicolon
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|perfmon_interrupt
id|perfmon_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|update_counters
c_func
(paren
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|perfmon_irqaction
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
id|handler
suffix:colon
id|perfmon_interrupt
comma
id|flags
suffix:colon
id|SA_INTERRUPT
comma
id|name
suffix:colon
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
r_static
r_int
DECL|function|perfmon_proc_info
id|perfmon_proc_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;PMC[0]=%lx&bslash;n&quot;
comma
id|pmc0
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|perfmon_read_entry
id|perfmon_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|perfmon_proc_info
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
r_void
id|__init
DECL|function|perfmon_init
id|perfmon_init
(paren
r_void
)paren
(brace
id|pal_perf_mon_info_u_t
id|pm_info
suffix:semicolon
id|u64
id|pm_buffer
(braket
l_int|16
)braket
suffix:semicolon
id|s64
id|status
suffix:semicolon
id|irq_desc
(braket
id|PERFMON_IRQ
)braket
dot
id|status
op_or_assign
id|IRQ_PER_CPU
suffix:semicolon
id|irq_desc
(braket
id|PERFMON_IRQ
)braket
dot
id|handler
op_assign
op_amp
id|irq_type_ia64_sapic
suffix:semicolon
id|setup_irq
c_func
(paren
id|PERFMON_IRQ
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_set_pmv
c_func
(paren
id|PERFMON_IRQ
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Initialized vector to %u&bslash;n&quot;
comma
id|PERFMON_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_perf_mon_info
c_func
(paren
id|pm_buffer
comma
op_amp
id|pm_info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; pal call failed (%ld)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmu_conf.perf_ovfl_val
op_assign
id|perf_ovfl_val
op_assign
(paren
l_int|1L
op_lshift
id|pm_info.pal_perf_mon_info_s.width
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* XXX need to use PAL instead */
id|pmu_conf.max_pmc
op_assign
l_int|13
suffix:semicolon
id|pmu_conf.max_pmd
op_assign
l_int|17
suffix:semicolon
id|pmu_conf.max_counters
op_assign
id|pm_info.pal_perf_mon_info_s.generic
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Counters are %d bits&bslash;n&quot;
comma
id|pm_info.pal_perf_mon_info_s.width
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Maximum counter value 0x%lx&bslash;n&quot;
comma
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * for now here for debug purposes&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_read_entry
(paren
l_string|&quot;perfmon&quot;
comma
l_int|0
comma
l_int|0
comma
id|perfmon_read_entry
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|perfmon_init_percpu
id|perfmon_init_percpu
(paren
r_void
)paren
(brace
id|ia64_set_pmv
c_func
(paren
id|PERFMON_IRQ
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|ia64_save_pm_regs
id|ia64_save_pm_regs
(paren
r_struct
id|thread_struct
op_star
id|t
)paren
(brace
r_int
id|i
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: this will need to be extended beyong just counters&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IA64_NUM_PM_REGS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
l_int|4
op_plus
id|i
)paren
suffix:semicolon
id|t-&gt;pmod
(braket
id|i
)braket
op_assign
id|pmds
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
(braket
id|i
)braket
suffix:semicolon
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|4
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ia64_load_pm_regs
id|ia64_load_pm_regs
(paren
r_struct
id|thread_struct
op_star
id|t
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: this will need to be extended beyong just counters &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IA64_NUM_PM_REGS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ia64_set_pmd
c_func
(paren
l_int|4
op_plus
id|i
comma
id|t-&gt;pmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|pmds
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
(braket
id|i
)braket
op_assign
id|t-&gt;pmod
(braket
id|i
)braket
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|4
op_plus
id|i
comma
id|t-&gt;pmc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PERFMON */
id|asmlinkage
r_int
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|cmd
comma
r_int
id|count
comma
r_void
op_star
id|ptr
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_PERFMON */
eof
