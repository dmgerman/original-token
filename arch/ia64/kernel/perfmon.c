multiline_comment|/*&n; * This file contains the code to configure and read/write the ia64 performance&n; * monitoring stuff.&n; *&n; * Originaly Written by Ganesh Venkitachalam, IBM Corp.&n; * Modifications by David Mosberger-Tang, Hewlett-Packard Co.&n; * Modifications by Stephane Eranian, Hewlett-Packard Co.&n; * Copyright (C) 1999 Ganesh Venkitachalam &lt;venkitac@us.ibm.com&gt;&n; * Copyright (C) 1999 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; * Copyright (C) 2000 Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pal.h&gt;
multiline_comment|/* Long blurb on how this works: &n; * We set dcr.pp, psr.pp, and the appropriate pmc control values with&n; * this.  Notice that we go about modifying _each_ task&squot;s pt_regs to&n; * set cr_ipsr.pp.  This will start counting when &quot;current&quot; does an&n; * _rfi_. Also, since each task&squot;s cr_ipsr.pp, and cr_ipsr is inherited&n; * across forks, we do _not_ need additional code on context&n; * switches. On stopping of the counters we dont need to go about&n; * changing every task&squot;s cr_ipsr back to where it wuz, because we can&n; * just set pmc[0]=1. But we do it anyways becuase we will probably&n; * add thread specific accounting later.&n; *&n; * The obvious problem with this is that on SMP systems, it is a bit&n; * of work (when someone wants to do it:-)) - it would be easier if we&n; * just added code to the context-switch path, but if we wanted to support&n; * per-thread accounting, the context-switch path might be long unless &n; * we introduce a flag in the task_struct. Right now, the following code &n; * will NOT work correctly on MP (for more than one reason:-)).&n; *&n; * The short answer is that to make this work on SMP,  we would need &n; * to lock the run queue to ensure no context switches, send &n; * an IPI to each processor, and in that IPI handler, set processor regs,&n; * and just modify the psr bit of only the _current_ thread, since we have &n; * modified the psr bit correctly in the kernel stack for every process &n; * which is not running. Also, we need pmd arrays per-processor, and &n; * the READ_PMD command will need to get values off of other processors. &n; * IPIs are the answer, irrespective of what the question is. Might &n; * crash on SMP systems without the lock_kernel().&n; */
macro_line|#ifdef CONFIG_PERFMON
DECL|macro|MAX_PERF_COUNTER
mdefine_line|#define MAX_PERF_COUNTER&t;4&t;/* true for Itanium, at least */
DECL|macro|PMU_FIRST_COUNTER
mdefine_line|#define PMU_FIRST_COUNTER&t;4&t;/* first generic counter */
DECL|macro|PFM_WRITE_PMCS
mdefine_line|#define PFM_WRITE_PMCS&t;&t;0xa0
DECL|macro|PFM_WRITE_PMDS
mdefine_line|#define PFM_WRITE_PMDS&t;&t;0xa1
DECL|macro|PFM_READ_PMDS
mdefine_line|#define PFM_READ_PMDS&t;&t;0xa2
DECL|macro|PFM_STOP
mdefine_line|#define PFM_STOP&t;&t;0xa3
DECL|macro|PFM_START
mdefine_line|#define PFM_START&t;&t;0xa4
DECL|macro|PFM_ENABLE
mdefine_line|#define PFM_ENABLE&t;&t;0xa5&t;/* unfreeze only */
DECL|macro|PFM_DISABLE
mdefine_line|#define PFM_DISABLE&t;&t;0xa6&t;/* freeze only */
multiline_comment|/* &n; * Those 2 are just meant for debugging. I considered using sysctl() for&n; * that but it is a little bit too pervasive. This solution is at least&n; * self-contained.&n; */
DECL|macro|PFM_DEBUG_ON
mdefine_line|#define PFM_DEBUG_ON&t;&t;0xe0&t;
DECL|macro|PFM_DEBUG_OFF
mdefine_line|#define PFM_DEBUG_OFF&t;&t;0xe1
macro_line|#ifdef CONFIG_SMP
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i) (cpu_online_map &amp; (1UL &lt;&lt; i))
macro_line|#else
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i)&t;1
macro_line|#endif
DECL|macro|PMC_IS_IMPL
mdefine_line|#define PMC_IS_IMPL(i)&t;&t;(pmu_conf.impl_regs[i&gt;&gt;6] &amp; (1&lt;&lt; (i&amp;~(64-1))))
DECL|macro|PMD_IS_IMPL
mdefine_line|#define PMD_IS_IMPL(i)  &t;(pmu_conf.impl_regs[4+(i&gt;&gt;6)] &amp; (1&lt;&lt; (i&amp;~(64-1))))
DECL|macro|PMD_IS_COUNTER
mdefine_line|#define PMD_IS_COUNTER(i)&t;(i&gt;=PMU_FIRST_COUNTER &amp;&amp; i &lt; (PMU_FIRST_COUNTER+pmu_conf.max_counters))
DECL|macro|PMC_IS_COUNTER
mdefine_line|#define PMC_IS_COUNTER(i)&t;(i&gt;=PMU_FIRST_COUNTER &amp;&amp; i &lt; (PMU_FIRST_COUNTER+pmu_conf.max_counters))
multiline_comment|/*&n; * this structure needs to be enhanced&n; */
r_typedef
r_struct
(brace
DECL|member|pfr_reg_num
r_int
r_int
id|pfr_reg_num
suffix:semicolon
multiline_comment|/* which register */
DECL|member|pfr_reg_value
r_int
r_int
id|pfr_reg_value
suffix:semicolon
multiline_comment|/* configuration (PMC) or initial value (PMD) */
DECL|member|pfr_reg_reset
r_int
r_int
id|pfr_reg_reset
suffix:semicolon
multiline_comment|/* reset value on overflow (PMD) */
DECL|member|pfr_smpl_buf
r_void
op_star
id|pfr_smpl_buf
suffix:semicolon
multiline_comment|/* pointer to user buffer for EAR/BTB */
DECL|member|pfr_smpl_size
r_int
r_int
id|pfr_smpl_size
suffix:semicolon
multiline_comment|/* size of user buffer for EAR/BTB */
DECL|member|pfr_notify_pid
id|pid_t
id|pfr_notify_pid
suffix:semicolon
multiline_comment|/* process to notify */
DECL|member|pfr_notify_sig
r_int
id|pfr_notify_sig
suffix:semicolon
multiline_comment|/* signal for notification, 0=no notification */
DECL|typedef|perfmon_req_t
)brace
id|perfmon_req_t
suffix:semicolon
macro_line|#if 0
r_typedef
r_struct
(brace
r_int
r_int
id|pmu_reg_data
suffix:semicolon
multiline_comment|/* generic PMD register */
r_int
r_int
id|pmu_reg_num
suffix:semicolon
multiline_comment|/* which register number */
)brace
id|perfmon_reg_t
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * This structure is initialize at boot time and contains&n; * a description of the PMU main characteristic as indicated&n; * by PAL&n; */
r_typedef
r_struct
(brace
DECL|member|perf_ovfl_val
r_int
r_int
id|perf_ovfl_val
suffix:semicolon
multiline_comment|/* overflow value for generic counters   */
DECL|member|max_counters
r_int
r_int
id|max_counters
suffix:semicolon
multiline_comment|/* upper limit on counter pair (PMC/PMD) */
DECL|member|impl_regs
r_int
r_int
id|impl_regs
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* buffer used to hold implememted PMC/PMD mask */
DECL|typedef|pmu_config_t
)brace
id|pmu_config_t
suffix:semicolon
DECL|variable|pmu_conf
r_static
id|pmu_config_t
id|pmu_conf
suffix:semicolon
multiline_comment|/* for debug only */
DECL|variable|pfm_debug
r_static
r_int
r_int
id|pfm_debug
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 0= nodebug, &gt;0= debug output on */
DECL|macro|DBprintk
mdefine_line|#define DBprintk(a)&t;{&bslash;&n;&t;if (pfm_debug &gt;0) { printk a; } &bslash;&n;}
multiline_comment|/*&n; * could optimize to avoid cache line conflicts in SMP&n; */
DECL|variable|pmu_owners
r_static
r_struct
id|task_struct
op_star
id|pmu_owners
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_static
r_int
DECL|function|do_perfmonctl
id|do_perfmonctl
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|perfmon_req_t
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PFM_WRITE_PMCS
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX needs to check validity of the data maybe */
r_if
c_cond
(paren
op_logical_neg
id|PMC_IS_IMPL
c_func
(paren
id|tmp.pfr_reg_num
)paren
)paren
(brace
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; invalid pmc[%ld]&bslash;n&quot;
comma
id|tmp.pfr_reg_num
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* XXX: for counters, need to some checks */
r_if
c_cond
(paren
id|PMC_IS_COUNTER
c_func
(paren
id|tmp.pfr_reg_num
)paren
)paren
(brace
id|current-&gt;thread.pmu_counters
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|sig
op_assign
id|tmp.pfr_notify_sig
suffix:semicolon
id|current-&gt;thread.pmu_counters
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|pid
op_assign
id|tmp.pfr_notify_pid
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; setting PMC[%ld] send sig %d to %d&bslash;n&quot;
comma
id|tmp.pfr_reg_num
comma
id|tmp.pfr_notify_sig
comma
id|tmp.pfr_notify_pid
)paren
)paren
suffix:semicolon
)brace
id|ia64_set_pmc
c_func
(paren
id|tmp.pfr_reg_num
comma
id|tmp.pfr_reg_value
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; setting PMC[%ld]=0x%lx&bslash;n&quot;
comma
id|tmp.pfr_reg_num
comma
id|tmp.pfr_reg_value
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * we have to set this here event hough we haven&squot;t necessarily started monitoring&n;&t;&t;&t; * because we may be context switched out&n;&t;&t;&t; */
id|current-&gt;thread.flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_WRITE_PMDS
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|tmp.pfr_reg_num
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* update virtualized (64bits) counter */
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|tmp.pfr_reg_num
)paren
)paren
(brace
id|current-&gt;thread.pmu_counters
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|val
op_assign
id|tmp.pfr_reg_value
op_amp
op_complement
id|pmu_conf.perf_ovfl_val
suffix:semicolon
id|current-&gt;thread.pmu_counters
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|rval
op_assign
id|tmp.pfr_reg_reset
suffix:semicolon
)brace
multiline_comment|/* writes to unimplemented part is ignored, so this is safe */
id|ia64_set_pmd
c_func
(paren
id|tmp.pfr_reg_num
comma
id|tmp.pfr_reg_value
)paren
suffix:semicolon
multiline_comment|/* to go away */
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; setting PMD[%ld]:  pmod.val=0x%lx pmd=0x%lx rval=0x%lx&bslash;n&quot;
comma
id|tmp.pfr_reg_num
comma
id|current-&gt;thread.pmu_counters
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|val
comma
id|ia64_get_pmd
c_func
(paren
id|tmp.pfr_reg_num
)paren
comma
id|current-&gt;thread.pmu_counters
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|rval
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * we have to set this here event hough we haven&squot;t necessarily started monitoring&n;&t;&t;&t; * because we may be context switched out&n;&t;&t;&t; */
id|current-&gt;thread.flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_START
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|current
suffix:semicolon
multiline_comment|/* will start monitoring right after rfi */
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t;&t; &t; * mark the state as valid.&n;&t;&t; &t; * this will trigger save/restore at context switch&n;&t;&t; &t; */
id|current-&gt;thread.flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_ENABLE
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|current
suffix:semicolon
multiline_comment|/* &n;&t;&t; &t; * mark the state as valid.&n;&t;&t; &t; * this will trigger save/restore at context switch&n;&t;&t; &t; */
id|current-&gt;thread.flags
op_or_assign
id|IA64_THREAD_PM_VALID
suffix:semicolon
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_DISABLE
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* simply unfreeze */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_READ_PMDS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|req
comma
r_sizeof
(paren
r_struct
id|perfmon_req_t
)paren
op_star
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* This looks shady, but IMHO this will work fine. This is  &n;&t;&t; * the sequence that I could come up with to avoid races&n;&t;&t; * with the interrupt handler. See explanation in the &n;&t;&t; * following comment.&n;&t;&t; */
macro_line|#if 0
multiline_comment|/* irrelevant with user monitors */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rsm psr.pp&bslash;n&quot;
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_and_assign
op_complement
id|IA64_DCR_PP
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * We cannot write to pmc[0] to stop counting here, as&n;&t;&t; * that particular instruction might cause an overflow&n;&t;&t; * and the mask in pmc[0] might get lost. I&squot;m _not_ &n;&t;&t; * sure of the hardware behavior here. So we stop&n;&t;&t; * counting by psr.pp = 0. And we reset dcr.pp to&n;&t;&t; * prevent an interrupt from mucking up psr.pp in the&n;&t;&t; * meanwhile. Perfmon interrupts are pended, hence the&n;&t;&t; * above code should be ok if one of the above instructions &n;&t;&t; * caused overflows, i.e the interrupt should get serviced&n;&t;&t; * when we re-enabled interrupts. When I muck with dcr, &n;&t;&t; * is the irq_save/restore needed?&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|req
op_increment
)paren
(brace
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|req
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PMD_IS_IMPL
c_func
(paren
id|tmp.pfr_reg_num
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|PMD_IS_COUNTER
c_func
(paren
id|tmp.pfr_reg_num
)paren
)paren
(brace
r_if
c_cond
(paren
id|task
op_eq
id|current
)paren
(brace
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.pfr_reg_num
)paren
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|task-&gt;thread.pmd
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
op_amp
id|pmu_conf.perf_ovfl_val
suffix:semicolon
)brace
id|val
op_add_assign
id|task-&gt;thread.pmu_counters
(braket
id|tmp.pfr_reg_num
op_minus
id|PMU_FIRST_COUNTER
)braket
dot
id|val
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* for now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|val
op_assign
id|ia64_get_pmd
c_func
(paren
id|tmp.pfr_reg_num
)paren
suffix:semicolon
)brace
id|tmp.pfr_reg_value
op_assign
id|val
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; reading PMD[%ld]=0x%lx&bslash;n&quot;
comma
id|tmp.pfr_reg_num
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|req
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* irrelevant with user monitors */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ssm psr.pp&quot;
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_or_assign
id|IA64_DCR_PP
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|PFM_STOP
suffix:colon
multiline_comment|/* we don&squot;t quite support this right now */
r_if
c_cond
(paren
id|task
op_ne
id|current
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
id|current-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if 0
multiline_comment|/* irrelevant with user monitors */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|dcr
op_assign
id|ia64_get_dcr
c_func
(paren
)paren
suffix:semicolon
id|dcr
op_and_assign
op_complement
id|IA64_DCR_PP
suffix:semicolon
id|ia64_set_dcr
c_func
(paren
id|dcr
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|up
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|PFM_DEBUG_ON
suffix:colon
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; debuggin on&bslash;n&quot;
)paren
suffix:semicolon
id|pfm_debug
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PFM_DEBUG_OFF
suffix:colon
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; debuggin off&bslash;n&quot;
)paren
suffix:semicolon
id|pfm_debug
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; UNknown command 0x%x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|pid
comma
r_int
id|cmd
comma
r_int
id|flags
comma
id|perfmon_req_t
op_star
id|req
comma
r_int
id|count
comma
r_int
id|arg6
comma
r_int
id|arg7
comma
r_int
id|arg8
comma
r_int
id|stack
)paren
(brace
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|stack
suffix:semicolon
r_struct
id|task_struct
op_star
id|child
op_assign
id|current
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ne
id|current-&gt;pid
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
(brace
id|child
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|child
)paren
id|get_task_struct
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|child
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * XXX: need to do more checking here&n;&t;&t; */
r_if
c_cond
(paren
id|child-&gt;state
op_ne
id|TASK_ZOMBIE
)paren
(brace
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; warning process %d not in stable state %ld&bslash;n&quot;
comma
id|pid
comma
id|child-&gt;state
)paren
)paren
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|do_perfmonctl
c_func
(paren
id|child
comma
id|cmd
comma
id|flags
comma
id|req
comma
id|count
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|child
op_ne
id|current
)paren
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|update_counters
id|update_counters
(paren
id|u64
id|pmc0
)paren
(brace
r_int
r_int
id|mask
comma
id|i
comma
id|cnum
suffix:semicolon
r_struct
id|thread_struct
op_star
id|th
suffix:semicolon
r_struct
id|task_struct
op_star
id|ta
suffix:semicolon
r_if
c_cond
(paren
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_eq
l_int|NULL
)paren
(brace
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; Spurious overflow interrupt: PMU not owned&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It is never safe to access the task for which the overflow interrupt is destinated&n;&t; * using the current variable as the interrupt may occur in the middle of a context switch&n;&t; * where current does not hold the task that is running yet.&n;&t; *&n;&t; * For monitoring, however, we do need to get access to the task which caused the overflow&n;&t; * to account for overflow on the counters.&n;&t; * We accomplish this by maintaining a current owner of the PMU per CPU. During context&n;&t; * switch the ownership is changed in a way such that the reflected owner is always the &n;&t; * valid one, i.e. the one that caused the interrupt.&n;&t; */
id|ta
op_assign
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
id|th
op_assign
op_amp
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_member_access_from_pointer
id|thread
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t think this could happen given first test. Keep as sanity check&n;&t; */
r_if
c_cond
(paren
(paren
id|th-&gt;flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_eq
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; Spurious overflow interrupt: process %d not using perfmon&bslash;n&quot;
comma
id|ta-&gt;pid
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if PMU not frozen: spurious from previous context &n;&t; * if PMC[0] = 0x1 : frozen but no overflow reported: leftover from previous context&n;&t; *&n;&t; * in either case we don&squot;t touch the state upon return from handler&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
l_int|0x1
)paren
op_eq
l_int|0
op_logical_or
id|pmc0
op_eq
l_int|0x1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; Spurious overflow interrupt: process %d freeze=0&bslash;n&quot;
comma
id|ta-&gt;pid
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mask
op_assign
id|pmc0
op_rshift
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnum
op_assign
id|PMU_FIRST_COUNTER
suffix:semicolon
id|i
OL
id|pmu_conf.max_counters
suffix:semicolon
id|cnum
op_increment
comma
id|i
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x1
)paren
(brace
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; PMD[%ld] overflowed pmd=0x%lx pmod.val=0x%lx&bslash;n&quot;
comma
id|cnum
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
comma
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|val
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Because we somtimes (EARS/BTB) reset to a specific value, we cannot simply use &n;&t;&t;&t; * val to count the number of times we overflowed. Otherwise we would loose the value&n;&t;&t;&t; * current in the PMD (which can be &gt;0). So to make sure we don&squot;t loose&n;&t;&t;&t; * the residual counts we set val to contain full 64bits value of the counter.&n;&t;&t;&t; */
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|val
op_add_assign
l_int|1
op_plus
id|pmu_conf.perf_ovfl_val
op_plus
(paren
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
multiline_comment|/* writes to upper part are ignored, so this is safe */
id|ia64_set_pmd
c_func
(paren
id|cnum
comma
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|rval
)paren
suffix:semicolon
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; pmod[%ld].val=0x%lx pmd=0x%lx&bslash;n&quot;
comma
id|i
comma
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|val
comma
id|ia64_get_pmd
c_func
(paren
id|cnum
)paren
op_amp
id|pmu_conf.perf_ovfl_val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|pid
op_ne
l_int|0
op_logical_and
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|sig
OG
l_int|0
)paren
(brace
id|DBprintk
c_func
(paren
(paren
id|__FUNCTION__
l_string|&quot; shouild notify process %d with signal %d&bslash;n&quot;
comma
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|pid
comma
id|th-&gt;pmu_counters
(braket
id|i
)braket
dot
id|sig
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
DECL|function|perfmon_interrupt
id|perfmon_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* unfreeze if not spurious */
r_if
c_cond
(paren
id|update_counters
c_func
(paren
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
)paren
)paren
(brace
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|perfmon_irqaction
r_static
r_struct
id|irqaction
id|perfmon_irqaction
op_assign
(brace
id|handler
suffix:colon
id|perfmon_interrupt
comma
id|flags
suffix:colon
id|SA_INTERRUPT
comma
id|name
suffix:colon
l_string|&quot;perfmon&quot;
)brace
suffix:semicolon
r_static
r_int
DECL|function|perfmon_proc_info
id|perfmon_proc_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;PMC[0]=%lx&bslash;nPerfmon debug: %s&bslash;n&quot;
comma
id|pmc0
comma
id|pfm_debug
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_is_online
c_func
(paren
id|i
)paren
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;CPU%d.PMU %d&bslash;n&quot;
comma
id|i
comma
id|pmu_owners
(braket
id|i
)braket
ques
c_cond
id|pmu_owners
(braket
id|i
)braket
op_member_access_from_pointer
id|pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|perfmon_read_entry
id|perfmon_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|perfmon_proc_info
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|variable|perfmon_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|perfmon_dir
suffix:semicolon
r_void
id|__init
DECL|function|perfmon_init
id|perfmon_init
(paren
r_void
)paren
(brace
id|pal_perf_mon_info_u_t
id|pm_info
suffix:semicolon
id|s64
id|status
suffix:semicolon
id|irq_desc
(braket
id|PERFMON_IRQ
)braket
dot
id|status
op_or_assign
id|IRQ_PER_CPU
suffix:semicolon
id|irq_desc
(braket
id|PERFMON_IRQ
)braket
dot
id|handler
op_assign
op_amp
id|irq_type_ia64_sapic
suffix:semicolon
id|setup_irq
c_func
(paren
id|PERFMON_IRQ
comma
op_amp
id|perfmon_irqaction
)paren
suffix:semicolon
id|ia64_set_pmv
c_func
(paren
id|PERFMON_IRQ
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Initialized vector to %u&bslash;n&quot;
comma
id|PERFMON_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_perf_mon_info
c_func
(paren
id|pmu_conf.impl_regs
comma
op_amp
id|pm_info
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; pal call failed (%ld)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmu_conf.perf_ovfl_val
op_assign
(paren
l_int|1L
op_lshift
id|pm_info.pal_perf_mon_info_s.width
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* XXX need to use PAL instead */
id|pmu_conf.max_counters
op_assign
id|pm_info.pal_perf_mon_info_s.generic
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Counters are %d bits&bslash;n&quot;
comma
id|pm_info.pal_perf_mon_info_s.width
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;perfmon: Maximum counter value 0x%lx&bslash;n&quot;
comma
id|pmu_conf.perf_ovfl_val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * for now here for debug purposes&n;&t; */
id|perfmon_dir
op_assign
id|create_proc_read_entry
(paren
l_string|&quot;perfmon&quot;
comma
l_int|0
comma
l_int|0
comma
id|perfmon_read_entry
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|perfmon_init_percpu
id|perfmon_init_percpu
(paren
r_void
)paren
(brace
id|ia64_set_pmv
c_func
(paren
id|PERFMON_IRQ
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX: for system wide this function MUST never be called&n; */
r_void
DECL|function|ia64_save_pm_regs
id|ia64_save_pm_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
id|u64
id|pmc0
comma
id|psr
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * We must maek sure that we don&squot;t loose any potential overflow&n;&t; * interrupt while saving PMU context. In this code, external&n;&t; * interrupts are always enabled.&n;&t; */
multiline_comment|/*&n;&t; * save current PSR: needed because we modify it&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov %0=psr;;&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|psr
)paren
op_scope_resolution
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop monitoring:&n;&t; * This is the only way to stop monitoring without destroying overflow&n;&t; * information in PMC[0..3].&n;&t; * This is the last instruction which can cause overflow when monitoring&n;&t; * in kernel.&n;&t; * By now, we could still have an overflow interrupt in flight.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;rsm psr.up;;&quot;
op_scope_resolution
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read current overflow status:&n;&t; *&n;&t; * We may be reading stale information at this point, if we got interrupt&n;&t; * just before the read(pmc0) but that&squot;s all right. However, if we did&n;&t; * not get the interrupt before, this read reflects LAST state.&n;&t; *&n;&t; */
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * freeze PMU:&n;&t; *&n;&t; * This destroys the overflow information. This is required to make sure&n;&t; * next process does not start with monitoring on if not requested&n;&t; * (PSR.up may not be enough).&n;&t; *&n;&t; * We could still get an overflow interrupt by now. However the handler&n;&t; * will not do anything if is sees PMC[0].fr=1 but no overflow bits&n;&t; * are set. So PMU will stay in frozen state. This implies that pmc0&n;&t; * will still be holding the correct unprocessed information.&n;&t; *&n;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check for overflow bits set:&n;&t; *&n;&t; * If pmc0 reports PMU frozen, this means we have a pending overflow,&n;&t; * therefore we invoke the handler. Handler is reentrant with regards&n;&t; * to PMC[0] so it is safe to call it twice.&n;&t; *&n;&t; * IF pmc0 reports overflow, we need to reread current PMC[0] value&n;&t; * in case the handler was invoked right after the first pmc0 read.&n;&t; * it is was not invoked then pmc0==PMC[0], otherwise it&squot;s been invoked&n;&t; * and overflow information has been processed, so we don&squot;t need to call.&n;&t; *&n;&t; * Test breakdown:&n;&t; *&t;- pmc0 &amp; ~0x1: test if overflow happened&n;&t; * &t;- second part: check if current register reflects this as well.&n;&t; *&n;&t; * NOTE: testing for pmc0 &amp; 0x1 is not enough has it would trigger call&n;&t; * when PM_VALID and PMU.fr which is common when setting up registers&n;&t; * just before actually starting monitors.&n;&t; *&n;&t; */
r_if
c_cond
(paren
(paren
id|pmc0
op_amp
op_complement
l_int|0x1
)paren
op_logical_and
(paren
(paren
id|pmc0
op_assign
id|ia64_get_pmc
c_func
(paren
l_int|0
)paren
)paren
op_amp
op_complement
l_int|0x1
)paren
)paren
(brace
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; Warning: pmc[0]=0x%lx&bslash;n&quot;
comma
id|pmc0
)paren
suffix:semicolon
id|update_counters
c_func
(paren
id|pmc0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * XXX: not sure that&squot;s enough. the next task may still get the&n;&t;&t; * interrupt.&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * restore PSR for context switch to save&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov psr.l=%0;;&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: this will need to be extended beyong just counters&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|4
suffix:semicolon
id|i
OL
id|IA64_NUM_PMD_COUNTERS
suffix:semicolon
id|i
op_increment
comma
id|j
op_increment
)paren
(brace
id|t-&gt;pmd
(braket
id|i
)braket
op_assign
id|ia64_get_pmd
c_func
(paren
id|j
)paren
suffix:semicolon
id|t-&gt;pmc
(braket
id|i
)braket
op_assign
id|ia64_get_pmc
c_func
(paren
id|j
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * PMU is frozen, PMU context is saved: nobody owns the PMU on this CPU&n;&t; * At this point, we should not receive any pending interrupt from the &n;&t; * &squot;switched out&squot; task&n;&t; */
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|ia64_load_pm_regs
id|ia64_load_pm_regs
(paren
r_struct
id|task_struct
op_star
id|ta
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|ta-&gt;thread
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * we first restore ownership of the PMU to the &squot;soon to be current&squot;&n;&t; * context. This way, if, as soon as we unfreeze the PMU at the end&n;&t; * of this function, we get an interrupt, we attribute it to the correct&n;&t; * task&n;&t; */
id|pmu_owners
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|ta
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: this will need to be extended beyong just counters &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|4
suffix:semicolon
id|i
OL
id|IA64_NUM_PMD_COUNTERS
suffix:semicolon
id|i
op_increment
comma
id|j
op_increment
)paren
(brace
id|ia64_set_pmd
c_func
(paren
id|j
comma
id|t-&gt;pmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|ia64_set_pmc
c_func
(paren
id|j
comma
id|t-&gt;pmc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * unfreeze PMU&n;&t; */
id|ia64_set_pmc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ia64_srlz_d
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_PERFMON */
id|asmlinkage
r_int
r_int
DECL|function|sys_perfmonctl
id|sys_perfmonctl
(paren
r_int
id|cmd
comma
r_int
id|count
comma
r_void
op_star
id|ptr
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_PERFMON */
eof
