multiline_comment|/*&n; * IA-64 semaphore implementation (derived from x86 version).&n; *&n; * Copyright (C) 1999-2000 Hewlett-Packard Co&n; * Copyright (C) 1999-2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
multiline_comment|/*&n; * Semaphores are implemented using a two-way counter: The &quot;count&quot;&n; * variable is decremented for each process that tries to acquire the&n; * semaphore, while the &quot;sleepers&quot; variable is a count of such&n; * acquires.&n; *&n; * Notably, the inline &quot;up()&quot; and &quot;down()&quot; functions can efficiently&n; * test if they need to do any extra work (up needs to do something&n; * only if count was negative before the increment operation.&n; *&n; * &quot;sleepers&quot; and the contention routine ordering is protected by the&n; * semaphore spinlock.&n; *&n; * Note that these functions are only called when there is contention&n; * on the lock, and as such all this is the &quot;non-critical&quot; part of the&n; * whole semaphore business. The critical part is the inline stuff in&n; * &lt;asm/semaphore.h&gt; where we want to avoid any extra jumps and calls.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/*&n; * Logic:&n; *  - Only on a boundary condition do we need to care. When we go&n; *    from a negative count to a non-negative, we wake people up.&n; *  - When we go from a non-negative count to a negative do we&n; *    (a) synchronize with the &quot;sleepers&quot; count and (b) make sure&n; *    that we&squot;re on the wakeup list before we synchronize so that&n; *    we cannot lose wakeup events.&n; */
r_void
DECL|function|__up
id|__up
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|variable|semaphore_lock
r_static
id|spinlock_t
id|semaphore_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_void
DECL|function|__down
id|__down
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|sem-&gt;sleepers
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|sleepers
op_assign
id|sem-&gt;sleepers
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add &quot;everybody else&quot; into it. They aren&squot;t&n;&t;&t; * playing, because we own the spinlock.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
)paren
(brace
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sem-&gt;sleepers
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* us - see -1 above */
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
r_int
DECL|function|__down_interruptible
id|__down_interruptible
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|sem-&gt;sleepers
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|sleepers
op_assign
id|sem-&gt;sleepers
suffix:semicolon
multiline_comment|/*&n;&t;&t; * With signals pending, this turns into&n;&t;&t; * the trylock failure case - we won&squot;t be&n;&t;&t; * sleeping, and we* can&squot;t get the lock as&n;&t;&t; * it has contention. Just correct the count&n;&t;&t; * and exit.&n;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
id|atomic_add
c_func
(paren
id|sleepers
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Add &quot;everybody else&quot; into it. They aren&squot;t&n;&t;&t; * playing, because we own the spinlock. The&n;&t;&t; * &quot;-1&quot; is because we&squot;re still hoping to get&n;&t;&t; * the lock.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
)paren
(brace
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sem-&gt;sleepers
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* us - see -1 above */
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Trylock failed - make sure we correct for having decremented the&n; * count.&n; */
r_int
DECL|function|__down_trylock
id|__down_trylock
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|sleepers
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
id|sleepers
op_assign
id|sem-&gt;sleepers
op_plus
l_int|1
suffix:semicolon
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Add &quot;everybody else&quot; and us into it. They aren&squot;t&n;&t; * playing, because we own the spinlock.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
comma
op_amp
id|sem-&gt;count
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper routines for rw semaphores.  These could be optimized some&n; * more, but since they&squot;re off the critical path, I prefer clarity for&n; * now...&n; */
multiline_comment|/*&n; * This gets called if we failed to acquire the lock, but we&squot;re biased&n; * to acquire the lock by virtue of causing the count to change from 0&n; * to -1.  Being biased, we sleep and attempt to grab the lock until&n; * we succeed.  When this function returns, we own the lock.&n; */
r_static
r_inline
r_void
DECL|function|down_read_failed_biased
id|down_read_failed_biased
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* put ourselves at the head of the list */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|sem-&gt;read_bias_granted
op_logical_and
id|xchg
c_func
(paren
op_amp
id|sem-&gt;read_bias_granted
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sem-&gt;read_bias_granted
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * This gets called if we failed to acquire the lock and we are not&n; * biased to acquire the lock.  We undo the decrement that was&n; * done earlier, go to sleep, and then attempt to re-acquire the&n; * lock afterwards.&n; */
r_static
r_inline
r_void
DECL|function|down_read_failed
id|down_read_failed
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Undo the decrement we did in down_read() and check if we&n;&t; * need to wake up someone.&n;&t; */
id|__up_read
c_func
(paren
id|sem
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sem-&gt;count
OL
l_int|0
)paren
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;count
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the lock to become unbiased.  Readers are non-exclusive.&n; */
r_void
DECL|function|__down_read_failed
id|__down_read_failed
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|count
op_eq
op_minus
l_int|1
)paren
(brace
id|down_read_failed_biased
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* unbiased */
id|down_read_failed
c_func
(paren
id|sem
)paren
suffix:semicolon
id|count
op_assign
id|ia64_fetch_and_add
c_func
(paren
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|0
)paren
r_return
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|down_write_failed_biased
id|down_write_failed_biased
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* put ourselves at the end of the list */
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|sem-&gt;write_bias_granted
op_logical_and
id|xchg
c_func
(paren
op_amp
id|sem-&gt;write_bias_granted
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sem-&gt;write_bias_granted
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/*&n;&t; * If the lock is currently unbiased, awaken the sleepers&n;&t; * FIXME: this wakes up the readers early in a bit of a&n;&t; * stampede -&gt; bad!&n;&t; */
r_if
c_cond
(paren
id|sem-&gt;count
op_ge
l_int|0
)paren
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|down_write_failed
id|down_write_failed
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|__up_write
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/* this takes care of granting the lock */
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sem-&gt;count
OL
l_int|0
)paren
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;count
op_ge
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* we must attempt to acquire or bias the lock */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the lock to become unbiased.  Since we&squot;re a writer, we&squot;ll&n; * make ourselves exclusive.&n; */
r_void
DECL|function|__down_write_failed
id|__down_write_failed
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
(brace
r_int
id|old_count
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|count
op_eq
op_minus
id|RW_LOCK_BIAS
)paren
(brace
id|down_write_failed_biased
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|down_write_failed
c_func
(paren
id|sem
)paren
suffix:semicolon
r_do
(brace
id|old_count
op_assign
id|sem-&gt;count
suffix:semicolon
id|count
op_assign
id|old_count
op_minus
id|RW_LOCK_BIAS
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmpxchg_acq
c_func
(paren
op_amp
id|sem-&gt;count
comma
id|old_count
comma
id|count
)paren
op_ne
id|old_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
)brace
)brace
r_void
DECL|function|__rwsem_wake
id|__rwsem_wake
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
(brace
id|wait_queue_head_t
op_star
id|wq
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* wake a writer */
r_if
c_cond
(paren
id|xchg
c_func
(paren
op_amp
id|sem-&gt;write_bias_granted
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|wq
op_assign
op_amp
id|sem-&gt;write_bias_wait
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* wake reader(s) */
r_if
c_cond
(paren
id|xchg
c_func
(paren
op_amp
id|sem-&gt;read_bias_granted
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|wq
op_assign
op_amp
id|sem-&gt;wait
suffix:semicolon
)brace
id|wake_up
c_func
(paren
id|wq
)paren
suffix:semicolon
multiline_comment|/* wake up everyone on the wait queue */
)brace
eof
