multiline_comment|/*&n; * Architecture-specific setup.&n; *&n; * Copyright (C) 1998-2000 Hewlett-Packard Co&n; * Copyright (C) 1998-2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__&t;/* see &lt;asm/unistd.h&gt; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/efi.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unwind.h&gt;
macro_line|#include &lt;asm/user.h&gt;
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
r_static
r_void
DECL|function|do_show_stack
id|do_show_stack
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
id|ip
comma
id|sp
comma
id|bsp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace: &quot;
)paren
suffix:semicolon
r_do
(brace
id|unw_get_ip
c_func
(paren
id|info
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|unw_get_sp
c_func
(paren
id|info
comma
op_amp
id|sp
)paren
suffix:semicolon
id|unw_get_bsp
c_func
(paren
id|info
comma
op_amp
id|bsp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%016lx&gt;] sp=0x%016lx bsp=0x%016lx&bslash;n&quot;
comma
id|ip
comma
id|sp
comma
id|bsp
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|unw_unwind
c_func
(paren
id|info
)paren
op_ge
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|show_stack
id|show_stack
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
id|unw_init_running
c_func
(paren
id|do_show_stack
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
r_struct
id|unw_frame_info
id|info
suffix:semicolon
id|unw_init_from_blocked_task
c_func
(paren
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
id|do_show_stack
c_func
(paren
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_void
DECL|function|show_regs
id|show_regs
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|ip
op_assign
id|regs-&gt;cr_iip
op_plus
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|ri
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;npsr : %016lx ifs : %016lx ip  : [&lt;%016lx&gt;]&bslash;n&quot;
comma
id|regs-&gt;cr_ipsr
comma
id|regs-&gt;cr_ifs
comma
id|ip
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;unat: %016lx pfs : %016lx rsc : %016lx&bslash;n&quot;
comma
id|regs-&gt;ar_unat
comma
id|regs-&gt;ar_pfs
comma
id|regs-&gt;ar_rsc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rnat: %016lx bsps: %016lx pr  : %016lx&bslash;n&quot;
comma
id|regs-&gt;ar_rnat
comma
id|regs-&gt;ar_bspstore
comma
id|regs-&gt;pr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ldrs: %016lx ccv : %016lx fpsr: %016lx&bslash;n&quot;
comma
id|regs-&gt;loadrs
comma
id|regs-&gt;ar_ccv
comma
id|regs-&gt;ar_fpsr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;b0  : %016lx b6  : %016lx b7  : %016lx&bslash;n&quot;
comma
id|regs-&gt;b0
comma
id|regs-&gt;b6
comma
id|regs-&gt;b7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;f6  : %05lx%016lx f7  : %05lx%016lx&bslash;n&quot;
comma
id|regs-&gt;f6.u.bits
(braket
l_int|1
)braket
comma
id|regs-&gt;f6.u.bits
(braket
l_int|0
)braket
comma
id|regs-&gt;f7.u.bits
(braket
l_int|1
)braket
comma
id|regs-&gt;f7.u.bits
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;f8  : %05lx%016lx f9  : %05lx%016lx&bslash;n&quot;
comma
id|regs-&gt;f8.u.bits
(braket
l_int|1
)braket
comma
id|regs-&gt;f8.u.bits
(braket
l_int|0
)braket
comma
id|regs-&gt;f9.u.bits
(braket
l_int|1
)braket
comma
id|regs-&gt;f9.u.bits
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r1  : %016lx r2  : %016lx r3  : %016lx&bslash;n&quot;
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
comma
id|regs-&gt;r3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r8  : %016lx r9  : %016lx r10 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r8
comma
id|regs-&gt;r9
comma
id|regs-&gt;r10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r11 : %016lx r12 : %016lx r13 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r11
comma
id|regs-&gt;r12
comma
id|regs-&gt;r13
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r14 : %016lx r15 : %016lx r16 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r14
comma
id|regs-&gt;r15
comma
id|regs-&gt;r16
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r17 : %016lx r18 : %016lx r19 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r17
comma
id|regs-&gt;r18
comma
id|regs-&gt;r19
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r20 : %016lx r21 : %016lx r22 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r20
comma
id|regs-&gt;r21
comma
id|regs-&gt;r22
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r23 : %016lx r24 : %016lx r25 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r23
comma
id|regs-&gt;r24
comma
id|regs-&gt;r25
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r26 : %016lx r27 : %016lx r28 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r26
comma
id|regs-&gt;r27
comma
id|regs-&gt;r28
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r29 : %016lx r30 : %016lx r31 : %016lx&bslash;n&quot;
comma
id|regs-&gt;r29
comma
id|regs-&gt;r30
comma
id|regs-&gt;r31
)paren
suffix:semicolon
multiline_comment|/* print the stacked registers if cr.ifs is valid: */
r_if
c_cond
(paren
id|regs-&gt;cr_ifs
op_amp
l_int|0x8000000000000000
)paren
(brace
r_int
r_int
id|val
comma
id|sof
comma
op_star
id|bsp
comma
id|ndirty
suffix:semicolon
r_int
id|i
comma
id|is_nat
op_assign
l_int|0
suffix:semicolon
id|sof
op_assign
id|regs-&gt;cr_ifs
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* size of frame */
id|ndirty
op_assign
(paren
id|regs-&gt;loadrs
op_rshift
l_int|19
)paren
suffix:semicolon
id|bsp
op_assign
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;ar_bspstore
comma
id|ndirty
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sof
suffix:semicolon
op_increment
id|i
)paren
(brace
id|get_user
c_func
(paren
id|val
comma
id|ia64_rse_skip_regs
c_func
(paren
id|bsp
comma
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r%-3u:%c%016lx%s&quot;
comma
l_int|32
op_plus
id|i
comma
id|is_nat
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|val
comma
(paren
(paren
id|i
op_eq
id|sof
op_minus
l_int|1
)paren
op_logical_or
(paren
id|i
op_mod
l_int|3
)paren
op_eq
l_int|2
)paren
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|show_stack
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
id|__attribute__
c_func
(paren
(paren
id|noreturn
)paren
)paren
DECL|function|cpu_idle
id|cpu_idle
(paren
r_void
op_star
id|unused
)paren
(brace
multiline_comment|/* endless idle loop with no priority at all */
id|init_idle
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;nice
op_assign
l_int|20
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;need_resched
)paren
id|min_xtp
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
id|current-&gt;need_resched
)paren
r_continue
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|normal_xtp
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|check_pgt_cache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pm_idle
)paren
(paren
op_star
id|pm_idle
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ia64_save_extra
id|ia64_save_extra
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
op_ne
l_int|0
)paren
id|ia64_save_debug_regs
c_func
(paren
op_amp
id|task-&gt;thread.dbr
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PERFMON
r_if
c_cond
(paren
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_ne
l_int|0
)paren
id|ia64_save_pm_regs
c_func
(paren
id|task
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|IS_IA32_PROCESS
c_func
(paren
id|ia64_task_regs
c_func
(paren
id|task
)paren
)paren
)paren
id|ia32_save_state
c_func
(paren
op_amp
id|task-&gt;thread
)paren
suffix:semicolon
)brace
r_void
DECL|function|ia64_load_extra
id|ia64_load_extra
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_if
c_cond
(paren
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_DBG_VALID
)paren
op_ne
l_int|0
)paren
id|ia64_load_debug_regs
c_func
(paren
op_amp
id|task-&gt;thread.dbr
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PERFMON
r_if
c_cond
(paren
(paren
id|task-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_ne
l_int|0
)paren
id|ia64_load_pm_regs
c_func
(paren
id|task
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|IS_IA32_PROCESS
c_func
(paren
id|ia64_task_regs
c_func
(paren
id|task
)paren
)paren
)paren
id|ia32_load_state
c_func
(paren
op_amp
id|task-&gt;thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the state of an ia-64 thread.&n; *&n; * We get here through the following  call chain:&n; *&n; *&t;&lt;clone syscall&gt;&n; *&t;sys_clone&n; *&t;do_fork&n; *&t;copy_thread&n; *&n; * This means that the stack layout is as follows:&n; *&n; *&t;+---------------------+ (highest addr)&n; *&t;|   struct pt_regs    |&n; *&t;+---------------------+&n; *&t;| struct switch_stack |&n; *&t;+---------------------+&n; *&t;|                     |&n; *&t;|    memory stack     |&n; *&t;|                     | &lt;-- sp (lowest addr)&n; *&t;+---------------------+&n; *&n; * Note: if we get called through kernel_thread() then the memory&n; * above &quot;(highest addr)&quot; is valid kernel stack memory that needs to&n; * be copied as well.&n; *&n; * Observe that we copy the unat values that are in pt_regs and&n; * switch_stack.  Spilling an integer to address X causes bit N in&n; * ar.unat to be set to the NaT bit of the register, with N=(X &amp;&n; * 0x1ff)/8.  Thus, copying the unat value preserves the NaT bits ONLY&n; * if the pt_regs structure in the parent is congruent to that of the&n; * child, modulo 512.  Since the stack is page aligned and the page&n; * size is at least 4KB, this is always the case, so there is nothing&n; * to worry about.&n; */
r_int
DECL|function|copy_thread
id|copy_thread
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|user_stack_base
comma
r_int
r_int
id|user_stack_size
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|rbs
comma
id|child_rbs
comma
id|rbs_size
comma
id|stack_offset
comma
id|stack_top
comma
id|stack_used
suffix:semicolon
r_struct
id|switch_stack
op_star
id|child_stack
comma
op_star
id|stack
suffix:semicolon
r_extern
r_char
id|ia64_ret_from_clone
suffix:semicolon
r_struct
id|pt_regs
op_star
id|child_ptregs
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; * For SMP idle threads, fork_by_hand() calls do_fork with&n;&t; * NULL regs.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|regs
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|stack_top
op_assign
(paren
r_int
r_int
)paren
id|current
op_plus
id|IA64_STK_OFFSET
suffix:semicolon
id|stack
op_assign
(paren
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
)paren
op_minus
l_int|1
suffix:semicolon
id|stack_used
op_assign
id|stack_top
op_minus
(paren
r_int
r_int
)paren
id|stack
suffix:semicolon
id|stack_offset
op_assign
id|IA64_STK_OFFSET
op_minus
id|stack_used
suffix:semicolon
id|child_stack
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|p
op_plus
id|stack_offset
)paren
suffix:semicolon
id|child_ptregs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|child_stack
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* copy parent&squot;s switch_stack &amp; pt_regs to child: */
id|memcpy
c_func
(paren
id|child_stack
comma
id|stack
comma
id|stack_used
)paren
suffix:semicolon
id|rbs
op_assign
(paren
r_int
r_int
)paren
id|current
op_plus
id|IA64_RBS_OFFSET
suffix:semicolon
id|child_rbs
op_assign
(paren
r_int
r_int
)paren
id|p
op_plus
id|IA64_RBS_OFFSET
suffix:semicolon
id|rbs_size
op_assign
id|stack-&gt;ar_bspstore
op_minus
id|rbs
suffix:semicolon
multiline_comment|/* copy the parent&squot;s register backing store to the child: */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|child_rbs
comma
(paren
r_void
op_star
)paren
id|rbs
comma
id|rbs_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|child_ptregs
)paren
)paren
(brace
r_if
c_cond
(paren
id|user_stack_base
)paren
(brace
id|child_ptregs-&gt;r12
op_assign
id|user_stack_base
op_plus
id|user_stack_size
suffix:semicolon
id|child_ptregs-&gt;ar_bspstore
op_assign
id|user_stack_base
suffix:semicolon
id|child_ptregs-&gt;ar_rnat
op_assign
l_int|0
suffix:semicolon
id|child_ptregs-&gt;loadrs
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Note: we simply preserve the relative position of&n;&t;&t; * the stack pointer here.  There is no need to&n;&t;&t; * allocate a scratch area here, since that will have&n;&t;&t; * been taken care of by the caller of sys_clone()&n;&t;&t; * already.&n;&t;&t; */
id|child_ptregs-&gt;r12
op_assign
(paren
r_int
r_int
)paren
(paren
id|child_ptregs
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* kernel sp */
id|child_ptregs-&gt;r13
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
multiline_comment|/* set `current&squot; pointer */
)brace
id|child_stack-&gt;b0
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ia64_ret_from_clone
suffix:semicolon
id|child_stack-&gt;ar_bspstore
op_assign
id|child_rbs
op_plus
id|rbs_size
suffix:semicolon
multiline_comment|/* copy parts of thread_struct: */
id|p-&gt;thread.ksp
op_assign
(paren
r_int
r_int
)paren
id|child_stack
op_minus
l_int|16
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: The calling convention considers all floating point&n;&t; * registers in the high partition (fph) to be scratch.  Since&n;&t; * the only way to get to this point is through a system call,&n;&t; * we know that the values in fph are all dead.  Hence, there&n;&t; * is no need to inherit the fph state from the parent to the&n;&t; * child and all we have to do is to make sure that&n;&t; * IA64_THREAD_FPH_VALID is cleared in the child.&n;&t; *&n;&t; * XXX We could push this optimization a bit further by&n;&t; * clearing IA64_THREAD_FPH_VALID on ANY system call.&n;&t; * However, it&squot;s not clear this is worth doing.  Also, it&n;&t; * would be a slight deviation from the normal Linux system&n;&t; * call behavior where scratch registers are preserved across&n;&t; * system calls (unless used by the system call itself).&n;&t; */
DECL|macro|THREAD_FLAGS_TO_CLEAR
macro_line|#&t;define THREAD_FLAGS_TO_CLEAR&t;(IA64_THREAD_FPH_VALID | IA64_THREAD_DBG_VALID &bslash;&n;&t;&t;&t;&t;&t; | IA64_THREAD_PM_VALID)
DECL|macro|THREAD_FLAGS_TO_SET
macro_line|#&t;define THREAD_FLAGS_TO_SET&t;0
id|p-&gt;thread.flags
op_assign
(paren
(paren
id|current-&gt;thread.flags
op_amp
op_complement
id|THREAD_FLAGS_TO_CLEAR
)paren
op_or
id|THREAD_FLAGS_TO_SET
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IA32_SUPPORT
multiline_comment|/*&n;&t; * If we&squot;re cloning an IA32 task then save the IA32 extra&n;&t; * state from the current task to the new task&n;&t; */
r_if
c_cond
(paren
id|IS_IA32_PROCESS
c_func
(paren
id|ia64_task_regs
c_func
(paren
id|current
)paren
)paren
)paren
id|ia32_save_state
c_func
(paren
op_amp
id|p-&gt;thread
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
r_void
DECL|function|do_copy_regs
id|do_copy_regs
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
id|ar_bsp
comma
id|ndirty
comma
op_star
id|krbs
comma
id|addr
comma
id|mask
comma
id|sp
comma
id|nat_bits
op_assign
l_int|0
comma
id|ip
suffix:semicolon
id|elf_greg_t
op_star
id|dst
op_assign
id|arg
suffix:semicolon
r_struct
id|pt_regs
op_star
id|pt
suffix:semicolon
r_char
id|nat
suffix:semicolon
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|dst
comma
l_int|0
comma
r_sizeof
(paren
id|elf_gregset_t
)paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t leak any kernel bits to user-level */
r_if
c_cond
(paren
id|unw_unwind_to_user
c_func
(paren
id|info
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|unw_get_sp
c_func
(paren
id|info
comma
op_amp
id|sp
)paren
suffix:semicolon
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|sp
op_plus
l_int|16
)paren
suffix:semicolon
id|krbs
op_assign
(paren
r_int
r_int
op_star
)paren
id|current
op_plus
id|IA64_RBS_OFFSET
op_div
l_int|8
suffix:semicolon
id|ndirty
op_assign
id|ia64_rse_num_regs
c_func
(paren
id|krbs
comma
id|krbs
op_plus
(paren
id|pt-&gt;loadrs
op_rshift
l_int|19
)paren
)paren
suffix:semicolon
id|ar_bsp
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
op_star
)paren
id|pt-&gt;ar_bspstore
comma
id|ndirty
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write portion of RSE backing store living on the kernel&n;&t; * stack to the VM of the process.&n;&t; */
r_for
c_loop
(paren
id|addr
op_assign
id|pt-&gt;ar_bspstore
suffix:semicolon
id|addr
OL
id|ar_bsp
suffix:semicolon
id|addr
op_add_assign
l_int|8
)paren
r_if
c_cond
(paren
id|ia64_peek
c_func
(paren
id|pt
comma
id|current
comma
id|addr
comma
op_amp
id|val
)paren
op_eq
l_int|0
)paren
id|access_process_vm
c_func
(paren
id|current
comma
id|addr
comma
op_amp
id|val
comma
r_sizeof
(paren
id|val
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * coredump format:&n;&t; *&t;r0-r31&n;&t; *&t;NaT bits (for r0-r31; bit N == 1 iff rN is a NaT)&n;&t; *&t;predicate registers (p0-p63)&n;&t; *&t;b0-b7&n;&t; *&t;ip cfm user-mask&n;&t; *&t;ar.rsc ar.bsp ar.bspstore ar.rnat&n;&t; *&t;ar.ccv ar.unat ar.fpsr ar.pfs ar.lc ar.ec&n;&t; */
multiline_comment|/* r0 is zero */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|mask
op_assign
(paren
l_int|1UL
op_lshift
id|i
)paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
op_increment
id|i
)paren
(brace
id|unw_get_gr
c_func
(paren
id|info
comma
id|i
comma
op_amp
id|dst
(braket
id|i
)braket
comma
op_amp
id|nat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nat
)paren
id|nat_bits
op_or_assign
id|mask
suffix:semicolon
id|mask
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|dst
(braket
l_int|32
)braket
op_assign
id|nat_bits
suffix:semicolon
id|unw_get_pr
c_func
(paren
id|info
comma
op_amp
id|dst
(braket
l_int|33
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|unw_get_br
c_func
(paren
id|info
comma
id|i
comma
op_amp
id|dst
(braket
l_int|34
op_plus
id|i
)braket
)paren
suffix:semicolon
id|unw_get_rp
c_func
(paren
id|info
comma
op_amp
id|ip
)paren
suffix:semicolon
id|dst
(braket
l_int|42
)braket
op_assign
id|ip
op_plus
id|ia64_psr
c_func
(paren
id|pt
)paren
op_member_access_from_pointer
id|ri
suffix:semicolon
id|dst
(braket
l_int|43
)braket
op_assign
id|pt-&gt;cr_ifs
op_amp
l_int|0x3fffffffff
suffix:semicolon
id|dst
(braket
l_int|44
)braket
op_assign
id|pt-&gt;cr_ipsr
op_amp
id|IA64_PSR_UM
suffix:semicolon
id|unw_get_ar
c_func
(paren
id|info
comma
id|UNW_AR_RSC
comma
op_amp
id|dst
(braket
l_int|45
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For bsp and bspstore, unw_get_ar() would return the kernel&n;&t; * addresses, but we need the user-level addresses instead:&n;&t; */
id|dst
(braket
l_int|46
)braket
op_assign
id|ar_bsp
suffix:semicolon
id|dst
(braket
l_int|47
)braket
op_assign
id|pt-&gt;ar_bspstore
suffix:semicolon
id|unw_get_ar
c_func
(paren
id|info
comma
id|UNW_AR_RNAT
comma
op_amp
id|dst
(braket
l_int|48
)braket
)paren
suffix:semicolon
id|unw_get_ar
c_func
(paren
id|info
comma
id|UNW_AR_CCV
comma
op_amp
id|dst
(braket
l_int|49
)braket
)paren
suffix:semicolon
id|unw_get_ar
c_func
(paren
id|info
comma
id|UNW_AR_UNAT
comma
op_amp
id|dst
(braket
l_int|50
)braket
)paren
suffix:semicolon
id|unw_get_ar
c_func
(paren
id|info
comma
id|UNW_AR_FPSR
comma
op_amp
id|dst
(braket
l_int|51
)braket
)paren
suffix:semicolon
id|dst
(braket
l_int|52
)braket
op_assign
id|pt-&gt;ar_pfs
suffix:semicolon
multiline_comment|/* UNW_AR_PFS is == to pt-&gt;cr_ifs for interrupt frames */
id|unw_get_ar
c_func
(paren
id|info
comma
id|UNW_AR_LC
comma
op_amp
id|dst
(braket
l_int|53
)braket
)paren
suffix:semicolon
id|unw_get_ar
c_func
(paren
id|info
comma
id|UNW_AR_EC
comma
op_amp
id|dst
(braket
l_int|54
)braket
)paren
suffix:semicolon
)brace
r_void
DECL|function|do_dump_fpu
id|do_dump_fpu
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_void
op_star
id|arg
)paren
(brace
id|elf_fpreg_t
op_star
id|dst
op_assign
id|arg
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|dst
comma
l_int|0
comma
r_sizeof
(paren
id|elf_fpregset_t
)paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t leak any &quot;random&quot; bits */
r_if
c_cond
(paren
id|unw_unwind_to_user
c_func
(paren
id|info
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* f0 is 0.0, f1 is 1.0 */
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
op_increment
id|i
)paren
id|unw_get_fr
c_func
(paren
id|info
comma
id|i
comma
id|dst
op_plus
id|i
)paren
suffix:semicolon
id|ia64_flush_fph
c_func
(paren
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_FPH_VALID
)paren
op_ne
l_int|0
)paren
id|memcpy
c_func
(paren
id|dst
op_plus
l_int|32
comma
id|current-&gt;thread.fph
comma
l_int|96
op_star
l_int|16
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IA64_NEW_UNWIND */
r_void
DECL|function|ia64_elf_core_copy_regs
id|ia64_elf_core_copy_regs
(paren
r_struct
id|pt_regs
op_star
id|pt
comma
id|elf_gregset_t
id|dst
)paren
(brace
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
id|unw_init_running
c_func
(paren
id|do_copy_regs
comma
id|dst
)paren
suffix:semicolon
macro_line|#else
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
(paren
r_struct
id|switch_stack
op_star
)paren
id|pt
)paren
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|ar_ec
comma
id|cfm
comma
id|ar_bsp
comma
id|ndirty
comma
op_star
id|krbs
comma
id|addr
suffix:semicolon
id|ar_ec
op_assign
(paren
id|sw-&gt;ar_pfs
op_rshift
l_int|52
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|cfm
op_assign
id|pt-&gt;cr_ifs
op_amp
(paren
(paren
l_int|1UL
op_lshift
l_int|63
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pt-&gt;cr_ifs
op_amp
(paren
l_int|1UL
op_lshift
l_int|63
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if cr_ifs isn&squot;t valid, we got here through a syscall or a break */
id|cfm
op_assign
id|sw-&gt;ar_pfs
op_amp
(paren
(paren
l_int|1UL
op_lshift
l_int|38
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|krbs
op_assign
(paren
r_int
r_int
op_star
)paren
id|current
op_plus
id|IA64_RBS_OFFSET
op_div
l_int|8
suffix:semicolon
id|ndirty
op_assign
id|ia64_rse_num_regs
c_func
(paren
id|krbs
comma
id|krbs
op_plus
(paren
id|pt-&gt;loadrs
op_rshift
l_int|19
)paren
)paren
suffix:semicolon
id|ar_bsp
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
op_star
)paren
id|pt-&gt;ar_bspstore
comma
id|ndirty
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write portion of RSE backing store living on the kernel&n;&t; * stack to the VM of the process.&n;&t; */
r_for
c_loop
(paren
id|addr
op_assign
id|pt-&gt;ar_bspstore
suffix:semicolon
id|addr
OL
id|ar_bsp
suffix:semicolon
id|addr
op_add_assign
l_int|8
)paren
(brace
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|ia64_peek
c_func
(paren
id|pt
comma
id|current
comma
id|addr
comma
op_amp
id|val
)paren
op_eq
l_int|0
)paren
id|access_process_vm
c_func
(paren
id|current
comma
id|addr
comma
op_amp
id|val
comma
r_sizeof
(paren
id|val
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;r0-r31&n;&t; *&t;NaT bits (for r0-r31; bit N == 1 iff rN is a NaT)&n;&t; *&t;predicate registers (p0-p63)&n;&t; *&t;b0-b7&n;&t; *&t;ip cfm user-mask&n;&t; *&t;ar.rsc ar.bsp ar.bspstore ar.rnat&n;&t; *&t;ar.ccv ar.unat ar.fpsr ar.pfs ar.lc ar.ec&n;&t; */
id|memset
c_func
(paren
id|dst
comma
l_int|0
comma
r_sizeof
(paren
id|dst
)paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t leak any &quot;random&quot; bits */
multiline_comment|/* r0 is zero */
id|dst
(braket
l_int|1
)braket
op_assign
id|pt-&gt;r1
suffix:semicolon
id|dst
(braket
l_int|2
)braket
op_assign
id|pt-&gt;r2
suffix:semicolon
id|dst
(braket
l_int|3
)braket
op_assign
id|pt-&gt;r3
suffix:semicolon
id|dst
(braket
l_int|4
)braket
op_assign
id|sw-&gt;r4
suffix:semicolon
id|dst
(braket
l_int|5
)braket
op_assign
id|sw-&gt;r5
suffix:semicolon
id|dst
(braket
l_int|6
)braket
op_assign
id|sw-&gt;r6
suffix:semicolon
id|dst
(braket
l_int|7
)braket
op_assign
id|sw-&gt;r7
suffix:semicolon
id|dst
(braket
l_int|8
)braket
op_assign
id|pt-&gt;r8
suffix:semicolon
id|dst
(braket
l_int|9
)braket
op_assign
id|pt-&gt;r9
suffix:semicolon
id|dst
(braket
l_int|10
)braket
op_assign
id|pt-&gt;r10
suffix:semicolon
id|dst
(braket
l_int|11
)braket
op_assign
id|pt-&gt;r11
suffix:semicolon
id|dst
(braket
l_int|12
)braket
op_assign
id|pt-&gt;r12
suffix:semicolon
id|dst
(braket
l_int|13
)braket
op_assign
id|pt-&gt;r13
suffix:semicolon
id|dst
(braket
l_int|14
)braket
op_assign
id|pt-&gt;r14
suffix:semicolon
id|dst
(braket
l_int|15
)braket
op_assign
id|pt-&gt;r15
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
op_plus
l_int|16
comma
op_amp
id|pt-&gt;r16
comma
l_int|16
op_star
l_int|8
)paren
suffix:semicolon
multiline_comment|/* r16-r31 are contiguous */
id|dst
(braket
l_int|32
)braket
op_assign
id|ia64_get_nat_bits
c_func
(paren
id|pt
comma
id|sw
)paren
suffix:semicolon
id|dst
(braket
l_int|33
)braket
op_assign
id|pt-&gt;pr
suffix:semicolon
multiline_comment|/* branch regs: */
id|dst
(braket
l_int|34
)braket
op_assign
id|pt-&gt;b0
suffix:semicolon
id|dst
(braket
l_int|35
)braket
op_assign
id|sw-&gt;b1
suffix:semicolon
id|dst
(braket
l_int|36
)braket
op_assign
id|sw-&gt;b2
suffix:semicolon
id|dst
(braket
l_int|37
)braket
op_assign
id|sw-&gt;b3
suffix:semicolon
id|dst
(braket
l_int|38
)braket
op_assign
id|sw-&gt;b4
suffix:semicolon
id|dst
(braket
l_int|39
)braket
op_assign
id|sw-&gt;b5
suffix:semicolon
id|dst
(braket
l_int|40
)braket
op_assign
id|pt-&gt;b6
suffix:semicolon
id|dst
(braket
l_int|41
)braket
op_assign
id|pt-&gt;b7
suffix:semicolon
id|dst
(braket
l_int|42
)braket
op_assign
id|pt-&gt;cr_iip
op_plus
id|ia64_psr
c_func
(paren
id|pt
)paren
op_member_access_from_pointer
id|ri
suffix:semicolon
id|dst
(braket
l_int|43
)braket
op_assign
id|pt-&gt;cr_ifs
suffix:semicolon
id|dst
(braket
l_int|44
)braket
op_assign
id|pt-&gt;cr_ipsr
op_amp
id|IA64_PSR_UM
suffix:semicolon
id|dst
(braket
l_int|45
)braket
op_assign
id|pt-&gt;ar_rsc
suffix:semicolon
id|dst
(braket
l_int|46
)braket
op_assign
id|ar_bsp
suffix:semicolon
id|dst
(braket
l_int|47
)braket
op_assign
id|pt-&gt;ar_bspstore
suffix:semicolon
id|dst
(braket
l_int|48
)braket
op_assign
id|pt-&gt;ar_rnat
suffix:semicolon
id|dst
(braket
l_int|49
)braket
op_assign
id|pt-&gt;ar_ccv
suffix:semicolon
id|dst
(braket
l_int|50
)braket
op_assign
id|pt-&gt;ar_unat
suffix:semicolon
id|dst
(braket
l_int|51
)braket
op_assign
id|sw-&gt;ar_fpsr
suffix:semicolon
id|dst
(braket
l_int|52
)braket
op_assign
id|pt-&gt;ar_pfs
suffix:semicolon
id|dst
(braket
l_int|53
)braket
op_assign
id|sw-&gt;ar_lc
suffix:semicolon
id|dst
(braket
l_int|54
)braket
op_assign
(paren
id|sw-&gt;ar_pfs
op_rshift
l_int|52
)paren
op_amp
l_int|0x3f
suffix:semicolon
macro_line|#endif /* !CONFIG_IA64_NEW_UNWIND */
)brace
r_int
DECL|function|dump_fpu
id|dump_fpu
(paren
r_struct
id|pt_regs
op_star
id|pt
comma
id|elf_fpregset_t
id|dst
)paren
(brace
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
id|unw_init_running
c_func
(paren
id|do_dump_fpu
comma
id|dst
)paren
suffix:semicolon
macro_line|#else
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
(paren
r_struct
id|switch_stack
op_star
)paren
id|pt
)paren
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|dst
comma
l_int|0
comma
r_sizeof
(paren
id|dst
)paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t leak any &quot;random&quot; bits */
multiline_comment|/* f0 is 0.0 */
multiline_comment|/* f1 is 1.0 */
id|dst
(braket
l_int|2
)braket
op_assign
id|sw-&gt;f2
suffix:semicolon
id|dst
(braket
l_int|3
)braket
op_assign
id|sw-&gt;f3
suffix:semicolon
id|dst
(braket
l_int|4
)braket
op_assign
id|sw-&gt;f4
suffix:semicolon
id|dst
(braket
l_int|5
)braket
op_assign
id|sw-&gt;f5
suffix:semicolon
id|dst
(braket
l_int|6
)braket
op_assign
id|pt-&gt;f6
suffix:semicolon
id|dst
(braket
l_int|7
)braket
op_assign
id|pt-&gt;f7
suffix:semicolon
id|dst
(braket
l_int|8
)braket
op_assign
id|pt-&gt;f8
suffix:semicolon
id|dst
(braket
l_int|9
)braket
op_assign
id|pt-&gt;f9
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
op_plus
l_int|10
comma
op_amp
id|sw-&gt;f10
comma
l_int|22
op_star
l_int|16
)paren
suffix:semicolon
multiline_comment|/* f10-f31 are contiguous */
id|ia64_flush_fph
c_func
(paren
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_FPH_VALID
)paren
op_ne
l_int|0
)paren
id|memcpy
c_func
(paren
id|dst
op_plus
l_int|32
comma
id|current-&gt;thread.fph
comma
l_int|96
op_star
l_int|16
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
multiline_comment|/* f0-f31 are always valid so we always return 1 */
)brace
id|asmlinkage
r_int
DECL|function|sys_execve
id|sys_execve
(paren
r_char
op_star
id|filename
comma
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|envp
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
id|argv
comma
id|envp
comma
id|regs
)paren
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
id|pid_t
DECL|function|kernel_thread
id|kernel_thread
(paren
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|task_struct
op_star
id|parent
op_assign
id|current
suffix:semicolon
r_int
id|result
comma
id|tid
suffix:semicolon
id|tid
op_assign
id|clone
c_func
(paren
id|flags
op_or
id|CLONE_VM
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_ne
id|current
)paren
(brace
id|result
op_assign
(paren
op_star
id|fn
)paren
(paren
id|arg
)paren
suffix:semicolon
id|_exit
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
r_return
id|tid
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush thread state.  This is called when a thread does an execve().&n; */
r_void
DECL|function|flush_thread
id|flush_thread
(paren
r_void
)paren
(brace
multiline_comment|/* drop floating-point and debug-register state if it exists: */
id|current-&gt;thread.flags
op_and_assign
op_complement
(paren
id|IA64_THREAD_FPH_VALID
op_or
id|IA64_THREAD_DBG_VALID
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
r_if
c_cond
(paren
id|ia64_get_fpu_owner
c_func
(paren
)paren
op_eq
id|current
)paren
id|ia64_set_fpu_owner
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Clean up state associated with current thread.  This is called when&n; * the thread calls exit().&n; */
r_void
DECL|function|exit_thread
id|exit_thread
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_SMP
r_if
c_cond
(paren
id|ia64_get_fpu_owner
c_func
(paren
)paren
op_eq
id|current
)paren
id|ia64_set_fpu_owner
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PERFMON
multiline_comment|/* stop monitoring */
r_if
c_cond
(paren
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_PM_VALID
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * we cannot rely on switch_to() to save the PMU&n;&t;&t; * context for the last time. There is a possible race&n;&t;&t; * condition in SMP mode between the child and the&n;&t;&t; * parent.  by explicitly saving the PMU context here&n;&t;&t; * we garantee no race.  this call we also stop&n;&t;&t; * monitoring&n;&t;&t; */
id|ia64_save_pm_regs
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * make sure that switch_to() will not save context again&n;&t;&t; */
id|current-&gt;thread.flags
op_and_assign
op_complement
id|IA64_THREAD_PM_VALID
suffix:semicolon
)brace
macro_line|#endif
)brace
r_int
r_int
DECL|function|get_wchan
id|get_wchan
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_struct
id|unw_frame_info
id|info
suffix:semicolon
r_int
r_int
id|ip
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * These bracket the sleeping functions..&n;&t; */
r_extern
r_void
id|scheduling_functions_start_here
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|scheduling_functions_end_here
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|first_sched
macro_line|#&t;define first_sched&t;((unsigned long) scheduling_functions_start_here)
DECL|macro|last_sched
macro_line|#&t;define last_sched&t;((unsigned long) scheduling_functions_end_here)
multiline_comment|/*&n;&t; * Note: p may not be a blocked task (it could be current or&n;&t; * another process running on some other CPU.  Rather than&n;&t; * trying to determine if p is really blocked, we just assume&n;&t; * it&squot;s blocked and rely on the unwind routines to fail&n;&t; * gracefully if the process wasn&squot;t really blocked after all.&n;&t; * --davidm 99/12/15&n;&t; */
id|unw_init_from_blocked_task
c_func
(paren
op_amp
id|info
comma
id|p
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unw_unwind
c_func
(paren
op_amp
id|info
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|unw_get_ip
c_func
(paren
op_amp
id|info
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
OL
id|first_sched
op_logical_or
id|ip
op_ge
id|last_sched
)paren
r_return
id|ip
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_increment
OL
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
DECL|macro|first_sched
macro_line|#&t;undef first_sched
DECL|macro|last_sched
macro_line|#&t;undef last_sched
)brace
r_void
DECL|function|machine_restart
id|machine_restart
(paren
r_char
op_star
id|restart_cmd
)paren
(brace
(paren
op_star
id|efi.reset_system
)paren
(paren
id|EFI_RESET_WARM
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|machine_halt
id|machine_halt
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;machine_halt: need PAL or ACPI version here!!&bslash;n&quot;
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|machine_power_off
id|machine_power_off
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;machine_power_off: unimplemented (need ACPI version here)&bslash;n&quot;
)paren
suffix:semicolon
id|machine_halt
(paren
)paren
suffix:semicolon
)brace
eof
