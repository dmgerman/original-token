multiline_comment|/*&n; * Copyright (C) 1999-2000 Hewlett-Packard Co&n; * Copyright (C) 1999-2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
multiline_comment|/*&n; * This file implements call frame unwind support for the Linux&n; * kernel.  Parsing and processing the unwind information is&n; * time-consuming, so this implementation translates the the unwind&n; * descriptors into unwind scripts.  These scripts are very simple&n; * (basically a sequence of assignments) and efficient to execute.&n; * They are cached for later re-use.  Each script is specific for a&n; * given instruction pointer address and the set of predicate values&n; * that the script depends on (most unwind descriptors are&n; * unconditional and scripts often do not depend on predicates at&n; * all).  This code is based on the unwind conventions described in&n; * the &quot;IA-64 Software Conventions and Runtime Architecture&quot; manual.&n; *&n; * SMP conventions:&n; *&t;o updates to the global unwind data (in structure &quot;unw&quot;) are serialized&n; *&t;  by the unw.lock spinlock&n; *&t;o each unwind script has its own read-write lock; a thread must acquire&n; *&t;  a read lock before executing a script and must acquire a write lock&n; *&t;  before modifying a script&n; *&t;o if both the unw.lock spinlock and a script&squot;s read-write lock must be&n; *&t;  acquired, then the read-write lock must be acquired first.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/unwind.h&gt;
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/ptrace_offsets.h&gt;
macro_line|#include &lt;asm/rse.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;entry.h&quot;
macro_line|#include &quot;unwind_i.h&quot;
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
DECL|macro|p5
mdefine_line|#define p5&t;&t;5
DECL|macro|UNW_LOG_CACHE_SIZE
mdefine_line|#define UNW_LOG_CACHE_SIZE&t;7&t;/* each unw_script is ~256 bytes in size */
DECL|macro|UNW_CACHE_SIZE
mdefine_line|#define UNW_CACHE_SIZE&t;&t;(1 &lt;&lt; UNW_LOG_CACHE_SIZE)
DECL|macro|UNW_LOG_HASH_SIZE
mdefine_line|#define UNW_LOG_HASH_SIZE&t;(UNW_LOG_CACHE_SIZE + 1)
DECL|macro|UNW_HASH_SIZE
mdefine_line|#define UNW_HASH_SIZE&t;&t;(1 &lt;&lt; UNW_LOG_HASH_SIZE)
DECL|macro|UNW_DEBUG
mdefine_line|#define UNW_DEBUG&t;0
DECL|macro|UNW_STATS
mdefine_line|#define UNW_STATS&t;0&t;/* WARNING: this disabled interrupts for long time-spans!! */
macro_line|#if UNW_DEBUG
DECL|variable|unw_debug_level
r_static
r_int
id|unw_debug_level
op_assign
l_int|255
suffix:semicolon
DECL|macro|debug
macro_line|# define debug(level,format...)&t;if (unw_debug_level &gt; level) printk(format)
DECL|macro|dprintk
macro_line|# define dprintk(format...)&t;printk(format)
DECL|macro|inline
macro_line|# define inline
macro_line|#else
DECL|macro|debug
macro_line|# define debug(level,format...)
DECL|macro|dprintk
macro_line|# define dprintk(format...)
macro_line|#endif
macro_line|#if UNW_STATS
DECL|macro|STAT
macro_line|# define STAT(x...)&t;x
macro_line|#else
DECL|macro|STAT
macro_line|# define STAT(x...)
macro_line|#endif
DECL|macro|alloc_reg_state
mdefine_line|#define alloc_reg_state()&t;kmalloc(sizeof(struct unw_state_record), GFP_ATOMIC)
DECL|macro|free_reg_state
mdefine_line|#define free_reg_state(usr)&t;kfree(usr)
DECL|typedef|unw_word
r_typedef
r_int
r_int
id|unw_word
suffix:semicolon
DECL|typedef|unw_hash_index_t
r_typedef
r_int
r_char
id|unw_hash_index_t
suffix:semicolon
DECL|macro|struct_offset
mdefine_line|#define struct_offset(str,fld)&t;((char *)&amp;((str *)NULL)-&gt;fld - (char *) 0)
r_static
r_struct
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* spinlock for unwind data */
multiline_comment|/* list of unwind tables (one per load-module) */
DECL|member|tables
r_struct
id|unw_table
op_star
id|tables
suffix:semicolon
multiline_comment|/* table of registers that prologues can save (and order in which they&squot;re saved): */
DECL|member|save_order
r_const
r_int
r_char
id|save_order
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* maps a preserved register index (preg_index) to corresponding switch_stack offset: */
DECL|member|sw_off
r_int
r_int
id|sw_off
(braket
r_sizeof
(paren
r_struct
id|unw_frame_info
)paren
op_div
l_int|8
)braket
suffix:semicolon
DECL|member|lru_head
r_int
r_int
id|lru_head
suffix:semicolon
multiline_comment|/* index of lead-recently used script */
DECL|member|lru_tail
r_int
r_int
id|lru_tail
suffix:semicolon
multiline_comment|/* index of most-recently used script */
multiline_comment|/* index into unw_frame_info for preserved register i */
DECL|member|preg_index
r_int
r_int
id|preg_index
(braket
id|UNW_NUM_REGS
)braket
suffix:semicolon
multiline_comment|/* unwind table for the kernel: */
DECL|member|kernel_table
r_struct
id|unw_table
id|kernel_table
suffix:semicolon
multiline_comment|/* hash table that maps instruction pointer to script index: */
DECL|member|hash
r_int
r_int
id|hash
(braket
id|UNW_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/* script cache: */
DECL|member|cache
r_struct
id|unw_script
id|cache
(braket
id|UNW_CACHE_SIZE
)braket
suffix:semicolon
macro_line|# if UNW_DEBUG
DECL|member|preg_name
r_const
r_char
op_star
id|preg_name
(braket
id|UNW_NUM_REGS
)braket
suffix:semicolon
macro_line|# endif
macro_line|# if UNW_STATS
r_struct
(brace
r_struct
(brace
DECL|member|lookups
r_int
id|lookups
suffix:semicolon
DECL|member|hinted_hits
r_int
id|hinted_hits
suffix:semicolon
DECL|member|normal_hits
r_int
id|normal_hits
suffix:semicolon
DECL|member|collision_chain_traversals
r_int
id|collision_chain_traversals
suffix:semicolon
DECL|member|cache
)brace
id|cache
suffix:semicolon
r_struct
(brace
DECL|member|build_time
r_int
r_int
id|build_time
suffix:semicolon
DECL|member|run_time
r_int
r_int
id|run_time
suffix:semicolon
DECL|member|parse_time
r_int
r_int
id|parse_time
suffix:semicolon
DECL|member|builds
r_int
id|builds
suffix:semicolon
DECL|member|news
r_int
id|news
suffix:semicolon
DECL|member|collisions
r_int
id|collisions
suffix:semicolon
DECL|member|runs
r_int
id|runs
suffix:semicolon
DECL|member|script
)brace
id|script
suffix:semicolon
r_struct
(brace
DECL|member|init_time
r_int
r_int
id|init_time
suffix:semicolon
DECL|member|unwind_time
r_int
r_int
id|unwind_time
suffix:semicolon
DECL|member|inits
r_int
id|inits
suffix:semicolon
DECL|member|unwinds
r_int
id|unwinds
suffix:semicolon
DECL|member|api
)brace
id|api
suffix:semicolon
DECL|member|stat
)brace
id|stat
suffix:semicolon
macro_line|# endif
DECL|variable|unw
)brace
id|unw
op_assign
(brace
id|tables
suffix:colon
op_amp
id|unw.kernel_table
comma
id|lock
suffix:colon
id|SPIN_LOCK_UNLOCKED
comma
id|save_order
suffix:colon
(brace
id|UNW_REG_RP
comma
id|UNW_REG_PFS
comma
id|UNW_REG_PSP
comma
id|UNW_REG_PR
comma
id|UNW_REG_UNAT
comma
id|UNW_REG_LC
comma
id|UNW_REG_FPSR
comma
id|UNW_REG_PRI_UNAT_GR
)brace
comma
id|preg_index
suffix:colon
(brace
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|pri_unat_loc
)paren
op_div
l_int|8
comma
multiline_comment|/* PRI_UNAT_GR */
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|pri_unat_loc
)paren
op_div
l_int|8
comma
multiline_comment|/* PRI_UNAT_MEM */
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|bsp_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|bspstore_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|pfs_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|rnat_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|psp
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|rp_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|r4
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|r5
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|r6
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|r7
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|unat_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|pr_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|lc_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fpsr_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|b1_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|b2_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|b3_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|b4_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|b5_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|f2_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|f3_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|f4_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|f5_loc
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|16
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|17
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|18
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|19
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|20
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|21
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|22
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|23
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|24
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|25
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|26
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|27
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|28
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|29
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|30
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|fr_loc
(braket
l_int|31
op_minus
l_int|16
)braket
)paren
op_div
l_int|8
comma
)brace
comma
id|hash
suffix:colon
(brace
(braket
l_int|0
dot
dot
dot
id|UNW_HASH_SIZE
op_minus
l_int|1
)braket
op_assign
op_minus
l_int|1
)brace
comma
macro_line|#if UNW_DEBUG
id|preg_name
suffix:colon
(brace
l_string|&quot;pri_unat_gr&quot;
comma
l_string|&quot;pri_unat_mem&quot;
comma
l_string|&quot;bsp&quot;
comma
l_string|&quot;bspstore&quot;
comma
l_string|&quot;ar.pfs&quot;
comma
l_string|&quot;ar.rnat&quot;
comma
l_string|&quot;psp&quot;
comma
l_string|&quot;rp&quot;
comma
l_string|&quot;r4&quot;
comma
l_string|&quot;r5&quot;
comma
l_string|&quot;r6&quot;
comma
l_string|&quot;r7&quot;
comma
l_string|&quot;ar.unat&quot;
comma
l_string|&quot;pr&quot;
comma
l_string|&quot;ar.lc&quot;
comma
l_string|&quot;ar.fpsr&quot;
comma
l_string|&quot;b1&quot;
comma
l_string|&quot;b2&quot;
comma
l_string|&quot;b3&quot;
comma
l_string|&quot;b4&quot;
comma
l_string|&quot;b5&quot;
comma
l_string|&quot;f2&quot;
comma
l_string|&quot;f3&quot;
comma
l_string|&quot;f4&quot;
comma
l_string|&quot;f5&quot;
comma
l_string|&quot;f16&quot;
comma
l_string|&quot;f17&quot;
comma
l_string|&quot;f18&quot;
comma
l_string|&quot;f19&quot;
comma
l_string|&quot;f20&quot;
comma
l_string|&quot;f21&quot;
comma
l_string|&quot;f22&quot;
comma
l_string|&quot;f23&quot;
comma
l_string|&quot;f24&quot;
comma
l_string|&quot;f25&quot;
comma
l_string|&quot;f26&quot;
comma
l_string|&quot;f27&quot;
comma
l_string|&quot;f28&quot;
comma
l_string|&quot;f29&quot;
comma
l_string|&quot;f30&quot;
comma
l_string|&quot;f31&quot;
)brace
macro_line|#endif
)brace
suffix:semicolon
"&f;"
multiline_comment|/* Unwind accessors.  */
multiline_comment|/*&n; * Returns offset of rREG in struct pt_regs.&n; */
r_static
r_inline
r_int
r_int
DECL|function|pt_regs_off
id|pt_regs_off
(paren
r_int
r_int
id|reg
)paren
(brace
r_int
r_int
id|off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_ge
l_int|1
op_logical_and
id|reg
op_le
l_int|3
)paren
id|off
op_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|r1
)paren
op_plus
l_int|8
op_star
(paren
id|reg
op_minus
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reg
op_le
l_int|11
)paren
id|off
op_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|r8
)paren
op_plus
l_int|8
op_star
(paren
id|reg
op_minus
l_int|8
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reg
op_le
l_int|15
)paren
id|off
op_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|r12
)paren
op_plus
l_int|8
op_star
(paren
id|reg
op_minus
l_int|12
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reg
op_le
l_int|31
)paren
id|off
op_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|r16
)paren
op_plus
l_int|8
op_star
(paren
id|reg
op_minus
l_int|16
)paren
suffix:semicolon
r_else
id|dprintk
c_func
(paren
l_string|&quot;unwind: bad scratch reg r%lu&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
id|off
suffix:semicolon
)brace
r_int
DECL|function|unw_access_gr
id|unw_access_gr
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_int
id|regnum
comma
r_int
r_int
op_star
id|val
comma
r_char
op_star
id|nat
comma
r_int
id|write
)paren
(brace
r_int
r_int
op_star
id|addr
comma
op_star
id|nat_addr
comma
id|nat_mask
op_assign
l_int|0
comma
id|dummy_nat
suffix:semicolon
r_struct
id|unw_ireg
op_star
id|ireg
suffix:semicolon
r_struct
id|pt_regs
op_star
id|pt
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|regnum
op_minus
l_int|1
op_ge
l_int|127
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: trying to access non-existent r%u&bslash;n&quot;
comma
id|regnum
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|regnum
OL
l_int|32
)paren
(brace
r_if
c_cond
(paren
id|regnum
op_ge
l_int|4
op_logical_and
id|regnum
op_le
l_int|7
)paren
(brace
multiline_comment|/* access a preserved register */
id|ireg
op_assign
op_amp
id|info-&gt;r4
op_plus
(paren
id|regnum
op_minus
l_int|4
)paren
suffix:semicolon
id|addr
op_assign
id|ireg-&gt;loc
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
id|nat_addr
op_assign
id|addr
op_plus
id|ireg-&gt;nat.off
suffix:semicolon
r_switch
c_cond
(paren
id|ireg-&gt;nat.type
)paren
(brace
r_case
id|UNW_NAT_VAL
suffix:colon
multiline_comment|/* simulate getf.sig/setf.sig */
r_if
c_cond
(paren
id|write
)paren
(brace
r_if
c_cond
(paren
op_star
id|nat
)paren
(brace
multiline_comment|/* write NaTVal and be done with it */
id|addr
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|addr
(braket
l_int|1
)braket
op_assign
l_int|0x1fffe
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|addr
(braket
l_int|1
)braket
op_assign
l_int|0x1003e
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|addr
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|addr
(braket
l_int|1
)braket
op_eq
l_int|0x1ffe
)paren
(brace
multiline_comment|/* return NaT and be done with it */
op_star
id|val
op_assign
l_int|0
suffix:semicolon
op_star
id|nat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* fall through */
r_case
id|UNW_NAT_NONE
suffix:colon
id|dummy_nat
op_assign
l_int|0
suffix:semicolon
id|nat_addr
op_assign
op_amp
id|dummy_nat
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_NAT_MEMSTK
suffix:colon
id|nat_mask
op_assign
(paren
l_int|1UL
op_lshift
(paren
(paren
r_int
)paren
id|addr
op_amp
l_int|0x1f8
)paren
op_div
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_NAT_REGSTK
suffix:colon
id|nat_addr
op_assign
id|ia64_rse_rnat_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|addr
OL
id|info-&gt;regstk.limit
op_logical_or
(paren
r_int
r_int
)paren
id|addr
op_ge
id|info-&gt;regstk.top
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: %p outside of regstk &quot;
l_string|&quot;[0x%lx-0x%lx)&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|addr
comma
id|info-&gt;regstk.limit
comma
id|info-&gt;regstk.top
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|nat_addr
op_ge
id|info-&gt;regstk.top
)paren
id|nat_addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_rnat
suffix:semicolon
id|nat_mask
op_assign
(paren
l_int|1UL
op_lshift
id|ia64_rse_slot_num
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;r4
op_plus
(paren
id|regnum
op_minus
l_int|4
)paren
suffix:semicolon
id|nat_addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_unat
suffix:semicolon
id|nat_mask
op_assign
(paren
l_int|1UL
op_lshift
(paren
(paren
r_int
)paren
id|addr
op_amp
l_int|0x1f8
)paren
op_div
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* access a scratch register */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|UNW_FLAG_INTERRUPT_FRAME
)paren
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;psp
op_minus
l_int|1
suffix:semicolon
r_else
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;sp
op_minus
l_int|1
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
)paren
id|pt
op_plus
id|pt_regs_off
c_func
(paren
id|regnum
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pri_unat_loc
)paren
id|nat_addr
op_assign
id|info-&gt;pri_unat_loc
suffix:semicolon
r_else
id|nat_addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_unat
suffix:semicolon
id|nat_mask
op_assign
(paren
l_int|1UL
op_lshift
(paren
(paren
r_int
)paren
id|addr
op_amp
l_int|0x1f8
)paren
op_div
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* access a stacked register */
id|addr
op_assign
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|info-&gt;bsp
comma
id|regnum
)paren
suffix:semicolon
id|nat_addr
op_assign
id|ia64_rse_rnat_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|addr
OL
id|info-&gt;regstk.limit
op_logical_or
(paren
r_int
r_int
)paren
id|addr
op_ge
id|info-&gt;regstk.top
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: ignoring attempt to access register outside of rbs&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|nat_addr
op_ge
id|info-&gt;regstk.top
)paren
id|nat_addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_rnat
suffix:semicolon
id|nat_mask
op_assign
(paren
l_int|1UL
op_lshift
id|ia64_rse_slot_num
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
)paren
(brace
op_star
id|addr
op_assign
op_star
id|val
suffix:semicolon
r_if
c_cond
(paren
op_star
id|nat
)paren
op_star
id|nat_addr
op_or_assign
id|nat_mask
suffix:semicolon
r_else
op_star
id|nat_addr
op_and_assign
op_complement
id|nat_mask
suffix:semicolon
)brace
r_else
(brace
op_star
id|val
op_assign
op_star
id|addr
suffix:semicolon
op_star
id|nat
op_assign
(paren
op_star
id|nat_addr
op_amp
id|nat_mask
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|unw_access_br
id|unw_access_br
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_int
id|regnum
comma
r_int
r_int
op_star
id|val
comma
r_int
id|write
)paren
(brace
r_int
r_int
op_star
id|addr
suffix:semicolon
r_struct
id|pt_regs
op_star
id|pt
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|UNW_FLAG_INTERRUPT_FRAME
)paren
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;psp
op_minus
l_int|1
suffix:semicolon
r_else
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;sp
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|regnum
)paren
(brace
multiline_comment|/* scratch: */
r_case
l_int|0
suffix:colon
id|addr
op_assign
op_amp
id|pt-&gt;b0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|addr
op_assign
op_amp
id|pt-&gt;b6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|addr
op_assign
op_amp
id|pt-&gt;b7
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* preserved: */
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
id|addr
op_assign
op_star
(paren
op_amp
id|info-&gt;b1_loc
op_plus
(paren
id|regnum
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;b1
op_plus
(paren
id|regnum
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;unwind: trying to access non-existent b%u&bslash;n&quot;
comma
id|regnum
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
)paren
op_star
id|addr
op_assign
op_star
id|val
suffix:semicolon
r_else
op_star
id|val
op_assign
op_star
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|unw_access_fr
id|unw_access_fr
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_int
id|regnum
comma
r_struct
id|ia64_fpreg
op_star
id|val
comma
r_int
id|write
)paren
(brace
r_struct
id|ia64_fpreg
op_star
id|addr
op_assign
l_int|0
suffix:semicolon
r_struct
id|pt_regs
op_star
id|pt
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|regnum
op_minus
l_int|2
)paren
op_ge
l_int|126
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: trying to access non-existent f%u&bslash;n&quot;
comma
id|regnum
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|UNW_FLAG_INTERRUPT_FRAME
)paren
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;psp
op_minus
l_int|1
suffix:semicolon
r_else
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;sp
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|regnum
op_le
l_int|5
)paren
(brace
id|addr
op_assign
op_star
(paren
op_amp
id|info-&gt;f2_loc
op_plus
(paren
id|regnum
op_minus
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;f2
op_plus
(paren
id|regnum
op_minus
l_int|2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regnum
op_le
l_int|15
)paren
(brace
r_if
c_cond
(paren
id|regnum
op_le
l_int|9
)paren
id|addr
op_assign
op_amp
id|pt-&gt;f6
op_plus
(paren
id|regnum
op_minus
l_int|6
)paren
suffix:semicolon
r_else
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;f10
op_plus
(paren
id|regnum
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|regnum
op_le
l_int|31
)paren
(brace
id|addr
op_assign
id|info-&gt;fr_loc
(braket
id|regnum
op_minus
l_int|16
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;f16
op_plus
(paren
id|regnum
op_minus
l_int|16
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|task_struct
op_star
id|t
op_assign
id|info-&gt;task
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
id|ia64_sync_fph
c_func
(paren
id|t
)paren
suffix:semicolon
r_else
id|ia64_flush_fph
c_func
(paren
id|t
)paren
suffix:semicolon
id|addr
op_assign
id|t-&gt;thread.fph
op_plus
(paren
id|regnum
op_minus
l_int|32
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
)paren
op_star
id|addr
op_assign
op_star
id|val
suffix:semicolon
r_else
op_star
id|val
op_assign
op_star
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|unw_access_ar
id|unw_access_ar
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_int
id|regnum
comma
r_int
r_int
op_star
id|val
comma
r_int
id|write
)paren
(brace
r_int
r_int
op_star
id|addr
suffix:semicolon
r_struct
id|pt_regs
op_star
id|pt
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|UNW_FLAG_INTERRUPT_FRAME
)paren
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;psp
op_minus
l_int|1
suffix:semicolon
r_else
id|pt
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|info-&gt;sp
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|regnum
)paren
(brace
r_case
id|UNW_AR_BSP
suffix:colon
id|addr
op_assign
id|info-&gt;bsp_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_bspstore
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_BSPSTORE
suffix:colon
id|addr
op_assign
id|info-&gt;bspstore_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_bspstore
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_PFS
suffix:colon
id|addr
op_assign
id|info-&gt;pfs_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_pfs
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_RNAT
suffix:colon
id|addr
op_assign
id|info-&gt;rnat_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_rnat
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_UNAT
suffix:colon
id|addr
op_assign
id|info-&gt;unat_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_unat
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_LC
suffix:colon
id|addr
op_assign
id|info-&gt;lc_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_lc
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_EC
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;cfm_loc
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
op_star
id|info-&gt;cfm_loc
op_assign
(paren
op_star
id|info-&gt;cfm_loc
op_amp
op_complement
(paren
l_int|0x3fUL
op_lshift
l_int|52
)paren
)paren
op_or
(paren
(paren
op_star
id|val
op_amp
l_int|0x3f
)paren
op_lshift
l_int|52
)paren
suffix:semicolon
r_else
op_star
id|val
op_assign
(paren
op_star
id|info-&gt;cfm_loc
op_rshift
l_int|52
)paren
op_amp
l_int|0x3f
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|UNW_AR_FPSR
suffix:colon
id|addr
op_assign
id|info-&gt;fpsr_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;ar_fpsr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_RSC
suffix:colon
id|addr
op_assign
op_amp
id|pt-&gt;ar_rsc
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_AR_CCV
suffix:colon
id|addr
op_assign
op_amp
id|pt-&gt;ar_ccv
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;unwind: trying to access non-existent ar%u&bslash;n&quot;
comma
id|regnum
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
)paren
op_star
id|addr
op_assign
op_star
id|val
suffix:semicolon
r_else
op_star
id|val
op_assign
op_star
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_inline
r_int
DECL|function|unw_access_pr
id|unw_access_pr
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_int
r_int
op_star
id|val
comma
r_int
id|write
)paren
(brace
r_int
r_int
op_star
id|addr
suffix:semicolon
id|addr
op_assign
id|info-&gt;pr_loc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
op_amp
id|info-&gt;sw-&gt;pr
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
op_star
id|addr
op_assign
op_star
id|val
suffix:semicolon
r_else
op_star
id|val
op_assign
op_star
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Unwind decoder routines */
r_static
r_inline
r_void
DECL|function|push
id|push
(paren
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_state
op_star
id|rs
suffix:semicolon
id|rs
op_assign
id|alloc_reg_state
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unwind: cannot stack reg state!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rs
comma
op_amp
id|sr-&gt;curr
comma
r_sizeof
(paren
op_star
id|rs
)paren
)paren
suffix:semicolon
id|rs-&gt;next
op_assign
id|sr-&gt;stack
suffix:semicolon
id|sr-&gt;stack
op_assign
id|rs
suffix:semicolon
)brace
r_static
r_void
DECL|function|pop
id|pop
(paren
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_state
op_star
id|rs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sr-&gt;stack
)paren
(brace
id|printk
(paren
l_string|&quot;unwind: stack underflow!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rs
op_assign
id|sr-&gt;stack
suffix:semicolon
id|sr-&gt;stack
op_assign
id|rs-&gt;next
suffix:semicolon
id|free_reg_state
c_func
(paren
id|rs
)paren
suffix:semicolon
)brace
r_static
r_enum
id|unw_register_index
id|__attribute__
c_func
(paren
(paren
r_const
)paren
)paren
DECL|function|decode_abreg
id|decode_abreg
(paren
r_int
r_char
id|abreg
comma
r_int
id|memory
)paren
(brace
r_switch
c_cond
(paren
id|abreg
)paren
(brace
r_case
l_int|0x04
dot
dot
dot
l_int|0x07
suffix:colon
r_return
id|UNW_REG_R4
op_plus
(paren
id|abreg
op_minus
l_int|0x04
)paren
suffix:semicolon
r_case
l_int|0x22
dot
dot
dot
l_int|0x25
suffix:colon
r_return
id|UNW_REG_F2
op_plus
(paren
id|abreg
op_minus
l_int|0x22
)paren
suffix:semicolon
r_case
l_int|0x30
dot
dot
dot
l_int|0x3f
suffix:colon
r_return
id|UNW_REG_F16
op_plus
(paren
id|abreg
op_minus
l_int|0x30
)paren
suffix:semicolon
r_case
l_int|0x41
dot
dot
dot
l_int|0x45
suffix:colon
r_return
id|UNW_REG_B1
op_plus
(paren
id|abreg
op_minus
l_int|0x41
)paren
suffix:semicolon
r_case
l_int|0x60
suffix:colon
r_return
id|UNW_REG_PR
suffix:semicolon
r_case
l_int|0x61
suffix:colon
r_return
id|UNW_REG_PSP
suffix:semicolon
r_case
l_int|0x62
suffix:colon
r_return
id|memory
ques
c_cond
id|UNW_REG_PRI_UNAT_MEM
suffix:colon
id|UNW_REG_PRI_UNAT_GR
suffix:semicolon
r_case
l_int|0x63
suffix:colon
r_return
id|UNW_REG_RP
suffix:semicolon
r_case
l_int|0x64
suffix:colon
r_return
id|UNW_REG_BSP
suffix:semicolon
r_case
l_int|0x65
suffix:colon
r_return
id|UNW_REG_BSPSTORE
suffix:semicolon
r_case
l_int|0x66
suffix:colon
r_return
id|UNW_REG_RNAT
suffix:semicolon
r_case
l_int|0x67
suffix:colon
r_return
id|UNW_REG_UNAT
suffix:semicolon
r_case
l_int|0x68
suffix:colon
r_return
id|UNW_REG_FPSR
suffix:semicolon
r_case
l_int|0x69
suffix:colon
r_return
id|UNW_REG_PFS
suffix:semicolon
r_case
l_int|0x6a
suffix:colon
r_return
id|UNW_REG_LC
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: bad abreg=0x%x&bslash;n&quot;
comma
id|abreg
)paren
suffix:semicolon
r_return
id|UNW_REG_LC
suffix:semicolon
)brace
r_static
r_void
DECL|function|set_reg
id|set_reg
(paren
r_struct
id|unw_reg_info
op_star
id|reg
comma
r_enum
id|unw_where
id|where
comma
r_int
id|when
comma
r_int
r_int
id|val
)paren
(brace
id|reg-&gt;val
op_assign
id|val
suffix:semicolon
id|reg-&gt;where
op_assign
id|where
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;when
op_eq
id|UNW_WHEN_NEVER
)paren
id|reg-&gt;when
op_assign
id|when
suffix:semicolon
)brace
r_static
r_void
DECL|function|alloc_spill_area
id|alloc_spill_area
(paren
r_int
r_int
op_star
id|offp
comma
r_int
r_int
id|regsize
comma
r_struct
id|unw_reg_info
op_star
id|lo
comma
r_struct
id|unw_reg_info
op_star
id|hi
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
id|hi
suffix:semicolon
id|reg
op_ge
id|lo
suffix:semicolon
op_decrement
id|reg
)paren
(brace
r_if
c_cond
(paren
id|reg-&gt;where
op_eq
id|UNW_WHERE_SPILL_HOME
)paren
(brace
id|reg-&gt;where
op_assign
id|UNW_WHERE_PSPREL
suffix:semicolon
id|reg-&gt;val
op_assign
l_int|0x10
op_minus
op_star
id|offp
suffix:semicolon
op_star
id|offp
op_add_assign
id|regsize
suffix:semicolon
)brace
)brace
)brace
r_static
r_inline
r_void
DECL|function|spill_next_when
id|spill_next_when
(paren
r_struct
id|unw_reg_info
op_star
op_star
id|regp
comma
r_struct
id|unw_reg_info
op_star
id|lim
comma
id|unw_word
id|t
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|reg
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
op_star
id|regp
suffix:semicolon
id|reg
op_le
id|lim
suffix:semicolon
op_increment
id|reg
)paren
(brace
r_if
c_cond
(paren
id|reg-&gt;where
op_eq
id|UNW_WHERE_SPILL_HOME
)paren
(brace
id|reg-&gt;when
op_assign
id|t
suffix:semicolon
op_star
id|regp
op_assign
id|reg
op_plus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: excess spill!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|finish_prologue
id|finish_prologue
(paren
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|reg
suffix:semicolon
r_int
r_int
id|off
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * First, resolve implicit register save locations (see Section &quot;11.4.2.3 Rules&n;&t; * for Using Unwind Descriptors&quot;, rule 3):&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
r_sizeof
(paren
id|unw.save_order
)paren
op_div
r_sizeof
(paren
id|unw.save_order
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|reg
op_assign
id|sr-&gt;curr.reg
op_plus
id|unw.save_order
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;where
op_eq
id|UNW_WHERE_GR_SAVE
)paren
(brace
id|reg-&gt;where
op_assign
id|UNW_WHERE_GR
suffix:semicolon
id|reg-&gt;val
op_assign
id|sr-&gt;gr_save_loc
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Next, compute when the fp, general, and branch registers get&n;&t; * saved.  This must come before alloc_spill_area() because&n;&t; * we need to know which registers are spilled to their home&n;&t; * locations.&n;&t; */
r_if
c_cond
(paren
id|sr-&gt;imask
)paren
(brace
r_int
r_char
id|kind
comma
id|mask
op_assign
l_int|0
comma
op_star
id|cp
op_assign
id|sr-&gt;imask
suffix:semicolon
r_int
r_int
id|t
suffix:semicolon
r_static
r_const
r_int
r_char
id|limit
(braket
l_int|3
)braket
op_assign
(brace
id|UNW_REG_F31
comma
id|UNW_REG_R7
comma
id|UNW_REG_B5
)brace
suffix:semicolon
r_struct
id|unw_reg_info
op_star
(paren
id|regs
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|regs
(braket
l_int|0
)braket
op_assign
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_F2
suffix:semicolon
id|regs
(braket
l_int|1
)braket
op_assign
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_R4
suffix:semicolon
id|regs
(braket
l_int|2
)braket
op_assign
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_B1
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|sr-&gt;region_len
suffix:semicolon
op_increment
id|t
)paren
(brace
r_if
c_cond
(paren
(paren
id|t
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
id|mask
op_assign
op_star
id|cp
op_increment
suffix:semicolon
id|kind
op_assign
(paren
id|mask
op_rshift
l_int|2
op_star
(paren
l_int|3
op_minus
(paren
id|t
op_amp
l_int|3
)paren
)paren
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|kind
OG
l_int|0
)paren
id|spill_next_when
c_func
(paren
op_amp
id|regs
(braket
id|kind
op_minus
l_int|1
)braket
comma
id|sr-&gt;curr.reg
op_plus
id|limit
(braket
id|kind
op_minus
l_int|1
)braket
comma
id|sr-&gt;region_start
op_plus
id|t
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Next, lay out the memory stack spill area:&n;&t; */
r_if
c_cond
(paren
id|sr-&gt;any_spills
)paren
(brace
id|off
op_assign
id|sr-&gt;spill_offset
suffix:semicolon
id|alloc_spill_area
c_func
(paren
op_amp
id|off
comma
l_int|16
comma
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_F2
comma
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_F31
)paren
suffix:semicolon
id|alloc_spill_area
c_func
(paren
op_amp
id|off
comma
l_int|8
comma
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_B1
comma
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_B5
)paren
suffix:semicolon
id|alloc_spill_area
c_func
(paren
op_amp
id|off
comma
l_int|8
comma
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_R4
comma
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_R7
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Region header descriptors.&n; */
r_static
r_void
DECL|function|desc_prologue
id|desc_prologue
(paren
r_int
id|body
comma
id|unw_word
id|rlen
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|grsave
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sr-&gt;in_body
op_logical_or
id|sr-&gt;first_region
)paren
)paren
id|finish_prologue
c_func
(paren
id|sr
)paren
suffix:semicolon
id|sr-&gt;first_region
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check if we&squot;re done: */
r_if
c_cond
(paren
id|body
op_logical_and
id|sr-&gt;when_target
OL
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
)paren
(brace
id|sr-&gt;done
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sr-&gt;epilogue_count
suffix:semicolon
op_increment
id|i
)paren
id|pop
c_func
(paren
id|sr
)paren
suffix:semicolon
id|sr-&gt;epilogue_count
op_assign
l_int|0
suffix:semicolon
id|sr-&gt;epilogue_start
op_assign
id|UNW_WHEN_NEVER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|body
)paren
id|push
c_func
(paren
id|sr
)paren
suffix:semicolon
id|sr-&gt;region_start
op_add_assign
id|sr-&gt;region_len
suffix:semicolon
id|sr-&gt;region_len
op_assign
id|rlen
suffix:semicolon
id|sr-&gt;in_body
op_assign
id|body
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|body
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x8
)paren
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|unw.save_order
(braket
id|i
)braket
comma
id|UNW_WHERE_GR
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
id|grsave
op_increment
)paren
suffix:semicolon
id|mask
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|sr-&gt;gr_save_loc
op_assign
id|grsave
suffix:semicolon
id|sr-&gt;any_spills
op_assign
l_int|0
suffix:semicolon
id|sr-&gt;imask
op_assign
l_int|0
suffix:semicolon
id|sr-&gt;spill_offset
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* default to psp+16 */
)brace
)brace
multiline_comment|/*&n; * Prologue descriptors.&n; */
r_static
r_inline
r_void
DECL|function|desc_abi
id|desc_abi
(paren
r_int
r_char
id|abi
comma
r_int
r_char
id|context
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_if
c_cond
(paren
id|abi
op_eq
l_int|0
op_logical_and
id|context
op_eq
l_char|&squot;i&squot;
)paren
id|sr-&gt;flags
op_or_assign
id|UNW_FLAG_INTERRUPT_FRAME
suffix:semicolon
r_else
id|dprintk
c_func
(paren
l_string|&quot;unwind: ignoring unwabi(abi=0x%x,context=0x%x)&bslash;n&quot;
comma
id|abi
comma
id|context
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_br_gr
id|desc_br_gr
(paren
r_int
r_char
id|brmask
comma
r_int
r_char
id|gr
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|brmask
op_amp
l_int|1
)paren
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_B1
op_plus
id|i
comma
id|UNW_WHERE_GR
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
id|gr
op_increment
)paren
suffix:semicolon
id|brmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|desc_br_mem
id|desc_br_mem
(paren
r_int
r_char
id|brmask
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|brmask
op_amp
l_int|1
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_B1
op_plus
id|i
comma
id|UNW_WHERE_SPILL_HOME
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|sr-&gt;any_spills
op_assign
l_int|1
suffix:semicolon
)brace
id|brmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|desc_frgr_mem
id|desc_frgr_mem
(paren
r_int
r_char
id|grmask
comma
id|unw_word
id|frmask
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|grmask
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_R4
op_plus
id|i
comma
id|UNW_WHERE_SPILL_HOME
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|sr-&gt;any_spills
op_assign
l_int|1
suffix:semicolon
)brace
id|grmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|frmask
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_F2
op_plus
id|i
comma
id|UNW_WHERE_SPILL_HOME
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|sr-&gt;any_spills
op_assign
l_int|1
suffix:semicolon
)brace
id|frmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|desc_fr_mem
id|desc_fr_mem
(paren
r_int
r_char
id|frmask
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|frmask
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_F2
op_plus
id|i
comma
id|UNW_WHERE_SPILL_HOME
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|sr-&gt;any_spills
op_assign
l_int|1
suffix:semicolon
)brace
id|frmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|desc_gr_gr
id|desc_gr_gr
(paren
r_int
r_char
id|grmask
comma
r_int
r_char
id|gr
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|grmask
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_R4
op_plus
id|i
comma
id|UNW_WHERE_GR
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
id|gr
op_increment
)paren
suffix:semicolon
id|grmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|desc_gr_mem
id|desc_gr_mem
(paren
r_int
r_char
id|grmask
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|grmask
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_R4
op_plus
id|i
comma
id|UNW_WHERE_SPILL_HOME
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|sr-&gt;any_spills
op_assign
l_int|1
suffix:semicolon
)brace
id|grmask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|desc_mem_stack_f
id|desc_mem_stack_f
(paren
id|unw_word
id|t
comma
id|unw_word
id|size
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|UNW_REG_PSP
comma
id|UNW_WHERE_NONE
comma
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
comma
l_int|16
op_star
id|size
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_mem_stack_v
id|desc_mem_stack_v
(paren
id|unw_word
id|t
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|sr-&gt;curr.reg
(braket
id|UNW_REG_PSP
)braket
dot
id|when
op_assign
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_reg_gr
id|desc_reg_gr
(paren
r_int
r_char
id|reg
comma
r_int
r_char
id|dst
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|reg
comma
id|UNW_WHERE_GR
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
id|dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_reg_psprel
id|desc_reg_psprel
(paren
r_int
r_char
id|reg
comma
id|unw_word
id|pspoff
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|reg
comma
id|UNW_WHERE_PSPREL
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
l_int|0x10
op_minus
l_int|4
op_star
id|pspoff
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_reg_sprel
id|desc_reg_sprel
(paren
r_int
r_char
id|reg
comma
id|unw_word
id|spoff
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|set_reg
c_func
(paren
id|sr-&gt;curr.reg
op_plus
id|reg
comma
id|UNW_WHERE_SPREL
comma
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
comma
l_int|4
op_star
id|spoff
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_rp_br
id|desc_rp_br
(paren
r_int
r_char
id|dst
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|sr-&gt;return_link_reg
op_assign
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_reg_when
id|desc_reg_when
(paren
r_int
r_char
id|regnum
comma
id|unw_word
id|t
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|reg
op_assign
id|sr-&gt;curr.reg
op_plus
id|regnum
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;where
op_eq
id|UNW_WHERE_NONE
)paren
id|reg-&gt;where
op_assign
id|UNW_WHERE_GR_SAVE
suffix:semicolon
id|reg-&gt;when
op_assign
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_spill_base
id|desc_spill_base
(paren
id|unw_word
id|pspoff
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|sr-&gt;spill_offset
op_assign
l_int|0x10
op_minus
l_int|4
op_star
id|pspoff
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
op_star
DECL|function|desc_spill_mask
id|desc_spill_mask
(paren
r_int
r_char
op_star
id|imaskp
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|sr-&gt;imask
op_assign
id|imaskp
suffix:semicolon
r_return
id|imaskp
op_plus
(paren
l_int|2
op_star
id|sr-&gt;region_len
op_plus
l_int|7
)paren
op_div
l_int|8
suffix:semicolon
)brace
multiline_comment|/*&n; * Body descriptors.&n; */
r_static
r_inline
r_void
DECL|function|desc_epilogue
id|desc_epilogue
(paren
id|unw_word
id|t
comma
id|unw_word
id|ecount
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|sr-&gt;epilogue_start
op_assign
id|sr-&gt;region_start
op_plus
id|sr-&gt;region_len
op_minus
l_int|1
op_minus
id|t
suffix:semicolon
id|sr-&gt;epilogue_count
op_assign
id|ecount
op_plus
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_copy_state
id|desc_copy_state
(paren
id|unw_word
id|label
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_state
op_star
id|rs
suffix:semicolon
r_for
c_loop
(paren
id|rs
op_assign
id|sr-&gt;reg_state_list
suffix:semicolon
id|rs
suffix:semicolon
id|rs
op_assign
id|rs-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|rs-&gt;label
op_eq
id|label
)paren
(brace
id|memcpy
(paren
op_amp
id|sr-&gt;curr
comma
id|rs
comma
r_sizeof
(paren
id|sr-&gt;curr
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;unwind: failed to find state labelled 0x%lx&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_label_state
id|desc_label_state
(paren
id|unw_word
id|label
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_state
op_star
id|rs
suffix:semicolon
id|rs
op_assign
id|alloc_reg_state
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|rs
comma
op_amp
id|sr-&gt;curr
comma
r_sizeof
(paren
op_star
id|rs
)paren
)paren
suffix:semicolon
id|rs-&gt;label
op_assign
id|label
suffix:semicolon
id|rs-&gt;next
op_assign
id|sr-&gt;reg_state_list
suffix:semicolon
id|sr-&gt;reg_state_list
op_assign
id|rs
suffix:semicolon
)brace
multiline_comment|/*&n; * General descriptors.&n; */
r_static
r_inline
r_int
DECL|function|desc_is_active
id|desc_is_active
(paren
r_int
r_char
id|qp
comma
id|unw_word
id|t
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_if
c_cond
(paren
id|sr-&gt;when_target
op_le
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|qp
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|sr-&gt;pr_val
op_amp
(paren
l_int|1UL
op_lshift
id|qp
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|sr-&gt;pr_mask
op_or_assign
(paren
l_int|1UL
op_lshift
id|qp
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_restore_p
id|desc_restore_p
(paren
r_int
r_char
id|qp
comma
id|unw_word
id|t
comma
r_int
r_char
id|abreg
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc_is_active
c_func
(paren
id|qp
comma
id|t
comma
id|sr
)paren
)paren
r_return
suffix:semicolon
id|r
op_assign
id|sr-&gt;curr.reg
op_plus
id|decode_abreg
c_func
(paren
id|abreg
comma
l_int|0
)paren
suffix:semicolon
id|r-&gt;where
op_assign
id|UNW_WHERE_NONE
suffix:semicolon
id|r-&gt;when
op_assign
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
suffix:semicolon
id|r-&gt;val
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_spill_reg_p
id|desc_spill_reg_p
(paren
r_int
r_char
id|qp
comma
id|unw_word
id|t
comma
r_int
r_char
id|abreg
comma
r_int
r_char
id|x
comma
r_int
r_char
id|ytreg
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_enum
id|unw_where
id|where
op_assign
id|UNW_WHERE_GR
suffix:semicolon
r_struct
id|unw_reg_info
op_star
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc_is_active
c_func
(paren
id|qp
comma
id|t
comma
id|sr
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|x
)paren
id|where
op_assign
id|UNW_WHERE_BR
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ytreg
op_amp
l_int|0x80
)paren
id|where
op_assign
id|UNW_WHERE_FR
suffix:semicolon
id|r
op_assign
id|sr-&gt;curr.reg
op_plus
id|decode_abreg
c_func
(paren
id|abreg
comma
l_int|0
)paren
suffix:semicolon
id|r-&gt;where
op_assign
id|where
suffix:semicolon
id|r-&gt;when
op_assign
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
suffix:semicolon
id|r-&gt;val
op_assign
(paren
id|ytreg
op_amp
l_int|0x7f
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_spill_psprel_p
id|desc_spill_psprel_p
(paren
r_int
r_char
id|qp
comma
id|unw_word
id|t
comma
r_int
r_char
id|abreg
comma
id|unw_word
id|pspoff
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc_is_active
c_func
(paren
id|qp
comma
id|t
comma
id|sr
)paren
)paren
r_return
suffix:semicolon
id|r
op_assign
id|sr-&gt;curr.reg
op_plus
id|decode_abreg
c_func
(paren
id|abreg
comma
l_int|1
)paren
suffix:semicolon
id|r-&gt;where
op_assign
id|UNW_WHERE_PSPREL
suffix:semicolon
id|r-&gt;when
op_assign
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
suffix:semicolon
id|r-&gt;val
op_assign
l_int|0x10
op_minus
l_int|4
op_star
id|pspoff
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|desc_spill_sprel_p
id|desc_spill_sprel_p
(paren
r_int
r_char
id|qp
comma
id|unw_word
id|t
comma
r_int
r_char
id|abreg
comma
id|unw_word
id|spoff
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc_is_active
c_func
(paren
id|qp
comma
id|t
comma
id|sr
)paren
)paren
r_return
suffix:semicolon
id|r
op_assign
id|sr-&gt;curr.reg
op_plus
id|decode_abreg
c_func
(paren
id|abreg
comma
l_int|1
)paren
suffix:semicolon
id|r-&gt;where
op_assign
id|UNW_WHERE_SPREL
suffix:semicolon
id|r-&gt;when
op_assign
id|sr-&gt;region_start
op_plus
id|MIN
c_func
(paren
(paren
r_int
)paren
id|t
comma
id|sr-&gt;region_len
op_minus
l_int|1
)paren
suffix:semicolon
id|r-&gt;val
op_assign
l_int|4
op_star
id|spoff
suffix:semicolon
)brace
DECL|macro|UNW_DEC_BAD_CODE
mdefine_line|#define UNW_DEC_BAD_CODE(code)&t;&t;&t;printk(&quot;unwind: unknown code 0x%02x&bslash;n&quot;, code);
multiline_comment|/*&n; * region headers:&n; */
DECL|macro|UNW_DEC_PROLOGUE_GR
mdefine_line|#define UNW_DEC_PROLOGUE_GR(fmt,r,m,gr,arg)&t;desc_prologue(0,r,m,gr,arg)
DECL|macro|UNW_DEC_PROLOGUE
mdefine_line|#define UNW_DEC_PROLOGUE(fmt,b,r,arg)&t;&t;desc_prologue(b,r,0,32,arg)
multiline_comment|/*&n; * prologue descriptors:&n; */
DECL|macro|UNW_DEC_ABI
mdefine_line|#define UNW_DEC_ABI(fmt,a,c,arg)&t;&t;desc_abi(a,c,arg)
DECL|macro|UNW_DEC_BR_GR
mdefine_line|#define UNW_DEC_BR_GR(fmt,b,g,arg)&t;&t;desc_br_gr(b,g,arg)
DECL|macro|UNW_DEC_BR_MEM
mdefine_line|#define UNW_DEC_BR_MEM(fmt,b,arg)&t;&t;desc_br_mem(b,arg)
DECL|macro|UNW_DEC_FRGR_MEM
mdefine_line|#define UNW_DEC_FRGR_MEM(fmt,g,f,arg)&t;&t;desc_frgr_mem(g,f,arg)
DECL|macro|UNW_DEC_FR_MEM
mdefine_line|#define UNW_DEC_FR_MEM(fmt,f,arg)&t;&t;desc_fr_mem(f,arg)
DECL|macro|UNW_DEC_GR_GR
mdefine_line|#define UNW_DEC_GR_GR(fmt,m,g,arg)&t;&t;desc_gr_gr(m,g,arg)
DECL|macro|UNW_DEC_GR_MEM
mdefine_line|#define UNW_DEC_GR_MEM(fmt,m,arg)&t;&t;desc_gr_mem(m,arg)
DECL|macro|UNW_DEC_MEM_STACK_F
mdefine_line|#define UNW_DEC_MEM_STACK_F(fmt,t,s,arg)&t;desc_mem_stack_f(t,s,arg)
DECL|macro|UNW_DEC_MEM_STACK_V
mdefine_line|#define UNW_DEC_MEM_STACK_V(fmt,t,arg)&t;&t;desc_mem_stack_v(t,arg)
DECL|macro|UNW_DEC_REG_GR
mdefine_line|#define UNW_DEC_REG_GR(fmt,r,d,arg)&t;&t;desc_reg_gr(r,d,arg)
DECL|macro|UNW_DEC_REG_PSPREL
mdefine_line|#define UNW_DEC_REG_PSPREL(fmt,r,o,arg)&t;&t;desc_reg_psprel(r,o,arg)
DECL|macro|UNW_DEC_REG_SPREL
mdefine_line|#define UNW_DEC_REG_SPREL(fmt,r,o,arg)&t;&t;desc_reg_sprel(r,o,arg)
DECL|macro|UNW_DEC_REG_WHEN
mdefine_line|#define UNW_DEC_REG_WHEN(fmt,r,t,arg)&t;&t;desc_reg_when(r,t,arg)
DECL|macro|UNW_DEC_PRIUNAT_WHEN_GR
mdefine_line|#define UNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg)&t;desc_reg_when(UNW_REG_PRI_UNAT_GR,t,arg)
DECL|macro|UNW_DEC_PRIUNAT_WHEN_MEM
mdefine_line|#define UNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg)&t;desc_reg_when(UNW_REG_PRI_UNAT_MEM,t,arg)
DECL|macro|UNW_DEC_PRIUNAT_GR
mdefine_line|#define UNW_DEC_PRIUNAT_GR(fmt,r,arg)&t;&t;desc_reg_gr(UNW_REG_PRI_UNAT_GR,r,arg)
DECL|macro|UNW_DEC_PRIUNAT_PSPREL
mdefine_line|#define UNW_DEC_PRIUNAT_PSPREL(fmt,o,arg)&t;desc_reg_psprel(UNW_REG_PRI_UNAT_MEM,o,arg)
DECL|macro|UNW_DEC_PRIUNAT_SPREL
mdefine_line|#define UNW_DEC_PRIUNAT_SPREL(fmt,o,arg)&t;desc_reg_sprel(UNW_REG_PRI_UNAT_MEM,o,arg)
DECL|macro|UNW_DEC_RP_BR
mdefine_line|#define UNW_DEC_RP_BR(fmt,d,arg)&t;&t;desc_rp_br(d,arg)
DECL|macro|UNW_DEC_SPILL_BASE
mdefine_line|#define UNW_DEC_SPILL_BASE(fmt,o,arg)&t;&t;desc_spill_base(o,arg)
DECL|macro|UNW_DEC_SPILL_MASK
mdefine_line|#define UNW_DEC_SPILL_MASK(fmt,m,arg)&t;&t;(m = desc_spill_mask(m,arg))
multiline_comment|/*&n; * body descriptors:&n; */
DECL|macro|UNW_DEC_EPILOGUE
mdefine_line|#define UNW_DEC_EPILOGUE(fmt,t,c,arg)&t;&t;desc_epilogue(t,c,arg)
DECL|macro|UNW_DEC_COPY_STATE
mdefine_line|#define UNW_DEC_COPY_STATE(fmt,l,arg)&t;&t;desc_copy_state(l,arg)
DECL|macro|UNW_DEC_LABEL_STATE
mdefine_line|#define UNW_DEC_LABEL_STATE(fmt,l,arg)&t;&t;desc_label_state(l,arg)
multiline_comment|/*&n; * general unwind descriptors:&n; */
DECL|macro|UNW_DEC_SPILL_REG_P
mdefine_line|#define UNW_DEC_SPILL_REG_P(f,p,t,a,x,y,arg)&t;desc_spill_reg_p(p,t,a,x,y,arg)
DECL|macro|UNW_DEC_SPILL_REG
mdefine_line|#define UNW_DEC_SPILL_REG(f,t,a,x,y,arg)&t;desc_spill_reg_p(0,t,a,x,y,arg)
DECL|macro|UNW_DEC_SPILL_PSPREL_P
mdefine_line|#define UNW_DEC_SPILL_PSPREL_P(f,p,t,a,o,arg)&t;desc_spill_psprel_p(p,t,a,o,arg)
DECL|macro|UNW_DEC_SPILL_PSPREL
mdefine_line|#define UNW_DEC_SPILL_PSPREL(f,t,a,o,arg)&t;desc_spill_psprel_p(0,t,a,o,arg)
DECL|macro|UNW_DEC_SPILL_SPREL_P
mdefine_line|#define UNW_DEC_SPILL_SPREL_P(f,p,t,a,o,arg)&t;desc_spill_sprel_p(p,t,a,o,arg)
DECL|macro|UNW_DEC_SPILL_SPREL
mdefine_line|#define UNW_DEC_SPILL_SPREL(f,t,a,o,arg)&t;desc_spill_sprel_p(0,t,a,o,arg)
DECL|macro|UNW_DEC_RESTORE_P
mdefine_line|#define UNW_DEC_RESTORE_P(f,p,t,a,arg)&t;&t;desc_restore_p(p,t,a,arg)
DECL|macro|UNW_DEC_RESTORE
mdefine_line|#define UNW_DEC_RESTORE(f,t,a,arg)&t;&t;desc_restore_p(0,t,a,arg)
macro_line|#include &quot;unwind_decoder.c&quot;
"&f;"
multiline_comment|/* Unwind scripts. */
r_static
r_inline
id|unw_hash_index_t
DECL|function|hash
id|hash
(paren
r_int
r_int
id|ip
)paren
(brace
DECL|macro|magic
macro_line|#&t;define magic&t;0x9e3779b97f4a7c16&t;/* based on (sqrt(5)/2-1)*2^64 */
r_return
(paren
id|ip
op_rshift
l_int|4
)paren
op_star
id|magic
op_rshift
(paren
l_int|64
op_minus
id|UNW_LOG_HASH_SIZE
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|cache_match
id|cache_match
(paren
r_struct
id|unw_script
op_star
id|script
comma
r_int
r_int
id|ip
comma
r_int
r_int
id|pr
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|script-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
id|script-&gt;ip
op_logical_and
(paren
(paren
id|pr
op_xor
id|script-&gt;pr_val
)paren
op_amp
id|script-&gt;pr_mask
)paren
op_eq
l_int|0
)paren
multiline_comment|/* keep the read lock... */
r_return
l_int|1
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|script-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|unw_script
op_star
DECL|function|script_lookup
id|script_lookup
(paren
r_struct
id|unw_frame_info
op_star
id|info
)paren
(brace
r_struct
id|unw_script
op_star
id|script
op_assign
id|unw.cache
op_plus
id|info-&gt;hint
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_int
r_int
id|ip
comma
id|pr
suffix:semicolon
id|STAT
c_func
(paren
op_increment
id|unw.stat.cache.lookups
)paren
suffix:semicolon
id|ip
op_assign
id|info-&gt;ip
suffix:semicolon
id|pr
op_assign
id|info-&gt;pr
suffix:semicolon
r_if
c_cond
(paren
id|cache_match
c_func
(paren
id|script
comma
id|ip
comma
id|pr
)paren
)paren
(brace
id|STAT
c_func
(paren
op_increment
id|unw.stat.cache.hinted_hits
)paren
suffix:semicolon
r_return
id|script
suffix:semicolon
)brace
id|index
op_assign
id|unw.hash
(braket
id|hash
c_func
(paren
id|ip
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|UNW_CACHE_SIZE
)paren
r_return
l_int|0
suffix:semicolon
id|script
op_assign
id|unw.cache
op_plus
id|index
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|cache_match
c_func
(paren
id|script
comma
id|ip
comma
id|pr
)paren
)paren
(brace
multiline_comment|/* update hint; no locking required as single-word writes are atomic */
id|STAT
c_func
(paren
op_increment
id|unw.stat.cache.normal_hits
)paren
suffix:semicolon
id|unw.cache
(braket
id|info-&gt;prev_script
)braket
dot
id|hint
op_assign
id|script
op_minus
id|unw.cache
suffix:semicolon
r_return
id|script
suffix:semicolon
)brace
r_if
c_cond
(paren
id|script-&gt;coll_chain
op_ge
id|UNW_HASH_SIZE
)paren
r_return
l_int|0
suffix:semicolon
id|script
op_assign
id|unw.cache
op_plus
id|script-&gt;coll_chain
suffix:semicolon
id|STAT
c_func
(paren
op_increment
id|unw.stat.cache.collision_chain_traversals
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * On returning, a write lock for the SCRIPT is still being held.&n; */
r_static
r_inline
r_struct
id|unw_script
op_star
DECL|function|script_new
id|script_new
(paren
r_int
r_int
id|ip
)paren
(brace
r_struct
id|unw_script
op_star
id|script
comma
op_star
id|prev
comma
op_star
id|tmp
suffix:semicolon
id|unw_hash_index_t
id|index
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|head
suffix:semicolon
id|STAT
c_func
(paren
op_increment
id|unw.stat.script.news
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Can&squot;t (easily) use cmpxchg() here because of ABA problem&n;&t; * that is intrinsic in cmpxchg()...&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|unw.lock
comma
id|flags
)paren
suffix:semicolon
(brace
id|head
op_assign
id|unw.lru_head
suffix:semicolon
id|script
op_assign
id|unw.cache
op_plus
id|head
suffix:semicolon
id|unw.lru_head
op_assign
id|script-&gt;lru_chain
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|unw.lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX We&squot;ll deadlock here if we interrupt a thread that is&n;&t; * holding a read lock on script-&gt;lock.  A try_write_lock()&n;&t; * might be mighty handy here...  Alternatively, we could&n;&t; * disable interrupts whenever we hold a read-lock, but that&n;&t; * seems silly.&n;&t; */
id|write_lock
c_func
(paren
op_amp
id|script-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|unw.lock
)paren
suffix:semicolon
(brace
multiline_comment|/* re-insert script at the tail of the LRU chain: */
id|unw.cache
(braket
id|unw.lru_tail
)braket
dot
id|lru_chain
op_assign
id|head
suffix:semicolon
id|unw.lru_tail
op_assign
id|head
suffix:semicolon
multiline_comment|/* remove the old script from the hash table (if it&squot;s there): */
r_if
c_cond
(paren
id|script-&gt;ip
)paren
(brace
id|index
op_assign
id|hash
c_func
(paren
id|script-&gt;ip
)paren
suffix:semicolon
id|tmp
op_assign
id|unw.cache
op_plus
id|unw.hash
(braket
id|index
)braket
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|tmp
op_eq
id|script
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;coll_chain
op_assign
id|tmp-&gt;coll_chain
suffix:semicolon
r_else
id|unw.hash
(braket
id|index
)braket
op_assign
id|tmp-&gt;coll_chain
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|prev
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;coll_chain
op_ge
id|UNW_CACHE_SIZE
)paren
multiline_comment|/* old script wasn&squot;t in the hash-table */
r_break
suffix:semicolon
id|tmp
op_assign
id|unw.cache
op_plus
id|tmp-&gt;coll_chain
suffix:semicolon
)brace
)brace
multiline_comment|/* enter new script in the hash table */
id|index
op_assign
id|hash
c_func
(paren
id|ip
)paren
suffix:semicolon
id|script-&gt;coll_chain
op_assign
id|unw.hash
(braket
id|index
)braket
suffix:semicolon
id|unw.hash
(braket
id|index
)braket
op_assign
id|script
op_minus
id|unw.cache
suffix:semicolon
id|script-&gt;ip
op_assign
id|ip
suffix:semicolon
multiline_comment|/* set new IP while we&squot;re holding the locks */
id|STAT
c_func
(paren
r_if
(paren
id|script-&gt;coll_chain
OL
id|UNW_CACHE_SIZE
)paren
op_increment
id|unw.stat.script.collisions
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|unw.lock
comma
id|flags
)paren
suffix:semicolon
id|script-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|script-&gt;hint
op_assign
l_int|0
suffix:semicolon
id|script-&gt;count
op_assign
l_int|0
suffix:semicolon
r_return
id|script
suffix:semicolon
)brace
r_static
r_void
DECL|function|script_finalize
id|script_finalize
(paren
r_struct
id|unw_script
op_star
id|script
comma
r_struct
id|unw_state_record
op_star
id|sr
)paren
(brace
id|script-&gt;pr_mask
op_assign
id|sr-&gt;pr_mask
suffix:semicolon
id|script-&gt;pr_val
op_assign
id|sr-&gt;pr_val
suffix:semicolon
multiline_comment|/*&n;&t; * We could down-grade our write-lock on script-&gt;lock here but&n;&t; * the rwlock API doesn&squot;t offer atomic lock downgrading, so&n;&t; * we&squot;ll just keep the write-lock and release it later when&n;&t; * we&squot;re done using the script.&n;&t; */
)brace
r_static
r_inline
r_void
DECL|function|script_emit
id|script_emit
(paren
r_struct
id|unw_script
op_star
id|script
comma
r_struct
id|unw_insn
id|insn
)paren
(brace
r_if
c_cond
(paren
id|script-&gt;count
op_ge
id|UNW_MAX_SCRIPT_LEN
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: script exceeds maximum size of %u instructions!&bslash;n&quot;
comma
id|UNW_MAX_SCRIPT_LEN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|script-&gt;insn
(braket
id|script-&gt;count
op_increment
)braket
op_assign
id|insn
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|emit_nat_info
id|emit_nat_info
(paren
r_struct
id|unw_state_record
op_star
id|sr
comma
r_int
id|i
comma
r_struct
id|unw_script
op_star
id|script
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|r
op_assign
id|sr-&gt;curr.reg
op_plus
id|i
suffix:semicolon
r_enum
id|unw_insn_opcode
id|opc
suffix:semicolon
r_struct
id|unw_insn
id|insn
suffix:semicolon
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|r-&gt;where
)paren
(brace
r_case
id|UNW_WHERE_GR
suffix:colon
r_if
c_cond
(paren
id|r-&gt;val
op_ge
l_int|32
)paren
(brace
multiline_comment|/* register got spilled to a stacked register */
id|opc
op_assign
id|UNW_INSN_SETNAT_TYPE
suffix:semicolon
id|val
op_assign
id|UNW_NAT_REGSTK
suffix:semicolon
)brace
r_else
multiline_comment|/* register got spilled to a scratch register */
id|opc
op_assign
id|UNW_INSN_SETNAT_MEMSTK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_FR
suffix:colon
id|opc
op_assign
id|UNW_INSN_SETNAT_TYPE
suffix:semicolon
id|val
op_assign
id|UNW_NAT_VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_BR
suffix:colon
id|opc
op_assign
id|UNW_INSN_SETNAT_TYPE
suffix:semicolon
id|val
op_assign
id|UNW_NAT_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_PSPREL
suffix:colon
r_case
id|UNW_WHERE_SPREL
suffix:colon
id|opc
op_assign
id|UNW_INSN_SETNAT_MEMSTK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;unwind: don&squot;t know how to emit nat info for where = %u&bslash;n&quot;
comma
id|r-&gt;where
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|insn.opc
op_assign
id|opc
suffix:semicolon
id|insn.dst
op_assign
id|unw.preg_index
(braket
id|i
)braket
suffix:semicolon
id|insn.val
op_assign
id|val
suffix:semicolon
id|script_emit
c_func
(paren
id|script
comma
id|insn
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|compile_reg
id|compile_reg
(paren
r_struct
id|unw_state_record
op_star
id|sr
comma
r_int
id|i
comma
r_struct
id|unw_script
op_star
id|script
)paren
(brace
r_struct
id|unw_reg_info
op_star
id|r
op_assign
id|sr-&gt;curr.reg
op_plus
id|i
suffix:semicolon
r_enum
id|unw_insn_opcode
id|opc
suffix:semicolon
r_int
r_int
id|val
comma
id|rval
suffix:semicolon
r_struct
id|unw_insn
id|insn
suffix:semicolon
r_int
id|need_nat_info
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;where
op_eq
id|UNW_WHERE_NONE
op_logical_or
id|r-&gt;when
op_ge
id|sr-&gt;when_target
)paren
r_return
suffix:semicolon
id|opc
op_assign
id|UNW_INSN_MOVE
suffix:semicolon
id|val
op_assign
id|rval
op_assign
id|r-&gt;val
suffix:semicolon
id|need_nat_info
op_assign
(paren
id|i
op_ge
id|UNW_REG_R4
op_logical_and
id|i
op_le
id|UNW_REG_R7
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|r-&gt;where
)paren
(brace
r_case
id|UNW_WHERE_GR
suffix:colon
r_if
c_cond
(paren
id|rval
op_ge
l_int|32
)paren
(brace
id|opc
op_assign
id|UNW_INSN_MOVE_STACKED
suffix:semicolon
id|val
op_assign
id|rval
op_minus
l_int|32
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rval
op_ge
l_int|4
op_logical_and
id|rval
op_le
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|need_nat_info
)paren
(brace
id|opc
op_assign
id|UNW_INSN_MOVE2
suffix:semicolon
id|need_nat_info
op_assign
l_int|0
suffix:semicolon
)brace
id|val
op_assign
id|unw.preg_index
(braket
id|UNW_REG_R4
op_plus
(paren
id|rval
op_minus
l_int|4
)paren
)braket
suffix:semicolon
)brace
r_else
(brace
id|opc
op_assign
id|UNW_INSN_ADD_SP
suffix:semicolon
id|val
op_assign
op_minus
r_sizeof
(paren
r_struct
id|pt_regs
)paren
op_plus
id|pt_regs_off
c_func
(paren
id|rval
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UNW_WHERE_FR
suffix:colon
r_if
c_cond
(paren
id|rval
op_le
l_int|5
)paren
id|val
op_assign
id|unw.preg_index
(braket
id|UNW_REG_F2
op_plus
(paren
id|rval
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rval
op_ge
l_int|16
op_logical_and
id|rval
op_le
l_int|31
)paren
id|val
op_assign
id|unw.preg_index
(braket
id|UNW_REG_F16
op_plus
(paren
id|rval
op_minus
l_int|16
)paren
)braket
suffix:semicolon
r_else
(brace
id|opc
op_assign
id|UNW_INSN_ADD_SP
suffix:semicolon
id|val
op_assign
op_minus
r_sizeof
(paren
r_struct
id|pt_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_le
l_int|9
)paren
id|val
op_add_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|f6
)paren
op_plus
l_int|16
op_star
(paren
id|rval
op_minus
l_int|6
)paren
suffix:semicolon
r_else
id|dprintk
c_func
(paren
l_string|&quot;unwind: kernel may not touch f%lu&bslash;n&quot;
comma
id|rval
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UNW_WHERE_BR
suffix:colon
r_if
c_cond
(paren
id|rval
op_ge
l_int|1
op_logical_and
id|rval
op_le
l_int|5
)paren
id|val
op_assign
id|unw.preg_index
(braket
id|UNW_REG_B1
op_plus
(paren
id|rval
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_else
(brace
id|opc
op_assign
id|UNW_INSN_ADD_SP
suffix:semicolon
id|val
op_assign
op_minus
r_sizeof
(paren
r_struct
id|pt_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_eq
l_int|0
)paren
id|val
op_add_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|b0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rval
op_eq
l_int|6
)paren
id|val
op_add_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|b6
)paren
suffix:semicolon
r_else
id|val
op_add_assign
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|b7
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UNW_WHERE_SPREL
suffix:colon
id|opc
op_assign
id|UNW_INSN_ADD_SP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_PSPREL
suffix:colon
id|opc
op_assign
id|UNW_INSN_ADD_PSP
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;unwind: register %u has unexpected `where&squot; value of %u&bslash;n&quot;
comma
id|i
comma
id|r-&gt;where
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|insn.opc
op_assign
id|opc
suffix:semicolon
id|insn.dst
op_assign
id|unw.preg_index
(braket
id|i
)braket
suffix:semicolon
id|insn.val
op_assign
id|val
suffix:semicolon
id|script_emit
c_func
(paren
id|script
comma
id|insn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_nat_info
)paren
id|emit_nat_info
c_func
(paren
id|sr
comma
id|i
comma
id|script
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|UNW_REG_PSP
)paren
(brace
multiline_comment|/*&n;&t;&t; * info-&gt;psp must contain the _value_ of the previous&n;&t;&t; * sp, not it&squot;s save location.  We get this by&n;&t;&t; * dereferencing the value we just stored in&n;&t;&t; * info-&gt;psp:&n;&t;&t; */
id|insn.opc
op_assign
id|UNW_INSN_LOAD
suffix:semicolon
id|insn.dst
op_assign
id|insn.val
op_assign
id|unw.preg_index
(braket
id|UNW_REG_PSP
)braket
suffix:semicolon
id|script_emit
c_func
(paren
id|script
comma
id|insn
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_struct
id|unw_table_entry
op_star
DECL|function|lookup
id|lookup
(paren
r_struct
id|unw_table
op_star
id|table
comma
r_int
r_int
id|rel_ip
)paren
(brace
r_struct
id|unw_table_entry
op_star
id|e
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|lo
comma
id|hi
comma
id|mid
suffix:semicolon
multiline_comment|/* do a binary search for right entry: */
r_for
c_loop
(paren
id|lo
op_assign
l_int|0
comma
id|hi
op_assign
id|table-&gt;length
suffix:semicolon
id|lo
OL
id|hi
suffix:semicolon
)paren
(brace
id|mid
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
id|e
op_assign
op_amp
id|table-&gt;array
(braket
id|mid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rel_ip
OL
id|e-&gt;start_offset
)paren
id|hi
op_assign
id|mid
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rel_ip
op_ge
id|e-&gt;end_offset
)paren
id|lo
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_return
id|e
suffix:semicolon
)brace
multiline_comment|/*&n; * Build an unwind script that unwinds from state OLD_STATE to the&n; * entrypoint of the function that called OLD_STATE.&n; */
r_static
r_inline
r_struct
id|unw_script
op_star
DECL|function|build_script
id|build_script
(paren
r_struct
id|unw_frame_info
op_star
id|info
)paren
(brace
r_struct
id|unw_reg_state
op_star
id|rs
comma
op_star
id|next
suffix:semicolon
r_struct
id|unw_table_entry
op_star
id|e
op_assign
l_int|0
suffix:semicolon
r_struct
id|unw_script
op_star
id|script
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|ip
op_assign
id|info-&gt;ip
suffix:semicolon
r_struct
id|unw_state_record
id|sr
suffix:semicolon
r_struct
id|unw_table
op_star
id|table
suffix:semicolon
r_struct
id|unw_reg_info
op_star
id|r
suffix:semicolon
r_struct
id|unw_insn
id|insn
suffix:semicolon
id|u8
op_star
id|dp
comma
op_star
id|desc_end
suffix:semicolon
id|u64
id|hdr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|STAT
c_func
(paren
r_int
r_int
id|start
comma
id|parse_start
suffix:semicolon
)paren
id|STAT
c_func
(paren
op_increment
id|unw.stat.script.builds
suffix:semicolon
id|start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* build state record */
id|memset
c_func
(paren
op_amp
id|sr
comma
l_int|0
comma
r_sizeof
(paren
id|sr
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|sr.curr.reg
suffix:semicolon
id|r
OL
id|sr.curr.reg
op_plus
id|UNW_NUM_REGS
suffix:semicolon
op_increment
id|r
)paren
id|r-&gt;when
op_assign
id|UNW_WHEN_NEVER
suffix:semicolon
id|sr.pr_val
op_assign
id|info-&gt;pr
suffix:semicolon
id|script
op_assign
id|script_new
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|script
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: failed to create unwind script&bslash;n&quot;
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.script.build_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|unw.cache
(braket
id|info-&gt;prev_script
)braket
dot
id|hint
op_assign
id|script
op_minus
id|unw.cache
suffix:semicolon
multiline_comment|/* search the kernels and the modules&squot; unwind tables for IP: */
id|STAT
c_func
(paren
id|parse_start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|table
op_assign
id|unw.tables
suffix:semicolon
id|table
suffix:semicolon
id|table
op_assign
id|table-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ip
op_ge
id|table-&gt;start
op_logical_and
id|ip
OL
id|table-&gt;end
)paren
(brace
id|e
op_assign
id|lookup
c_func
(paren
id|table
comma
id|ip
op_minus
id|table-&gt;segment_base
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
(brace
multiline_comment|/* no info, return default unwinder (leaf proc, no mem stack, no saved regs)  */
id|dprintk
c_func
(paren
l_string|&quot;unwind: no unwind info for ip=0x%lx (prev ip=0x%lx)&bslash;n&quot;
comma
id|ip
comma
id|unw.cache
(braket
id|info-&gt;prev_script
)braket
dot
id|ip
)paren
suffix:semicolon
id|sr.curr.reg
(braket
id|UNW_REG_RP
)braket
dot
id|where
op_assign
id|UNW_WHERE_BR
suffix:semicolon
id|sr.curr.reg
(braket
id|UNW_REG_RP
)braket
dot
id|when
op_assign
op_minus
l_int|1
suffix:semicolon
id|sr.curr.reg
(braket
id|UNW_REG_RP
)braket
dot
id|val
op_assign
l_int|0
suffix:semicolon
id|compile_reg
c_func
(paren
op_amp
id|sr
comma
id|UNW_REG_RP
comma
id|script
)paren
suffix:semicolon
id|script_finalize
c_func
(paren
id|script
comma
op_amp
id|sr
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.script.parse_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|parse_start
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.script.build_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
)paren
suffix:semicolon
r_return
id|script
suffix:semicolon
)brace
id|sr.when_target
op_assign
(paren
l_int|3
op_star
(paren
(paren
id|ip
op_amp
op_complement
l_int|0xfUL
)paren
op_minus
(paren
id|table-&gt;segment_base
op_plus
id|e-&gt;start_offset
)paren
)paren
op_div
l_int|16
op_plus
(paren
id|ip
op_amp
l_int|0xfUL
)paren
)paren
suffix:semicolon
id|hdr
op_assign
op_star
(paren
id|u64
op_star
)paren
(paren
id|table-&gt;segment_base
op_plus
id|e-&gt;info_offset
)paren
suffix:semicolon
id|dp
op_assign
(paren
id|u8
op_star
)paren
(paren
id|table-&gt;segment_base
op_plus
id|e-&gt;info_offset
op_plus
l_int|8
)paren
suffix:semicolon
id|desc_end
op_assign
id|dp
op_plus
l_int|8
op_star
id|UNW_LENGTH
c_func
(paren
id|hdr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|sr.done
op_logical_and
id|dp
OL
id|desc_end
)paren
id|dp
op_assign
id|unw_decode
c_func
(paren
id|dp
comma
id|sr.in_body
comma
op_amp
id|sr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sr.when_target
OG
id|sr.epilogue_start
)paren
(brace
multiline_comment|/*&n;&t;&t; * sp has been restored and all values on the memory stack below&n;&t;&t; * psp also have been restored.&n;&t;&t; */
id|sr.curr.reg
(braket
id|UNW_REG_PSP
)braket
dot
id|where
op_assign
id|UNW_WHERE_NONE
suffix:semicolon
id|sr.curr.reg
(braket
id|UNW_REG_PSP
)braket
dot
id|val
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|sr.curr.reg
suffix:semicolon
id|r
OL
id|sr.curr.reg
op_plus
id|UNW_NUM_REGS
suffix:semicolon
op_increment
id|r
)paren
r_if
c_cond
(paren
(paren
id|r-&gt;where
op_eq
id|UNW_WHERE_PSPREL
op_logical_and
id|r-&gt;val
op_le
l_int|0x10
)paren
op_logical_or
id|r-&gt;where
op_eq
id|UNW_WHERE_SPREL
)paren
id|r-&gt;where
op_assign
id|UNW_WHERE_NONE
suffix:semicolon
)brace
id|script-&gt;flags
op_assign
id|sr.flags
suffix:semicolon
multiline_comment|/*&n;&t; * If RP did&squot;t get saved, generate entry for the return link&n;&t; * register.&n;&t; */
r_if
c_cond
(paren
id|sr.curr.reg
(braket
id|UNW_REG_RP
)braket
dot
id|when
op_ge
id|sr.when_target
)paren
(brace
id|sr.curr.reg
(braket
id|UNW_REG_RP
)braket
dot
id|where
op_assign
id|UNW_WHERE_BR
suffix:semicolon
id|sr.curr.reg
(braket
id|UNW_REG_RP
)braket
dot
id|when
op_assign
op_minus
l_int|1
suffix:semicolon
id|sr.curr.reg
(braket
id|UNW_REG_RP
)braket
dot
id|val
op_assign
id|sr.return_link_reg
suffix:semicolon
)brace
macro_line|#if UNW_DEBUG
id|printk
c_func
(paren
l_string|&quot;unwind: state record for func 0x%lx, t=%u:&bslash;n&quot;
comma
id|table-&gt;segment_base
op_plus
id|e-&gt;start_offset
comma
id|sr.when_target
)paren
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
id|sr.curr.reg
suffix:semicolon
id|r
OL
id|sr.curr.reg
op_plus
id|UNW_NUM_REGS
suffix:semicolon
op_increment
id|r
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;where
op_ne
id|UNW_WHERE_NONE
op_logical_or
id|r-&gt;when
op_ne
id|UNW_WHEN_NEVER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  %s &lt;- &quot;
comma
id|unw.preg_name
(braket
id|r
op_minus
id|sr.curr.reg
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|r-&gt;where
)paren
(brace
r_case
id|UNW_WHERE_GR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;r%lu&quot;
comma
id|r-&gt;val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_FR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;f%lu&quot;
comma
id|r-&gt;val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_BR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;b%lu&quot;
comma
id|r-&gt;val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_SPREL
suffix:colon
id|printk
c_func
(paren
l_string|&quot;[sp+0x%lx]&quot;
comma
id|r-&gt;val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_PSPREL
suffix:colon
id|printk
c_func
(paren
l_string|&quot;[psp+0x%lx]&quot;
comma
id|r-&gt;val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_WHERE_NONE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s+0x%lx&quot;
comma
id|unw.preg_name
(braket
id|r
op_minus
id|sr.curr.reg
)braket
comma
id|r-&gt;val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;BADWHERE(%d)&quot;
comma
id|r-&gt;where
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t&bslash;t%d&bslash;n&quot;
comma
id|r-&gt;when
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|STAT
c_func
(paren
id|unw.stat.script.parse_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|parse_start
)paren
suffix:semicolon
multiline_comment|/* translate state record into unwinder instructions: */
multiline_comment|/*&n;&t; * First, set psp if we&squot;re dealing with a fixed-size frame;&n;&t; * subsequent instructions may depend on this value.&n;&t; */
r_if
c_cond
(paren
id|sr.when_target
OG
id|sr.curr.reg
(braket
id|UNW_REG_PSP
)braket
dot
id|when
op_logical_and
(paren
id|sr.curr.reg
(braket
id|UNW_REG_PSP
)braket
dot
id|where
op_eq
id|UNW_WHERE_NONE
)paren
op_logical_and
id|sr.curr.reg
(braket
id|UNW_REG_PSP
)braket
dot
id|val
op_ne
l_int|0
)paren
(brace
multiline_comment|/* new psp is sp plus frame size */
id|insn.opc
op_assign
id|UNW_INSN_ADD
suffix:semicolon
id|insn.dst
op_assign
id|struct_offset
c_func
(paren
r_struct
id|unw_frame_info
comma
id|psp
)paren
op_div
l_int|8
suffix:semicolon
id|insn.val
op_assign
id|sr.curr.reg
(braket
id|UNW_REG_PSP
)braket
dot
id|val
suffix:semicolon
multiline_comment|/* frame size */
id|script_emit
c_func
(paren
id|script
comma
id|insn
)paren
suffix:semicolon
)brace
multiline_comment|/* determine where the primary UNaT is: */
r_if
c_cond
(paren
id|sr.when_target
OL
id|sr.curr.reg
(braket
id|UNW_REG_PRI_UNAT_GR
)braket
dot
id|when
)paren
id|i
op_assign
id|UNW_REG_PRI_UNAT_MEM
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sr.when_target
OL
id|sr.curr.reg
(braket
id|UNW_REG_PRI_UNAT_MEM
)braket
dot
id|when
)paren
id|i
op_assign
id|UNW_REG_PRI_UNAT_GR
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sr.curr.reg
(braket
id|UNW_REG_PRI_UNAT_MEM
)braket
dot
id|when
OG
id|sr.curr.reg
(braket
id|UNW_REG_PRI_UNAT_GR
)braket
dot
id|when
)paren
id|i
op_assign
id|UNW_REG_PRI_UNAT_MEM
suffix:semicolon
r_else
id|i
op_assign
id|UNW_REG_PRI_UNAT_GR
suffix:semicolon
id|compile_reg
c_func
(paren
op_amp
id|sr
comma
id|i
comma
id|script
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|UNW_REG_BSP
suffix:semicolon
id|i
OL
id|UNW_NUM_REGS
suffix:semicolon
op_increment
id|i
)paren
id|compile_reg
c_func
(paren
op_amp
id|sr
comma
id|i
comma
id|script
)paren
suffix:semicolon
multiline_comment|/* free labelled register states &amp; stack: */
id|STAT
c_func
(paren
id|parse_start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|rs
op_assign
id|sr.reg_state_list
suffix:semicolon
id|rs
suffix:semicolon
id|rs
op_assign
id|next
)paren
(brace
id|next
op_assign
id|rs-&gt;next
suffix:semicolon
id|free_reg_state
c_func
(paren
id|rs
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sr.stack
)paren
id|pop
c_func
(paren
op_amp
id|sr
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.script.parse_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|parse_start
)paren
suffix:semicolon
id|script_finalize
c_func
(paren
id|script
comma
op_amp
id|sr
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.script.build_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
)paren
suffix:semicolon
r_return
id|script
suffix:semicolon
)brace
multiline_comment|/*&n; * Apply the unwinding actions represented by OPS and update SR to&n; * reflect the state that existed upon entry to the function that this&n; * unwinder represents.&n; */
r_static
r_inline
r_void
DECL|function|run_script
id|run_script
(paren
r_struct
id|unw_script
op_star
id|script
comma
r_struct
id|unw_frame_info
op_star
id|state
)paren
(brace
r_struct
id|unw_insn
op_star
id|ip
comma
op_star
id|limit
comma
id|next_insn
suffix:semicolon
r_int
r_int
id|opc
comma
id|dst
comma
id|val
comma
id|off
suffix:semicolon
r_int
r_int
op_star
id|s
op_assign
(paren
r_int
r_int
op_star
)paren
id|state
suffix:semicolon
id|STAT
c_func
(paren
r_int
r_int
id|start
suffix:semicolon
)paren
id|STAT
c_func
(paren
op_increment
id|unw.stat.script.runs
suffix:semicolon
id|start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
)paren
suffix:semicolon
id|state-&gt;flags
op_assign
id|script-&gt;flags
suffix:semicolon
id|ip
op_assign
id|script-&gt;insn
suffix:semicolon
id|limit
op_assign
id|script-&gt;insn
op_plus
id|script-&gt;count
suffix:semicolon
id|next_insn
op_assign
op_star
id|ip
suffix:semicolon
r_while
c_loop
(paren
id|ip
op_increment
OL
id|limit
)paren
(brace
id|opc
op_assign
id|next_insn.opc
suffix:semicolon
id|dst
op_assign
id|next_insn.dst
suffix:semicolon
id|val
op_assign
id|next_insn.val
suffix:semicolon
id|next_insn
op_assign
op_star
id|ip
suffix:semicolon
id|redo
suffix:colon
r_switch
c_cond
(paren
id|opc
)paren
(brace
r_case
id|UNW_INSN_ADD
suffix:colon
id|s
(braket
id|dst
)braket
op_add_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_MOVE2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|s
(braket
id|val
)braket
)paren
r_goto
id|lazy_init
suffix:semicolon
id|s
(braket
id|dst
op_plus
l_int|1
)braket
op_assign
id|s
(braket
id|val
op_plus
l_int|1
)braket
suffix:semicolon
id|s
(braket
id|dst
)braket
op_assign
id|s
(braket
id|val
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_MOVE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|s
(braket
id|val
)braket
)paren
r_goto
id|lazy_init
suffix:semicolon
id|s
(braket
id|dst
)braket
op_assign
id|s
(braket
id|val
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_MOVE_STACKED
suffix:colon
id|s
(braket
id|dst
)braket
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|state-&gt;bsp
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_ADD_PSP
suffix:colon
id|s
(braket
id|dst
)braket
op_assign
id|state-&gt;psp
op_plus
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_ADD_SP
suffix:colon
id|s
(braket
id|dst
)braket
op_assign
id|state-&gt;sp
op_plus
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_SETNAT_MEMSTK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;pri_unat_loc
)paren
id|state-&gt;pri_unat_loc
op_assign
op_amp
id|state-&gt;sw-&gt;ar_unat
suffix:semicolon
multiline_comment|/* register off. is a multiple of 8, so the least 3 bits (type) are 0 */
id|s
(braket
id|dst
op_plus
l_int|1
)braket
op_assign
(paren
op_star
id|state-&gt;pri_unat_loc
op_minus
id|s
(braket
id|dst
)braket
)paren
op_or
id|UNW_NAT_MEMSTK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_SETNAT_TYPE
suffix:colon
id|s
(braket
id|dst
op_plus
l_int|1
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNW_INSN_LOAD
suffix:colon
macro_line|#if UNW_DEBUG
r_if
c_cond
(paren
(paren
id|s
(braket
id|val
)braket
op_amp
(paren
id|my_cpu_data.unimpl_va_mask
op_or
l_int|0x7
)paren
)paren
op_logical_or
id|s
(braket
id|val
)braket
OL
id|TASK_SIZE
)paren
(brace
id|debug
c_func
(paren
l_int|1
comma
l_string|&quot;unwind: rejecting bad psp=0x%lx&bslash;n&quot;
comma
id|s
(braket
id|val
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|s
(braket
id|dst
)braket
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|s
(braket
id|val
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|STAT
c_func
(paren
id|unw.stat.script.run_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
)paren
suffix:semicolon
r_return
suffix:semicolon
id|lazy_init
suffix:colon
id|off
op_assign
id|unw.sw_off
(braket
id|val
)braket
suffix:semicolon
id|s
(braket
id|val
)braket
op_assign
(paren
r_int
r_int
)paren
id|state-&gt;sw
op_plus
id|off
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ge
id|struct_offset
c_func
(paren
r_struct
id|switch_stack
comma
id|r4
)paren
op_logical_and
id|off
op_le
id|struct_offset
c_func
(paren
r_struct
id|switch_stack
comma
id|r7
)paren
)paren
multiline_comment|/*&n;&t;&t; * We&squot;re initializing a general register: init NaT info, too.  Note that&n;&t;&t; * the offset is a multiple of 8 which gives us the 3 bits needed for&n;&t;&t; * the type field.&n;&t;&t; */
id|s
(braket
id|val
op_plus
l_int|1
)braket
op_assign
(paren
id|struct_offset
c_func
(paren
r_struct
id|switch_stack
comma
id|ar_unat
)paren
op_minus
id|off
)paren
op_or
id|UNW_NAT_MEMSTK
suffix:semicolon
r_goto
id|redo
suffix:semicolon
)brace
r_static
r_int
DECL|function|find_save_locs
id|find_save_locs
(paren
r_struct
id|unw_frame_info
op_star
id|info
)paren
(brace
r_int
id|have_write_lock
op_assign
l_int|0
suffix:semicolon
r_struct
id|unw_script
op_star
id|scr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;ip
op_amp
(paren
id|my_cpu_data.unimpl_va_mask
op_or
l_int|0xf
)paren
)paren
op_logical_or
id|info-&gt;ip
OL
id|TASK_SIZE
)paren
(brace
multiline_comment|/* don&squot;t let obviously bad addresses pollute the cache */
id|debug
c_func
(paren
l_int|1
comma
l_string|&quot;unwind: rejecting bad ip=0x%lx&bslash;n&quot;
comma
id|info-&gt;ip
)paren
suffix:semicolon
id|info-&gt;rp_loc
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|scr
op_assign
id|script_lookup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scr
)paren
(brace
id|scr
op_assign
id|build_script
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scr
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: failed to locate/build unwind script for ip %lx&bslash;n&quot;
comma
id|info-&gt;ip
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|have_write_lock
op_assign
l_int|1
suffix:semicolon
)brace
id|info-&gt;hint
op_assign
id|scr-&gt;hint
suffix:semicolon
id|info-&gt;prev_script
op_assign
id|scr
op_minus
id|unw.cache
suffix:semicolon
id|run_script
c_func
(paren
id|scr
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|have_write_lock
)paren
id|write_unlock
c_func
(paren
op_amp
id|scr-&gt;lock
)paren
suffix:semicolon
r_else
id|read_unlock
c_func
(paren
op_amp
id|scr-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|unw_unwind
id|unw_unwind
(paren
r_struct
id|unw_frame_info
op_star
id|info
)paren
(brace
r_int
r_int
id|prev_ip
comma
id|prev_sp
comma
id|prev_bsp
suffix:semicolon
r_int
r_int
id|ip
comma
id|pr
comma
id|num_regs
suffix:semicolon
id|STAT
c_func
(paren
r_int
r_int
id|start
comma
id|flags
suffix:semicolon
)paren
r_int
id|retval
suffix:semicolon
id|STAT
c_func
(paren
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
op_increment
id|unw.stat.api.unwinds
suffix:semicolon
id|start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
)paren
suffix:semicolon
id|prev_ip
op_assign
id|info-&gt;ip
suffix:semicolon
id|prev_sp
op_assign
id|info-&gt;sp
suffix:semicolon
id|prev_bsp
op_assign
id|info-&gt;bsp
suffix:semicolon
multiline_comment|/* restore the ip */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;rp_loc
)paren
(brace
id|debug
c_func
(paren
l_int|1
comma
l_string|&quot;unwind: failed to locate return link (ip=0x%lx)!&bslash;n&quot;
comma
id|info-&gt;ip
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.unwind_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ip
op_assign
id|info-&gt;ip
op_assign
op_star
id|info-&gt;rp_loc
suffix:semicolon
r_if
c_cond
(paren
id|ip
OL
id|GATE_ADDR
op_plus
id|PAGE_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t have unwind info for the gate page, so we consider that part&n;&t;&t; * of user-space for the purpose of unwinding.&n;&t;&t; */
id|debug
c_func
(paren
l_int|1
comma
l_string|&quot;unwind: reached user-space (ip=0x%lx)&bslash;n&quot;
comma
id|ip
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.unwind_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* restore the cfm: */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;pfs_loc
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: failed to locate ar.pfs!&bslash;n&quot;
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.unwind_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|info-&gt;cfm_loc
op_assign
id|info-&gt;pfs_loc
suffix:semicolon
multiline_comment|/* restore the bsp: */
id|pr
op_assign
id|info-&gt;pr
suffix:semicolon
id|num_regs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|UNW_FLAG_INTERRUPT_FRAME
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|pr
op_amp
(paren
l_int|1UL
op_lshift
id|pNonSys
)paren
)paren
op_ne
l_int|0
)paren
id|num_regs
op_assign
op_star
id|info-&gt;cfm_loc
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* size of frame */
id|info-&gt;pfs_loc
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|info-&gt;sp
op_plus
l_int|16
op_plus
id|struct_offset
c_func
(paren
r_struct
id|pt_regs
comma
id|ar_pfs
)paren
)paren
suffix:semicolon
)brace
r_else
id|num_regs
op_assign
(paren
op_star
id|info-&gt;cfm_loc
op_rshift
l_int|7
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* size of locals */
id|info-&gt;bsp
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|info-&gt;bsp
comma
op_minus
id|num_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bsp
template_param
id|info-&gt;regstk.top
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: bsp (0x%lx) out of range [0x%lx-0x%lx]&bslash;n&quot;
comma
id|info-&gt;bsp
comma
id|info-&gt;regstk.limit
comma
id|info-&gt;regstk.top
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.unwind_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* restore the sp: */
id|info-&gt;sp
op_assign
id|info-&gt;psp
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;sp
template_param
id|info-&gt;memstk.limit
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: sp (0x%lx) out of range [0x%lx-0x%lx]&bslash;n&quot;
comma
id|info-&gt;sp
comma
id|info-&gt;memstk.top
comma
id|info-&gt;memstk.limit
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.unwind_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;ip
op_eq
id|prev_ip
op_logical_and
id|info-&gt;sp
op_eq
id|prev_sp
op_logical_and
id|info-&gt;bsp
op_eq
id|prev_bsp
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: ip, sp, bsp remain unchanged; stopping here (ip=0x%lx)&bslash;n&quot;
comma
id|ip
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.unwind_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* as we unwind, the saved ar.unat becomes the primary unat: */
id|info-&gt;pri_unat_loc
op_assign
id|info-&gt;unat_loc
suffix:semicolon
multiline_comment|/* finally, restore the predicates: */
id|unw_get_pr
c_func
(paren
id|info
comma
op_amp
id|info-&gt;pr
)paren
suffix:semicolon
id|retval
op_assign
id|find_save_locs
c_func
(paren
id|info
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.unwind_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_int
DECL|function|unw_unwind_to_user
id|unw_unwind_to_user
(paren
r_struct
id|unw_frame_info
op_star
id|info
)paren
(brace
r_int
r_int
id|ip
suffix:semicolon
r_while
c_loop
(paren
id|unw_unwind
c_func
(paren
id|info
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|unw_get_rp
c_func
(paren
id|info
comma
op_amp
id|ip
)paren
OL
l_int|0
)paren
(brace
id|unw_get_ip
c_func
(paren
id|info
comma
op_amp
id|ip
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;unwind: failed to read return pointer (ip=0x%lx)&bslash;n&quot;
comma
id|ip
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We don&squot;t have unwind info for the gate page, so we consider that part&n;&t;&t; * of user-space for the purpose of unwinding.&n;&t;&t; */
r_if
c_cond
(paren
id|ip
OL
id|GATE_ADDR
op_plus
id|PAGE_SIZE
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|unw_get_ip
c_func
(paren
id|info
comma
op_amp
id|ip
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;unwind: failed to unwind to user-level (ip=0x%lx)&bslash;n&quot;
comma
id|ip
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|unw_init_frame_info
id|unw_init_frame_info
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_struct
id|task_struct
op_star
id|t
comma
r_struct
id|switch_stack
op_star
id|sw
)paren
(brace
r_int
r_int
id|rbslimit
comma
id|rbstop
comma
id|stklimit
comma
id|stktop
comma
id|sol
suffix:semicolon
id|STAT
c_func
(paren
r_int
r_int
id|start
comma
id|flags
suffix:semicolon
)paren
id|STAT
c_func
(paren
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
op_increment
id|unw.stat.api.inits
suffix:semicolon
id|start
op_assign
id|ia64_get_itc
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Subtle stuff here: we _could_ unwind through the&n;&t; * switch_stack frame but we don&squot;t want to do that because it&n;&t; * would be slow as each preserved register would have to be&n;&t; * processed.  Instead, what we do here is zero out the frame&n;&t; * info and start the unwind process at the function that&n;&t; * created the switch_stack frame.  When a preserved value in&n;&t; * switch_stack needs to be accessed, run_script() will&n;&t; * initialize the appropriate pointer on demand.&n;&t; */
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
id|rbslimit
op_assign
(paren
r_int
r_int
)paren
id|t
op_plus
id|IA64_RBS_OFFSET
suffix:semicolon
id|rbstop
op_assign
id|sw-&gt;ar_bspstore
suffix:semicolon
r_if
c_cond
(paren
id|rbstop
op_minus
(paren
r_int
r_int
)paren
id|t
op_ge
id|IA64_STK_OFFSET
)paren
id|rbstop
op_assign
id|rbslimit
suffix:semicolon
id|stklimit
op_assign
(paren
r_int
r_int
)paren
id|t
op_plus
id|IA64_STK_OFFSET
suffix:semicolon
id|stktop
op_assign
(paren
r_int
r_int
)paren
id|sw
op_minus
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|stktop
op_le
id|rbstop
)paren
id|stktop
op_assign
id|rbstop
suffix:semicolon
id|info-&gt;regstk.limit
op_assign
id|rbslimit
suffix:semicolon
id|info-&gt;regstk.top
op_assign
id|rbstop
suffix:semicolon
id|info-&gt;memstk.limit
op_assign
id|stklimit
suffix:semicolon
id|info-&gt;memstk.top
op_assign
id|stktop
suffix:semicolon
id|info-&gt;task
op_assign
id|t
suffix:semicolon
id|info-&gt;sw
op_assign
id|sw
suffix:semicolon
id|info-&gt;sp
op_assign
id|info-&gt;psp
op_assign
(paren
r_int
r_int
)paren
(paren
id|sw
op_plus
l_int|1
)paren
op_minus
l_int|16
suffix:semicolon
id|info-&gt;cfm_loc
op_assign
op_amp
id|sw-&gt;ar_pfs
suffix:semicolon
id|sol
op_assign
(paren
op_star
id|info-&gt;cfm_loc
op_rshift
l_int|7
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|info-&gt;bsp
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|info-&gt;regstk.top
comma
op_minus
id|sol
)paren
suffix:semicolon
id|info-&gt;ip
op_assign
id|sw-&gt;b0
suffix:semicolon
id|info-&gt;pr
op_assign
id|sw-&gt;pr
suffix:semicolon
id|find_save_locs
c_func
(paren
id|info
)paren
suffix:semicolon
id|STAT
c_func
(paren
id|unw.stat.api.init_time
op_add_assign
id|ia64_get_itc
c_func
(paren
)paren
op_minus
id|start
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IA64_NEW_UNWIND */
r_void
DECL|function|unw_init_from_blocked_task
id|unw_init_from_blocked_task
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_struct
id|task_struct
op_star
id|t
)paren
(brace
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
(paren
id|t-&gt;thread.ksp
op_plus
l_int|16
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
id|unw_init_frame_info
c_func
(paren
id|info
comma
id|t
comma
id|sw
)paren
suffix:semicolon
macro_line|#else
r_int
r_int
id|sol
comma
id|limit
comma
id|top
suffix:semicolon
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
id|sol
op_assign
(paren
id|sw-&gt;ar_pfs
op_rshift
l_int|7
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* size of locals */
id|limit
op_assign
(paren
r_int
r_int
)paren
id|t
op_plus
id|IA64_RBS_OFFSET
suffix:semicolon
id|top
op_assign
id|sw-&gt;ar_bspstore
suffix:semicolon
r_if
c_cond
(paren
id|top
op_minus
(paren
r_int
r_int
)paren
id|t
op_ge
id|IA64_STK_OFFSET
)paren
id|top
op_assign
id|limit
suffix:semicolon
id|info-&gt;regstk.limit
op_assign
id|limit
suffix:semicolon
id|info-&gt;regstk.top
op_assign
id|top
suffix:semicolon
id|info-&gt;sw
op_assign
id|sw
suffix:semicolon
id|info-&gt;bsp
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|info-&gt;regstk.top
comma
op_minus
id|sol
)paren
suffix:semicolon
id|info-&gt;cfm_loc
op_assign
op_amp
id|sw-&gt;ar_pfs
suffix:semicolon
id|info-&gt;ip
op_assign
id|sw-&gt;b0
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|unw_init_from_current
id|unw_init_from_current
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
id|unw_init_frame_info
c_func
(paren
id|info
comma
id|current
comma
id|sw
)paren
suffix:semicolon
multiline_comment|/* skip over interrupt frame: */
id|unw_unwind
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#else
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|sol
comma
id|sof
comma
op_star
id|bsp
comma
id|limit
comma
id|top
suffix:semicolon
id|limit
op_assign
(paren
r_int
r_int
)paren
id|current
op_plus
id|IA64_RBS_OFFSET
suffix:semicolon
id|top
op_assign
id|sw-&gt;ar_bspstore
suffix:semicolon
r_if
c_cond
(paren
id|top
op_minus
(paren
r_int
r_int
)paren
id|current
op_ge
id|IA64_STK_OFFSET
)paren
id|top
op_assign
id|limit
suffix:semicolon
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
id|sol
op_assign
(paren
id|sw-&gt;ar_pfs
op_rshift
l_int|7
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* size of frame */
multiline_comment|/* this gives us the bsp top level frame (kdb interrupt frame): */
id|bsp
op_assign
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|top
comma
op_minus
id|sol
)paren
suffix:semicolon
multiline_comment|/* now skip past the interrupt frame: */
id|sof
op_assign
id|regs-&gt;cr_ifs
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* size of frame */
id|info-&gt;regstk.limit
op_assign
id|limit
suffix:semicolon
id|info-&gt;regstk.top
op_assign
id|top
suffix:semicolon
id|info-&gt;sw
op_assign
id|sw
suffix:semicolon
id|info-&gt;bsp
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
id|bsp
comma
op_minus
id|sof
)paren
suffix:semicolon
id|info-&gt;cfm_loc
op_assign
op_amp
id|regs-&gt;cr_ifs
suffix:semicolon
id|info-&gt;ip
op_assign
id|regs-&gt;cr_iip
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifndef CONFIG_IA64_NEW_UNWIND
r_static
r_int
r_int
DECL|function|read_reg
id|read_reg
(paren
r_struct
id|unw_frame_info
op_star
id|info
comma
r_int
id|regnum
comma
r_int
op_star
id|is_nat
)paren
(brace
r_int
r_int
op_star
id|addr
comma
op_star
id|rnat_addr
comma
id|rnat
suffix:semicolon
id|addr
op_assign
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|info-&gt;bsp
comma
id|regnum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|addr
OL
id|info-&gt;regstk.limit
op_logical_or
(paren
r_int
r_int
)paren
id|addr
op_ge
id|info-&gt;regstk.top
op_logical_or
(paren
(paren
r_int
)paren
id|addr
op_amp
l_int|0x7
)paren
op_ne
l_int|0
)paren
(brace
op_star
id|is_nat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0xdeadbeefdeadbeef
suffix:semicolon
)brace
id|rnat_addr
op_assign
id|ia64_rse_rnat_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|rnat_addr
op_ge
id|info-&gt;regstk.top
)paren
id|rnat
op_assign
id|info-&gt;sw-&gt;ar_rnat
suffix:semicolon
r_else
id|rnat
op_assign
op_star
id|rnat_addr
suffix:semicolon
op_star
id|is_nat
op_assign
(paren
id|rnat
op_amp
(paren
l_int|1UL
op_lshift
id|ia64_rse_slot_num
c_func
(paren
id|addr
)paren
)paren
)paren
op_ne
l_int|0
suffix:semicolon
r_return
op_star
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * On entry, info-&gt;regstk.top should point to the register backing&n; * store for r32.&n; */
r_int
DECL|function|unw_unwind
id|unw_unwind
(paren
r_struct
id|unw_frame_info
op_star
id|info
)paren
(brace
r_int
r_int
id|sol
comma
id|cfm
op_assign
op_star
id|info-&gt;cfm_loc
suffix:semicolon
r_int
id|is_nat
suffix:semicolon
id|sol
op_assign
(paren
id|cfm
op_rshift
l_int|7
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/* size of locals */
multiline_comment|/*&n;&t; * In general, we would have to make use of unwind info to&n;&t; * unwind an IA-64 stack, but for now gcc uses a special&n;&t; * convention that makes this possible without full-fledged&n;&t; * unwindo info.  Specifically, we expect &quot;rp&quot; in the second&n;&t; * last, and &quot;ar.pfs&quot; in the last local register, so the&n;&t; * number of locals in a frame must be at least two.  If it&squot;s&n;&t; * less than that, we reached the end of the C call stack.&n;&t; */
r_if
c_cond
(paren
id|sol
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|info-&gt;ip
op_assign
id|read_reg
c_func
(paren
id|info
comma
id|sol
op_minus
l_int|2
comma
op_amp
id|is_nat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_nat
op_logical_or
(paren
id|info-&gt;ip
op_amp
(paren
id|my_cpu_data.unimpl_va_mask
op_or
l_int|0xf
)paren
)paren
)paren
multiline_comment|/* reject let obviously bad addresses */
r_return
op_minus
l_int|1
suffix:semicolon
id|info-&gt;cfm_loc
op_assign
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|info-&gt;bsp
comma
id|sol
op_minus
l_int|1
)paren
suffix:semicolon
id|cfm
op_assign
id|read_reg
c_func
(paren
id|info
comma
id|sol
op_minus
l_int|1
comma
op_amp
id|is_nat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_nat
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sol
op_assign
(paren
id|cfm
op_rshift
l_int|7
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|info-&gt;bsp
op_assign
(paren
r_int
r_int
)paren
id|ia64_rse_skip_regs
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|info-&gt;bsp
comma
op_minus
id|sol
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_IA64_NEW_UNWIND */
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
r_static
r_void
DECL|function|init_unwind_table
id|init_unwind_table
(paren
r_struct
id|unw_table
op_star
id|table
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|segment_base
comma
r_int
r_int
id|gp
comma
r_void
op_star
id|table_start
comma
r_void
op_star
id|table_end
)paren
(brace
r_struct
id|unw_table_entry
op_star
id|start
op_assign
id|table_start
comma
op_star
id|end
op_assign
id|table_end
suffix:semicolon
id|table-&gt;name
op_assign
id|name
suffix:semicolon
id|table-&gt;segment_base
op_assign
id|segment_base
suffix:semicolon
id|table-&gt;gp
op_assign
id|gp
suffix:semicolon
id|table-&gt;start
op_assign
id|segment_base
op_plus
id|start
(braket
l_int|0
)braket
dot
id|start_offset
suffix:semicolon
id|table-&gt;end
op_assign
id|segment_base
op_plus
id|end
(braket
op_minus
l_int|1
)braket
dot
id|end_offset
suffix:semicolon
id|table-&gt;array
op_assign
id|start
suffix:semicolon
id|table-&gt;length
op_assign
id|end
op_minus
id|start
suffix:semicolon
)brace
r_void
op_star
DECL|function|unw_add_unwind_table
id|unw_add_unwind_table
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|segment_base
comma
r_int
r_int
id|gp
comma
r_void
op_star
id|table_start
comma
r_void
op_star
id|table_end
)paren
(brace
r_struct
id|unw_table_entry
op_star
id|start
op_assign
id|table_start
comma
op_star
id|end
op_assign
id|table_end
suffix:semicolon
r_struct
id|unw_table
op_star
id|table
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
op_le
l_int|0
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: ignoring attempt to insert empty unwind table&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|table
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|table
)paren
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|table
)paren
r_return
l_int|0
suffix:semicolon
id|init_unwind_table
c_func
(paren
id|table
comma
id|name
comma
id|segment_base
comma
id|gp
comma
id|table_start
comma
id|table_end
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|unw.lock
comma
id|flags
)paren
suffix:semicolon
(brace
multiline_comment|/* keep kernel unwind table at the front (it&squot;s searched most commonly): */
id|table-&gt;next
op_assign
id|unw.tables-&gt;next
suffix:semicolon
id|unw.tables-&gt;next
op_assign
id|table
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|unw.lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|table
suffix:semicolon
)brace
r_void
DECL|function|unw_remove_unwind_table
id|unw_remove_unwind_table
(paren
r_void
op_star
id|handle
)paren
(brace
r_struct
id|unw_table
op_star
id|table
comma
op_star
id|prev
suffix:semicolon
r_struct
id|unw_script
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: ignoring attempt to remove non-existent unwind table&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|table
op_assign
id|handle
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
op_amp
id|unw.kernel_table
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: sorry, freeing the kernel&squot;s unwind table is a no-can-do!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|unw.lock
comma
id|flags
)paren
suffix:semicolon
(brace
multiline_comment|/* first, delete the table: */
r_for
c_loop
(paren
id|prev
op_assign
(paren
r_struct
id|unw_table
op_star
)paren
op_amp
id|unw.tables
suffix:semicolon
id|prev
suffix:semicolon
id|prev
op_assign
id|prev-&gt;next
)paren
r_if
c_cond
(paren
id|prev-&gt;next
op_eq
id|table
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;unwind: failed to find unwind table %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|table
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|unw.lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prev-&gt;next
op_assign
id|table-&gt;next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|unw.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* next, remove hash table entries for this table */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
op_le
id|UNW_HASH_SIZE
suffix:semicolon
op_increment
id|index
)paren
(brace
id|tmp
op_assign
id|unw.cache
op_plus
id|unw.hash
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unw.hash
(braket
id|index
)braket
op_ge
id|UNW_CACHE_SIZE
op_logical_or
id|tmp-&gt;ip
OL
id|table-&gt;start
op_logical_or
id|tmp-&gt;ip
op_ge
id|table-&gt;end
)paren
r_continue
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|tmp-&gt;lock
)paren
suffix:semicolon
(brace
r_if
c_cond
(paren
id|tmp-&gt;ip
op_ge
id|table-&gt;start
op_logical_and
id|tmp-&gt;ip
OL
id|table-&gt;end
)paren
(brace
id|unw.hash
(braket
id|index
)braket
op_assign
id|tmp-&gt;coll_chain
suffix:semicolon
id|tmp-&gt;ip
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|write_unlock
c_func
(paren
op_amp
id|tmp-&gt;lock
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|table
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_IA64_NEW_UNWIND */
r_void
DECL|function|unw_init
id|unw_init
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_IA64_NEW_UNWIND
r_extern
r_int
id|ia64_unw_start
comma
id|ia64_unw_end
comma
id|__gp
suffix:semicolon
r_extern
r_void
id|unw_hash_index_t_is_too_narrow
(paren
r_void
)paren
suffix:semicolon
r_int
id|i
comma
id|off
suffix:semicolon
r_if
c_cond
(paren
l_int|8
op_star
r_sizeof
(paren
id|unw_hash_index_t
)paren
OL
id|UNW_LOG_HASH_SIZE
)paren
id|unw_hash_index_t_is_too_narrow
c_func
(paren
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_PRI_UNAT_GR
)braket
)braket
op_assign
id|SW
c_func
(paren
id|AR_UNAT
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_BSPSTORE
)braket
)braket
op_assign
id|SW
c_func
(paren
id|AR_BSPSTORE
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_PFS
)braket
)braket
op_assign
id|SW
c_func
(paren
id|AR_UNAT
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_RP
)braket
)braket
op_assign
id|SW
c_func
(paren
id|B0
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_UNAT
)braket
)braket
op_assign
id|SW
c_func
(paren
id|AR_UNAT
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_PR
)braket
)braket
op_assign
id|SW
c_func
(paren
id|PR
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_LC
)braket
)braket
op_assign
id|SW
c_func
(paren
id|AR_LC
)paren
suffix:semicolon
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|UNW_REG_FPSR
)braket
)braket
op_assign
id|SW
c_func
(paren
id|AR_FPSR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|UNW_REG_R4
comma
id|off
op_assign
id|SW
c_func
(paren
id|R4
)paren
suffix:semicolon
id|i
op_le
id|UNW_REG_R7
suffix:semicolon
op_increment
id|i
comma
id|off
op_add_assign
l_int|8
)paren
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|i
)braket
)braket
op_assign
id|off
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|UNW_REG_B1
comma
id|off
op_assign
id|SW
c_func
(paren
id|B1
)paren
suffix:semicolon
id|i
op_le
id|UNW_REG_B5
suffix:semicolon
op_increment
id|i
comma
id|off
op_add_assign
l_int|8
)paren
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|i
)braket
)braket
op_assign
id|off
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|UNW_REG_F2
comma
id|off
op_assign
id|SW
c_func
(paren
id|F2
)paren
suffix:semicolon
id|i
op_le
id|UNW_REG_F5
suffix:semicolon
op_increment
id|i
comma
id|off
op_add_assign
l_int|16
)paren
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|i
)braket
)braket
op_assign
id|off
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|UNW_REG_F16
comma
id|off
op_assign
id|SW
c_func
(paren
id|F16
)paren
suffix:semicolon
id|i
op_le
id|UNW_REG_F31
suffix:semicolon
op_increment
id|i
comma
id|off
op_add_assign
l_int|16
)paren
id|unw.sw_off
(braket
id|unw.preg_index
(braket
id|i
)braket
)braket
op_assign
id|off
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UNW_CACHE_SIZE
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|unw.cache
(braket
id|i
)braket
dot
id|lru_chain
op_assign
(paren
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|unw.cache
(braket
id|i
)braket
dot
id|coll_chain
op_assign
op_minus
l_int|1
suffix:semicolon
id|unw.cache
(braket
id|i
)braket
dot
id|lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
)brace
id|unw.lru_head
op_assign
id|UNW_CACHE_SIZE
op_minus
l_int|1
suffix:semicolon
id|unw.lru_tail
op_assign
l_int|0
suffix:semicolon
id|init_unwind_table
c_func
(paren
op_amp
id|unw.kernel_table
comma
l_string|&quot;kernel&quot;
comma
id|KERNEL_START
comma
(paren
r_int
r_int
)paren
op_amp
id|__gp
comma
op_amp
id|ia64_unw_start
comma
op_amp
id|ia64_unw_end
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_IA64_NEW_UNWIND */
)brace
eof
