multiline_comment|/*&n; * Architecture-specific unaligned trap handling.&n; *&n; * Copyright (C) 1999-2000 Hewlett-Packard Co&n; * Copyright (C) 1999-2000 Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/rse.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
id|__attribute__
(paren
(paren
id|noreturn
)paren
)paren
suffix:semicolon
DECL|macro|DEBUG_UNALIGNED_TRAP
macro_line|#undef DEBUG_UNALIGNED_TRAP
macro_line|#ifdef DEBUG_UNALIGNED_TRAP
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a) { printk(&quot;%s, line %d: &quot;, __FUNCTION__, __LINE__); printk a;}
macro_line|#else
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a)
macro_line|#endif
DECL|macro|IA64_FIRST_STACKED_GR
mdefine_line|#define IA64_FIRST_STACKED_GR&t;32
DECL|macro|IA64_FIRST_ROTATING_FR
mdefine_line|#define IA64_FIRST_ROTATING_FR&t;32
DECL|macro|SIGN_EXT9
mdefine_line|#define SIGN_EXT9&t;&t;__IA64_UL(0xffffffffffffff00)
multiline_comment|/*&n; * For M-unit:&n; *&n; *  opcode |   m  |   x6    |&n; * --------|------|---------|&n; * [40-37] | [36] | [35:30] |&n; * --------|------|---------|&n; *     4   |   1  |    6    | = 11 bits&n; * --------------------------&n; * However bits [31:30] are not directly useful to distinguish between &n; * load/store so we can use [35:32] instead, which gives the following &n; * mask ([40:32]) using 9 bits. The &squot;e&squot; comes from the fact that we defer&n; * checking the m-bit until later in the load/store emulation.&n; */
DECL|macro|IA64_OPCODE_MASK
mdefine_line|#define IA64_OPCODE_MASK&t;0x1ef00000000
multiline_comment|/*&n; * Table C-28 Integer Load/Store&n; * &n; * We ignore [35:32]= 0x6, 0x7, 0xE, 0xF&n; *&n; * ld8.fill, st8.fill  MUST be aligned because the RNATs are based on &n; * the address (bits [8:3]), so we must failed.&n; */
DECL|macro|LD_OP
mdefine_line|#define LD_OP            0x08000000000
DECL|macro|LDS_OP
mdefine_line|#define LDS_OP           0x08100000000
DECL|macro|LDA_OP
mdefine_line|#define LDA_OP           0x08200000000
DECL|macro|LDSA_OP
mdefine_line|#define LDSA_OP          0x08300000000
DECL|macro|LDBIAS_OP
mdefine_line|#define LDBIAS_OP        0x08400000000
DECL|macro|LDACQ_OP
mdefine_line|#define LDACQ_OP         0x08500000000
multiline_comment|/* 0x086, 0x087 are not relevant */
DECL|macro|LDCCLR_OP
mdefine_line|#define LDCCLR_OP        0x08800000000
DECL|macro|LDCNC_OP
mdefine_line|#define LDCNC_OP         0x08900000000
DECL|macro|LDCCLRACQ_OP
mdefine_line|#define LDCCLRACQ_OP     0x08a00000000
DECL|macro|ST_OP
mdefine_line|#define ST_OP            0x08c00000000
DECL|macro|STREL_OP
mdefine_line|#define STREL_OP         0x08d00000000
multiline_comment|/* 0x08e,0x8f are not relevant */
multiline_comment|/*&n; * Table C-29 Integer Load +Reg&n; *&n; * we use the ld-&gt;m (bit [36:36]) field to determine whether or not we have&n; * a load/store of this form.&n; */
multiline_comment|/*&n; * Table C-30 Integer Load/Store +Imm&n; * &n; * We ignore [35:32]= 0x6, 0x7, 0xE, 0xF&n; *&n; * ld8.fill, st8.fill  must be aligned because the Nat register are based on &n; * the address, so we must fail and the program must be fixed.&n; */
DECL|macro|LD_IMM_OP
mdefine_line|#define LD_IMM_OP            0x0a000000000
DECL|macro|LDS_IMM_OP
mdefine_line|#define LDS_IMM_OP           0x0a100000000
DECL|macro|LDA_IMM_OP
mdefine_line|#define LDA_IMM_OP           0x0a200000000
DECL|macro|LDSA_IMM_OP
mdefine_line|#define LDSA_IMM_OP          0x0a300000000
DECL|macro|LDBIAS_IMM_OP
mdefine_line|#define LDBIAS_IMM_OP        0x0a400000000
DECL|macro|LDACQ_IMM_OP
mdefine_line|#define LDACQ_IMM_OP         0x0a500000000
multiline_comment|/* 0x0a6, 0xa7 are not relevant */
DECL|macro|LDCCLR_IMM_OP
mdefine_line|#define LDCCLR_IMM_OP        0x0a800000000
DECL|macro|LDCNC_IMM_OP
mdefine_line|#define LDCNC_IMM_OP         0x0a900000000
DECL|macro|LDCCLRACQ_IMM_OP
mdefine_line|#define LDCCLRACQ_IMM_OP     0x0aa00000000
DECL|macro|ST_IMM_OP
mdefine_line|#define ST_IMM_OP            0x0ac00000000
DECL|macro|STREL_IMM_OP
mdefine_line|#define STREL_IMM_OP         0x0ad00000000
multiline_comment|/* 0x0ae,0xaf are not relevant */
multiline_comment|/*&n; * Table C-32 Floating-point Load/Store&n; */
DECL|macro|LDF_OP
mdefine_line|#define LDF_OP           0x0c000000000
DECL|macro|LDFS_OP
mdefine_line|#define LDFS_OP          0x0c100000000
DECL|macro|LDFA_OP
mdefine_line|#define LDFA_OP          0x0c200000000
DECL|macro|LDFSA_OP
mdefine_line|#define LDFSA_OP         0x0c300000000
multiline_comment|/* 0x0c6 is irrelevant */
DECL|macro|LDFCCLR_OP
mdefine_line|#define LDFCCLR_OP       0x0c800000000
DECL|macro|LDFCNC_OP
mdefine_line|#define LDFCNC_OP        0x0c900000000
multiline_comment|/* 0x0cb is irrelevant  */
DECL|macro|STF_OP
mdefine_line|#define STF_OP           0x0cc00000000
multiline_comment|/*&n; * Table C-33 Floating-point Load +Reg&n; *&n; * we use the ld-&gt;m (bit [36:36]) field to determine whether or not we have&n; * a load/store of this form.&n; */
multiline_comment|/*&n; * Table C-34 Floating-point Load/Store +Imm&n; */
DECL|macro|LDF_IMM_OP
mdefine_line|#define LDF_IMM_OP       0x0e000000000
DECL|macro|LDFS_IMM_OP
mdefine_line|#define LDFS_IMM_OP      0x0e100000000
DECL|macro|LDFA_IMM_OP
mdefine_line|#define LDFA_IMM_OP      0x0e200000000
DECL|macro|LDFSA_IMM_OP
mdefine_line|#define LDFSA_IMM_OP     0x0e300000000
multiline_comment|/* 0x0e6 is irrelevant */
DECL|macro|LDFCCLR_IMM_OP
mdefine_line|#define LDFCCLR_IMM_OP   0x0e800000000
DECL|macro|LDFCNC_IMM_OP
mdefine_line|#define LDFCNC_IMM_OP    0x0e900000000
DECL|macro|STF_IMM_OP
mdefine_line|#define STF_IMM_OP       0x0ec00000000
r_typedef
r_struct
(brace
DECL|member|qp
r_int
r_int
id|qp
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* [0:5]   */
DECL|member|r1
r_int
r_int
id|r1
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* [6:12]  */
DECL|member|imm
r_int
r_int
id|imm
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* [13:19] */
DECL|member|r3
r_int
r_int
id|r3
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* [20:26] */
DECL|member|x
r_int
r_int
id|x
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* [27:27] */
DECL|member|hint
r_int
r_int
id|hint
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* [28:29] */
DECL|member|x6_sz
r_int
r_int
id|x6_sz
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* [30:31] */
DECL|member|x6_op
r_int
r_int
id|x6_op
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* [32:35], x6 = x6_sz|x6_op */
DECL|member|m
r_int
r_int
id|m
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* [36:36] */
DECL|member|op
r_int
r_int
id|op
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* [37:40] */
DECL|member|pad
r_int
r_int
id|pad
suffix:colon
l_int|23
suffix:semicolon
multiline_comment|/* [41:63] */
DECL|typedef|load_store_t
)brace
id|load_store_t
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|UPD_IMMEDIATE
id|UPD_IMMEDIATE
comma
multiline_comment|/* ldXZ r1=[r3],imm(9) */
DECL|enumerator|UPD_REG
id|UPD_REG
multiline_comment|/* ldXZ r1=[r3],r2     */
DECL|typedef|update_t
)brace
id|update_t
suffix:semicolon
multiline_comment|/*&n; * We use tables to keep track of the offsets of registers in the saved state.&n; * This way we save having big switch/case statements.&n; *&n; * We use bit 0 to indicate switch_stack or pt_regs.&n; * The offset is simply shifted by 1 bit.&n; * A 2-byte value should be enough to hold any kind of offset&n; *&n; * In case the calling convention changes (and thus pt_regs/switch_stack)&n; * simply use RSW instead of RPT or vice-versa.&n; */
DECL|macro|RPO
mdefine_line|#define RPO(x)&t;((size_t) &amp;((struct pt_regs *)0)-&gt;x)
DECL|macro|RSO
mdefine_line|#define RSO(x)&t;((size_t) &amp;((struct switch_stack *)0)-&gt;x)
DECL|macro|RPT
mdefine_line|#define RPT(x)&t;&t;(RPO(x) &lt;&lt; 1)
DECL|macro|RSW
mdefine_line|#define RSW(x)&t;&t;(1| RSO(x)&lt;&lt;1)
DECL|macro|GR_OFFS
mdefine_line|#define GR_OFFS(x)&t;(gr_info[x]&gt;&gt;1)
DECL|macro|GR_IN_SW
mdefine_line|#define GR_IN_SW(x)&t;(gr_info[x] &amp; 0x1)
DECL|macro|FR_OFFS
mdefine_line|#define FR_OFFS(x)&t;(fr_info[x]&gt;&gt;1)
DECL|macro|FR_IN_SW
mdefine_line|#define FR_IN_SW(x)&t;(fr_info[x] &amp; 0x1)
DECL|variable|gr_info
r_static
id|u16
id|gr_info
(braket
l_int|32
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|fr_info
r_static
id|u16
id|fr_info
(braket
l_int|32
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Invalidate ALAT entry for integer register REGNO.  */
r_static
r_void
DECL|function|invala_gr
id|invala_gr
(paren
r_int
id|regno
)paren
(brace
DECL|macro|F
macro_line|#&t;define F(reg)&t;case reg: __asm__ __volatile__ (&quot;invala.e r%0&quot; :: &quot;i&quot;(reg)); break
r_switch
c_cond
(paren
id|regno
)paren
(brace
id|F
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|9
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|11
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|12
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|13
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|14
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|16
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|17
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|18
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|19
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|21
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|22
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|23
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|24
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|26
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|27
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|28
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|29
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|31
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|32
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|33
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|34
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|35
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|36
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|37
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|38
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|39
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|42
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|43
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|44
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|45
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|46
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|47
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|48
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|49
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|51
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|52
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|53
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|54
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|55
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|56
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|57
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|58
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|59
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|60
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|61
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|62
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|63
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|64
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|65
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|66
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|67
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|68
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|69
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|70
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|71
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|72
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|73
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|74
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|75
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|76
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|77
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|78
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|79
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|80
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|81
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|82
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|83
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|84
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|85
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|86
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|87
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|88
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|89
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|90
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|91
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|92
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|93
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|94
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|95
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|96
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|97
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|98
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|99
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|101
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|102
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|103
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|104
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|105
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|106
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|107
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|108
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|109
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|110
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|111
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|112
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|113
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|114
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|116
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|117
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|118
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|119
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|120
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|121
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|122
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|123
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|124
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|125
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|126
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|127
)paren
suffix:semicolon
)brace
DECL|macro|F
macro_line|#&t;undef F
)brace
multiline_comment|/* Invalidate ALAT entry for floating-point register REGNO.  */
r_static
r_void
DECL|function|invala_fr
id|invala_fr
(paren
r_int
id|regno
)paren
(brace
DECL|macro|F
macro_line|#&t;define F(reg)&t;case reg: __asm__ __volatile__ (&quot;invala.e f%0&quot; :: &quot;i&quot;(reg)); break
r_switch
c_cond
(paren
id|regno
)paren
(brace
id|F
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|9
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|11
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|12
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|13
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|14
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|16
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|17
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|18
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|19
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|21
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|22
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|23
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|24
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|26
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|27
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|28
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|29
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|31
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|32
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|33
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|34
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|35
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|36
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|37
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|38
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|39
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|41
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|42
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|43
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|44
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|45
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|46
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|47
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|48
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|49
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|51
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|52
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|53
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|54
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|55
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|56
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|57
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|58
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|59
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|60
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|61
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|62
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|63
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|64
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|65
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|66
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|67
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|68
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|69
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|70
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|71
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|72
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|73
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|74
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|75
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|76
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|77
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|78
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|79
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|80
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|81
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|82
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|83
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|84
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|85
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|86
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|87
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|88
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|89
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|90
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|91
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|92
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|93
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|94
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|95
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|96
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|97
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|98
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|99
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|101
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|102
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|103
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|104
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|105
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|106
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|107
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|108
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|109
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|110
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|111
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|112
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|113
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|114
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|116
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|117
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|118
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|119
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|120
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|121
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|122
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|123
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|124
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|125
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|126
)paren
suffix:semicolon
id|F
c_func
(paren
l_int|127
)paren
suffix:semicolon
)brace
DECL|macro|F
macro_line|#&t;undef F
)brace
r_static
r_void
DECL|function|set_rse_reg
id|set_rse_reg
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|r1
comma
r_int
r_int
id|val
comma
r_int
id|nat
)paren
(brace
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
r_int
r_int
op_star
id|kbs
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|current
)paren
op_plus
id|IA64_RBS_OFFSET
op_div
l_int|8
suffix:semicolon
r_int
r_int
id|on_kbs
suffix:semicolon
r_int
r_int
op_star
id|bsp
comma
op_star
id|bspstore
comma
op_star
id|addr
comma
op_star
id|ubs_end
comma
op_star
id|slot
suffix:semicolon
r_int
r_int
id|rnats
suffix:semicolon
r_int
id|nlocals
suffix:semicolon
multiline_comment|/*&n;&t; * cr_ifs=[rv:ifm], ifm=[....:sof(6)]&n;&t; * nlocal=number of locals (in+loc) register of the faulting function&n;&t; */
id|nlocals
op_assign
(paren
id|regs-&gt;cr_ifs
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;sw.bsptore=%lx pt.bspstore=%lx&bslash;n&quot;
comma
id|sw-&gt;ar_bspstore
comma
id|regs-&gt;ar_bspstore
)paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;cr.ifs=%lx sof=%ld sol=%ld&bslash;n&quot;
comma
id|regs-&gt;cr_ifs
comma
id|regs-&gt;cr_ifs
op_amp
l_int|0x7f
comma
(paren
id|regs-&gt;cr_ifs
op_rshift
l_int|7
)paren
op_amp
l_int|0x7f
)paren
)paren
suffix:semicolon
id|on_kbs
op_assign
id|ia64_rse_num_regs
c_func
(paren
id|kbs
comma
(paren
r_int
r_int
op_star
)paren
id|sw-&gt;ar_bspstore
)paren
suffix:semicolon
id|bspstore
op_assign
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;ar_bspstore
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;rse_slot_num=0x%lx&bslash;n&quot;
comma
id|ia64_rse_slot_num
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|sw-&gt;ar_bspstore
)paren
)paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;kbs=%p nlocals=%ld&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|kbs
comma
id|nlocals
)paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;bspstore next rnat slot %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ia64_rse_rnat_addr
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|sw-&gt;ar_bspstore
)paren
)paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;on_kbs=%ld rnats=%ld&bslash;n&quot;
comma
id|on_kbs
comma
(paren
(paren
id|sw-&gt;ar_bspstore
op_minus
(paren
r_int
r_int
)paren
id|kbs
)paren
op_rshift
l_int|3
)paren
op_minus
id|on_kbs
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See get_rse_reg() for an explanation on the following instructions&n;&t; */
id|ubs_end
op_assign
id|ia64_rse_skip_regs
c_func
(paren
id|bspstore
comma
id|on_kbs
)paren
suffix:semicolon
id|bsp
op_assign
id|ia64_rse_skip_regs
c_func
(paren
id|ubs_end
comma
op_minus
id|nlocals
)paren
suffix:semicolon
id|addr
op_assign
id|slot
op_assign
id|ia64_rse_skip_regs
c_func
(paren
id|bsp
comma
id|r1
op_minus
l_int|32
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ubs_end=%p bsp=%p addr=%p slot=0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ubs_end
comma
(paren
r_void
op_star
)paren
id|bsp
comma
(paren
r_void
op_star
)paren
id|addr
comma
id|ia64_rse_slot_num
c_func
(paren
id|addr
)paren
)paren
)paren
suffix:semicolon
id|ia64_poke
c_func
(paren
id|regs
comma
id|current
comma
(paren
r_int
r_int
)paren
id|addr
comma
id|val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * addr will now contain the address of the RNAT for the register&n;&t; */
id|addr
op_assign
id|ia64_rse_rnat_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
id|ia64_peek
c_func
(paren
id|regs
comma
id|current
comma
(paren
r_int
r_int
)paren
id|addr
comma
op_amp
id|rnats
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;rnat @%p = 0x%lx nat=%d rnatval=%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|addr
comma
id|rnats
comma
id|nat
comma
id|rnats
op_amp
id|ia64_rse_slot_num
c_func
(paren
id|slot
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nat
)paren
(brace
id|rnats
op_or_assign
id|__IA64_UL
c_func
(paren
l_int|1
)paren
op_lshift
id|ia64_rse_slot_num
c_func
(paren
id|slot
)paren
suffix:semicolon
)brace
r_else
(brace
id|rnats
op_and_assign
op_complement
(paren
id|__IA64_UL
c_func
(paren
l_int|1
)paren
op_lshift
id|ia64_rse_slot_num
c_func
(paren
id|slot
)paren
)paren
suffix:semicolon
)brace
id|ia64_poke
c_func
(paren
id|regs
comma
id|current
comma
(paren
r_int
r_int
)paren
id|addr
comma
id|rnats
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;rnat changed to @%p = 0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|addr
comma
id|rnats
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|get_rse_reg
id|get_rse_reg
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|r1
comma
r_int
r_int
op_star
id|val
comma
r_int
op_star
id|nat
)paren
(brace
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
r_int
r_int
op_star
id|kbs
op_assign
(paren
r_int
r_int
op_star
)paren
id|current
op_plus
id|IA64_RBS_OFFSET
op_div
l_int|8
suffix:semicolon
r_int
r_int
id|on_kbs
suffix:semicolon
r_int
id|nlocals
suffix:semicolon
r_int
r_int
op_star
id|bsp
comma
op_star
id|addr
comma
op_star
id|ubs_end
comma
op_star
id|slot
comma
op_star
id|bspstore
suffix:semicolon
r_int
r_int
id|rnats
suffix:semicolon
multiline_comment|/*&n;&t; * cr_ifs=[rv:ifm], ifm=[....:sof(6)]&n;&t; * nlocals=number of local registers in the faulting function&n;&t; */
id|nlocals
op_assign
(paren
id|regs-&gt;cr_ifs
)paren
op_amp
l_int|0x7f
suffix:semicolon
multiline_comment|/*&n;&t; * save_switch_stack does a flushrs and saves bspstore.&n;&t; * on_kbs = actual number of registers saved on kernel backing store&n;&t; *          (taking into accound potential RNATs)&n;&t; *&n;&t; * Note that this number can be greater than nlocals if the dirty&n;&t; * parititions included more than one stack frame at the time we&n;&t; * switched to KBS&n;&t; */
id|on_kbs
op_assign
id|ia64_rse_num_regs
c_func
(paren
id|kbs
comma
(paren
r_int
r_int
op_star
)paren
id|sw-&gt;ar_bspstore
)paren
suffix:semicolon
id|bspstore
op_assign
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;ar_bspstore
suffix:semicolon
multiline_comment|/*&n;&t; * To simplify the logic, we calculate everything as if there was only&n;&t; * one backing store i.e., the user one (UBS). We let it to peek/poke&n;&t; * to figure out whether the register we&squot;re looking for really is&n;&t; * on the UBS or on KBS.&n;&t; *&n;&t; * regs-&gt;ar_bsptore = address of last register saved on UBS (before switch)&n;&t; *&n;&t; * ubs_end = virtual end of the UBS (if everything had been spilled there)&n;&t; *&n;&t; * We know that ubs_end is the point where the last register on the&n;&t; * stack frame we&squot;re interested in as been saved. So we need to walk&n;&t; * our way backward to figure out what the BSP &quot;was&quot; for that frame,&n;&t; * this will give us the location of r32. &n;&t; *&n;&t; * bsp = &quot;virtual UBS&quot; address of r32 for our frame&n;&t; *&n;&t; * Finally, get compute the address of the register we&squot;re looking for&n;&t; * using bsp as our base (move up again).&n;&t; *&n;&t; * Please note that in our case, we know that the register is necessarily&n;&t; * on the KBS because we are only interested in the current frame at the moment&n;&t; * we got the exception i.e., bsp is not changed until we switch to KBS.&n;&t; */
id|ubs_end
op_assign
id|ia64_rse_skip_regs
c_func
(paren
id|bspstore
comma
id|on_kbs
)paren
suffix:semicolon
id|bsp
op_assign
id|ia64_rse_skip_regs
c_func
(paren
id|ubs_end
comma
op_minus
id|nlocals
)paren
suffix:semicolon
id|addr
op_assign
id|slot
op_assign
id|ia64_rse_skip_regs
c_func
(paren
id|bsp
comma
id|r1
op_minus
l_int|32
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ubs_end=%p bsp=%p addr=%p slot=0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|ubs_end
comma
(paren
r_void
op_star
)paren
id|bsp
comma
(paren
r_void
op_star
)paren
id|addr
comma
id|ia64_rse_slot_num
c_func
(paren
id|addr
)paren
)paren
)paren
suffix:semicolon
id|ia64_peek
c_func
(paren
id|regs
comma
id|current
comma
(paren
r_int
r_int
)paren
id|addr
comma
id|val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * addr will now contain the address of the RNAT for the register&n;&t; */
id|addr
op_assign
id|ia64_rse_rnat_addr
c_func
(paren
id|addr
)paren
suffix:semicolon
id|ia64_peek
c_func
(paren
id|regs
comma
id|current
comma
(paren
r_int
r_int
)paren
id|addr
comma
op_amp
id|rnats
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;rnat @%p = 0x%lx&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|addr
comma
id|rnats
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nat
)paren
op_star
id|nat
op_assign
id|rnats
op_rshift
id|ia64_rse_slot_num
c_func
(paren
id|slot
)paren
op_amp
l_int|0x1
suffix:semicolon
)brace
r_static
r_void
DECL|function|setreg
id|setreg
c_func
(paren
r_int
r_int
id|regnum
comma
r_int
r_int
id|val
comma
r_int
id|nat
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
id|bitmask
suffix:semicolon
r_int
r_int
op_star
id|unat
suffix:semicolon
multiline_comment|/*&n;&t; * First takes care of stacked registers&n;&t; */
r_if
c_cond
(paren
id|regnum
op_ge
id|IA64_FIRST_STACKED_GR
)paren
(brace
id|set_rse_reg
c_func
(paren
id|regs
comma
id|regnum
comma
id|val
comma
id|nat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Using r0 as a target raises a General Exception fault which has &n;&t; * higher priority than the Unaligned Reference fault.&n;&t; */
multiline_comment|/*&n;&t; * Now look at registers in [0-31] range and init correct UNAT&n;&t; */
r_if
c_cond
(paren
id|GR_IN_SW
c_func
(paren
id|regnum
)paren
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|sw
suffix:semicolon
id|unat
op_assign
op_amp
id|sw-&gt;ar_unat
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|regs
suffix:semicolon
id|unat
op_assign
op_amp
id|sw-&gt;caller_unat
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;tmp_base=%lx switch_stack=%s offset=%d&bslash;n&quot;
comma
id|addr
comma
id|unat
op_eq
op_amp
id|sw-&gt;ar_unat
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|GR_OFFS
c_func
(paren
id|regnum
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * add offset from base of struct&n;&t; * and do it !&n;&t; */
id|addr
op_add_assign
id|GR_OFFS
c_func
(paren
id|regnum
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|addr
op_assign
id|val
suffix:semicolon
multiline_comment|/*&n;&t; * We need to clear the corresponding UNAT bit to fully emulate the load&n;&t; * UNAT bit_pos = GR[r3]{8:3} form EAS-2.4&n;&t; */
id|bitmask
op_assign
id|__IA64_UL
c_func
(paren
l_int|1
)paren
op_lshift
(paren
id|addr
op_rshift
l_int|3
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;*0x%lx=0x%lx NaT=%d prev_unat @%p=%lx&bslash;n&quot;
comma
id|addr
comma
id|val
comma
id|nat
comma
(paren
r_void
op_star
)paren
id|unat
comma
op_star
id|unat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nat
)paren
(brace
op_star
id|unat
op_or_assign
id|bitmask
suffix:semicolon
)brace
r_else
(brace
op_star
id|unat
op_and_assign
op_complement
id|bitmask
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;*0x%lx=0x%lx NaT=%d new unat: %p=%lx&bslash;n&quot;
comma
id|addr
comma
id|val
comma
id|nat
comma
(paren
r_void
op_star
)paren
id|unat
comma
op_star
id|unat
)paren
)paren
suffix:semicolon
)brace
DECL|macro|IA64_FPH_OFFS
mdefine_line|#define IA64_FPH_OFFS(r) (r - IA64_FIRST_ROTATING_FR)
r_static
r_void
DECL|function|setfpreg
id|setfpreg
c_func
(paren
r_int
r_int
id|regnum
comma
r_struct
id|ia64_fpreg
op_star
id|fpval
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * From EAS-2.5: FPDisableFault has higher priority than Unaligned&n;&t; * Fault. Thus, when we get here, we know the partition is enabled.&n;&t; * To update f32-f127, there are three choices:&n;&t; *&n;&t; *&t;(1) save f32-f127 to thread.fph and update the values there&n;&t; *&t;(2) use a gigantic switch statement to directly access the registers&n;&t; *&t;(3) generate code on the fly to update the desired register&n;&t; *&n;&t; * For now, we are using approach (1).&n;&t; */
r_if
c_cond
(paren
id|regnum
op_ge
id|IA64_FIRST_ROTATING_FR
)paren
(brace
id|ia64_sync_fph
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;thread.fph
(braket
id|IA64_FPH_OFFS
c_func
(paren
id|regnum
)paren
)braket
op_assign
op_star
id|fpval
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * pt_regs or switch_stack ?&n;&t;&t; */
r_if
c_cond
(paren
id|FR_IN_SW
c_func
(paren
id|regnum
)paren
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|sw
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|regs
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;tmp_base=%lx offset=%d&bslash;n&quot;
comma
id|addr
comma
id|FR_OFFS
c_func
(paren
id|regnum
)paren
)paren
)paren
suffix:semicolon
id|addr
op_add_assign
id|FR_OFFS
c_func
(paren
id|regnum
)paren
suffix:semicolon
op_star
(paren
r_struct
id|ia64_fpreg
op_star
)paren
id|addr
op_assign
op_star
id|fpval
suffix:semicolon
multiline_comment|/*&n;&t; &t; * mark the low partition as being used now&n;&t;&t; *&n;&t;&t; * It is highly unlikely that this bit is not already set, but&n;&t;&t; * let&squot;s do it for safety.&n;&t; &t; */
id|regs-&gt;cr_ipsr
op_or_assign
id|IA64_PSR_MFL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Those 2 inline functions generate the spilled versions of the constant floating point&n; * registers which can be used with stfX&n; */
r_static
r_inline
r_void
DECL|function|float_spill_f0
id|float_spill_f0
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;stf.spill [%0]=f0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|float_spill_f1
id|float_spill_f1
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;stf.spill [%0]=f1&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|getfpreg
id|getfpreg
c_func
(paren
r_int
r_int
id|regnum
comma
r_struct
id|ia64_fpreg
op_star
id|fpval
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * From EAS-2.5: FPDisableFault has higher priority than &n;&t; * Unaligned Fault. Thus, when we get here, we know the partition is &n;&t; * enabled.&n;&t; *&n;&t; * When regnum &gt; 31, the register is still live and we need to force a save&n;&t; * to current-&gt;thread.fph to get access to it.  See discussion in setfpreg()&n;&t; * for reasons and other ways of doing this.&n;&t; */
r_if
c_cond
(paren
id|regnum
op_ge
id|IA64_FIRST_ROTATING_FR
)paren
(brace
id|ia64_flush_fph
c_func
(paren
id|current
)paren
suffix:semicolon
op_star
id|fpval
op_assign
id|current-&gt;thread.fph
(braket
id|IA64_FPH_OFFS
c_func
(paren
id|regnum
)paren
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * f0 = 0.0, f1= 1.0. Those registers are constant and are thus&n;&t; &t; * not saved, we must generate their spilled form on the fly&n;&t;&t; */
r_switch
c_cond
(paren
id|regnum
)paren
(brace
r_case
l_int|0
suffix:colon
id|float_spill_f0
c_func
(paren
id|fpval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|float_spill_f1
c_func
(paren
id|fpval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * pt_regs or switch_stack ?&n;&t;&t;&t; */
id|addr
op_assign
id|FR_IN_SW
c_func
(paren
id|regnum
)paren
ques
c_cond
(paren
r_int
r_int
)paren
id|sw
suffix:colon
(paren
r_int
r_int
)paren
id|regs
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;is_sw=%d tmp_base=%lx offset=0x%x&bslash;n&quot;
comma
id|FR_IN_SW
c_func
(paren
id|regnum
)paren
comma
id|addr
comma
id|FR_OFFS
c_func
(paren
id|regnum
)paren
)paren
)paren
suffix:semicolon
id|addr
op_add_assign
id|FR_OFFS
c_func
(paren
id|regnum
)paren
suffix:semicolon
op_star
id|fpval
op_assign
op_star
(paren
r_struct
id|ia64_fpreg
op_star
)paren
id|addr
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|getreg
id|getreg
c_func
(paren
r_int
r_int
id|regnum
comma
r_int
r_int
op_star
id|val
comma
r_int
op_star
id|nat
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|switch_stack
op_star
id|sw
op_assign
(paren
r_struct
id|switch_stack
op_star
)paren
id|regs
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|addr
comma
op_star
id|unat
suffix:semicolon
r_if
c_cond
(paren
id|regnum
op_ge
id|IA64_FIRST_STACKED_GR
)paren
(brace
id|get_rse_reg
c_func
(paren
id|regs
comma
id|regnum
comma
id|val
comma
id|nat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * take care of r0 (read-only always evaluate to 0)&n;&t; */
r_if
c_cond
(paren
id|regnum
op_eq
l_int|0
)paren
(brace
op_star
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nat
)paren
op_star
id|nat
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now look at registers in [0-31] range and init correct UNAT&n;&t; */
r_if
c_cond
(paren
id|GR_IN_SW
c_func
(paren
id|regnum
)paren
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|sw
suffix:semicolon
id|unat
op_assign
op_amp
id|sw-&gt;ar_unat
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|regs
suffix:semicolon
id|unat
op_assign
op_amp
id|sw-&gt;caller_unat
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;addr_base=%lx offset=0x%x&bslash;n&quot;
comma
id|addr
comma
id|GR_OFFS
c_func
(paren
id|regnum
)paren
)paren
)paren
suffix:semicolon
id|addr
op_add_assign
id|GR_OFFS
c_func
(paren
id|regnum
)paren
suffix:semicolon
op_star
id|val
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * do it only when requested&n;&t; */
r_if
c_cond
(paren
id|nat
)paren
op_star
id|nat
op_assign
(paren
op_star
id|unat
op_rshift
(paren
id|addr
op_rshift
l_int|3
op_amp
l_int|0x3f
)paren
)paren
op_amp
l_int|0x1UL
suffix:semicolon
)brace
r_static
r_void
DECL|function|emulate_load_updates
id|emulate_load_updates
c_func
(paren
id|update_t
id|type
comma
id|load_store_t
op_star
id|ld
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|ifa
)paren
(brace
multiline_comment|/*&n;&t; * IMPORTANT: &n;&t; * Given the way we handle unaligned speculative loads, we should&n;&t; * not get to this point in the code but we keep this sanity check,&n;&t; * just in case.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_eq
l_int|1
op_logical_or
id|ld-&gt;x6_op
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;: register update on speculative load, error&bslash;n&quot;
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;unaligned reference on specualtive load with register update&bslash;n&quot;
comma
id|regs
comma
l_int|30
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * at this point, we know that the base register to update is valid i.e.,&n;&t; * it&squot;s not r0&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|UPD_IMMEDIATE
)paren
(brace
r_int
r_int
id|imm
suffix:semicolon
multiline_comment|/* &n;&t; &t; * Load +Imm: ldXZ r1=[r3],imm(9)&n;&t; &t; *&n;&t;&t; *&n;&t;   &t; * form imm9: [13:19] contain the first 7 bits&n;      &t;&t; */
id|imm
op_assign
id|ld-&gt;x
op_lshift
l_int|7
op_or
id|ld-&gt;imm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * sign extend (1+8bits) if m set&n;&t;&t; */
r_if
c_cond
(paren
id|ld-&gt;m
)paren
id|imm
op_or_assign
id|SIGN_EXT9
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ifa == r3 and we know that the NaT bit on r3 was clear so&n;&t;&t; * we can directly use ifa.&n;&t;&t; */
id|ifa
op_add_assign
id|imm
suffix:semicolon
id|setreg
c_func
(paren
id|ld-&gt;r3
comma
id|ifa
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ld.x=%d ld.m=%d imm=%ld r3=0x%lx&bslash;n&quot;
comma
id|ld-&gt;x
comma
id|ld-&gt;m
comma
id|imm
comma
id|ifa
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ld-&gt;m
)paren
(brace
r_int
r_int
id|r2
suffix:semicolon
r_int
id|nat_r2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Load +Reg Opcode: ldXZ r1=[r3],r2&n;&t;&t; *&n;&t;&t; * Note: that we update r3 even in the case of ldfX.a &n;&t;&t; * (where the load does not happen)&n;&t;&t; *&n;&t;&t; * The way the load algorithm works, we know that r3 does not&n;&t;&t; * have its NaT bit set (would have gotten NaT consumption&n;&t;&t; * before getting the unaligned fault). So we can use ifa &n;&t;&t; * which equals r3 at this point.&n;&t;&t; *&n;&t;&t; * IMPORTANT:&n;&t; &t; * The above statement holds ONLY because we know that we&n;&t;&t; * never reach this code when trying to do a ldX.s.&n;&t;&t; * If we ever make it to here on an ldfX.s then &n;&t;&t; */
id|getreg
c_func
(paren
id|ld-&gt;imm
comma
op_amp
id|r2
comma
op_amp
id|nat_r2
comma
id|regs
)paren
suffix:semicolon
id|ifa
op_add_assign
id|r2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * propagate Nat r2 -&gt; r3&n;&t;&t; */
id|setreg
c_func
(paren
id|ld-&gt;r3
comma
id|ifa
comma
id|nat_r2
comma
id|regs
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;imm=%d r2=%ld r3=0x%lx nat_r2=%d&bslash;n&quot;
comma
id|ld-&gt;imm
comma
id|r2
comma
id|ifa
comma
id|nat_r2
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|emulate_load_int
id|emulate_load_int
c_func
(paren
r_int
r_int
id|ifa
comma
id|load_store_t
op_star
id|ld
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|len
op_assign
l_int|1
op_lshift
id|ld-&gt;x6_sz
suffix:semicolon
multiline_comment|/*&n;&t; * the macro supposes sequential access (which is the case)&n;&t; * if the first byte is an invalid address we return here. Otherwise&n;&t; * there is a guard page at the top of the user&squot;s address page and &n;&t; * the first access would generate a NaT consumption fault and return&n;&t; * with a SIGSEGV, which is what we want.&n;&t; *&n;&t; * Note: the first argument is ignored &n;&t; */
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|ifa
comma
id|len
)paren
OL
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;verify area failed on %lx&bslash;n&quot;
comma
id|ifa
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * r0, as target, doesn&squot;t need to be checked because Illegal Instruction&n;&t; * faults have higher priority than unaligned faults.&n;&t; *&n;&t; * r0 cannot be found as the base as it would never generate an &n;&t; * unaligned reference.&n;&t; */
multiline_comment|/*&n;&t; * ldX.a we don&squot;t try to emulate anything but we must&n;&t; * invalidate the ALAT entry.&n;&t; * See comment below for explanation on how we handle ldX.a&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_ne
l_int|0x2
)paren
(brace
multiline_comment|/*&n;&t;&t; * we rely on the macros in unaligned.h for now i.e.,&n;&t;&t; * we let the compiler figure out how to read memory gracefully.&n;&t;&t; *&n;&t;&t; * We need this switch/case because the way the inline function&n;&t;&t; * works. The code is optimized by the compiler and looks like&n;&t;&t; * a single switch/case.&n;&t;&t; */
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|2
suffix:colon
id|val
op_assign
id|ia64_get_unaligned
c_func
(paren
(paren
r_void
op_star
)paren
id|ifa
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|val
op_assign
id|ia64_get_unaligned
c_func
(paren
(paren
r_void
op_star
)paren
id|ifa
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|val
op_assign
id|ia64_get_unaligned
c_func
(paren
(paren
r_void
op_star
)paren
id|ifa
comma
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;unknown size: x6=%d&bslash;n&quot;
comma
id|ld-&gt;x6_sz
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|setreg
c_func
(paren
id|ld-&gt;r1
comma
id|val
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for updates on any kind of loads&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;op
op_eq
l_int|0x5
op_logical_or
id|ld-&gt;m
)paren
id|emulate_load_updates
c_func
(paren
id|ld-&gt;op
op_eq
l_int|0x5
ques
c_cond
id|UPD_IMMEDIATE
suffix:colon
id|UPD_REG
comma
id|ld
comma
id|regs
comma
id|ifa
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * handling of various loads (based on EAS2.4):&n;&t; *&n;&t; * ldX.acq (ordered load):&n;&t; *&t;- acquire semantics would have been used, so force fence instead.&n;&t; *&n;&t; *&n;&t; * ldX.c.clr (check load and clear):&n;&t; *&t;- if we get to this handler, it&squot;s because the entry was not in the ALAT.&n;&t; *&t;  Therefore the operation reverts to a normal load&n;&t; *&n;&t; * ldX.c.nc (check load no clear):&n;&t; *&t;- same as previous one&n;&t; *&n;&t; * ldX.c.clr.acq (ordered check load and clear):&n;&t; *&t;- same as above for c.clr part. The load needs to have acquire semantics. So&n;&t; *&t;  we use the fence semantics which is stronger and thus ensures correctness.&n;&t; *&t;&n;&t; * ldX.a (advanced load):&n;&t; *&t;- suppose ldX.a r1=[r3]. If we get to the unaligned trap it&squot;s because the &n;&t; * &t;  address doesn&squot;t match requested size alignement. This means that we would &n;&t; *&t;  possibly need more than one load to get the result.&n;&t; *&n;&t; *&t;  The load part can be handled just like a normal load, however the difficult&n;&t; *&t;  part is to get the right thing into the ALAT. The critical piece of information&n;&t; * &t;  in the base address of the load &amp; size. To do that, a ld.a must be executed,&n;&t; *&t;  clearly any address can be pushed into the table by using ld1.a r1=[r3]. Now&n;&t; *&t;  if we use the same target register, we will be okay for the check.a instruction.&n;&t; *&t;  If we look at the store, basically a stX [r3]=r1 checks the ALAT  for any entry&n;&t; *&t;  which would overlap within [r3,r3+X] (the size of the load was store in the&n;&t; *&t;  ALAT). If such an entry is found the entry is invalidated. But this is not good&n;&t; *&t;  enough, take the following example:&n;&t; *&t;&t;r3=3&n;&t; *&t;&t;ld4.a r1=[r3]&n;&t; *&n;&t; *&t;  Could be emulated by doing:&n;&t; *&t;&t;ld1.a r1=[r3],1&n;&t; *&t;&t;store to temporary;&n;&t; *&t;&t;ld1.a r1=[r3],1&n;&t; *&t;&t;store &amp; shift to temporary;&n;&t; *&t;&t;ld1.a r1=[r3],1&n;&t; *&t;&t;store &amp; shift to temporary;&n;&t; *&t;&t;ld1.a r1=[r3]&n;&t; *&t;&t;store &amp; shift to temporary;&n;&t; * &t;&t;r1=temporary&n;&t; *&n;&t; *&t;  So int this case, you would get the right value is r1 but the wrong info in&n;&t; *&t;  the ALAT.  Notice that you could do it in reverse to finish with address 3&n;&t; *&t;  but you would still get the size wrong.  To get the size right, one needs to&n;&t; *&t;  execute exactly the same kind of load. You could do it from a aligned&n;&t; *&t;  temporary location, but you would get the address wrong.&n;&t; *&n;&t; *&t;  So no matter what, it is not possible to emulate an advanced load&n;&t; *&t;  correctly. But is that really critical ?&n;&t; *&n;&t; *&n;&t; *&t;  Now one has to look at how ld.a is used, one must either do a ld.c.* or&n;&t; *&t;  chck.a.* to reuse the value stored in the ALAT. Both can &quot;fail&quot; (meaning no&n;&t; *&t;  entry found in ALAT), and that&squot;s perfectly ok because:&n;&t; *&n;&t; *&t;&t;- ld.c.*, if the entry is not present a  normal load is executed&n;&t; *&t;&t;- chk.a.*, if the entry is not present, execution jumps to recovery code&n;&t; *&n;&t; *&t;  In either case, the load can be potentially retried in another form.&n;&t; *&n;&t; *&t;  So it&squot;s okay NOT to do any actual load on an unaligned ld.a. However the ALAT&n;&t; *&t;  must be invalidated for the register (so that&squot;s chck.a.*,ld.c.* don&squot;t pick up&n;&t; *&t;  a stale entry later) The register base update MUST also be performed.&n;&t; *&t;  &n;&t; *&t;  Now what is the content of the register and its NaT bit in the case we don&squot;t&n;&t; *&t;  do the load ?  EAS2.4, says (in case an actual load is needed)&n;&t; *&n;&t; *&t;&t;- r1 = [r3], Nat = 0 if succeeds&n;&t; *&t;&t;- r1 = 0 Nat = 0 if trying to access non-speculative memory&n;&t; *&n;&t; *&t;  For us, there is nothing to do, because both ld.c.* and chk.a.* are going to&n;&t; *&t;  retry and thus eventually reload the register thereby changing Nat and&n;&t; *&t;  register content.&n;&t; */
multiline_comment|/*&n;&t; * when the load has the .acq completer then &n;&t; * use ordering fence.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_eq
l_int|0x5
op_logical_or
id|ld-&gt;x6_op
op_eq
l_int|0xa
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * invalidate ALAT entry in case of advanced load&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_eq
l_int|0x2
)paren
id|invala_gr
c_func
(paren
id|ld-&gt;r1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|emulate_store_int
id|emulate_store_int
c_func
(paren
r_int
r_int
id|ifa
comma
id|load_store_t
op_star
id|ld
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|r2
suffix:semicolon
r_int
r_int
id|len
op_assign
l_int|1
op_lshift
id|ld-&gt;x6_sz
suffix:semicolon
multiline_comment|/*&n;&t; * the macro supposes sequential access (which is the case)&n;&t; * if the first byte is an invalid address we return here. Otherwise&n;&t; * there is a guard page at the top of the user&squot;s address page and &n;&t; * the first access would generate a NaT consumption fault and return&n;&t; * with a SIGSEGV, which is what we want.&n;&t; *&n;&t; * Note: the first argument is ignored &n;&t; */
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|ifa
comma
id|len
)paren
OL
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;verify area failed on %lx&bslash;n&quot;
comma
id|ifa
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if we get to this handler, Nat bits on both r3 and r2 have already&n;&t; * been checked. so we don&squot;t need to do it&n;&t; *&n;&t; * extract the value to be stored&n;&t; */
id|getreg
c_func
(paren
id|ld-&gt;imm
comma
op_amp
id|r2
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we rely on the macros in unaligned.h for now i.e.,&n;&t; * we let the compiler figure out how to read memory gracefully.&n;&t; *&n;&t; * We need this switch/case because the way the inline function&n;&t; * works. The code is optimized by the compiler and looks like&n;&t; * a single switch/case.&n;&t; */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;st%d [%lx]=%lx&bslash;n&quot;
comma
id|len
comma
id|ifa
comma
id|r2
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|2
suffix:colon
id|ia64_put_unaligned
c_func
(paren
id|r2
comma
(paren
r_void
op_star
)paren
id|ifa
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ia64_put_unaligned
c_func
(paren
id|r2
comma
(paren
r_void
op_star
)paren
id|ifa
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|ia64_put_unaligned
c_func
(paren
id|r2
comma
(paren
r_void
op_star
)paren
id|ifa
comma
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;unknown size: x6=%d&bslash;n&quot;
comma
id|ld-&gt;x6_sz
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * stX [r3]=r2,imm(9)&n;&t; *&n;&t; * NOTE:&n;&t; * ld-&gt;r3 can never be r0, because r0 would not generate an &n;&t; * unaligned access.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;op
op_eq
l_int|0x5
)paren
(brace
r_int
r_int
id|imm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * form imm9: [12:6] contain first 7bits&n;&t;&t; */
id|imm
op_assign
id|ld-&gt;x
op_lshift
l_int|7
op_or
id|ld-&gt;r1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * sign extend (8bits) if m set&n;&t;&t; */
r_if
c_cond
(paren
id|ld-&gt;m
)paren
id|imm
op_or_assign
id|SIGN_EXT9
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ifa == r3 (NaT is necessarily cleared)&n;&t;&t; */
id|ifa
op_add_assign
id|imm
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;imm=%lx r3=%lx&bslash;n&quot;
comma
id|imm
comma
id|ifa
)paren
)paren
suffix:semicolon
id|setreg
c_func
(paren
id|ld-&gt;r3
comma
id|ifa
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we don&squot;t have alat_invalidate_multiple() so we need&n;&t; * to do the complete flush :-&lt;&lt;&n;&t; */
id|ia64_invala
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stX.rel: use fence instead of release&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_eq
l_int|0xd
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * floating point operations sizes in bytes&n; */
DECL|variable|float_fsz
r_static
r_const
r_int
r_int
id|float_fsz
(braket
l_int|4
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_inline
r_void
DECL|function|mem2float_extended
id|mem2float_extended
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldfe f6=[%0];; stf.spill [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|mem2float_integer
id|mem2float_integer
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldf8 f6=[%0];; stf.spill [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|mem2float_single
id|mem2float_single
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldfs f6=[%0];; stf.spill [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|mem2float_double
id|mem2float_double
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldfd f6=[%0];; stf.spill [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|float2mem_extended
id|float2mem_extended
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldf.fill f6=[%0];; stfe [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|float2mem_integer
id|float2mem_integer
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldf.fill f6=[%0];; stf8 [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|float2mem_single
id|float2mem_single
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldf.fill f6=[%0];; stfs [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|float2mem_double
id|float2mem_double
c_func
(paren
r_struct
id|ia64_fpreg
op_star
id|init
comma
r_struct
id|ia64_fpreg
op_star
id|final
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;ldf.fill f6=[%0];; stfd [%1]=f6&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|init
)paren
comma
l_string|&quot;r&quot;
(paren
id|final
)paren
suffix:colon
l_string|&quot;f6&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|emulate_load_floatpair
id|emulate_load_floatpair
c_func
(paren
r_int
r_int
id|ifa
comma
id|load_store_t
op_star
id|ld
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ia64_fpreg
id|fpr_init
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|ia64_fpreg
id|fpr_final
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|len
op_assign
id|float_fsz
(braket
id|ld-&gt;x6_sz
)braket
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|ifa
comma
id|len
op_lshift
l_int|1
)paren
OL
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;verify area failed on %lx&bslash;n&quot;
comma
id|ifa
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * fr0 &amp; fr1 don&squot;t need to be checked because Illegal Instruction&n;&t; * faults have higher priority than unaligned faults.&n;&t; *&n;&t; * r0 cannot be found as the base as it would never generate an &n;&t; * unaligned reference.&n;&t; */
multiline_comment|/* &n;&t; * make sure we get clean buffers&n;&t; */
id|memset
c_func
(paren
op_amp
id|fpr_init
comma
l_int|0
comma
r_sizeof
(paren
id|fpr_init
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|fpr_final
comma
l_int|0
comma
r_sizeof
(paren
id|fpr_final
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ldfpX.a: we don&squot;t try to emulate anything but we must&n;&t; * invalidate the ALAT entry and execute updates, if any.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_ne
l_int|0x2
)paren
(brace
multiline_comment|/*&n;&t;&t; * does the unaligned access&n;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|0
)braket
comma
(paren
r_void
op_star
)paren
id|ifa
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|1
)braket
comma
(paren
r_void
op_star
)paren
(paren
id|ifa
op_plus
id|len
)paren
comma
id|len
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ld.r1=%d ld.imm=%d x6_sz=%d&bslash;n&quot;
comma
id|ld-&gt;r1
comma
id|ld-&gt;imm
comma
id|ld-&gt;x6_sz
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_UNALIGNED_TRAP
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
op_amp
id|fpr_init
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpr_init= &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_lshift
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * XXX fixme&n;&t;&t; * Could optimize inlines by using ldfpX &amp; 2 spills &n;&t;&t; */
r_switch
c_cond
(paren
id|ld-&gt;x6_sz
)paren
(brace
r_case
l_int|0
suffix:colon
id|mem2float_extended
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|0
)braket
comma
op_amp
id|fpr_final
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|mem2float_extended
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|1
)braket
comma
op_amp
id|fpr_final
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|mem2float_integer
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|0
)braket
comma
op_amp
id|fpr_final
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|mem2float_integer
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|1
)braket
comma
op_amp
id|fpr_final
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|mem2float_single
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|0
)braket
comma
op_amp
id|fpr_final
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|mem2float_single
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|1
)braket
comma
op_amp
id|fpr_final
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|mem2float_double
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|0
)braket
comma
op_amp
id|fpr_final
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|mem2float_double
c_func
(paren
op_amp
id|fpr_init
(braket
l_int|1
)braket
comma
op_amp
id|fpr_final
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_UNALIGNED_TRAP
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
op_amp
id|fpr_final
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpr_final= &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_lshift
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * XXX fixme&n;&t;&t; *&n;&t;&t; * A possible optimization would be to drop fpr_final and directly&n;&t;&t; * use the storage from the saved context i.e., the actual final&n;&t;&t; * destination (pt_regs, switch_stack or thread structure).&n;&t;&t; */
id|setfpreg
c_func
(paren
id|ld-&gt;r1
comma
op_amp
id|fpr_final
(braket
l_int|0
)braket
comma
id|regs
)paren
suffix:semicolon
id|setfpreg
c_func
(paren
id|ld-&gt;imm
comma
op_amp
id|fpr_final
(braket
l_int|1
)braket
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for updates: only immediate updates are available for this&n;&t; * instruction.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;m
)paren
(brace
multiline_comment|/*&n;&t;&t; * the immediate is implicit given the ldsz of the operation:&n;&t;&t; * single: 8 (2x4) and for  all others it&squot;s 16 (2x8)&n;&t;&t; */
id|ifa
op_add_assign
id|len
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * IMPORTANT: &n;&t;&t; * the fact that we force the NaT of r3 to zero is ONLY valid&n;&t;&t; * as long as we don&squot;t come here with a ldfpX.s.&n;&t;&t; * For this reason we keep this sanity check&n;&t;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_eq
l_int|1
op_logical_or
id|ld-&gt;x6_op
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: register update on speculative load pair, error&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
id|setreg
c_func
(paren
id|ld-&gt;r3
comma
id|ifa
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Invalidate ALAT entries, if any, for both registers.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_eq
l_int|0x2
)paren
(brace
id|invala_fr
c_func
(paren
id|ld-&gt;r1
)paren
suffix:semicolon
id|invala_fr
c_func
(paren
id|ld-&gt;imm
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|emulate_load_float
id|emulate_load_float
c_func
(paren
r_int
r_int
id|ifa
comma
id|load_store_t
op_star
id|ld
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ia64_fpreg
id|fpr_init
suffix:semicolon
r_struct
id|ia64_fpreg
id|fpr_final
suffix:semicolon
r_int
r_int
id|len
op_assign
id|float_fsz
(braket
id|ld-&gt;x6_sz
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * check for load pair because our masking scheme is not fine grain enough&n;&t;if (ld-&gt;x == 1) return emulate_load_floatpair(ifa,ld,regs);&n;&t; */
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|ifa
comma
id|len
)paren
OL
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;verify area failed on %lx&bslash;n&quot;
comma
id|ifa
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * fr0 &amp; fr1 don&squot;t need to be checked because Illegal Instruction&n;&t; * faults have higher priority than unaligned faults.&n;&t; *&n;&t; * r0 cannot be found as the base as it would never generate an &n;&t; * unaligned reference.&n;&t; */
multiline_comment|/* &n;&t; * make sure we get clean buffers&n;&t; */
id|memset
c_func
(paren
op_amp
id|fpr_init
comma
l_int|0
comma
r_sizeof
(paren
id|fpr_init
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|fpr_final
comma
l_int|0
comma
r_sizeof
(paren
id|fpr_final
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ldfX.a we don&squot;t try to emulate anything but we must&n;&t; * invalidate the ALAT entry.&n;&t; * See comments in ldX for descriptions on how the various loads are handled.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_ne
l_int|0x2
)paren
(brace
multiline_comment|/*&n;&t;&t; * does the unaligned access&n;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|fpr_init
comma
(paren
r_void
op_star
)paren
id|ifa
comma
id|len
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ld.r1=%d x6_sz=%d&bslash;n&quot;
comma
id|ld-&gt;r1
comma
id|ld-&gt;x6_sz
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_UNALIGNED_TRAP
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
op_amp
id|fpr_init
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpr_init= &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * we only do something for x6_op={0,8,9}&n;&t;&t; */
r_switch
c_cond
(paren
id|ld-&gt;x6_sz
)paren
(brace
r_case
l_int|0
suffix:colon
id|mem2float_extended
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|mem2float_integer
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|mem2float_single
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|mem2float_double
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_UNALIGNED_TRAP
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
op_amp
id|fpr_final
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpr_final= &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * XXX fixme&n;&t;&t; *&n;&t;&t; * A possible optimization would be to drop fpr_final and directly&n;&t;&t; * use the storage from the saved context i.e., the actual final&n;&t;&t; * destination (pt_regs, switch_stack or thread structure).&n;&t;&t; */
id|setfpreg
c_func
(paren
id|ld-&gt;r1
comma
op_amp
id|fpr_final
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for updates on any loads&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;op
op_eq
l_int|0x7
op_logical_or
id|ld-&gt;m
)paren
id|emulate_load_updates
c_func
(paren
id|ld-&gt;op
op_eq
l_int|0x7
ques
c_cond
id|UPD_IMMEDIATE
suffix:colon
id|UPD_REG
comma
id|ld
comma
id|regs
comma
id|ifa
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * invalidate ALAT entry in case of advanced floating point loads&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;x6_op
op_eq
l_int|0x2
)paren
id|invala_fr
c_func
(paren
id|ld-&gt;r1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|emulate_store_float
id|emulate_store_float
c_func
(paren
r_int
r_int
id|ifa
comma
id|load_store_t
op_star
id|ld
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ia64_fpreg
id|fpr_init
suffix:semicolon
r_struct
id|ia64_fpreg
id|fpr_final
suffix:semicolon
r_int
r_int
id|len
op_assign
id|float_fsz
(braket
id|ld-&gt;x6_sz
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * the macro supposes sequential access (which is the case)&n;&t; * if the first byte is an invalid address we return here. Otherwise&n;&t; * there is a guard page at the top of the user&squot;s address page and &n;&t; * the first access would generate a NaT consumption fault and return&n;&t; * with a SIGSEGV, which is what we want.&n;&t; *&n;&t; * Note: the first argument is ignored &n;&t; */
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|ifa
comma
id|len
)paren
OL
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;verify area failed on %lx&bslash;n&quot;
comma
id|ifa
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * make sure we get clean buffers&n;&t; */
id|memset
c_func
(paren
op_amp
id|fpr_init
comma
l_int|0
comma
r_sizeof
(paren
id|fpr_init
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|fpr_final
comma
l_int|0
comma
r_sizeof
(paren
id|fpr_final
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if we get to this handler, Nat bits on both r3 and r2 have already&n;&t; * been checked. so we don&squot;t need to do it&n;&t; *&n;&t; * extract the value to be stored&n;&t; */
id|getfpreg
c_func
(paren
id|ld-&gt;imm
comma
op_amp
id|fpr_init
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * during this step, we extract the spilled registers from the saved&n;&t; * context i.e., we refill. Then we store (no spill) to temporary&n;&t; * aligned location&n;&t; */
r_switch
c_cond
(paren
id|ld-&gt;x6_sz
)paren
(brace
r_case
l_int|0
suffix:colon
id|float2mem_extended
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|float2mem_integer
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|float2mem_single
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|float2mem_double
c_func
(paren
op_amp
id|fpr_init
comma
op_amp
id|fpr_final
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ld.r1=%d x6_sz=%d&bslash;n&quot;
comma
id|ld-&gt;r1
comma
id|ld-&gt;x6_sz
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_UNALIGNED_TRAP
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
op_amp
id|fpr_init
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpr_init= &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
op_amp
id|fpr_final
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpr_final= &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * does the unaligned store&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|ifa
comma
op_amp
id|fpr_final
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stfX [r3]=r2,imm(9)&n;&t; *&n;&t; * NOTE:&n;&t; * ld-&gt;r3 can never be r0, because r0 would not generate an &n;&t; * unaligned access.&n;&t; */
r_if
c_cond
(paren
id|ld-&gt;op
op_eq
l_int|0x7
)paren
(brace
r_int
r_int
id|imm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * form imm9: [12:6] contain first 7bits&n;&t;&t; */
id|imm
op_assign
id|ld-&gt;x
op_lshift
l_int|7
op_or
id|ld-&gt;r1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * sign extend (8bits) if m set&n;&t;&t; */
r_if
c_cond
(paren
id|ld-&gt;m
)paren
id|imm
op_or_assign
id|SIGN_EXT9
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ifa == r3 (NaT is necessarily cleared)&n;&t;&t; */
id|ifa
op_add_assign
id|imm
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;imm=%lx r3=%lx&bslash;n&quot;
comma
id|imm
comma
id|ifa
)paren
)paren
suffix:semicolon
id|setreg
c_func
(paren
id|ld-&gt;r3
comma
id|ifa
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we don&squot;t have alat_invalidate_multiple() so we need&n;&t; * to do the complete flush :-&lt;&lt;&n;&t; */
id|ia64_invala
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|ia64_handle_unaligned
id|ia64_handle_unaligned
c_func
(paren
r_int
r_int
id|ifa
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_static
r_int
r_int
id|unalign_count
suffix:semicolon
r_static
r_int
id|last_time
suffix:semicolon
r_struct
id|ia64_psr
op_star
id|ipsr
op_assign
id|ia64_psr
c_func
(paren
id|regs
)paren
suffix:semicolon
r_int
r_int
op_star
id|bundle_addr
suffix:semicolon
r_int
r_int
id|opcode
suffix:semicolon
r_int
r_int
id|op
suffix:semicolon
id|load_store_t
op_star
id|insn
suffix:semicolon
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Unaligned references in the kernel could come from unaligned&n;&t; *   arguments to system calls.  We fault the user process in&n;&t; *   these cases and panic the kernel otherwise (the kernel should&n;&t; *   be fixed to not make unaligned accesses).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_const
r_struct
id|exception_table_entry
op_star
id|fix
suffix:semicolon
id|fix
op_assign
id|search_exception_table
c_func
(paren
id|regs-&gt;cr_iip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fix
)paren
(brace
id|regs-&gt;r8
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|fix-&gt;skip
op_amp
l_int|1
)paren
(brace
id|regs-&gt;r9
op_assign
l_int|0
suffix:semicolon
)brace
id|regs-&gt;cr_iip
op_add_assign
(paren
(paren
r_int
)paren
id|fix-&gt;skip
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
id|regs-&gt;cr_ipsr
op_and_assign
op_complement
id|IA64_PSR_RI
suffix:semicolon
multiline_comment|/* clear exception slot number */
r_return
suffix:semicolon
)brace
id|die_if_kernel
c_func
(paren
l_string|&quot;Unaligned reference while in kernel&bslash;n&quot;
comma
id|regs
comma
l_int|30
)paren
suffix:semicolon
multiline_comment|/* NOT_REACHED */
)brace
multiline_comment|/*&n;&t; * For now, we don&squot;t support user processes running big-endian&n;&t; * which do unaligned accesses&n;&t; */
r_if
c_cond
(paren
id|ia64_psr
c_func
(paren
id|regs
)paren
op_member_access_from_pointer
id|be
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(%d): big-endian unaligned access %016lx (ip=%016lx) not &quot;
l_string|&quot;yet supported&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|ifa
comma
id|regs-&gt;cr_iip
op_plus
id|ipsr-&gt;ri
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|BUS_ADRALN
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|ifa
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_UAC_SIGBUS
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
id|si.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|BUS_ADRALN
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|ifa
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|current-&gt;thread.flags
op_amp
id|IA64_THREAD_UAC_NOPRINT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make sure we log the unaligned access, so that&n;&t;&t; * user/sysadmin can notice it and eventually fix the&n;&t;&t; * program.&n;&t;&t; *&n;&t;&t; * We don&squot;t want to do that for every access so we&n;&t;&t; * pace it with jiffies.&n;&t;&t; */
r_if
c_cond
(paren
id|unalign_count
OG
l_int|5
op_logical_and
id|jiffies
op_minus
id|last_time
OG
l_int|5
op_star
id|HZ
)paren
id|unalign_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|unalign_count
OL
l_int|5
)paren
(brace
r_char
id|buf
(braket
l_int|200
)braket
suffix:semicolon
multiline_comment|/* comm[] is at most 16 bytes... */
r_int
id|len
suffix:semicolon
id|last_time
op_assign
id|jiffies
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s(%d): unaligned access to 0x%016lx, ip=0x%016lx&bslash;n&bslash;r&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|ifa
comma
id|regs-&gt;cr_iip
op_plus
id|ipsr-&gt;ri
)paren
suffix:semicolon
id|tty_write_message
c_func
(paren
id|current-&gt;tty
comma
id|buf
)paren
suffix:semicolon
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* drop &squot;&bslash;r&squot; */
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* guard against command names containing %s!! */
)brace
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;iip=%lx ifa=%lx isr=%lx&bslash;n&quot;
comma
id|regs-&gt;cr_iip
comma
id|ifa
comma
id|regs-&gt;cr_ipsr
)paren
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ISR.ei=%d ISR.sp=%d&bslash;n&quot;
comma
id|ipsr-&gt;ri
comma
id|ipsr-&gt;it
)paren
)paren
suffix:semicolon
id|bundle_addr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|regs-&gt;cr_iip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * extract the instruction from the bundle given the slot number&n;&t; */
r_switch
c_cond
(paren
id|ipsr-&gt;ri
)paren
(brace
r_case
l_int|0
suffix:colon
id|op
op_assign
op_star
id|bundle_addr
op_rshift
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|op
op_assign
op_star
id|bundle_addr
op_rshift
l_int|46
op_or
(paren
op_star
(paren
id|bundle_addr
op_plus
l_int|1
)paren
op_amp
l_int|0x7fffff
)paren
op_lshift
l_int|18
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|op
op_assign
op_star
(paren
id|bundle_addr
op_plus
l_int|1
)paren
op_rshift
l_int|23
suffix:semicolon
r_break
suffix:semicolon
)brace
id|insn
op_assign
(paren
id|load_store_t
op_star
)paren
op_amp
id|op
suffix:semicolon
id|opcode
op_assign
id|op
op_amp
id|IA64_OPCODE_MASK
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;opcode=%lx ld.qp=%d ld.r1=%d ld.imm=%d ld.r3=%d ld.x=%d ld.hint=%d &quot;
l_string|&quot;ld.x6=0x%x ld.m=%d ld.op=%d&bslash;n&quot;
comma
id|opcode
comma
id|insn-&gt;qp
comma
id|insn-&gt;r1
comma
id|insn-&gt;imm
comma
id|insn-&gt;r3
comma
id|insn-&gt;x
comma
id|insn-&gt;hint
comma
id|insn-&gt;x6_sz
comma
id|insn-&gt;m
comma
id|insn-&gt;op
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;  &t; * IMPORTANT:&n;&t; * Notice that the swictch statement DOES not cover all possible instructions&n;&t; * that DO generate unaligned references. This is made on purpose because for some&n;&t; * instructions it DOES NOT make sense to try and emulate the access. Sometimes it&n;&t; * is WRONG to try and emulate. Here is a list of instruction we don&squot;t emulate i.e.,&n;&t; * the program will get a signal and die:&n;&t; *&n;&t; *&t;load/store:&n;&t; *&t;&t;- ldX.spill&n;&t; *&t;&t;- stX.spill&n;&t; * &t;Reason: RNATs are based on addresses&n;&t; *&n;&t; *&t;synchronization:&n;&t; *&t;&t;- cmpxchg&n;&t; *&t;&t;- fetchadd&n;&t; *&t;&t;- xchg&n;&t; * &t;Reason: ATOMIC operations cannot be emulated properly using multiple &n;&t; * &t;        instructions.&n;&t; *&n;&t; *&t;speculative loads:&n;&t; *&t;&t;- ldX.sZ&n;&t; *&t;Reason: side effects, code must be ready to deal with failure so simpler &n;&t; * &t;&t;to let the load fail.&n;&t; * ---------------------------------------------------------------------------------&n;&t; * XXX fixme&n;&t; *&n;&t; * I would like to get rid of this switch case and do something&n;&t; * more elegant.&n;&t; */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|LDS_OP
suffix:colon
r_case
id|LDSA_OP
suffix:colon
r_case
id|LDS_IMM_OP
suffix:colon
r_case
id|LDSA_IMM_OP
suffix:colon
r_case
id|LDFS_OP
suffix:colon
r_case
id|LDFSA_OP
suffix:colon
r_case
id|LDFS_IMM_OP
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * The instruction will be retried with defered exceptions&n;&t;&t;&t; * turned on, and we should get Nat bit installed&n;&t;&t;&t; *&n;&t;&t;&t; * IMPORTANT:&n;&t;&t;&t; * When PSR_ED is set, the register &amp; immediate update&n;&t;&t;&t; * forms are actually executed even though the operation&n;&t;&t;&t; * failed. So we don&squot;t need to take care of this.&n;&t;&t;&t; */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;forcing PSR_ED&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|regs-&gt;cr_ipsr
op_or_assign
id|IA64_PSR_ED
suffix:semicolon
r_return
suffix:semicolon
r_case
id|LD_OP
suffix:colon
r_case
id|LDA_OP
suffix:colon
r_case
id|LDBIAS_OP
suffix:colon
r_case
id|LDACQ_OP
suffix:colon
r_case
id|LDCCLR_OP
suffix:colon
r_case
id|LDCNC_OP
suffix:colon
r_case
id|LDCCLRACQ_OP
suffix:colon
r_case
id|LD_IMM_OP
suffix:colon
r_case
id|LDA_IMM_OP
suffix:colon
r_case
id|LDBIAS_IMM_OP
suffix:colon
r_case
id|LDACQ_IMM_OP
suffix:colon
r_case
id|LDCCLR_IMM_OP
suffix:colon
r_case
id|LDCNC_IMM_OP
suffix:colon
r_case
id|LDCCLRACQ_IMM_OP
suffix:colon
id|ret
op_assign
id|emulate_load_int
c_func
(paren
id|ifa
comma
id|insn
comma
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ST_OP
suffix:colon
r_case
id|STREL_OP
suffix:colon
r_case
id|ST_IMM_OP
suffix:colon
r_case
id|STREL_IMM_OP
suffix:colon
id|ret
op_assign
id|emulate_store_int
c_func
(paren
id|ifa
comma
id|insn
comma
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LDF_OP
suffix:colon
r_case
id|LDFA_OP
suffix:colon
r_case
id|LDFCCLR_OP
suffix:colon
r_case
id|LDFCNC_OP
suffix:colon
r_case
id|LDF_IMM_OP
suffix:colon
r_case
id|LDFA_IMM_OP
suffix:colon
r_case
id|LDFCCLR_IMM_OP
suffix:colon
r_case
id|LDFCNC_IMM_OP
suffix:colon
id|ret
op_assign
id|insn-&gt;x
ques
c_cond
id|emulate_load_floatpair
c_func
(paren
id|ifa
comma
id|insn
comma
id|regs
)paren
suffix:colon
id|emulate_load_float
c_func
(paren
id|ifa
comma
id|insn
comma
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STF_OP
suffix:colon
r_case
id|STF_IMM_OP
suffix:colon
id|ret
op_assign
id|emulate_store_float
c_func
(paren
id|ifa
comma
id|insn
comma
id|regs
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ret=%d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
id|si.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|BUS_ADRALN
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|ifa
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t; &t; * given today&squot;s architecture this case is not likely to happen&n;&t; &t; * because a memory access instruction (M) can never be in the &n;&t; &t; * last slot of a bundle. But let&squot;s keep it for  now.&n;&t; &t; */
r_if
c_cond
(paren
id|ipsr-&gt;ri
op_eq
l_int|2
)paren
id|regs-&gt;cr_iip
op_add_assign
l_int|16
suffix:semicolon
id|ipsr-&gt;ri
op_assign
op_increment
id|ipsr-&gt;ri
op_amp
l_int|3
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;ipsr-&gt;ri=%d iip=%lx&bslash;n&quot;
comma
id|ipsr-&gt;ri
comma
id|regs-&gt;cr_iip
)paren
)paren
suffix:semicolon
)brace
eof
