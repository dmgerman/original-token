multiline_comment|/*&n; * palinfo.c&n; *&n; * Prints processor specific information reported by PAL.&n; * This code is based on specification of PAL as of the&n; * Intel IA-64 Architecture Software Developer&squot;s Manual v1.0.&n; *&n; * &n; * Copyright (C) 2000 Hewlett-Packard Co&n; * Copyright (C) 2000 Stephane Eranian &lt;eranian@hpl.hp.com&gt;&n; * &n; * 05/26/2000&t;S.Eranian&t;initial release&n; * 08/21/2000&t;S.Eranian&t;updated to July 2000 PAL specs&n; *&n; * ISSUES:&n; *&t;- as of 2.2.9/2.2.12, the following values are still wrong&n; *&t;&t;PAL_VM_SUMMARY: key &amp; rid sizes&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#if defined(MODVERSIONS)
macro_line|#include &lt;linux/modversions.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/pal.h&gt;
macro_line|#include &lt;asm/sal.h&gt;
macro_line|#include &lt;asm/efi.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#ifdef CONFIG_SMP
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#endif
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Stephane Eranian &lt;eranian@hpl.hp.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;/proc interface to IA-64 PAL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Hope to get rid of this one in a near future&n;*/
DECL|macro|IA64_PAL_VERSION_BUG
mdefine_line|#define IA64_PAL_VERSION_BUG&t;&t;1
DECL|macro|PALINFO_VERSION
mdefine_line|#define PALINFO_VERSION &quot;0.3&quot;
macro_line|#ifdef CONFIG_SMP
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i) (cpu_online_map &amp; (1UL &lt;&lt; i))
macro_line|#else
DECL|macro|cpu_is_online
mdefine_line|#define cpu_is_online(i)&t;1
macro_line|#endif
DECL|typedef|palinfo_func_t
r_typedef
r_int
(paren
op_star
id|palinfo_func_t
)paren
(paren
r_char
op_star
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* name of the proc entry */
DECL|member|proc_read
id|palinfo_func_t
id|proc_read
suffix:semicolon
multiline_comment|/* function to call for reading */
DECL|member|entry
r_struct
id|proc_dir_entry
op_star
id|entry
suffix:semicolon
multiline_comment|/* registered entry (removal) */
DECL|typedef|palinfo_entry_t
)brace
id|palinfo_entry_t
suffix:semicolon
multiline_comment|/*&n; *  A bunch of string array to get pretty printing&n; */
DECL|variable|cache_types
r_static
r_char
op_star
id|cache_types
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
multiline_comment|/* not used */
l_string|&quot;Instruction&quot;
comma
l_string|&quot;Data&quot;
comma
l_string|&quot;Data/Instruction&quot;
multiline_comment|/* unified */
)brace
suffix:semicolon
DECL|variable|cache_mattrib
r_static
r_const
r_char
op_star
id|cache_mattrib
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|cache_st_hints
r_static
r_const
r_char
op_star
id|cache_st_hints
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|cache_ld_hints
r_static
r_const
r_char
op_star
id|cache_ld_hints
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|rse_hints
r_static
r_const
r_char
op_star
id|rse_hints
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|macro|RSE_HINTS_COUNT
mdefine_line|#define RSE_HINTS_COUNT (sizeof(rse_hints)/sizeof(const char *))
multiline_comment|/*&n; * The current revision of the Volume 2 (July 2000) of &n; * IA-64 Architecture Software Developer&squot;s Manual is wrong.&n; * Table 4-10 has invalid information concerning the ma field:&n; * Correct table is:&n; *      bit 0 - 001 - UC&n; *      bit 4 - 100 - UC&n; *      bit 5 - 101 - UCE&n; *      bit 6 - 110 - WC&n; *      bit 7 - 111 - NatPage &n; */
DECL|variable|mem_attrib
r_static
r_const
r_char
op_star
id|mem_attrib
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; * Take a 64bit vector and produces a string such that&n; * if bit n is set then 2^n in clear text is generated. The adjustment&n; * to the right unit is also done.&n; *&n; * Input:&n; *&t;- a pointer to a buffer to hold the string&n; * &t;- a 64-bit vector&n; * Ouput:&n; *&t;- a pointer to the end of the buffer&n; *&n; */
r_static
r_char
op_star
DECL|function|bitvector_process
id|bitvector_process
c_func
(paren
r_char
op_star
id|p
comma
id|u64
id|vector
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_const
r_char
op_star
id|units
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
comma
id|j
op_assign
id|i
op_div
l_int|10
)paren
(brace
r_if
c_cond
(paren
id|vector
op_amp
l_int|0x1
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d%s &quot;
comma
l_int|1
op_lshift
(paren
id|i
op_minus
id|j
op_star
l_int|10
)paren
comma
id|units
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
id|vector
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * Take a 64bit vector and produces a string such that&n; * if bit n is set then register n is present. The function&n; * takes into account consecutive registers and prints out ranges.&n; *&n; * Input:&n; *&t;- a pointer to a buffer to hold the string&n; * &t;- a 64-bit vector&n; * Ouput:&n; *&t;- a pointer to the end of the buffer&n; *&n; */
r_static
r_char
op_star
DECL|function|bitregister_process
id|bitregister_process
c_func
(paren
r_char
op_star
id|p
comma
id|u64
op_star
id|reg_info
comma
r_int
id|max
)paren
(brace
r_int
id|i
comma
id|begin
comma
id|skip
op_assign
l_int|0
suffix:semicolon
id|u64
id|value
op_assign
id|reg_info
(braket
l_int|0
)braket
suffix:semicolon
id|value
op_rshift_assign
id|i
op_assign
id|begin
op_assign
id|ffs
c_func
(paren
id|value
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|64
)paren
op_eq
l_int|0
)paren
id|value
op_assign
op_star
op_increment
id|reg_info
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_amp
l_int|0x1
)paren
op_eq
l_int|0
op_logical_and
id|skip
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|begin
op_le
id|i
op_minus
l_int|2
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d-%d &quot;
comma
id|begin
comma
id|i
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d &quot;
comma
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
id|begin
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|value
op_amp
l_int|0x1
)paren
op_logical_and
id|skip
op_eq
l_int|1
)paren
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|i
suffix:semicolon
)brace
id|value
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|begin
OG
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|begin
OL
l_int|127
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d-127&quot;
comma
id|begin
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;127&quot;
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
r_static
r_int
DECL|function|power_info
id|power_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
id|s64
id|status
suffix:semicolon
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|halt_info_buffer
(braket
l_int|8
)braket
suffix:semicolon
id|pal_power_mgmt_info_u_t
op_star
id|halt_info
op_assign
(paren
id|pal_power_mgmt_info_u_t
op_star
)paren
id|halt_info_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|status
op_assign
id|ia64_pal_halt_info
c_func
(paren
id|halt_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|halt_info
(braket
id|i
)braket
dot
id|pal_power_mgmt_info_s.im
op_eq
l_int|1
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Power level %d:&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tentry_latency       : %d cycles&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;texit_latency        : %d cycles&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tpower consumption   : %d mW&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tCache+TLB coherency : %s&bslash;n&quot;
comma
id|i
comma
id|halt_info
(braket
id|i
)braket
dot
id|pal_power_mgmt_info_s.entry_latency
comma
id|halt_info
(braket
id|i
)braket
dot
id|pal_power_mgmt_info_s.exit_latency
comma
id|halt_info
(braket
id|i
)braket
dot
id|pal_power_mgmt_info_s.power_consumption
comma
id|halt_info
(braket
id|i
)braket
dot
id|pal_power_mgmt_info_s.co
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Power level %d: not implemented&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|cache_info
id|cache_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|levels
comma
id|unique_caches
suffix:semicolon
id|pal_cache_config_info_t
id|cci
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
id|s64
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_cache_summary
c_func
(paren
op_amp
id|levels
comma
op_amp
id|unique_caches
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ia64_pal_cache_summary=%ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Cache levels  : %ld&bslash;n&quot;
"&bslash;"
l_string|&quot;Unique caches : %ld&bslash;n&bslash;n&quot;
comma
id|levels
comma
id|unique_caches
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|levels
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|2
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
multiline_comment|/* even without unification some level may not be present */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_cache_config_info
c_func
(paren
id|i
comma
id|j
comma
op_amp
id|cci
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s Cache level %d:&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tSize           : %ld bytes&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tAttributes     : &quot;
comma
id|cache_types
(braket
id|j
op_plus
id|cci.pcci_unified
)braket
comma
id|i
op_plus
l_int|1
comma
id|cci.pcci_cache_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cci.pcci_unified
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Unified &quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|cache_mattrib
(braket
id|cci.pcci_cache_attr
)braket
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;tAssociativity  : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tLine size      : %d bytes&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tStride         : %d bytes&bslash;n&quot;
comma
id|cci.pcci_assoc
comma
l_int|1
op_lshift
id|cci.pcci_line_size
comma
l_int|1
op_lshift
id|cci.pcci_stride
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|1
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;tStore latency  : N/A&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;tStore latency  : %d cycle(s)&bslash;n&quot;
comma
id|cci.pcci_st_latency
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;tLoad latency   : %d cycle(s)&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tStore hints    : &quot;
comma
id|cci.pcci_ld_latency
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|8
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cci.pcci_st_hints
op_amp
l_int|0x1
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;[%s]&quot;
comma
id|cache_st_hints
(braket
id|k
)braket
)paren
suffix:semicolon
id|cci.pcci_st_hints
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&bslash;tLoad hints     : &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|8
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cci.pcci_ld_hints
op_amp
l_int|0x1
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;[%s]&quot;
comma
id|cache_ld_hints
(braket
id|k
)braket
)paren
suffix:semicolon
id|cci.pcci_ld_hints
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&bslash;tAlias boundary : %d byte(s)&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tTag LSB        : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tTag MSB        : %d&bslash;n&quot;
comma
l_int|1
op_lshift
id|cci.pcci_alias_boundary
comma
id|cci.pcci_tag_lsb
comma
id|cci.pcci_tag_msb
)paren
suffix:semicolon
multiline_comment|/* when unified, data(j=2) is enough */
r_if
c_cond
(paren
id|cci.pcci_unified
)paren
r_break
suffix:semicolon
)brace
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|vm_info
id|vm_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|tr_pages
op_assign
l_int|0
comma
id|vw_pages
op_assign
l_int|0
comma
id|tc_pages
suffix:semicolon
id|u64
id|attrib
suffix:semicolon
id|pal_vm_info_1_u_t
id|vm_info_1
suffix:semicolon
id|pal_vm_info_2_u_t
id|vm_info_2
suffix:semicolon
id|pal_tc_info_u_t
id|tc_info
suffix:semicolon
id|ia64_ptce_info_t
id|ptce
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|s64
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_vm_summary
c_func
(paren
op_amp
id|vm_info_1
comma
op_amp
id|vm_info_2
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ia64_pal_vm_summary=%ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Physical Address Space         : %d bits&bslash;n&quot;
"&bslash;"
l_string|&quot;Virtual Address Space          : %d bits&bslash;n&quot;
"&bslash;"
l_string|&quot;Protection Key Registers(PKR)  : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Implemented bits in PKR.key    : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Hash Tag ID                    : 0x%x&bslash;n&quot;
"&bslash;"
l_string|&quot;Size of RR.rid                 : %d&bslash;n&quot;
comma
id|vm_info_1.pal_vm_info_1_s.phys_add_size
comma
id|vm_info_2.pal_vm_info_2_s.impl_va_msb
op_plus
l_int|1
comma
id|vm_info_1.pal_vm_info_1_s.max_pkr
op_plus
l_int|1
comma
id|vm_info_1.pal_vm_info_1_s.key_size
comma
id|vm_info_1.pal_vm_info_1_s.hash_tag_id
comma
id|vm_info_2.pal_vm_info_2_s.rid_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ia64_pal_mem_attrib
c_func
(paren
op_amp
id|attrib
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Supported memory attributes    : %s&bslash;n&quot;
comma
id|mem_attrib
(braket
id|attrib
op_amp
l_int|0x7
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_vm_page_size
c_func
(paren
op_amp
id|tr_pages
comma
op_amp
id|vw_pages
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ia64_pal_vm_page_size=%ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nTLB walker                     : %s implemented&bslash;n&quot;
"&bslash;"
l_string|&quot;Number of DTR                  : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Number of ITR                  : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;TLB insertable page sizes      : &quot;
comma
id|vm_info_1.pal_vm_info_1_s.vw
ques
c_cond
l_string|&quot;&bslash;b&quot;
suffix:colon
l_string|&quot;not&quot;
comma
id|vm_info_1.pal_vm_info_1_s.max_dtr_entry
op_plus
l_int|1
comma
id|vm_info_1.pal_vm_info_1_s.max_itr_entry
op_plus
l_int|1
)paren
suffix:semicolon
id|p
op_assign
id|bitvector_process
c_func
(paren
id|p
comma
id|tr_pages
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nTLB purgeable page sizes       : &quot;
)paren
suffix:semicolon
id|p
op_assign
id|bitvector_process
c_func
(paren
id|p
comma
id|vw_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_get_ptce
c_func
(paren
op_amp
id|ptce
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ia64_get_ptce=%ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nPurge base address             : 0x%016lx&bslash;n&quot;
"&bslash;"
l_string|&quot;Purge outer loop count         : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Purge inner loop count         : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Purge outer loop stride        : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Purge inner loop stride        : %d&bslash;n&quot;
comma
id|ptce.base
comma
id|ptce.count
(braket
l_int|0
)braket
comma
id|ptce.count
(braket
l_int|1
)braket
comma
id|ptce.stride
(braket
l_int|0
)braket
comma
id|ptce.stride
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;TC Levels                      : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Unique TC(s)                   : %d&bslash;n&quot;
comma
id|vm_info_1.pal_vm_info_1_s.num_tc_levels
comma
id|vm_info_1.pal_vm_info_1_s.max_unique_tcs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vm_info_1.pal_vm_info_1_s.num_tc_levels
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|2
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|tc_pages
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just in case */
multiline_comment|/* even without unification, some levels may not be present */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_vm_info
c_func
(paren
id|i
comma
id|j
comma
op_amp
id|tc_info
comma
op_amp
id|tc_pages
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n%s Translation Cache Level %d:&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tHash sets           : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tAssociativity       : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tNumber of entries   : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tFlags               : &quot;
comma
id|cache_types
(braket
id|j
op_plus
id|tc_info.tc_unified
)braket
comma
id|i
op_plus
l_int|1
comma
id|tc_info.tc_num_sets
comma
id|tc_info.tc_associativity
comma
id|tc_info.tc_num_entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc_info.tc_pf
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;PreferredPageSizeOptimized &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc_info.tc_unified
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Unified &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc_info.tc_reduce_tr
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;TCReduction&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&bslash;tSupported page sizes: &quot;
)paren
suffix:semicolon
id|p
op_assign
id|bitvector_process
c_func
(paren
id|p
comma
id|tc_pages
)paren
suffix:semicolon
multiline_comment|/* when unified date (j=2) is enough */
r_if
c_cond
(paren
id|tc_info.tc_unified
)paren
r_break
suffix:semicolon
)brace
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|register_info
id|register_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|reg_info
(braket
l_int|2
)braket
suffix:semicolon
id|u64
id|info
suffix:semicolon
id|u64
id|phys_stacked
suffix:semicolon
id|pal_hints_u_t
id|hints
suffix:semicolon
id|u64
id|iregs
comma
id|dregs
suffix:semicolon
r_char
op_star
id|info_type
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_for
c_loop
(paren
id|info
op_assign
l_int|0
suffix:semicolon
id|info
OL
l_int|4
suffix:semicolon
id|info
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ia64_pal_register_info
c_func
(paren
id|info
comma
op_amp
id|reg_info
(braket
l_int|0
)braket
comma
op_amp
id|reg_info
(braket
l_int|1
)braket
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%-32s : &quot;
comma
id|info_type
(braket
id|info
)braket
)paren
suffix:semicolon
id|p
op_assign
id|bitregister_process
c_func
(paren
id|p
comma
id|reg_info
comma
l_int|128
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ia64_pal_rse_info
c_func
(paren
op_amp
id|phys_stacked
comma
op_amp
id|hints
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;RSE stacked physical registers   : %ld&bslash;n&quot;
"&bslash;"
l_string|&quot;RSE load/store hints             : %ld (%s)&bslash;n&quot;
comma
id|phys_stacked
comma
id|hints.ph_data
comma
id|hints.ph_data
OL
id|RSE_HINTS_COUNT
ques
c_cond
id|rse_hints
(braket
id|hints.ph_data
)braket
suffix:colon
l_string|&quot;(&bslash;?&bslash;?)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ia64_pal_debug_info
c_func
(paren
op_amp
id|iregs
comma
op_amp
id|dregs
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Instruction debug register pairs : %ld&bslash;n&quot;
"&bslash;"
l_string|&quot;Data debug register pairs        : %ld&bslash;n&quot;
comma
id|iregs
comma
id|dregs
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
DECL|variable|proc_features
r_static
r_const
r_char
op_star
id|proc_features
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_int
DECL|function|processor_info
id|processor_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_const
r_char
op_star
op_star
id|v
op_assign
id|proc_features
suffix:semicolon
id|u64
id|avail
op_assign
l_int|1
comma
id|status
op_assign
l_int|1
comma
id|control
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s64
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|ia64_pal_proc_get_features
c_func
(paren
op_amp
id|avail
comma
op_amp
id|status
comma
op_amp
id|control
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
comma
id|v
op_increment
comma
id|avail
op_rshift_assign
l_int|1
comma
id|status
op_rshift_assign
l_int|1
comma
id|control
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|v
)paren
r_continue
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%-40s : %s%s %s&bslash;n&quot;
comma
op_star
id|v
comma
id|avail
op_amp
l_int|0x1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;NotImpl&quot;
comma
id|avail
op_amp
l_int|0x1
ques
c_cond
(paren
id|status
op_amp
l_int|0x1
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:colon
l_string|&quot;&quot;
comma
id|avail
op_amp
l_int|0x1
ques
c_cond
(paren
id|control
op_amp
l_int|0x1
ques
c_cond
l_string|&quot;Ctrl&quot;
suffix:colon
l_string|&quot;NoCtrl&quot;
)paren
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
DECL|variable|bus_features
r_static
r_const
r_char
op_star
id|bus_features
(braket
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_int
DECL|function|bus_info
id|bus_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_const
r_char
op_star
op_star
id|v
op_assign
id|bus_features
suffix:semicolon
id|pal_bus_features_u_t
id|av
comma
id|st
comma
id|ct
suffix:semicolon
id|u64
id|avail
comma
id|status
comma
id|control
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s64
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|ia64_pal_bus_get_features
c_func
(paren
op_amp
id|av
comma
op_amp
id|st
comma
op_amp
id|ct
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|avail
op_assign
id|av.pal_bus_features_val
suffix:semicolon
id|status
op_assign
id|st.pal_bus_features_val
suffix:semicolon
id|control
op_assign
id|ct.pal_bus_features_val
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
comma
id|v
op_increment
comma
id|avail
op_rshift_assign
l_int|1
comma
id|status
op_rshift_assign
l_int|1
comma
id|control
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|v
)paren
r_continue
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%-48s : %s%s %s&bslash;n&quot;
comma
op_star
id|v
comma
id|avail
op_amp
l_int|0x1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;NotImpl&quot;
comma
id|avail
op_amp
l_int|0x1
ques
c_cond
(paren
id|status
op_amp
l_int|0x1
ques
c_cond
l_string|&quot;On&quot;
suffix:colon
l_string|&quot;Off&quot;
)paren
suffix:colon
l_string|&quot;&quot;
comma
id|avail
op_amp
l_int|0x1
ques
c_cond
(paren
id|control
op_amp
l_int|0x1
ques
c_cond
l_string|&quot;Ctrl&quot;
suffix:colon
l_string|&quot;NoCtrl&quot;
)paren
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * physical mode call for PAL_VERSION is working fine.&n; * This function is meant to go away once PAL get fixed.&n; */
r_static
r_inline
id|s64
DECL|function|ia64_pal_version_phys
id|ia64_pal_version_phys
c_func
(paren
id|pal_version_u_t
op_star
id|pal_min_version
comma
id|pal_version_u_t
op_star
id|pal_cur_version
)paren
(brace
r_struct
id|ia64_pal_retval
id|iprv
suffix:semicolon
id|PAL_CALL_PHYS
c_func
(paren
id|iprv
comma
id|PAL_VERSION
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pal_min_version
)paren
id|pal_min_version-&gt;pal_version_val
op_assign
id|iprv.v0
suffix:semicolon
r_if
c_cond
(paren
id|pal_cur_version
)paren
id|pal_cur_version-&gt;pal_version_val
op_assign
id|iprv.v1
suffix:semicolon
r_return
id|iprv.status
suffix:semicolon
)brace
r_static
r_int
DECL|function|version_info
id|version_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
id|s64
id|status
suffix:semicolon
id|pal_version_u_t
id|min_ver
comma
id|cur_ver
suffix:semicolon
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
macro_line|#ifdef IA64_PAL_VERSION_BUG
multiline_comment|/* The virtual mode call is buggy. But the physical mode call seems&n;&t; * to be ok. Until they fix virtual mode, we do physical.&n;&t; */
id|status
op_assign
id|ia64_pal_version_phys
c_func
(paren
op_amp
id|min_ver
comma
op_amp
id|cur_ver
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* The system crashes if you enable this code with the wrong PAL &n;&t; * code&n;&t; */
id|status
op_assign
id|ia64_pal_version
c_func
(paren
op_amp
id|min_ver
comma
op_amp
id|cur_ver
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;PAL_vendor : 0x%02x (min=0x%02x)&bslash;n&quot;
"&bslash;"
l_string|&quot;PAL_A      : %x.%x.%x (min=%x.%x.%x)&bslash;n&quot;
"&bslash;"
l_string|&quot;PAL_B      : %x.%x.%x (min=%x.%x.%x)&bslash;n&quot;
comma
id|cur_ver.pal_version_s.pv_pal_vendor
comma
id|min_ver.pal_version_s.pv_pal_vendor
comma
id|cur_ver.pal_version_s.pv_pal_a_model
op_rshift
l_int|4
comma
id|cur_ver.pal_version_s.pv_pal_a_model
op_amp
l_int|0xf
comma
id|cur_ver.pal_version_s.pv_pal_a_rev
comma
id|min_ver.pal_version_s.pv_pal_a_model
op_rshift
l_int|4
comma
id|min_ver.pal_version_s.pv_pal_a_model
op_amp
l_int|0xf
comma
id|min_ver.pal_version_s.pv_pal_a_rev
comma
id|cur_ver.pal_version_s.pv_pal_b_model
op_rshift
l_int|4
comma
id|cur_ver.pal_version_s.pv_pal_b_model
op_amp
l_int|0xf
comma
id|cur_ver.pal_version_s.pv_pal_b_rev
comma
id|min_ver.pal_version_s.pv_pal_b_model
op_rshift
l_int|4
comma
id|min_ver.pal_version_s.pv_pal_b_model
op_amp
l_int|0xf
comma
id|min_ver.pal_version_s.pv_pal_b_rev
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|perfmon_info
id|perfmon_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|u64
id|pm_buffer
(braket
l_int|16
)braket
suffix:semicolon
id|pal_perf_mon_info_u_t
id|pm_info
suffix:semicolon
r_if
c_cond
(paren
id|ia64_pal_perf_mon_info
c_func
(paren
id|pm_buffer
comma
op_amp
id|pm_info
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef IA64_PAL_PERF_MON_INFO_BUG
multiline_comment|/*&n;&t; * This bug has been fixed in PAL 2.2.9 and higher&n;&t; */
id|pm_buffer
(braket
l_int|5
)braket
op_assign
l_int|0x3
suffix:semicolon
id|pm_info.pal_perf_mon_info_s.cycles
op_assign
l_int|0x12
suffix:semicolon
id|pm_info.pal_perf_mon_info_s.retired
op_assign
l_int|0x08
suffix:semicolon
macro_line|#endif
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;PMC/PMD pairs                 : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Counter width                 : %d bits&bslash;n&quot;
"&bslash;"
l_string|&quot;Cycle event number            : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Retired event number          : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;Implemented PMC               : &quot;
comma
id|pm_info.pal_perf_mon_info_s.generic
comma
id|pm_info.pal_perf_mon_info_s.width
comma
id|pm_info.pal_perf_mon_info_s.cycles
comma
id|pm_info.pal_perf_mon_info_s.retired
)paren
suffix:semicolon
id|p
op_assign
id|bitregister_process
c_func
(paren
id|p
comma
id|pm_buffer
comma
l_int|256
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nImplemented PMD               : &quot;
)paren
suffix:semicolon
id|p
op_assign
id|bitregister_process
c_func
(paren
id|p
comma
id|pm_buffer
op_plus
l_int|4
comma
l_int|256
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nCycles count capable          : &quot;
)paren
suffix:semicolon
id|p
op_assign
id|bitregister_process
c_func
(paren
id|p
comma
id|pm_buffer
op_plus
l_int|8
comma
l_int|256
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nRetired bundles count capable : &quot;
)paren
suffix:semicolon
id|p
op_assign
id|bitregister_process
c_func
(paren
id|p
comma
id|pm_buffer
op_plus
l_int|12
comma
l_int|256
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|frequency_info
id|frequency_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_struct
id|pal_freq_ratio
id|proc
comma
id|itc
comma
id|bus
suffix:semicolon
id|u64
id|base
suffix:semicolon
r_if
c_cond
(paren
id|ia64_pal_freq_base
c_func
(paren
op_amp
id|base
)paren
op_eq
op_minus
l_int|1
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Output clock            : not implemented&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Output clock            : %ld ticks/s&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ia64_pal_freq_ratios
c_func
(paren
op_amp
id|proc
comma
op_amp
id|bus
comma
op_amp
id|itc
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Processor/Clock ratio   : %ld/%ld&bslash;n&quot;
"&bslash;"
l_string|&quot;Bus/Clock ratio         : %ld/%ld&bslash;n&quot;
"&bslash;"
l_string|&quot;ITC/Clock ratio         : %ld/%ld&bslash;n&quot;
comma
id|proc.num
comma
id|proc.den
comma
id|bus.num
comma
id|bus.den
comma
id|itc.num
comma
id|itc.den
)paren
suffix:semicolon
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
r_static
r_int
DECL|function|tr_info
id|tr_info
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
id|s64
id|status
suffix:semicolon
id|pal_tr_valid_u_t
id|tr_valid
suffix:semicolon
id|u64
id|tr_buffer
(braket
l_int|4
)braket
suffix:semicolon
id|pal_vm_info_1_u_t
id|vm_info_1
suffix:semicolon
id|pal_vm_info_2_u_t
id|vm_info_2
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|u64
id|max
(braket
l_int|3
)braket
comma
id|pgm
suffix:semicolon
r_struct
id|ifa_reg
(brace
id|u64
id|valid
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|ig
suffix:colon
l_int|11
suffix:semicolon
id|u64
id|vpn
suffix:colon
l_int|52
suffix:semicolon
)brace
op_star
id|ifa_reg
suffix:semicolon
r_struct
id|itir_reg
(brace
id|u64
id|rv1
suffix:colon
l_int|2
suffix:semicolon
id|u64
id|ps
suffix:colon
l_int|6
suffix:semicolon
id|u64
id|key
suffix:colon
l_int|24
suffix:semicolon
id|u64
id|rv2
suffix:colon
l_int|32
suffix:semicolon
)brace
op_star
id|itir_reg
suffix:semicolon
r_struct
id|gr_reg
(brace
id|u64
id|p
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|rv1
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|ma
suffix:colon
l_int|3
suffix:semicolon
id|u64
id|a
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|d
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|pl
suffix:colon
l_int|2
suffix:semicolon
id|u64
id|ar
suffix:colon
l_int|3
suffix:semicolon
id|u64
id|ppn
suffix:colon
l_int|38
suffix:semicolon
id|u64
id|rv2
suffix:colon
l_int|2
suffix:semicolon
id|u64
id|ed
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|ig
suffix:colon
l_int|11
suffix:semicolon
)brace
op_star
id|gr_reg
suffix:semicolon
r_struct
id|rid_reg
(brace
id|u64
id|ig1
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|rv1
suffix:colon
l_int|1
suffix:semicolon
id|u64
id|ig2
suffix:colon
l_int|6
suffix:semicolon
id|u64
id|rid
suffix:colon
l_int|24
suffix:semicolon
id|u64
id|rv2
suffix:colon
l_int|32
suffix:semicolon
)brace
op_star
id|rid_reg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ia64_pal_vm_summary
c_func
(paren
op_amp
id|vm_info_1
comma
op_amp
id|vm_info_2
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ia64_pal_vm_summary=%ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|max
(braket
l_int|0
)braket
op_assign
id|vm_info_1.pal_vm_info_1_s.max_itr_entry
op_plus
l_int|1
suffix:semicolon
id|max
(braket
l_int|1
)braket
op_assign
id|vm_info_1.pal_vm_info_1_s.max_dtr_entry
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|max
(braket
id|i
)braket
suffix:semicolon
id|j
op_increment
)paren
(brace
id|status
op_assign
id|ia64_pal_tr_read
c_func
(paren
id|j
comma
id|i
comma
id|tr_buffer
comma
op_amp
id|tr_valid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; pal call failed on tr[%d:%d]=%ld&bslash;n&quot;
comma
id|i
comma
id|j
comma
id|status
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ifa_reg
op_assign
(paren
r_struct
id|ifa_reg
op_star
)paren
op_amp
id|tr_buffer
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ifa_reg-&gt;valid
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|gr_reg
op_assign
(paren
r_struct
id|gr_reg
op_star
)paren
id|tr_buffer
suffix:semicolon
id|itir_reg
op_assign
(paren
r_struct
id|itir_reg
op_star
)paren
op_amp
id|tr_buffer
(braket
l_int|1
)braket
suffix:semicolon
id|rid_reg
op_assign
(paren
r_struct
id|rid_reg
op_star
)paren
op_amp
id|tr_buffer
(braket
l_int|3
)braket
suffix:semicolon
id|pgm
op_assign
op_minus
l_int|1
op_lshift
(paren
id|itir_reg-&gt;ps
op_minus
l_int|12
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%cTR%d: av=%d pv=%d dv=%d mv=%d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tppn  : 0x%lx&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tvpn  : 0x%lx&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tps   : &quot;
comma
l_string|&quot;ID&quot;
(braket
id|i
)braket
comma
id|j
comma
id|tr_valid.pal_tr_valid_s.access_rights_valid
comma
id|tr_valid.pal_tr_valid_s.priv_level_valid
comma
id|tr_valid.pal_tr_valid_s.dirty_bit_valid
comma
id|tr_valid.pal_tr_valid_s.mem_attr_valid
comma
(paren
id|gr_reg-&gt;ppn
op_amp
id|pgm
)paren
op_lshift
l_int|12
comma
(paren
id|ifa_reg-&gt;vpn
op_amp
id|pgm
)paren
op_lshift
l_int|12
)paren
suffix:semicolon
id|p
op_assign
id|bitvector_process
c_func
(paren
id|p
comma
l_int|1
op_lshift
id|itir_reg-&gt;ps
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&bslash;tpl   : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tar   : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;trid  : %x&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tp    : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;tma   : %d&bslash;n&quot;
"&bslash;"
l_string|&quot;&bslash;td    : %d&bslash;n&quot;
comma
id|gr_reg-&gt;pl
comma
id|gr_reg-&gt;ar
comma
id|rid_reg-&gt;rid
comma
id|gr_reg-&gt;p
comma
id|gr_reg-&gt;ma
comma
id|gr_reg-&gt;d
)paren
suffix:semicolon
)brace
)brace
r_return
id|p
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * List {name,function} pairs for every entry in /proc/palinfo/cpu*&n; */
DECL|variable|palinfo_entries
r_static
id|palinfo_entry_t
id|palinfo_entries
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|macro|NR_PALINFO_ENTRIES
mdefine_line|#define NR_PALINFO_ENTRIES&t;(sizeof(palinfo_entries)/sizeof(palinfo_entry_t))
multiline_comment|/*&n; * this array is used to keep track of the proc entries we create. This is &n; * required in the module mode when we need to remove all entries. The procfs code&n; * does not do recursion of deletion&n; *&n; * Notes:&n; *&t;- first +1 accounts for the cpuN entry&n; *&t;- second +1 account for toplevel palinfo&n; * &n; */
DECL|macro|NR_PALINFO_PROC_ENTRIES
mdefine_line|#define NR_PALINFO_PROC_ENTRIES&t;(NR_CPUS*(NR_PALINFO_ENTRIES+1)+1)
DECL|variable|palinfo_proc_entries
r_static
r_struct
id|proc_dir_entry
op_star
id|palinfo_proc_entries
(braket
id|NR_PALINFO_PROC_ENTRIES
)braket
suffix:semicolon
multiline_comment|/*&n; * This data structure is used to pass which cpu,function is being requested&n; * It must fit in a 64bit quantity to be passed to the proc callback routine&n; *&n; * In SMP mode, when we get a request for another CPU, we must call that&n; * other CPU using IPI and wait for the result before returning.&n; */
r_typedef
r_union
(brace
DECL|member|value
id|u64
id|value
suffix:semicolon
r_struct
(brace
DECL|member|req_cpu
r_int
id|req_cpu
suffix:colon
l_int|32
suffix:semicolon
multiline_comment|/* for which CPU this info is */
DECL|member|func_id
r_int
id|func_id
suffix:colon
l_int|32
suffix:semicolon
multiline_comment|/* which function is requested */
DECL|member|pal_func_cpu
)brace
id|pal_func_cpu
suffix:semicolon
DECL|typedef|pal_func_cpu_u_t
)brace
id|pal_func_cpu_u_t
suffix:semicolon
DECL|macro|req_cpu
mdefine_line|#define req_cpu&t;pal_func_cpu.req_cpu
DECL|macro|func_id
mdefine_line|#define func_id pal_func_cpu.func_id
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * used to hold information about final function to call &n; */
r_typedef
r_struct
(brace
DECL|member|func
id|palinfo_func_t
id|func
suffix:semicolon
multiline_comment|/* pointer to function to call */
DECL|member|page
r_char
op_star
id|page
suffix:semicolon
multiline_comment|/* buffer to store results */
DECL|member|ret
r_int
id|ret
suffix:semicolon
multiline_comment|/* return value from call */
DECL|typedef|palinfo_smp_data_t
)brace
id|palinfo_smp_data_t
suffix:semicolon
multiline_comment|/*&n; * this function does the actual final call and he called&n; * from the smp code, i.e., this is the palinfo callback routine&n; */
r_static
r_void
DECL|function|palinfo_smp_call
id|palinfo_smp_call
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|palinfo_smp_data_t
op_star
id|data
op_assign
(paren
id|palinfo_smp_data_t
op_star
)paren
id|info
suffix:semicolon
multiline_comment|/* printk(__FUNCTION__&quot; called on CPU %d&bslash;n&quot;, smp_processor_id());*/
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot; data pointer is NULL&bslash;n&quot;
)paren
suffix:semicolon
id|data-&gt;ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no output */
r_return
suffix:semicolon
)brace
multiline_comment|/* does this actual call */
id|data-&gt;ret
op_assign
(paren
op_star
id|data-&gt;func
)paren
(paren
id|data-&gt;page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * function called to trigger the IPI, we need to access a remote CPU&n; * Return:&n; *&t;0 : error or nothing to output&n; *&t;otherwise how many bytes in the &quot;page&quot; buffer were written&n; */
r_static
DECL|function|palinfo_handle_smp
r_int
id|palinfo_handle_smp
c_func
(paren
id|pal_func_cpu_u_t
op_star
id|f
comma
r_char
op_star
id|page
)paren
(brace
id|palinfo_smp_data_t
id|ptr
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ptr.func
op_assign
id|palinfo_entries
(braket
id|f-&gt;func_id
)braket
dot
id|proc_read
suffix:semicolon
id|ptr.page
op_assign
id|page
suffix:semicolon
id|ptr.ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* just in case */
multiline_comment|/*printk(__FUNCTION__&quot; calling CPU %d from CPU %d for function %d&bslash;n&quot;, f-&gt;req_cpu,smp_processor_id(), f-&gt;func_id);*/
multiline_comment|/* will send IPI to other CPU and wait for completion of remote call */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|smp_call_function_single
c_func
(paren
id|f-&gt;req_cpu
comma
id|palinfo_smp_call
comma
op_amp
id|ptr
comma
l_int|0
comma
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; remote CPU call from %d to %d on function %d: error %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|f-&gt;req_cpu
comma
id|f-&gt;func_id
comma
id|ret
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ptr.ret
suffix:semicolon
)brace
macro_line|#else /* ! CONFIG_SMP */
r_static
DECL|function|palinfo_handle_smp
r_int
id|palinfo_handle_smp
c_func
(paren
id|pal_func_cpu_u_t
op_star
id|f
comma
r_char
op_star
id|page
)paren
(brace
id|printk
c_func
(paren
id|__FUNCTION__
l_string|&quot; should not be called with non SMP kernel&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; * Entry point routine: all calls go through this function&n; */
r_static
r_int
DECL|function|palinfo_read_entry
id|palinfo_read_entry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|pal_func_cpu_u_t
op_star
id|f
op_assign
(paren
id|pal_func_cpu_u_t
op_star
)paren
op_amp
id|data
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * in SMP mode, we may need to call another CPU to get correct&n;&t; * information. PAL, by definition, is processor specific&n;&t; */
r_if
c_cond
(paren
id|f-&gt;req_cpu
op_eq
id|smp_processor_id
c_func
(paren
)paren
)paren
id|len
op_assign
(paren
op_star
id|palinfo_entries
(braket
id|f-&gt;func_id
)braket
dot
id|proc_read
)paren
(paren
id|page
)paren
suffix:semicolon
r_else
id|len
op_assign
id|palinfo_handle_smp
c_func
(paren
id|f
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|palinfo_init
id|palinfo_init
c_func
(paren
r_void
)paren
(brace
DECL|macro|CPUSTR
macro_line|#&t;define CPUSTR&t;&quot;cpu%d&quot;
id|pal_func_cpu_u_t
id|f
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
op_star
id|pdir
op_assign
id|palinfo_proc_entries
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|palinfo_dir
comma
op_star
id|cpu_dir
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_char
id|cpustr
(braket
r_sizeof
(paren
id|CPUSTR
)paren
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PAL Information Facility v%s&bslash;n&quot;
comma
id|PALINFO_VERSION
)paren
suffix:semicolon
id|palinfo_dir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;pal&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we keep track of created entries in a depth-first order for&n;&t; * cleanup purposes. Each entry is stored into palinfo_proc_entries&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_is_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|sprintf
c_func
(paren
id|cpustr
comma
id|CPUSTR
comma
id|i
)paren
suffix:semicolon
id|cpu_dir
op_assign
id|proc_mkdir
c_func
(paren
id|cpustr
comma
id|palinfo_dir
)paren
suffix:semicolon
id|f.req_cpu
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_PALINFO_ENTRIES
suffix:semicolon
id|j
op_increment
)paren
(brace
id|f.func_id
op_assign
id|j
suffix:semicolon
op_star
id|pdir
op_increment
op_assign
id|create_proc_read_entry
(paren
id|palinfo_entries
(braket
id|j
)braket
dot
id|name
comma
l_int|0
comma
id|cpu_dir
comma
id|palinfo_read_entry
comma
(paren
r_void
op_star
)paren
id|f.value
)paren
suffix:semicolon
)brace
op_star
id|pdir
op_increment
op_assign
id|cpu_dir
suffix:semicolon
)brace
op_star
id|pdir
op_assign
id|palinfo_dir
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|palinfo_exit
id|palinfo_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* remove all nodes: depth first pass */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PALINFO_PROC_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|remove_proc_entry
(paren
id|palinfo_proc_entries
(braket
id|i
)braket
op_member_access_from_pointer
id|name
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
DECL|variable|palinfo_init
id|module_init
c_func
(paren
id|palinfo_init
)paren
suffix:semicolon
DECL|variable|palinfo_exit
id|module_exit
c_func
(paren
id|palinfo_exit
)paren
suffix:semicolon
eof
