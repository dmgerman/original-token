macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/sn/types.h&gt;
macro_line|#include &lt;asm/sn/addrs.h&gt;
macro_line|#include &lt;asm/sn/nmi.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/sn0/hub.h&gt;
macro_line|#if 0
mdefine_line|#define NODE_NUM_CPUS(n)&t;CNODE_NUM_CPUS(n)
macro_line|#else
DECL|macro|NODE_NUM_CPUS
mdefine_line|#define NODE_NUM_CPUS(n)&t;CPUS_PER_NODE
macro_line|#endif
DECL|macro|CNODEID_NONE
mdefine_line|#define CNODEID_NONE (cnodeid_t)-1
DECL|macro|enter_panic_mode
mdefine_line|#define enter_panic_mode()&t;spin_lock(&amp;nmi_lock)
DECL|typedef|machreg_t
r_typedef
r_int
r_int
id|machreg_t
suffix:semicolon
DECL|variable|nmi_lock
id|spinlock_t
id|nmi_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Lets see what else we need to do here. Set up sp, gp?&n; */
DECL|function|nmi_dump
r_void
id|nmi_dump
c_func
(paren
r_void
)paren
(brace
r_void
id|cont_nmi_dump
c_func
(paren
r_void
)paren
suffix:semicolon
id|cont_nmi_dump
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|install_cpu_nmi_handler
r_void
id|install_cpu_nmi_handler
c_func
(paren
r_int
id|slice
)paren
(brace
id|nmi_t
op_star
id|nmi_addr
suffix:semicolon
id|nmi_addr
op_assign
(paren
id|nmi_t
op_star
)paren
id|NMI_ADDR
c_func
(paren
id|get_nasid
c_func
(paren
)paren
comma
id|slice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nmi_addr-&gt;call_addr
)paren
r_return
suffix:semicolon
id|nmi_addr-&gt;magic
op_assign
id|NMI_MAGIC
suffix:semicolon
id|nmi_addr-&gt;call_addr
op_assign
(paren
r_void
op_star
)paren
id|nmi_dump
suffix:semicolon
id|nmi_addr-&gt;call_addr_c
op_assign
(paren
r_void
op_star
)paren
(paren
op_complement
(paren
(paren
r_int
r_int
)paren
(paren
id|nmi_addr-&gt;call_addr
)paren
)paren
)paren
suffix:semicolon
id|nmi_addr-&gt;call_parm
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the cpu registers which have been saved in the IP27prom format&n; * into the eframe format for the node under consideration.&n; */
r_void
DECL|function|nmi_cpu_eframe_save
id|nmi_cpu_eframe_save
c_func
(paren
id|nasid_t
id|nasid
comma
r_int
id|slice
)paren
(brace
r_int
id|i
comma
id|numberof_nmi_cpu_regs
suffix:semicolon
id|machreg_t
op_star
id|prom_format
suffix:semicolon
multiline_comment|/* Get the total number of registers being saved by the prom */
id|numberof_nmi_cpu_regs
op_assign
r_sizeof
(paren
r_struct
id|reg_struct
)paren
op_div
r_sizeof
(paren
id|machreg_t
)paren
suffix:semicolon
multiline_comment|/* Get the pointer to the current cpu&squot;s register set. */
id|prom_format
op_assign
(paren
id|machreg_t
op_star
)paren
(paren
id|TO_UNCAC
c_func
(paren
id|TO_NODE
c_func
(paren
id|nasid
comma
id|IP27_NMI_KREGS_OFFSET
)paren
)paren
op_plus
id|slice
op_star
id|IP27_NMI_KREGS_CPU_SIZE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NMI nasid %d: slice %d&bslash;n&quot;
comma
id|nasid
comma
id|slice
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numberof_nmi_cpu_regs
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;0x%lx  &quot;
comma
id|prom_format
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the cpu registers which have been saved in the IP27prom format&n; * into the eframe format for the node under consideration.&n; */
r_void
DECL|function|nmi_node_eframe_save
id|nmi_node_eframe_save
c_func
(paren
id|cnodeid_t
id|cnode
)paren
(brace
r_int
id|cpu
suffix:semicolon
id|nasid_t
id|nasid
suffix:semicolon
multiline_comment|/* Make sure that we have a valid node */
r_if
c_cond
(paren
id|cnode
op_eq
id|CNODEID_NONE
)paren
r_return
suffix:semicolon
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cnode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nasid
op_eq
id|INVALID_NASID
)paren
r_return
suffix:semicolon
multiline_comment|/* Save the registers into eframe for each cpu */
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NODE_NUM_CPUS
c_func
(paren
id|cnode
)paren
suffix:semicolon
id|cpu
op_increment
)paren
(brace
id|nmi_cpu_eframe_save
c_func
(paren
id|nasid
comma
id|cpu
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Save the nmi cpu registers for all cpus in the system.&n; */
r_void
DECL|function|nmi_eframes_save
id|nmi_eframes_save
c_func
(paren
r_void
)paren
(brace
id|cnodeid_t
id|cnode
suffix:semicolon
r_for
c_loop
(paren
id|cnode
op_assign
l_int|0
suffix:semicolon
id|cnode
OL
id|numnodes
suffix:semicolon
id|cnode
op_increment
)paren
(brace
id|nmi_node_eframe_save
c_func
(paren
id|cnode
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|cont_nmi_dump
id|cont_nmi_dump
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef REAL_NMI_SIGNAL
r_static
id|atomic_t
id|nmied_cpus
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|nmied_cpus
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * Use enter_panic_mode to allow only 1 cpu to proceed&n;&t; */
id|enter_panic_mode
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef REAL_NMI_SIGNAL
multiline_comment|/*&n;&t; * Wait up to 15 seconds for the other cpus to respond to the NMI.&n;&t; * If a cpu has not responded after 10 sec, send it 1 additional NMI.&n;&t; * This is for 2 reasons:&n;&t; *&t;- sometimes a MMSC fail to NMI all cpus.&n;&t; *&t;- on 512p SN0 system, the MMSC will only send NMIs to&n;&t; *&t;  half the cpus. Unfortunately, we dont know which cpus may be&n;&t; *&t;  NMIed - it depends on how the site chooses to configure.&n;&t; * &n;&t; * Note: it has been measure that it takes the MMSC up to 2.3 secs to&n;&t; * send NMIs to all cpus on a 256p system.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1500
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|dump_count
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|numnodes
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
r_if
c_cond
(paren
id|NODEPDA
c_func
(paren
id|node
)paren
op_member_access_from_pointer
id|dump_count
op_eq
l_int|0
)paren
(brace
id|cpu
op_assign
id|CNODE_TO_CPU_BASE
c_func
(paren
id|node
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|CNODE_NUM_CPUS
c_func
(paren
id|node
)paren
suffix:semicolon
id|cpu
op_increment
comma
id|n
op_increment
)paren
(brace
id|CPUMASK_SETB
c_func
(paren
id|nmied_cpus
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * cputonasid, cputoslice&n;&t;&t;&t;&t;&t;&t; * needs kernel cpuid&n;&t;&t;&t;&t;&t;&t; */
id|SEND_NMI
c_func
(paren
(paren
id|cputonasid
c_func
(paren
id|cpu
)paren
)paren
comma
(paren
id|cputoslice
c_func
(paren
id|cpu
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|udelay
c_func
(paren
l_int|10000
)paren
suffix:semicolon
)brace
macro_line|#else
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|nmied_cpus
)paren
op_ne
id|smp_num_cpus
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Save the nmi cpu registers for all cpu in the eframe format.&n;&t; */
id|nmi_eframes_save
c_func
(paren
)paren
suffix:semicolon
id|LOCAL_HUB_S
c_func
(paren
id|NI_PORT_RESET
comma
id|NPR_PORTRESET
op_or
id|NPR_LOCALRESET
)paren
suffix:semicolon
)brace
eof
