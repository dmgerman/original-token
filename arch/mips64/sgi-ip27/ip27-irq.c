multiline_comment|/*&n; * ip27-irq.c: Highlevel interrupt handling for IP27 architecture.&n; *&n; * Copyright (C) 1999, 2000 Ralf Baechle (ralf@gnu.org)&n; * Copyright (C) 1999, 2000 Silicon Graphics, Inc.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pci/bridge.h&gt;
macro_line|#include &lt;asm/sn/sn0/hub.h&gt;
macro_line|#include &lt;asm/sn/sn0/ip27.h&gt;
macro_line|#include &lt;asm/sn/arch.h&gt;
macro_line|#include &lt;asm/sn/intr.h&gt;
macro_line|#include &lt;asm/sn/intr_public.h&gt;
DECL|macro|DEBUG_IRQ
macro_line|#undef DEBUG_IRQ
macro_line|#ifdef DEBUG_IRQ
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
multiline_comment|/*&n; * Linux has a controller-independent x86 interrupt architecture.&n; * every controller has a &squot;controller-template&squot;, that is used&n; * by the main code to do the right thing. Each driver-visible&n; * interrupt source is transparently wired to the apropriate&n; * controller. Thus drivers need not be aware of the&n; * interrupt-controller.&n; *&n; * Various interrupt controllers we handle: 8259 PIC, SMP IO-APIC,&n; * PIIX4&squot;s internal 8259 PIC and SGI&squot;s Visual Workstation Cobalt (IO-)APIC.&n; * (IO-APICs assumed to be messaging to Pentium local-APICs)&n; *&n; * the code is designed to be easily extended with new/different&n; * interrupt controllers, without having to do assembly magic.&n; */
r_extern
id|asmlinkage
r_void
id|ip27_irq
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|irq_to_bus
(braket
)braket
comma
id|irq_to_slot
(braket
)braket
comma
id|bus_to_cpu
(braket
)braket
suffix:semicolon
r_int
id|intr_connect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
suffix:semicolon
r_int
id|intr_disconnect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
suffix:semicolon
DECL|variable|spurious_count
r_int
r_int
id|spurious_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * we need to map irq&squot;s up to at least bit 7 of the INT_MASK0_A register&n; * since bits 0-6 are pre-allocated for other purposes.&n; */
DECL|macro|IRQ_TO_SWLEVEL
mdefine_line|#define IRQ_TO_SWLEVEL(cpu, i)&t;i + 7
DECL|macro|SWLEVEL_TO_IRQ
mdefine_line|#define SWLEVEL_TO_IRQ(cpu, s)&t;s - 7
multiline_comment|/*&n; * use these macros to get the encoded nasid and widget id&n; * from the irq value&n; */
DECL|macro|IRQ_TO_BUS
mdefine_line|#define IRQ_TO_BUS(i)&t;&t;&t;irq_to_bus[(i)]
DECL|macro|IRQ_TO_CPU
mdefine_line|#define IRQ_TO_CPU(i)&t;&t;&t;bus_to_cpu[IRQ_TO_BUS(i)]
DECL|macro|NASID_FROM_PCI_IRQ
mdefine_line|#define NASID_FROM_PCI_IRQ(i)&t;&t;bus_to_nid[IRQ_TO_BUS(i)]
DECL|macro|WID_FROM_PCI_IRQ
mdefine_line|#define WID_FROM_PCI_IRQ(i)&t;&t;bus_to_wid[IRQ_TO_BUS(i)]
DECL|macro|SLOT_FROM_PCI_IRQ
mdefine_line|#define&t;SLOT_FROM_PCI_IRQ(i)&t;&t;irq_to_slot[i]
DECL|function|disable_irq
r_void
id|disable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;disable_irq() called ...&quot;
)paren
suffix:semicolon
)brace
DECL|function|enable_irq
r_void
id|enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;enable_irq() called ...&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This is stupid for an Origin which can have thousands of IRQs ...  */
DECL|variable|irq_action
r_static
r_struct
id|irqaction
op_star
id|irq_action
(braket
id|NR_IRQS
)braket
suffix:semicolon
DECL|function|get_irq_list
r_int
id|get_irq_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|action
op_assign
id|irq_action
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
r_continue
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%2d: %8d %c %s&quot;
comma
id|i
comma
id|kstat.irqs
(braket
l_int|0
)braket
(braket
id|i
)braket
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;,%s %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_string|&quot; +&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * do_IRQ handles all normal device IRQ&squot;s (the special SMP cross-CPU interrupts&n; * have their own specific handlers).&n; */
DECL|function|do_IRQ
r_static
r_void
id|do_IRQ
c_func
(paren
id|cpuid_t
id|thiscpu
comma
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
id|do_random
suffix:semicolon
id|irq_enter
c_func
(paren
id|thiscpu
comma
id|irq
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|thiscpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
)paren
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|do_random
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|do_random
op_or_assign
id|action-&gt;flags
suffix:semicolon
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
id|action
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_random
op_amp
id|SA_SAMPLE_RANDOM
)paren
id|add_interrupt_randomness
c_func
(paren
id|irq
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|irq_exit
c_func
(paren
id|thiscpu
comma
id|irq
)paren
suffix:semicolon
multiline_comment|/* unmasking and bottom half handling is done magically for us. */
)brace
multiline_comment|/*&n; * Find first bit set&n; */
DECL|function|ms1bit
r_static
r_int
id|ms1bit
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|b
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|32
)paren
id|b
op_assign
l_int|32
comma
id|x
op_rshift_assign
l_int|32
suffix:semicolon
r_else
id|b
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|16
)paren
id|b
op_add_assign
l_int|16
comma
id|x
op_rshift_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|8
)paren
id|b
op_add_assign
l_int|8
comma
id|x
op_rshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|4
)paren
id|b
op_add_assign
l_int|4
comma
id|x
op_rshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|x
op_rshift
l_int|2
)paren
id|b
op_add_assign
l_int|2
comma
id|x
op_rshift_assign
l_int|2
suffix:semicolon
r_return
id|b
op_plus
(paren
r_int
)paren
(paren
id|x
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This code is unnecessarily complex, because we do SA_INTERRUPT&n; * intr enabling. Basically, once we grab the set of intrs we need&n; * to service, we must mask _all_ these interrupts; firstly, to make&n; * sure the same intr does not intr again, causing recursion that &n; * can lead to stack overflow. Secondly, we can not just mask the&n; * one intr we are do_IRQing, because the non-masked intrs in the&n; * first set might intr again, causing multiple servicings of the&n; * same intr. This effect is mostly seen for intercpu intrs.&n; * Kanoj 05.13.00&n; */
DECL|function|ip27_do_irq
r_void
id|ip27_do_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
comma
id|swlevel
suffix:semicolon
id|hubreg_t
id|pend0
comma
id|mask0
suffix:semicolon
id|cpuid_t
id|thiscpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|pi_int_mask0
op_assign
(paren
(paren
id|cputoslice
c_func
(paren
id|thiscpu
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|PI_INT_MASK0_A
suffix:colon
id|PI_INT_MASK0_B
)paren
suffix:semicolon
multiline_comment|/* copied from Irix intpend0() */
r_while
c_loop
(paren
(paren
(paren
id|pend0
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
)paren
op_amp
(paren
id|mask0
op_assign
id|LOCAL_HUB_L
c_func
(paren
id|pi_int_mask0
)paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|pend0
op_and_assign
id|mask0
suffix:semicolon
multiline_comment|/* Pick intrs we should look at */
r_if
c_cond
(paren
id|pend0
)paren
(brace
multiline_comment|/* Prevent any of the picked intrs from recursing */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask0
comma
id|mask0
op_amp
op_complement
(paren
id|pend0
)paren
)paren
suffix:semicolon
r_do
(brace
id|swlevel
op_assign
id|ms1bit
c_func
(paren
id|pend0
)paren
suffix:semicolon
id|LOCAL_HUB_CLR_INTR
c_func
(paren
id|swlevel
)paren
suffix:semicolon
multiline_comment|/* &quot;map&quot; swlevel to irq */
id|irq
op_assign
id|SWLEVEL_TO_IRQ
c_func
(paren
id|thiscpu
comma
id|swlevel
)paren
suffix:semicolon
id|do_IRQ
c_func
(paren
id|thiscpu
comma
id|irq
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* clear bit in pend0 */
id|pend0
op_xor_assign
l_int|1ULL
op_lshift
id|swlevel
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pend0
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Now allow the set of serviced intrs again */
id|LOCAL_HUB_S
c_func
(paren
id|pi_int_mask0
comma
id|mask0
)paren
suffix:semicolon
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Startup one of the (PCI ...) IRQs routes over a bridge.  */
DECL|function|bridge_startup
r_static
r_int
r_int
id|bridge_startup
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|bridgereg_t
id|device
suffix:semicolon
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|pin
comma
id|swlevel
suffix:semicolon
id|cpuid_t
id|cpu
suffix:semicolon
id|nasid_t
id|master
op_assign
id|NASID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|NODE_SWIN_BASE
c_func
(paren
id|master
comma
id|WID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|pin
op_assign
id|SLOT_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|cpu
op_assign
id|IRQ_TO_CPU
c_func
(paren
id|irq
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;bridge_startup(): irq= 0x%x  pin=%d&bslash;n&quot;
comma
id|irq
comma
id|pin
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;map&quot; irq to a swlevel greater than 6 since the first 6 bits&n;&t; * of INT_PEND0 are taken&n;&t; */
id|swlevel
op_assign
id|IRQ_TO_SWLEVEL
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|swlevel
)paren
suffix:semicolon
id|bridge-&gt;b_int_addr
(braket
id|pin
)braket
dot
id|addr
op_assign
(paren
l_int|0x20000
op_or
id|swlevel
op_or
(paren
id|master
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_int_enable
op_or_assign
(paren
l_int|1
op_lshift
id|pin
)paren
suffix:semicolon
multiline_comment|/* more stuff in int_enable reg */
id|bridge-&gt;b_int_enable
op_or_assign
l_int|0x7ffffe00
suffix:semicolon
multiline_comment|/*&n;&t; * XXX This only works if b_int_device is initialized to 0!&n;&t; * We program the bridge to have a 1:1 mapping between devices&n;&t; * (slots) and intr pins.&n;&t; */
id|device
op_assign
id|bridge-&gt;b_int_device
suffix:semicolon
id|device
op_or_assign
(paren
id|pin
op_lshift
(paren
id|pin
op_star
l_int|3
)paren
)paren
suffix:semicolon
id|bridge-&gt;b_int_device
op_assign
id|device
suffix:semicolon
id|bridge-&gt;b_widget.w_tflush
suffix:semicolon
multiline_comment|/* Flush */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Never anything pending.  */
)brace
multiline_comment|/* Shutdown one of the (PCI ...) IRQs routes over a bridge.  */
DECL|function|bridge_shutdown
r_static
r_int
r_int
id|bridge_shutdown
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|bridge_t
op_star
id|bridge
suffix:semicolon
r_int
id|pin
comma
id|swlevel
suffix:semicolon
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
id|NODE_SWIN_BASE
c_func
(paren
id|NASID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
comma
id|WID_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;bridge_shutdown: irq 0x%x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|pin
op_assign
id|SLOT_FROM_PCI_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * map irq to a swlevel greater than 6 since the first 6 bits&n;&t; * of INT_PEND0 are taken&n;&t; */
id|swlevel
op_assign
id|IRQ_TO_SWLEVEL
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|intr_disconnect_level
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|swlevel
)paren
suffix:semicolon
id|bridge-&gt;b_int_enable
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|pin
)paren
suffix:semicolon
id|bridge-&gt;b_widget.w_tflush
suffix:semicolon
multiline_comment|/* Flush */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Never anything pending.  */
)brace
DECL|function|irq_debug
r_void
id|irq_debug
c_func
(paren
r_void
)paren
(brace
id|bridge_t
op_star
id|bridge
op_assign
(paren
id|bridge_t
op_star
)paren
l_int|0x9200000008000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bridge-&gt;b_int_status = 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_int_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bridge-&gt;b_int_enable = 0x%x&bslash;n&quot;
comma
id|bridge-&gt;b_int_enable
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PI_INT_PEND0   = 0x%lx&bslash;n&quot;
comma
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_PEND0
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PI_INT_MASK0_A = 0x%lx&bslash;n&quot;
comma
id|LOCAL_HUB_L
c_func
(paren
id|PI_INT_MASK0_A
)paren
)paren
suffix:semicolon
)brace
DECL|function|setup_irq
r_int
id|setup_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|irqaction
op_star
r_new
)paren
(brace
r_int
id|shared
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqaction
op_star
id|old
comma
op_star
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;setup_irq: 0x%x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRQ array overflow %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|flags
op_amp
id|SA_SAMPLE_RANDOM
)paren
id|rand_initialize_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|p
op_assign
id|irq_action
op_plus
id|irq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Can&squot;t share interrupts unless both agree to */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old-&gt;flags
op_amp
r_new
op_member_access_from_pointer
id|flags
op_amp
id|SA_SHIRQ
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Add new interrupt at end of irq queue */
r_do
(brace
id|p
op_assign
op_amp
id|old-&gt;next
suffix:semicolon
id|old
op_assign
op_star
id|p
suffix:semicolon
)brace
r_while
c_loop
(paren
id|old
)paren
suffix:semicolon
id|shared
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|p
op_assign
r_new
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|shared
)paren
op_logical_and
(paren
id|irq
op_ge
id|BASE_PCI_IRQ
)paren
)paren
(brace
id|bridge_startup
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;request_irq(): irq= 0x%x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|action
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;mask
op_assign
l_int|0
suffix:semicolon
id|action-&gt;name
op_assign
id|devname
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;request_irq(): %s  devid= 0x%x&bslash;n&quot;
comma
id|devname
comma
id|dev_id
)paren
suffix:semicolon
id|retval
op_assign
id|setup_irq
c_func
(paren
id|irq
comma
id|action
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;request_irq(): retval= %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|irq
op_plus
id|irq_action
suffix:semicolon
(paren
id|action
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_ne
id|dev_id
)paren
r_continue
suffix:semicolon
multiline_comment|/* Found it - now free it */
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|p
op_assign
id|action-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|BASE_PCI_IRQ
)paren
id|bridge_shutdown
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* Useless ISA nonsense.  */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
(paren
r_void
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;probe_irq_on called!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|probe_irq_off
r_int
id|probe_irq_off
(paren
r_int
r_int
id|irqs
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
id|set_except_vector
c_func
(paren
l_int|0
comma
id|ip27_irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * This following are the global intr on off routines, copied almost&n; * entirely from i386 code.&n; */
DECL|variable|global_irq_holder
r_int
id|global_irq_holder
op_assign
id|NO_PROC_ID
suffix:semicolon
DECL|variable|global_irq_lock
id|spinlock_t
id|global_irq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_extern
r_void
id|show_stack
c_func
(paren
r_int
r_int
op_star
id|esp
)paren
suffix:semicolon
DECL|function|show
r_static
r_void
id|show
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s, CPU %d:&bslash;n&quot;
comma
id|str
comma
id|cpu
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq:  %d [&quot;
comma
id|irqs_running
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|local_irq_count
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; ]&bslash;nbh:   %d [&quot;
comma
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|local_bh_count
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; ]&bslash;nStack dumps:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|esp
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|cpu
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCPU %d:&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Code not developed yet&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* show_stack(0); */
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCPU %d:&quot;
comma
id|cpu
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Code not developed yet&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* show_stack(NULL); */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|macro|MAXCOUNT
mdefine_line|#define MAXCOUNT &t;&t;100000000
DECL|macro|SYNC_OTHER_CORES
mdefine_line|#define SYNC_OTHER_CORES(x)&t;udelay(x+1)
DECL|function|wait_on_irq
r_static
r_inline
r_void
id|wait_on_irq
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|count
op_assign
id|MAXCOUNT
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * Wait until all interrupts are gone. Wait&n;&t;&t; * for bottom half handlers unless we&squot;re&n;&t;&t; * already executing in one..&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|irqs_running
c_func
(paren
)paren
)paren
r_if
c_cond
(paren
id|local_bh_count
c_func
(paren
id|cpu
)paren
op_logical_or
op_logical_neg
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Duh, we have to loop. Release the lock to avoid deadlocks */
id|spin_unlock
c_func
(paren
op_amp
id|global_irq_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
(brace
id|show
c_func
(paren
l_string|&quot;wait_on_irq&quot;
)paren
suffix:semicolon
id|count
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|SYNC_OTHER_CORES
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqs_running
c_func
(paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_bh_count
c_func
(paren
id|cpu
)paren
op_logical_and
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|synchronize_irq
r_void
id|synchronize_irq
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|irqs_running
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Stupid approach */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_irqlock
r_static
r_inline
r_void
id|get_irqlock
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
(brace
multiline_comment|/* do we already hold the lock? */
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|cpu
op_eq
id|global_irq_holder
)paren
r_return
suffix:semicolon
multiline_comment|/* Uhhuh.. Somebody else got it. Wait.. */
id|spin_lock
c_func
(paren
op_amp
id|global_irq_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We also to make sure that nobody else is running&n;&t; * in an interrupt context.&n;&t; */
id|wait_on_irq
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, finally..&n;&t; */
id|global_irq_holder
op_assign
id|cpu
suffix:semicolon
)brace
DECL|function|__global_cli
r_void
id|__global_cli
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|ST0_IE
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
id|get_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|__global_sti
r_void
id|__global_sti
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
id|release_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * SMP flags value to restore to:&n; * 0 - global cli&n; * 1 - global sti&n; * 2 - local cli&n; * 3 - local sti&n; */
DECL|function|__global_save_flags
r_int
r_int
id|__global_save_flags
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|local_enabled
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_enabled
op_assign
(paren
id|flags
op_amp
id|ST0_IE
)paren
suffix:semicolon
multiline_comment|/* default to local */
id|retval
op_assign
l_int|2
op_plus
id|local_enabled
suffix:semicolon
multiline_comment|/* check for global flags if we&squot;re not in an interrupt */
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
(brace
r_if
c_cond
(paren
id|local_enabled
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|global_irq_holder
op_eq
id|cpu
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|__global_restore_flags
r_void
id|__global_restore_flags
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
l_int|0
suffix:colon
id|__global_cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|__global_sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|__sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;global_restore_flags: %08lx&bslash;n&quot;
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; * Get values that vary depending on which CPU and bit we&squot;re operating on.&n; */
DECL|function|intr_get_ptrs
r_static
id|hub_intmasks_t
op_star
id|intr_get_ptrs
c_func
(paren
id|cpuid_t
id|cpu
comma
r_int
id|bit
comma
r_int
op_star
id|new_bit
comma
id|hubreg_t
op_star
op_star
id|intpend_masks
comma
r_int
op_star
id|ip
)paren
(brace
id|hub_intmasks_t
op_star
id|hub_intmasks
suffix:semicolon
id|hub_intmasks
op_assign
op_amp
id|cpu_data
(braket
id|cpu
)braket
dot
id|p_intmasks
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
id|N_INTPEND_BITS
)paren
(brace
op_star
id|intpend_masks
op_assign
id|hub_intmasks-&gt;intpend0_masks
suffix:semicolon
op_star
id|ip
op_assign
l_int|0
suffix:semicolon
op_star
id|new_bit
op_assign
id|bit
suffix:semicolon
)brace
r_else
(brace
op_star
id|intpend_masks
op_assign
id|hub_intmasks-&gt;intpend1_masks
suffix:semicolon
op_star
id|ip
op_assign
l_int|1
suffix:semicolon
op_star
id|new_bit
op_assign
id|bit
op_minus
id|N_INTPEND_BITS
suffix:semicolon
)brace
r_return
id|hub_intmasks
suffix:semicolon
)brace
DECL|function|intr_connect_level
r_int
id|intr_connect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
(brace
r_int
id|ip
suffix:semicolon
r_int
id|slice
op_assign
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_volatile
id|hubreg_t
op_star
id|mask_reg
suffix:semicolon
id|hubreg_t
op_star
id|intpend_masks
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|intr_get_ptrs
c_func
(paren
id|cpu
comma
id|bit
comma
op_amp
id|bit
comma
op_amp
id|intpend_masks
comma
op_amp
id|ip
)paren
suffix:semicolon
multiline_comment|/* Make sure it&squot;s not already pending when we connect it. */
id|REMOTE_HUB_CLR_INTR
c_func
(paren
id|nasid
comma
id|bit
op_plus
id|ip
op_star
id|N_INTPEND_BITS
)paren
suffix:semicolon
id|intpend_masks
(braket
l_int|0
)braket
op_or_assign
(paren
l_int|1ULL
op_lshift
(paren
id|u64
)paren
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
r_else
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
id|HUB_S
c_func
(paren
id|mask_reg
comma
id|intpend_masks
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intr_disconnect_level
r_int
id|intr_disconnect_level
c_func
(paren
r_int
id|cpu
comma
r_int
id|bit
)paren
(brace
r_int
id|ip
suffix:semicolon
r_int
id|slice
op_assign
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_volatile
id|hubreg_t
op_star
id|mask_reg
suffix:semicolon
id|hubreg_t
op_star
id|intpend_masks
suffix:semicolon
id|nasid_t
id|nasid
op_assign
id|COMPACT_TO_NASID_NODEID
c_func
(paren
id|cputocnode
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|intr_get_ptrs
c_func
(paren
id|cpu
comma
id|bit
comma
op_amp
id|bit
comma
op_amp
id|intpend_masks
comma
op_amp
id|ip
)paren
suffix:semicolon
id|intpend_masks
(braket
l_int|0
)braket
op_and_assign
op_complement
(paren
l_int|1ULL
op_lshift
(paren
id|u64
)paren
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK0_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
r_else
(brace
id|mask_reg
op_assign
id|REMOTE_HUB_ADDR
c_func
(paren
id|nasid
comma
id|PI_INT_MASK1_A
op_plus
id|PI_INT_MASK_OFFSET
op_star
id|slice
)paren
suffix:semicolon
)brace
id|HUB_S
c_func
(paren
id|mask_reg
comma
id|intpend_masks
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_resched_intr
r_void
id|handle_resched_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Nothing, the return from intr will work for us */
)brace
r_extern
r_void
id|smp_call_function_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|install_cpuintr
r_void
id|install_cpuintr
c_func
(paren
r_int
id|cpu
)paren
(brace
macro_line|#ifdef CONFIG_SMP
macro_line|#if (CPUS_PER_NODE == 2)
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|irq
suffix:semicolon
multiline_comment|/*&n;&t; * This is a hack till we have a pernode irqlist. Currently,&n;&t; * just have the master cpu set up the handlers for the per&n;&t; * cpu irqs.&n;&t; */
id|irq
op_assign
id|CPU_RESCHED_A_IRQ
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|IRQ_TO_SWLEVEL
c_func
(paren
id|cpu
comma
id|irq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|handle_resched_intr
comma
l_int|0
comma
l_string|&quot;resched&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&bslash;n&quot;
)paren
suffix:semicolon
id|irq
op_assign
id|CPU_CALL_A_IRQ
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|IRQ_TO_SWLEVEL
c_func
(paren
id|cpu
comma
id|irq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|smp_call_function_interrupt
comma
l_int|0
comma
l_string|&quot;callfunc&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* HACK STARTS */
r_if
c_cond
(paren
id|done
)paren
r_return
suffix:semicolon
id|irq
op_assign
id|CPU_RESCHED_A_IRQ
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|handle_resched_intr
comma
l_int|0
comma
l_string|&quot;resched&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&bslash;n&quot;
)paren
suffix:semicolon
id|irq
op_assign
id|CPU_CALL_A_IRQ
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|smp_call_function_interrupt
comma
l_int|0
comma
l_string|&quot;callfunc&quot;
comma
l_int|0
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;intercpu intr unconnectible&bslash;n&quot;
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* HACK ENDS */
macro_line|#else /* CPUS_PER_NODE */
macro_line|#error Must redefine this for more than 2 CPUS.
macro_line|#endif /* CPUS_PER_NODE */
macro_line|#endif /* CONFIG_SMP */
)brace
DECL|function|install_tlbintr
r_void
id|install_tlbintr
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|intr_bit
op_assign
id|N_INTPEND_BITS
op_plus
id|TLB_INTR_A
op_plus
id|cputoslice
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|intr_connect_level
c_func
(paren
id|cpu
comma
id|intr_bit
)paren
suffix:semicolon
)brace
eof
