multiline_comment|/*&n; * arch/m68k/q40/q40ints.c&n; *&n; * Copyright (C) 1999 Richard Zidlicky&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; *&n; * losely based on bvme6000ints.c&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/q40_master.h&gt;
macro_line|#include &lt;asm/q40ints.h&gt;
multiline_comment|/* &n; * Q40 IRQs are defined as follows: &n; *            3,4,5,6,7,10,11,14,15 : ISA dev IRQs&n; *            16-31: reserved&n; *            32   : keyboard int&n; *            33   : frame int (50/200 Hz periodic timer)&n; *            34   : sample int (10/20 KHz periodic timer)&n; *          &n;*/
r_extern
r_int
id|ints_inited
suffix:semicolon
r_void
id|q40_irq2_handler
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|q40_sys_default_handler
(braket
)braket
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/* added just for debugging */
r_static
r_void
id|q40_defhand
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|sys_default_handler
c_func
(paren
r_int
id|lev
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|macro|DEVNAME_SIZE
mdefine_line|#define DEVNAME_SIZE 24
DECL|struct|q40_irq_node
r_static
r_struct
id|q40_irq_node
(brace
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|dev_id
r_void
op_star
id|dev_id
suffix:semicolon
multiline_comment|/*        struct q40_irq_node *next;*/
DECL|member|devname
r_char
id|devname
(braket
id|DEVNAME_SIZE
)braket
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|state
r_int
r_int
id|state
suffix:semicolon
DECL|variable|irq_tab
)brace
id|irq_tab
(braket
id|Q40_IRQ_MAX
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|q40_ablecount
r_int
r_int
id|q40_ablecount
(braket
id|Q40_IRQ_MAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; * void q40_init_IRQ (void)&n; *&n; * Parameters:&t;None&n; *&n; * Returns:&t;Nothing&n; *&n; * This function is called during kernel startup to initialize&n; * the q40 IRQ handling routines.&n; */
DECL|function|q40_init_IRQ
r_void
id|q40_init_IRQ
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|Q40_IRQ_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_tab
(braket
id|i
)braket
dot
id|handler
op_assign
id|q40_defhand
suffix:semicolon
id|irq_tab
(braket
id|i
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|irq_tab
(braket
id|i
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&t;&t;irq_tab[i].next = NULL;*/
id|irq_tab
(braket
id|i
)braket
dot
id|devname
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|irq_tab
(braket
id|i
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|irq_tab
(braket
id|i
)braket
dot
id|state
op_assign
l_int|0
suffix:semicolon
id|q40_ablecount
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* all enabled */
)brace
multiline_comment|/* setup handler for ISA ints */
id|sys_request_irq
c_func
(paren
id|IRQ2
comma
id|q40_irq2_handler
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;q40 ISA and master chip&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* now enable some ints.. */
macro_line|#if 0  /* has been abandoned */
id|master_outb
c_func
(paren
l_int|1
comma
id|SER_ENABLE_REG
)paren
suffix:semicolon
macro_line|#endif
id|master_outb
c_func
(paren
l_int|1
comma
id|EXT_ENABLE_REG
)paren
suffix:semicolon
multiline_comment|/* would be spurious ints by now, q40kbd_init_hw() does that */
id|master_outb
c_func
(paren
l_int|0
comma
id|KEY_IRQ_ENABLE_REG
)paren
suffix:semicolon
)brace
DECL|function|q40_request_irq
r_int
id|q40_request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
multiline_comment|/*printk(&quot;q40_request_irq %d, %s&bslash;n&quot;,irq,devname);*/
r_if
c_cond
(paren
id|irq
OG
id|Q40_IRQ_MAX
op_logical_or
(paren
id|irq
OG
l_int|15
op_logical_and
id|irq
OL
l_int|32
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Incorrect IRQ %d from %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|devname
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* test for ISA ints not implemented by HW */
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|9
suffix:colon
r_case
l_int|12
suffix:colon
r_case
l_int|13
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: ISA IRQ %d from %s not implemented by HW&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|devname
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
r_case
l_int|11
suffix:colon
id|printk
c_func
(paren
l_string|&quot;warning IRQ 10 and 11 not distinguishable&bslash;n&quot;
)paren
suffix:semicolon
id|irq
op_assign
l_int|10
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
r_if
c_cond
(paren
id|irq
OL
id|Q40_IRQ_TIMER
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|flags
op_amp
id|IRQ_FLG_STD
)paren
)paren
(brace
r_if
c_cond
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|flags
op_amp
id|IRQ_FLG_LOCK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: IRQ %d from %s is not replaceable&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|irq_tab
(braket
id|irq
)braket
dot
id|devname
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|IRQ_FLG_REPLACE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s can&squot;t replace IRQ %d from %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|devname
comma
id|irq
comma
id|irq_tab
(braket
id|irq
)braket
dot
id|devname
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/*printk(&quot;IRQ %d set to handler %p&bslash;n&quot;,irq,handler);*/
id|irq_tab
(braket
id|irq
)braket
dot
id|handler
op_assign
id|handler
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|dev_id
op_assign
id|dev_id
suffix:semicolon
id|strncpy
c_func
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|devname
comma
id|devname
comma
id|DEVNAME_SIZE
)paren
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|state
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Q40_IRQ_TIMER :somewhat special actions required here ..*/
id|sys_request_irq
c_func
(paren
l_int|4
comma
id|handler
comma
id|flags
comma
id|devname
comma
id|dev_id
)paren
suffix:semicolon
id|sys_request_irq
c_func
(paren
l_int|6
comma
id|handler
comma
id|flags
comma
id|devname
comma
id|dev_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|q40_free_irq
r_void
id|q40_free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_if
c_cond
(paren
id|irq
OG
id|Q40_IRQ_MAX
op_logical_or
(paren
id|irq
OG
l_int|15
op_logical_and
id|irq
OL
l_int|32
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Incorrect IRQ %d, dev_id %x &bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
(paren
r_int
)paren
id|dev_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* test for ISA ints not implemented by HW */
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|9
suffix:colon
r_case
l_int|12
suffix:colon
r_case
l_int|13
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: ISA IRQ %d from %x illegal&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
(paren
r_int
)paren
id|dev_id
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|11
suffix:colon
id|irq
op_assign
l_int|10
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
r_if
c_cond
(paren
id|irq
OL
id|Q40_IRQ_TIMER
)paren
(brace
r_if
c_cond
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|dev_id
op_ne
id|dev_id
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Removing probably wrong IRQ %d from %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|irq_tab
(braket
id|irq
)braket
dot
id|devname
)paren
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|handler
op_assign
id|q40_defhand
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* irq_tab[irq].devname = NULL; */
multiline_comment|/* do not reset state !! */
)brace
r_else
(brace
multiline_comment|/* == Q40_IRQ_TIMER */
id|sys_free_irq
c_func
(paren
l_int|4
comma
id|dev_id
)paren
suffix:semicolon
id|sys_free_irq
c_func
(paren
l_int|6
comma
id|dev_id
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 1
DECL|function|q40_process_int
r_void
id|q40_process_int
(paren
r_int
id|level
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unexpected interrupt %x&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * tables to translate bits into IRQ numbers &n; * it is a good idea to order the entries by priority&n; * &n;*/
DECL|struct|IRQ_TABLE
DECL|member|mask
DECL|member|irq
r_struct
id|IRQ_TABLE
(brace
r_int
id|mask
suffix:semicolon
r_int
id|irq
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|iirqs
r_static
r_struct
id|IRQ_TABLE
id|iirqs
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|eirqs
r_static
r_struct
id|IRQ_TABLE
id|eirqs
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* complain only this many times about spurious ints : */
DECL|variable|ccleirq
r_static
r_int
id|ccleirq
op_assign
l_int|60
suffix:semicolon
multiline_comment|/* ISA dev IRQ&squot;s*/
DECL|variable|cclirq
r_static
r_int
id|cclirq
op_assign
l_int|60
suffix:semicolon
multiline_comment|/* internal */
multiline_comment|/* FIX: add shared ints,mask,unmask,probing.... */
multiline_comment|/* this is an awfull hack.. */
DECL|macro|IRQ_INPROGRESS
mdefine_line|#define IRQ_INPROGRESS 1
DECL|variable|disabled
r_static
r_int
id|disabled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*static unsigned short saved_mask;*/
DECL|function|q40_irq2_handler
r_void
id|q40_irq2_handler
(paren
r_int
id|vec
comma
r_void
op_star
id|devname
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
multiline_comment|/* got level 2 interrupt, dispatch to ISA or keyboard IRQs */
r_int
id|mir
op_assign
id|master_inb
c_func
(paren
id|IIRQ_REG
)paren
suffix:semicolon
r_int
id|mer
suffix:semicolon
r_int
id|irq
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mir
op_amp
id|IRQ_SER_MASK
)paren
op_logical_or
(paren
id|mir
op_amp
id|IRQ_EXT_MASK
)paren
)paren
(brace
multiline_comment|/* some ISA dev caused the int */
id|mer
op_assign
id|master_inb
c_func
(paren
id|EIRQ_REG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|eirqs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mer
op_amp
(paren
id|eirqs
(braket
id|i
)braket
dot
id|mask
)paren
)paren
(brace
id|irq
op_assign
id|eirqs
(braket
id|i
)braket
dot
id|irq
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|handler
op_eq
id|q40_defhand
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;handler for IRQ %d not defined&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* ignore uninited INTs :-( */
)brace
r_if
c_cond
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|state
op_amp
id|IRQ_INPROGRESS
)paren
(brace
multiline_comment|/*printk(&quot;IRQ_INPROGRESS detected for irq %d, disabling - %s disabled&bslash;n&quot;,irq,disabled ? &quot;already&quot; : &quot;not yet&quot;); */
multiline_comment|/*saved_mask = fp-&gt;sr;*/
id|fp-&gt;sr
op_assign
(paren
id|fp-&gt;sr
op_amp
(paren
op_complement
l_int|0x700
)paren
)paren
op_plus
l_int|0x200
suffix:semicolon
id|disabled
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|irq_tab
(braket
id|irq
)braket
dot
id|state
op_or_assign
id|IRQ_INPROGRESS
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|handler
c_func
(paren
id|irq
comma
id|irq_tab
(braket
id|irq
)braket
dot
id|dev_id
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* naively enable everything, if that fails than    */
multiline_comment|/* this function will be reentered immediately thus */
multiline_comment|/* getting another chance to disable the IRQ        */
id|irq_tab
(braket
id|irq
)braket
dot
id|state
op_and_assign
op_complement
id|IRQ_INPROGRESS
suffix:semicolon
r_if
c_cond
(paren
id|disabled
)paren
(brace
multiline_comment|/*printk(&quot;reenabling irq %d&bslash;n&quot;,irq); */
id|fp-&gt;sr
op_assign
(paren
id|fp-&gt;sr
op_amp
(paren
op_complement
l_int|0x700
)paren
)paren
suffix:semicolon
multiline_comment|/*saved_mask; */
id|disabled
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fp-&gt;sr
op_amp
l_int|0x200
)paren
id|printk
c_func
(paren
l_string|&quot;exiting irq handler: fp-&gt;sr &amp;0x200 !!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ccleirq
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;ISA interrupt from unknown source? EIRQ_REG = %x&bslash;n&quot;
comma
id|mer
)paren
comma
id|ccleirq
op_decrement
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* internal */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|iirqs
(braket
id|i
)braket
dot
id|mask
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mir
op_amp
(paren
id|iirqs
(braket
id|i
)braket
dot
id|mask
)paren
)paren
(brace
id|irq
op_assign
id|iirqs
(braket
id|i
)braket
dot
id|irq
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|handler
op_eq
id|q40_defhand
)paren
r_continue
suffix:semicolon
multiline_comment|/* ignore uninited INTs :-( */
multiline_comment|/* the INPROGRESS stuff should be completely useless*/
multiline_comment|/* for internal ints, nevertheless test it..*/
r_if
c_cond
(paren
id|irq_tab
(braket
id|irq
)braket
dot
id|state
op_amp
id|IRQ_INPROGRESS
)paren
(brace
multiline_comment|/*disable_irq(irq);&n;&t;&t;&t;  return;*/
id|printk
c_func
(paren
l_string|&quot;rentering handler for IRQ %d !!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
id|irq_tab
(braket
id|irq
)braket
dot
id|handler
c_func
(paren
id|irq
comma
id|irq_tab
(braket
id|irq
)braket
dot
id|dev_id
comma
id|fp
)paren
suffix:semicolon
id|irq_tab
(braket
id|irq
)braket
dot
id|state
op_and_assign
op_complement
id|IRQ_INPROGRESS
suffix:semicolon
multiline_comment|/*enable_irq(irq);*/
multiline_comment|/* better not try luck !*/
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cclirq
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;internal level 2 interrupt from unknown source ? IIRQ_REG=%x&bslash;n&quot;
comma
id|mir
)paren
comma
id|cclirq
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|q40_get_irq_list
r_int
id|q40_get_irq_list
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|Q40_IRQ_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irq_tab
(braket
id|i
)braket
dot
id|count
)paren
id|len
op_add_assign
id|sprintf
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Vec 0x%02x: %8d  %s%s&bslash;n&quot;
comma
id|i
comma
id|irq_tab
(braket
id|i
)braket
dot
id|count
comma
id|irq_tab
(braket
id|i
)braket
dot
id|devname
(braket
l_int|0
)braket
ques
c_cond
id|irq_tab
(braket
id|i
)braket
dot
id|devname
suffix:colon
l_string|&quot;?&quot;
comma
id|irq_tab
(braket
id|i
)braket
dot
id|handler
op_eq
id|q40_defhand
ques
c_cond
l_string|&quot; (now unassigned)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|q40_defhand
r_static
r_void
id|q40_defhand
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;Unknown q40 interrupt 0x%02x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|sys_default_handler
r_static
r_void
id|sys_default_handler
c_func
(paren
r_int
id|lev
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|ints_inited
)paren
macro_line|#endif
id|printk
(paren
l_string|&quot;Uninitialised interrupt level %d&bslash;n&quot;
comma
id|lev
)paren
suffix:semicolon
macro_line|#if 0
r_else
id|printk
(paren
l_string|&quot;Interrupt before interrupt initialisation&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|q40_sys_default_handler
r_void
(paren
op_star
id|q40_sys_default_handler
(braket
id|SYS_IRQS
)braket
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
op_assign
(brace
id|sys_default_handler
comma
id|sys_default_handler
comma
id|sys_default_handler
comma
id|sys_default_handler
comma
id|sys_default_handler
comma
id|sys_default_handler
comma
id|sys_default_handler
comma
id|sys_default_handler
)brace
suffix:semicolon
DECL|variable|irq_disabled
r_int
id|irq_disabled
op_assign
l_int|0
suffix:semicolon
DECL|function|q40_enable_irq
r_void
id|q40_enable_irq
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* enable ISA iqs */
r_if
c_cond
(paren
id|irq
op_ge
l_int|0
op_logical_and
id|irq
op_le
l_int|15
)paren
multiline_comment|/* the moderately bad case */
id|master_outb
c_func
(paren
l_int|1
comma
id|EXT_ENABLE_REG
)paren
suffix:semicolon
macro_line|#if 0
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
l_int|10
op_logical_and
id|irq
op_le
l_int|15
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|q40_ablecount
(braket
id|irq
)braket
)paren
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|10
comma
id|irq_disabled
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_disabled
op_or_assign
(paren
id|q40_ablecount
(braket
id|irq
)braket
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|irq_disabled
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
op_amp
(paren
op_complement
l_int|0x700
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
DECL|function|q40_disable_irq
r_void
id|q40_disable_irq
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* disable ISA iqs : only do something if the driver has been&n;  * verified to be Q40 &quot;compatible&quot; - right now only IDE&n;  * Any driver should not attempt to sleep accross disable_irq !!&n;  */
r_if
c_cond
(paren
id|irq
op_ge
l_int|10
op_logical_and
id|irq
op_le
l_int|15
)paren
multiline_comment|/* the moderately bad case */
id|master_outb
c_func
(paren
l_int|0
comma
id|EXT_ENABLE_REG
)paren
suffix:semicolon
macro_line|#if 0
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
l_int|10
op_logical_and
id|irq
op_le
l_int|15
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
op_or
l_int|0x200
)paren
suffix:semicolon
id|irq_disabled
op_assign
l_int|1
suffix:semicolon
id|q40_ablecount
(braket
id|irq
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|q40_probe_irq_on
r_int
r_int
id|q40_probe_irq_on
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;irq probing not working - reconfigure the driver to avoid this&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|q40_probe_irq_off
r_int
id|q40_probe_irq_off
(paren
r_int
r_int
id|irqs
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
eof
