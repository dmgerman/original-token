multiline_comment|/*&n; *  arch/m68k/kernel/kgdb.c  --  Stub for GDB remote debugging protocol&n; *&n; *  Originally written by Glenn Engel, Lake Stevens Instrument Division&n; *&n; *  Contributed by HP Systems&n; *&n; *  Modified for SPARC by Stu Grossman, Cygnus Support.&n; *  Modified for Linux/MIPS (and MIPS in general) by Andreas Busse&n; *  Modified and extended for Linux/68k by Roman Hodek&n; *&n; *  Send complaints, suggestions etc. to&n; *  &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;&n; *&n; *  Copyright (C) 1996-97 Roman Hodek&n; */
multiline_comment|/*&n; *  kgdb usage notes:&n; *  -----------------&n; *&n; * If you select CONFIG_KGDB in the configuration, the kernel will be built&n; * with different gccc flags: &quot;-g&quot; is added to get debug infos, and&n; * &quot;-fomit-frame-pointer&quot; is omitted to make debugging easier. Since the&n; * resulting kernel will be quite big (approx. &gt; 7 MB), it will be stripped&n; * before compresion. Such a kernel will behave just as usually, except if&n; * given a &quot;debug=&lt;device&gt;&quot; command line option. (Only serial devices are&n; * allowed for &lt;device&gt;, i.e. no printers or the like; possible values are&n; * machine depedend and are the same as for the usual debug device, the one&n; * for logging kernel messages.) If that option is given and the device can be&n; * initialized, the kernel will connect to the remote gdb in trap_init(). The&n; * serial parameters are fixed to 8N1 and 9600bps, for easyness of&n; * implementation.&n; *&n; * Of course, you need a remote machine a suitable gdb there. I.e., it must&n; * have support for a m68k-linux target built in. If the remote machine&n; * doesn&squot;t run Linux/68k itself, you have to build a cross gdb. This is done&n; * by&n; *    ./configure --target=m68k-linux&n; * in the gdb source directory. Until gdb comes with m68k-linux support by&n; * default, you have to apply some patches before. The remote debugging&n; * protocol itself is always built into gdb anyway, so you don&squot;t have to take&n; * special care about it.&n; *&n; * To start a debugging session, start that gdb with the debugging kernel&n; * image (the one with the symbols, vmlinux.debug) named on the command line.&n; * This file will be used by gdb to get symbol and debugging infos about the&n; * kernel. Next, select remote debug mode by&n; *    target remote &lt;device&gt;&n; * where &lt;device&gt; is the name of the serial device over which the debugged&n; * machine is connected. Maybe you have to adjust the baud rate by&n; *    set remotebaud &lt;rate&gt;&n; * or also other parameters with stty:&n; *    shell stty ... &lt;/dev/...&n; * If the kernel to debug has already booted, it waited for gdb and now&n; * connects, and you&squot;ll see a breakpoint being reported. If the kernel isn&squot;t&n; * running yet, start it now. The order of gdb and the kernel doesn&squot;t matter.&n; * Another thing worth knowing about in the getting-started phase is how to&n; * debug the remote protocol itself. This is activated with&n; *    set remotedebug 1&n; * gdb will then print out each packet sent or received. You&squot;ll also get some&n; * messages about the gdb stub on the console of the debugged machine.&n; *&n; * If all that works, you can use lots of the usual debugging techniques on&n; * the kernel, e.g. inspecting and changing variables/memory, setting&n; * breakpoints, single stepping and so on. It&squot;s also possible to interrupt the&n; * debugged kernel by pressing C-c in gdb. Have fun! :-)&n; *&n; * The gdb stub is entered (and thus the remote gdb gets control) in the&n; * following situations:&n; *&n; *  - If breakpoint() is called. This is just after kgdb initialization, or if&n; *    a breakpoint() call has been put somewhere into the kernel source.&n; *    (Breakpoints can of course also be set the usual way in gdb.)&n; *&n; *  - If there is a kernel exception, i.e. bad_super_trap() or die_if_kernel()&n; *    are entered. All the CPU exceptions are mapped to (more or less..., see&n; *    the hard_trap_info array below) appropriate signal, which are reported&n; *    to gdb. die_if_kernel() is usually called after some kind of access&n; *    error and thus is reported as SIGSEGV.&n; *&n; *  - When panic() is called. This is reported as SIGABRT.&n; *&n; *  - If C-c is received over the serial line, which is treated as&n; *    SIGINT.&n; *&n; * Of course, all these signals are just faked for gdb, since there is no&n; * signal concept as such for the kernel. It also isn&squot;t possible --obviously--&n; * to set signal handlers from inside gdb, or restart the kernel with a&n; * signal.&n; *&n; * Current limitations:&n; *&n; *  - While the kernel is stopped, interrupts are disabled for safety reasons&n; *    (i.e., variables not changing magically or the like). But this also&n; *    means that the clock isn&squot;t running anymore, and that interrupts from the&n; *    hardware may get lost/not be served in time. This can cause some device&n; *    errors...&n; *&n; *  - When single-stepping, only one instruction of the current thread is&n; *    executed, but interrupts are allowed for that time and will be serviced&n; *    if pending. Be prepared for that.&n; *&n; *  - All debugging happens in kernel virtual address space. There&squot;s no way to&n; *    access physical memory not mapped in kernel space, or to access user&n; *    space. A way to work around this is using get_user_long &amp; Co. in gdb&n; *    expressions, but only for the current process.&n; *&n; *  - Interrupting the kernel only works if interrupts are currently allowed,&n; *    and the interrupt of the serial line isn&squot;t blocked by some other means&n; *    (IPL too high, disabled, ...)&n; *&n; *  - The gdb stub is currently not reentrant, i.e. errors that happen therein&n; *    (e.g. accesing invalid memory) may not be caught correctly. This could&n; *    be removed in future by introducing a stack of struct registers.&n; *&n; */
multiline_comment|/*&n; *  To enable debugger support, two things need to happen.  One, a&n; *  call to kgdb_init() is necessary in order to allow any breakpoints&n; *  or error conditions to be properly intercepted and reported to gdb.&n; *  (Linux/68k note: Due to the current design, kgdb has to be initialized&n; *  after traps and interrupts.)&n; *  Two, a breakpoint needs to be generated to begin communication.  This&n; *  is most easily accomplished by a call to breakpoint().  Breakpoint()&n; *  simulates a breakpoint by executing a TRAP #15 instruction.&n; *&n; *&n; *    The following gdb commands are supported:&n; *&n; * command          function                               Return value&n; *&n; *    g             return the value of the CPU registers  hex data or ENN&n; *    G             set the value of the CPU registers     OK or ENN&n; *&n; *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN&n; *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN&n; *&n; *    c             Resume at current address              SNN   ( signal NN)&n; *    cAA..AA       Continue at address AA..AA             SNN&n; *&n; *    s             Step one instruction                   SNN&n; *    sAA..AA       Step one instruction from AA..AA       SNN&n; *&n; *    k             kill&n; *&n; *    ?             What was the last sigval ?             SNN   (signal NN)&n; *&n; *    bBB..BB&t;    Set baud rate to BB..BB&t;&t;   OK or BNN, then sets&n; *&t;&t;&t;&t;&t;&t;&t;   baud rate&n; *&n; * All commands and responses are sent with a packet which includes a&n; * checksum.  A packet consists of&n; *&n; * $&lt;packet info&gt;#&lt;checksum&gt;.&n; *&n; * where&n; * &lt;packet info&gt; :: &lt;characters representing the command or response&gt;&n; * &lt;checksum&gt;    :: &lt; two hex digits computed as modulo 256 sum of &lt;packetinfo&gt;&gt;&n; *&n; * When a packet is received, it is first acknowledged with either &squot;+&squot; or &squot;-&squot;.&n; * &squot;+&squot; indicates a successful transfer.  &squot;-&squot; indicates a failed transfer.&n; *&n; * Example:&n; *&n; * Host:                  Reply:&n; * $m0,10#2a               +$00010203040506070809101112131415#42&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/kgdb.h&gt;
macro_line|#ifdef CONFIG_ATARI
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_AMIGA
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#include &lt;asm/amigaints.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_MAC
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/macints.h&gt;
macro_line|#endif
DECL|macro|DEBUG
macro_line|#undef DEBUG
multiline_comment|/*&n; * global variable: register structure&n; */
DECL|variable|kgdb_registers
r_struct
id|gdb_regs
id|kgdb_registers
suffix:semicolon
multiline_comment|/*&n; * serial i/o functions&n; */
DECL|variable|serial_out
r_static
r_int
(paren
op_star
id|serial_out
)paren
(paren
r_int
r_char
id|c
)paren
suffix:semicolon
DECL|variable|serial_in
r_static
r_int
r_char
(paren
op_star
id|serial_in
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|serial_intr
r_static
r_int
r_char
(paren
op_star
id|serial_intr
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|macro|putDebugChar
mdefine_line|#define&t;putDebugChar(c)&t;&t;serial_out(c)
DECL|macro|getDebugChar
mdefine_line|#define&t;getDebugChar()&t;&t;serial_in()
multiline_comment|/***************************** Prototypes *****************************/
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|expect_ack
)paren
suffix:semicolon
r_static
r_inline
r_int
r_int
op_star
id|get_vbr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|protected_read
c_func
(paren
r_char
op_star
id|p
comma
r_int
r_int
op_star
id|vbr
)paren
suffix:semicolon
r_static
r_int
id|protected_write
c_func
(paren
r_char
op_star
id|p
comma
r_char
id|val
comma
r_int
r_int
op_star
id|vbr
)paren
suffix:semicolon
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
suffix:semicolon
r_static
r_char
op_star
id|hex2mem
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|mem
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
suffix:semicolon
r_static
r_int
id|computeSignal
c_func
(paren
r_int
id|tt
)paren
suffix:semicolon
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|kgdb_intr
c_func
(paren
r_int
id|intno
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
id|asmlinkage
r_void
id|handle_exception
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|show_gdbregs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI
r_static
r_int
id|atari_mfp_out
c_func
(paren
r_int
r_char
id|c
)paren
suffix:semicolon
r_static
r_int
r_char
id|atari_mfp_in
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_char
id|atari_mfp_intr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|atari_scc_out
c_func
(paren
r_int
r_char
id|c
)paren
suffix:semicolon
r_static
r_int
r_char
id|atari_scc_in
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_char
id|atari_scc_intr
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_AMIGA
r_extern
r_int
id|amiga_ser_out
c_func
(paren
r_int
r_char
id|c
)paren
suffix:semicolon
r_extern
r_int
r_char
id|amiga_ser_in
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MAC
r_static
r_int
r_char
id|mac_scca_in
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_char
id|mac_scca_out
c_func
(paren
r_int
r_char
id|c
)paren
suffix:semicolon
r_static
r_int
r_char
id|mac_scca_intr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_char
id|mac_sccb_in
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_char
id|mac_sccb_out
c_func
(paren
r_int
r_char
id|c
)paren
suffix:semicolon
r_static
r_int
r_char
id|mac_sccb_intr
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|mac_init_scc_port
c_func
(paren
r_int
id|cflag
comma
r_int
id|port
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/************************* End of Prototypes **************************/
DECL|variable|kgdb_initialized
r_int
id|kgdb_initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* !0 means we&squot;ve been initialized */
multiline_comment|/*&n; * BUFMAX defines the maximum number of characters in inbound/outbound buffers&n; * at least NUMREGBYTES*2 are needed for register packets&n; */
DECL|macro|BUFMAX
mdefine_line|#define BUFMAX 2048
DECL|variable|input_buffer
r_static
r_char
id|input_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|output_buffer
r_static
r_char
id|output_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|hexchars
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
multiline_comment|/* debug &gt; 0 prints ill-formed commands in valid packets &amp; checksum errors */
DECL|variable|remote_debug
r_static
r_int
id|remote_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* sizes (in bytes) of CPU stack frames */
DECL|variable|frame_sizes
r_static
r_int
id|frame_sizes
(braket
l_int|16
)braket
op_assign
(brace
l_int|8
comma
l_int|8
comma
l_int|12
comma
l_int|12
comma
multiline_comment|/* $0..$3 */
l_int|16
comma
l_int|8
comma
l_int|8
comma
l_int|60
comma
multiline_comment|/* $4..$7 */
l_int|8
comma
l_int|20
comma
l_int|32
comma
l_int|92
comma
multiline_comment|/* $8..$B */
l_int|12
comma
l_int|4
comma
l_int|4
comma
l_int|4
multiline_comment|/* $C..$F */
)brace
suffix:semicolon
multiline_comment|/*&n; * Convert ch from a hex digit to an int&n; */
DECL|function|hex
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * scan for the sequence $&lt;data&gt;#&lt;checksum&gt;&n; */
DECL|function|getpacket
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
r_char
id|xmitcsum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * wait around for the start character,&n;&t;&t; * ignore all other characters&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|ch
op_assign
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|xmitcsum
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now, read until a # or end of buffer is found&n;&t;&t; */
r_while
c_loop
(paren
id|count
OL
id|BUFMAX
)paren
(brace
id|ch
op_assign
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
id|checksum
op_assign
id|checksum
op_plus
id|ch
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
id|ch
suffix:semicolon
id|count
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
id|BUFMAX
)paren
r_continue
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;kgdb: received packet %s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|xmitcsum
op_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_lshift
l_int|4
suffix:semicolon
id|xmitcsum
op_or_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|xmitcsum
)paren
(brace
r_if
c_cond
(paren
id|remote_debug
)paren
id|printk
c_func
(paren
l_string|&quot;kgdb: bad checksum. count = 0x%x sent=0x%x &quot;
l_string|&quot;buf=%s&bslash;n&quot;
comma
id|checksum
comma
id|xmitcsum
comma
id|buffer
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
multiline_comment|/* failed checksum */
)brace
r_else
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* successful transfer */
multiline_comment|/*&n;&t;&t;&t;&t; * if a sequence char is present,&n;&t;&t;&t;&t; * reply the sequence ID&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer
(braket
l_int|2
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * remove sequence chars from buffer&n;&t;&t;&t;&t;&t; */
id|count
op_assign
id|strlen
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
id|buffer
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|checksum
op_ne
id|xmitcsum
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send the packet in buffer.&n; */
DECL|function|putpacket
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|expect_ack
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&n;&t; * $&lt;packet info&gt;#&lt;checksum&gt;.&n;&t; */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;kgdb: sending packet %s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|buffer
(braket
id|count
)braket
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|putDebugChar
c_func
(paren
id|ch
)paren
)paren
)paren
r_return
suffix:semicolon
id|checksum
op_add_assign
id|ch
suffix:semicolon
id|count
op_add_assign
l_int|1
suffix:semicolon
)brace
id|putDebugChar
c_func
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_amp
l_int|0xf
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|expect_ack
op_logical_and
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_ne
l_char|&squot;+&squot;
)paren
suffix:semicolon
)brace
DECL|function|get_vbr
r_static
r_inline
r_int
r_int
op_star
id|get_vbr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|vbr
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec&t;%/vbr,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|vbr
)paren
suffix:colon
)paren
suffix:semicolon
r_return
id|vbr
suffix:semicolon
)brace
DECL|function|protected_read
r_static
r_int
id|protected_read
c_func
(paren
r_char
op_star
id|p
comma
r_int
r_int
op_star
id|vbr
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel&t;%3@(8),%/a0&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;#Lberr1,%3@(8)&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%/sp,%/a1&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#1,%1&bslash;n&bslash;t&quot;
l_string|&quot;moveb&t;%2@,%0&bslash;n&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%1&bslash;n&bslash;t&quot;
l_string|&quot;Lberr1:&bslash;t&quot;
l_string|&quot;movel&t;%/a1,%/sp&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%/a0,%3@(8)&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|val
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|rv
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|p
)paren
comma
l_string|&quot;a&quot;
(paren
id|vbr
)paren
suffix:colon
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
)paren
suffix:semicolon
r_return
id|rv
ques
c_cond
op_minus
l_int|1
suffix:colon
id|val
suffix:semicolon
)brace
DECL|function|protected_write
r_static
r_int
id|protected_write
c_func
(paren
r_char
op_star
id|p
comma
r_char
id|val
comma
r_int
r_int
op_star
id|vbr
)paren
(brace
r_int
id|rv
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel&t;%3@(8),%/a0&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;#Lberr2,%3@(8)&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%/sp,%/a1&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#1,%0&bslash;n&bslash;t&quot;
l_string|&quot;moveb&t;%2,%1@&bslash;n&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%0&bslash;n&bslash;t&quot;
l_string|&quot;Lberr2:&bslash;t&quot;
l_string|&quot;movel&t;%/a1,%/sp&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%/a0,%3@(8)&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|rv
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|p
)paren
comma
l_string|&quot;d&quot;
(paren
id|val
)paren
comma
l_string|&quot;a&quot;
(paren
id|vbr
)paren
suffix:colon
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert the memory pointed to by mem into hex, placing result in buf.&n; * Return a pointer to the last char put in buf (null), in case of mem fault,&n; * return 0.&n; * If MAY_FAULT is non-zero, then we will handle memory faults by returning&n; * a 0, else treat a fault like any other fault in the stub.&n; */
DECL|function|mem2hex
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_int
id|ch
suffix:semicolon
r_int
r_int
op_star
id|vbr
op_assign
id|get_vbr
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|count
op_decrement
OG
l_int|0
suffix:semicolon
op_increment
id|mem
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|protected_read
c_func
(paren
id|mem
comma
id|vbr
)paren
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* bus error happened */
r_if
c_cond
(paren
id|may_fault
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/* ignore, but print a warning */
id|printk
c_func
(paren
l_string|&quot;Bus error on read from %p&bslash;n&quot;
comma
id|mem
)paren
suffix:semicolon
id|ch
op_assign
l_int|0
suffix:semicolon
)brace
)brace
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
(paren
id|ch
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * convert the hex array pointed to by buf into binary to be placed in mem&n; * return a pointer to the character AFTER the last byte written&n; */
DECL|function|hex2mem
r_static
r_char
op_star
id|hex2mem
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|mem
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_int
r_int
op_star
id|vbr
op_assign
id|get_vbr
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|mem
op_increment
)paren
(brace
id|ch
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|protected_write
c_func
(paren
id|mem
comma
id|ch
comma
id|vbr
)paren
)paren
(brace
multiline_comment|/* bus error happened */
r_if
c_cond
(paren
id|may_fault
)paren
r_return
l_int|0
suffix:semicolon
r_else
multiline_comment|/* ignore, but print a warning */
id|printk
c_func
(paren
l_string|&quot;Bus error on write to %p&bslash;n&quot;
comma
id|mem
)paren
suffix:semicolon
)brace
)brace
r_return
id|mem
suffix:semicolon
)brace
multiline_comment|/*&n; * This table contains the mapping between SPARC hardware trap types, and&n; * signals, which are primarily what GDB understands.  It also indicates&n; * which hardware traps we need to commandeer when initializing the stub.&n; */
DECL|struct|hard_trap_info
r_static
r_struct
id|hard_trap_info
(brace
DECL|member|tt
r_int
r_char
id|tt
suffix:semicolon
multiline_comment|/* Trap type code for MIPS R3xxx and R4xxx */
DECL|member|signo
r_int
r_char
id|signo
suffix:semicolon
multiline_comment|/* Signal that we map this trap into */
DECL|variable|hard_trap_info
)brace
id|hard_trap_info
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
id|SIGINT
)brace
comma
multiline_comment|/* excep. 1 is used to fake SIGINT */
(brace
id|VEC_BUSERR
comma
id|SIGSEGV
)brace
comma
multiline_comment|/* bus/access error */
(brace
id|VEC_ADDRERR
comma
id|SIGBUS
)brace
comma
multiline_comment|/* address error */
(brace
id|VEC_ILLEGAL
comma
id|SIGILL
)brace
comma
multiline_comment|/* illegal insn */
(brace
id|VEC_ZERODIV
comma
id|SIGFPE
)brace
comma
multiline_comment|/* (integer) divison by zero */
(brace
id|VEC_CHK
comma
id|SIGILL
)brace
comma
multiline_comment|/* CHK insn */
(brace
id|VEC_TRAP
comma
id|SIGFPE
)brace
comma
multiline_comment|/* [F]TRAPcc insn */
(brace
id|VEC_PRIV
comma
id|SIGILL
)brace
comma
multiline_comment|/* priviledge violation (cannot happen) */
(brace
id|VEC_TRACE
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* trace trap (single-stepping) */
(brace
id|VEC_LINE10
comma
id|SIGILL
)brace
comma
multiline_comment|/* A-line insn */
(brace
id|VEC_LINE11
comma
id|SIGILL
)brace
comma
multiline_comment|/* F-line insn */
(brace
id|VEC_COPROC
comma
id|SIGIOT
)brace
comma
multiline_comment|/* coprocessor protocol error */
(brace
id|VEC_FORMAT
comma
id|SIGIOT
)brace
comma
multiline_comment|/* frame format error */
(brace
id|VEC_UNINT
comma
id|SIGIOT
)brace
comma
multiline_comment|/* uninitialized intr. (should not happen) */
(brace
id|VEC_SYS
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #0 = system call (illegal in kernel) */
(brace
id|VEC_TRAP1
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #1 */
(brace
id|VEC_TRAP2
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #2 */
(brace
id|VEC_TRAP3
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #3 */
(brace
id|VEC_TRAP4
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #4 */
(brace
id|VEC_TRAP5
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #5 */
(brace
id|VEC_TRAP6
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #6 */
(brace
id|VEC_TRAP7
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #7 */
(brace
id|VEC_TRAP8
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #8 */
(brace
id|VEC_TRAP9
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #9 */
(brace
id|VEC_TRAP10
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #10 */
(brace
id|VEC_TRAP11
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #11 */
(brace
id|VEC_TRAP12
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #12 */
(brace
id|VEC_TRAP13
comma
id|SIGILL
)brace
comma
multiline_comment|/* TRAP #13 */
(brace
id|VEC_TRAP14
comma
id|SIGABRT
)brace
comma
multiline_comment|/* TRAP #14 (used by kgdb_abort) */
(brace
id|VEC_TRAP15
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* TRAP #15 (breakpoint) */
(brace
id|VEC_FPBRUC
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_FPIR
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_FPDIVZ
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_FPUNDER
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_FPOE
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_FPOVER
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_FPNAN
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_FPUNSUP
comma
id|SIGFPE
)brace
comma
multiline_comment|/* FPU */
(brace
id|VEC_UNIMPEA
comma
id|SIGILL
)brace
comma
multiline_comment|/* unimpl. effective address */
(brace
id|VEC_UNIMPII
comma
id|SIGILL
)brace
comma
multiline_comment|/* unimpl. integer insn */
(brace
l_int|0
comma
l_int|0
)brace
multiline_comment|/* Must be last */
)brace
suffix:semicolon
multiline_comment|/*&n; * Set up exception handlers for tracing and breakpoints&n; */
DECL|function|kgdb_init
r_void
id|kgdb_init
c_func
(paren
r_void
)paren
(brace
r_extern
r_char
id|m68k_debug_device
(braket
)braket
suffix:semicolon
multiline_comment|/* fake usage to avoid gcc warnings about unused stuff (they&squot;re used in&n;&t; * assembler code) The local variables will be optimized away... */
r_void
(paren
op_star
id|fake1
)paren
(paren
r_void
)paren
op_assign
id|handle_exception
suffix:semicolon
r_int
op_star
id|fake2
op_assign
id|frame_sizes
suffix:semicolon
(paren
r_void
)paren
id|fake1
suffix:semicolon
(paren
r_void
)paren
id|fake2
suffix:semicolon
multiline_comment|/* We don&squot;t modify the real exception vectors here for the m68k.&n;&t; * handle_exception() will be called from bad_kernel_trap() or&n;&t; * die_if_kernel() as needed. */
multiline_comment|/*&n;&t; * Initialize the serial port (name in &squot;m68k_debug_device&squot;)&n;&t; */
id|serial_in
op_assign
l_int|NULL
suffix:semicolon
id|serial_out
op_assign
l_int|NULL
suffix:semicolon
id|serial_intr
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI
r_if
c_cond
(paren
id|MACH_IS_ATARI
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser&quot;
)paren
)paren
(brace
multiline_comment|/* defaults to ser2 for a Falcon and ser1 otherwise */
id|strcpy
c_func
(paren
id|m68k_debug_device
comma
(paren
(paren
id|atari_mch_cookie
op_rshift
l_int|16
)paren
op_eq
id|ATARI_MCH_FALCON
)paren
ques
c_cond
l_string|&quot;ser2&quot;
suffix:colon
l_string|&quot;ser1&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser1&quot;
)paren
)paren
(brace
multiline_comment|/* ST-MFP Modem1 serial port init */
id|mfp.trn_stat
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
multiline_comment|/* disable TX */
id|mfp.rcv_stat
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
multiline_comment|/* disable RX */
id|mfp.usart_ctr
op_assign
l_int|0x88
suffix:semicolon
multiline_comment|/* clk 1:16, 8N1 */
id|mfp.tim_ct_cd
op_and_assign
l_int|0x70
suffix:semicolon
multiline_comment|/* stop timer D */
id|mfp.tim_dt_d
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 9600 bps */
id|mfp.tim_ct_cd
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* start timer D, 1:4 */
id|mfp.trn_stat
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* enable TX */
id|mfp.rcv_stat
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* enable RX */
multiline_comment|/* set function pointers */
id|serial_in
op_assign
id|atari_mfp_in
suffix:semicolon
id|serial_out
op_assign
id|atari_mfp_out
suffix:semicolon
id|serial_intr
op_assign
id|atari_mfp_intr
suffix:semicolon
multiline_comment|/* allocate interrupt */
id|request_irq
c_func
(paren
id|IRQ_MFP_RECFULL
comma
id|kgdb_intr
comma
id|IRQ_TYPE_FAST
comma
l_string|&quot;kgdb&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser2&quot;
)paren
)paren
(brace
r_extern
r_int
id|atari_SCC_reset_done
suffix:semicolon
multiline_comment|/* SCC Modem2 serial port init */
r_static
r_int
r_char
op_star
id|p
comma
id|scc_table
(braket
)braket
op_assign
(brace
l_int|9
comma
l_int|0xc0
comma
multiline_comment|/* Reset */
l_int|4
comma
l_int|0x44
comma
multiline_comment|/* x16, 1 stopbit, no parity */
l_int|3
comma
l_int|0xc0
comma
multiline_comment|/* receiver: 8 bpc */
l_int|5
comma
l_int|0xe2
comma
multiline_comment|/* transmitter: 8 bpc, assert dtr/rts */
l_int|2
comma
l_int|0x60
comma
multiline_comment|/* base int vector */
l_int|9
comma
l_int|0x09
comma
multiline_comment|/* int enab, with status low */
l_int|10
comma
l_int|0
comma
multiline_comment|/* NRZ */
l_int|11
comma
l_int|0x50
comma
multiline_comment|/* use baud rate generator */
l_int|12
comma
l_int|24
comma
l_int|13
comma
l_int|0
comma
multiline_comment|/* 9600 baud */
l_int|14
comma
l_int|2
comma
l_int|14
comma
l_int|3
comma
multiline_comment|/* use master clock for BRG, enable */
l_int|3
comma
l_int|0xc1
comma
multiline_comment|/* enable receiver */
l_int|5
comma
l_int|0xea
comma
multiline_comment|/* enable transmitter */
l_int|15
comma
l_int|0
comma
multiline_comment|/* no stat ints */
l_int|1
comma
l_int|0x10
comma
multiline_comment|/* Rx int every char, other ints off */
l_int|0
)brace
suffix:semicolon
(paren
r_void
)paren
id|scc.cha_b_ctrl
suffix:semicolon
multiline_comment|/* reset reg pointer */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|scc_table
suffix:semicolon
op_star
id|p
op_ne
l_int|0
suffix:semicolon
)paren
(brace
id|scc.cha_b_ctrl
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|scc.cha_b_ctrl
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
op_minus
l_int|2
)braket
op_eq
l_int|9
)paren
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
multiline_comment|/* extra delay after WR9 access */
)brace
multiline_comment|/* avoid that atari_SCC.c resets the whole SCC again */
id|atari_SCC_reset_done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set function pointers */
id|serial_in
op_assign
id|atari_scc_in
suffix:semicolon
id|serial_out
op_assign
id|atari_scc_out
suffix:semicolon
id|serial_intr
op_assign
id|atari_scc_intr
suffix:semicolon
multiline_comment|/* allocate rx and spcond ints */
id|request_irq
c_func
(paren
id|IRQ_SCCB_RX
comma
id|kgdb_intr
comma
id|IRQ_TYPE_FAST
comma
l_string|&quot;kgdb&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|IRQ_SCCB_SPCOND
comma
id|kgdb_intr
comma
id|IRQ_TYPE_FAST
comma
l_string|&quot;kgdb&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_AMIGA
r_if
c_cond
(paren
id|MACH_IS_AMIGA
)paren
(brace
multiline_comment|/* always use built-in serial port, no init required */
id|serial_in
op_assign
id|amiga_ser_in
suffix:semicolon
id|serial_out
op_assign
id|amiga_ser_out
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_MAC
r_if
c_cond
(paren
id|MACH_IS_MAC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser1&quot;
)paren
)paren
(brace
id|mac_init_scc_port
c_func
(paren
id|B9600
op_or
id|CS8
comma
l_int|0
)paren
suffix:semicolon
id|serial_in
op_assign
id|mac_scca_in
suffix:semicolon
id|serial_out
op_assign
id|mac_scca_out
suffix:semicolon
id|serial_intr
op_assign
id|mac_scca_intr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser2&quot;
)paren
)paren
(brace
id|mac_init_scc_port
c_func
(paren
id|B9600
op_or
id|CS8
comma
l_int|1
)paren
suffix:semicolon
id|serial_in
op_assign
id|mac_sccb_in
suffix:semicolon
id|serial_out
op_assign
id|mac_sccb_out
suffix:semicolon
id|serial_intr
op_assign
id|mac_sccb_intr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial_in
op_logical_or
op_logical_neg
id|serial_out
)paren
(brace
r_if
c_cond
(paren
op_star
id|m68k_debug_device
)paren
id|printk
c_func
(paren
l_string|&quot;kgdb_init failed: no valid serial device!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;kgdb not enabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|request_irq
c_func
(paren
l_int|4
comma
id|kgdb_intr
comma
id|IRQ_TYPE_FAST
comma
l_string|&quot;kgdb&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ATARI
r_if
c_cond
(paren
op_logical_neg
id|serial_in
op_logical_or
op_logical_neg
id|serial_out
)paren
(brace
r_if
c_cond
(paren
op_star
id|m68k_debug_device
)paren
id|printk
c_func
(paren
l_string|&quot;kgdb_init failed: no valid serial device!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;kgdb not enabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * In case GDB is started before us, ack any packets&n;&t; * (presumably &quot;$?#xx&quot;) sitting there.&n;&t; */
id|putDebugChar
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
id|kgdb_initialized
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;kgdb initialized.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert the MIPS hardware trap type code to a unix signal number.&n; */
DECL|function|computeSignal
r_static
r_int
id|computeSignal
c_func
(paren
r_int
id|tt
)paren
(brace
r_struct
id|hard_trap_info
op_star
id|ht
suffix:semicolon
r_for
c_loop
(paren
id|ht
op_assign
id|hard_trap_info
suffix:semicolon
id|ht-&gt;tt
op_logical_and
id|ht-&gt;signo
suffix:semicolon
id|ht
op_increment
)paren
r_if
c_cond
(paren
id|ht-&gt;tt
op_eq
id|tt
)paren
r_return
id|ht-&gt;signo
suffix:semicolon
r_return
id|SIGHUP
suffix:semicolon
multiline_comment|/* default for things we don&squot;t know about */
)brace
multiline_comment|/*&n; * While we find nice hex chars, build an int.&n; * Return number of chars processed.&n; */
DECL|function|hexToInt
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
(brace
r_int
id|numChars
op_assign
l_int|0
suffix:semicolon
r_int
id|hexValue
suffix:semicolon
op_star
id|intValue
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|ptr
)paren
(brace
id|hexValue
op_assign
id|hex
c_func
(paren
op_star
op_star
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hexValue
OL
l_int|0
)paren
r_break
suffix:semicolon
op_star
id|intValue
op_assign
(paren
op_star
id|intValue
op_lshift
l_int|4
)paren
op_or
id|hexValue
suffix:semicolon
id|numChars
op_increment
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
(paren
id|numChars
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This assembler stuff copies a struct frame (passed as argument) into struct&n; * gdb_regs registers and then calls handle_exception. After return from&n; * there, register and the like are restored from &squot;registers&squot;, the stack is&n; * set up and execution is continued where registers-&gt;pc tells us.&n; */
multiline_comment|/* offsets in struct frame */
DECL|macro|FRAMEOFF_D1
mdefine_line|#define FRAMEOFF_D1&t;&t;&quot;0&quot;&t;&t;/* d1..d5 */
DECL|macro|FRAMEOFF_A0
mdefine_line|#define FRAMEOFF_A0&t;&t;&quot;5*4&quot;&t;/* a0..a2 */
DECL|macro|FRAMEOFF_D0
mdefine_line|#define FRAMEOFF_D0&t;&t;&quot;8*4&quot;
DECL|macro|FRAMEOFF_SR
mdefine_line|#define FRAMEOFF_SR&t;&t;&quot;11*4&quot;
DECL|macro|FRAMEOFF_PC
mdefine_line|#define FRAMEOFF_PC&t;&t;&quot;11*4+2&quot;
DECL|macro|FRAMEOFF_VECTOR
mdefine_line|#define FRAMEOFF_VECTOR&t;&quot;12*4+2&quot;
multiline_comment|/* offsets in struct gdb_regs */
DECL|macro|GDBOFF_D0
mdefine_line|#define GDBOFF_D0&t;&t;&quot;0&quot;
DECL|macro|GDBOFF_D1
mdefine_line|#define GDBOFF_D1&t;&t;&quot;1*4&quot;
DECL|macro|GDBOFF_D6
mdefine_line|#define GDBOFF_D6&t;&t;&quot;6*4&quot;
DECL|macro|GDBOFF_A0
mdefine_line|#define GDBOFF_A0&t;&t;&quot;8*4&quot;
DECL|macro|GDBOFF_A3
mdefine_line|#define GDBOFF_A3&t;&t;&quot;11*4&quot;
DECL|macro|GDBOFF_A7
mdefine_line|#define GDBOFF_A7&t;&t;&quot;15*4&quot;
DECL|macro|GDBOFF_VECTOR
mdefine_line|#define GDBOFF_VECTOR&t;&quot;16*4&quot;
DECL|macro|GDBOFF_SR
mdefine_line|#define GDBOFF_SR&t;&t;&quot;16*4+2&quot;
DECL|macro|GDBOFF_PC
mdefine_line|#define GDBOFF_PC&t;&t;&quot;17*4&quot;
DECL|macro|GDBOFF_FP0
mdefine_line|#define GDBOFF_FP0&t;&t;&quot;18*4&quot;
DECL|macro|GDBOFF_FPCTL
mdefine_line|#define GDBOFF_FPCTL&t;&quot;42*4&quot;
id|__asm__
(paren
l_string|&quot;&t;.globl &quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|enter_kgdb
)paren
l_string|&quot;&bslash;n&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|enter_kgdb
)paren
l_string|&quot;:&bslash;n&quot;
multiline_comment|/* return if not initialized */
l_string|&quot;&t;&t;tstl&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|kgdb_initialized
)paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;&t;bne&t;&t;1f&bslash;n&quot;
l_string|&quot;&t;&t;rts&t;&t;&bslash;n&quot;
l_string|&quot;1:&t;orw&t;&t;#0x700,%sr&bslash;n&quot;
multiline_comment|/* disable interrupts while in stub */
l_string|&quot;&t;&t;tstl&t;%sp@+&bslash;n&quot;
multiline_comment|/* pop off return address */
l_string|&quot;&t;&t;movel&t;%sp@+,%a0&bslash;n&quot;
multiline_comment|/* get pointer to fp-&gt;ptregs (param) */
l_string|&quot;&t;&t;movel&t;#&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|kgdb_registers
)paren
l_string|&quot;,%a1&bslash;n&quot;
multiline_comment|/* destination */
multiline_comment|/* copy d0-d5/a0-a1 into gdb_regs */
l_string|&quot;&t;&t;movel&t;%a0@(&quot;
id|FRAMEOFF_D0
l_string|&quot;),%a1@(&quot;
id|GDBOFF_D0
l_string|&quot;)&bslash;n&quot;
l_string|&quot;&t;&t;moveml&t;%a0@(&quot;
id|FRAMEOFF_D1
l_string|&quot;),%d1-%d5&bslash;n&quot;
l_string|&quot;&t;&t;moveml&t;%d1-%d5,%a1@(&quot;
id|GDBOFF_D1
l_string|&quot;)&bslash;n&quot;
l_string|&quot;&t;&t;moveml&t;%a0@(&quot;
id|FRAMEOFF_A0
l_string|&quot;),%d0-%d2&bslash;n&quot;
l_string|&quot;&t;&t;moveml&t;%d0-%d2,%a1@(&quot;
id|GDBOFF_A0
l_string|&quot;)&bslash;n&quot;
multiline_comment|/* copy sr and pc */
l_string|&quot;&t;&t;movel&t;%a0@(&quot;
id|FRAMEOFF_PC
l_string|&quot;),%a1@(&quot;
id|GDBOFF_PC
l_string|&quot;)&bslash;n&quot;
l_string|&quot;&t;&t;movew&t;%a0@(&quot;
id|FRAMEOFF_SR
l_string|&quot;),%a1@(&quot;
id|GDBOFF_SR
l_string|&quot;)&bslash;n&quot;
multiline_comment|/* copy format/vector word */
l_string|&quot;&t;&t;movew&t;%a0@(&quot;
id|FRAMEOFF_VECTOR
l_string|&quot;),%a1@(&quot;
id|GDBOFF_VECTOR
l_string|&quot;)&bslash;n&quot;
multiline_comment|/* save FPU regs */
macro_line|#ifndef CONFIG_M68KFPU_EMU_ONLY
macro_line|#ifdef CONFIG_M68KFPU_EMU
l_string|&quot;&t;&t;tstl&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|m68k_fputype
)paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;&t;jeq&t;1f&bslash;n&quot;
macro_line|#endif
l_string|&quot;&t;&t;fmovemx&t;%fp0-%fp7,%a1@(&quot;
id|GDBOFF_FP0
l_string|&quot;)&bslash;n&quot;
l_string|&quot;&t;&t;fmoveml&t;%fpcr/%fpsr/%fpiar,%a1@(&quot;
id|GDBOFF_FPCTL
l_string|&quot;)&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
macro_line|#endif&t;/* CONFIG_M68KFPU_EMU_ONLY */
multiline_comment|/* set stack to CPU frame */
l_string|&quot;&t;&t;addl&t;#&quot;
id|FRAMEOFF_SR
l_string|&quot;,%a0&bslash;n&quot;
l_string|&quot;&t;&t;movel&t;%a0,%sp&bslash;n&quot;
l_string|&quot;&t;&t;movew&t;%sp@(6),%d0&bslash;n&quot;
l_string|&quot;&t;&t;andl&t;#0xf000,%d0&bslash;n&quot;
l_string|&quot;&t;&t;lsrl&t;#8,%d0&bslash;n&quot;
l_string|&quot;&t;&t;lsrl&t;#2,%d0&bslash;n&quot;
multiline_comment|/* get frame format &lt;&lt; 2 */
l_string|&quot;&t;&t;lea&t;&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|frame_sizes
)paren
l_string|&quot;,%a2&bslash;n&quot;
l_string|&quot;&t;&t;addl&t;%a2@(%d0),%sp&bslash;n&quot;
l_string|&quot;&t;&t;movel&t;%sp,%a1@(&quot;
id|GDBOFF_A7
l_string|&quot;)&bslash;n&quot;
multiline_comment|/* save a7 now */
multiline_comment|/* call handle_exception() now that the stack is set up */
l_string|&quot;Lcall_handle_excp:&quot;
l_string|&quot;&t;&t;jsr&t;&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|handle_exception
)paren
l_string|&quot;&bslash;n&quot;
multiline_comment|/* after return, first restore FPU registers */
l_string|&quot;&t;&t;movel&t;#&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|kgdb_registers
)paren
l_string|&quot;,%a0&bslash;n&quot;
multiline_comment|/* source */
macro_line|#ifndef CONFIG_M68KFPU_EMU_ONLY
macro_line|#ifdef CONFIG_M68KFPU_EMU
l_string|&quot;&t;&t;tstl&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|m68k_fputype
)paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;&t;jeq&t;1f&bslash;n&quot;
macro_line|#endif
l_string|&quot;&t;&t;fmovemx&t;%a0@(&quot;
id|GDBOFF_FP0
l_string|&quot;),%fp0-%fp7&bslash;n&quot;
l_string|&quot;&t;&t;fmoveml&t;%a0@(&quot;
id|GDBOFF_FPCTL
l_string|&quot;),%fpcr/%fpsr/%fpiar&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
macro_line|#endif&t;/* CONFIG_M68KFPU_EMU_ONLY */
multiline_comment|/* set new stack pointer */
l_string|&quot;&t;&t;movel&t;%a0@(&quot;
id|GDBOFF_A7
l_string|&quot;),%sp&bslash;n&quot;
l_string|&quot;&t;&t;clrw&t;%sp@-&bslash;n&quot;
multiline_comment|/* fake format $0 frame */
l_string|&quot;&t;&t;movel&t;%a0@(&quot;
id|GDBOFF_PC
l_string|&quot;),%sp@-&bslash;n&quot;
multiline_comment|/* new PC into frame */
l_string|&quot;&t;&t;movew&t;%a0@(&quot;
id|GDBOFF_SR
l_string|&quot;),%sp@-&bslash;n&quot;
multiline_comment|/* new SR into frame */
multiline_comment|/* restore general registers */
l_string|&quot;&t;&t;moveml&t;%a0@(&quot;
id|GDBOFF_D0
l_string|&quot;),%d0-%d7/%a0-%a6&bslash;n&quot;
multiline_comment|/* and jump to new PC */
l_string|&quot;&t;&t;rte&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * This is the entry point for the serial interrupt handler. It calls the&n; * machine specific function pointer &squot;serial_intr&squot; to get the char that&n; * interrupted. If that was C-c, the stub is entered as above, but based on&n; * just a struct intframe, not a struct frame.&n; */
id|__asm__
(paren
id|SYMBOL_NAME_STR
c_func
(paren
id|kgdb_intr
)paren
l_string|&quot;:&bslash;n&quot;
multiline_comment|/* return if not initialized */
l_string|&quot;&t;&t;tstl&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|kgdb_initialized
)paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;&t;bne&t;&t;1f&bslash;n&quot;
l_string|&quot;2:&t;rts&t;&t;&bslash;n&quot;
l_string|&quot;1:&t;movel&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|serial_intr
)paren
l_string|&quot;,%a0&bslash;n&quot;
l_string|&quot;&t;&t;jsr&t;&t;(%a0)&bslash;n&quot;
multiline_comment|/* get char from serial */
l_string|&quot;&t;&t;cmpb&t;#3,%d0&bslash;n&quot;
multiline_comment|/* is it C-c ? */
l_string|&quot;&t;&t;bne&t;&t;2b&bslash;n&quot;
multiline_comment|/* no -&gt; just ignore  */
l_string|&quot;&t;&t;orw&t;&t;#0x700,%sr&bslash;n&quot;
multiline_comment|/* disable interrupts */
l_string|&quot;&t;&t;subql&t;#1,&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|local_irq_count
)paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;&t;movel&t;%sp@(12),%sp&bslash;n&quot;
multiline_comment|/* revert stack to where &squot;inthandler&squot; set&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; * it up */
multiline_comment|/* restore regs from frame */
l_string|&quot;&t;&t;moveml&t;%sp@+,%d1-%d5/%a0-%a2&bslash;n&quot;
l_string|&quot;&t;&t;movel&t;%sp@+,%d0&bslash;n&quot;
l_string|&quot;&t;&t;addql&t;#8,%sp&bslash;n&quot;
multiline_comment|/* throw away orig_d0 and stkadj */
multiline_comment|/* save them into &squot;registers&squot; */
l_string|&quot;&t;&t;moveml&t;%d0-%d7/%a0-%a6,&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|kgdb_registers
)paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;&t;movel&t;#&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|kgdb_registers
)paren
l_string|&quot;,%a1&bslash;n&quot;
multiline_comment|/* destination */
multiline_comment|/* copy sr and pc */
l_string|&quot;&t;&t;movel&t;%sp@(2),%a1@(&quot;
id|GDBOFF_PC
l_string|&quot;)&bslash;n&quot;
l_string|&quot;&t;&t;movew&t;%sp@,%a1@(&quot;
id|GDBOFF_SR
l_string|&quot;)&bslash;n&quot;
multiline_comment|/* fake format 0 and vector 1 (translated to SIGINT) */
l_string|&quot;&t;&t;movew&t;#4,%a1@(&quot;
id|GDBOFF_VECTOR
l_string|&quot;)&bslash;n&quot;
multiline_comment|/* save FPU regs */
macro_line|#ifndef CONFIG_M68KFPU_EMU_ONLY
macro_line|#ifdef CONFIG_M68KFPU_EMU
l_string|&quot;&t;&t;tstl&t;&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|m68k_fputype
)paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;&t;jeq&t;1f&bslash;n&quot;
macro_line|#endif
l_string|&quot;&t;&t;fmovemx&t;%fp0-%fp7,%a1@(&quot;
id|GDBOFF_FP0
l_string|&quot;)&bslash;n&quot;
l_string|&quot;&t;&t;fmoveml&t;%fpcr/%fpsr/%fpiar,%a1@(&quot;
id|GDBOFF_FPCTL
l_string|&quot;)&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
macro_line|#endif&t;/* CONFIG_M68KFPU_EMU_ONLY */
multiline_comment|/* pop off the CPU stack frame */
l_string|&quot;&t;&t;addql&t;#8,%sp&bslash;n&quot;
l_string|&quot;&t;&t;movel&t;%sp,%a1@(&quot;
id|GDBOFF_A7
l_string|&quot;)&bslash;n&quot;
multiline_comment|/* save a7 now */
multiline_comment|/* proceed as in enter_kgdb */
l_string|&quot;&t;&t;jbra&t;Lcall_handle_excp&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * This function does all command processing for interfacing to gdb.  It&n; * returns 1 if you should skip the instruction at the trap address, 0&n; * otherwise.&n; */
DECL|function|handle_exception
r_static
id|asmlinkage
r_void
id|handle_exception
c_func
(paren
r_void
)paren
(brace
r_int
id|trap
suffix:semicolon
multiline_comment|/* Trap type */
r_int
id|sigval
suffix:semicolon
r_int
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
id|trap
op_assign
id|kgdb_registers.vector
op_rshift
l_int|2
suffix:semicolon
id|sigval
op_assign
id|computeSignal
c_func
(paren
id|trap
)paren
suffix:semicolon
multiline_comment|/* clear upper half of vector/sr word */
id|kgdb_registers.vector
op_assign
l_int|0
suffix:semicolon
id|kgdb_registers.format
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef DEBUG
r_if
c_cond
(paren
id|remote_debug
)paren
(brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;in handle_exception() trap=%d sigval=%d&bslash;n&quot;
comma
id|trap
comma
id|sigval
)paren
suffix:semicolon
id|show_gdbregs
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef DEBUG
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * reply to host that an exception has occurred&n;&t; */
id|ptr
op_assign
id|output_buffer
suffix:semicolon
multiline_comment|/*&n;&t; * Send trap type (converted to signal)&n;&t; */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Send Error PC&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDBREG_PC
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDBREG_PC
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers.pc
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send frame pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDBREG_A6
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDBREG_A6
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers.regs
(braket
id|GDBREG_A6
)braket
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send stack pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDBREG_SP
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|GDBREG_SP
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers.regs
(braket
id|GDBREG_SP
)braket
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0
suffix:semicolon
id|putpacket
c_func
(paren
id|output_buffer
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* send it off... */
multiline_comment|/*&n;&t; * Wait for input from remote GDB&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|getpacket
c_func
(paren
id|input_buffer
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|input_buffer
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;?&squot;
suffix:colon
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|output_buffer
(braket
l_int|1
)braket
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|2
)braket
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* toggle debug flag */
id|remote_debug
op_assign
op_logical_neg
id|remote_debug
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Return the value of the CPU registers&n;&t;&t;&t; */
r_case
l_char|&squot;g&squot;
suffix:colon
id|ptr
op_assign
id|output_buffer
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers
comma
id|ptr
comma
id|NUMREGSBYTES
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * set the value of the CPU registers - return OK&n;&t;&t;&t; */
r_case
l_char|&squot;G&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
id|ptr
op_assign
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers
comma
id|NUMREGSBYTES
comma
l_int|0
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Pn...=r...    Write register n&n;&t;&t;&t; */
r_case
l_char|&squot;P&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;=&squot;
)paren
(brace
r_if
c_cond
(paren
id|addr
op_ge
l_int|0
op_logical_and
id|addr
op_le
id|GDBREG_PC
)paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers.regs
(braket
id|addr
)braket
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
op_ge
id|GDBREG_FP0
op_logical_and
id|addr
op_le
id|GDBREG_FP7
)paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers.fpregs
(braket
id|addr
op_minus
id|GDBREG_FP0
)braket
comma
l_int|12
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
op_ge
id|GDBREG_FPCR
op_logical_and
id|addr
op_le
id|GDBREG_FPIAR
)paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|kgdb_registers.fpcntl
(braket
id|addr
op_minus
id|GDBREG_FPCR
)braket
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * mAA..AA,LLLL  Read LLLL bytes at address AA..AA&n;&t;&t;&t; */
r_case
l_char|&squot;m&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
r_if
c_cond
(paren
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
id|addr
comma
id|output_buffer
comma
id|length
comma
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|strcpy
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK&n;&t;&t;&t; */
r_case
l_char|&squot;M&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_if
c_cond
(paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|length
comma
l_int|1
)paren
)paren
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E02&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * cAA..AA    Continue at address AA..AA(optional)&n;&t;&t;&t; * sAA..AA    Step one instruction from AA..AA(optional)&n;&t;&t;&t; */
r_case
l_char|&squot;c&squot;
suffix:colon
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/* try to read optional parameter, pc unchanged if no parm */
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
)paren
id|kgdb_registers.pc
op_assign
id|addr
suffix:semicolon
id|kgdb_registers.sr
op_and_assign
l_int|0x7fff
suffix:semicolon
multiline_comment|/* clear Trace bit */
r_if
c_cond
(paren
id|input_buffer
(braket
l_int|0
)braket
op_eq
l_char|&squot;s&squot;
)paren
id|kgdb_registers.sr
op_or_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* set it if step command */
r_if
c_cond
(paren
id|remote_debug
)paren
id|printk
c_func
(paren
l_string|&quot;cont; new PC=0x%08lx SR=0x%04x&bslash;n&quot;
comma
id|kgdb_registers.pc
comma
id|kgdb_registers.sr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to flush the instruction cache here, as we may&n;&t;&t;&t; * have deposited a breakpoint, and the icache probably&n;&t;&t;&t; * has no way of knowing that a data ref to some location&n;&t;&t;&t; * may have changed something that is in the instruction&n;&t;&t;&t; * cache.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|m68k_is040or060
)paren
id|__asm__
id|__volatile__
(paren
l_string|&quot;.word 0xf4f8&bslash;n&bslash;t&quot;
multiline_comment|/* CPUSHA I/D */
l_string|&quot;.word 0xf498&quot;
multiline_comment|/* CINVA  I */
)paren
suffix:semicolon
r_else
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw  #0x0008,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * kill the program means reset the machine&n;&t;&t;&t; */
r_case
l_char|&squot;k&squot;
suffix:colon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
id|mach_reset
)paren
(brace
multiline_comment|/* reply OK before actual reset */
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
id|putpacket
c_func
(paren
id|output_buffer
comma
l_int|0
)paren
suffix:semicolon
id|mach_reset
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set baud rate (bBB)&n;&t;&t;&t; * FIXME: Needs to be written (in gdb, too...)&n;&t;&t;&t; */
r_case
l_char|&squot;b&squot;
suffix:colon
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
multiline_comment|/*&n;&t;&t; * reply to the request&n;&t;&t; */
id|putpacket
c_func
(paren
id|output_buffer
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Print registers (on target console)&n; * Used only to debug the stub...&n; */
DECL|function|show_gdbregs
r_static
r_void
id|show_gdbregs
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;d0: %08lx d1: %08lx d2: %08lx d3: %08lx&bslash;n&quot;
comma
id|kgdb_registers.regs
(braket
l_int|0
)braket
comma
id|kgdb_registers.regs
(braket
l_int|1
)braket
comma
id|kgdb_registers.regs
(braket
l_int|2
)braket
comma
id|kgdb_registers.regs
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;d4: %08lx d5: %08lx d6: %08lx d7: %08lx&bslash;n&quot;
comma
id|kgdb_registers.regs
(braket
l_int|4
)braket
comma
id|kgdb_registers.regs
(braket
l_int|5
)braket
comma
id|kgdb_registers.regs
(braket
l_int|6
)braket
comma
id|kgdb_registers.regs
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;a0: %08lx a1: %08lx a2: %08lx a3: %08lx&bslash;n&quot;
comma
id|kgdb_registers.regs
(braket
l_int|8
)braket
comma
id|kgdb_registers.regs
(braket
l_int|9
)braket
comma
id|kgdb_registers.regs
(braket
l_int|10
)braket
comma
id|kgdb_registers.regs
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;a4: %08lx a5: %08lx a6: %08lx a7: %08lx&bslash;n&quot;
comma
id|kgdb_registers.regs
(braket
l_int|12
)braket
comma
id|kgdb_registers.regs
(braket
l_int|13
)braket
comma
id|kgdb_registers.regs
(braket
l_int|14
)braket
comma
id|kgdb_registers.regs
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pc: %08lx sr: %04x&bslash;n&quot;
comma
id|kgdb_registers.pc
comma
id|kgdb_registers.sr
)paren
suffix:semicolon
)brace
multiline_comment|/* -------------------- Atari serial I/O -------------------- */
macro_line|#ifdef CONFIG_ATARI
DECL|function|atari_mfp_out
r_static
r_int
id|atari_mfp_out
c_func
(paren
r_int
r_char
id|c
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|mfp.trn_stat
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* wait for tx buf empty */
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|mfp.usart_dta
op_assign
id|c
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|atari_mfp_in
r_static
r_int
r_char
id|atari_mfp_in
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|mfp.rcv_stat
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* wait for rx buf filled */
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|mfp.usart_dta
suffix:semicolon
)brace
DECL|function|atari_mfp_intr
r_static
r_int
r_char
id|atari_mfp_intr
c_func
(paren
r_void
)paren
(brace
r_return
id|mfp.usart_dta
suffix:semicolon
)brace
DECL|function|atari_scc_out
r_static
r_int
id|atari_scc_out
c_func
(paren
r_int
r_char
id|c
)paren
(brace
r_do
(brace
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|scc.cha_b_ctrl
op_amp
l_int|0x04
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for tx buf empty */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|scc.cha_b_data
op_assign
id|c
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|atari_scc_in
r_static
r_int
r_char
id|atari_scc_in
c_func
(paren
r_void
)paren
(brace
r_do
(brace
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|scc.cha_b_ctrl
op_amp
l_int|0x01
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for rx buf filled */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|scc.cha_b_data
suffix:semicolon
)brace
DECL|function|atari_scc_intr
r_static
r_int
r_char
id|atari_scc_intr
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|c
comma
id|stat
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|scc.cha_b_ctrl
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* RR1 */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|stat
op_assign
id|scc.cha_b_ctrl
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
id|scc.cha_b_data
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x30
)paren
(brace
id|scc.cha_b_ctrl
op_assign
l_int|0x30
suffix:semicolon
multiline_comment|/* error reset for overrun and parity */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
id|scc.cha_b_ctrl
op_assign
l_int|0x38
suffix:semicolon
multiline_comment|/* reset highest IUS */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* -------------------- Macintosh serial I/O -------------------- */
macro_line|#ifdef CONFIG_MAC
DECL|struct|SCC
r_struct
id|SCC
(brace
DECL|member|cha_b_ctrl
id|u_char
id|cha_b_ctrl
suffix:semicolon
DECL|member|char_dummy1
id|u_char
id|char_dummy1
suffix:semicolon
DECL|member|cha_a_ctrl
id|u_char
id|cha_a_ctrl
suffix:semicolon
DECL|member|char_dummy2
id|u_char
id|char_dummy2
suffix:semicolon
DECL|member|cha_b_data
id|u_char
id|cha_b_data
suffix:semicolon
DECL|member|char_dummy3
id|u_char
id|char_dummy3
suffix:semicolon
DECL|member|cha_a_data
id|u_char
id|cha_a_data
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|scc
mdefine_line|#define scc (*((volatile struct SCC*)mac_bi_data.sccbase))
DECL|macro|uSEC
mdefine_line|#define uSEC 1
DECL|macro|LONG_DELAY
mdefine_line|#define LONG_DELAY()&t;&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&bslash;&n;&t;int i;&t;&t;&t;&t;&t;&bslash;&n;&t;for( i = 60*uSEC; i &gt; 0; --i )&t;&t;&bslash;&n;&t;    barrier();&t;&t;&t;&t;&bslash;&n;    } while(0)
DECL|function|mac_sccb_out
r_static
r_int
r_char
id|mac_sccb_out
(paren
r_int
r_char
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_do
(brace
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|scc.cha_b_ctrl
op_amp
l_int|0x04
)paren
)paren
suffix:semicolon
multiline_comment|/* wait for tx buf empty */
r_for
c_loop
(paren
id|i
op_assign
id|uSEC
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|scc.cha_b_data
op_assign
id|c
suffix:semicolon
)brace
DECL|function|mac_scca_out
r_static
r_int
r_char
id|mac_scca_out
(paren
r_int
r_char
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_do
(brace
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|scc.cha_a_ctrl
op_amp
l_int|0x04
)paren
)paren
suffix:semicolon
multiline_comment|/* wait for tx buf empty */
r_for
c_loop
(paren
id|i
op_assign
id|uSEC
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|scc.cha_a_data
op_assign
id|c
suffix:semicolon
)brace
DECL|function|mac_sccb_in
r_static
r_int
r_char
id|mac_sccb_in
c_func
(paren
r_void
)paren
(brace
r_do
(brace
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|scc.cha_b_ctrl
op_amp
l_int|0x01
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for rx buf filled */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|scc.cha_b_data
suffix:semicolon
)brace
DECL|function|mac_scca_in
r_static
r_int
r_char
id|mac_scca_in
c_func
(paren
r_void
)paren
(brace
r_do
(brace
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|scc.cha_a_ctrl
op_amp
l_int|0x01
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for rx buf filled */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|scc.cha_a_data
suffix:semicolon
)brace
DECL|function|mac_sccb_intr
r_static
r_int
r_char
id|mac_sccb_intr
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|c
comma
id|stat
suffix:semicolon
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
id|scc.cha_b_ctrl
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* RR1 */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
id|stat
op_assign
id|scc.cha_b_ctrl
suffix:semicolon
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
id|scc.cha_b_data
suffix:semicolon
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x30
)paren
(brace
id|scc.cha_b_ctrl
op_assign
l_int|0x30
suffix:semicolon
multiline_comment|/* error reset for overrun and parity */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
)brace
id|scc.cha_b_ctrl
op_assign
l_int|0x38
suffix:semicolon
multiline_comment|/* reset highest IUS */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|function|mac_scca_intr
r_static
r_int
r_char
id|mac_scca_intr
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|c
comma
id|stat
suffix:semicolon
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
id|scc.cha_a_ctrl
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* RR1 */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
id|stat
op_assign
id|scc.cha_a_ctrl
suffix:semicolon
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
id|scc.cha_a_data
suffix:semicolon
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
l_int|0x30
)paren
(brace
id|scc.cha_a_ctrl
op_assign
l_int|0x30
suffix:semicolon
multiline_comment|/* error reset for overrun and parity */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
)brace
id|scc.cha_a_ctrl
op_assign
l_int|0x38
suffix:semicolon
multiline_comment|/* reset highest IUS */
id|LONG_DELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
macro_line|#endif
eof
