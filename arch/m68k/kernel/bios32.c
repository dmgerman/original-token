multiline_comment|/*&n; * bios32.c - PCI BIOS functions for Alpha systems not using BIOS&n; *&t;      emulation code.&n; *&n; * Written by Wout Klaren.&n; *&n; * Based on the DEC Alpha bios32.c by Dave Rusling and David Mosberger.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#if 0
macro_line|# define DBG_DEVS(args)&t;&t;printk args
macro_line|#else
DECL|macro|DBG_DEVS
macro_line|# define DBG_DEVS(args)
macro_line|#endif
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n; * PCI support for Linux/m68k. Currently only the Hades is supported.&n; *&n; * Notes:&n; *&n; * 1. The PCI memory area starts at address 0x80000000 and the&n; *    I/O area starts at 0xB0000000. Therefore these offsets&n; *    are added to the base addresses when they are read and&n; *    substracted when they are written.&n; *&n; * 2. The support for PCI bridges in the DEC Alpha version has&n; *    been removed in this version.&n; */
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|KB
mdefine_line|#define KB&t;&t;1024
DECL|macro|MB
mdefine_line|#define MB&t;&t;(1024*KB)
DECL|macro|GB
mdefine_line|#define GB&t;&t;(1024*MB)
DECL|macro|MAJOR_REV
mdefine_line|#define MAJOR_REV&t;0
DECL|macro|MINOR_REV
mdefine_line|#define MINOR_REV&t;1
multiline_comment|/*&n; * Base addresses of the PCI memory and I/O areas on the Hades.&n; */
DECL|variable|pci_mem_base
r_static
r_int
r_int
id|pci_mem_base
op_assign
l_int|0
suffix:semicolon
DECL|variable|pci_io_base
r_static
r_int
r_int
id|pci_io_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Align VAL to ALIGN, which must be a power of two.&n; */
DECL|macro|ALIGN
mdefine_line|#define ALIGN(val,align)&t;(((val) + ((align) - 1)) &amp; ~((align) - 1))
multiline_comment|/*&n; * Calculate the address of the PCI configuration area of the given&n; * device.&n; *&n; * BUG: boards with multiple functions are probably not correctly&n; * supported.&n; */
DECL|function|mk_conf_addr
r_static
r_int
id|mk_conf_addr
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
op_star
id|pci_addr
)paren
(brace
r_static
r_const
r_int
r_int
id|pci_conf_base
(braket
)braket
op_assign
(brace
l_int|0xA0080000
comma
l_int|0xA0040000
comma
l_int|0xA0020000
comma
l_int|0xA0010000
)brace
suffix:semicolon
r_int
id|device
op_assign
id|device_fn
op_rshift
l_int|3
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x, pci_addr=0x%p)&bslash;n&quot;
comma
id|bus
comma
id|device_fn
comma
id|where
comma
id|pci_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
OG
l_int|3
)paren
(brace
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;mk_conf_addr: device (%d) &gt; 3, returning -1&bslash;n&quot;
comma
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|pci_addr
op_assign
id|pci_conf_base
(braket
id|device
)braket
op_or
(paren
id|where
)paren
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;mk_conf_addr: returning pci_addr 0x%lx&bslash;n&quot;
comma
op_star
id|pci_addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pcibios_read_config_byte
r_int
id|pcibios_read_config_byte
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_char
op_star
id|value
)paren
(brace
r_int
r_int
id|pci_addr
suffix:semicolon
op_star
id|value
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|device_fn
comma
id|where
comma
op_amp
id|pci_addr
)paren
OL
l_int|0
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
op_star
id|value
op_assign
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|pci_addr
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcibios_read_config_word
r_int
id|pcibios_read_config_word
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|pci_addr
suffix:semicolon
op_star
id|value
op_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|where
op_amp
l_int|0x1
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|device_fn
comma
id|where
comma
op_amp
id|pci_addr
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
op_star
id|value
op_assign
id|le16_to_cpu
c_func
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|pci_addr
)paren
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcibios_read_config_dword
r_int
id|pcibios_read_config_dword
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|pci_addr
suffix:semicolon
op_star
id|value
op_assign
l_int|0xffffffff
suffix:semicolon
r_if
c_cond
(paren
id|where
op_amp
l_int|0x3
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|device_fn
comma
id|where
comma
op_amp
id|pci_addr
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
op_star
id|value
op_assign
id|le32_to_cpu
c_func
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|pci_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|where
op_ge
id|PCI_BASE_ADDRESS_0
)paren
op_logical_and
(paren
id|where
op_le
id|PCI_BASE_ADDRESS_5
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|value
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_eq
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
op_star
id|value
op_add_assign
id|pci_io_base
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_star
id|value
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Base address is 0. Test if this base&n;&t;&t;&t;&t; * address register is used.&n;&t;&t;&t;&t; */
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|pci_addr
)paren
op_assign
l_int|0xffffffff
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|pci_addr
)paren
op_ne
l_int|0
)paren
op_star
id|value
op_add_assign
id|pci_mem_base
suffix:semicolon
)brace
r_else
op_star
id|value
op_add_assign
id|pci_mem_base
suffix:semicolon
)brace
)brace
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcibios_write_config_byte
r_int
id|pcibios_write_config_byte
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_char
id|value
)paren
(brace
r_int
r_int
id|pci_addr
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|device_fn
comma
id|where
comma
op_amp
id|pci_addr
)paren
OL
l_int|0
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|pci_addr
)paren
op_assign
id|value
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcibios_write_config_word
r_int
id|pcibios_write_config_word
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_int
id|pci_addr
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|device_fn
comma
id|where
comma
op_amp
id|pci_addr
)paren
OL
l_int|0
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|pci_addr
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcibios_write_config_dword
r_int
id|pcibios_write_config_dword
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_int
id|pci_addr
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|device_fn
comma
id|where
comma
op_amp
id|pci_addr
)paren
OL
l_int|0
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
(paren
id|where
op_ge
id|PCI_BASE_ADDRESS_0
)paren
op_logical_and
(paren
id|where
op_le
id|PCI_BASE_ADDRESS_5
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|value
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_eq
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
id|value
op_sub_assign
id|pci_io_base
suffix:semicolon
r_else
id|value
op_sub_assign
id|pci_mem_base
suffix:semicolon
)brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|pci_addr
)paren
op_assign
id|cpu_to_le32
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
multiline_comment|/*&n; * Macro to enable programming of the PCI devices. On the Hades this&n; * define should be true, because the Hades has no PCI BIOS.&n; */
DECL|macro|PCI_MODIFY
mdefine_line|#define PCI_MODIFY&t;&t;1
macro_line|#if PCI_MODIFY
multiline_comment|/*&n; * Leave some room for a VGA card. We assume that the VGA card is&n; * always in the first 32M of PCI memory. For the time being we do&n; * not program the VGA card, because to make this work we also&n; * need to change the frame buffer device.&n; */
DECL|macro|FIRST_IO_ADDR
mdefine_line|#define FIRST_IO_ADDR&t;0x10000
DECL|macro|FIRST_MEM_ADDR
mdefine_line|#define FIRST_MEM_ADDR&t;0x02000000
DECL|variable|io_base
r_static
r_int
r_int
id|io_base
op_assign
id|FIRST_IO_ADDR
suffix:semicolon
multiline_comment|/* Skip first 64K. */
DECL|variable|mem_base
r_static
r_int
r_int
id|mem_base
op_assign
id|FIRST_MEM_ADDR
suffix:semicolon
multiline_comment|/* Skip first 32M. */
multiline_comment|/*&n; * Disable PCI device DEV so that it does not respond to I/O or memory&n; * accesses.&n; */
DECL|function|disable_dev
r_static
r_void
id|__init
id|disable_dev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_DISPLAY_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_DISPLAY_XGA
)paren
r_return
suffix:semicolon
id|bus
op_assign
id|dev-&gt;bus
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|cmd
op_and_assign
(paren
op_complement
id|PCI_COMMAND_IO
op_amp
op_complement
id|PCI_COMMAND_MEMORY
op_amp
op_complement
id|PCI_COMMAND_MASTER
)paren
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Layout memory and I/O for a device:&n; */
DECL|macro|MAX
mdefine_line|#define MAX(val1, val2) ( ((val1) &gt; (val2)) ? val1 : val2)
DECL|function|layout_dev
r_static
r_void
id|__init
id|layout_dev
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
r_int
id|pci_mem_base
comma
r_int
r_int
id|pci_io_base
)paren
(brace
r_struct
id|pci_bus
op_star
id|bus
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|base
comma
id|mask
comma
id|size
comma
id|reg
suffix:semicolon
r_int
r_int
id|alignto
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Skip video cards for the time being.&n;&t; */
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_DISPLAY_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_DISPLAY_XGA
)paren
r_return
suffix:semicolon
id|bus
op_assign
id|dev-&gt;bus
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
id|PCI_BASE_ADDRESS_0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|reg
op_le
id|PCI_BASE_ADDRESS_5
suffix:semicolon
id|reg
op_add_assign
l_int|4
comma
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Figure out how much space and of what type this&n;&t;&t; * device wants.&n;&t;&t; */
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
op_amp
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
multiline_comment|/* this base-address register is unused */
id|dev-&gt;base_address
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We&squot;ve read the base address register back after&n;&t;&t; * writing all ones and so now we must decode it.&n;&t;&t; */
r_if
c_cond
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * I/O space base address register.&n;&t;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|mask
op_assign
(paren
op_complement
id|base
op_lshift
l_int|1
)paren
op_or
l_int|0x1
suffix:semicolon
id|size
op_assign
(paren
id|mask
op_amp
id|base
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* align to multiple of size of minimum base */
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x400
comma
id|size
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
id|alignto
)paren
suffix:semicolon
id|io_base
op_assign
id|base
op_plus
id|size
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
id|base
op_or
l_int|0x1
)paren
suffix:semicolon
id|dev-&gt;base_address
(braket
id|i
)braket
op_assign
(paren
id|pci_io_base
op_plus
id|base
)paren
op_or
l_int|1
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: IO address: %lX&bslash;n&quot;
comma
id|base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|type
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Memory space base address register.&n;&t;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
id|type
op_assign
id|base
op_amp
id|PCI_BASE_ADDRESS_MEM_TYPE_MASK
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|mask
op_assign
(paren
op_complement
id|base
op_lshift
l_int|1
)paren
op_or
l_int|0x1
suffix:semicolon
id|size
op_assign
(paren
id|mask
op_amp
id|base
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_32
suffix:colon
r_break
suffix:semicolon
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_64
suffix:colon
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: &quot;
l_string|&quot;ignoring 64-bit device in &quot;
l_string|&quot;slot %d, function %d: &bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
suffix:semicolon
id|reg
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip extra 4 bytes */
r_continue
suffix:semicolon
r_case
id|PCI_BASE_ADDRESS_MEM_TYPE_1M
suffix:colon
id|printk
c_func
(paren
l_string|&quot;bios32 WARNING: slot %d, function %d &quot;
l_string|&quot;requests memory below 1MB---don&squot;t &quot;
l_string|&quot;know how to do that.&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|dev-&gt;devfn
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Align to multiple of size of minimum base&n;&t;&t;&t; */
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x1000
comma
id|size
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
id|alignto
)paren
suffix:semicolon
id|mem_base
op_assign
id|base
op_plus
id|size
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|reg
comma
id|base
)paren
suffix:semicolon
id|dev-&gt;base_address
(braket
id|i
)braket
op_assign
id|pci_mem_base
op_plus
id|base
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Enable device:&n;&t; */
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_NOT_DEFINED_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_DISPLAY_VGA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
op_eq
id|PCI_CLASS_DISPLAY_XGA
)paren
(brace
multiline_comment|/*&n;&t;&t; * All of these (may) have I/O scattered all around&n;&t;&t; * and may not use i/o-base address registers at all.&n;&t;&t; * So we just have to always enable I/O to these&n;&t;&t; * devices.&n;&t;&t; */
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
)brace
id|pcibios_write_config_word
c_func
(paren
id|bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|cmd
op_or
id|PCI_COMMAND_MASTER
)paren
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_dev: bus %d  slot 0x%x  VID 0x%x  DID 0x%x  class 0x%x&bslash;n&quot;
comma
id|bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|dev-&gt;vendor
comma
id|dev-&gt;device
comma
id|dev
op_member_access_from_pointer
r_class
)paren
)paren
suffix:semicolon
)brace
DECL|function|layout_bus
r_static
r_void
id|__init
id|layout_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|pci_mem_base
comma
r_int
r_int
id|pci_io_base
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus-&gt;devices
op_logical_and
op_logical_neg
id|bus-&gt;children
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Align the current bases on appropriate boundaries (4K for&n;&t; * IO and 1MB for memory).&n;&t; */
id|io_base
op_assign
id|ALIGN
c_func
(paren
id|io_base
comma
l_int|4
op_star
id|KB
)paren
suffix:semicolon
id|mem_base
op_assign
id|ALIGN
c_func
(paren
id|mem_base
comma
l_int|1
op_star
id|MB
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * PCI devices might have been setup by a PCI BIOS emulation&n;&t; * running under TOS. In these cases there is a&n;&t; * window during which two devices may have an overlapping&n;&t; * address range.  To avoid this causing trouble, we first&n;&t; * turn off the I/O and memory address decoders for all PCI&n;&t; * devices.  They&squot;ll be re-enabled only once all address&n;&t; * decoders are programmed consistently.&n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|bus-&gt;devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
id|disable_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate space to each device:&n;&t; */
id|DBG_DEVS
c_func
(paren
(paren
l_string|&quot;layout_bus: starting bus %d devices&bslash;n&quot;
comma
id|bus-&gt;number
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|bus-&gt;devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
id|layout_dev
c_func
(paren
id|dev
comma
id|pci_mem_base
comma
id|pci_io_base
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* !PCI_MODIFY */
DECL|function|pcibios_init
r_void
id|__init
id|pcibios_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Linux/m68k PCI BIOS32 revision %x.%02x&bslash;n&quot;
comma
id|MAJOR_REV
comma
id|MINOR_REV
)paren
suffix:semicolon
macro_line|#if !PCI_MODIFY
id|printk
c_func
(paren
l_string|&quot;...NOT modifying existing PCI configuration&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|pci_mem_base
op_assign
l_int|0x80000000
suffix:semicolon
id|pci_io_base
op_assign
l_int|0xB0000000
suffix:semicolon
)brace
multiline_comment|/*&n; * static inline void hades_fixup(void)&n; *&n; * Assign IRQ numbers as used by Linux to the interrupt pins&n; * of the PCI cards.&n; */
DECL|function|hades_fixup
r_static
r_inline
r_void
id|__init
id|hades_fixup
c_func
(paren
r_void
)paren
(brace
r_char
id|irq_tab
(braket
l_int|4
)braket
op_assign
(brace
id|IRQ_TT_MFP_IO0
comma
multiline_comment|/* Slot 0. */
id|IRQ_TT_MFP_IO1
comma
multiline_comment|/* Slot 1. */
id|IRQ_TT_MFP_SCC
comma
multiline_comment|/* Slot 2. */
id|IRQ_TT_MFP_SCSIDMA
multiline_comment|/* Slot 3. */
)brace
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_int
r_char
id|slot
suffix:semicolon
multiline_comment|/*&n;&t; * Go through all devices, fixing up irqs as we see fit:&n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|pci_devices
suffix:semicolon
id|dev
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
(brace
id|slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
suffix:semicolon
multiline_comment|/* Determine slot number. */
id|dev-&gt;irq
op_assign
id|irq_tab
(braket
id|slot
)braket
suffix:semicolon
macro_line|#if PCI_MODIFY
id|pcibios_write_config_byte
c_func
(paren
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|PCI_INTERRUPT_LINE
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
DECL|function|pcibios_fixup
r_void
id|__init
id|pcibios_fixup
c_func
(paren
r_void
)paren
(brace
macro_line|#if PCI_MODIFY
r_int
r_int
id|orig_mem_base
comma
id|orig_io_base
suffix:semicolon
id|orig_mem_base
op_assign
id|pci_mem_base
suffix:semicolon
id|orig_io_base
op_assign
id|pci_io_base
suffix:semicolon
id|pci_mem_base
op_assign
l_int|0
suffix:semicolon
id|pci_io_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the tree, allocating PCI memory and I/O space.&n;&t; */
id|layout_bus
c_func
(paren
id|pci_bus_b
c_func
(paren
id|pci_root.next
)paren
comma
id|orig_mem_base
comma
id|orig_io_base
)paren
suffix:semicolon
id|pci_mem_base
op_assign
id|orig_mem_base
suffix:semicolon
id|pci_io_base
op_assign
id|orig_io_base
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Now is the time to do all those dirty little deeds...&n;&t; */
id|hades_fixup
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|pcibios_fixup_bus
r_void
id|__init
id|pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
)brace
DECL|function|pcibios_setup
r_char
op_star
id|__init
id|pcibios_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|str
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PCI */
eof
