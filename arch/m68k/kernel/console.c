multiline_comment|/*&n; *  linux/drivers/char/console.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; *&t;console.c&n; *&n; * This module exports the console io functions:&n; *&n; *     &squot;void do_keyboard_interrupt(void)&squot;&n; *&n; *     &squot;int vc_allocate(unsigned int console)&squot;&n; *     &squot;int vc_cons_allocated(unsigned int console)&squot;&n; *     &squot;int vc_resize(unsigned long lines, unsigned long cols)&squot;&n; *     &squot;int vc_resize_con(unsigned long lines, unsigned long cols,&n; *&t;&t;&t;  unsigned int currcons)&squot;&n; *     &squot;void vc_disallocate(unsigned int currcons)&squot;&n; *&n; *     &squot;unsigned long con_init(unsigned long)&squot;&n; *     &squot;int con_open(struct tty_struct *tty, struct file * filp)&squot;&n; *     &squot;void con_write(struct tty_struct * tty)&squot;&n; *     &squot;void console_print(const char * b)&squot;&n; *     &squot;void update_screen(int new_console)&squot;&n; *&n; *     &squot;void do_blank_screen(int)&squot;&n; *     &squot;void do_unblank_screen(void)&squot;&n; *     &squot;void poke_blanked_console(void)&squot;&n; *&n; *     &squot;unsigned short *screen_pos(int currcons, int w_offset, int viewed)&squot;&n; *     &squot;void complement_pos(int currcons, int offset)&squot;&n; *     &squot;void invert_screen(int currcons, int offset, int count, int shift)&squot;&n; *&n; *     &squot;void scrollback(int lines)&squot;&n; *     &squot;void scrollfront(int lines)&squot;&n; *&n; *     &squot;int con_get_font(char *)&squot; &n; *     &squot;int con_set_font(char *)&squot;&n; * &n; *     &squot;void mouse_report(struct tty_struct * tty, int butt, int mrx, int mry)&squot;&n; *     &squot;int mouse_reporting(void)&squot;&n; *&n; *     &squot;unsigned long get_video_num_lines(unsigned int console)&squot;&n; *     &squot;unsigned long get_video_num_columns(unsigned int console)&squot;&n; *     &squot;unsigned long get_video_size_row(unsigned int console)&squot;&n; *&n; * Hopefully this will be a rather complete VT102 implementation.&n; *&n; * Beeping thanks to John T Kohl.&n; *&n; * Virtual Consoles, Screen Blanking, Screen Dumping, Color, Graphics&n; *   Chars, and VT100 enhancements by Peter MacDonald.&n; *&n; * Copy and paste function by Andrew Haylett,&n; *   some enhancements by Alessandro Rubini.&n; *&n; * User definable mapping table and font loading by Eugene G. Crosser,&n; * &lt;crosser@pccross.msk.su&gt;&n; *&n; * Code to check for different video-cards mostly by Galen Hunt,&n; * &lt;g-hunt@ee.utah.edu&gt;&n; *&n; * Rudimentary ISO 10646/Unicode/UTF-8 character set support by&n; * Markus Kuhn, &lt;mskuhn@immd4.informatik.uni-erlangen.de&gt;.&n; *&n; * Dynamic allocation of consoles, aeb@cwi.nl, May 1994&n; * Resizing of consoles, aeb, 940926&n; *&n; * Code for xterm like mouse click reporting by Peter Orbaek 20-Jul-94&n; * &lt;poe@daimi.aau.dk&gt;&n; *&n; * 680x0 LINUX support by Arno Griffioen (arno@usn.nl)&n; *&n; * 9-Apr-94:  Arno Griffioen: fixed scrolling and delete-char bug.&n; *            Scrolling code moved to amicon.c&n; *&n; * 18-Apr-94: David Carter [carter@cs.bris.ac.uk]. 680x0 LINUX modified &n; *            Integrated support for new low level driver `amicon_ocs.c&squot;&n; *&n; */
DECL|macro|BLANK
mdefine_line|#define BLANK 0x0020
DECL|macro|CAN_LOAD_EGA_FONTS
mdefine_line|#define CAN_LOAD_EGA_FONTS    /* undefine if the user must not do this */
multiline_comment|/* A bitmap for codes &lt;32. A bit of 1 indicates that the code&n; * corresponding to that bit number invokes some special action&n; * (such as cursor movement) and should not be displayed as a&n; * glyph unless the disp_ctrl mode is explicitly enabled.&n; */
DECL|macro|CTRL_ACTION
mdefine_line|#define CTRL_ACTION 0x0d00ff81
DECL|macro|CTRL_ALWAYS
mdefine_line|#define CTRL_ALWAYS 0x0800f501&t;/* Cannot be overridden by disp_ctrl */
multiline_comment|/*&n; * Here is the default bell parameters: 750HZ, 1/8th of a second&n; */
DECL|macro|DEFAULT_BELL_PITCH
mdefine_line|#define DEFAULT_BELL_PITCH&t;750
DECL|macro|DEFAULT_BELL_DURATION
mdefine_line|#define DEFAULT_BELL_DURATION&t;(HZ/8)
multiline_comment|/*&n; *  NOTE!!! We sometimes disable and enable interrupts for a short while&n; * (to put a word in video IO), but this will work even for keyboard&n; * interrupts. We know interrupts aren&squot;t enabled when getting a keyboard&n; * interrupt, as we use trap-gates. Hopefully all is well.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;../../../drivers/char/kbd_kern.h&quot;
macro_line|#include &quot;../../../drivers/char/vt_kern.h&quot;
macro_line|#include &quot;../../../drivers/char/consolemap.h&quot;
macro_line|#include &quot;../../../drivers/char/selection.h&quot;
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
DECL|variable|console_driver
r_struct
id|tty_driver
id|console_driver
suffix:semicolon
DECL|variable|console_refcount
r_static
r_int
id|console_refcount
suffix:semicolon
DECL|variable|console_table
r_static
r_struct
id|tty_struct
op_star
id|console_table
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|console_termios
r_static
r_struct
id|termios
op_star
id|console_termios
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|console_termios_locked
r_static
r_struct
id|termios
op_star
id|console_termios_locked
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
r_static
r_void
id|vc_init
c_func
(paren
r_int
r_int
id|console
comma
r_int
id|do_clear
)paren
suffix:semicolon
r_static
r_void
id|update_attr
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_static
r_void
id|gotoxy
c_func
(paren
r_int
id|currcons
comma
r_int
id|new_x
comma
r_int
id|new_y
)paren
suffix:semicolon
r_static
r_void
id|save_cur
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_static
r_void
id|blank_screen
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|unblank_screen
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|change_console
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_inline
r_void
id|set_cursor
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_static
r_void
id|reset_terminal
c_func
(paren
r_int
id|currcons
comma
r_int
id|do_clear
)paren
suffix:semicolon
r_extern
r_void
id|reset_vc
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|vt_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|register_console
c_func
(paren
r_void
(paren
op_star
id|proc
)paren
(paren
r_const
r_char
op_star
)paren
)paren
suffix:semicolon
r_extern
r_void
id|vesa_blank
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|vesa_unblank
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|poke_blanked_console
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|do_blank_screen
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|variable|video_num_lines
r_int
r_int
id|video_num_lines
suffix:semicolon
DECL|variable|video_num_columns
r_int
r_int
id|video_num_columns
suffix:semicolon
DECL|variable|video_size_row
r_int
r_int
id|video_size_row
suffix:semicolon
DECL|variable|printable
r_static
r_int
id|printable
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is console ready for printing? */
DECL|variable|video_font_height
r_int
r_int
id|video_font_height
suffix:semicolon
multiline_comment|/* Height of current screen font */
DECL|variable|video_scan_lines
r_int
r_int
id|video_scan_lines
suffix:semicolon
multiline_comment|/* Number of scan lines on screen */
DECL|variable|default_font_height
r_int
r_int
id|default_font_height
suffix:semicolon
multiline_comment|/* Height of default screen font */
DECL|variable|video_mode_512ch
r_int
id|video_mode_512ch
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 512-character mode */
DECL|variable|console_charmask
r_static
r_int
r_int
id|console_charmask
op_assign
l_int|0x0ff
suffix:semicolon
DECL|variable|vc_scrbuf
r_static
r_int
r_int
op_star
id|vc_scrbuf
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
multiline_comment|/* used by kbd_bh - set by keyboard_interrupt */
DECL|variable|do_poke_blanked_console
r_int
id|do_poke_blanked_console
op_assign
l_int|0
suffix:semicolon
DECL|variable|console_blanked
r_int
id|console_blanked
op_assign
l_int|0
suffix:semicolon
DECL|variable|blankinterval
r_static
r_int
id|blankinterval
op_assign
l_int|10
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
DECL|variable|vesa_off_interval
r_static
r_int
id|vesa_off_interval
op_assign
l_int|0
suffix:semicolon
DECL|variable|vesa_blank_mode
r_static
r_int
id|vesa_blank_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0:none 1:suspendV 2:suspendH 3:powerdown */
DECL|struct|vc
r_static
r_struct
id|vc
(brace
DECL|member|d
r_struct
id|vc_data
op_star
id|d
suffix:semicolon
multiline_comment|/* might add  scrmem, vt_struct, kbd  at some time,&n;&t;   to have everything in one place - the disadvantage&n;&t;   would be that vc_cons etc can no longer be static */
DECL|variable|vc_cons
)brace
id|vc_cons
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|conswitchp
r_struct
id|consw
op_star
id|conswitchp
suffix:semicolon
DECL|macro|cols
mdefine_line|#define cols            (vc_cons[currcons].d-&gt;vc_cols)
DECL|macro|rows
mdefine_line|#define rows            (vc_cons[currcons].d-&gt;vc_rows)
DECL|macro|size_row
mdefine_line|#define size_row        (vc_cons[currcons].d-&gt;vc_size_row)
DECL|macro|screenbuf_size
mdefine_line|#define screenbuf_size&t;(vc_cons[currcons].d-&gt;vc_screenbuf_size)
DECL|macro|cons_num
mdefine_line|#define cons_num&t;(vc_cons[currcons].d-&gt;vc_num)
DECL|macro|origin
mdefine_line|#define origin&t;&t;(vc_cons[currcons].d-&gt;vc_origin)
DECL|macro|scr_end
mdefine_line|#define scr_end&t;&t;(vc_cons[currcons].d-&gt;vc_scr_end)
DECL|macro|pos
mdefine_line|#define pos&t;&t;(vc_cons[currcons].d-&gt;vc_pos)
DECL|macro|top
mdefine_line|#define top&t;&t;(vc_cons[currcons].d-&gt;vc_top)
DECL|macro|bottom
mdefine_line|#define bottom&t;&t;(vc_cons[currcons].d-&gt;vc_bottom)
DECL|macro|x
mdefine_line|#define x&t;&t;(vc_cons[currcons].d-&gt;vc_x)
DECL|macro|y
mdefine_line|#define y&t;&t;(vc_cons[currcons].d-&gt;vc_y)
DECL|macro|vc_state
mdefine_line|#define vc_state&t;(vc_cons[currcons].d-&gt;vc_state)
DECL|macro|npar
mdefine_line|#define npar&t;&t;(vc_cons[currcons].d-&gt;vc_npar)
DECL|macro|par
mdefine_line|#define par&t;&t;(vc_cons[currcons].d-&gt;vc_par)
DECL|macro|ques
mdefine_line|#define ques&t;&t;(vc_cons[currcons].d-&gt;vc_ques)
DECL|macro|attr
mdefine_line|#define attr&t;&t;(vc_cons[currcons].d-&gt;vc_attr)
DECL|macro|saved_x
mdefine_line|#define saved_x&t;&t;(vc_cons[currcons].d-&gt;vc_saved_x)
DECL|macro|saved_y
mdefine_line|#define saved_y&t;&t;(vc_cons[currcons].d-&gt;vc_saved_y)
DECL|macro|translate
mdefine_line|#define translate&t;(vc_cons[currcons].d-&gt;vc_translate)
DECL|macro|G0_charset
mdefine_line|#define G0_charset&t;(vc_cons[currcons].d-&gt;vc_G0_charset)
DECL|macro|G1_charset
mdefine_line|#define G1_charset&t;(vc_cons[currcons].d-&gt;vc_G1_charset)
DECL|macro|saved_G0
mdefine_line|#define saved_G0&t;(vc_cons[currcons].d-&gt;vc_saved_G0)
DECL|macro|saved_G1
mdefine_line|#define saved_G1&t;(vc_cons[currcons].d-&gt;vc_saved_G1)
DECL|macro|utf
mdefine_line|#define utf&t;&t;(vc_cons[currcons].d-&gt;vc_utf)
DECL|macro|utf_count
mdefine_line|#define utf_count&t;(vc_cons[currcons].d-&gt;vc_utf_count)
DECL|macro|utf_char
mdefine_line|#define utf_char&t;(vc_cons[currcons].d-&gt;vc_utf_char)
DECL|macro|video_mem_start
mdefine_line|#define video_mem_start&t;(vc_cons[currcons].d-&gt;vc_video_mem_start)
DECL|macro|video_mem_end
mdefine_line|#define video_mem_end&t;(vc_cons[currcons].d-&gt;vc_video_mem_end)
DECL|macro|video_erase_char
mdefine_line|#define video_erase_char (vc_cons[currcons].d-&gt;vc_video_erase_char)&t;
DECL|macro|disp_ctrl
mdefine_line|#define disp_ctrl&t;(vc_cons[currcons].d-&gt;vc_disp_ctrl)
DECL|macro|toggle_meta
mdefine_line|#define toggle_meta&t;(vc_cons[currcons].d-&gt;vc_toggle_meta)
DECL|macro|decscnm
mdefine_line|#define decscnm&t;&t;(vc_cons[currcons].d-&gt;vc_decscnm)
DECL|macro|decom
mdefine_line|#define decom&t;&t;(vc_cons[currcons].d-&gt;vc_decom)
DECL|macro|decawm
mdefine_line|#define decawm&t;&t;(vc_cons[currcons].d-&gt;vc_decawm)
DECL|macro|deccm
mdefine_line|#define deccm&t;&t;(vc_cons[currcons].d-&gt;vc_deccm)
DECL|macro|decim
mdefine_line|#define decim&t;&t;(vc_cons[currcons].d-&gt;vc_decim)
DECL|macro|deccolm
mdefine_line|#define deccolm&t; &t;(vc_cons[currcons].d-&gt;vc_deccolm)
DECL|macro|need_wrap
mdefine_line|#define need_wrap&t;(vc_cons[currcons].d-&gt;vc_need_wrap)
DECL|macro|has_scrolled
mdefine_line|#define has_scrolled&t;(vc_cons[currcons].d-&gt;vc_has_scrolled)
DECL|macro|kmalloced
mdefine_line|#define kmalloced&t;(vc_cons[currcons].d-&gt;vc_kmalloced)
DECL|macro|report_mouse
mdefine_line|#define report_mouse&t;(vc_cons[currcons].d-&gt;vc_report_mouse)
DECL|macro|can_do_color
mdefine_line|#define can_do_color&t;(vc_cons[currcons].d-&gt;vc_can_do_color)
DECL|macro|color
mdefine_line|#define color&t;&t;(vc_cons[currcons].d-&gt;vc_color)
DECL|macro|s_color
mdefine_line|#define s_color&t;&t;(vc_cons[currcons].d-&gt;vc_s_color)
DECL|macro|def_color
mdefine_line|#define def_color&t;(vc_cons[currcons].d-&gt;vc_def_color)
DECL|macro|foreground
mdefine_line|#define&t;foreground&t;(color &amp; 0x0f)
DECL|macro|background
mdefine_line|#define background&t;(color &amp; 0xf0)
DECL|macro|charset
mdefine_line|#define charset&t;&t;(vc_cons[currcons].d-&gt;vc_charset)
DECL|macro|s_charset
mdefine_line|#define s_charset&t;(vc_cons[currcons].d-&gt;vc_s_charset)
DECL|macro|intensity
mdefine_line|#define&t;intensity&t;(vc_cons[currcons].d-&gt;vc_intensity)
DECL|macro|underline
mdefine_line|#define&t;underline&t;(vc_cons[currcons].d-&gt;vc_underline)
DECL|macro|blink
mdefine_line|#define&t;blink&t;&t;(vc_cons[currcons].d-&gt;vc_blink)
DECL|macro|reverse
mdefine_line|#define&t;reverse&t;&t;(vc_cons[currcons].d-&gt;vc_reverse)
DECL|macro|s_intensity
mdefine_line|#define&t;s_intensity&t;(vc_cons[currcons].d-&gt;vc_s_intensity)
DECL|macro|s_underline
mdefine_line|#define&t;s_underline&t;(vc_cons[currcons].d-&gt;vc_s_underline)
DECL|macro|s_blink
mdefine_line|#define&t;s_blink&t;&t;(vc_cons[currcons].d-&gt;vc_s_blink)
DECL|macro|s_reverse
mdefine_line|#define&t;s_reverse&t;(vc_cons[currcons].d-&gt;vc_s_reverse)
DECL|macro|ulcolor
mdefine_line|#define&t;ulcolor&t;&t;(vc_cons[currcons].d-&gt;vc_ulcolor)
DECL|macro|halfcolor
mdefine_line|#define&t;halfcolor&t;(vc_cons[currcons].d-&gt;vc_halfcolor)
DECL|macro|tab_stop
mdefine_line|#define tab_stop&t;(vc_cons[currcons].d-&gt;vc_tab_stop)
DECL|macro|bell_pitch
mdefine_line|#define bell_pitch&t;(vc_cons[currcons].d-&gt;vc_bell_pitch)
DECL|macro|bell_duration
mdefine_line|#define bell_duration&t;(vc_cons[currcons].d-&gt;vc_bell_duration)
DECL|macro|sw
mdefine_line|#define sw&t;&t;(vc_cons[currcons].d-&gt;vc_sw)
DECL|macro|vcmode
mdefine_line|#define vcmode&t;&t;(vt_cons[currcons]-&gt;vc_mode)
macro_line|#if 0 /* XXX */
mdefine_line|#define&t;vtmode&t;&t;(vt_cons[currcons]-&gt;vt_mode)
mdefine_line|#define&t;vtpid&t;&t;(vt_cons[currcons]-&gt;vt_pid)
mdefine_line|#define&t;vtnewvt&t;&t;(vt_cons[currcons]-&gt;vt_newvt)
macro_line|#endif
DECL|macro|structsize
mdefine_line|#define structsize&t;(sizeof(struct vc_data) + sizeof(struct vt_struct))
DECL|function|vc_cons_allocated
r_int
id|vc_cons_allocated
c_func
(paren
r_int
r_int
id|i
)paren
(brace
r_return
(paren
id|i
OL
id|MAX_NR_CONSOLES
op_logical_and
id|vc_cons
(braket
id|i
)braket
dot
id|d
)paren
suffix:semicolon
)brace
DECL|function|vc_allocate
r_int
id|vc_allocate
c_func
(paren
r_int
r_int
id|currcons
)paren
multiline_comment|/* return 0 on success */
(brace
r_if
c_cond
(paren
id|currcons
op_ge
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
)paren
(brace
r_int
id|p
comma
id|q
suffix:semicolon
multiline_comment|/* prevent users from taking too much memory */
r_if
c_cond
(paren
id|currcons
op_ge
id|MAX_NR_USER_CONSOLES
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* due to the granularity of kmalloc, we waste some memory here */
multiline_comment|/* the alloc is done in two steps, to optimize the common situation&n;&t;       of a 25x80 console (structsize=216, screenbuf_size=4000) */
id|p
op_assign
(paren
r_int
)paren
id|kmalloc
c_func
(paren
id|structsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
op_assign
(paren
r_struct
id|vc_data
op_star
)paren
id|p
suffix:semicolon
id|vt_cons
(braket
id|currcons
)braket
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
(paren
id|p
op_plus
r_sizeof
(paren
r_struct
id|vc_data
)paren
)paren
suffix:semicolon
multiline_comment|/* ++Geert: sw-&gt;con_init determines console size */
id|sw
op_assign
id|conswitchp
suffix:semicolon
id|cons_num
op_assign
id|currcons
suffix:semicolon
id|sw-&gt;con_init
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
)paren
suffix:semicolon
id|size_row
op_assign
id|cols
op_lshift
l_int|1
suffix:semicolon
id|screenbuf_size
op_assign
id|rows
op_star
id|size_row
suffix:semicolon
id|q
op_assign
(paren
r_int
)paren
id|kmalloc
c_func
(paren
id|screenbuf_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_char
op_star
)paren
id|p
comma
id|structsize
)paren
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vc_scrbuf
(braket
id|currcons
)braket
op_assign
(paren
r_int
r_int
op_star
)paren
id|q
suffix:semicolon
id|kmalloced
op_assign
l_int|1
suffix:semicolon
id|vc_init
(paren
id|currcons
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Change # of rows and columns (0 means the size of fg_console)&n; * [this is to be used together with some user program&n; * like resize that changes the hardware videomode]&n; */
DECL|function|vc_resize
r_int
id|vc_resize
c_func
(paren
r_int
r_int
id|lines
comma
r_int
r_int
id|columns
)paren
(brace
r_int
r_int
id|cc
comma
id|ll
comma
id|ss
comma
id|sr
suffix:semicolon
r_int
r_int
id|occ
comma
id|oll
comma
id|oss
comma
id|osr
suffix:semicolon
r_int
r_int
op_star
id|p
suffix:semicolon
r_int
r_int
id|currcons
op_assign
id|fg_console
comma
id|i
suffix:semicolon
r_int
r_int
op_star
id|newscreens
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
r_int
id|ol
comma
id|nl
comma
id|rlth
comma
id|rrem
suffix:semicolon
id|cc
op_assign
(paren
id|columns
ques
c_cond
id|columns
suffix:colon
id|cols
)paren
suffix:semicolon
id|ll
op_assign
(paren
id|lines
ques
c_cond
id|lines
suffix:colon
id|rows
)paren
suffix:semicolon
id|sr
op_assign
id|cc
op_lshift
l_int|1
suffix:semicolon
id|ss
op_assign
id|sr
op_star
id|ll
suffix:semicolon
multiline_comment|/*&n;&t; * Some earlier version had all consoles of potentially&n;&t; * different sizes, but that was really messy.&n;&t; * So now we only change if there is room for all consoles&n;&t; * of the same size.&n;&t; */
r_for
c_loop
(paren
id|currcons
op_assign
l_int|0
suffix:semicolon
id|currcons
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|currcons
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
id|newscreens
(braket
id|currcons
)braket
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|kmalloc
c_func
(paren
id|ss
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|currcons
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|newscreens
(braket
id|i
)braket
)paren
id|kfree_s
c_func
(paren
id|newscreens
(braket
id|i
)braket
comma
id|ss
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|newscreens
(braket
id|currcons
)braket
op_assign
id|p
suffix:semicolon
)brace
)brace
macro_line|#if 0 /* XXX */
id|get_scrmem
c_func
(paren
id|fg_console
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|currcons
op_assign
l_int|0
suffix:semicolon
id|currcons
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|currcons
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
r_continue
suffix:semicolon
id|oll
op_assign
id|rows
suffix:semicolon
id|occ
op_assign
id|cols
suffix:semicolon
id|osr
op_assign
id|size_row
suffix:semicolon
id|oss
op_assign
id|screenbuf_size
suffix:semicolon
id|rows
op_assign
id|ll
suffix:semicolon
id|cols
op_assign
id|cc
suffix:semicolon
id|size_row
op_assign
id|sr
suffix:semicolon
id|screenbuf_size
op_assign
id|ss
suffix:semicolon
id|rlth
op_assign
id|MIN
c_func
(paren
id|osr
comma
id|sr
)paren
suffix:semicolon
id|rrem
op_assign
id|sr
op_minus
id|rlth
suffix:semicolon
id|ol
op_assign
id|origin
suffix:semicolon
id|nl
op_assign
(paren
r_int
)paren
id|newscreens
(braket
id|currcons
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ll
OL
id|oll
)paren
id|ol
op_add_assign
(paren
id|oll
op_minus
id|ll
)paren
op_star
id|osr
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ol
OL
id|scr_end
)paren
(brace
multiline_comment|/* ++Geert: TODO: Because the attributes have different meanings&n;                   on monochrome and color, they should really be converted if&n;                   can_do_color changes... */
id|memcpyw
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|nl
comma
(paren
r_int
r_int
op_star
)paren
id|ol
comma
id|rlth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rrem
)paren
id|memsetw
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|nl
op_plus
id|rlth
)paren
comma
id|video_erase_char
comma
id|rrem
)paren
suffix:semicolon
id|ol
op_add_assign
id|osr
suffix:semicolon
id|nl
op_add_assign
id|sr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kmalloced
)paren
id|kfree_s
c_func
(paren
id|vc_scrbuf
(braket
id|currcons
)braket
comma
id|oss
)paren
suffix:semicolon
id|vc_scrbuf
(braket
id|currcons
)braket
op_assign
id|newscreens
(braket
id|currcons
)braket
suffix:semicolon
id|kmalloced
op_assign
l_int|1
suffix:semicolon
id|screenbuf_size
op_assign
id|ss
suffix:semicolon
id|origin
op_assign
(paren
r_int
)paren
id|video_mem_start
op_assign
id|vc_scrbuf
(braket
id|currcons
)braket
suffix:semicolon
id|scr_end
op_assign
id|video_mem_end
op_assign
(paren
(paren
r_int
)paren
id|video_mem_start
)paren
op_plus
id|ss
suffix:semicolon
r_if
c_cond
(paren
id|scr_end
OG
id|nl
)paren
id|memsetw
c_func
(paren
(paren
r_void
op_star
)paren
id|nl
comma
id|video_erase_char
comma
id|scr_end
op_minus
id|nl
)paren
suffix:semicolon
multiline_comment|/* do part of a reset_terminal() */
id|top
op_assign
l_int|0
suffix:semicolon
id|bottom
op_assign
id|rows
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|y
)paren
suffix:semicolon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* XXX */
id|set_scrmem
c_func
(paren
id|fg_console
comma
l_int|0
)paren
suffix:semicolon
id|set_origin
c_func
(paren
id|fg_console
)paren
suffix:semicolon
macro_line|#endif /* XXX */
id|update_screen
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|set_cursor
c_func
(paren
id|fg_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ++Geert: Change # of rows and columns for one specific console.&n; * Of course it&squot;s not messy to have all consoles of potentially different sizes,&n; * except on PCish hardware :-)&n; *&n; * This is called by the low level console driver (arch/m68k/console/fbcon.c or&n; * arch/m68k/console/txtcon.c)&n; */
DECL|function|vc_resize_con
r_void
id|vc_resize_con
c_func
(paren
r_int
r_int
id|lines
comma
r_int
r_int
id|columns
comma
r_int
r_int
id|currcons
)paren
(brace
r_int
r_int
id|cc
comma
id|ll
comma
id|ss
comma
id|sr
suffix:semicolon
r_int
r_int
id|occ
comma
id|oll
comma
id|oss
comma
id|osr
suffix:semicolon
r_int
r_int
op_star
id|newscreen
suffix:semicolon
r_int
id|ol
comma
id|nl
comma
id|rlth
comma
id|rrem
suffix:semicolon
r_struct
id|winsize
id|ws
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|columns
op_logical_or
op_logical_neg
id|lines
op_logical_or
id|currcons
op_ge
id|MAX_NR_CONSOLES
)paren
r_return
suffix:semicolon
id|cc
op_assign
id|columns
suffix:semicolon
id|ll
op_assign
id|lines
suffix:semicolon
id|sr
op_assign
id|cc
op_lshift
l_int|1
suffix:semicolon
id|ss
op_assign
id|sr
op_star
id|ll
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
id|newscreen
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|newscreen
op_assign
(paren
r_int
r_int
op_star
)paren
id|kmalloc
c_func
(paren
id|ss
comma
id|GFP_USER
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
(brace
id|oll
op_assign
id|rows
suffix:semicolon
id|occ
op_assign
id|cols
suffix:semicolon
id|osr
op_assign
id|size_row
suffix:semicolon
id|oss
op_assign
id|screenbuf_size
suffix:semicolon
id|rows
op_assign
id|ll
suffix:semicolon
id|cols
op_assign
id|cc
suffix:semicolon
id|size_row
op_assign
id|sr
suffix:semicolon
id|screenbuf_size
op_assign
id|ss
suffix:semicolon
id|rlth
op_assign
id|MIN
c_func
(paren
id|osr
comma
id|sr
)paren
suffix:semicolon
id|rrem
op_assign
id|sr
op_minus
id|rlth
suffix:semicolon
id|ol
op_assign
id|origin
suffix:semicolon
id|nl
op_assign
(paren
r_int
)paren
id|newscreen
suffix:semicolon
r_if
c_cond
(paren
id|ll
OL
id|oll
)paren
id|ol
op_add_assign
(paren
id|oll
op_minus
id|ll
)paren
op_star
id|osr
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ol
OL
id|scr_end
)paren
(brace
multiline_comment|/* ++Geert: TODO: Because the attributes have different meanings&n;                   on monochrome and color, they should really be converted if&n;                   can_do_color changes... */
id|memcpyw
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|nl
comma
(paren
r_int
r_int
op_star
)paren
id|ol
comma
id|rlth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rrem
)paren
id|memsetw
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|nl
op_plus
id|rlth
)paren
comma
id|video_erase_char
comma
id|rrem
)paren
suffix:semicolon
id|ol
op_add_assign
id|osr
suffix:semicolon
id|nl
op_add_assign
id|sr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kmalloced
)paren
id|kfree_s
c_func
(paren
id|vc_scrbuf
(braket
id|currcons
)braket
comma
id|oss
)paren
suffix:semicolon
id|vc_scrbuf
(braket
id|currcons
)braket
op_assign
id|newscreen
suffix:semicolon
id|kmalloced
op_assign
l_int|1
suffix:semicolon
id|screenbuf_size
op_assign
id|ss
suffix:semicolon
id|origin
op_assign
(paren
r_int
)paren
id|video_mem_start
op_assign
id|vc_scrbuf
(braket
id|currcons
)braket
suffix:semicolon
id|scr_end
op_assign
id|video_mem_end
op_assign
(paren
(paren
r_int
)paren
id|video_mem_start
)paren
op_plus
id|ss
suffix:semicolon
r_if
c_cond
(paren
id|scr_end
OG
id|nl
)paren
id|memsetw
c_func
(paren
(paren
r_void
op_star
)paren
id|nl
comma
id|video_erase_char
comma
id|scr_end
op_minus
id|nl
)paren
suffix:semicolon
multiline_comment|/* do part of a reset_terminal() */
id|top
op_assign
l_int|0
suffix:semicolon
id|bottom
op_assign
id|rows
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|y
)paren
suffix:semicolon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|ws.ws_row
op_assign
id|rows
suffix:semicolon
id|ws.ws_col
op_assign
id|cols
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|ws
comma
op_amp
id|console_table
(braket
id|currcons
)braket
op_member_access_from_pointer
id|winsize
comma
r_sizeof
(paren
r_struct
id|winsize
)paren
)paren
op_logical_and
id|console_table
(braket
id|currcons
)braket
op_member_access_from_pointer
id|pgrp
OG
l_int|0
)paren
id|kill_pg
c_func
(paren
id|console_table
(braket
id|currcons
)braket
op_member_access_from_pointer
id|pgrp
comma
id|SIGWINCH
comma
l_int|1
)paren
suffix:semicolon
id|console_table
(braket
id|currcons
)braket
op_member_access_from_pointer
id|winsize
op_assign
id|ws
suffix:semicolon
)brace
r_if
c_cond
(paren
id|currcons
op_eq
id|fg_console
)paren
id|update_screen
c_func
(paren
id|fg_console
)paren
suffix:semicolon
)brace
DECL|function|vc_disallocate
r_void
id|vc_disallocate
c_func
(paren
r_int
r_int
id|currcons
)paren
(brace
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
(brace
r_if
c_cond
(paren
id|kmalloced
)paren
id|kfree_s
c_func
(paren
id|vc_scrbuf
(braket
id|currcons
)braket
comma
id|screenbuf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ge
id|MIN_NR_CONSOLES
)paren
id|kfree_s
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|structsize
)paren
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|macro|set_kbd
mdefine_line|#define set_kbd(x) set_vc_kbd_mode(kbd_table+currcons,x)
DECL|macro|clr_kbd
mdefine_line|#define clr_kbd(x) clr_vc_kbd_mode(kbd_table+currcons,x)
DECL|macro|is_kbd
mdefine_line|#define is_kbd(x) vc_kbd_mode(kbd_table+currcons,x)
DECL|macro|decarm
mdefine_line|#define decarm&t;&t;VC_REPEAT
DECL|macro|decckm
mdefine_line|#define decckm&t;&t;VC_CKMODE
DECL|macro|kbdapplic
mdefine_line|#define kbdapplic&t;VC_APPLIC
DECL|macro|lnm
mdefine_line|#define lnm&t;&t;VC_CRLF
multiline_comment|/*&n; * this is what the terminal answers to a ESC-Z or csi0c query.&n; */
DECL|macro|VT100ID
mdefine_line|#define VT100ID &quot;&bslash;033[?1;2c&quot;
DECL|macro|VT102ID
mdefine_line|#define VT102ID &quot;&bslash;033[?6c&quot;
DECL|variable|color_table
r_static
r_int
r_char
id|color_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|4
comma
l_int|2
comma
l_int|6
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|7
comma
l_int|8
comma
l_int|12
comma
l_int|10
comma
l_int|14
comma
l_int|9
comma
l_int|13
comma
l_int|11
comma
l_int|15
)brace
suffix:semicolon
multiline_comment|/*&n; * gotoxy() must verify all boundaries, because the arguments&n; * might also be negative. If the given position is out of&n; * bounds, the cursor is placed at the nearest margin.&n; */
DECL|function|gotoxy
r_static
r_void
id|gotoxy
c_func
(paren
r_int
id|currcons
comma
r_int
id|new_x
comma
r_int
id|new_y
)paren
(brace
r_int
id|min_y
comma
id|max_y
suffix:semicolon
r_if
c_cond
(paren
id|new_x
OL
l_int|0
)paren
id|x
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|new_x
op_ge
id|cols
)paren
id|x
op_assign
id|cols
op_minus
l_int|1
suffix:semicolon
r_else
id|x
op_assign
id|new_x
suffix:semicolon
r_if
c_cond
(paren
id|decom
)paren
(brace
id|min_y
op_assign
id|top
suffix:semicolon
id|max_y
op_assign
id|bottom
suffix:semicolon
)brace
r_else
(brace
id|min_y
op_assign
l_int|0
suffix:semicolon
id|max_y
op_assign
id|rows
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_y
OL
id|min_y
)paren
id|y
op_assign
id|min_y
suffix:semicolon
r_else
r_if
c_cond
(paren
id|new_y
op_ge
id|max_y
)paren
id|y
op_assign
id|max_y
op_minus
l_int|1
suffix:semicolon
r_else
id|y
op_assign
id|new_y
suffix:semicolon
id|pos
op_assign
id|video_mem_start
op_plus
id|y
op_star
id|cols
op_plus
id|x
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* for absolute user moves, when decom is set */
DECL|function|gotoxay
r_static
r_void
id|gotoxay
c_func
(paren
r_int
id|currcons
comma
r_int
id|new_x
comma
r_int
id|new_y
)paren
(brace
id|gotoxy
c_func
(paren
id|currcons
comma
id|new_x
comma
id|decom
ques
c_cond
(paren
id|top
op_plus
id|new_y
)paren
suffix:colon
id|new_y
)paren
suffix:semicolon
)brace
DECL|function|hide_cursor
r_static
r_void
id|hide_cursor
c_func
(paren
r_int
id|currcons
)paren
(brace
id|sw
op_member_access_from_pointer
id|con_cursor
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|CM_ERASE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|set_cursor
r_static
r_void
id|set_cursor
c_func
(paren
r_int
id|currcons
)paren
(brace
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
op_logical_or
id|console_blanked
op_logical_or
id|vcmode
op_eq
id|KD_GRAPHICS
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|deccm
)paren
id|sw
op_member_access_from_pointer
id|con_cursor
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|CM_DRAW
)paren
suffix:semicolon
r_else
id|hide_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|no_scroll
r_void
id|no_scroll
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/*&n;   * no_scroll currently does nothing on the m68k.&n;   */
)brace
multiline_comment|/*&n; * Arno:&n; * Why do we need these? The keyboard code doesn&squot;t seem to do anything&n; * with them either...&n; */
DECL|function|scrollfront
r_void
id|scrollfront
c_func
(paren
r_int
id|l
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|function|scrollback
r_void
id|scrollback
c_func
(paren
r_int
id|l
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|function|scrup
r_static
r_void
id|scrup
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|t
comma
r_int
r_int
id|b
comma
r_int
id|nr
)paren
(brace
r_int
r_int
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
id|rows
op_logical_or
id|t
op_ge
id|b
)paren
r_return
suffix:semicolon
id|memmove
(paren
id|video_mem_start
op_plus
id|t
op_star
id|cols
comma
id|video_mem_start
op_plus
(paren
id|t
op_plus
id|nr
)paren
op_star
id|cols
comma
(paren
id|b
op_minus
id|t
op_minus
id|nr
)paren
op_star
id|cols
op_star
l_int|2
)paren
suffix:semicolon
id|p
op_assign
id|video_mem_start
op_plus
(paren
id|b
op_minus
id|nr
)paren
op_star
id|cols
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr
op_star
id|cols
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
op_star
id|p
op_increment
op_assign
id|video_erase_char
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_return
suffix:semicolon
multiline_comment|/*&n; * Arno:&n; * Scrolling has now been moved to amicon.c where it should have&n; * been all along.&n; */
id|sw
op_member_access_from_pointer
id|con_scroll
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|t
comma
id|b
comma
id|SM_UP
comma
id|nr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|scrdown
r_static
r_void
id|scrdown
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|t
comma
r_int
r_int
id|b
comma
r_int
id|nr
)paren
(brace
r_int
r_int
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
id|rows
op_logical_or
id|t
op_ge
id|b
)paren
r_return
suffix:semicolon
id|memmove
(paren
id|video_mem_start
op_plus
(paren
id|t
op_plus
id|nr
)paren
op_star
id|cols
comma
id|video_mem_start
op_plus
id|t
op_star
id|cols
comma
(paren
id|b
op_minus
id|t
op_minus
id|nr
)paren
op_star
id|cols
op_star
l_int|2
)paren
suffix:semicolon
id|p
op_assign
id|video_mem_start
op_plus
id|t
op_star
id|cols
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr
op_star
id|cols
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
op_star
id|p
op_increment
op_assign
id|video_erase_char
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_return
suffix:semicolon
multiline_comment|/*&n; * Arno:&n; * Scrolling has now been moved to amicon.c where it should have&n; * been all along.&n; */
id|sw
op_member_access_from_pointer
id|con_scroll
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|t
comma
id|b
comma
id|SM_DOWN
comma
id|nr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|lf
r_static
r_void
id|lf
c_func
(paren
r_int
id|currcons
)paren
(brace
multiline_comment|/* don&squot;t scroll if above bottom of scrolling region, or&n;&t; * if below scrolling region&n;&t; */
r_if
c_cond
(paren
id|y
op_plus
l_int|1
op_eq
id|bottom
)paren
id|scrup
c_func
(paren
id|currcons
comma
id|top
comma
id|bottom
comma
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|y
OL
id|rows
op_minus
l_int|1
)paren
(brace
id|y
op_increment
suffix:semicolon
id|pos
op_add_assign
id|cols
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ri
r_static
r_void
id|ri
c_func
(paren
r_int
id|currcons
)paren
(brace
multiline_comment|/* don&squot;t scroll if below top of scrolling region, or&n;&t; * if above scrolling region&n;&t; */
r_if
c_cond
(paren
id|y
op_eq
id|top
)paren
id|scrdown
c_func
(paren
id|currcons
comma
id|top
comma
id|bottom
comma
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|y
OG
l_int|0
)paren
(brace
id|y
op_decrement
suffix:semicolon
id|pos
op_sub_assign
id|cols
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|cr
r_static
r_inline
r_void
id|cr
c_func
(paren
r_int
id|currcons
)paren
(brace
id|pos
op_sub_assign
id|x
suffix:semicolon
id|need_wrap
op_assign
id|x
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|bs
r_static
r_inline
r_void
id|bs
c_func
(paren
r_int
id|currcons
)paren
(brace
r_if
c_cond
(paren
id|x
)paren
(brace
id|pos
op_decrement
suffix:semicolon
id|x
op_decrement
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|del
r_static
r_inline
r_void
id|del
c_func
(paren
r_int
id|currcons
)paren
(brace
multiline_comment|/* ignored */
)brace
DECL|function|csi_J
r_static
r_void
id|csi_J
c_func
(paren
r_int
id|currcons
comma
r_int
id|vpar
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
r_int
r_int
op_star
id|start
suffix:semicolon
r_switch
c_cond
(paren
id|vpar
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* erase from cursor to end of display */
id|count
op_assign
(paren
id|video_mem_start
op_plus
id|cols
op_star
id|rows
op_minus
id|pos
)paren
suffix:semicolon
id|start
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_break
suffix:semicolon
multiline_comment|/* 680x0 do in two stages */
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
id|x
comma
l_int|1
comma
id|cols
op_minus
id|x
)paren
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
op_plus
l_int|1
comma
l_int|0
comma
id|rows
op_minus
id|y
op_minus
l_int|1
comma
id|cols
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* erase from start to cursor */
id|count
op_assign
id|pos
op_minus
id|video_mem_start
op_plus
l_int|1
suffix:semicolon
id|start
op_assign
id|video_mem_start
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_break
suffix:semicolon
multiline_comment|/* 680x0 do in two stages */
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
l_int|0
comma
l_int|0
comma
id|y
comma
id|cols
)paren
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
l_int|0
comma
l_int|1
comma
id|x
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* erase whole display */
id|count
op_assign
id|cols
op_star
id|rows
suffix:semicolon
id|start
op_assign
id|video_mem_start
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_break
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
l_int|0
comma
l_int|0
comma
id|rows
comma
id|cols
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
op_star
id|start
op_increment
op_assign
id|video_erase_char
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|csi_K
r_static
r_void
id|csi_K
c_func
(paren
r_int
id|currcons
comma
r_int
id|vpar
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
r_int
r_int
op_star
id|start
suffix:semicolon
r_switch
c_cond
(paren
id|vpar
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* erase from cursor to end of line */
id|count
op_assign
id|cols
op_minus
id|x
suffix:semicolon
id|start
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_break
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
id|x
comma
l_int|1
comma
id|cols
op_minus
id|x
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* erase from start of line to cursor */
id|start
op_assign
id|pos
op_minus
id|x
suffix:semicolon
id|count
op_assign
id|x
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_break
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
l_int|0
comma
l_int|1
comma
id|x
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* erase whole line */
id|start
op_assign
id|pos
op_minus
id|x
suffix:semicolon
id|count
op_assign
id|cols
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_break
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
l_int|0
comma
l_int|1
comma
id|cols
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
op_star
id|start
op_increment
op_assign
id|video_erase_char
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|csi_X
r_static
r_void
id|csi_X
c_func
(paren
r_int
id|currcons
comma
r_int
id|vpar
)paren
multiline_comment|/* erase the following vpar positions */
(brace
multiline_comment|/* not vt100? */
r_int
r_int
id|count
suffix:semicolon
r_int
r_int
op_star
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vpar
)paren
id|vpar
op_increment
suffix:semicolon
id|start
op_assign
id|pos
suffix:semicolon
id|count
op_assign
(paren
id|vpar
OG
id|cols
op_minus
id|x
)paren
ques
c_cond
(paren
id|cols
op_minus
id|x
)paren
suffix:colon
id|vpar
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_eq
id|fg_console
)paren
id|sw
op_member_access_from_pointer
id|con_clear
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
id|x
comma
l_int|1
comma
id|count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
op_star
id|start
op_increment
op_assign
id|video_erase_char
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Arno: &n; * On 680x0 attributes are currently not used. This piece of code&n; * seems hardware independent, but uses the EGA/VGA way of representing&n; * attributes. &n; * TODO: modify for 680x0 and add attribute processing to putc code.&n; *&n; * ++roman: I completely changed the attribute format for monochrome&n; * mode (!can_do_color). The formerly used MDA (monochrome display&n; * adapter) format didn&squot;t allow the combination of certain effects.&n; * Now the attribute is just a bit vector:&n; *  Bit 0..1: intensity (0..2)&n; *  Bit 2   : underline&n; *  Bit 3   : reverse&n; *  Bit 7   : blink&n; */
DECL|function|update_attr
r_static
r_void
id|update_attr
c_func
(paren
r_int
id|currcons
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|can_do_color
)paren
(brace
multiline_comment|/* Special treatment for monochrome */
id|attr
op_assign
id|intensity
op_or
(paren
id|underline
ques
c_cond
l_int|4
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|reverse
op_xor
id|decscnm
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|0
)paren
op_or
(paren
id|blink
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
suffix:semicolon
id|video_erase_char
op_assign
l_char|&squot; &squot;
op_or
(paren
(paren
id|reverse
op_xor
id|decscnm
)paren
ques
c_cond
l_int|0x800
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|attr
op_assign
id|color
suffix:semicolon
r_if
c_cond
(paren
id|underline
)paren
id|attr
op_assign
(paren
id|attr
op_amp
l_int|0xf0
)paren
op_or
id|ulcolor
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intensity
op_eq
l_int|0
)paren
id|attr
op_assign
(paren
id|attr
op_amp
l_int|0xf0
)paren
op_or
id|halfcolor
suffix:semicolon
r_if
c_cond
(paren
id|reverse
op_xor
id|decscnm
)paren
id|attr
op_assign
id|reverse_video_char
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blink
)paren
id|attr
op_xor_assign
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
id|intensity
op_eq
l_int|2
)paren
id|attr
op_xor_assign
l_int|0x08
suffix:semicolon
r_if
c_cond
(paren
id|decscnm
)paren
id|video_erase_char
op_assign
(paren
id|reverse_video_char
c_func
(paren
id|color
)paren
op_lshift
l_int|8
)paren
op_or
l_char|&squot; &squot;
suffix:semicolon
r_else
id|video_erase_char
op_assign
(paren
id|color
op_lshift
l_int|8
)paren
op_or
l_char|&squot; &squot;
suffix:semicolon
)brace
DECL|function|default_attr
r_static
r_void
id|default_attr
c_func
(paren
r_int
id|currcons
)paren
(brace
id|intensity
op_assign
l_int|1
suffix:semicolon
id|underline
op_assign
l_int|0
suffix:semicolon
id|reverse
op_assign
l_int|0
suffix:semicolon
id|blink
op_assign
l_int|0
suffix:semicolon
id|color
op_assign
id|def_color
suffix:semicolon
)brace
DECL|function|csi_m
r_static
r_void
id|csi_m
c_func
(paren
r_int
id|currcons
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|npar
suffix:semicolon
id|i
op_increment
)paren
r_switch
c_cond
(paren
id|par
(braket
id|i
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* all attributes off */
id|default_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|intensity
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|intensity
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|underline
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|blink
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|reverse
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Select primary font, don&squot;t display&n;&t;&t;&t;&t;  * control chars if defined, don&squot;t set&n;&t;&t;&t;&t;  * bit 8 on output.&n;&t;&t;&t;&t;  */
id|translate
op_assign
id|set_translate
c_func
(paren
id|charset
op_eq
l_int|0
ques
c_cond
id|G0_charset
suffix:colon
id|G1_charset
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|0
suffix:semicolon
id|toggle_meta
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Select first alternate font, let&squot;s&n;&t;&t;&t;&t;  * chars &lt; 32 be displayed as ROM chars.&n;&t;&t;&t;&t;  */
id|translate
op_assign
id|set_translate
c_func
(paren
id|IBMPC_MAP
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|1
suffix:semicolon
id|toggle_meta
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Select second alternate font, toggle&n;&t;&t;&t;&t;  * high bit before displaying as ROM char.&n;&t;&t;&t;&t;  */
id|translate
op_assign
id|set_translate
c_func
(paren
id|IBMPC_MAP
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|1
suffix:semicolon
id|toggle_meta
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|21
suffix:colon
r_case
l_int|22
suffix:colon
id|intensity
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|underline
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
id|blink
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|27
suffix:colon
id|reverse
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Enables underscore, white foreground&n;&t;&t;&t;&t;  * with white underscore (Linux - use&n;&t;&t;&t;&t;  * default foreground).&n;&t;&t;&t;&t;  */
id|color
op_assign
(paren
id|def_color
op_amp
l_int|0x0f
)paren
op_or
id|background
suffix:semicolon
id|underline
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|39
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Disable underline option.&n;&t;&t;&t;&t;  * Reset colour to default? It did this&n;&t;&t;&t;&t;  * before...&n;&t;&t;&t;&t;  */
id|color
op_assign
(paren
id|def_color
op_amp
l_int|0x0f
)paren
op_or
id|background
suffix:semicolon
id|underline
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|49
suffix:colon
id|color
op_assign
(paren
id|def_color
op_amp
l_int|0xf0
)paren
op_or
id|foreground
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|par
(braket
id|i
)braket
op_ge
l_int|30
op_logical_and
id|par
(braket
id|i
)braket
op_le
l_int|37
)paren
id|color
op_assign
id|color_table
(braket
id|par
(braket
id|i
)braket
op_minus
l_int|30
)braket
op_or
id|background
suffix:semicolon
r_else
r_if
c_cond
(paren
id|par
(braket
id|i
)braket
op_ge
l_int|40
op_logical_and
id|par
(braket
id|i
)braket
op_le
l_int|47
)paren
id|color
op_assign
(paren
id|color_table
(braket
id|par
(braket
id|i
)braket
op_minus
l_int|40
)braket
op_lshift
l_int|4
)paren
op_or
id|foreground
suffix:semicolon
r_break
suffix:semicolon
)brace
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|respond_string
r_static
r_void
id|respond_string
c_func
(paren
r_const
r_char
op_star
id|p
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
op_star
id|p
comma
l_int|0
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|cursor_report
r_static
r_inline
r_void
id|cursor_report
c_func
(paren
r_int
id|currcons
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;033[%ld;%ldR&quot;
comma
id|y
op_plus
(paren
id|decom
ques
c_cond
id|top
op_plus
l_int|1
suffix:colon
l_int|1
)paren
comma
id|x
op_plus
l_int|1
)paren
suffix:semicolon
id|respond_string
c_func
(paren
id|buf
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|status_report
r_static
r_inline
r_void
id|status_report
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|respond_string
c_func
(paren
l_string|&quot;&bslash;033[0n&quot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* Terminal ok */
)brace
DECL|function|respond_ID
r_static
r_inline
r_void
id|respond_ID
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|respond_string
c_func
(paren
id|VT102ID
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|mouse_report
r_void
id|mouse_report
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|butt
comma
r_int
id|mrx
comma
r_int
id|mry
)paren
(brace
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;033[M%c%c%c&quot;
comma
(paren
r_char
)paren
(paren
l_char|&squot; &squot;
op_plus
id|butt
)paren
comma
(paren
r_char
)paren
(paren
l_char|&squot;!&squot;
op_plus
id|mrx
)paren
comma
(paren
r_char
)paren
(paren
l_char|&squot;!&squot;
op_plus
id|mry
)paren
)paren
suffix:semicolon
id|respond_string
c_func
(paren
id|buf
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* invoked via ioctl(TIOCLINUX) */
DECL|function|mouse_reporting
r_int
id|mouse_reporting
c_func
(paren
r_void
)paren
(brace
r_int
id|currcons
op_assign
id|fg_console
suffix:semicolon
r_return
id|report_mouse
suffix:semicolon
)brace
DECL|function|screenpos
r_static
r_inline
r_int
r_int
op_star
id|screenpos
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
comma
r_int
id|viewed
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|origin
op_plus
id|offset
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|viewed
op_logical_and
id|currcons
op_eq
id|fg_console
)paren
id|p
op_sub_assign
(paren
id|__real_origin
op_minus
id|__origin
)paren
suffix:semicolon
macro_line|#endif
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* Note: inverting the screen twice should revert to the original state */
DECL|function|invert_screen
r_void
id|invert_screen
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
comma
r_int
id|count
comma
r_int
id|viewed
)paren
(brace
r_int
r_int
op_star
id|p
suffix:semicolon
r_int
r_int
id|xx
comma
id|yy
comma
id|oldattr
suffix:semicolon
id|count
op_div_assign
l_int|2
suffix:semicolon
id|p
op_assign
id|screenpos
c_func
(paren
id|currcons
comma
id|offset
comma
id|viewed
)paren
suffix:semicolon
id|xx
op_assign
(paren
id|offset
op_rshift
l_int|1
)paren
op_mod
id|cols
suffix:semicolon
id|yy
op_assign
(paren
id|offset
op_rshift
l_int|1
)paren
op_div
id|cols
suffix:semicolon
id|oldattr
op_assign
id|attr
suffix:semicolon
r_if
c_cond
(paren
id|can_do_color
)paren
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
r_int
r_int
id|old
op_assign
id|scr_readw
c_func
(paren
id|p
)paren
suffix:semicolon
r_int
r_int
r_new
op_assign
id|reverse_video_short
c_func
(paren
id|old
)paren
suffix:semicolon
id|scr_writew
c_func
(paren
r_new
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_continue
suffix:semicolon
id|attr
op_assign
r_new
op_rshift
l_int|8
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_putc
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
r_new
op_amp
l_int|0xff
comma
id|yy
comma
id|xx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|xx
op_eq
id|cols
)paren
id|xx
op_assign
l_int|0
comma
op_increment
id|yy
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
r_int
r_int
id|old
op_assign
id|scr_readw
c_func
(paren
id|p
)paren
suffix:semicolon
r_int
r_int
r_new
op_assign
id|old
op_xor
l_int|0x800
suffix:semicolon
id|scr_writew
c_func
(paren
r_new
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_continue
suffix:semicolon
id|attr
op_assign
r_new
op_rshift
l_int|8
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_putc
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
r_new
op_amp
l_int|0xff
comma
id|yy
comma
id|xx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|xx
op_eq
id|cols
)paren
id|xx
op_assign
l_int|0
comma
op_increment
id|yy
suffix:semicolon
)brace
id|attr
op_assign
id|oldattr
suffix:semicolon
)brace
multiline_comment|/* used by selection: complement pointer position */
DECL|function|complement_pos
r_void
id|complement_pos
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
)paren
(brace
r_static
r_int
r_int
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
r_int
id|old
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|oldx
op_assign
l_int|0
comma
id|oldy
op_assign
l_int|0
suffix:semicolon
r_int
r_int
r_new
comma
id|oldattr
suffix:semicolon
id|oldattr
op_assign
id|attr
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|scr_writew
c_func
(paren
id|old
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_eq
id|fg_console
)paren
(brace
id|attr
op_assign
id|old
op_rshift
l_int|8
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_putc
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|old
op_amp
l_int|0xff
comma
id|oldy
comma
id|oldx
)paren
suffix:semicolon
id|attr
op_assign
id|oldattr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|offset
op_eq
op_minus
l_int|1
)paren
id|p
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|p
op_assign
id|screenpos
c_func
(paren
id|currcons
comma
id|offset
comma
l_int|1
)paren
suffix:semicolon
id|old
op_assign
id|scr_readw
c_func
(paren
id|p
)paren
suffix:semicolon
id|oldx
op_assign
(paren
id|offset
op_rshift
l_int|1
)paren
op_mod
id|cols
suffix:semicolon
id|oldy
op_assign
(paren
id|offset
op_rshift
l_int|1
)paren
op_div
id|cols
suffix:semicolon
r_if
c_cond
(paren
id|can_do_color
)paren
r_new
op_assign
id|old
op_xor
l_int|0x7700
suffix:semicolon
r_else
r_new
op_assign
id|old
op_xor
l_int|0x800
suffix:semicolon
id|scr_writew
c_func
(paren
r_new
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_eq
id|fg_console
)paren
(brace
id|attr
op_assign
r_new
op_rshift
l_int|8
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_putc
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
r_new
op_amp
l_int|0xff
comma
id|oldy
comma
id|oldx
)paren
suffix:semicolon
id|attr
op_assign
id|oldattr
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* used by selection */
DECL|function|screen_word
r_int
r_int
id|screen_word
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
comma
r_int
id|viewed
)paren
(brace
r_return
id|scr_readw
c_func
(paren
id|screenpos
c_func
(paren
id|currcons
comma
id|offset
comma
id|viewed
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* used by selection - convert a screen word to a glyph number */
DECL|function|scrw2glyph
r_int
id|scrw2glyph
c_func
(paren
r_int
r_int
id|scr_word
)paren
(brace
r_return
(paren
id|video_mode_512ch
)paren
ques
c_cond
(paren
(paren
id|scr_word
op_amp
l_int|0x0800
)paren
op_rshift
l_int|3
)paren
op_plus
(paren
id|scr_word
op_amp
l_int|0x00ff
)paren
suffix:colon
id|scr_word
op_amp
l_int|0x00ff
suffix:semicolon
)brace
multiline_comment|/* used by vcs - note the word offset */
DECL|function|screen_pos
r_int
r_int
op_star
id|screen_pos
c_func
(paren
r_int
id|currcons
comma
r_int
id|w_offset
comma
r_int
id|viewed
)paren
(brace
r_return
id|screenpos
c_func
(paren
id|currcons
comma
l_int|2
op_star
id|w_offset
comma
id|viewed
)paren
suffix:semicolon
)brace
DECL|function|getconsxy
r_void
id|getconsxy
c_func
(paren
r_int
id|currcons
comma
r_char
op_star
id|p
)paren
(brace
id|p
(braket
l_int|0
)braket
op_assign
id|x
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
id|y
suffix:semicolon
)brace
DECL|function|putconsxy
r_void
id|putconsxy
c_func
(paren
r_int
id|currcons
comma
r_char
op_star
id|p
)paren
(brace
id|gotoxy
c_func
(paren
id|currcons
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|set_mode
r_static
r_void
id|set_mode
c_func
(paren
r_int
id|currcons
comma
r_int
id|on_off
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|npar
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ques
)paren
r_switch
c_cond
(paren
id|par
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* DEC private modes set/reset */
r_case
l_int|1
suffix:colon
multiline_comment|/* Cursor keys send ^[Ox/^[[x */
r_if
c_cond
(paren
id|on_off
)paren
id|set_kbd
c_func
(paren
id|decckm
)paren
suffix:semicolon
r_else
id|clr_kbd
c_func
(paren
id|decckm
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* 80/132 mode switch unimplemented */
id|deccolm
op_assign
id|on_off
suffix:semicolon
macro_line|#if 0
(paren
r_void
)paren
id|vc_resize
c_func
(paren
id|rows
comma
id|deccolm
ques
c_cond
l_int|132
suffix:colon
l_int|80
)paren
suffix:semicolon
multiline_comment|/* this alone does not suffice; some user mode&n;&t;&t;&t;&t;   utility has to change the hardware regs */
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Inverted screen on/off */
r_if
c_cond
(paren
id|decscnm
op_ne
id|on_off
)paren
(brace
id|decscnm
op_assign
id|on_off
suffix:semicolon
id|invert_screen
c_func
(paren
id|currcons
comma
l_int|0
comma
id|screenbuf_size
comma
l_int|0
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Origin relative/absolute */
id|decom
op_assign
id|on_off
suffix:semicolon
id|gotoxay
c_func
(paren
id|currcons
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
multiline_comment|/* Autowrap on/off */
id|decawm
op_assign
id|on_off
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* Autorepeat on/off */
r_if
c_cond
(paren
id|on_off
)paren
id|set_kbd
c_func
(paren
id|decarm
)paren
suffix:semicolon
r_else
id|clr_kbd
c_func
(paren
id|decarm
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|report_mouse
op_assign
id|on_off
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
multiline_comment|/* Cursor on/off */
id|deccm
op_assign
id|on_off
suffix:semicolon
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1000
suffix:colon
id|report_mouse
op_assign
id|on_off
ques
c_cond
l_int|2
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|par
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* ANSI modes set/reset */
r_case
l_int|3
suffix:colon
multiline_comment|/* Monitor (display ctrls) */
id|disp_ctrl
op_assign
id|on_off
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Insert Mode on/off */
id|decim
op_assign
id|on_off
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|20
suffix:colon
multiline_comment|/* Lf, Enter == CrLf/Lf */
r_if
c_cond
(paren
id|on_off
)paren
id|set_kbd
c_func
(paren
id|lnm
)paren
suffix:semicolon
r_else
id|clr_kbd
c_func
(paren
id|lnm
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|setterm_command
r_static
r_void
id|setterm_command
c_func
(paren
r_int
id|currcons
)paren
(brace
r_switch
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* set color for underline mode */
r_if
c_cond
(paren
id|can_do_color
op_logical_and
id|par
(braket
l_int|1
)braket
OL
l_int|16
)paren
(brace
id|ulcolor
op_assign
id|color_table
(braket
id|par
(braket
l_int|1
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|underline
)paren
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* set color for half intensity mode */
r_if
c_cond
(paren
id|can_do_color
op_logical_and
id|par
(braket
l_int|1
)braket
OL
l_int|16
)paren
(brace
id|halfcolor
op_assign
id|color_table
(braket
id|par
(braket
l_int|1
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intensity
op_eq
l_int|0
)paren
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* store colors as defaults */
id|def_color
op_assign
id|attr
suffix:semicolon
id|default_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
multiline_comment|/* set blanking interval */
id|blankinterval
op_assign
(paren
(paren
id|par
(braket
l_int|1
)braket
OL
l_int|60
)paren
ques
c_cond
id|par
(braket
l_int|1
)braket
suffix:colon
l_int|60
)paren
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
id|poke_blanked_console
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
multiline_comment|/* set bell frequency in Hz */
r_if
c_cond
(paren
id|npar
op_ge
l_int|1
)paren
id|bell_pitch
op_assign
id|par
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|bell_pitch
op_assign
id|DEFAULT_BELL_PITCH
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* set bell duration in msec */
r_if
c_cond
(paren
id|npar
op_ge
l_int|1
)paren
id|bell_duration
op_assign
(paren
id|par
(braket
l_int|1
)braket
OL
l_int|2000
)paren
ques
c_cond
id|par
(braket
l_int|1
)braket
op_star
id|HZ
op_div
l_int|1000
suffix:colon
l_int|0
suffix:semicolon
r_else
id|bell_duration
op_assign
id|DEFAULT_BELL_DURATION
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* bring specified console to the front */
r_if
c_cond
(paren
id|par
(braket
l_int|1
)braket
op_ge
l_int|1
op_logical_and
id|vc_cons_allocated
c_func
(paren
id|par
(braket
l_int|1
)braket
op_minus
l_int|1
)paren
)paren
id|update_screen
c_func
(paren
id|par
(braket
l_int|1
)braket
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
multiline_comment|/* unblank the screen */
id|unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* set vesa powerdown interval */
id|vesa_off_interval
op_assign
(paren
(paren
id|par
(braket
l_int|1
)braket
OL
l_int|60
)paren
ques
c_cond
id|par
(braket
l_int|1
)braket
suffix:colon
l_int|60
)paren
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|insert_char
r_static
r_inline
r_void
id|insert_char
c_func
(paren
r_int
id|currcons
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|p
op_assign
id|pos
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|cols
op_minus
id|x
op_minus
l_int|2
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|p
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|p
(braket
id|i
)braket
suffix:semicolon
op_star
id|pos
op_assign
id|video_erase_char
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_return
suffix:semicolon
multiline_comment|/* Arno:&n;&t; * Move the remainder of the line (-1 character) one spot to the right&n;&t; */
id|sw
op_member_access_from_pointer
id|con_bmove
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
id|x
comma
id|y
comma
id|x
op_plus
l_int|1
comma
l_int|1
comma
(paren
id|cols
op_minus
id|x
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Print the erase char on the current position&n;&t; */
id|sw
op_member_access_from_pointer
id|con_putc
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
(paren
id|video_erase_char
op_amp
l_int|0x00ff
)paren
comma
id|y
comma
id|x
)paren
suffix:semicolon
)brace
DECL|function|csi_at
r_static
r_void
id|csi_at
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|cols
op_minus
id|x
)paren
id|nr
op_assign
id|cols
op_minus
id|x
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
id|p
op_assign
id|pos
op_plus
id|cols
op_minus
id|x
op_minus
id|nr
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|p
op_ge
id|pos
)paren
id|p
(braket
id|nr
)braket
op_assign
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
op_star
op_increment
id|p
op_assign
id|video_erase_char
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_return
suffix:semicolon
id|sw-&gt;con_bmove
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
id|x
comma
id|y
comma
id|x
op_plus
id|nr
comma
l_int|1
comma
id|cols
op_minus
id|x
op_minus
id|nr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_decrement
)paren
id|sw-&gt;con_putc
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|video_erase_char
op_amp
l_int|0x00ff
comma
id|y
comma
id|x
op_plus
id|nr
)paren
suffix:semicolon
)brace
DECL|function|csi_L
r_static
r_void
id|csi_L
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
OG
id|rows
)paren
id|nr
op_assign
id|rows
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
id|scrdown
(paren
id|currcons
comma
id|y
comma
id|bottom
comma
id|nr
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|csi_P
r_static
r_void
id|csi_P
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|p
comma
op_star
id|end
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|cols
op_minus
id|x
)paren
id|nr
op_assign
id|cols
op_minus
id|x
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
id|p
op_assign
id|pos
suffix:semicolon
id|end
op_assign
id|pos
op_plus
id|cols
op_minus
id|x
op_minus
id|nr
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
)paren
op_star
id|p
op_assign
id|p
(braket
id|nr
)braket
comma
id|p
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
op_star
id|p
op_increment
op_assign
id|video_erase_char
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
)paren
r_return
suffix:semicolon
id|sw-&gt;con_bmove
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|y
comma
id|x
op_plus
id|nr
comma
id|y
comma
id|x
comma
l_int|1
comma
id|cols
op_minus
id|x
op_minus
id|nr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_decrement
)paren
id|sw-&gt;con_putc
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|video_erase_char
op_amp
l_int|0x00ff
comma
id|y
comma
id|cols
op_minus
l_int|1
op_minus
id|nr
)paren
suffix:semicolon
)brace
DECL|function|csi_M
r_static
r_void
id|csi_M
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
OG
id|rows
)paren
id|nr
op_assign
id|rows
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
id|scrup
(paren
id|currcons
comma
id|y
comma
id|bottom
comma
id|nr
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|save_cur
r_static
r_void
id|save_cur
c_func
(paren
r_int
id|currcons
)paren
(brace
id|saved_x
op_assign
id|x
suffix:semicolon
id|saved_y
op_assign
id|y
suffix:semicolon
id|s_intensity
op_assign
id|intensity
suffix:semicolon
id|s_underline
op_assign
id|underline
suffix:semicolon
id|s_blink
op_assign
id|blink
suffix:semicolon
id|s_reverse
op_assign
id|reverse
suffix:semicolon
id|s_charset
op_assign
id|charset
suffix:semicolon
id|s_color
op_assign
id|color
suffix:semicolon
id|saved_G0
op_assign
id|G0_charset
suffix:semicolon
id|saved_G1
op_assign
id|G1_charset
suffix:semicolon
)brace
DECL|function|restore_cur
r_static
r_void
id|restore_cur
c_func
(paren
r_int
id|currcons
)paren
(brace
id|gotoxy
c_func
(paren
id|currcons
comma
id|saved_x
comma
id|saved_y
)paren
suffix:semicolon
id|intensity
op_assign
id|s_intensity
suffix:semicolon
id|underline
op_assign
id|s_underline
suffix:semicolon
id|blink
op_assign
id|s_blink
suffix:semicolon
id|reverse
op_assign
id|s_reverse
suffix:semicolon
id|charset
op_assign
id|s_charset
suffix:semicolon
id|color
op_assign
id|s_color
suffix:semicolon
id|G0_charset
op_assign
id|saved_G0
suffix:semicolon
id|G1_charset
op_assign
id|saved_G1
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|charset
ques
c_cond
id|G1_charset
suffix:colon
id|G0_charset
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|enumerator|ESnormal
DECL|enumerator|ESesc
DECL|enumerator|ESsquare
DECL|enumerator|ESgetpars
DECL|enumerator|ESgotpars
DECL|enumerator|ESfunckey
r_enum
(brace
id|ESnormal
comma
id|ESesc
comma
id|ESsquare
comma
id|ESgetpars
comma
id|ESgotpars
comma
id|ESfunckey
comma
DECL|enumerator|EShash
DECL|enumerator|ESsetG0
DECL|enumerator|ESsetG1
DECL|enumerator|ESpercent
DECL|enumerator|ESignore
DECL|enumerator|ESnonstd
id|EShash
comma
id|ESsetG0
comma
id|ESsetG1
comma
id|ESpercent
comma
id|ESignore
comma
id|ESnonstd
comma
DECL|enumerator|ESpalette
id|ESpalette
)brace
suffix:semicolon
DECL|function|reset_terminal
r_static
r_void
id|reset_terminal
c_func
(paren
r_int
id|currcons
comma
r_int
id|do_clear
)paren
(brace
id|top
op_assign
l_int|0
suffix:semicolon
id|bottom
op_assign
id|rows
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
id|ques
op_assign
l_int|0
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|LAT1_MAP
)paren
suffix:semicolon
id|G0_charset
op_assign
id|LAT1_MAP
suffix:semicolon
id|G1_charset
op_assign
id|GRAF_MAP
suffix:semicolon
id|charset
op_assign
l_int|0
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
id|report_mouse
op_assign
l_int|0
suffix:semicolon
id|utf
op_assign
l_int|0
suffix:semicolon
id|utf_count
op_assign
l_int|0
suffix:semicolon
id|disp_ctrl
op_assign
l_int|0
suffix:semicolon
id|toggle_meta
op_assign
l_int|0
suffix:semicolon
id|decscnm
op_assign
l_int|0
suffix:semicolon
id|decom
op_assign
l_int|0
suffix:semicolon
id|decawm
op_assign
l_int|1
suffix:semicolon
id|deccm
op_assign
l_int|1
suffix:semicolon
id|decim
op_assign
l_int|0
suffix:semicolon
id|set_kbd
c_func
(paren
id|decarm
)paren
suffix:semicolon
id|clr_kbd
c_func
(paren
id|decckm
)paren
suffix:semicolon
id|clr_kbd
c_func
(paren
id|kbdapplic
)paren
suffix:semicolon
id|clr_kbd
c_func
(paren
id|lnm
)paren
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|lockstate
op_assign
l_int|0
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|slockstate
op_assign
l_int|0
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|ledflagstate
op_assign
id|kbd_table
(braket
id|currcons
)braket
dot
id|default_ledflagstate
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
id|default_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|tab_stop
(braket
l_int|0
)braket
op_assign
l_int|0x01010100
suffix:semicolon
id|tab_stop
(braket
l_int|1
)braket
op_assign
id|tab_stop
(braket
l_int|2
)braket
op_assign
id|tab_stop
(braket
l_int|3
)braket
op_assign
id|tab_stop
(braket
l_int|4
)braket
op_assign
l_int|0x01010101
suffix:semicolon
id|bell_pitch
op_assign
id|DEFAULT_BELL_PITCH
suffix:semicolon
id|bell_duration
op_assign
id|DEFAULT_BELL_DURATION
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_clear
)paren
id|csi_J
c_func
(paren
id|currcons
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Turn the Scroll-Lock LED on when the tty is stopped&n; */
DECL|function|con_stop
r_static
r_void
id|con_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|console_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|console_num
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
(paren
id|tty-&gt;driver.minor_start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|console_num
)paren
)paren
r_return
suffix:semicolon
id|set_vc_kbd_led
c_func
(paren
id|kbd_table
op_plus
id|console_num
comma
id|VC_SCROLLOCK
)paren
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Turn the Scroll-Lock LED off when the console is started&n; */
DECL|function|con_start
r_static
r_void
id|con_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|console_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|console_num
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
(paren
id|tty-&gt;driver.minor_start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|console_num
)paren
)paren
r_return
suffix:semicolon
id|clr_vc_kbd_led
c_func
(paren
id|kbd_table
op_plus
id|console_num
comma
id|VC_SCROLLOCK
)paren
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|con_flush_chars
r_static
r_void
id|con_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|currcons
suffix:semicolon
r_struct
id|vt_struct
op_star
id|vt
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|currcons
op_assign
id|vt-&gt;vc_num
suffix:semicolon
r_if
c_cond
(paren
id|vcmode
op_ne
id|KD_GRAPHICS
)paren
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|do_con_write
r_static
r_int
id|do_con_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
comma
id|tc
comma
id|ok
comma
id|n
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|currcons
suffix:semicolon
r_struct
id|vt_struct
op_star
id|vt
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|currcons
op_assign
id|vt-&gt;vc_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
(brace
multiline_comment|/* could this happen? */
r_static
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;con_write: tty %d not allocated&bslash;n&quot;
comma
id|currcons
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* undraw cursor first */
r_if
c_cond
(paren
id|currcons
op_eq
id|fg_console
)paren
id|hide_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
multiline_comment|/* clear the selection */
r_if
c_cond
(paren
id|currcons
op_eq
id|sel_cons
)paren
id|clear_selection
c_func
(paren
)paren
suffix:semicolon
id|disable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|enable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|get_user
c_func
(paren
id|c
comma
id|buf
)paren
suffix:semicolon
r_else
id|c
op_assign
op_star
id|buf
suffix:semicolon
id|buf
op_increment
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|disable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|utf
)paren
(brace
multiline_comment|/* Combine UTF-8 into Unicode */
multiline_comment|/* Incomplete characters silently ignored */
r_if
c_cond
(paren
id|c
OG
l_int|0x7f
)paren
(brace
r_if
c_cond
(paren
id|utf_count
OG
l_int|0
op_logical_and
(paren
id|c
op_amp
l_int|0xc0
)paren
op_eq
l_int|0x80
)paren
(brace
id|utf_char
op_assign
(paren
id|utf_char
op_lshift
l_int|6
)paren
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|utf_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|utf_count
op_eq
l_int|0
)paren
id|tc
op_assign
id|c
op_assign
id|utf_char
suffix:semicolon
r_else
r_continue
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xe0
)paren
op_eq
l_int|0xc0
)paren
(brace
id|utf_count
op_assign
l_int|1
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x1f
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xf0
)paren
op_eq
l_int|0xe0
)paren
(brace
id|utf_count
op_assign
l_int|2
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xf8
)paren
op_eq
l_int|0xf0
)paren
(brace
id|utf_count
op_assign
l_int|3
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xfc
)paren
op_eq
l_int|0xf8
)paren
(brace
id|utf_count
op_assign
l_int|4
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x03
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xfe
)paren
op_eq
l_int|0xfc
)paren
(brace
id|utf_count
op_assign
l_int|5
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
r_else
id|utf_count
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|tc
op_assign
id|c
suffix:semicolon
id|utf_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no utf */
id|tc
op_assign
id|translate
(braket
id|toggle_meta
ques
c_cond
(paren
id|c
op_or
l_int|0x80
)paren
suffix:colon
id|c
)braket
suffix:semicolon
)brace
multiline_comment|/* If the original code was a control character we&n;                 * only allow a glyph to be displayed if the code is&n;                 * not normally used (such as for cursor movement) or&n;                 * if the disp_ctrl mode has been explicitly enabled.&n;                 * Certain characters (as given by the CTRL_ALWAYS&n;                 * bitmap) are always displayed as control characters,&n;                 * as the console would be pretty useless without&n;                 * them; to display an arbitrary font position use the&n;                 * direct-to-font zone in UTF-8 mode.&n;                 */
id|ok
op_assign
id|tc
op_logical_and
(paren
id|c
op_ge
l_int|32
op_logical_or
(paren
op_logical_neg
id|utf
op_logical_and
op_logical_neg
(paren
(paren
(paren
id|disp_ctrl
ques
c_cond
id|CTRL_ALWAYS
suffix:colon
id|CTRL_ACTION
)paren
op_rshift
id|c
)paren
op_amp
l_int|1
)paren
)paren
)paren
op_logical_and
(paren
id|c
op_ne
l_int|127
op_logical_or
id|disp_ctrl
)paren
op_logical_and
(paren
id|c
op_ne
l_int|128
op_plus
l_int|27
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc_state
op_eq
id|ESnormal
op_logical_and
id|ok
)paren
(brace
multiline_comment|/* Now try to find out how to display it */
id|tc
op_assign
id|conv_uni_to_pc
c_func
(paren
id|tc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_eq
op_minus
l_int|4
)paren
(brace
multiline_comment|/* If we got -4 (not found) then see if we have&n;                                   defined a replacement character (U+FFFD) */
id|tc
op_assign
id|conv_uni_to_pc
c_func
(paren
l_int|0xfffd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tc
op_eq
op_minus
l_int|3
)paren
(brace
multiline_comment|/* Bad hash table -- hope for the best */
id|tc
op_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tc
op_amp
op_complement
id|console_charmask
)paren
r_continue
suffix:semicolon
multiline_comment|/* Conversion failed */
r_if
c_cond
(paren
id|need_wrap
)paren
(brace
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
macro_line|#if 1 /* XXX */
multiline_comment|/* DPC: 1994-04-12&n;                         *   Speed up overstrike mode, using new putcs.&n;                         *&n;                         * P.S. I hate 8 spaces per tab! Use Emacs!&n;&t;&t;&t; */
multiline_comment|/* Only use this for the foreground console,&n;                           where we really draw the chars */
r_if
c_cond
(paren
id|count
OG
l_int|2
op_logical_and
op_logical_neg
id|decim
op_logical_and
op_logical_neg
id|utf
op_logical_and
id|currcons
op_eq
id|fg_console
)paren
(brace
r_static
r_char
id|putcs_buf
(braket
l_int|256
)braket
suffix:semicolon
r_char
op_star
id|p
op_assign
id|putcs_buf
suffix:semicolon
r_int
id|putcs_count
op_assign
l_int|1
suffix:semicolon
id|ushort
id|nextx
op_assign
id|x
op_plus
l_int|1
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|tc
suffix:semicolon
op_star
id|pos
op_increment
op_assign
id|tc
op_or
(paren
id|attr
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextx
op_eq
id|cols
)paren
(brace
id|sw
op_member_access_from_pointer
id|con_putc
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
op_star
id|putcs_buf
comma
id|y
comma
id|x
)paren
suffix:semicolon
id|pos
op_decrement
suffix:semicolon
id|need_wrap
op_assign
id|decawm
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* TAB TAB TAB - Arghh!!!! */
r_while
c_loop
(paren
id|count
)paren
(brace
id|enable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|get_user
c_func
(paren
id|c
comma
id|buf
)paren
suffix:semicolon
r_else
id|c
op_assign
op_star
id|buf
suffix:semicolon
id|disable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
id|tc
op_assign
id|translate
(braket
id|toggle_meta
ques
c_cond
(paren
id|c
op_or
l_int|0x80
)paren
suffix:colon
id|c
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tc
op_logical_or
op_logical_neg
(paren
id|c
op_ge
l_int|32
op_logical_or
op_logical_neg
(paren
(paren
(paren
id|disp_ctrl
ques
c_cond
id|CTRL_ALWAYS
suffix:colon
id|CTRL_ACTION
)paren
op_rshift
id|c
)paren
op_amp
l_int|1
)paren
)paren
)paren
r_break
suffix:semicolon
id|tc
op_assign
id|conv_uni_to_pc
c_func
(paren
id|tc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_eq
op_minus
l_int|4
)paren
id|tc
op_assign
id|conv_uni_to_pc
c_func
(paren
l_int|0xfffd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tc
op_eq
op_minus
l_int|3
)paren
id|tc
op_assign
id|c
suffix:semicolon
id|buf
op_increment
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_amp
op_complement
id|console_charmask
)paren
r_continue
suffix:semicolon
multiline_comment|/* Conversion failed */
op_star
id|p
op_increment
op_assign
id|tc
suffix:semicolon
op_star
id|pos
op_increment
op_assign
id|tc
op_or
(paren
id|attr
op_lshift
l_int|8
)paren
suffix:semicolon
op_increment
id|putcs_count
suffix:semicolon
op_increment
id|nextx
suffix:semicolon
r_if
c_cond
(paren
id|nextx
op_eq
id|cols
op_logical_or
id|putcs_count
op_eq
r_sizeof
(paren
id|putcs_buf
)paren
)paren
r_break
suffix:semicolon
)brace
id|sw
op_member_access_from_pointer
id|con_putcs
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|putcs_buf
comma
id|putcs_count
comma
id|y
comma
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextx
op_eq
id|cols
)paren
(brace
id|pos
op_decrement
suffix:semicolon
id|x
op_assign
id|cols
op_minus
l_int|1
suffix:semicolon
id|need_wrap
op_assign
id|decawm
suffix:semicolon
)brace
r_else
id|x
op_add_assign
id|putcs_count
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* DPC: End of putcs support */
macro_line|#endif
r_if
c_cond
(paren
id|decim
)paren
id|insert_char
c_func
(paren
id|currcons
)paren
suffix:semicolon
op_star
id|pos
op_assign
(paren
id|attr
op_lshift
l_int|8
)paren
op_plus
id|tc
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_eq
id|fg_console
)paren
id|sw
op_member_access_from_pointer
id|con_putc
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|tc
comma
id|y
comma
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
id|cols
op_minus
l_int|1
)paren
id|need_wrap
op_assign
id|decawm
suffix:semicolon
r_else
(brace
id|pos
op_increment
suffix:semicolon
id|x
op_increment
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Control characters can be used in the _middle_&n;&t;&t; *  of an escape sequence.&n;&t;&t; */
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_int|0
suffix:colon
r_continue
suffix:semicolon
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
id|bell_duration
)paren
id|kd_mksound
c_func
(paren
id|bell_pitch
comma
id|bell_duration
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|8
suffix:colon
id|bs
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|9
suffix:colon
id|pos
op_sub_assign
id|x
suffix:semicolon
r_while
c_loop
(paren
id|x
OL
id|cols
op_minus
l_int|1
)paren
(brace
id|x
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tab_stop
(braket
id|x
op_rshift
l_int|5
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|x
op_amp
l_int|31
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|pos
op_add_assign
id|x
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|10
suffix:colon
r_case
l_int|11
suffix:colon
r_case
l_int|12
suffix:colon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_kbd
c_func
(paren
id|lnm
)paren
)paren
r_continue
suffix:semicolon
r_case
l_int|13
suffix:colon
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|14
suffix:colon
id|charset
op_assign
l_int|1
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|G1_charset
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|15
suffix:colon
id|charset
op_assign
l_int|0
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|G0_charset
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|24
suffix:colon
r_case
l_int|26
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|27
suffix:colon
id|vc_state
op_assign
id|ESesc
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|127
suffix:colon
id|del
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|128
op_plus
l_int|27
suffix:colon
id|vc_state
op_assign
id|ESsquare
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|vc_state
)paren
(brace
r_case
id|ESesc
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;[&squot;
suffix:colon
id|vc_state
op_assign
id|ESsquare
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
id|vc_state
op_assign
id|ESnonstd
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;%&squot;
suffix:colon
id|vc_state
op_assign
id|ESpercent
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;E&squot;
suffix:colon
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|ri
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
id|tab_stop
(braket
id|x
op_rshift
l_int|5
)braket
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|x
op_amp
l_int|31
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;Z&squot;
suffix:colon
id|respond_ID
c_func
(paren
id|tty
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;7&squot;
suffix:colon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;8&squot;
suffix:colon
id|restore_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;(&squot;
suffix:colon
id|vc_state
op_assign
id|ESsetG0
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;)&squot;
suffix:colon
id|vc_state
op_assign
id|ESsetG1
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;#&squot;
suffix:colon
id|vc_state
op_assign
id|EShash
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
id|reset_terminal
c_func
(paren
id|currcons
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
multiline_comment|/* Numeric keypad */
id|clr_kbd
c_func
(paren
id|kbdapplic
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;=&squot;
suffix:colon
multiline_comment|/* Appl. keypad */
id|set_kbd
c_func
(paren
id|kbdapplic
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESnonstd
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;P&squot;
)paren
(brace
multiline_comment|/* palette escape sequence */
r_for
c_loop
(paren
id|npar
op_assign
l_int|0
suffix:semicolon
id|npar
OL
id|NPAR
suffix:semicolon
id|npar
op_increment
)paren
id|par
(braket
id|npar
)braket
op_assign
l_int|0
suffix:semicolon
id|npar
op_assign
l_int|0
suffix:semicolon
id|vc_state
op_assign
id|ESpalette
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;R&squot;
)paren
(brace
multiline_comment|/* reset palette */
macro_line|#if 0
id|reset_palette
(paren
id|currcons
)paren
suffix:semicolon
macro_line|#endif
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
)brace
r_else
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|ESpalette
suffix:colon
r_if
c_cond
(paren
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
op_logical_or
(paren
id|c
op_ge
l_char|&squot;A&squot;
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
op_logical_or
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
)paren
(brace
id|par
(braket
id|npar
op_increment
)braket
op_assign
(paren
id|c
OG
l_char|&squot;9&squot;
ques
c_cond
(paren
id|c
op_amp
l_int|0xDF
)paren
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:colon
id|c
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|npar
op_eq
l_int|7
)paren
(brace
macro_line|#if 0
r_int
id|i
op_assign
id|par
(braket
l_int|0
)braket
op_star
l_int|3
comma
id|j
op_assign
l_int|1
suffix:semicolon
id|palette
(braket
id|i
)braket
op_assign
l_int|16
op_star
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
op_increment
)braket
op_add_assign
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
)braket
op_assign
l_int|16
op_star
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
op_increment
)braket
op_add_assign
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
)braket
op_assign
l_int|16
op_star
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
)braket
op_add_assign
id|par
(braket
id|j
)braket
suffix:semicolon
id|set_palette
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
)brace
)brace
r_else
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|ESsquare
suffix:colon
r_for
c_loop
(paren
id|npar
op_assign
l_int|0
suffix:semicolon
id|npar
OL
id|NPAR
suffix:semicolon
id|npar
op_increment
)paren
(brace
id|par
(braket
id|npar
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|npar
op_assign
l_int|0
suffix:semicolon
id|vc_state
op_assign
id|ESgetpars
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;[&squot;
)paren
(brace
multiline_comment|/* Function key */
id|vc_state
op_assign
id|ESfunckey
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ques
op_assign
(paren
id|c
op_eq
l_char|&squot;?&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ques
)paren
r_continue
suffix:semicolon
r_case
id|ESgetpars
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;;&squot;
op_logical_and
id|npar
OL
id|NPAR
op_minus
l_int|1
)paren
(brace
id|npar
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
(brace
id|par
(braket
id|npar
)braket
op_mul_assign
l_int|10
suffix:semicolon
id|par
(braket
id|npar
)braket
op_add_assign
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|vc_state
op_assign
id|ESgotpars
suffix:semicolon
r_case
id|ESgotpars
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;h&squot;
suffix:colon
id|set_mode
c_func
(paren
id|currcons
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|set_mode
c_func
(paren
id|currcons
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ques
)paren
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
op_eq
l_int|5
)paren
id|status_report
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
op_eq
l_int|6
)paren
id|cursor_report
c_func
(paren
id|currcons
comma
id|tty
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ques
)paren
(brace
id|ques
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;G&squot;
suffix:colon
r_case
l_char|&squot;`&squot;
suffix:colon
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_decrement
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
comma
id|y
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;A&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|y
op_minus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
r_case
l_char|&squot;e&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|y
op_plus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
r_case
l_char|&squot;a&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
op_plus
id|par
(braket
l_int|0
)braket
comma
id|y
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
op_minus
id|par
(braket
l_int|0
)braket
comma
id|y
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;E&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
id|y
op_plus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
id|y
op_minus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_decrement
suffix:semicolon
id|gotoxay
c_func
(paren
id|currcons
comma
id|x
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
r_case
l_char|&squot;f&squot;
suffix:colon
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|par
(braket
l_int|1
)braket
)paren
id|par
(braket
l_int|1
)braket
op_decrement
suffix:semicolon
id|gotoxay
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|1
)braket
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;J&squot;
suffix:colon
id|csi_J
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;K&squot;
suffix:colon
id|csi_K
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
id|csi_L
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|csi_M
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;P&squot;
suffix:colon
id|csi_P
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|respond_ID
c_func
(paren
id|tty
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;g&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|tab_stop
(braket
id|x
op_rshift
l_int|5
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|x
op_amp
l_int|31
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
op_eq
l_int|3
)paren
(brace
id|tab_stop
(braket
l_int|0
)braket
op_assign
id|tab_stop
(braket
l_int|1
)braket
op_assign
id|tab_stop
(braket
l_int|2
)braket
op_assign
id|tab_stop
(braket
l_int|3
)braket
op_assign
id|tab_stop
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|csi_m
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
multiline_comment|/* DECLL - but only 3 leds */
multiline_comment|/* map 0,1,2,3 to 0,1,2,4 */
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
OL
l_int|4
)paren
id|setledstate
c_func
(paren
id|kbd_table
op_plus
id|currcons
comma
(paren
id|par
(braket
l_int|0
)braket
OL
l_int|3
)paren
ques
c_cond
id|par
(braket
l_int|0
)braket
suffix:colon
l_int|4
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|1
)braket
)paren
id|par
(braket
l_int|1
)braket
op_assign
id|rows
suffix:semicolon
multiline_comment|/* Minimum allowed region is 2 lines */
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
OL
id|par
(braket
l_int|1
)braket
op_logical_and
id|par
(braket
l_int|1
)braket
op_le
id|rows
)paren
(brace
id|top
op_assign
id|par
(braket
l_int|0
)braket
op_minus
l_int|1
suffix:semicolon
id|bottom
op_assign
id|par
(braket
l_int|1
)braket
suffix:semicolon
id|gotoxay
c_func
(paren
id|currcons
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|restore_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
id|csi_X
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;@&squot;
suffix:colon
id|csi_at
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
multiline_comment|/* setterm functions */
id|setterm_command
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESpercent
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;@&squot;
suffix:colon
multiline_comment|/* defined in ISO 2022 */
id|utf
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;G&squot;
suffix:colon
multiline_comment|/* prelim official escape code */
r_case
l_char|&squot;8&squot;
suffix:colon
multiline_comment|/* retained for compatibility */
id|utf
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESfunckey
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|EShash
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;8&squot;
)paren
(brace
multiline_comment|/* DEC screen alignment test. kludge :-) */
id|video_erase_char
op_assign
(paren
id|video_erase_char
op_amp
l_int|0xff00
)paren
op_or
l_char|&squot;E&squot;
suffix:semicolon
multiline_comment|/* Arno:&n;&t;&t;&t;&t; * Doesn&squot;t work, because csi_J(c,2)&n;&t;&t;&t;&t; * calls con_clear and doesn&squot;t print&n;&t;&t;&t;&t; * the erase char..&n;&t;&t;&t;&t; */
id|csi_J
c_func
(paren
id|currcons
comma
l_int|2
)paren
suffix:semicolon
id|video_erase_char
op_assign
(paren
id|video_erase_char
op_amp
l_int|0xff00
)paren
op_or
l_char|&squot; &squot;
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESsetG0
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
id|G0_charset
op_assign
id|GRAF_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;B&squot;
)paren
id|G0_charset
op_assign
id|LAT1_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;U&squot;
)paren
id|G0_charset
op_assign
id|IBMPC_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;K&squot;
)paren
id|G0_charset
op_assign
id|USER_MAP
suffix:semicolon
r_if
c_cond
(paren
id|charset
op_eq
l_int|0
)paren
id|translate
op_assign
id|set_translate
c_func
(paren
id|G0_charset
)paren
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|ESsetG1
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
id|G1_charset
op_assign
id|GRAF_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;B&squot;
)paren
id|G1_charset
op_assign
id|LAT1_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;U&squot;
)paren
id|G1_charset
op_assign
id|IBMPC_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;K&squot;
)paren
id|G1_charset
op_assign
id|USER_MAP
suffix:semicolon
r_if
c_cond
(paren
id|charset
op_eq
l_int|1
)paren
id|translate
op_assign
id|set_translate
c_func
(paren
id|G1_charset
)paren
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
)brace
)brace
id|enable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|con_write
r_static
r_int
id|con_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|do_con_write
c_func
(paren
id|tty
comma
id|from_user
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|con_flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|con_put_char
r_static
r_void
id|con_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
id|do_con_write
c_func
(paren
id|tty
comma
l_int|0
comma
op_amp
id|ch
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|con_write_room
r_static
r_int
id|con_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|4096
suffix:semicolon
multiline_comment|/* No limit, really; we&squot;re not buffering */
)brace
DECL|function|con_chars_in_buffer
r_static
r_int
id|con_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we&squot;re not buffering */
)brace
DECL|function|poke_blanked_console
r_void
id|poke_blanked_console
c_func
(paren
r_void
)paren
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_GRAPHICS
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|console_blanked
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|unblank_screen
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|blankinterval
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|blankinterval
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
)brace
multiline_comment|/* DPC: New version of console_print using putcs */
DECL|function|console_print
r_void
id|console_print
c_func
(paren
r_const
r_char
op_star
id|b
)paren
(brace
r_int
id|currcons
op_assign
id|fg_console
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_const
r_char
op_star
id|start
op_assign
id|b
suffix:semicolon
id|ushort
id|count
op_assign
l_int|0
suffix:semicolon
id|ushort
id|myx
op_assign
id|x
suffix:semicolon
r_static
r_int
id|printing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|printable
op_logical_or
id|printing
)paren
r_return
suffix:semicolon
multiline_comment|/* console not yet initialized */
id|printing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|kmsg_redirect
op_logical_and
id|vc_cons_allocated
c_func
(paren
id|kmsg_redirect
op_minus
l_int|1
)paren
)paren
id|currcons
op_assign
id|kmsg_redirect
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
(brace
multiline_comment|/* impossible */
id|printk
c_func
(paren
l_string|&quot;console_print: tty %d not allocated ??&bslash;n&quot;
comma
id|currcons
op_plus
l_int|1
)paren
suffix:semicolon
id|printing
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* undraw cursor first */
id|hide_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
multiline_comment|/* Contrived structure to try to emulate original need_wrap behaviour&n;    * Problems caused when we have need_wrap set on &squot;&bslash;n&squot; character */
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
(paren
id|b
op_increment
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_int|10
op_logical_or
id|c
op_eq
l_int|13
op_logical_or
id|c
op_eq
l_int|8
op_logical_or
id|need_wrap
)paren
(brace
r_if
c_cond
(paren
(paren
id|count
op_assign
id|b
op_minus
id|start
op_minus
l_int|1
)paren
OG
l_int|0
)paren
(brace
id|sw
op_member_access_from_pointer
id|con_putcs
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|start
comma
id|count
comma
id|y
comma
id|x
)paren
suffix:semicolon
id|x
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|need_wrap
)paren
id|x
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_int|8
)paren
(brace
multiline_comment|/* backspace */
id|bs
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|start
op_assign
id|b
suffix:semicolon
id|myx
op_assign
id|x
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_ne
l_int|13
)paren
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|10
op_logical_or
id|c
op_eq
l_int|13
)paren
(brace
id|start
op_assign
id|b
suffix:semicolon
id|myx
op_assign
id|x
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|start
op_assign
id|b
op_minus
l_int|1
suffix:semicolon
id|myx
op_assign
id|x
suffix:semicolon
)brace
op_star
id|pos
op_assign
id|c
op_or
(paren
id|attr
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|myx
op_eq
id|cols
op_minus
l_int|1
)paren
(brace
id|need_wrap
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pos
op_increment
suffix:semicolon
id|myx
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|count
op_assign
id|b
op_minus
id|start
op_minus
l_int|1
)paren
OG
l_int|0
)paren
(brace
id|sw
op_member_access_from_pointer
id|con_putcs
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|start
comma
id|count
comma
id|y
comma
id|x
)paren
suffix:semicolon
id|x
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
id|cols
)paren
(brace
id|x
op_decrement
suffix:semicolon
id|need_wrap
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|poke_blanked_console
c_func
(paren
)paren
suffix:semicolon
id|printing
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * con_throttle and con_unthrottle are only used for&n; * paste_selection(), which has to stuff in a large number of&n; * characters...&n; */
DECL|function|con_throttle
r_static
r_void
id|con_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
)brace
DECL|function|con_unthrottle
r_static
r_void
id|con_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|vt_struct
op_star
id|vt
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|vt-&gt;paste_wait
)paren
suffix:semicolon
)brace
DECL|function|vc_init
r_static
r_void
id|vc_init
c_func
(paren
r_int
r_int
id|currcons
comma
r_int
id|do_clear
)paren
(brace
r_int
id|base
op_assign
(paren
r_int
)paren
id|vc_scrbuf
(braket
id|currcons
)braket
suffix:semicolon
id|pos
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|origin
op_assign
(paren
id|ulong
)paren
id|video_mem_start
op_assign
id|base
)paren
suffix:semicolon
id|scr_end
op_assign
id|base
op_plus
id|screenbuf_size
suffix:semicolon
id|video_mem_end
op_assign
id|base
op_plus
id|screenbuf_size
suffix:semicolon
id|reset_vc
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|def_color
op_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* white */
id|ulcolor
op_assign
l_int|0x0f
suffix:semicolon
multiline_comment|/* bold white */
id|halfcolor
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* grey */
id|vt_cons
(braket
id|currcons
)braket
op_member_access_from_pointer
id|paste_wait
op_assign
l_int|0
suffix:semicolon
id|reset_terminal
c_func
(paren
id|currcons
comma
id|do_clear
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the console switching bottom half handler.&n; *&n; * Doing console switching in a bottom half handler allows&n; * us to do the switches asynchronously (needed when we want&n; * to switch due to a keyboard interrupt), while still giving&n; * us the option to easily disable it to avoid races when we&n; * need to write to the console.&n; */
DECL|function|console_bh
r_static
r_void
id|console_bh
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|want_console
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|want_console
op_ne
id|fg_console
)paren
(brace
id|change_console
c_func
(paren
id|want_console
)paren
suffix:semicolon
multiline_comment|/* we only changed when the console had already&n;&t;&t;&t;   been allocated - a new console is not created&n;&t;&t;&t;   in an interrupt routine */
)brace
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_poke_blanked_console
)paren
(brace
multiline_comment|/* do not unblank for a LED change */
id|do_poke_blanked_console
op_assign
l_int|0
suffix:semicolon
id|poke_blanked_console
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  unsigned long con_init(unsigned long);&n; *&n; * This routine initializes console interrupts, and does nothing&n; * else. If you want the screen to clear, call tty_write with&n; * the appropriate escape-sequence.&n; *&n; * Reads the information preserved by setup.s to determine the current display&n; * type and sets everything accordingly.&n; */
DECL|function|con_init
r_int
r_int
id|con_init
c_func
(paren
r_int
r_int
id|kmem_start
)paren
(brace
r_char
op_star
id|display_desc
op_assign
l_string|&quot;????&quot;
suffix:semicolon
r_int
r_int
id|currcons
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|serial_debug
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|console_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|console_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|console_driver.name
op_assign
l_string|&quot;tty&quot;
suffix:semicolon
id|console_driver.name_base
op_assign
l_int|1
suffix:semicolon
id|console_driver.major
op_assign
id|TTY_MAJOR
suffix:semicolon
id|console_driver.minor_start
op_assign
l_int|1
suffix:semicolon
id|console_driver.num
op_assign
id|MAX_NR_CONSOLES
suffix:semicolon
id|console_driver.type
op_assign
id|TTY_DRIVER_TYPE_CONSOLE
suffix:semicolon
id|console_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|console_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
op_or
id|TTY_DRIVER_RESET_TERMIOS
suffix:semicolon
id|console_driver.refcount
op_assign
op_amp
id|console_refcount
suffix:semicolon
id|console_driver.table
op_assign
id|console_table
suffix:semicolon
id|console_driver.termios
op_assign
id|console_termios
suffix:semicolon
id|console_driver.termios_locked
op_assign
id|console_termios_locked
suffix:semicolon
id|console_driver.open
op_assign
id|con_open
suffix:semicolon
id|console_driver.write
op_assign
id|con_write
suffix:semicolon
id|console_driver.write_room
op_assign
id|con_write_room
suffix:semicolon
id|console_driver.put_char
op_assign
id|con_put_char
suffix:semicolon
id|console_driver.flush_chars
op_assign
id|con_flush_chars
suffix:semicolon
id|console_driver.chars_in_buffer
op_assign
id|con_chars_in_buffer
suffix:semicolon
id|console_driver.ioctl
op_assign
id|vt_ioctl
suffix:semicolon
id|console_driver.stop
op_assign
id|con_stop
suffix:semicolon
id|console_driver.start
op_assign
id|con_start
suffix:semicolon
id|console_driver.throttle
op_assign
id|con_throttle
suffix:semicolon
id|console_driver.unthrottle
op_assign
id|con_unthrottle
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|console_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register console driver&bslash;n&quot;
)paren
suffix:semicolon
id|kmem_start
op_assign
id|conswitchp-&gt;con_startup
(paren
id|kmem_start
comma
op_amp
id|display_desc
)paren
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|blank_screen
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blankinterval
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|blankinterval
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
multiline_comment|/* Due to kmalloc roundup allocating statically is more efficient -&n;&t;   so provide MIN_NR_CONSOLES for people with very little memory */
r_for
c_loop
(paren
id|currcons
op_assign
l_int|0
suffix:semicolon
id|currcons
OL
id|MIN_NR_CONSOLES
suffix:semicolon
id|currcons
op_increment
)paren
(brace
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
op_assign
(paren
r_struct
id|vc_data
op_star
)paren
id|kmem_start
suffix:semicolon
id|kmem_start
op_add_assign
r_sizeof
(paren
r_struct
id|vc_data
)paren
suffix:semicolon
id|vt_cons
(braket
id|currcons
)braket
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|kmem_start
suffix:semicolon
id|kmem_start
op_add_assign
r_sizeof
(paren
r_struct
id|vt_struct
)paren
suffix:semicolon
multiline_comment|/* ++Geert: sw-&gt;con_init determines console size */
id|sw
op_assign
id|conswitchp
suffix:semicolon
id|cons_num
op_assign
id|currcons
suffix:semicolon
id|sw-&gt;con_init
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
)paren
suffix:semicolon
id|size_row
op_assign
id|cols
op_lshift
l_int|1
suffix:semicolon
id|screenbuf_size
op_assign
id|rows
op_star
id|size_row
suffix:semicolon
id|vc_scrbuf
(braket
id|currcons
)braket
op_assign
(paren
r_int
r_int
op_star
)paren
id|kmem_start
suffix:semicolon
id|kmem_start
op_add_assign
id|screenbuf_size
suffix:semicolon
id|kmalloced
op_assign
l_int|0
suffix:semicolon
id|vc_init
c_func
(paren
id|currcons
comma
id|currcons
)paren
suffix:semicolon
)brace
id|currcons
op_assign
id|fg_console
op_assign
l_int|0
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|csi_J
c_func
(paren
id|currcons
comma
l_int|0
)paren
suffix:semicolon
id|printable
op_assign
l_int|1
suffix:semicolon
id|update_screen
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_cursor
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|CM_DRAW
)paren
suffix:semicolon
id|printable
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If &quot;serdebug&quot; cmd line option was present, don&squot;t register for printk */
r_if
c_cond
(paren
op_logical_neg
id|serial_debug
)paren
id|register_console
c_func
(paren
id|console_print
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Console: %s %s %ldx%ld, %d virtual console%s (max %d)&bslash;n&quot;
comma
id|can_do_color
ques
c_cond
l_string|&quot;colour&quot;
suffix:colon
l_string|&quot;mono&quot;
comma
id|display_desc
comma
id|cols
comma
id|rows
comma
id|MIN_NR_CONSOLES
comma
(paren
id|MIN_NR_CONSOLES
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
comma
id|MAX_NR_CONSOLES
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|CONSOLE_BH
comma
id|console_bh
)paren
suffix:semicolon
r_return
id|kmem_start
suffix:semicolon
)brace
DECL|function|vesa_powerdown_screen
r_void
id|vesa_powerdown_screen
c_func
(paren
r_void
)paren
(brace
r_int
id|currcons
op_assign
id|fg_console
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|unblank_screen
suffix:semicolon
multiline_comment|/* Power down if currently suspended (1 or 2),&n;&t; * suspend if currently blanked (0),&n;&t; * else do nothing (i.e. already powered down (3)).&n;&t; * Called only if powerdown features are allowed.&n;&t; */
r_switch
c_cond
(paren
id|vesa_blank_mode
)paren
(brace
r_case
l_int|0
suffix:colon
id|sw
op_member_access_from_pointer
id|con_blank
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
id|sw
op_member_access_from_pointer
id|con_blank
c_func
(paren
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|do_blank_screen
r_void
id|do_blank_screen
c_func
(paren
r_int
id|nopowersave
)paren
(brace
r_int
id|currcons
suffix:semicolon
r_if
c_cond
(paren
id|console_blanked
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|fg_console
)paren
)paren
(brace
multiline_comment|/* impossible */
id|printk
c_func
(paren
l_string|&quot;blank_screen: tty %d not allocated ??&bslash;n&quot;
comma
id|fg_console
op_plus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* don&squot;t blank graphics */
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_TEXT
)paren
(brace
r_if
c_cond
(paren
id|vesa_off_interval
op_logical_and
op_logical_neg
id|nopowersave
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|vesa_powerdown_screen
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|vesa_off_interval
suffix:semicolon
id|timer_active
op_or_assign
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
)brace
r_else
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|unblank_screen
suffix:semicolon
)brace
multiline_comment|/* try not to lose information by blanking,&n;&t;&t;   and not to waste memory */
id|currcons
op_assign
id|fg_console
suffix:semicolon
id|has_scrolled
op_assign
l_int|0
suffix:semicolon
id|sw
op_member_access_from_pointer
id|con_blank
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nopowersave
)paren
id|sw
op_member_access_from_pointer
id|con_blank
c_func
(paren
id|vesa_blank_mode
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|hide_cursor
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|console_blanked
op_assign
id|fg_console
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|do_unblank_screen
r_void
id|do_unblank_screen
c_func
(paren
r_void
)paren
(brace
r_int
id|currcons
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|console_blanked
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|fg_console
)paren
)paren
(brace
multiline_comment|/* impossible */
id|printk
c_func
(paren
l_string|&quot;unblank_screen: tty %d not allocated ??&bslash;n&quot;
comma
id|fg_console
op_plus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|blank_screen
suffix:semicolon
r_if
c_cond
(paren
id|blankinterval
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|blankinterval
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
id|currcons
op_assign
id|fg_console
suffix:semicolon
id|console_blanked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sw-&gt;con_blank
(paren
l_int|0
)paren
)paren
multiline_comment|/* Low-level driver cannot restore -&gt; do it ourselves */
id|update_screen
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|set_cursor
(paren
id|fg_console
)paren
suffix:semicolon
)brace
DECL|function|update_screen
r_void
id|update_screen
c_func
(paren
r_int
id|new_console
)paren
(brace
r_int
id|currcons
op_assign
id|fg_console
suffix:semicolon
r_int
id|xx
comma
id|yy
comma
id|startx
comma
id|attr_save
suffix:semicolon
r_char
id|buf
(braket
l_int|256
)braket
comma
op_star
id|bufp
suffix:semicolon
r_int
r_int
op_star
id|p
suffix:semicolon
r_static
r_int
id|lock
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
multiline_comment|/* new_console == fg_console || */
id|lock
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|new_console
)paren
)paren
(brace
multiline_comment|/* strange ... */
id|printk
c_func
(paren
l_string|&quot;update_screen: tty %d not allocated ??&bslash;n&quot;
comma
id|new_console
op_plus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lock
op_assign
l_int|1
suffix:semicolon
id|clear_selection
c_func
(paren
)paren
suffix:semicolon
id|currcons
op_assign
id|fg_console
op_assign
id|new_console
suffix:semicolon
id|sw-&gt;con_cursor
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|CM_ERASE
)paren
suffix:semicolon
id|sw-&gt;con_switch
(paren
id|vc_cons
(braket
id|new_console
)braket
dot
id|d
)paren
suffix:semicolon
multiline_comment|/* Update the screen contents */
id|p
op_assign
id|video_mem_start
suffix:semicolon
id|attr_save
op_assign
id|attr
suffix:semicolon
r_for
c_loop
(paren
id|yy
op_assign
l_int|0
suffix:semicolon
id|yy
OL
id|rows
suffix:semicolon
id|yy
op_increment
)paren
(brace
id|bufp
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|startx
op_assign
id|xx
op_assign
l_int|0
suffix:semicolon
id|xx
OL
id|cols
suffix:semicolon
id|xx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|attr
op_ne
(paren
(paren
op_star
id|p
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
(brace
r_if
c_cond
(paren
id|bufp
OG
id|buf
)paren
id|sw-&gt;con_putcs
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|buf
comma
id|bufp
op_minus
id|buf
comma
id|yy
comma
id|startx
)paren
suffix:semicolon
id|startx
op_assign
id|xx
suffix:semicolon
id|bufp
op_assign
id|buf
suffix:semicolon
id|attr
op_assign
(paren
op_star
id|p
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
op_star
id|bufp
op_increment
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bufp
op_eq
id|buf
op_plus
r_sizeof
(paren
id|buf
)paren
)paren
(brace
id|sw-&gt;con_putcs
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|buf
comma
id|bufp
op_minus
id|buf
comma
id|yy
comma
id|startx
)paren
suffix:semicolon
id|startx
op_assign
id|xx
op_plus
l_int|1
suffix:semicolon
id|bufp
op_assign
id|buf
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bufp
OG
id|buf
)paren
id|sw-&gt;con_putcs
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|buf
comma
id|bufp
op_minus
id|buf
comma
id|yy
comma
id|startx
)paren
suffix:semicolon
)brace
id|set_cursor
(paren
id|currcons
)paren
suffix:semicolon
id|attr
op_assign
id|attr_save
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
id|lock
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * If a blank_screen is due to a timer, then a power save is allowed.&n; * If it is related to console_switching, then avoid vesa_blank().&n; */
DECL|function|blank_screen
r_static
r_void
id|blank_screen
c_func
(paren
r_void
)paren
(brace
id|do_blank_screen
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|unblank_screen
r_static
r_void
id|unblank_screen
c_func
(paren
r_void
)paren
(brace
id|do_unblank_screen
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate the console screen memory.&n; */
DECL|function|con_open
r_int
id|con_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|currcons
suffix:semicolon
r_int
id|i
suffix:semicolon
id|currcons
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
id|i
op_assign
id|vc_allocate
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|vt_cons
(braket
id|currcons
)braket
op_member_access_from_pointer
id|vc_num
op_assign
id|currcons
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|vt_cons
(braket
id|currcons
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;winsize.ws_row
op_logical_and
op_logical_neg
id|tty-&gt;winsize.ws_col
)paren
(brace
id|tty-&gt;winsize.ws_row
op_assign
id|rows
suffix:semicolon
id|tty-&gt;winsize.ws_col
op_assign
id|cols
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * PIO_FONT support.&n; *&n; * Currently we only support 8 pixels wide fonts, at a maximum height&n; * of 32 pixels. Userspace fontdata is stored with 32 bytes reserved&n; * for each character which is kinda wasty, but this is done in order&n; * to maintain compatibility with the EGA/VGA fonts. It is upto the&n; * actual low-level console-driver convert data into its favorite&n; * format (maybe we should add a `fontoffset&squot; field to the `display&squot;&n; * structure so we wont have to convert the fontdata all the time.&n; * /Jes&n; */
DECL|macro|cmapsz
mdefine_line|#define cmapsz 8192
DECL|function|set_get_font
r_static
r_int
id|set_get_font
c_func
(paren
r_char
op_star
id|arg
comma
r_int
id|set
comma
r_int
id|ch512
)paren
(brace
macro_line|#ifdef CAN_LOAD_EGA_FONTS
r_int
id|i
comma
id|unit
comma
id|size
suffix:semicolon
r_char
op_star
id|charmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|size
op_assign
id|ch512
ques
c_cond
l_int|2
op_star
id|cmapsz
suffix:colon
id|cmapsz
suffix:semicolon
id|charmap
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|charmap
comma
id|arg
comma
id|size
)paren
)paren
(brace
id|kfree
c_func
(paren
id|charmap
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|unit
op_assign
l_int|32
suffix:semicolon
id|unit
OG
l_int|0
suffix:semicolon
id|unit
op_decrement
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|ch512
ques
c_cond
l_int|512
suffix:colon
l_int|256
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|charmap
(braket
l_int|32
op_star
id|i
op_plus
id|unit
op_minus
l_int|1
)braket
)paren
r_goto
id|nonzero
suffix:semicolon
id|nonzero
suffix:colon
id|i
op_assign
id|conswitchp
op_member_access_from_pointer
id|con_set_font
c_func
(paren
id|vc_cons
(braket
id|fg_console
)braket
dot
id|d
comma
l_int|8
comma
id|unit
comma
id|charmap
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|charmap
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|i
op_assign
id|conswitchp
op_member_access_from_pointer
id|con_get_font
c_func
(paren
id|vc_cons
(braket
id|fg_console
)braket
dot
id|d
comma
op_amp
id|unit
comma
op_amp
id|unit
comma
id|charmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|copy_to_user
c_func
(paren
id|arg
comma
id|charmap
comma
id|size
)paren
)paren
id|i
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|charmap
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Load palette into the EGA/VGA DAC registers. arg points to a colour&n; * map, 3 bytes per colour, 16 colours, range from 0 to 255.&n; */
DECL|function|con_set_cmap
r_int
id|con_set_cmap
(paren
r_int
r_char
op_star
id|arg
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|con_get_cmap
r_int
id|con_get_cmap
(paren
r_int
r_char
op_star
id|arg
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|reset_palette
r_void
id|reset_palette
c_func
(paren
r_int
id|currcons
)paren
(brace
)brace
DECL|function|set_palette
r_void
id|set_palette
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/*&n; * Load font into the EGA/VGA character generator. arg points to a 8192&n; * byte map, 32 bytes per character. Only first H of them are used for&n; * 8xH fonts (0 &lt; H &lt;= 32).&n; */
DECL|function|con_set_font
r_int
id|con_set_font
(paren
r_char
op_star
id|arg
comma
r_int
id|ch512
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|set_get_font
(paren
id|arg
comma
l_int|1
comma
id|ch512
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|hashtable_contents_valid
op_assign
l_int|0
suffix:semicolon
id|video_mode_512ch
op_assign
id|ch512
suffix:semicolon
id|console_charmask
op_assign
id|ch512
ques
c_cond
l_int|0x1ff
suffix:colon
l_int|0x0ff
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|con_get_font
r_int
id|con_get_font
(paren
r_char
op_star
id|arg
)paren
(brace
r_return
id|set_get_font
(paren
id|arg
comma
l_int|0
comma
id|video_mode_512ch
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust the screen to fit a font of a certain height&n; *&n; * Returns &lt; 0 for error, 0 if nothing changed, and the number&n; * of lines on the adjusted console if changed.&n; */
DECL|function|con_adjust_height
r_int
id|con_adjust_height
c_func
(paren
r_int
r_int
id|fontheight
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|set_vesa_blanking
r_void
id|set_vesa_blanking
c_func
(paren
r_int
id|arg
)paren
(brace
r_char
op_star
id|argp
op_assign
(paren
r_char
op_star
)paren
id|arg
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|mode
suffix:semicolon
id|get_user
c_func
(paren
id|mode
comma
id|argp
)paren
suffix:semicolon
id|vesa_blank_mode
op_assign
(paren
id|mode
OL
l_int|4
)paren
ques
c_cond
id|mode
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|get_video_num_lines
r_int
r_int
id|get_video_num_lines
c_func
(paren
r_int
r_int
id|currcons
)paren
(brace
r_return
id|rows
suffix:semicolon
)brace
DECL|function|get_video_num_columns
r_int
r_int
id|get_video_num_columns
c_func
(paren
r_int
r_int
id|currcons
)paren
(brace
r_return
id|cols
suffix:semicolon
)brace
DECL|function|get_video_size_row
r_int
r_int
id|get_video_size_row
c_func
(paren
r_int
r_int
id|currcons
)paren
(brace
r_return
id|size_row
suffix:semicolon
)brace
eof
