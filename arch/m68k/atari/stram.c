multiline_comment|/*&n; * arch/m68k/atari/stram.c: Functions for ST-RAM allocations&n; *&n; * Copyright 1994-97 Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atari_stram.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#ifdef CONFIG_STRAM_SWAP
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR    Z2RAM_MAJOR
DECL|macro|do_z2_request
mdefine_line|#define do_z2_request do_stram_request
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|DEVICE_NAME
macro_line|#undef DEVICE_NAME
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME&t;&quot;stram&quot;
macro_line|#endif
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
mdefine_line|#define&t;DPRINTK(fmt,args...) printk( fmt, ##args )
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt,args...)
macro_line|#endif
macro_line|#if defined(CONFIG_PROC_FS) &amp;&amp; defined(CONFIG_STRAM_PROC)
multiline_comment|/* abbrev for the &amp;&amp; above... */
DECL|macro|DO_PROC
mdefine_line|#define DO_PROC
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#endif
multiline_comment|/* Pre-swapping comments:&n; *&n; * ++roman:&n; * &n; * New version of ST-Ram buffer allocation. Instead of using the&n; * 1 MB - 4 KB that remain when the ST-Ram chunk starts at $1000&n; * (1 MB granularity!), such buffers are reserved like this:&n; *&n; *  - If the kernel resides in ST-Ram anyway, we can take the buffer&n; *    from behind the current kernel data space the normal way&n; *    (incrementing start_mem).&n; *    &n; *  - If the kernel is in TT-Ram, stram_init() initializes start and&n; *    end of the available region. Buffers are allocated from there&n; *    and mem_init() later marks the such used pages as reserved.&n; *    Since each TT-Ram chunk is at least 4 MB in size, I hope there&n; *    won&squot;t be an overrun of the ST-Ram region by normal kernel data&n; *    space.&n; *    &n; * For that, ST-Ram may only be allocated while kernel initialization&n; * is going on, or exactly: before mem_init() is called. There is also&n; * no provision now for freeing ST-Ram buffers. It seems that isn&squot;t&n; * really needed.&n; *&n; */
multiline_comment|/*&n; * New Nov 1997: Use ST-RAM as swap space!&n; *&n; * In the past, there were often problems with modules that require ST-RAM&n; * buffers. Such drivers have to use __get_dma_pages(), which unfortunately&n; * often isn&squot;t very successful in allocating more than 1 page :-( [1] The net&n; * result was that most of the time you couldn&squot;t insmod such modules (ataflop,&n; * ACSI, SCSI on Falcon, Atari internal framebuffer, not to speak of acsi_slm,&n; * which needs a 1 MB buffer... :-).&n; *&n; * To overcome this limitation, ST-RAM can now be turned into a very&n; * high-speed swap space. If a request for an ST-RAM buffer comes, the kernel&n; * now tries to unswap some pages on that swap device to make some free (and&n; * contiguous) space. This works much better in comparison to&n; * __get_dma_pages(), since used swap pages can be selectively freed by either&n; * moving them to somewhere else in swap space, or by reading them back into&n; * system memory. Ok, there operation of unswapping isn&squot;t really cheap (for&n; * each page, one has to go through the page tables of all processes), but it&n; * doesn&squot;t happen that often (only when allocation ST-RAM, i.e. when loading a&n; * module that needs ST-RAM). But it at least makes it possible to load such&n; * modules!&n; *&n; * It could also be that overall system performance increases a bit due to&n; * ST-RAM swapping, since slow ST-RAM isn&squot;t used anymore for holding data or&n; * executing code in. It&squot;s then just a (very fast, compared to disk) back&n; * storage for not-so-often needed data. (But this effect must be compared&n; * with the loss of total memory...) Don&squot;t know if the effect is already&n; * visible on a TT, where the speed difference between ST- and TT-RAM isn&squot;t&n; * that dramatic, but it should on machines where TT-RAM is really much faster&n; * (e.g. Afterburner).&n; * &n; *   [1]: __get_free_pages() does a fine job if you only want one page, but if&n; * you want more (contiguous) pages, it can give you such a block only if&n; * there&squot;s already a free one. The algorithm can&squot;t try to free buffers or swap&n; * out something in order to make more free space, since all that page-freeing&n; * mechanisms work &quot;target-less&quot;, i.e. they just free something, but not in a&n; * specific place. I.e., __get_free_pages() can&squot;t do anything to free&n; * *adjacent* pages :-( This situation becomes even worse for DMA memory,&n; * since the freeing algorithms are also blind to DMA capability of pages.&n; */
multiline_comment|/* 1998-10-20: ++andreas&n;   unswap_by_move disabled because it does not handle swapped shm pages.&n;*/
multiline_comment|/* 2000-05-01: ++andreas&n;   Integrated with bootmem.  Remove all traces of unswap_by_move.&n;*/
macro_line|#ifdef CONFIG_STRAM_SWAP
DECL|macro|ALIGN_IF_SWAP
mdefine_line|#define ALIGN_IF_SWAP(x)&t;PAGE_ALIGN(x)
macro_line|#else
DECL|macro|ALIGN_IF_SWAP
mdefine_line|#define ALIGN_IF_SWAP(x)&t;(x)
macro_line|#endif
multiline_comment|/* get index of swap page at address &squot;addr&squot; */
DECL|macro|SWAP_NR
mdefine_line|#define SWAP_NR(addr)&t;&t;(((addr) - swap_start) &gt;&gt; PAGE_SHIFT)
multiline_comment|/* get address of swap page #&squot;nr&squot; */
DECL|macro|SWAP_ADDR
mdefine_line|#define SWAP_ADDR(nr)&t;&t;(swap_start + ((nr) &lt;&lt; PAGE_SHIFT))
multiline_comment|/* get number of pages for &squot;n&squot; bytes (already page-aligned) */
DECL|macro|N_PAGES
mdefine_line|#define N_PAGES(n)&t;&t;&t;((n) &gt;&gt; PAGE_SHIFT)
multiline_comment|/* The following two numbers define the maximum fraction of ST-RAM in total&n; * memory, below that the kernel would automatically use ST-RAM as swap&n; * space. This decision can be overriden with stram_swap= */
DECL|macro|MAX_STRAM_FRACTION_NOM
mdefine_line|#define MAX_STRAM_FRACTION_NOM&t;&t;1
DECL|macro|MAX_STRAM_FRACTION_DENOM
mdefine_line|#define MAX_STRAM_FRACTION_DENOM&t;3
multiline_comment|/* Start and end (virtual) of ST-RAM */
DECL|variable|stram_start
DECL|variable|stram_end
r_static
r_void
op_star
id|stram_start
comma
op_star
id|stram_end
suffix:semicolon
multiline_comment|/* set after memory_init() executed and allocations via start_mem aren&squot;t&n; * possible anymore */
DECL|variable|mem_init_done
r_static
r_int
id|mem_init_done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set if kernel is in ST-RAM */
DECL|variable|kernel_in_stram
r_static
r_int
id|kernel_in_stram
suffix:semicolon
DECL|struct|stram_block
r_typedef
r_struct
id|stram_block
(brace
DECL|member|next
r_struct
id|stram_block
op_star
id|next
suffix:semicolon
DECL|member|start
r_void
op_star
id|start
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|owner
r_const
r_char
op_star
id|owner
suffix:semicolon
DECL|typedef|BLOCK
)brace
id|BLOCK
suffix:semicolon
multiline_comment|/* values for flags field */
DECL|macro|BLOCK_FREE
mdefine_line|#define BLOCK_FREE&t;&t;0x01&t;/* free structure in the BLOCKs pool */
DECL|macro|BLOCK_KMALLOCED
mdefine_line|#define BLOCK_KMALLOCED&t;0x02&t;/* structure allocated by kmalloc() */
DECL|macro|BLOCK_GFP
mdefine_line|#define BLOCK_GFP&t;&t;0x08&t;/* block allocated with __get_dma_pages() */
DECL|macro|BLOCK_INSWAP
mdefine_line|#define BLOCK_INSWAP&t;0x10&t;/* block allocated in swap space */
multiline_comment|/* list of allocated blocks */
DECL|variable|alloc_list
r_static
id|BLOCK
op_star
id|alloc_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We can&squot;t always use kmalloc() to allocate BLOCK structures, since&n; * stram_alloc() can be called rather early. So we need some pool of&n; * statically allocated structures. 20 of them is more than enough, so in most&n; * cases we never should need to call kmalloc(). */
DECL|macro|N_STATIC_BLOCKS
mdefine_line|#define N_STATIC_BLOCKS&t;20
DECL|variable|static_blocks
r_static
id|BLOCK
id|static_blocks
(braket
id|N_STATIC_BLOCKS
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
multiline_comment|/* max. number of bytes to use for swapping&n; *  0 = no ST-RAM swapping&n; * -1 = do swapping (to whole ST-RAM) if it&squot;s less than MAX_STRAM_FRACTION of&n; *      total memory&n; */
DECL|variable|max_swap_size
r_static
r_int
id|max_swap_size
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* start and end of swapping area */
DECL|variable|swap_start
DECL|variable|swap_end
r_static
r_void
op_star
id|swap_start
comma
op_star
id|swap_end
suffix:semicolon
multiline_comment|/* The ST-RAM&squot;s swap info structure */
DECL|variable|stram_swap_info
r_static
r_struct
id|swap_info_struct
op_star
id|stram_swap_info
suffix:semicolon
multiline_comment|/* The ST-RAM&squot;s swap type */
DECL|variable|stram_swap_type
r_static
r_int
id|stram_swap_type
suffix:semicolon
multiline_comment|/* Semaphore for get_stram_region.  */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|stram_swap_sem
)paren
suffix:semicolon
multiline_comment|/* major and minor device number of the ST-RAM device; for the major, we use&n; * the same as Amiga z2ram, which is really similar and impossible on Atari,&n; * and for the minor a relatively odd number to avoid the user creating and&n; * using that device. */
DECL|macro|STRAM_MAJOR
mdefine_line|#define&t;STRAM_MAJOR&t;&t;Z2RAM_MAJOR
DECL|macro|STRAM_MINOR
mdefine_line|#define&t;STRAM_MINOR&t;&t;13
multiline_comment|/* Some impossible pointer value */
DECL|macro|MAGIC_FILE_P
mdefine_line|#define MAGIC_FILE_P&t;(struct file *)0xffffdead
macro_line|#ifdef DO_PROC
DECL|variable|stat_swap_read
r_static
r_int
id|stat_swap_read
op_assign
l_int|0
suffix:semicolon
DECL|variable|stat_swap_write
r_static
r_int
id|stat_swap_write
op_assign
l_int|0
suffix:semicolon
DECL|variable|stat_swap_force
r_static
r_int
id|stat_swap_force
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* DO_PROC */
macro_line|#endif /* CONFIG_STRAM_SWAP */
multiline_comment|/***************************** Prototypes *****************************/
macro_line|#ifdef CONFIG_STRAM_SWAP
r_static
r_int
id|swap_init
c_func
(paren
r_void
op_star
id|start_mem
comma
r_void
op_star
id|swap_data
)paren
suffix:semicolon
r_static
r_void
op_star
id|get_stram_region
c_func
(paren
r_int
r_int
id|n_pages
)paren
suffix:semicolon
r_static
r_void
id|free_stram_region
c_func
(paren
r_int
r_int
id|offset
comma
r_int
r_int
id|n_pages
)paren
suffix:semicolon
r_static
r_int
id|in_some_region
c_func
(paren
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_int
r_int
id|find_free_region
c_func
(paren
r_int
r_int
id|n_pages
comma
r_int
r_int
op_star
id|total_free
comma
r_int
r_int
op_star
id|region_free
)paren
suffix:semicolon
r_static
r_void
id|do_stram_request
c_func
(paren
id|request_queue_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|stram_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|stram_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|reserve_region
c_func
(paren
r_void
op_star
id|start
comma
r_void
op_star
id|end
)paren
suffix:semicolon
r_static
id|BLOCK
op_star
id|add_region
c_func
(paren
r_void
op_star
id|addr
comma
r_int
r_int
id|size
)paren
suffix:semicolon
r_static
id|BLOCK
op_star
id|find_region
c_func
(paren
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_int
id|remove_region
c_func
(paren
id|BLOCK
op_star
id|block
)paren
suffix:semicolon
multiline_comment|/************************* End of Prototypes **************************/
"&f;"
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;   Public Interface&t;&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&n; * This init function is called very early by atari/config.c&n; * It initializes some internal variables needed for stram_alloc()&n; */
DECL|function|atari_stram_init
r_void
id|__init
id|atari_stram_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* initialize static blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_STATIC_BLOCKS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|static_blocks
(braket
id|i
)braket
dot
id|flags
op_assign
id|BLOCK_FREE
suffix:semicolon
)brace
multiline_comment|/* determine whether kernel code resides in ST-RAM (then ST-RAM is the&n;&t; * first memory block at virtual 0x0) */
id|stram_start
op_assign
id|phys_to_virt
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|kernel_in_stram
op_assign
(paren
id|stram_start
op_eq
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|m68k_num_memory
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* skip first 2kB or page (supervisor-only!) */
id|stram_end
op_assign
id|stram_start
op_plus
id|m68k_memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Should never come here! (There is always ST-Ram!) */
id|panic
c_func
(paren
l_string|&quot;atari_stram_init: no ST-RAM found!&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called from setup_arch() to reserve the pages needed for&n; * ST-RAM management.&n; */
DECL|function|atari_stram_reserve_pages
r_void
id|__init
id|atari_stram_reserve_pages
c_func
(paren
r_void
op_star
id|start_mem
)paren
(brace
macro_line|#ifdef CONFIG_STRAM_SWAP
multiline_comment|/* if max_swap_size is negative (i.e. no stram_swap= option given),&n;&t; * determine at run time whether to use ST-RAM swapping */
r_if
c_cond
(paren
id|max_swap_size
OL
l_int|0
)paren
multiline_comment|/* Use swapping if ST-RAM doesn&squot;t make up more than MAX_STRAM_FRACTION&n;&t;&t; * of total memory. In that case, the max. size is set to 16 MB,&n;&t;&t; * because ST-RAM can never be bigger than that.&n;&t;&t; * Also, never use swapping on a Hades, there&squot;s no separate ST-RAM in&n;&t;&t; * that machine. */
id|max_swap_size
op_assign
(paren
op_logical_neg
id|MACH_IS_HADES
op_logical_and
(paren
id|N_PAGES
c_func
(paren
id|stram_end
op_minus
id|stram_start
)paren
op_star
id|MAX_STRAM_FRACTION_DENOM
op_le
(paren
id|high_memory
op_rshift
id|PAGE_SHIFT
)paren
op_star
id|MAX_STRAM_FRACTION_NOM
)paren
)paren
ques
c_cond
l_int|16
op_star
l_int|1024
op_star
l_int|1024
suffix:colon
l_int|0
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_reserve_pages: max_swap_size = %d&bslash;n&quot;
comma
id|max_swap_size
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* always reserve first page of ST-RAM, the first 2 kB are&n;&t; * supervisor-only! */
r_if
c_cond
(paren
op_logical_neg
id|kernel_in_stram
)paren
id|reserve_bootmem
(paren
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
(brace
r_void
op_star
id|swap_data
suffix:semicolon
id|start_mem
op_assign
(paren
r_void
op_star
)paren
id|PAGE_ALIGN
(paren
(paren
r_int
r_int
)paren
id|start_mem
)paren
suffix:semicolon
multiline_comment|/* determine first page to use as swap: if the kernel is&n;&t;&t;   in TT-RAM, this is the first page of (usable) ST-RAM;&n;&t;&t;   otherwise just use the end of kernel data (= start_mem) */
id|swap_start
op_assign
op_logical_neg
id|kernel_in_stram
ques
c_cond
id|stram_start
op_plus
id|PAGE_SIZE
suffix:colon
id|start_mem
suffix:semicolon
multiline_comment|/* decrement by one page, rest of kernel assumes that first swap page&n;&t;&t; * is always reserved and maybe doesn&squot;t handle SWP_ENTRY == 0&n;&t;&t; * correctly */
id|swap_start
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|swap_end
op_assign
id|stram_end
suffix:semicolon
r_if
c_cond
(paren
id|swap_end
op_minus
id|swap_start
OG
id|max_swap_size
)paren
id|swap_end
op_assign
id|swap_start
op_plus
id|max_swap_size
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_reserve_pages: swapping enabled; &quot;
l_string|&quot;swap=%p-%p&bslash;n&quot;
comma
id|swap_start
comma
id|swap_end
)paren
suffix:semicolon
multiline_comment|/* reserve some amount of memory for maintainance of&n;&t;&t; * swapping itself: one page for each 2048 (PAGE_SIZE/2)&n;&t;&t; * swap pages. (2 bytes for each page) */
id|swap_data
op_assign
id|start_mem
suffix:semicolon
id|start_mem
op_add_assign
(paren
(paren
id|SWAP_NR
c_func
(paren
id|swap_end
)paren
op_plus
id|PAGE_SIZE
op_div
l_int|2
op_minus
l_int|1
)paren
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|1
)paren
)paren
op_lshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* correct swap_start if necessary */
r_if
c_cond
(paren
id|swap_start
op_plus
id|PAGE_SIZE
op_eq
id|swap_data
)paren
id|swap_start
op_assign
id|start_mem
op_minus
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swap_init
c_func
(paren
id|start_mem
comma
id|swap_data
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ST-RAM swap space initialization failed&bslash;n&quot;
)paren
suffix:semicolon
id|max_swap_size
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* reserve region for swapping meta-data */
id|reserve_region
c_func
(paren
id|swap_data
comma
id|start_mem
)paren
suffix:semicolon
multiline_comment|/* reserve swapping area itself */
id|reserve_region
c_func
(paren
id|swap_start
op_plus
id|PAGE_SIZE
comma
id|swap_end
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the whole ST-RAM is used for swapping, there are no allocatable&n;&t;&t; * dma pages left. But unfortunately, some shared parts of the kernel&n;&t;&t; * (particularily the SCSI mid-level) call __get_dma_pages()&n;&t;&t; * unconditionally :-( These calls then fail, and scsi.c even doesn&squot;t&n;&t;&t; * check for NULL return values and just crashes. The quick fix for&n;&t;&t; * this (instead of doing much clean up work in the SCSI code) is to&n;&t;&t; * pretend all pages are DMA-able by setting mach_max_dma_address to&n;&t;&t; * ULONG_MAX. This doesn&squot;t change any functionality so far, since&n;&t;&t; * get_dma_pages() shouldn&squot;t be used on Atari anyway anymore (better&n;&t;&t; * use atari_stram_alloc()), and the Atari SCSI drivers don&squot;t need DMA&n;&t;&t; * memory. But unfortunately there&squot;s now no kind of warning (even not&n;&t;&t; * a NULL return value) if you use get_dma_pages() nevertheless :-(&n;&t;&t; * You just will get non-DMA-able memory...&n;&t;&t; */
id|mach_max_dma_address
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|atari_stram_mem_init_hook
r_void
id|atari_stram_mem_init_hook
(paren
r_void
)paren
(brace
id|mem_init_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This is main public interface: somehow allocate a ST-RAM block&n; * There are three strategies:&n; * &n; *  - If we&squot;re before mem_init(), we have to make a static allocation. The&n; *    region is taken in the kernel data area (if the kernel is in ST-RAM) or&n; *    from the start of ST-RAM (if the kernel is in TT-RAM) and added to the&n; *    rsvd_stram_* region. The ST-RAM is somewhere in the middle of kernel&n; *    address space in the latter case.&n; * &n; *  - If mem_init() already has been called and ST-RAM swapping is enabled,&n; *    try to get the memory from the (pseudo) swap-space, either free already&n; *    or by moving some other pages out of the swap.&n; *&n; *  - If mem_init() already has been called, and ST-RAM swapping is not&n; *    enabled, the only possibility is to try with __get_dma_pages(). This has&n; *    the disadvantage that it&squot;s very hard to get more than 1 page, and it is&n; *    likely to fail :-(&n; * &n; */
DECL|function|atari_stram_alloc
r_void
op_star
id|atari_stram_alloc
c_func
(paren
r_int
id|size
comma
r_const
r_char
op_star
id|owner
)paren
(brace
r_void
op_star
id|addr
op_assign
l_int|NULL
suffix:semicolon
id|BLOCK
op_star
id|block
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_alloc(size=%08lx,owner=%s)&bslash;n&quot;
comma
id|size
comma
id|owner
)paren
suffix:semicolon
id|size
op_assign
id|ALIGN_IF_SWAP
c_func
(paren
id|size
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_alloc: rounded size = %08lx&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
r_if
c_cond
(paren
id|max_swap_size
)paren
(brace
multiline_comment|/* If swapping is active: make some free space in the swap&n;&t;&t;   &quot;device&quot;. */
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_alloc: after mem_init, swapping ok, &quot;
l_string|&quot;calling get_region&bslash;n&quot;
)paren
suffix:semicolon
id|addr
op_assign
id|get_stram_region
c_func
(paren
id|N_PAGES
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
id|flags
op_assign
id|BLOCK_INSWAP
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|mem_init_done
)paren
r_return
id|alloc_bootmem_low
c_func
(paren
id|size
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* After mem_init() and no swapping: can only resort to&n;&t;&t; * __get_dma_pages() */
id|addr
op_assign
(paren
r_void
op_star
)paren
id|__get_dma_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
id|flags
op_assign
id|BLOCK_GFP
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_alloc: after mem_init, swapping off, &quot;
l_string|&quot;get_pages=%p&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|block
op_assign
id|add_region
c_func
(paren
id|addr
comma
id|size
)paren
)paren
)paren
(brace
multiline_comment|/* out of memory for BLOCK structure :-( */
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_alloc: out of mem for BLOCK -- &quot;
l_string|&quot;freeing again&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
r_if
c_cond
(paren
id|flags
op_eq
id|BLOCK_INSWAP
)paren
id|free_stram_region
c_func
(paren
id|SWAP_NR
c_func
(paren
id|addr
)paren
comma
id|N_PAGES
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_else
macro_line|#endif
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|block-&gt;owner
op_assign
id|owner
suffix:semicolon
id|block-&gt;flags
op_or_assign
id|flags
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
)brace
DECL|function|atari_stram_free
r_void
id|atari_stram_free
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|BLOCK
op_star
id|block
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_free(addr=%p)&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|block
op_assign
id|find_region
c_func
(paren
id|addr
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Attempt to free non-allocated ST-RAM block at %p &quot;
l_string|&quot;from %p&bslash;n&quot;
comma
id|addr
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_free: found block (%p): size=%08lx, owner=%s, &quot;
l_string|&quot;flags=%02x&bslash;n&quot;
comma
id|block
comma
id|block-&gt;size
comma
id|block-&gt;owner
comma
id|block-&gt;flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
r_if
c_cond
(paren
op_logical_neg
id|max_swap_size
)paren
(brace
macro_line|#endif
r_if
c_cond
(paren
id|block-&gt;flags
op_amp
id|BLOCK_GFP
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_free: is kmalloced, order_size=%d&bslash;n&quot;
comma
id|get_order
c_func
(paren
id|block-&gt;size
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|get_order
c_func
(paren
id|block-&gt;size
)paren
)paren
suffix:semicolon
)brace
r_else
r_goto
id|fail
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
)brace
r_else
r_if
c_cond
(paren
id|block-&gt;flags
op_amp
id|BLOCK_INSWAP
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;atari_stram_free: is swap-alloced&bslash;n&quot;
)paren
suffix:semicolon
id|free_stram_region
c_func
(paren
id|SWAP_NR
c_func
(paren
id|block-&gt;start
)paren
comma
id|N_PAGES
c_func
(paren
id|block-&gt;size
)paren
)paren
suffix:semicolon
)brace
r_else
r_goto
id|fail
suffix:semicolon
macro_line|#endif
id|remove_region
c_func
(paren
id|block
)paren
suffix:semicolon
r_return
suffix:semicolon
id|fail
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;atari_stram_free: cannot free block at %p &quot;
l_string|&quot;(called from %p)&bslash;n&quot;
comma
id|addr
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_STRAM_SWAP
"&f;"
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&t;&t;&t;&t;&t;&t;   Main Swapping Functions&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&n; * Initialize ST-RAM swap device&n; * (lots copied and modified from sys_swapon() in mm/swapfile.c)&n; */
DECL|function|swap_init
r_static
r_int
id|__init
id|swap_init
c_func
(paren
r_void
op_star
id|start_mem
comma
r_void
op_star
id|swap_data
)paren
(brace
r_static
r_struct
id|dentry
id|fake_dentry
suffix:semicolon
r_static
r_struct
id|vfsmount
id|fake_vfsmnt
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_struct
id|inode
id|swap_inode
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
comma
id|prev
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;swap_init(start_mem=%p, swap_data=%p)&bslash;n&quot;
comma
id|start_mem
comma
id|swap_data
)paren
suffix:semicolon
multiline_comment|/* need at least one page for swapping to (and this also isn&squot;t very&n;&t; * much... :-) */
r_if
c_cond
(paren
id|swap_end
op_minus
id|swap_start
OL
l_int|2
op_star
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;stram_swap_init: swap space too small&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* find free slot in swap_info */
r_for
c_loop
(paren
id|p
op_assign
id|swap_info
comma
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|MAX_SWAPFILES
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;stram_swap_init: max. number of &quot;
l_string|&quot;swap devices exhausted&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
id|nr_swapfiles
op_assign
id|type
op_plus
l_int|1
suffix:semicolon
id|stram_swap_info
op_assign
id|p
suffix:semicolon
id|stram_swap_type
op_assign
id|type
suffix:semicolon
multiline_comment|/* fake some dir cache entries to give us some name in /dev/swaps */
id|fake_dentry.d_parent
op_assign
op_amp
id|fake_dentry
suffix:semicolon
id|fake_dentry.d_name.name
op_assign
l_string|&quot;stram (internal)&quot;
suffix:semicolon
id|fake_dentry.d_name.len
op_assign
l_int|16
suffix:semicolon
id|fake_vfsmnt.mnt_parent
op_assign
op_amp
id|fake_vfsmnt
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|p-&gt;swap_file
op_assign
op_amp
id|fake_dentry
suffix:semicolon
id|p-&gt;swap_vfsmnt
op_assign
op_amp
id|fake_vfsmnt
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_map
op_assign
id|swap_data
suffix:semicolon
id|p-&gt;cluster_nr
op_assign
l_int|0
suffix:semicolon
id|p-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
id|p-&gt;prio
op_assign
l_int|0x7ff0
suffix:semicolon
multiline_comment|/* a rather high priority, but not the higest&n;&t;&t;&t;&t;&t;&t;&t;&t; * to give the user a chance to override */
multiline_comment|/* call stram_open() directly, avoids at least the overhead in&n;&t; * constructing a dummy file structure... */
id|p-&gt;swap_device
op_assign
id|MKDEV
c_func
(paren
id|STRAM_MAJOR
comma
id|STRAM_MINOR
)paren
suffix:semicolon
id|swap_inode.i_rdev
op_assign
id|p-&gt;swap_device
suffix:semicolon
id|stram_open
c_func
(paren
op_amp
id|swap_inode
comma
id|MAGIC_FILE_P
)paren
suffix:semicolon
id|p-&gt;max
op_assign
id|SWAP_NR
c_func
(paren
id|swap_end
)paren
suffix:semicolon
multiline_comment|/* initialize swap_map: set regions that are already allocated or belong&n;&t; * to kernel data space to SWAP_MAP_BAD, otherwise to free */
id|j
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # of free pages */
id|k
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # of already allocated pages (from pre-mem_init stram_alloc()) */
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|addr
op_assign
id|SWAP_ADDR
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|i
OL
id|p-&gt;max
suffix:semicolon
id|i
op_increment
comma
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|in_some_region
c_func
(paren
id|addr
)paren
)paren
(brace
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
op_increment
id|k
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kernel_in_stram
op_logical_and
id|addr
OL
id|start_mem
)paren
(brace
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
op_increment
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|i
suffix:semicolon
id|p-&gt;highest_bit
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* first page always reserved (and doesn&squot;t really belong to swap space) */
id|p-&gt;swap_map
(braket
l_int|0
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
multiline_comment|/* now swapping to this device ok */
id|p-&gt;pages
op_assign
id|j
op_plus
id|k
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|j
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
multiline_comment|/* insert swap space into swap_list */
id|prev
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|swap_list.head
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_assign
id|swap_info
(braket
id|i
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;prio
op_ge
id|swap_info
(braket
id|i
)braket
dot
id|prio
)paren
(brace
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|i
suffix:semicolon
)brace
id|p-&gt;next
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
(brace
id|swap_list.head
op_assign
id|swap_list.next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
)brace
r_else
(brace
id|swap_info
(braket
id|prev
)braket
dot
id|next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Using %dk (%d pages) of ST-RAM as swap space.&bslash;n&quot;
comma
id|p-&gt;pages
op_lshift
l_int|2
comma
id|p-&gt;pages
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The swap entry has been read in advance, and we return 1 to indicate&n; * that the page has been used or is no longer needed.&n; *&n; * Always set the resulting pte to be nowrite (the same as COW pages&n; * after one process has exited).  We don&squot;t know just how many PTEs will&n; * share this swap entry, so be cautious and let do_wp_page work out&n; * what to do if a write is requested later.&n; */
DECL|function|unswap_pte
r_static
r_inline
r_void
id|unswap_pte
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|dir
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pte_t
id|pte
op_assign
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|pte
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
multiline_comment|/* If this entry is swap-cached, then page must already&n;                   hold the right address for any copies in physical&n;                   memory */
r_if
c_cond
(paren
id|pte_page
c_func
(paren
id|pte
)paren
op_ne
id|page
)paren
r_return
suffix:semicolon
multiline_comment|/* We will be removing the swap cache in a moment, so... */
id|set_pte
c_func
(paren
id|dir
comma
id|pte_mkdirty
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_ne
id|entry.val
)paren
r_return
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;unswap_pte: replacing entry %08lx by new page %p&quot;
comma
id|entry.val
comma
id|page
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|dir
comma
id|pte_mkdirty
c_func
(paren
id|mk_pte
c_func
(paren
id|page
comma
id|vma-&gt;vm_page_prot
)paren
)paren
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
op_increment
id|vma-&gt;vm_mm-&gt;rss
suffix:semicolon
)brace
DECL|function|unswap_pmd
r_static
r_inline
r_void
id|unswap_pmd
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pmd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
r_int
id|offset
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pmd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|offset
op_add_assign
id|address
op_amp
id|PMD_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
r_do
(brace
id|unswap_pte
c_func
(paren
id|vma
comma
id|offset
op_plus
id|address
op_minus
id|vma-&gt;vm_start
comma
id|pte
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
)brace
DECL|function|unswap_pgd
r_static
r_inline
r_void
id|unswap_pgd
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|offset
comma
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pgd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|offset
op_assign
id|address
op_amp
id|PGDIR_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
r_do
(brace
id|unswap_pmd
c_func
(paren
id|vma
comma
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|offset
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
)brace
DECL|function|unswap_vma
r_static
r_void
id|unswap_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgd_t
op_star
id|pgdir
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|start
op_assign
id|vma-&gt;vm_start
comma
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
r_do
(brace
id|unswap_pgd
c_func
(paren
id|vma
comma
id|pgdir
comma
id|start
comma
id|end
op_minus
id|start
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|start
op_assign
(paren
id|start
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|pgdir
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
OL
id|end
)paren
suffix:semicolon
)brace
DECL|function|unswap_process
r_static
r_void
id|unswap_process
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
multiline_comment|/*&n;&t; * Go through process&squot; page directory.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
id|pgd_t
op_star
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|unswap_vma
c_func
(paren
id|vma
comma
id|pgd
comma
id|entry
comma
id|page
)paren
suffix:semicolon
)brace
)brace
DECL|function|unswap_by_read
r_static
r_int
id|unswap_by_read
c_func
(paren
r_int
r_int
op_star
id|map
comma
r_int
r_int
id|max
comma
r_int
r_int
id|start
comma
r_int
r_int
id|n_pages
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;unswapping %lu..%lu by reading in&bslash;n&quot;
comma
id|start
comma
id|start
op_plus
id|n_pages
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start
suffix:semicolon
id|i
OL
id|start
op_plus
id|n_pages
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|map
(braket
id|i
)braket
op_eq
id|SWAP_MAP_BAD
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;get_stram_region: page %lu already &quot;
l_string|&quot;reserved??&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map
(braket
id|i
)braket
)paren
(brace
id|entry
op_assign
id|SWP_ENTRY
c_func
(paren
id|stram_swap_type
comma
id|i
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;unswap: map[i=%lu]=%u nr_swap=%u&bslash;n&quot;
comma
id|i
comma
id|map
(braket
id|i
)braket
comma
id|nr_swap_pages
)paren
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|stram_swap_info
)paren
suffix:semicolon
id|map
(braket
id|i
)braket
op_increment
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|stram_swap_info
)paren
suffix:semicolon
multiline_comment|/* Get a page for the entry, using the existing&n;&t;&t;&t;   swap cache page if there is one.  Otherwise,&n;&t;&t;&t;   get a clean page and read the swap into it. */
id|page
op_assign
id|read_swap_cache
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
id|unswap_process
c_func
(paren
id|p-&gt;mm
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|shm_unuse
c_func
(paren
id|entry
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Now get rid of the extra reference to the&n;&t;&t;&t;   temporary page we&squot;ve been using. */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#ifdef DO_PROC
id|stat_swap_force
op_increment
suffix:semicolon
macro_line|#endif
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;unswap: map[i=%lu]=%u nr_swap=%u&bslash;n&quot;
comma
id|i
comma
id|map
(braket
id|i
)braket
comma
id|nr_swap_pages
)paren
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|stram_swap_info
)paren
suffix:semicolon
id|map
(braket
id|i
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
r_if
c_cond
(paren
id|stram_swap_info-&gt;lowest_bit
op_eq
id|i
)paren
id|stram_swap_info-&gt;lowest_bit
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stram_swap_info-&gt;highest_bit
op_eq
id|i
)paren
id|stram_swap_info-&gt;highest_bit
op_decrement
suffix:semicolon
op_decrement
id|nr_swap_pages
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|stram_swap_info
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * reserve a region in ST-RAM swap space for an allocation&n; */
DECL|function|get_stram_region
r_static
r_void
op_star
id|get_stram_region
c_func
(paren
r_int
r_int
id|n_pages
)paren
(brace
r_int
r_int
op_star
id|map
op_assign
id|stram_swap_info-&gt;swap_map
suffix:semicolon
r_int
r_int
id|max
op_assign
id|stram_swap_info-&gt;max
suffix:semicolon
r_int
r_int
id|start
comma
id|total_free
comma
id|region_free
suffix:semicolon
r_int
id|err
suffix:semicolon
r_void
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;get_stram_region(n_pages=%lu)&bslash;n&quot;
comma
id|n_pages
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|stram_swap_sem
)paren
suffix:semicolon
multiline_comment|/* disallow writing to the swap device now */
id|stram_swap_info-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
multiline_comment|/* find a region of n_pages pages in the swap space including as much free&n;&t; * pages as possible (and excluding any already-reserved pages). */
r_if
c_cond
(paren
op_logical_neg
(paren
id|start
op_assign
id|find_free_region
c_func
(paren
id|n_pages
comma
op_amp
id|total_free
comma
op_amp
id|region_free
)paren
)paren
)paren
r_goto
id|end
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;get_stram_region: region starts at %lu, has %lu free pages&bslash;n&quot;
comma
id|start
comma
id|region_free
)paren
suffix:semicolon
id|err
op_assign
id|unswap_by_read
c_func
(paren
id|map
comma
id|max
comma
id|start
comma
id|n_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|end
suffix:semicolon
id|ret
op_assign
id|SWAP_ADDR
c_func
(paren
id|start
)paren
suffix:semicolon
id|end
suffix:colon
multiline_comment|/* allow using swap device again */
id|stram_swap_info-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
id|up
c_func
(paren
op_amp
id|stram_swap_sem
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;get_stram_region: returning %p&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * free a reserved region in ST-RAM swap space&n; */
DECL|function|free_stram_region
r_static
r_void
id|free_stram_region
c_func
(paren
r_int
r_int
id|offset
comma
r_int
r_int
id|n_pages
)paren
(brace
r_int
r_int
op_star
id|map
op_assign
id|stram_swap_info-&gt;swap_map
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;free_stram_region(offset=%lu,n_pages=%lu)&bslash;n&quot;
comma
id|offset
comma
id|n_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
template_param
id|stram_swap_info-&gt;max
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;free_stram_region: Trying to free non-ST-RAM&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|stram_swap_info
)paren
suffix:semicolon
multiline_comment|/* un-reserve the freed pages */
r_for
c_loop
(paren
suffix:semicolon
id|n_pages
OG
l_int|0
suffix:semicolon
op_increment
id|offset
comma
op_decrement
id|n_pages
)paren
(brace
r_if
c_cond
(paren
id|map
(braket
id|offset
)braket
op_ne
id|SWAP_MAP_BAD
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;free_stram_region: Swap page %lu was not &quot;
l_string|&quot;reserved&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|map
(braket
id|offset
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* update swapping meta-data */
r_if
c_cond
(paren
id|offset
OL
id|stram_swap_info-&gt;lowest_bit
)paren
id|stram_swap_info-&gt;lowest_bit
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|n_pages
op_minus
l_int|1
OG
id|stram_swap_info-&gt;highest_bit
)paren
id|stram_swap_info-&gt;highest_bit
op_assign
id|offset
op_plus
id|n_pages
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|stram_swap_info-&gt;prio
OG
id|swap_info
(braket
id|swap_list.next
)braket
dot
id|prio
)paren
id|swap_list.next
op_assign
id|swap_list.head
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|n_pages
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|stram_swap_info
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&t;&t;&t;&t;&t;&t;Utility Functions for Swapping&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/* is addr in some of the allocated regions? */
DECL|function|in_some_region
r_static
r_int
id|in_some_region
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|BLOCK
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|alloc_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;start
op_le
id|addr
op_logical_and
id|addr
OL
id|p-&gt;start
op_plus
id|p-&gt;size
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_free_region
r_static
r_int
r_int
id|find_free_region
c_func
(paren
r_int
r_int
id|n_pages
comma
r_int
r_int
op_star
id|total_free
comma
r_int
r_int
op_star
id|region_free
)paren
(brace
r_int
r_int
op_star
id|map
op_assign
id|stram_swap_info-&gt;swap_map
suffix:semicolon
r_int
r_int
id|max
op_assign
id|stram_swap_info-&gt;max
suffix:semicolon
r_int
r_int
id|head
comma
id|tail
comma
id|max_start
suffix:semicolon
r_int
id|nfree
comma
id|max_free
suffix:semicolon
multiline_comment|/* first scan the swap space for a suitable place for the allocation */
id|head
op_assign
l_int|1
suffix:semicolon
id|max_start
op_assign
l_int|0
suffix:semicolon
id|max_free
op_assign
op_minus
l_int|1
suffix:semicolon
op_star
id|total_free
op_assign
l_int|0
suffix:semicolon
id|start_over
suffix:colon
multiline_comment|/* increment tail until final window size reached, and count free pages */
id|nfree
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|tail
op_assign
id|head
suffix:semicolon
id|tail
op_minus
id|head
OL
id|n_pages
op_logical_and
id|tail
OL
id|max
suffix:semicolon
op_increment
id|tail
)paren
(brace
r_if
c_cond
(paren
id|map
(braket
id|tail
)braket
op_eq
id|SWAP_MAP_BAD
)paren
(brace
id|head
op_assign
id|tail
op_plus
l_int|1
suffix:semicolon
r_goto
id|start_over
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|map
(braket
id|tail
)braket
)paren
(brace
op_increment
id|nfree
suffix:semicolon
op_increment
op_star
id|total_free
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tail
op_minus
id|head
OL
id|n_pages
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|nfree
OG
id|max_free
)paren
(brace
id|max_start
op_assign
id|head
suffix:semicolon
id|max_free
op_assign
id|nfree
suffix:semicolon
r_if
c_cond
(paren
id|max_free
op_ge
id|n_pages
)paren
multiline_comment|/* don&squot;t need more free pages... :-) */
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* now shift the window and look for the area where as much pages as&n;&t; * possible are free */
r_while
c_loop
(paren
id|tail
OL
id|max
)paren
(brace
id|nfree
op_sub_assign
(paren
id|map
(braket
id|head
op_increment
)braket
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
(braket
id|tail
)braket
op_eq
id|SWAP_MAP_BAD
)paren
(brace
id|head
op_assign
id|tail
op_plus
l_int|1
suffix:semicolon
r_goto
id|start_over
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|map
(braket
id|tail
)braket
)paren
(brace
op_increment
id|nfree
suffix:semicolon
op_increment
op_star
id|total_free
suffix:semicolon
)brace
op_increment
id|tail
suffix:semicolon
r_if
c_cond
(paren
id|nfree
OG
id|max_free
)paren
(brace
id|max_start
op_assign
id|head
suffix:semicolon
id|max_free
op_assign
id|nfree
suffix:semicolon
r_if
c_cond
(paren
id|max_free
op_ge
id|n_pages
)paren
multiline_comment|/* don&squot;t need more free pages... :-) */
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|max_free
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;get_stram_region: ST-RAM too full or fragmented &quot;
l_string|&quot;-- can&squot;t allocate %lu pages&bslash;n&quot;
comma
id|n_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|region_free
op_assign
id|max_free
suffix:semicolon
r_return
id|max_start
suffix:semicolon
)brace
multiline_comment|/* setup parameters from command line */
DECL|function|stram_swap_setup
r_void
id|__init
id|stram_swap_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|1
)paren
id|max_swap_size
op_assign
(paren
(paren
id|ints
(braket
l_int|1
)braket
OL
l_int|0
ques
c_cond
l_int|0
suffix:colon
id|ints
(braket
l_int|1
)braket
)paren
op_star
l_int|1024
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
)brace
"&f;"
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;&t;ST-RAM device&t;&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* ------------------------------------------------------------------------ */
DECL|variable|stram_blocksizes
r_static
r_int
id|stram_blocksizes
(braket
l_int|14
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|4096
)brace
suffix:semicolon
DECL|variable|stram_sizes
r_static
r_int
id|stram_sizes
(braket
l_int|14
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|refcnt
r_static
r_int
id|refcnt
op_assign
l_int|0
suffix:semicolon
DECL|function|do_stram_request
r_static
r_void
id|do_stram_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_void
op_star
id|start
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|INIT_REQUEST
suffix:semicolon
id|start
op_assign
id|swap_start
op_plus
(paren
id|CURRENT-&gt;sector
op_lshift
l_int|9
)paren
suffix:semicolon
id|len
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_plus
id|len
)paren
OG
id|swap_end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;stram: bad access beyond end of device: &quot;
l_string|&quot;block=%ld, count=%ld&bslash;n&quot;
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
(brace
id|memcpy
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|start
comma
id|len
)paren
suffix:semicolon
macro_line|#ifdef DO_PROC
id|stat_swap_read
op_add_assign
id|N_PAGES
c_func
(paren
id|len
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|start
comma
id|CURRENT-&gt;buffer
comma
id|len
)paren
suffix:semicolon
macro_line|#ifdef DO_PROC
id|stat_swap_write
op_add_assign
id|N_PAGES
c_func
(paren
id|len
)paren
suffix:semicolon
macro_line|#endif
)brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|stram_open
r_static
r_int
id|stram_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|filp
op_ne
id|MAGIC_FILE_P
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Only kernel can open ST-RAM device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ne
id|STRAM_MINOR
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|refcnt
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
op_increment
id|refcnt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|stram_release
r_static
r_int
id|stram_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|filp
op_ne
id|MAGIC_FILE_P
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Only kernel can close ST-RAM device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|refcnt
OG
l_int|0
)paren
op_decrement
id|refcnt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|stram_fops
r_static
r_struct
id|block_device_operations
id|stram_fops
op_assign
(brace
id|open
suffix:colon
id|stram_open
comma
id|release
suffix:colon
id|stram_release
comma
)brace
suffix:semicolon
DECL|function|stram_device_init
r_int
id|__init
id|stram_device_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_ATARI
)paren
multiline_comment|/* no point in initializing this, I hope */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_swap_size
)paren
multiline_comment|/* swapping not enabled */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|STRAM_MAJOR
comma
l_string|&quot;stram&quot;
comma
op_amp
id|stram_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;stram: Unable to get major %d&bslash;n&quot;
comma
id|STRAM_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|STRAM_MAJOR
)paren
comma
id|do_stram_request
)paren
suffix:semicolon
id|blksize_size
(braket
id|STRAM_MAJOR
)braket
op_assign
id|stram_blocksizes
suffix:semicolon
id|stram_sizes
(braket
id|STRAM_MINOR
)braket
op_assign
(paren
id|swap_end
op_minus
id|swap_start
)paren
op_div
l_int|1024
suffix:semicolon
id|blk_size
(braket
id|STRAM_MAJOR
)braket
op_assign
id|stram_sizes
suffix:semicolon
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|STRAM_MAJOR
comma
id|STRAM_MINOR
)paren
comma
l_int|1
comma
op_amp
id|stram_fops
comma
(paren
id|swap_end
op_minus
id|swap_start
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_STRAM_SWAP */
"&f;"
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;Misc Utility Functions&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/* reserve a range of pages */
DECL|function|reserve_region
r_static
r_void
id|reserve_region
c_func
(paren
r_void
op_star
id|start
comma
r_void
op_star
id|end
)paren
(brace
id|reserve_bootmem
(paren
id|virt_to_phys
c_func
(paren
id|start
)paren
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;  Region Management&t;&t;&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/* insert a region into the alloced list (sorted) */
DECL|function|add_region
r_static
id|BLOCK
op_star
id|add_region
c_func
(paren
r_void
op_star
id|addr
comma
r_int
r_int
id|size
)paren
(brace
id|BLOCK
op_star
op_star
id|p
comma
op_star
id|n
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_STATIC_BLOCKS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|static_blocks
(braket
id|i
)braket
dot
id|flags
op_amp
id|BLOCK_FREE
)paren
(brace
id|n
op_assign
op_amp
id|static_blocks
(braket
id|i
)braket
suffix:semicolon
id|n-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|n
op_logical_and
id|mem_init_done
)paren
(brace
multiline_comment|/* if statics block pool exhausted and we can call kmalloc() already&n;&t;&t; * (after mem_init()), try that */
id|n
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|BLOCK
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
id|n-&gt;flags
op_assign
id|BLOCK_KMALLOCED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Out of memory for ST-RAM descriptor blocks&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|n-&gt;start
op_assign
id|addr
suffix:semicolon
id|n-&gt;size
op_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|alloc_list
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|start
OG
id|addr
)paren
r_break
suffix:semicolon
id|n-&gt;next
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_assign
id|n
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/* find a region (by start addr) in the alloced list */
DECL|function|find_region
r_static
id|BLOCK
op_star
id|find_region
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|BLOCK
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|alloc_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;start
op_eq
id|addr
)paren
r_return
id|p
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;start
OG
id|addr
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* remove a block from the alloced list */
DECL|function|remove_region
r_static
r_int
id|remove_region
c_func
(paren
id|BLOCK
op_star
id|block
)paren
(brace
id|BLOCK
op_star
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|alloc_list
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|p
op_eq
id|block
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|p
op_assign
id|block-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|block-&gt;flags
op_amp
id|BLOCK_KMALLOCED
)paren
id|kfree
c_func
(paren
id|block
)paren
suffix:semicolon
r_else
id|block-&gt;flags
op_or_assign
id|BLOCK_FREE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
"&f;"
multiline_comment|/* ------------------------------------------------------------------------ */
multiline_comment|/*&t;&t;&t;&t;&t;&t; /proc statistics file stuff&t;&t;&t;&t;&t;&t;*/
multiline_comment|/* ------------------------------------------------------------------------ */
macro_line|#ifdef DO_PROC
DECL|macro|PRINT_PROC
mdefine_line|#define&t;PRINT_PROC(fmt,args...) len += sprintf( buf+len, fmt, ##args )
DECL|function|get_stram_list
r_int
id|get_stram_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|BLOCK
op_star
id|p
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|map
op_assign
id|stram_swap_info-&gt;swap_map
suffix:semicolon
r_int
r_int
id|max
op_assign
id|stram_swap_info-&gt;max
suffix:semicolon
r_int
id|free
op_assign
l_int|0
comma
id|used
op_assign
l_int|0
comma
id|rsvd
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_STRAM_SWAP
r_if
c_cond
(paren
id|max_swap_size
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|map
(braket
id|i
)braket
)paren
op_increment
id|free
suffix:semicolon
r_else
r_if
c_cond
(paren
id|map
(braket
id|i
)braket
op_eq
id|SWAP_MAP_BAD
)paren
op_increment
id|rsvd
suffix:semicolon
r_else
op_increment
id|used
suffix:semicolon
)brace
id|PRINT_PROC
c_func
(paren
l_string|&quot;Total ST-RAM:      %8u kB&bslash;n&quot;
l_string|&quot;Total ST-RAM swap: %8lu kB&bslash;n&quot;
l_string|&quot;Free swap:         %8u kB&bslash;n&quot;
l_string|&quot;Used swap:         %8u kB&bslash;n&quot;
l_string|&quot;Allocated swap:    %8u kB&bslash;n&quot;
l_string|&quot;Swap Reads:        %8u&bslash;n&quot;
l_string|&quot;Swap Writes:       %8u&bslash;n&quot;
l_string|&quot;Swap Forced Reads: %8u&bslash;n&quot;
comma
(paren
id|stram_end
op_minus
id|stram_start
)paren
op_rshift
l_int|10
comma
(paren
id|max
op_minus
l_int|1
)paren
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|free
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|used
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|rsvd
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|stat_swap_read
comma
id|stat_swap_write
comma
id|stat_swap_force
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
id|PRINT_PROC
c_func
(paren
l_string|&quot;ST-RAM swapping disabled&bslash;n&quot;
)paren
suffix:semicolon
id|PRINT_PROC
c_func
(paren
l_string|&quot;Total ST-RAM:      %8u kB&bslash;n&quot;
comma
(paren
id|stram_end
op_minus
id|stram_start
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_STRAM_SWAP
)brace
macro_line|#endif
id|PRINT_PROC
c_func
(paren
l_string|&quot;Allocated regions:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|alloc_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|len
op_plus
l_int|50
op_ge
id|PAGE_SIZE
)paren
r_break
suffix:semicolon
id|PRINT_PROC
c_func
(paren
l_string|&quot;0x%08lx-0x%08lx: %s (&quot;
comma
id|virt_to_phys
c_func
(paren
id|p-&gt;start
)paren
comma
id|virt_to_phys
c_func
(paren
id|p-&gt;start
op_plus
id|p-&gt;size
op_minus
l_int|1
)paren
comma
id|p-&gt;owner
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|BLOCK_GFP
)paren
id|PRINT_PROC
c_func
(paren
l_string|&quot;page-alloced)&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|BLOCK_INSWAP
)paren
id|PRINT_PROC
c_func
(paren
l_string|&quot;in swap)&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|PRINT_PROC
c_func
(paren
l_string|&quot;??)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Local variables:&n; *  c-indent-level: 4&n; *  tab-width: 4&n; * End:&n; */
eof
