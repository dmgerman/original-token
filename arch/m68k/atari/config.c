multiline_comment|/*&n; *  linux/atari/config.c&n; *&n; *  Copyright (C) 1994 Bj&#xfffd;rn Brauel&n; *&n; *  5/2/94 Roman Hodek:&n; *    Added setting of time_adj to get a better clock.&n; *&n; *  5/14/94 Roman Hodek:&n; *    gettod() for TT &n; *&n; *  5/15/94 Roman Hodek:&n; *    hard_reset_now() for Atari (and others?)&n; *&n; *  94/12/30 Andreas Schwab:&n; *    atari_sched_init fixed to get precise clock.&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file README.legal in the main directory of this archive&n; * for more details.&n; */
multiline_comment|/*&n; * Miscellaneous atari stuff&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atarihdreg.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
r_extern
r_void
id|atari_sched_init
c_func
(paren
id|isrfunc
)paren
suffix:semicolon
r_extern
r_int
id|atari_keyb_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|atari_kbdrate
(paren
r_struct
id|kbd_repeat
op_star
)paren
suffix:semicolon
r_extern
r_void
id|atari_kbd_leds
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|atari_init_INTS
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|atari_add_isr
(paren
r_int
r_int
comma
id|isrfunc
comma
r_int
comma
r_void
op_star
comma
r_char
op_star
)paren
suffix:semicolon
r_extern
r_int
id|atari_remove_isr
(paren
r_int
r_int
comma
id|isrfunc
)paren
suffix:semicolon
r_extern
r_void
id|atari_enable_irq
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|atari_disable_irq
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|atari_get_irq_list
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_int
r_int
id|atari_gettimeoffset
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|atari_mste_gettod
(paren
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
id|atari_gettod
(paren
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|atari_mste_hwclk
(paren
r_int
comma
r_struct
id|hwclk_time
op_star
)paren
suffix:semicolon
r_extern
r_int
id|atari_hwclk
(paren
r_int
comma
r_struct
id|hwclk_time
op_star
)paren
suffix:semicolon
r_extern
r_int
id|atari_mste_set_clock_mmss
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|atari_set_clock_mmss
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|atari_mksound
c_func
(paren
r_int
r_int
id|count
comma
r_int
r_int
id|ticks
)paren
suffix:semicolon
r_extern
r_void
id|atari_reset
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_FD
r_extern
r_int
id|atari_floppy_init
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|atari_floppy_setup
c_func
(paren
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|atari_waitbut
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|consw
id|fb_con
suffix:semicolon
r_extern
r_struct
id|fb_info
op_star
id|atari_fb_init
c_func
(paren
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
id|atari_debug_init
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|atari_video_setup
c_func
(paren
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|kd_mksound
)paren
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* This function tests for the presence of an address, specially a&n; * hardware register address. It is called very early in the kernel&n; * initialization process, when the VBR register isn&squot;t set up yet. On&n; * an Atari, it still points to address 0, which is unmapped. So a bus&n; * error would cause another bus error while fetching the exception&n; * vector, and the CPU would do nothing at all. So we needed to set up&n; * a temporary VBR and a vector table for the duration of the test.&n; */
DECL|function|hwreg_present
r_static
r_int
id|hwreg_present
c_func
(paren
r_volatile
r_void
op_star
id|regp
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|save_sp
comma
id|save_vbr
suffix:semicolon
r_int
id|tmp_vectors
(braket
l_int|3
)braket
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec&t;%/vbr,%2&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;#Lberr1,%4@(8)&bslash;n&bslash;t&quot;
l_string|&quot;movec&t;%4,%/vbr&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%/sp,%1&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%0&bslash;n&bslash;t&quot;
l_string|&quot;tstb&t;%3@&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#1,%0&bslash;n&quot;
l_string|&quot;Lberr1:&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%1,%/sp&bslash;n&bslash;t&quot;
l_string|&quot;movec&t;%2,%/vbr&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|save_sp
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|save_vbr
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|regp
)paren
comma
l_string|&quot;a&quot;
(paren
id|tmp_vectors
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|hwreg_present_bywrite
c_func
(paren
r_volatile
r_void
op_star
id|regp
comma
r_int
r_char
id|val
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|save_sp
comma
id|save_vbr
suffix:semicolon
r_static
r_int
id|tmp_vectors
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
(paren
r_int
)paren
op_logical_and
id|after_test
)brace
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec&t;%/vbr,%2&bslash;n&bslash;t&quot;
multiline_comment|/* save vbr value            */
l_string|&quot;movec&t;%4,%/vbr&bslash;n&bslash;t&quot;
multiline_comment|/* set up temporary vectors  */
l_string|&quot;movel&t;%/sp,%1&bslash;n&bslash;t&quot;
multiline_comment|/* save sp                   */
l_string|&quot;moveq&t;#0,%0&bslash;n&bslash;t&quot;
multiline_comment|/* assume not present        */
l_string|&quot;moveb&t;%5,%3@&bslash;n&bslash;t&quot;
multiline_comment|/* write the hardware reg    */
l_string|&quot;cmpb&t;%3@,%5&bslash;n&bslash;t&quot;
multiline_comment|/* compare it                */
l_string|&quot;seq&t;%0&quot;
multiline_comment|/* comes here only if reg    */
multiline_comment|/* is present                */
suffix:colon
l_string|&quot;=d&amp;&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=r&amp;&quot;
(paren
id|save_sp
)paren
comma
l_string|&quot;=r&amp;&quot;
(paren
id|save_vbr
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|regp
)paren
comma
l_string|&quot;r&quot;
(paren
id|tmp_vectors
)paren
comma
l_string|&quot;d&quot;
(paren
id|val
)paren
)paren
suffix:semicolon
id|after_test
suffix:colon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel&t;%0,%/sp&bslash;n&bslash;t&quot;
multiline_comment|/* restore sp                */
l_string|&quot;movec&t;%1,%/vbr&quot;
multiline_comment|/* restore vbr               */
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|save_sp
)paren
comma
l_string|&quot;r&quot;
(paren
id|save_vbr
)paren
suffix:colon
l_string|&quot;sp&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Basically the same, but writes a value into a word register, protected&n; * by a bus error handler */
DECL|function|hwreg_write
r_static
r_int
id|hwreg_write
c_func
(paren
r_volatile
r_void
op_star
id|regp
comma
r_int
r_int
id|val
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|save_sp
comma
id|save_vbr
suffix:semicolon
r_int
id|tmp_vectors
(braket
l_int|3
)braket
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movec&t;%/vbr,%2&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;#Lberr2,%4@(8)&bslash;n&bslash;t&quot;
l_string|&quot;movec&t;%4,%/vbr&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%/sp,%1&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%0&bslash;n&bslash;t&quot;
l_string|&quot;movew&t;%5,%3@&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&bslash;n&bslash;t&quot;
multiline_comment|/* If this nop isn&squot;t present, &squot;ret&squot; may already be&n;&t;&t;&t;&t; * loaded with 1 at the time the bus error&n;&t;&t;&t;&t; * happens! */
l_string|&quot;moveq&t;#1,%0&bslash;n&quot;
l_string|&quot;Lberr2:&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;%1,%/sp&bslash;n&bslash;t&quot;
l_string|&quot;movec&t;%2,%/vbr&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|save_sp
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|save_vbr
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|regp
)paren
comma
l_string|&quot;a&quot;
(paren
id|tmp_vectors
)paren
comma
l_string|&quot;g&quot;
(paren
id|val
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* ++roman: This is a more elaborate test for an SCC chip, since the plain&n; * Medusa board generates DTACK at the SCC&squot;s standard addresses, but a SCC&n; * board in the Medusa is possible. Also, the addresses where the ST_ESCC&n; * resides generate DTACK without the chip, too.&n; * The method is to write values into the interrupt vector register, that&n; * should be readable without trouble (from channel A!).&n; */
DECL|function|scc_test
r_static
r_int
id|scc_test
c_func
(paren
r_volatile
r_char
op_star
id|ctla
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hwreg_present
c_func
(paren
id|ctla
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
op_star
id|ctla
op_assign
l_int|2
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
op_star
id|ctla
op_assign
l_int|0x40
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
op_star
id|ctla
op_assign
l_int|2
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ctla
op_ne
l_int|0x40
)paren
r_return
l_int|0
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
op_star
id|ctla
op_assign
l_int|2
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
op_star
id|ctla
op_assign
l_int|0x60
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
op_star
id|ctla
op_assign
l_int|2
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ctla
op_ne
l_int|0x60
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|config_atari
r_void
id|config_atari
c_func
(paren
r_void
)paren
(brace
id|mach_sched_init
op_assign
id|atari_sched_init
suffix:semicolon
id|mach_keyb_init
op_assign
id|atari_keyb_init
suffix:semicolon
id|mach_kbdrate
op_assign
id|atari_kbdrate
suffix:semicolon
id|mach_kbd_leds
op_assign
id|atari_kbd_leds
suffix:semicolon
id|mach_init_INTS
op_assign
id|atari_init_INTS
suffix:semicolon
id|mach_add_isr
op_assign
id|atari_add_isr
suffix:semicolon
id|mach_remove_isr
op_assign
id|atari_remove_isr
suffix:semicolon
id|mach_enable_irq
op_assign
id|atari_enable_irq
suffix:semicolon
id|mach_disable_irq
op_assign
id|atari_disable_irq
suffix:semicolon
id|mach_get_irq_list
op_assign
id|atari_get_irq_list
suffix:semicolon
id|mach_gettimeoffset
op_assign
id|atari_gettimeoffset
suffix:semicolon
id|mach_mksound
op_assign
id|atari_mksound
suffix:semicolon
id|mach_reset
op_assign
id|atari_reset
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_FD
id|mach_floppy_init
op_assign
id|atari_floppy_init
suffix:semicolon
id|mach_floppy_setup
op_assign
id|atari_floppy_setup
suffix:semicolon
macro_line|#endif
id|conswitchp
op_assign
op_amp
id|fb_con
suffix:semicolon
id|waitbut
op_assign
id|atari_waitbut
suffix:semicolon
id|mach_fb_init
op_assign
id|atari_fb_init
suffix:semicolon
id|mach_max_dma_address
op_assign
l_int|0xffffff
suffix:semicolon
id|mach_debug_init
op_assign
id|atari_debug_init
suffix:semicolon
id|mach_video_setup
op_assign
id|atari_video_setup
suffix:semicolon
id|kd_mksound
op_assign
id|atari_mksound
suffix:semicolon
multiline_comment|/* ++bjoern: &n;     * Determine hardware present&n;     */
id|printk
c_func
(paren
l_string|&quot;Atari hardware found: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_medusa
)paren
(brace
multiline_comment|/* There&squot;s no Atari video hardware on the Medusa, but all the&n;         * addresses below generate a DTACK so no bus error occurs! */
)brace
r_else
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
id|f030_xreg
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|VIDEL_SHIFTER
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VIDEL &quot;
)paren
suffix:semicolon
multiline_comment|/* This is a temporary hack: If there is Falcon video&n;         * hardware, we assume that the ST-DMA serves SCSI instead of&n;         * ACSI. In the future, there should be a better method for&n;         * this...&n;         */
id|ATARIHW_SET
c_func
(paren
id|ST_SCSI
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STDMA-SCSI &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
id|tt_palette
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|TT_SHIFTER
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TT_SHIFTER &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|shifter.bas_hi
)paren
)paren
(brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|shifter.bas_lo
)paren
op_logical_and
(paren
id|shifter.bas_lo
op_assign
l_int|0x0aau
comma
id|shifter.bas_lo
op_eq
l_int|0x0aau
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|EXTD_SHIFTER
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EXTD_SHIFTER &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ATARIHW_SET
c_func
(paren
id|STND_SHIFTER
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STND_SHIFTER &quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|mfp.par_dt_reg
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|ST_MFP
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ST_MFP &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|tt_mfp.par_dt_reg
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|TT_MFP
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TT_MFP &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|tt_scsi_dma.dma_addr_hi
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|SCSI_DMA
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TT_SCSI_DMA &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|st_dma.dma_hi
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|STND_DMA
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STND_DMA &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_medusa
op_logical_or
multiline_comment|/* The ST-DMA address registers aren&squot;t readable&n;                      * on all Medusas, so the test below may fail */
(paren
id|hwreg_present
c_func
(paren
op_amp
id|st_dma.dma_vhi
)paren
op_logical_and
(paren
id|st_dma.dma_vhi
op_assign
l_int|0x55
)paren
op_logical_and
(paren
id|st_dma.dma_hi
op_assign
l_int|0xaa
)paren
op_logical_and
id|st_dma.dma_vhi
op_eq
l_int|0x55
op_logical_and
id|st_dma.dma_hi
op_eq
l_int|0xaa
op_logical_and
(paren
id|st_dma.dma_vhi
op_assign
l_int|0xaa
)paren
op_logical_and
(paren
id|st_dma.dma_hi
op_assign
l_int|0x55
)paren
op_logical_and
id|st_dma.dma_vhi
op_eq
l_int|0xaa
op_logical_and
id|st_dma.dma_hi
op_eq
l_int|0x55
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|EXTD_DMA
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EXTD_DMA &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|tt_scsi.scsi_data
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|TT_SCSI
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TT_SCSI &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|sound_ym.rd_data_reg_sel
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|YM_2149
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;YM2149 &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_medusa
op_logical_and
id|hwreg_present
c_func
(paren
op_amp
id|tt_dmasnd.ctrl
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|PCM_8BIT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCM &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
(paren
r_void
op_star
)paren
(paren
l_int|0xffff8940
)paren
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|CODEC
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CODEC &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|tt_scc_dma.dma_ctrl
)paren
op_logical_and
macro_line|#if 0
multiline_comment|/* This test sucks! Who knows some better? */
(paren
id|tt_scc_dma.dma_ctrl
op_assign
l_int|0x01
comma
(paren
id|tt_scc_dma.dma_ctrl
op_amp
l_int|1
)paren
op_eq
l_int|1
)paren
op_logical_and
(paren
id|tt_scc_dma.dma_ctrl
op_assign
l_int|0x00
comma
(paren
id|tt_scc_dma.dma_ctrl
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
macro_line|#else
op_logical_neg
id|is_medusa
macro_line|#endif
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|SCC_DMA
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCC_DMA &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc_test
c_func
(paren
op_amp
id|scc.cha_a_ctrl
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|SCC
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCC &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc_test
c_func
(paren
op_amp
id|st_escc.cha_b_ctrl
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|ST_ESCC
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ST_ESCC &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|tt_scu.sys_mask
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|SCU
)paren
suffix:semicolon
multiline_comment|/* Assume a VME bus if there&squot;s a SCU */
id|ATARIHW_SET
c_func
(paren
id|VME
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VME SCU &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
(paren
r_void
op_star
)paren
(paren
l_int|0xffff9210
)paren
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|ANALOG_JOY
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ANALOG_JOY &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
id|blitter.halftone
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|BLITTER
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BLITTER &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|ATA_HD_BASE
op_plus
id|ATA_HD_CMD
)paren
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|IDE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IDE &quot;
)paren
suffix:semicolon
)brace
macro_line|#if 1 /* This maybe wrong */
r_if
c_cond
(paren
op_logical_neg
id|is_medusa
op_logical_and
id|hwreg_present
c_func
(paren
op_amp
id|tt_microwire.data
)paren
op_logical_and
id|hwreg_present
c_func
(paren
op_amp
id|tt_microwire.mask
)paren
op_logical_and
(paren
id|tt_microwire.mask
op_assign
l_int|0x7ff
comma
id|tt_microwire.data
op_assign
id|MW_LM1992_PSG_HIGH
op_or
id|MW_LM1992_ADDR
comma
id|tt_microwire.data
op_ne
l_int|0
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|MICROWIRE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tt_microwire.mask
op_ne
l_int|0x7ff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MICROWIRE &quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|tt_rtc.regsel
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|TT_CLK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TT_CLK &quot;
)paren
suffix:semicolon
id|mach_gettod
op_assign
id|atari_gettod
suffix:semicolon
id|mach_hwclk
op_assign
id|atari_hwclk
suffix:semicolon
id|mach_set_clock_mmss
op_assign
id|atari_set_clock_mmss
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwreg_present
c_func
(paren
op_amp
id|mste_rtc.sec_ones
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|MSTE_CLK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSTE_CLK &quot;
)paren
suffix:semicolon
id|mach_gettod
op_assign
id|atari_mste_gettod
suffix:semicolon
id|mach_hwclk
op_assign
id|atari_mste_hwclk
suffix:semicolon
id|mach_set_clock_mmss
op_assign
id|atari_mste_set_clock_mmss
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_medusa
op_logical_and
id|hwreg_present
c_func
(paren
op_amp
id|dma_wd.fdc_speed
)paren
op_logical_and
id|hwreg_write
c_func
(paren
op_amp
id|dma_wd.fdc_speed
comma
l_int|0
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|FDCSPEED
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;FDC_SPEED &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ATARIHW_PRESENT
c_func
(paren
id|ST_SCSI
)paren
)paren
(brace
id|ATARIHW_SET
c_func
(paren
id|ACSI
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ACSI &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m68k_is040or060
)paren
multiline_comment|/* Now it seems to be safe to turn of the tt0 transparent&n;         * translation (the one that must not be turned off in&n;         * head.S...)&n;         */
id|__asm__
r_volatile
(paren
l_string|&quot;moveq #0,%/d0;&quot;
l_string|&quot;.long 0x4e7b0004;&quot;
multiline_comment|/* movec d0,itt0 */
l_string|&quot;.long 0x4e7b0006;&quot;
multiline_comment|/* movec d0,dtt0 */
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
multiline_comment|/* allocator for memory that must reside in st-ram */
id|atari_stram_init
(paren
)paren
suffix:semicolon
multiline_comment|/* Set up a mapping for the VMEbus address region:&n;     *&n;     * VME is either at phys. 0xfexxxxxx (TT) or 0xa00000..0xdfffff&n;     * (MegaSTE) In both cases, the whole 16 MB chunk is mapped at&n;     * 0xfe000000 virt., because this can be done with a single&n;     * transparent translation. On the 68040, lots of often unused&n;     * page tables would be needed otherwise. On a MegaSTE or similar,&n;     * the highest byte is stripped off by hardware due to the 24 bit&n;     * design of the bus.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|m68k_is040or060
)paren
(brace
r_int
r_int
id|tt1_val
suffix:semicolon
id|tt1_val
op_assign
l_int|0xfe008543
suffix:semicolon
multiline_comment|/* Translate 0xfexxxxxx, enable, cache&n;                                 * inhibit, read and write, FDC mask = 3,&n;                                 * FDC val = 4 -&gt; Supervisor only */
id|__asm__
id|__volatile__
(paren
l_string|&quot;pmove&t;%0@,%/tt1&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|tt1_val
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;.long 0x4e7b0005&bslash;n&bslash;t&quot;
multiline_comment|/* movec d0,itt1 */
l_string|&quot;.long 0x4e7b0007&quot;
multiline_comment|/* movec d0,dtt1 */
suffix:colon
suffix:colon
l_string|&quot;g&quot;
(paren
l_int|0xfe00a040
)paren
multiline_comment|/* Translate 0xfexxxxxx, enable,&n;                                         * supervisor only, non-cacheable/&n;                                         * serialized, writable */
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|atari_sched_init
r_void
id|atari_sched_init
(paren
id|isrfunc
id|timer_routine
)paren
(brace
multiline_comment|/* set Timer C data Register */
id|mfp.tim_dt_c
op_assign
id|INT_TICKS
suffix:semicolon
multiline_comment|/* start timer C, div = 1:100 */
id|mfp.tim_ct_cd
op_assign
(paren
id|mfp.tim_ct_cd
op_amp
l_int|15
)paren
op_or
l_int|0x60
suffix:semicolon
multiline_comment|/* install interrupt service routine for MFP Timer C */
id|add_isr
(paren
id|IRQ_MFP_TIMC
comma
id|timer_routine
comma
id|IRQ_TYPE_SLOW
comma
l_int|NULL
comma
l_string|&quot;timer&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ++andreas: gettimeoffset fixed to check for pending interrupt */
DECL|macro|TICK_SIZE
mdefine_line|#define TICK_SIZE 10000
multiline_comment|/* This is always executed with interrupts disabled.  */
DECL|function|atari_gettimeoffset
r_int
r_int
id|atari_gettimeoffset
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
comma
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* read MFP timer C current value */
id|ticks
op_assign
id|mfp.tim_dt_c
suffix:semicolon
multiline_comment|/* The probability of underflow is less than 2% */
r_if
c_cond
(paren
id|ticks
OG
id|INT_TICKS
op_minus
id|INT_TICKS
op_div
l_int|50
)paren
multiline_comment|/* Check for pending timer interrupt */
r_if
c_cond
(paren
id|mfp.int_pn_b
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
id|offset
op_assign
id|TICK_SIZE
suffix:semicolon
id|ticks
op_assign
id|INT_TICKS
op_minus
id|ticks
suffix:semicolon
id|ticks
op_assign
id|ticks
op_star
l_int|10000L
op_div
id|INT_TICKS
suffix:semicolon
r_return
id|ticks
op_plus
id|offset
suffix:semicolon
)brace
r_static
r_void
DECL|function|mste_read
id|mste_read
c_func
(paren
r_struct
id|MSTE_RTC
op_star
id|val
)paren
(brace
DECL|macro|COPY
mdefine_line|#define COPY(v) val-&gt;v=(mste_rtc.v &amp; 0xf)
r_do
(brace
id|COPY
c_func
(paren
id|sec_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|sec_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|min_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|min_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|hr_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|hr_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|weekday
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|day_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|day_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|mon_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|mon_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|year_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|year_tens
)paren
suffix:semicolon
multiline_comment|/* prevent from reading the clock while it changed */
)brace
r_while
c_loop
(paren
id|val-&gt;sec_ones
op_ne
(paren
id|mste_rtc.sec_ones
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
DECL|macro|COPY
macro_line|#undef COPY
)brace
r_static
r_void
DECL|function|mste_write
id|mste_write
c_func
(paren
r_struct
id|MSTE_RTC
op_star
id|val
)paren
(brace
DECL|macro|COPY
mdefine_line|#define COPY(v) mste_rtc.v=val-&gt;v
r_do
(brace
id|COPY
c_func
(paren
id|sec_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|sec_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|min_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|min_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|hr_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|hr_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|weekday
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|day_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|day_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|mon_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|mon_tens
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|year_ones
)paren
suffix:semicolon
id|COPY
c_func
(paren
id|year_tens
)paren
suffix:semicolon
multiline_comment|/* prevent from writing the clock while it changed */
)brace
r_while
c_loop
(paren
id|val-&gt;sec_ones
op_ne
(paren
id|mste_rtc.sec_ones
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
DECL|macro|COPY
macro_line|#undef COPY
)brace
DECL|macro|RTC_READ
mdefine_line|#define&t;RTC_READ(reg)&t;&t;&t;&t;&bslash;&n;    ({&t;unsigned char&t;__val;&t;&t;&t;&bslash;&n;&t;&t;outb(reg,&amp;tt_rtc.regsel);&t;&bslash;&n;&t;&t;__val = tt_rtc.data;&t;&t;&bslash;&n;&t;&t;__val;&t;&t;&t;&t;&bslash;&n;&t;})
DECL|macro|RTC_WRITE
mdefine_line|#define&t;RTC_WRITE(reg,val)&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;outb(reg,&amp;tt_rtc.regsel);&t;&bslash;&n;&t;&t;tt_rtc.data = (val);&t;&t;&bslash;&n;&t;} while(0)
DECL|function|atari_mste_gettod
r_void
id|atari_mste_gettod
(paren
r_int
op_star
id|yearp
comma
r_int
op_star
id|monp
comma
r_int
op_star
id|dayp
comma
r_int
op_star
id|hourp
comma
r_int
op_star
id|minp
comma
r_int
op_star
id|secp
)paren
(brace
r_int
id|hr24
op_assign
l_int|0
suffix:semicolon
r_struct
id|MSTE_RTC
id|val
suffix:semicolon
id|mste_rtc.mode
op_assign
(paren
id|mste_rtc.mode
op_or
l_int|1
)paren
suffix:semicolon
id|hr24
op_assign
id|mste_rtc.mon_tens
op_amp
l_int|1
suffix:semicolon
id|mste_rtc.mode
op_assign
(paren
id|mste_rtc.mode
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
id|mste_read
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
op_star
id|secp
op_assign
id|val.sec_ones
op_plus
id|val.sec_tens
op_star
l_int|10
suffix:semicolon
op_star
id|minp
op_assign
id|val.min_ones
op_plus
id|val.min_tens
op_star
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|hr24
)paren
op_star
id|hourp
op_assign
id|val.hr_ones
op_plus
id|val.hr_tens
op_star
l_int|10
suffix:semicolon
r_else
(brace
op_star
id|hourp
op_assign
id|val.hr_ones
op_plus
(paren
id|val.hr_tens
op_amp
l_int|1
)paren
op_star
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|val.hr_tens
op_amp
l_int|2
)paren
op_star
id|hourp
op_add_assign
l_int|12
suffix:semicolon
)brace
op_star
id|dayp
op_assign
id|val.day_ones
op_plus
id|val.day_tens
op_star
l_int|10
suffix:semicolon
op_star
id|monp
op_assign
id|val.mon_ones
op_plus
id|val.mon_tens
op_star
l_int|10
suffix:semicolon
op_star
id|yearp
op_assign
id|val.year_ones
op_plus
id|val.year_tens
op_star
l_int|10
op_plus
l_int|80
suffix:semicolon
)brace
DECL|function|atari_gettod
r_void
id|atari_gettod
(paren
r_int
op_star
id|yearp
comma
r_int
op_star
id|monp
comma
r_int
op_star
id|dayp
comma
r_int
op_star
id|hourp
comma
r_int
op_star
id|minp
comma
r_int
op_star
id|secp
)paren
(brace
r_int
r_char
id|ctrl
suffix:semicolon
r_int
r_int
id|tos_version
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|RTC_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
id|RTC_UIP
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|RTC_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
id|RTC_UIP
)paren
suffix:semicolon
op_star
id|secp
op_assign
id|RTC_READ
c_func
(paren
id|RTC_SECONDS
)paren
suffix:semicolon
op_star
id|minp
op_assign
id|RTC_READ
c_func
(paren
id|RTC_MINUTES
)paren
suffix:semicolon
op_star
id|hourp
op_assign
id|RTC_READ
c_func
(paren
id|RTC_HOURS
)paren
suffix:semicolon
op_star
id|dayp
op_assign
id|RTC_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
op_star
id|monp
op_assign
id|RTC_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
op_star
id|yearp
op_assign
id|RTC_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
id|ctrl
op_assign
id|RTC_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
op_star
id|secp
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
op_star
id|minp
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
op_star
id|hourp
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
op_star
id|dayp
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
op_star
id|monp
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
op_star
id|yearp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_24H
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|hourp
op_amp
l_int|0x80
)paren
(brace
op_star
id|hourp
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
op_star
id|hourp
op_add_assign
l_int|12
suffix:semicolon
)brace
)brace
multiline_comment|/* Adjust values (let the setup valid) */
multiline_comment|/* Fetch tos version at Physical 2 */
multiline_comment|/* We my not be able to access this address if the kernel is&n;       loaded to st ram, since the first page is unmapped.  On the&n;       Medusa this is always the case and there is nothing we can do&n;       about this, so we just assume the smaller offset.  For the TT&n;       we use the fact that in head.S we have set up a mapping&n;       0xFFxxxxxx -&gt; 0x00xxxxxx, so that the first 16MB is accessible&n;       in the last 16MB of the address space. */
id|tos_version
op_assign
id|is_medusa
ques
c_cond
l_int|0xfff
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
l_int|0xFF000002
suffix:semicolon
op_star
id|yearp
op_add_assign
(paren
id|tos_version
OL
l_int|0x306
)paren
ques
c_cond
l_int|70
suffix:colon
l_int|68
suffix:semicolon
)brace
DECL|macro|HWCLK_POLL_INTERVAL
mdefine_line|#define HWCLK_POLL_INTERVAL&t;5
DECL|function|atari_mste_hwclk
r_int
id|atari_mste_hwclk
c_func
(paren
r_int
id|op
comma
r_struct
id|hwclk_time
op_star
id|t
)paren
(brace
r_int
id|hour
comma
id|year
suffix:semicolon
r_int
id|hr24
op_assign
l_int|0
suffix:semicolon
r_struct
id|MSTE_RTC
id|val
suffix:semicolon
id|mste_rtc.mode
op_assign
(paren
id|mste_rtc.mode
op_or
l_int|1
)paren
suffix:semicolon
id|hr24
op_assign
id|mste_rtc.mon_tens
op_amp
l_int|1
suffix:semicolon
id|mste_rtc.mode
op_assign
(paren
id|mste_rtc.mode
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op
)paren
(brace
multiline_comment|/* write: prepare values */
id|val.sec_ones
op_assign
id|t-&gt;sec
op_mod
l_int|10
suffix:semicolon
id|val.sec_tens
op_assign
id|t-&gt;sec
op_div
l_int|10
suffix:semicolon
id|val.min_ones
op_assign
id|t-&gt;min
op_mod
l_int|10
suffix:semicolon
id|val.min_tens
op_assign
id|t-&gt;min
op_div
l_int|10
suffix:semicolon
id|hour
op_assign
id|t-&gt;hour
suffix:semicolon
id|val.hr_ones
op_assign
id|hour
op_mod
l_int|10
suffix:semicolon
id|val.hr_tens
op_assign
id|hour
op_div
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hr24
op_logical_and
id|hour
OG
l_int|11
)paren
(brace
id|hour
op_sub_assign
l_int|12
suffix:semicolon
id|val.hr_ones
op_assign
id|hour
op_mod
l_int|10
suffix:semicolon
id|val.hr_tens
op_assign
(paren
id|hour
op_div
l_int|10
)paren
op_or
l_int|2
suffix:semicolon
)brace
id|val.day_ones
op_assign
id|t-&gt;day
op_mod
l_int|10
suffix:semicolon
id|val.day_tens
op_assign
id|t-&gt;day
op_div
l_int|10
suffix:semicolon
id|val.mon_ones
op_assign
(paren
id|t-&gt;mon
op_plus
l_int|1
)paren
op_mod
l_int|10
suffix:semicolon
id|val.mon_tens
op_assign
(paren
id|t-&gt;mon
op_plus
l_int|1
)paren
op_div
l_int|10
suffix:semicolon
id|year
op_assign
id|t-&gt;year
op_minus
l_int|80
suffix:semicolon
id|val.year_ones
op_assign
id|year
op_mod
l_int|10
suffix:semicolon
id|val.year_tens
op_assign
id|year
op_div
l_int|10
suffix:semicolon
id|val.weekday
op_assign
id|t-&gt;wday
suffix:semicolon
id|mste_write
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|mste_rtc.mode
op_assign
(paren
id|mste_rtc.mode
op_or
l_int|1
)paren
suffix:semicolon
id|val.year_ones
op_assign
(paren
id|year
op_mod
l_int|4
)paren
suffix:semicolon
multiline_comment|/* leap year register */
id|mste_rtc.mode
op_assign
(paren
id|mste_rtc.mode
op_amp
op_complement
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|mste_read
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|t-&gt;sec
op_assign
id|val.sec_ones
op_plus
id|val.sec_tens
op_star
l_int|10
suffix:semicolon
id|t-&gt;min
op_assign
id|val.min_ones
op_plus
id|val.min_tens
op_star
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|hr24
)paren
id|t-&gt;hour
op_assign
id|val.hr_ones
op_plus
id|val.hr_tens
op_star
l_int|10
suffix:semicolon
r_else
(brace
id|t-&gt;hour
op_assign
id|val.hr_ones
op_plus
(paren
id|val.hr_tens
op_amp
l_int|1
)paren
op_star
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|val.hr_tens
op_amp
l_int|2
)paren
id|t-&gt;hour
op_add_assign
l_int|12
suffix:semicolon
)brace
id|t-&gt;day
op_assign
id|val.day_ones
op_plus
id|val.day_tens
op_star
l_int|10
suffix:semicolon
id|t-&gt;mon
op_assign
id|val.mon_ones
op_plus
id|val.mon_tens
op_star
l_int|10
op_minus
l_int|1
suffix:semicolon
id|t-&gt;year
op_assign
id|val.year_ones
op_plus
id|val.year_tens
op_star
l_int|10
op_plus
l_int|80
suffix:semicolon
id|t-&gt;wday
op_assign
id|val.weekday
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atari_hwclk
r_int
id|atari_hwclk
c_func
(paren
r_int
id|op
comma
r_struct
id|hwclk_time
op_star
id|t
)paren
(brace
r_int
id|sec
op_assign
l_int|0
comma
id|min
op_assign
l_int|0
comma
id|hour
op_assign
l_int|0
comma
id|day
op_assign
l_int|0
comma
id|mon
op_assign
l_int|0
comma
id|year
op_assign
l_int|0
comma
id|wday
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tos_version
suffix:semicolon
r_int
r_char
id|ctrl
suffix:semicolon
multiline_comment|/* Tos version at Physical 2.  See above for explanation why we&n;       cannot use PTOV(2).  */
id|tos_version
op_assign
id|is_medusa
ques
c_cond
l_int|0xfff
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
l_int|0xff000002
suffix:semicolon
id|ctrl
op_assign
id|RTC_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
multiline_comment|/* control registers are&n;                                   * independent from the UIP */
r_if
c_cond
(paren
id|op
)paren
(brace
multiline_comment|/* write: prepare values */
id|sec
op_assign
id|t-&gt;sec
suffix:semicolon
id|min
op_assign
id|t-&gt;min
suffix:semicolon
id|hour
op_assign
id|t-&gt;hour
suffix:semicolon
id|day
op_assign
id|t-&gt;day
suffix:semicolon
id|mon
op_assign
id|t-&gt;mon
op_plus
l_int|1
suffix:semicolon
id|year
op_assign
id|t-&gt;year
op_minus
(paren
(paren
id|tos_version
OL
l_int|0x306
)paren
ques
c_cond
l_int|70
suffix:colon
l_int|68
)paren
suffix:semicolon
id|wday
op_assign
id|t-&gt;wday
op_plus
(paren
id|t-&gt;wday
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_24H
)paren
op_logical_and
id|hour
OG
l_int|11
)paren
(brace
id|hour
op_sub_assign
l_int|12
suffix:semicolon
id|hour
op_or_assign
l_int|0x80
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
)paren
(brace
id|BIN_TO_BCD
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|hour
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|day
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|mon
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|year
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wday
op_ge
l_int|0
)paren
id|BIN_TO_BCD
c_func
(paren
id|wday
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reading/writing the clock registers is a bit critical due to&n;     * the regular update cycle of the RTC. While an update is in&n;     * progress, registers 0..9 shouldn&squot;t be touched.&n;     * The problem is solved like that: If an update is currently in&n;     * progress (the UIP bit is set), the process sleeps for a while&n;     * (50ms). This really should be enough, since the update cycle&n;     * normally needs 2 ms.&n;     * If the UIP bit reads as 0, we have at least 244 usecs until the&n;     * update starts. This should be enough... But to be sure,&n;     * additionally the RTC_SET bit is set to prevent an update cycle.&n;     */
r_while
c_loop
(paren
id|RTC_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
id|RTC_UIP
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HWCLK_POLL_INTERVAL
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|RTC_WRITE
c_func
(paren
id|RTC_CONTROL
comma
id|ctrl
op_or
id|RTC_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
id|sec
op_assign
id|RTC_READ
c_func
(paren
id|RTC_SECONDS
)paren
suffix:semicolon
id|min
op_assign
id|RTC_READ
c_func
(paren
id|RTC_MINUTES
)paren
suffix:semicolon
id|hour
op_assign
id|RTC_READ
c_func
(paren
id|RTC_HOURS
)paren
suffix:semicolon
id|day
op_assign
id|RTC_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|mon
op_assign
id|RTC_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
id|year
op_assign
id|RTC_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
id|wday
op_assign
id|RTC_READ
c_func
(paren
id|RTC_DAY_OF_WEEK
)paren
suffix:semicolon
)brace
r_else
(brace
id|RTC_WRITE
c_func
(paren
id|RTC_SECONDS
comma
id|sec
)paren
suffix:semicolon
id|RTC_WRITE
c_func
(paren
id|RTC_MINUTES
comma
id|min
)paren
suffix:semicolon
id|RTC_WRITE
c_func
(paren
id|RTC_HOURS
comma
id|hour
)paren
suffix:semicolon
id|RTC_WRITE
c_func
(paren
id|RTC_DAY_OF_MONTH
comma
id|day
)paren
suffix:semicolon
id|RTC_WRITE
c_func
(paren
id|RTC_MONTH
comma
id|mon
)paren
suffix:semicolon
id|RTC_WRITE
c_func
(paren
id|RTC_YEAR
comma
id|year
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wday
op_ge
l_int|0
)paren
id|RTC_WRITE
c_func
(paren
id|RTC_DAY_OF_WEEK
comma
id|wday
)paren
suffix:semicolon
)brace
id|RTC_WRITE
c_func
(paren
id|RTC_CONTROL
comma
id|ctrl
op_amp
op_complement
id|RTC_SET
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* read: adjust values */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|hour
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|day
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|mon
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|year
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|wday
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_24H
)paren
)paren
(brace
r_if
c_cond
(paren
id|hour
op_amp
l_int|0x80
)paren
(brace
id|hour
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
id|hour
op_add_assign
l_int|12
suffix:semicolon
)brace
)brace
id|t-&gt;sec
op_assign
id|sec
suffix:semicolon
id|t-&gt;min
op_assign
id|min
suffix:semicolon
id|t-&gt;hour
op_assign
id|hour
suffix:semicolon
id|t-&gt;day
op_assign
id|day
suffix:semicolon
id|t-&gt;mon
op_assign
id|mon
op_minus
l_int|1
suffix:semicolon
id|t-&gt;year
op_assign
id|year
op_plus
(paren
(paren
id|tos_version
OL
l_int|0x306
)paren
ques
c_cond
l_int|70
suffix:colon
l_int|68
)paren
suffix:semicolon
id|t-&gt;wday
op_assign
id|wday
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atari_mste_set_clock_mmss
r_int
id|atari_mste_set_clock_mmss
(paren
r_int
r_int
id|nowtime
)paren
(brace
r_int
id|real_seconds
op_assign
id|nowtime
op_mod
l_int|60
comma
id|real_minutes
op_assign
(paren
id|nowtime
op_div
l_int|60
)paren
op_mod
l_int|60
suffix:semicolon
r_struct
id|MSTE_RTC
id|val
suffix:semicolon
r_int
r_char
id|rtc_minutes
suffix:semicolon
id|mste_read
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|rtc_minutes
op_assign
id|val.min_ones
op_plus
id|val.min_tens
op_star
l_int|10
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rtc_minutes
OL
id|real_minutes
ques
c_cond
id|real_minutes
op_minus
id|rtc_minutes
suffix:colon
id|rtc_minutes
op_minus
id|real_minutes
)paren
OL
l_int|30
)paren
(brace
id|val.sec_ones
op_assign
id|real_seconds
op_mod
l_int|10
suffix:semicolon
id|val.sec_tens
op_assign
id|real_seconds
op_div
l_int|10
suffix:semicolon
id|val.min_ones
op_assign
id|real_minutes
op_mod
l_int|10
suffix:semicolon
id|val.min_tens
op_assign
id|real_minutes
op_div
l_int|10
suffix:semicolon
id|mste_write
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atari_set_clock_mmss
r_int
id|atari_set_clock_mmss
(paren
r_int
r_int
id|nowtime
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|real_seconds
op_assign
id|nowtime
op_mod
l_int|60
comma
id|real_minutes
op_assign
(paren
id|nowtime
op_div
l_int|60
)paren
op_mod
l_int|60
suffix:semicolon
r_int
r_char
id|save_control
comma
id|save_freq_select
comma
id|rtc_minutes
suffix:semicolon
id|save_control
op_assign
id|RTC_READ
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
multiline_comment|/* tell the clock it&squot;s being set */
id|RTC_WRITE
(paren
id|RTC_CONTROL
comma
id|save_control
op_or
id|RTC_SET
)paren
suffix:semicolon
id|save_freq_select
op_assign
id|RTC_READ
(paren
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
multiline_comment|/* stop and reset prescaler */
id|RTC_WRITE
(paren
id|RTC_FREQ_SELECT
comma
id|save_freq_select
op_or
id|RTC_DIV_RESET2
)paren
suffix:semicolon
id|rtc_minutes
op_assign
id|RTC_READ
(paren
id|RTC_MINUTES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|save_control
op_amp
id|RTC_DM_BINARY
)paren
)paren
id|BCD_TO_BIN
(paren
id|rtc_minutes
)paren
suffix:semicolon
multiline_comment|/* Since we&squot;re only adjusting minutes and seconds, don&squot;t interfere&n;       with hour overflow.  This avoids messing with unknown time zones&n;       but requires your RTC not to be off by more than 30 minutes.  */
r_if
c_cond
(paren
(paren
id|rtc_minutes
OL
id|real_minutes
ques
c_cond
id|real_minutes
op_minus
id|rtc_minutes
suffix:colon
id|rtc_minutes
op_minus
id|real_minutes
)paren
OL
l_int|30
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|save_control
op_amp
id|RTC_DM_BINARY
)paren
)paren
(brace
id|BIN_TO_BCD
(paren
id|real_seconds
)paren
suffix:semicolon
id|BIN_TO_BCD
(paren
id|real_minutes
)paren
suffix:semicolon
)brace
id|RTC_WRITE
(paren
id|RTC_SECONDS
comma
id|real_seconds
)paren
suffix:semicolon
id|RTC_WRITE
(paren
id|RTC_MINUTES
comma
id|real_minutes
)paren
suffix:semicolon
)brace
r_else
id|retval
op_assign
op_minus
l_int|1
suffix:semicolon
id|RTC_WRITE
(paren
id|RTC_FREQ_SELECT
comma
id|save_freq_select
)paren
suffix:semicolon
id|RTC_WRITE
(paren
id|RTC_CONTROL
comma
id|save_control
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|atari_waitbut
r_void
id|atari_waitbut
(paren
r_void
)paren
(brace
multiline_comment|/* sorry, no-op */
)brace
DECL|function|ata_mfp_out
r_static
r_inline
r_void
id|ata_mfp_out
(paren
r_char
id|c
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|mfp.trn_stat
op_amp
l_int|0x80
)paren
)paren
multiline_comment|/* wait for tx buf empty */
id|barrier
(paren
)paren
suffix:semicolon
id|mfp.usart_dta
op_assign
id|c
suffix:semicolon
)brace
DECL|function|ata_mfp_print
r_void
id|ata_mfp_print
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|str
suffix:semicolon
op_increment
id|str
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|ata_mfp_out
c_func
(paren
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
id|ata_mfp_out
c_func
(paren
op_star
id|str
)paren
suffix:semicolon
)brace
)brace
DECL|function|ata_scc_out
r_static
r_inline
r_void
id|ata_scc_out
(paren
r_char
id|c
)paren
(brace
r_do
(brace
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|scc.cha_b_ctrl
op_amp
l_int|0x04
)paren
)paren
suffix:semicolon
multiline_comment|/* wait for tx buf empty */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|scc.cha_b_data
op_assign
id|c
suffix:semicolon
)brace
DECL|function|ata_scc_print
r_void
id|ata_scc_print
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|str
suffix:semicolon
op_increment
id|str
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|ata_scc_out
c_func
(paren
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
id|ata_scc_out
c_func
(paren
op_star
id|str
)paren
suffix:semicolon
)brace
)brace
DECL|function|ata_par_out
r_static
r_int
id|ata_par_out
(paren
r_char
id|c
)paren
(brace
r_extern
r_int
r_int
id|loops_per_sec
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
multiline_comment|/* This a some-seconds timeout in case no printer is connected */
r_int
r_int
id|i
op_assign
id|loops_per_sec
OG
l_int|1
ques
c_cond
id|loops_per_sec
suffix:colon
l_int|10000000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mfp.par_dt_reg
op_amp
l_int|1
)paren
op_logical_and
op_decrement
id|i
)paren
(brace
multiline_comment|/* wait for BUSY == L */
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
id|sound_ym.rd_data_reg_sel
op_assign
l_int|15
suffix:semicolon
multiline_comment|/* select port B */
id|sound_ym.wd_data
op_assign
id|c
suffix:semicolon
multiline_comment|/* put char onto port */
id|sound_ym.rd_data_reg_sel
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* select port A */
id|tmp
op_assign
id|sound_ym.rd_data_reg_sel
suffix:semicolon
id|sound_ym.wd_data
op_assign
id|tmp
op_amp
op_complement
l_int|0x20
suffix:semicolon
multiline_comment|/* set strobe L */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a bit */
id|sound_ym.wd_data
op_assign
id|tmp
op_or
l_int|0x20
suffix:semicolon
multiline_comment|/* set strobe H */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ata_par_print
r_void
id|ata_par_print
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_static
r_int
id|printer_present
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|printer_present
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|str
suffix:semicolon
op_increment
id|str
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_if
c_cond
(paren
op_logical_neg
id|ata_par_out
c_func
(paren
l_char|&squot;&bslash;r&squot;
)paren
)paren
(brace
id|printer_present
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ata_par_out
c_func
(paren
op_star
id|str
)paren
)paren
(brace
id|printer_present
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
DECL|function|atari_debug_init
r_void
id|atari_debug_init
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
(paren
op_star
id|debug_print_proc
)paren
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_extern
r_char
id|m68k_debug_device
(braket
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser&quot;
)paren
)paren
(brace
multiline_comment|/* defaults to ser2 for a Falcon and ser1 otherwise */
id|strcpy
c_func
(paren
id|m68k_debug_device
comma
(paren
(paren
id|boot_info.bi_atari.mch_cookie
op_rshift
l_int|16
)paren
op_eq
id|ATARI_MCH_FALCON
)paren
ques
c_cond
l_string|&quot;ser2&quot;
suffix:colon
l_string|&quot;ser1&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser1&quot;
)paren
)paren
(brace
multiline_comment|/* ST-MFP Modem1 serial port */
id|mfp.trn_stat
op_and_assign
op_complement
l_int|0x01
suffix:semicolon
multiline_comment|/* disable TX */
id|mfp.usart_ctr
op_assign
l_int|0x88
suffix:semicolon
multiline_comment|/* clk 1:16, 8N1 */
id|mfp.tim_ct_cd
op_and_assign
l_int|0x70
suffix:semicolon
multiline_comment|/* stop timer D */
id|mfp.tim_dt_d
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 9600 bps */
id|mfp.tim_ct_cd
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* start timer D, 1:4 */
id|mfp.trn_stat
op_or_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* enable TX */
id|debug_print_proc
op_assign
id|ata_mfp_print
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;ser2&quot;
)paren
)paren
(brace
multiline_comment|/* SCC Modem2 serial port */
r_static
r_int
r_char
op_star
id|p
comma
id|scc_table
(braket
)braket
op_assign
(brace
l_int|9
comma
l_int|12
comma
multiline_comment|/* Reset */
l_int|4
comma
l_int|0x44
comma
multiline_comment|/* x16, 1 stopbit, no parity */
l_int|3
comma
l_int|0xc0
comma
multiline_comment|/* receiver: 8 bpc */
l_int|5
comma
l_int|0xe2
comma
multiline_comment|/* transmitter: 8 bpc, assert dtr/rts */
l_int|9
comma
l_int|0
comma
multiline_comment|/* no interrupts */
l_int|10
comma
l_int|0
comma
multiline_comment|/* NRZ */
l_int|11
comma
l_int|0x50
comma
multiline_comment|/* use baud rate generator */
l_int|12
comma
l_int|24
comma
l_int|13
comma
l_int|0
comma
multiline_comment|/* 9600 baud */
l_int|14
comma
l_int|2
comma
l_int|14
comma
l_int|3
comma
multiline_comment|/* use master clock for BRG, enable */
l_int|3
comma
l_int|0xc1
comma
multiline_comment|/* enable receiver */
l_int|5
comma
l_int|0xea
comma
multiline_comment|/* enable transmitter */
l_int|0
)brace
suffix:semicolon
(paren
r_void
)paren
id|scc.cha_b_ctrl
suffix:semicolon
multiline_comment|/* reset reg pointer */
r_for
c_loop
(paren
id|p
op_assign
id|scc_table
suffix:semicolon
op_star
id|p
op_ne
l_int|0
suffix:semicolon
)paren
(brace
id|scc.cha_b_ctrl
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|scc.cha_b_ctrl
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
id|debug_print_proc
op_assign
id|ata_scc_print
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|m68k_debug_device
comma
l_string|&quot;par&quot;
)paren
)paren
(brace
multiline_comment|/* parallel printer */
id|atari_turnoff_irq
c_func
(paren
id|IRQ_MFP_BUSY
)paren
suffix:semicolon
multiline_comment|/* avoid ints */
id|sound_ym.rd_data_reg_sel
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* select mixer control */
id|sound_ym.wd_data
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* sound off, ports are output */
id|sound_ym.rd_data_reg_sel
op_assign
l_int|15
suffix:semicolon
multiline_comment|/* select port B */
id|sound_ym.wd_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no char */
id|sound_ym.rd_data_reg_sel
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* select port A */
id|sound_ym.wd_data
op_assign
id|sound_ym.rd_data_reg_sel
op_or
l_int|0x20
suffix:semicolon
multiline_comment|/* strobe H */
id|debug_print_proc
op_assign
id|ata_par_print
suffix:semicolon
)brace
r_else
id|debug_print_proc
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|ata_serial_print
r_void
id|ata_serial_print
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_int
id|c
suffix:semicolon
r_while
c_loop
(paren
id|c
op_assign
op_star
id|str
op_increment
comma
id|c
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|mfp.trn_stat
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
)paren
id|barrier
(paren
)paren
suffix:semicolon
id|mfp.usart_dta
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|mfp.trn_stat
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
)paren
id|barrier
(paren
)paren
suffix:semicolon
id|mfp.usart_dta
op_assign
id|c
suffix:semicolon
)brace
)brace
multiline_comment|/* ++roman:&n; *&n; * This function does a reset on machines that lack the ability to&n; * assert the processor&squot;s _RESET signal somehow via hardware. It is&n; * based on the fact that you can find the initial SP and PC values&n; * after a reset at physical addresses 0 and 4. This works pretty well&n; * for Atari machines, since the lowest 8 bytes of physical memory are&n; * really ROM (mapped by hardware). For other 680x0 machines: don&squot;t&n; * know if it works...&n; *&n; * To get the values at addresses 0 and 4, the MMU better is turned&n; * off first. After that, we have to jump into physical address space&n; * (the PC before the pmove statement points to the virtual address of&n; * the code). Getting that physical address is not hard, but the code&n; * becomes a bit complex since I&squot;ve tried to ensure that the jump&n; * statement after the pmove is in the cache already (otherwise the&n; * processor can&squot;t fetch it!). For that, the code first jumps to the&n; * jump statement with the (virtual) address of the pmove section in&n; * an address register . The jump statement is surely in the cache&n; * now. After that, that physical address of the reset code is loaded&n; * into the same address register, pmove is done and the same jump&n; * statements goes to the reset code. Since there are not many&n; * statements between the two jumps, I hope it stays in the cache.&n; *&n; * The C code makes heavy use of the GCC features that you can get the&n; * address of a C label. No hope to compile this with another compiler&n; * than GCC!&n; */
multiline_comment|/* ++andreas: no need for complicated code, just depend on prefetch */
DECL|function|atari_reset
r_void
id|atari_reset
(paren
r_void
)paren
(brace
r_int
id|tc_val
op_assign
l_int|0
suffix:semicolon
r_int
id|reset_addr
suffix:semicolon
multiline_comment|/* On the Medusa, phys. 0x4 may contain garbage because it&squot;s no&n;       ROM.  See above for explanation why we cannot use PTOV(4). */
id|reset_addr
op_assign
id|is_medusa
ques
c_cond
l_int|0xe00030
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
l_int|0xff000004
suffix:semicolon
id|acia.key_ctrl
op_assign
id|ACIA_RESET
suffix:semicolon
multiline_comment|/* reset ACIA for switch off OverScan, if it&squot;s active */
multiline_comment|/* processor independent: turn off interrupts and reset the VBR;&n;     * the caches must be left enabled, else prefetching the final jump&n;     * instruction doesn&squot;t work. */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;moveq&t;#0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec&t;%/d0,%/vbr&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m68k_is040or060
)paren
(brace
r_int
r_int
id|jmp_addr040
op_assign
id|VTOP
c_func
(paren
op_logical_and
id|jmp_addr_label040
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m68k_is040or060
op_eq
l_int|6
)paren
(brace
multiline_comment|/* 68060: clear PCR to turn off superscalar operation */
id|__asm__
id|__volatile__
(paren
l_string|&quot;moveq&t;#0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;.long&t;0x4e7b0808&quot;
multiline_comment|/* movec d0,pcr */
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel    %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;andl     #0xff000000,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;orw      #0xe020,%/d0&bslash;n&bslash;t&quot;
multiline_comment|/* map 16 MB, enable, cacheable */
l_string|&quot;.long    0x4e7b0004&bslash;n&bslash;t&quot;
multiline_comment|/* movec d0,itt0 */
l_string|&quot;.long    0x4e7b0006&bslash;n&bslash;t&quot;
multiline_comment|/* movec d0,dtt0 */
l_string|&quot;jmp   %0@&bslash;n&bslash;t&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;a&quot;
(paren
id|jmp_addr040
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
id|jmp_addr_label040
suffix:colon
id|__asm__
id|__volatile__
(paren
l_string|&quot;moveq #0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;.word 0xf4d8&bslash;n&bslash;t&quot;
multiline_comment|/* cinva i/d */
l_string|&quot;.word 0xf518&bslash;n&bslash;t&quot;
multiline_comment|/* pflusha */
l_string|&quot;.long 0x4e7b0003&bslash;n&bslash;t&quot;
multiline_comment|/* movec d0,tc */
l_string|&quot;jmp %0@&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;a&quot;
(paren
id|reset_addr
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
r_else
id|__asm__
id|__volatile__
(paren
l_string|&quot;pmove %0@,%/tc&bslash;n&bslash;t&quot;
l_string|&quot;jmp %1@&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|tc_val
)paren
comma
l_string|&quot;a&quot;
(paren
id|reset_addr
)paren
)paren
suffix:semicolon
)brace
DECL|function|atari_get_model
r_void
id|atari_get_model
c_func
(paren
r_char
op_star
id|model
)paren
(brace
id|strcpy
c_func
(paren
id|model
comma
l_string|&quot;Atari &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|boot_info.bi_atari.mch_cookie
op_rshift
l_int|16
)paren
(brace
r_case
id|ATARI_MCH_ST
suffix:colon
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|MSTE_CLK
)paren
)paren
id|strcat
(paren
id|model
comma
l_string|&quot;Mega ST&quot;
)paren
suffix:semicolon
r_else
id|strcat
(paren
id|model
comma
l_string|&quot;ST&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATARI_MCH_STE
suffix:colon
r_if
c_cond
(paren
(paren
id|boot_info.bi_atari.mch_cookie
op_amp
l_int|0xffff
)paren
op_eq
l_int|0x10
)paren
id|strcat
(paren
id|model
comma
l_string|&quot;Mega STE&quot;
)paren
suffix:semicolon
r_else
id|strcat
(paren
id|model
comma
l_string|&quot;STE&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATARI_MCH_TT
suffix:colon
r_if
c_cond
(paren
id|is_medusa
)paren
multiline_comment|/* Medusa has TT _MCH cookie */
id|strcat
(paren
id|model
comma
l_string|&quot;Medusa&quot;
)paren
suffix:semicolon
r_else
id|strcat
(paren
id|model
comma
l_string|&quot;TT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATARI_MCH_FALCON
suffix:colon
id|strcat
(paren
id|model
comma
l_string|&quot;Falcon&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sprintf
(paren
id|model
op_plus
id|strlen
(paren
id|model
)paren
comma
l_string|&quot;(unknown mach cookie 0x%lx)&quot;
comma
id|boot_info.bi_atari.mch_cookie
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|atari_get_hardware_list
r_int
id|atari_get_hardware_list
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
id|len
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_info.num_memory
suffix:semicolon
id|i
op_increment
)paren
id|len
op_add_assign
id|sprintf
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;t%3ld MB at 0x%08lx (%s)&bslash;n&quot;
comma
id|boot_info.memory
(braket
id|i
)braket
dot
id|size
op_rshift
l_int|20
comma
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
comma
(paren
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
op_amp
l_int|0xff000000
ques
c_cond
l_string|&quot;alternate RAM&quot;
suffix:colon
l_string|&quot;ST-RAM&quot;
)paren
)paren
suffix:semicolon
DECL|macro|ATARIHW_ANNOUNCE
mdefine_line|#define ATARIHW_ANNOUNCE(name,str)&t;&t;&t;&t;&bslash;&n;    if (ATARIHW_PRESENT(name))&t;&t;&t;&bslash;&n;&t;len += sprintf (buffer + len, &quot;&bslash;t%s&bslash;n&quot;, str)
id|len
op_add_assign
id|sprintf
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Detected hardware:&bslash;n&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|STND_SHIFTER
comma
l_string|&quot;ST Shifter&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|EXTD_SHIFTER
comma
l_string|&quot;STe Shifter&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|TT_SHIFTER
comma
l_string|&quot;TT Shifter&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|VIDEL_SHIFTER
comma
l_string|&quot;Falcon Shifter&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|YM_2149
comma
l_string|&quot;Programmable Sound Generator&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|PCM_8BIT
comma
l_string|&quot;PCM 8 Bit Sound&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|CODEC
comma
l_string|&quot;CODEC Sound&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|TT_SCSI
comma
l_string|&quot;SCSI Controller NCR5380 (TT style)&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|ST_SCSI
comma
l_string|&quot;SCSI Controller NCR5380 (Falcon style)&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|ACSI
comma
l_string|&quot;ACSI Interface&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|IDE
comma
l_string|&quot;IDE Interface&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|FDCSPEED
comma
l_string|&quot;8/16 Mhz Switch for FDC&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|ST_MFP
comma
l_string|&quot;Multi Function Peripheral MFP 68901&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|TT_MFP
comma
l_string|&quot;Second Multi Function Peripheral MFP 68901&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|SCC
comma
l_string|&quot;Serial Communications Controller SCC 8530&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|ST_ESCC
comma
l_string|&quot;Extended Serial Communications Controller SCC 85230&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|ANALOG_JOY
comma
l_string|&quot;Paddle Interface&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|MICROWIRE
comma
l_string|&quot;MICROWIRE(tm) Interface&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|STND_DMA
comma
l_string|&quot;DMA Controller (24 bit)&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|EXTD_DMA
comma
l_string|&quot;DMA Controller (32 bit)&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|SCSI_DMA
comma
l_string|&quot;DMA Controller for NCR5380&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|SCC_DMA
comma
l_string|&quot;DMA Controller for SCC&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|TT_CLK
comma
l_string|&quot;Clock Chip MC146818A&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|MSTE_CLK
comma
l_string|&quot;Clock Chip RP5C15&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|SCU
comma
l_string|&quot;System Control Unit&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|BLITTER
comma
l_string|&quot;Blitter&quot;
)paren
suffix:semicolon
id|ATARIHW_ANNOUNCE
c_func
(paren
id|VME
comma
l_string|&quot;VME Bus&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
eof
