multiline_comment|/*&n; *  linux/arch/m68k/mm/memory.c&n; *&n; *  Copyright (C) 1995  Hamish Macdonald&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
r_extern
id|pte_t
op_star
id|kernel_page_table
(paren
r_int
r_int
op_star
id|memavailp
)paren
suffix:semicolon
multiline_comment|/* Strings for `extern inline&squot; functions in &lt;asm/pgtable.h&gt;.  If put&n;   directly into these functions, they are output for every file that&n;   includes pgtable.h */
DECL|variable|PgtabStr_bad_pmd
r_const
r_char
id|PgtabStr_bad_pmd
(braket
)braket
op_assign
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
suffix:semicolon
DECL|variable|PgtabStr_bad_pgd
r_const
r_char
id|PgtabStr_bad_pgd
(braket
)braket
op_assign
l_string|&quot;Bad pgd in pmd_alloc: %08lx&bslash;n&quot;
suffix:semicolon
DECL|variable|PgtabStr_bad_pmdk
r_const
r_char
id|PgtabStr_bad_pmdk
(braket
)braket
op_assign
l_string|&quot;Bad pmd in pte_alloc_kernel: %08lx&bslash;n&quot;
suffix:semicolon
DECL|variable|PgtabStr_bad_pgdk
r_const
r_char
id|PgtabStr_bad_pgdk
(braket
)braket
op_assign
l_string|&quot;Bad pgd in pmd_alloc_kernel: %08lx&bslash;n&quot;
suffix:semicolon
DECL|struct|ptable_desc
r_static
r_struct
id|ptable_desc
(brace
DECL|member|prev
r_struct
id|ptable_desc
op_star
id|prev
suffix:semicolon
DECL|member|next
r_struct
id|ptable_desc
op_star
id|next
suffix:semicolon
DECL|member|page
r_int
r_int
id|page
suffix:semicolon
DECL|member|alloced
r_int
r_char
id|alloced
suffix:semicolon
DECL|variable|ptable_list
)brace
id|ptable_list
op_assign
(brace
op_amp
id|ptable_list
comma
op_amp
id|ptable_list
comma
l_int|0
comma
l_int|0xff
)brace
suffix:semicolon
DECL|macro|PD_NONEFREE
mdefine_line|#define PD_NONEFREE(dp) ((dp)-&gt;alloced == 0xff)
DECL|macro|PD_ALLFREE
mdefine_line|#define PD_ALLFREE(dp) ((dp)-&gt;alloced == 0)
DECL|macro|PD_TABLEFREE
mdefine_line|#define PD_TABLEFREE(dp,i) (!((dp)-&gt;alloced &amp; (1&lt;&lt;(i))))
DECL|macro|PD_MARKUSED
mdefine_line|#define PD_MARKUSED(dp,i) ((dp)-&gt;alloced |= (1&lt;&lt;(i)))
DECL|macro|PD_MARKFREE
mdefine_line|#define PD_MARKFREE(dp,i) ((dp)-&gt;alloced &amp;= ~(1&lt;&lt;(i)))
DECL|macro|PTABLE_SIZE
mdefine_line|#define PTABLE_SIZE (PTRS_PER_PMD * sizeof(pmd_t))
DECL|function|get_pointer_table
id|pmd_t
op_star
id|get_pointer_table
(paren
r_void
)paren
(brace
id|pmd_t
op_star
id|pmdp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ptable_desc
op_star
id|dp
op_assign
id|ptable_list.next
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * For a pointer table for a user process address space, a&n;&t; * table is taken from a page allocated for the purpose.  Each&n;&t; * page can hold 8 pointer tables.  The page is remapped in&n;&t; * virtual address space to be noncacheable.&n;&t; */
r_if
c_cond
(paren
id|PD_NONEFREE
(paren
id|dp
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dp
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|ptable_desc
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dp-&gt;page
op_assign
id|get_free_page
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|kfree
(paren
id|dp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|flush_tlb_kernel_page
c_func
(paren
(paren
r_int
r_int
)paren
id|dp-&gt;page
)paren
suffix:semicolon
id|nocache_page
(paren
id|dp-&gt;page
)paren
suffix:semicolon
id|dp-&gt;alloced
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* put at head of list */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;next
op_assign
id|ptable_list.next
suffix:semicolon
id|dp-&gt;prev
op_assign
id|ptable_list.next-&gt;prev
suffix:semicolon
id|ptable_list.next-&gt;prev
op_assign
id|dp
suffix:semicolon
id|ptable_list.next
op_assign
id|dp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|PD_TABLEFREE
(paren
id|dp
comma
id|i
)paren
)paren
(brace
id|PD_MARKUSED
(paren
id|dp
comma
id|i
)paren
suffix:semicolon
id|pmdp
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|dp-&gt;page
op_plus
id|PTABLE_SIZE
op_star
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PD_NONEFREE
(paren
id|dp
)paren
)paren
(brace
multiline_comment|/* move to end of list */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;prev-&gt;next
op_assign
id|dp-&gt;next
suffix:semicolon
id|dp-&gt;next-&gt;prev
op_assign
id|dp-&gt;prev
suffix:semicolon
id|dp-&gt;next
op_assign
id|ptable_list.next-&gt;prev
suffix:semicolon
id|dp-&gt;prev
op_assign
id|ptable_list.prev
suffix:semicolon
id|ptable_list.prev-&gt;next
op_assign
id|dp
suffix:semicolon
id|ptable_list.prev
op_assign
id|dp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|memset
(paren
id|pmdp
comma
l_int|0
comma
id|PTABLE_SIZE
)paren
suffix:semicolon
r_return
id|pmdp
suffix:semicolon
)brace
DECL|function|free_pointer_table
r_void
id|free_pointer_table
(paren
id|pmd_t
op_star
id|ptable
)paren
(brace
r_struct
id|ptable_desc
op_star
id|dp
suffix:semicolon
r_int
r_int
id|page
op_assign
(paren
r_int
r_int
)paren
id|ptable
op_amp
id|PAGE_MASK
suffix:semicolon
r_int
id|index
op_assign
(paren
(paren
r_int
r_int
)paren
id|ptable
op_minus
id|page
)paren
op_div
id|PTABLE_SIZE
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|dp
op_assign
id|ptable_list.next
suffix:semicolon
id|dp-&gt;page
op_logical_and
id|dp-&gt;page
op_ne
id|page
suffix:semicolon
id|dp
op_assign
id|dp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dp-&gt;page
)paren
id|panic
(paren
l_string|&quot;unable to find desc for ptable %p on list!&quot;
comma
id|ptable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PD_TABLEFREE
(paren
id|dp
comma
id|index
)paren
)paren
id|panic
(paren
l_string|&quot;table already free!&quot;
)paren
suffix:semicolon
id|PD_MARKFREE
(paren
id|dp
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PD_ALLFREE
(paren
id|dp
)paren
)paren
(brace
multiline_comment|/* all tables in page are free, free page */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;prev-&gt;next
op_assign
id|dp-&gt;next
suffix:semicolon
id|dp-&gt;next-&gt;prev
op_assign
id|dp-&gt;prev
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cache_page
(paren
id|dp-&gt;page
)paren
suffix:semicolon
id|free_page
(paren
id|dp-&gt;page
)paren
suffix:semicolon
id|kfree
(paren
id|dp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * move this descriptor the the front of the list, since&n;&t;&t; * it has one or more free tables.&n;&t;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;prev-&gt;next
op_assign
id|dp-&gt;next
suffix:semicolon
id|dp-&gt;next-&gt;prev
op_assign
id|dp-&gt;prev
suffix:semicolon
id|dp-&gt;next
op_assign
id|ptable_list.next
suffix:semicolon
id|dp-&gt;prev
op_assign
id|ptable_list.next-&gt;prev
suffix:semicolon
id|ptable_list.next-&gt;prev
op_assign
id|dp
suffix:semicolon
id|ptable_list.next
op_assign
id|dp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* maximum pages used for kpointer tables */
DECL|macro|KPTR_PAGES
mdefine_line|#define KPTR_PAGES      4
multiline_comment|/* # of reserved slots */
DECL|macro|RESERVED_KPTR
mdefine_line|#define RESERVED_KPTR&t;4
r_extern
id|pmd_tablepage
id|kernel_pmd_table
suffix:semicolon
multiline_comment|/* reserved in head.S */
DECL|struct|kpointer_pages
r_static
r_struct
id|kpointer_pages
(brace
DECL|member|page
id|pmd_tablepage
op_star
id|page
(braket
id|KPTR_PAGES
)braket
suffix:semicolon
DECL|member|alloced
id|u_char
id|alloced
(braket
id|KPTR_PAGES
)braket
suffix:semicolon
DECL|variable|kptr_pages
)brace
id|kptr_pages
suffix:semicolon
DECL|function|init_kpointer_table
r_void
id|init_kpointer_table
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
id|KPTR_PAGES
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* first page is reserved in head.S */
id|kptr_pages.page
(braket
id|i
)braket
op_assign
op_amp
id|kernel_pmd_table
suffix:semicolon
id|kptr_pages.alloced
(braket
id|i
)braket
op_assign
op_complement
(paren
l_int|0xff
op_rshift
id|RESERVED_KPTR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_decrement
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|kptr_pages.page
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kptr_pages.alloced
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|get_kpointer_table
id|pmd_t
op_star
id|get_kpointer_table
(paren
r_void
)paren
(brace
multiline_comment|/* For pointer tables for the kernel virtual address space,&n;&t; * use the page that is reserved in head.S that can hold up to&n;&t; * 8 pointer tables. 3 of these tables are always reserved&n;&t; * (kernel_pg_dir, swapper_pg_dir and kernel pointer table for&n;&t; * the first 16 MB of RAM). In addition, the 4th pointer table&n;&t; * in this page is reserved. On Amiga and Atari, it is used to&n;&t; * map in the hardware registers. It may be used for other&n;&t; * purposes on other 68k machines. This leaves 4 pointer tables&n;&t; * available for use by the kernel. 1 of them are usually used&n;&t; * for the vmalloc tables. This allows mapping of 3 * 32 = 96 MB&n;&t; * of physical memory. But these pointer tables are also used&n;&t; * for other purposes, like kernel_map(), so further pages can&n;&t; * now be allocated.&n;&t; */
id|pmd_tablepage
op_star
id|page
suffix:semicolon
id|pmd_table
op_star
id|table
suffix:semicolon
r_int
id|nr
comma
id|offset
op_assign
op_minus
l_int|8
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|KPTR_PAGES
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;bfffo %1{%2,#8},%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|nr
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
(paren
id|u_char
)paren
op_complement
id|kptr_pages.alloced
(braket
id|i
)braket
)paren
comma
l_string|&quot;d&quot;
(paren
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No space for kernel pointer table!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|kptr_pages.page
(braket
id|i
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
(paren
id|pmd_tablepage
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No space for kernel pointer table!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|flush_tlb_kernel_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
id|nocache_page
c_func
(paren
(paren
id|u_long
)paren
(paren
id|kptr_pages.page
(braket
id|i
)braket
op_assign
id|page
)paren
)paren
suffix:semicolon
)brace
id|asm
r_volatile
(paren
l_string|&quot;bfset %0@{%1,#1}&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|kptr_pages.alloced
(braket
id|i
)braket
)paren
comma
l_string|&quot;d&quot;
(paren
id|nr
op_minus
id|offset
)paren
)paren
suffix:semicolon
id|table
op_assign
op_amp
(paren
op_star
id|page
)paren
(braket
id|nr
op_minus
id|offset
)braket
suffix:semicolon
id|memset
c_func
(paren
id|table
comma
l_int|0
comma
r_sizeof
(paren
id|pmd_table
)paren
)paren
suffix:semicolon
r_return
(paren
(paren
id|pmd_t
op_star
)paren
id|table
)paren
suffix:semicolon
)brace
DECL|function|free_kpointer_table
r_void
id|free_kpointer_table
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
id|pmd_table
op_star
id|table
op_assign
(paren
id|pmd_table
op_star
)paren
id|pmdp
suffix:semicolon
id|pmd_tablepage
op_star
id|page
op_assign
(paren
id|pmd_tablepage
op_star
)paren
(paren
(paren
id|u_long
)paren
id|table
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|KPTR_PAGES
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|kptr_pages.page
(braket
id|i
)braket
op_eq
id|page
)paren
r_break
suffix:semicolon
)brace
id|nr
op_assign
(paren
(paren
id|u_long
)paren
id|table
op_minus
(paren
id|u_long
)paren
id|page
)paren
op_div
r_sizeof
(paren
id|pmd_table
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|table
op_logical_or
id|i
OL
l_int|0
op_logical_or
(paren
id|i
op_eq
id|KPTR_PAGES
op_minus
l_int|1
op_logical_and
id|nr
OL
id|RESERVED_KPTR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to free invalid kernel pointer table: %p&bslash;n&quot;
comma
id|table
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|asm
r_volatile
(paren
l_string|&quot;bfclr %0@{%1,#1}&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|kptr_pages.alloced
(braket
id|i
)braket
)paren
comma
l_string|&quot;d&quot;
(paren
id|nr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kptr_pages.alloced
(braket
id|i
)braket
)paren
(brace
id|kptr_pages.page
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|cache_page
(paren
(paren
id|u_long
)paren
id|page
)paren
suffix:semicolon
id|free_page
(paren
(paren
id|u_long
)paren
id|page
)paren
suffix:semicolon
)brace
)brace
DECL|function|transp_transl_matches
r_static
r_int
r_int
id|transp_transl_matches
c_func
(paren
r_int
r_int
id|regval
comma
r_int
r_int
id|vaddr
)paren
(brace
r_int
r_int
id|base
comma
id|mask
suffix:semicolon
multiline_comment|/* enabled? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|regval
op_amp
l_int|0x8000
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_030
)paren
(brace
multiline_comment|/* function code match? */
id|base
op_assign
(paren
id|regval
op_rshift
l_int|4
)paren
op_amp
l_int|7
suffix:semicolon
id|mask
op_assign
op_complement
(paren
id|regval
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SUPER_DATA
op_amp
id|mask
)paren
op_ne
(paren
id|base
op_amp
id|mask
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* must not be user-only */
r_if
c_cond
(paren
(paren
id|regval
op_amp
l_int|0x6000
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* address match? */
id|base
op_assign
id|regval
op_amp
l_int|0xff000000
suffix:semicolon
id|mask
op_assign
op_complement
(paren
(paren
id|regval
op_lshift
l_int|8
)paren
op_amp
l_int|0xff000000
)paren
suffix:semicolon
r_return
(paren
id|vaddr
op_amp
id|mask
)paren
op_eq
(paren
id|base
op_amp
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following two routines map from a physical address to a kernel&n; * virtual address and vice versa.&n; */
DECL|function|mm_vtop
r_int
r_int
id|mm_vtop
(paren
r_int
r_int
id|vaddr
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|voff
op_assign
id|vaddr
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|voff
OL
id|offset
op_plus
id|m68k_memory
(braket
id|i
)braket
dot
id|size
)paren
(brace
macro_line|#ifdef DEBUGPV
id|printk
(paren
l_string|&quot;VTOP(%lx)=%lx&bslash;n&quot;
comma
id|vaddr
comma
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|voff
op_minus
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_return
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|voff
op_minus
id|offset
suffix:semicolon
)brace
r_else
id|offset
op_add_assign
id|m68k_memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|m68k_num_memory
)paren
suffix:semicolon
multiline_comment|/* not in one of the memory chunks; test for applying transparent&n;&t; * translation */
r_if
c_cond
(paren
id|CPU_IS_030
)paren
(brace
r_int
r_int
id|ttreg
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;.chip 68030&bslash;n&bslash;t&quot;
l_string|&quot;pmove %/tt0,%0@&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|ttreg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transp_transl_matches
c_func
(paren
id|ttreg
comma
id|vaddr
)paren
)paren
r_return
id|vaddr
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;.chip 68030&bslash;n&bslash;t&quot;
l_string|&quot;pmove %/tt1,%0@&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|ttreg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transp_transl_matches
c_func
(paren
id|ttreg
comma
id|vaddr
)paren
)paren
r_return
id|vaddr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_int
r_int
id|ttreg
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;movec %%dtt0,%0&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|ttreg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transp_transl_matches
c_func
(paren
id|ttreg
comma
id|vaddr
)paren
)paren
r_return
id|vaddr
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;movec %%dtt1,%0&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|ttreg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transp_transl_matches
c_func
(paren
id|ttreg
comma
id|vaddr
)paren
)paren
r_return
id|vaddr
suffix:semicolon
)brace
multiline_comment|/* no match, too, so get the actual physical address from the MMU. */
r_if
c_cond
(paren
id|CPU_IS_060
)paren
(brace
r_int
r_int
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
id|set_fs
(paren
id|SUPER_DATA
)paren
suffix:semicolon
multiline_comment|/* The PLPAR instruction causes an access error if the translation&n;&t;   * is not possible. We don&squot;t catch that here, so a bad kernel trap&n;&t;   * will be reported in this case. */
id|asm
r_volatile
(paren
l_string|&quot;.chip 68060&bslash;n&bslash;t&quot;
l_string|&quot;plpar (%0)&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|paddr
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|vaddr
)paren
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
r_return
id|paddr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CPU_IS_040
)paren
(brace
r_int
r_int
id|mmusr
suffix:semicolon
r_int
r_int
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|SUPER_DATA
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;ptestr (%1)&bslash;n&bslash;t&quot;
l_string|&quot;movec %%mmusr, %0&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|mmusr
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|vaddr
)paren
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mmusr
op_amp
id|MMU_R_040
)paren
r_return
(paren
id|mmusr
op_amp
id|PAGE_MASK
)paren
op_or
(paren
id|vaddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|panic
(paren
l_string|&quot;VTOP040: bad virtual address %08lx (%lx)&quot;
comma
id|vaddr
comma
id|mmusr
)paren
suffix:semicolon
)brace
r_else
(brace
r_volatile
r_int
r_int
id|temp
suffix:semicolon
r_int
r_int
id|mmusr
suffix:semicolon
r_int
r_int
op_star
id|descaddr
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;ptestr #5,%2@,#7,%0&bslash;n&bslash;t&quot;
l_string|&quot;pmove %/psr,%1@&quot;
suffix:colon
l_string|&quot;=a&amp;&quot;
(paren
id|descaddr
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|temp
)paren
comma
l_string|&quot;a&quot;
(paren
id|vaddr
)paren
)paren
suffix:semicolon
id|mmusr
op_assign
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|mmusr
op_amp
(paren
id|MMU_I
op_or
id|MMU_B
op_or
id|MMU_L
)paren
)paren
id|panic
(paren
l_string|&quot;VTOP030: bad virtual address %08lx (%x)&quot;
comma
id|vaddr
comma
id|mmusr
)paren
suffix:semicolon
id|descaddr
op_assign
(paren
r_int
r_int
op_star
)paren
id|PTOV
c_func
(paren
id|descaddr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mmusr
op_amp
id|MMU_NUM
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
(paren
op_star
id|descaddr
op_amp
l_int|0xfe000000
)paren
op_or
(paren
id|vaddr
op_amp
l_int|0x01ffffff
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
(paren
op_star
id|descaddr
op_amp
l_int|0xfffc0000
)paren
op_or
(paren
id|vaddr
op_amp
l_int|0x0003ffff
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
(paren
op_star
id|descaddr
op_amp
id|PAGE_MASK
)paren
op_or
(paren
id|vaddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_default
suffix:colon
id|panic
(paren
l_string|&quot;VTOP: bad levels (%u) for virtual address %08lx&quot;
comma
id|mmusr
op_amp
id|MMU_NUM
comma
id|vaddr
)paren
suffix:semicolon
)brace
)brace
id|panic
(paren
l_string|&quot;VTOP: bad virtual address %08lx&quot;
comma
id|vaddr
)paren
suffix:semicolon
)brace
DECL|function|mm_ptov
r_int
r_int
id|mm_ptov
(paren
r_int
r_int
id|paddr
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|paddr
op_ge
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_logical_and
id|paddr
OL
(paren
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|m68k_memory
(braket
id|i
)braket
dot
id|size
)paren
)paren
(brace
macro_line|#ifdef DEBUGPV
id|printk
(paren
l_string|&quot;PTOV(%lx)=%lx&bslash;n&quot;
comma
id|paddr
comma
(paren
id|paddr
op_minus
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
)paren
op_plus
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|paddr
op_minus
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
)paren
op_plus
id|offset
suffix:semicolon
)brace
r_else
id|offset
op_add_assign
id|m68k_memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|m68k_num_memory
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * assume that the kernel virtual address is the same as the&n;&t; * physical address.&n;&t; *&n;&t; * This should be reasonable in most situations:&n;&t; *  1) They shouldn&squot;t be dereferencing the virtual address&n;&t; *     unless they are sure that it is valid from kernel space.&n;&t; *  2) The only usage I see so far is converting a page table&n;&t; *     reference to some non-FASTMEM address space when freeing&n;         *     mmaped &quot;/dev/mem&quot; pages.  These addresses are just passed&n;&t; *     to &quot;free_page&quot;, which ignores addresses that aren&squot;t in&n;&t; *     the memory list anyway.&n;&t; *&n;&t; */
multiline_comment|/*&n;&t; * if on an amiga and address is in first 16M, move it &n;&t; * to the ZTWO_ADDR range&n;&t; */
r_if
c_cond
(paren
id|MACH_IS_AMIGA
op_logical_and
id|paddr
OL
l_int|16
op_star
l_int|1024
op_star
l_int|1024
)paren
r_return
id|ZTWO_VADDR
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_return
id|paddr
suffix:semicolon
)brace
multiline_comment|/* invalidate page in both caches */
DECL|macro|clear040
mdefine_line|#define&t;clear040(paddr)&t;&t;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__ (&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68040&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;cinvp %%bc,(%0)&bslash;n&bslash;t&quot;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68k&quot;&t;&t;&bslash;&n;&t;&t;&t;      : : &quot;a&quot; (paddr))
multiline_comment|/* invalidate page in i-cache */
DECL|macro|cleari040
mdefine_line|#define&t;cleari040(paddr)&t;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__ (&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68040&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;cinvp %%ic,(%0)&bslash;n&bslash;t&quot;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68k&quot;&t;&t;&bslash;&n;&t;&t;&t;      : : &quot;a&quot; (paddr))
multiline_comment|/* push page in both caches */
DECL|macro|push040
mdefine_line|#define&t;push040(paddr)&t;&t;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__ (&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68040&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;cpushp %%bc,(%0)&bslash;n&bslash;t&quot;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68k&quot;&t;&t;&bslash;&n;&t;&t;&t;      : : &quot;a&quot; (paddr))
multiline_comment|/* push and invalidate page in both caches */
DECL|macro|pushcl040
mdefine_line|#define&t;pushcl040(paddr)&t;&t;&t;&bslash;&n;&t;do { push040(paddr);&t;&t;&t;&bslash;&n;&t;     if (CPU_IS_060) clear040(paddr);&t;&bslash;&n;&t;} while(0)
multiline_comment|/* push page in both caches, invalidate in i-cache */
DECL|macro|pushcli040
mdefine_line|#define&t;pushcli040(paddr)&t;&t;&t;&bslash;&n;&t;do { push040(paddr);&t;&t;&t;&bslash;&n;&t;     if (CPU_IS_060) cleari040(paddr);&t;&bslash;&n;&t;} while(0)
multiline_comment|/* push page defined by virtual address in both caches */
DECL|macro|pushv040
mdefine_line|#define&t;pushv040(vaddr)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do { unsigned long _tmp1, _tmp2;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__ (&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68040&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;ptestr (%2)&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;movec %%mmusr,%0&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;andw #0xf000,%0&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;movel %0,%1&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;      &quot;cpushp %%bc,(%1)&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68k&quot;&t;&t;&t;&bslash;&n;&t;&t;&t;      : &quot;=d&quot; (_tmp1), &quot;=a&quot; (_tmp2)&t;&bslash;&n;&t;&t;&t;      : &quot;a&quot; (vaddr));&t;&t;&t;&bslash;&n;&t;} while (0)
multiline_comment|/* push page defined by virtual address in both caches */
DECL|macro|pushv060
mdefine_line|#define&t;pushv060(vaddr)&t;&t;&t;&t;&t;&bslash;&n;&t;do { unsigned long _tmp;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__ (&quot;.chip 68060&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;plpar (%0)&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&t;&t;      &quot;cpushp %%bc,(%0)&bslash;n&bslash;t&quot;&t;&bslash;&n;&t;&t;&t;      &quot;.chip 68k&quot;&t;&t;&bslash;&n;&t;&t;&t;      : &quot;=a&quot; (_tmp)&t;&t;&bslash;&n;&t;&t;&t;      : &quot;0&quot; (vaddr));&t;&t;&bslash;&n;&t;} while (0)
multiline_comment|/*&n; * 040: Hit every page containing an address in the range paddr..paddr+len-1.&n; * (Low order bits of the ea of a CINVP/CPUSHP are &quot;don&squot;t care&quot;s).&n; * Hit every page until there is a page or less to go. Hit the next page,&n; * and the one after that if the range hits it.&n; */
multiline_comment|/* ++roman: A little bit more care is required here: The CINVP instruction&n; * invalidates cache entries WITHOUT WRITING DIRTY DATA BACK! So the beginning&n; * and the end of the region must be treated differently if they are not&n; * exactly at the beginning or end of a page boundary. Else, maybe too much&n; * data becomes invalidated and thus lost forever. CPUSHP does what we need:&n; * it invalidates the page after pushing dirty data to memory. (Thanks to Jes&n; * for discovering the problem!)&n; */
multiline_comment|/* ... but on the &squot;060, CPUSH doesn&squot;t invalidate (for us, since we have set&n; * the DPI bit in the CACR; would it cause problems with temporarily changing&n; * this?). So we have to push first and then additionally to invalidate.&n; */
multiline_comment|/*&n; * cache_clear() semantics: Clear any cache entries for the area in question,&n; * without writing back dirty entries first. This is useful if the data will&n; * be overwritten anyway, e.g. by DMA to memory. The range is defined by a&n; * _physical_ address.&n; */
DECL|function|cache_clear
r_void
id|cache_clear
(paren
r_int
r_int
id|paddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
multiline_comment|/*&n;&t; * cwe need special treatment for the first page, in case it&n;&t; * is not page-aligned.&n;&t; */
r_if
c_cond
(paren
id|paddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
id|pushcl040
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|paddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
id|pushcl040
c_func
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
(brace
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|paddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
macro_line|#if 0
id|pushcl040
c_func
(paren
id|paddr
)paren
suffix:semicolon
macro_line|#else
id|clear040
c_func
(paren
id|paddr
)paren
suffix:semicolon
macro_line|#endif
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|paddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pushcl040
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|paddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|pushcl040
c_func
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I_AND_D
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cache_push() semantics: Write back any dirty cache data in the given area,&n; * and invalidate the range in the instruction cache. It needs not (but may)&n; * invalidate those entries also in the data cache. The range is defined by a&n; * _physical_ address.&n; */
DECL|function|cache_push
r_void
id|cache_push
(paren
r_int
r_int
id|paddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
multiline_comment|/*&n;         * on 68040 or 68060, push cache lines for pages in the range;&n;&t; * on the &squot;040 this also invalidates the pushed lines, but not on&n;&t; * the &squot;060!&n;&t; */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|pushcli040
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|paddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pushcli040
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|paddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|pushcli040
c_func
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * 68030/68020 have no writeback cache. On the other hand,&n;     * cache_push is actually a superset of cache_clear (the lines&n;     * get written back and invalidated), so we should make sure&n;     * to perform the corresponding actions. After all, this is getting&n;     * called in places where we&squot;ve just loaded code, or whatever, so&n;     * flushing the icache is appropriate; flushing the dcache shouldn&squot;t&n;     * be required.&n;     */
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cache_push_v() semantics: Write back any dirty cache data in the given&n; * area, and invalidate those entries at least in the instruction cache. This&n; * is intended to be used after data has been written that can be executed as&n; * code later. The range is defined by a _user_mode_ _virtual_ address  (or,&n; * more exactly, the space is defined by the %sfc/%dfc register.)&n; */
DECL|function|cache_push_v
r_void
id|cache_push_v
(paren
r_int
r_int
id|vaddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|CPU_IS_040
)paren
(brace
multiline_comment|/* on 68040, push cache lines for pages in the range */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|pushv040
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pushv040
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|vaddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|pushv040
c_func
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|CPU_IS_060
)paren
(brace
multiline_comment|/* on 68040, push cache lines for pages in the range */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|pushv060
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pushv060
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|vaddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|pushv060
c_func
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* 68030/68020 have no writeback cache; still need to clear icache. */
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
DECL|macro|clear040
macro_line|#undef clear040
DECL|macro|cleari040
macro_line|#undef cleari040
DECL|macro|push040
macro_line|#undef push040
DECL|macro|pushcl040
macro_line|#undef pushcl040
DECL|macro|pushcli040
macro_line|#undef pushcli040
DECL|macro|pushv040
macro_line|#undef pushv040
DECL|macro|pushv060
macro_line|#undef pushv060
DECL|function|mm_phys_to_virt
r_int
r_int
id|mm_phys_to_virt
(paren
r_int
r_int
id|addr
)paren
(brace
r_return
id|PTOV
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|function|mm_end_of_chunk
r_int
id|mm_end_of_chunk
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|m68k_num_memory
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|m68k_memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|m68k_memory
(braket
id|i
)braket
dot
id|size
op_eq
id|addr
op_plus
id|len
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Map some physical address range into the kernel address space. The&n; * code is copied and adapted from map_chunk().&n; */
DECL|function|kernel_map
r_int
r_int
id|kernel_map
c_func
(paren
r_int
r_int
id|paddr
comma
r_int
r_int
id|size
comma
r_int
id|nocacheflag
comma
r_int
r_int
op_star
id|memavailp
)paren
(brace
DECL|macro|STEP_SIZE
mdefine_line|#define STEP_SIZE&t;(256*1024)
r_static
r_int
r_int
id|vaddr
op_assign
l_int|0xe0000000
suffix:semicolon
multiline_comment|/* safe place */
r_int
r_int
id|physaddr
comma
id|retaddr
suffix:semicolon
id|pte_t
op_star
id|ktablep
op_assign
l_int|NULL
suffix:semicolon
id|pmd_t
op_star
id|kpointerp
suffix:semicolon
id|pgd_t
op_star
id|page_dir
suffix:semicolon
r_int
id|pindex
suffix:semicolon
multiline_comment|/* index into pointer table */
r_int
id|prot
suffix:semicolon
multiline_comment|/* Round down &squot;paddr&squot; to 256 KB and adjust size */
id|physaddr
op_assign
id|paddr
op_amp
op_complement
(paren
id|STEP_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_add_assign
id|paddr
op_minus
id|physaddr
suffix:semicolon
id|retaddr
op_assign
id|vaddr
op_plus
(paren
id|paddr
op_minus
id|physaddr
)paren
suffix:semicolon
id|paddr
op_assign
id|physaddr
suffix:semicolon
multiline_comment|/* Round up the size to 256 KB. It doesn&squot;t hurt if too much is&n;&t; * mapped... */
id|size
op_assign
(paren
id|size
op_plus
id|STEP_SIZE
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|STEP_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
id|prot
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_GLOBAL040
suffix:semicolon
r_switch
c_cond
(paren
id|nocacheflag
)paren
(brace
r_case
id|KERNELMAP_FULL_CACHING
suffix:colon
id|prot
op_or_assign
id|_PAGE_CACHE040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_SER
suffix:colon
r_default
suffix:colon
id|prot
op_or_assign
id|_PAGE_NOCACHE_S
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_NONSER
suffix:colon
id|prot
op_or_assign
id|_PAGE_NOCACHE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NO_COPYBACK
suffix:colon
id|prot
op_or_assign
id|_PAGE_CACHE040W
suffix:semicolon
multiline_comment|/* prot |= 0; */
r_break
suffix:semicolon
)brace
)brace
r_else
id|prot
op_assign
id|_PAGE_PRESENT
op_or
(paren
(paren
id|nocacheflag
op_eq
id|KERNELMAP_FULL_CACHING
op_logical_or
id|nocacheflag
op_eq
id|KERNELMAP_NO_COPYBACK
)paren
ques
c_cond
l_int|0
suffix:colon
id|_PAGE_NOCACHE030
)paren
suffix:semicolon
id|page_dir
op_assign
id|pgd_offset_k
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_present
c_func
(paren
op_star
id|page_dir
)paren
)paren
(brace
id|kpointerp
op_assign
(paren
id|pmd_t
op_star
)paren
id|pgd_page
c_func
(paren
op_star
id|page_dir
)paren
suffix:semicolon
id|pindex
op_assign
(paren
id|vaddr
op_rshift
l_int|18
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|pindex
op_ne
l_int|0
op_logical_and
id|CPU_IS_040_OR_060
)paren
(brace
r_if
c_cond
(paren
id|pmd_present
c_func
(paren
op_star
id|kpointerp
)paren
)paren
id|ktablep
op_assign
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|kpointerp
)paren
suffix:semicolon
r_else
(brace
id|ktablep
op_assign
id|kernel_page_table
(paren
id|memavailp
)paren
suffix:semicolon
multiline_comment|/* Make entries invalid */
id|memset
c_func
(paren
id|ktablep
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|PTRS_PER_PTE
)paren
suffix:semicolon
id|pmd_set
c_func
(paren
id|kpointerp
comma
id|ktablep
)paren
suffix:semicolon
)brace
id|ktablep
op_add_assign
(paren
id|pindex
op_amp
l_int|15
)paren
op_star
l_int|64
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* we need a new pointer table */
id|kpointerp
op_assign
id|get_kpointer_table
(paren
)paren
suffix:semicolon
id|pgd_set
c_func
(paren
id|page_dir
comma
(paren
id|pmd_t
op_star
)paren
id|kpointerp
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kpointerp
comma
l_int|0
comma
id|PTRS_PER_PMD
op_star
r_sizeof
(paren
id|pmd_t
)paren
)paren
suffix:semicolon
id|pindex
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|physaddr
op_assign
id|paddr
suffix:semicolon
id|physaddr
OL
id|paddr
op_plus
id|size
suffix:semicolon
id|vaddr
op_add_assign
id|STEP_SIZE
)paren
(brace
r_if
c_cond
(paren
id|pindex
OG
l_int|127
)paren
(brace
multiline_comment|/* we need a new pointer table */
id|kpointerp
op_assign
id|get_kpointer_table
(paren
)paren
suffix:semicolon
id|pgd_set
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|vaddr
)paren
comma
(paren
id|pmd_t
op_star
)paren
id|kpointerp
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kpointerp
comma
l_int|0
comma
id|PTRS_PER_PMD
op_star
r_sizeof
(paren
id|pmd_t
)paren
)paren
suffix:semicolon
id|pindex
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|ktable
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * 68040, use page tables pointed to by the&n;&t;&t;&t; * kernel pointer table.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|pindex
op_amp
l_int|15
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Need new page table every 4M on the &squot;040 */
id|ktablep
op_assign
id|kernel_page_table
(paren
id|memavailp
)paren
suffix:semicolon
multiline_comment|/* Make entries invalid */
id|memset
c_func
(paren
id|ktablep
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|PTRS_PER_PTE
)paren
suffix:semicolon
)brace
id|ktable
op_assign
id|VTOP
c_func
(paren
id|ktablep
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * initialize section of the page table mapping&n;&t;&t;&t; * this 1M portion.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pte_val
c_func
(paren
op_star
id|ktablep
op_increment
)paren
op_assign
id|physaddr
op_or
id|prot
suffix:semicolon
id|physaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * make the kernel pointer table point to the&n;&t;&t;&t; * kernel page table.&n;&t;&t;&t; */
(paren
(paren
r_int
r_int
op_star
)paren
id|kpointerp
)paren
(braket
id|pindex
op_increment
)braket
op_assign
id|ktable
op_or
id|_PAGE_TABLE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * 68030, use early termination page descriptors.&n;&t;&t;&t; * Each one points to 64 pages (256K).&n;&t;&t;&t; */
(paren
(paren
r_int
r_int
op_star
)paren
id|kpointerp
)paren
(braket
id|pindex
op_increment
)braket
op_assign
id|physaddr
op_or
id|prot
suffix:semicolon
id|physaddr
op_add_assign
l_int|64
op_star
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|retaddr
suffix:semicolon
)brace
DECL|function|set_cmode_pte
r_static
r_inline
r_void
id|set_cmode_pte
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ge
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|pte
op_increment
)paren
(brace
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_assign
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
op_complement
id|_PAGE_NOCACHE
)paren
op_or
id|cmode
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
DECL|function|set_cmode_pmd
r_static
r_inline
r_void
id|set_cmode_pmd
c_func
(paren
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_amp
id|_DESCTYPE_MASK
)paren
op_eq
id|_PAGE_PRESENT
)paren
(brace
multiline_comment|/* 68030 early termination descriptor */
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_amp
op_complement
id|_PAGE_NOCACHE
)paren
op_or
id|cmode
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &quot;normal&quot; tables */
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|pmd
op_increment
)paren
(brace
id|set_cmode_pte
c_func
(paren
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|cmode
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Set new cache mode for some kernel address space.&n; * The caller must push data for that range itself, if such data may already&n; * be in the cache.&n; */
DECL|function|kernel_set_cachemode
r_void
id|kernel_set_cachemode
c_func
(paren
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pgd_t
op_star
id|dir
op_assign
id|pgd_offset_k
c_func
(paren
id|address
)paren
suffix:semicolon
r_int
r_int
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_switch
c_cond
(paren
id|cmode
)paren
(brace
r_case
id|KERNELMAP_FULL_CACHING
suffix:colon
id|cmode
op_assign
id|_PAGE_CACHE040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_SER
suffix:colon
r_default
suffix:colon
id|cmode
op_assign
id|_PAGE_NOCACHE_S
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_NONSER
suffix:colon
id|cmode
op_assign
id|_PAGE_NOCACHE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NO_COPYBACK
suffix:colon
id|cmode
op_assign
id|_PAGE_CACHE040W
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|cmode
op_assign
(paren
(paren
id|cmode
op_eq
id|KERNELMAP_FULL_CACHING
op_logical_or
id|cmode
op_eq
id|KERNELMAP_NO_COPYBACK
)paren
ques
c_cond
l_int|0
suffix:colon
id|_PAGE_NOCACHE030
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|dir
op_increment
)paren
(brace
id|set_cmode_pmd
c_func
(paren
id|dir
comma
id|address
comma
id|end
op_minus
id|address
comma
id|cmode
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
)brace
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
eof
