multiline_comment|/*&n; *  linux/arch/m68k/mm/memory.c&n; *&n; *  Copyright (C) 1995  Hamish Macdonald&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
r_extern
id|pte_t
op_star
id|kernel_page_table
(paren
r_int
r_int
op_star
id|memavailp
)paren
suffix:semicolon
DECL|struct|ptable_desc
r_static
r_struct
id|ptable_desc
(brace
DECL|member|prev
r_struct
id|ptable_desc
op_star
id|prev
suffix:semicolon
DECL|member|next
r_struct
id|ptable_desc
op_star
id|next
suffix:semicolon
DECL|member|page
r_int
r_int
id|page
suffix:semicolon
DECL|member|alloced
r_int
r_char
id|alloced
suffix:semicolon
DECL|variable|ptable_list
)brace
id|ptable_list
op_assign
(brace
op_amp
id|ptable_list
comma
op_amp
id|ptable_list
comma
l_int|0
comma
l_int|0xff
)brace
suffix:semicolon
DECL|macro|PD_NONEFREE
mdefine_line|#define PD_NONEFREE(dp) ((dp)-&gt;alloced == 0xff)
DECL|macro|PD_ALLFREE
mdefine_line|#define PD_ALLFREE(dp) ((dp)-&gt;alloced == 0)
DECL|macro|PD_TABLEFREE
mdefine_line|#define PD_TABLEFREE(dp,i) (!((dp)-&gt;alloced &amp; (1&lt;&lt;(i))))
DECL|macro|PD_MARKUSED
mdefine_line|#define PD_MARKUSED(dp,i) ((dp)-&gt;alloced |= (1&lt;&lt;(i)))
DECL|macro|PD_MARKFREE
mdefine_line|#define PD_MARKFREE(dp,i) ((dp)-&gt;alloced &amp;= ~(1&lt;&lt;(i)))
DECL|macro|PTABLE_SIZE
mdefine_line|#define PTABLE_SIZE (PTRS_PER_PMD * sizeof(pmd_t))
DECL|function|get_pointer_table
id|pmd_t
op_star
id|get_pointer_table
(paren
r_void
)paren
(brace
id|pmd_t
op_star
id|pmdp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ptable_desc
op_star
id|dp
op_assign
id|ptable_list.next
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * For a pointer table for a user process address space, a&n;&t; * table is taken from a page allocated for the purpose.  Each&n;&t; * page can hold 8 pointer tables.  The page is remapped in&n;&t; * virtual address space to be noncacheable.&n;&t; */
r_if
c_cond
(paren
id|PD_NONEFREE
(paren
id|dp
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dp
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|ptable_desc
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dp-&gt;page
op_assign
id|__get_free_page
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|kfree
(paren
id|dp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nocache_page
(paren
id|dp-&gt;page
)paren
suffix:semicolon
id|dp-&gt;alloced
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* put at head of list */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;next
op_assign
id|ptable_list.next
suffix:semicolon
id|dp-&gt;prev
op_assign
id|ptable_list.next-&gt;prev
suffix:semicolon
id|ptable_list.next-&gt;prev
op_assign
id|dp
suffix:semicolon
id|ptable_list.next
op_assign
id|dp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|PD_TABLEFREE
(paren
id|dp
comma
id|i
)paren
)paren
(brace
id|PD_MARKUSED
(paren
id|dp
comma
id|i
)paren
suffix:semicolon
id|pmdp
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|dp-&gt;page
op_plus
id|PTABLE_SIZE
op_star
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PD_NONEFREE
(paren
id|dp
)paren
)paren
(brace
multiline_comment|/* move to end of list */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;prev-&gt;next
op_assign
id|dp-&gt;next
suffix:semicolon
id|dp-&gt;next-&gt;prev
op_assign
id|dp-&gt;prev
suffix:semicolon
id|dp-&gt;next
op_assign
id|ptable_list.next-&gt;prev
suffix:semicolon
id|dp-&gt;prev
op_assign
id|ptable_list.prev
suffix:semicolon
id|ptable_list.prev-&gt;next
op_assign
id|dp
suffix:semicolon
id|ptable_list.prev
op_assign
id|dp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|memset
(paren
id|pmdp
comma
l_int|0
comma
id|PTABLE_SIZE
)paren
suffix:semicolon
r_return
id|pmdp
suffix:semicolon
)brace
DECL|function|free_pointer_table
r_void
id|free_pointer_table
(paren
id|pmd_t
op_star
id|ptable
)paren
(brace
r_struct
id|ptable_desc
op_star
id|dp
suffix:semicolon
r_int
r_int
id|page
op_assign
(paren
r_int
r_int
)paren
id|ptable
op_amp
id|PAGE_MASK
suffix:semicolon
r_int
id|index
op_assign
(paren
(paren
r_int
r_int
)paren
id|ptable
op_minus
id|page
)paren
op_div
id|PTABLE_SIZE
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|dp
op_assign
id|ptable_list.next
suffix:semicolon
id|dp-&gt;page
op_logical_and
id|dp-&gt;page
op_ne
id|page
suffix:semicolon
id|dp
op_assign
id|dp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dp-&gt;page
)paren
id|panic
(paren
l_string|&quot;unable to find desc for ptable %p on list!&quot;
comma
id|ptable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PD_TABLEFREE
(paren
id|dp
comma
id|index
)paren
)paren
id|panic
(paren
l_string|&quot;table already free!&quot;
)paren
suffix:semicolon
id|PD_MARKFREE
(paren
id|dp
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PD_ALLFREE
(paren
id|dp
)paren
)paren
(brace
multiline_comment|/* all tables in page are free, free page */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;prev-&gt;next
op_assign
id|dp-&gt;next
suffix:semicolon
id|dp-&gt;next-&gt;prev
op_assign
id|dp-&gt;prev
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cache_page
(paren
id|dp-&gt;page
)paren
suffix:semicolon
id|free_page
(paren
id|dp-&gt;page
)paren
suffix:semicolon
id|kfree
(paren
id|dp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * move this descriptor the the front of the list, since&n;&t;&t; * it has one or more free tables.&n;&t;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dp-&gt;prev-&gt;next
op_assign
id|dp-&gt;next
suffix:semicolon
id|dp-&gt;next-&gt;prev
op_assign
id|dp-&gt;prev
suffix:semicolon
id|dp-&gt;next
op_assign
id|ptable_list.next
suffix:semicolon
id|dp-&gt;prev
op_assign
id|ptable_list.next-&gt;prev
suffix:semicolon
id|ptable_list.next-&gt;prev
op_assign
id|dp
suffix:semicolon
id|ptable_list.next
op_assign
id|dp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|variable|alloced
r_static
r_int
r_char
id|alloced
op_assign
l_int|0
suffix:semicolon
r_extern
id|pmd_t
(paren
op_star
id|kernel_pmd_table
)paren
(braket
id|PTRS_PER_PMD
)braket
suffix:semicolon
multiline_comment|/* initialized in head.S */
DECL|function|get_kpointer_table
id|pmd_t
op_star
id|get_kpointer_table
(paren
r_void
)paren
(brace
multiline_comment|/* For pointer tables for the kernel virtual address space,&n;&t; * use a page that is allocated in head.S that can hold up to&n;&t; * 8 pointer tables.  This allows mapping of 8 * 32M = 256M of&n;&t; * physical memory.  This should be sufficient for now.&n;&t; */
id|pmd_t
op_star
id|ptable
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAGE_SIZE
op_div
(paren
id|PTRS_PER_PMD
op_star
r_sizeof
(paren
id|pmd_t
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|alloced
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ptable
op_assign
id|kernel_pmd_table
(braket
id|i
)braket
suffix:semicolon
id|memset
(paren
id|ptable
comma
l_int|0
comma
id|PTRS_PER_PMD
op_star
r_sizeof
(paren
id|pmd_t
)paren
)paren
suffix:semicolon
id|alloced
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
r_return
id|ptable
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;no space for kernel pointer table&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|free_kpointer_table
r_void
id|free_kpointer_table
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
r_int
id|index
op_assign
(paren
id|pmd_t
(paren
op_star
)paren
(braket
id|PTRS_PER_PMD
)braket
)paren
id|pmdp
op_minus
id|kernel_pmd_table
suffix:semicolon
r_if
c_cond
(paren
id|index
template_param
l_int|7
op_logical_or
multiline_comment|/* This works because kernel_pmd_table is page aligned. */
(paren
(paren
r_int
r_int
)paren
id|pmdp
op_amp
(paren
r_sizeof
(paren
id|pmd_t
)paren
op_star
id|PTRS_PER_PMD
op_minus
l_int|1
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;attempt to free invalid kernel pointer table&quot;
)paren
suffix:semicolon
r_else
id|alloced
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following two routines map from a physical address to a kernel&n; * virtual address and vice versa.&n; */
DECL|function|mm_vtop
r_int
r_int
id|mm_vtop
(paren
r_int
r_int
id|vaddr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|voff
op_assign
id|vaddr
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_info.num_memory
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|voff
OL
id|offset
op_plus
id|boot_info.memory
(braket
id|i
)braket
dot
id|size
)paren
(brace
macro_line|#ifdef DEBUGPV
id|printk
(paren
l_string|&quot;VTOP(%lx)=%lx&bslash;n&quot;
comma
id|vaddr
comma
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|voff
op_minus
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_return
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|voff
op_minus
id|offset
suffix:semicolon
)brace
r_else
id|offset
op_add_assign
id|boot_info.memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
multiline_comment|/* not in one of the memory chunks; get the actual&n;&t; * physical address from the MMU.&n;&t; */
r_if
c_cond
(paren
id|m68k_is040or060
op_eq
l_int|6
)paren
(brace
r_int
r_int
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
id|set_fs
(paren
id|SUPER_DATA
)paren
suffix:semicolon
multiline_comment|/* The PLPAR instruction causes an access error if the translation&n;&t;   * is not possible. We don&squot;t catch that here, so a bad kernel trap&n;&t;   * will be reported in this case. */
id|asm
r_volatile
(paren
l_string|&quot;movel %1,%/a0&bslash;n&bslash;t&quot;
l_string|&quot;.word 0xf5c8&bslash;n&bslash;t&quot;
multiline_comment|/* plpar (a0) */
l_string|&quot;movel %/a0,%0&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|paddr
)paren
suffix:colon
l_string|&quot;g&quot;
(paren
id|vaddr
)paren
suffix:colon
l_string|&quot;a0&quot;
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
r_return
id|paddr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m68k_is040or060
op_eq
l_int|4
)paren
(brace
r_int
r_int
id|mmusr
suffix:semicolon
r_int
r_int
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|SUPER_DATA
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movel %1,%/a0&bslash;n&bslash;t&quot;
l_string|&quot;.word 0xf568&bslash;n&bslash;t&quot;
multiline_comment|/* ptestr (a0) */
l_string|&quot;.long 0x4e7a8805&bslash;n&bslash;t&quot;
multiline_comment|/* movec mmusr, a0 */
l_string|&quot;movel %/a0,%0&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|mmusr
)paren
suffix:colon
l_string|&quot;g&quot;
(paren
id|vaddr
)paren
suffix:colon
l_string|&quot;a0&quot;
comma
l_string|&quot;d0&quot;
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mmusr
op_amp
id|MMU_R_040
)paren
r_return
(paren
id|mmusr
op_amp
id|PAGE_MASK
)paren
op_or
(paren
id|vaddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|panic
(paren
l_string|&quot;VTOP040: bad virtual address %08lx (%lx)&quot;
comma
id|vaddr
comma
id|mmusr
)paren
suffix:semicolon
)brace
r_else
(brace
r_volatile
r_int
r_int
id|temp
suffix:semicolon
r_int
r_int
id|mmusr
suffix:semicolon
r_int
r_int
op_star
id|descaddr
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;ptestr #5,%2@,#7,%0&bslash;n&bslash;t&quot;
l_string|&quot;pmove %/psr,%1@&quot;
suffix:colon
l_string|&quot;=a&amp;&quot;
(paren
id|descaddr
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|temp
)paren
comma
l_string|&quot;a&quot;
(paren
id|vaddr
)paren
)paren
suffix:semicolon
id|mmusr
op_assign
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|mmusr
op_amp
(paren
id|MMU_I
op_or
id|MMU_B
op_or
id|MMU_L
)paren
)paren
id|panic
(paren
l_string|&quot;VTOP030: bad virtual address %08lx (%x)&quot;
comma
id|vaddr
comma
id|mmusr
)paren
suffix:semicolon
id|descaddr
op_assign
(paren
r_int
r_int
op_star
)paren
id|PTOV
c_func
(paren
id|descaddr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mmusr
op_amp
id|MMU_NUM
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
(paren
op_star
id|descaddr
op_amp
l_int|0xfe000000
)paren
op_or
(paren
id|vaddr
op_amp
l_int|0x01ffffff
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
(paren
op_star
id|descaddr
op_amp
l_int|0xfffc0000
)paren
op_or
(paren
id|vaddr
op_amp
l_int|0x0003ffff
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
(paren
op_star
id|descaddr
op_amp
id|PAGE_MASK
)paren
op_or
(paren
id|vaddr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_default
suffix:colon
id|panic
(paren
l_string|&quot;VTOP: bad levels (%u) for virtual address %08lx&quot;
comma
id|mmusr
op_amp
id|MMU_NUM
comma
id|vaddr
)paren
suffix:semicolon
)brace
)brace
id|panic
(paren
l_string|&quot;VTOP: bad virtual address %08lx&quot;
comma
id|vaddr
)paren
suffix:semicolon
)brace
DECL|function|mm_ptov
r_int
r_int
id|mm_ptov
(paren
r_int
r_int
id|paddr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_info.num_memory
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|paddr
op_ge
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
op_logical_and
id|paddr
OL
(paren
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|boot_info.memory
(braket
id|i
)braket
dot
id|size
)paren
)paren
(brace
macro_line|#ifdef DEBUGPV
id|printk
(paren
l_string|&quot;PTOV(%lx)=%lx&bslash;n&quot;
comma
id|paddr
comma
(paren
id|paddr
op_minus
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
)paren
op_plus
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|paddr
op_minus
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
)paren
op_plus
id|offset
suffix:semicolon
)brace
r_else
id|offset
op_add_assign
id|boot_info.memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * assume that the kernel virtual address is the same as the&n;&t; * physical address.&n;&t; *&n;&t; * This should be reasonable in most situations:&n;&t; *  1) They shouldn&squot;t be dereferencing the virtual address&n;&t; *     unless they are sure that it is valid from kernel space.&n;&t; *  2) The only usage I see so far is converting a page table&n;&t; *     reference to some non-FASTMEM address space when freeing&n;         *     mmaped &quot;/dev/mem&quot; pages.  These addresses are just passed&n;&t; *     to &quot;free_page&quot;, which ignores addresses that aren&squot;t in&n;&t; *     the memory list anyway.&n;&t; *&n;&t; */
multiline_comment|/*&n;&t; * if on an amiga and address is in first 16M, move it &n;&t; * to the ZTWO_ADDR range&n;&t; */
r_if
c_cond
(paren
id|MACH_IS_AMIGA
op_logical_and
id|paddr
OL
l_int|16
op_star
l_int|1024
op_star
l_int|1024
)paren
r_return
id|ZTWO_VADDR
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_return
id|paddr
suffix:semicolon
)brace
DECL|macro|clear040
mdefine_line|#define&t;clear040(paddr) __asm__ __volatile__ (&quot;movel %0,%/a0&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      &quot;.word 0xf4d0&quot;&bslash;&n;&t;&t;&t;&t;&t;      /* CINVP I/D (a0) */&bslash;&n;&t;&t;&t;&t;&t;      : : &quot;g&quot; ((paddr))&bslash;&n;&t;&t;&t;&t;&t;      : &quot;a0&quot;)
DECL|macro|push040
mdefine_line|#define&t;push040(paddr) __asm__ __volatile__ (&quot;movel %0,%/a0&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;     &quot;.word 0xf4f0&quot;&bslash;&n;&t;&t;&t;&t;&t;     /* CPUSHP I/D (a0) */&bslash;&n;&t;&t;&t;&t;&t;     : : &quot;g&quot; ((paddr))&bslash;&n;&t;&t;&t;&t;&t;     : &quot;a0&quot;)
DECL|macro|pushcl040
mdefine_line|#define&t;pushcl040(paddr) do { push040((paddr));&bslash;&n;&t;&t;&t;      if (m68k_is040or060 == 6) clear040((paddr));&bslash;&n;&t;&t;&t; } while(0)
DECL|macro|pushv040
mdefine_line|#define&t;pushv040(vaddr) __asm__ __volatile__ (&quot;movel %0,%/a0&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      /* ptestr (a0) */&bslash;&n;&t;&t;&t;&t;&t;      &quot;.word 0xf568&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      /* movec mmusr,d0 */&bslash;&n;&t;&t;&t;&t;&t;      &quot;.long 0x4e7a0805&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      &quot;andw #0xf000,%/d0&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      &quot;movel %/d0,%/a0&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      /* CPUSHP I/D (a0) */&bslash;&n;&t;&t;&t;&t;&t;      &quot;.word 0xf4f0&quot;&bslash;&n;&t;&t;&t;&t;&t;      : : &quot;g&quot; ((vaddr))&bslash;&n;&t;&t;&t;&t;&t;      : &quot;a0&quot;, &quot;d0&quot;)
DECL|macro|pushv060
mdefine_line|#define&t;pushv060(vaddr) __asm__ __volatile__ (&quot;movel %0,%/a0&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      /* plpar (a0) */&bslash;&n;&t;&t;&t;&t;&t;      &quot;.word 0xf5c8&bslash;n&bslash;t&quot;&bslash;&n;&t;&t;&t;&t;&t;      /* CPUSHP I/D (a0) */&bslash;&n;&t;&t;&t;&t;&t;      &quot;.word 0xf4f0&quot;&bslash;&n;&t;&t;&t;&t;&t;      : : &quot;g&quot; ((vaddr))&bslash;&n;&t;&t;&t;&t;&t;      : &quot;a0&quot;)
multiline_comment|/*&n; * 040: Hit every page containing an address in the range paddr..paddr+len-1.&n; * (Low order bits of the ea of a CINVP/CPUSHP are &quot;don&squot;t care&quot;s).&n; * Hit every page until there is a page or less to go. Hit the next page,&n; * and the one after that if the range hits it.&n; */
multiline_comment|/* ++roman: A little bit more care is required here: The CINVP instruction&n; * invalidates cache entries WITHOUT WRITING DIRTY DATA BACK! So the beginning&n; * and the end of the region must be treated differently if they are not&n; * exactly at the beginning or end of a page boundary. Else, maybe too much&n; * data becomes invalidated and thus lost forever. CPUSHP does what we need:&n; * it invalidates the page after pushing dirty data to memory. (Thanks to Jes&n; * for discovering the problem!)&n; */
multiline_comment|/* ... but on the &squot;060, CPUSH doesn&squot;t invalidate (for us, since we have set&n; * the DPI bit in the CACR; would it cause problems with temporarily changing&n; * this?). So we have to push first and then additionally to invalidate.&n; */
DECL|function|cache_clear
r_void
id|cache_clear
(paren
r_int
r_int
id|paddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|m68k_is040or060
)paren
(brace
multiline_comment|/* ++roman: There have been too many problems with the CINV, it seems&n;&t; * to break the cache maintainance of DMAing drivers. I don&squot;t expect&n;&t; * too much overhead by using CPUSH instead.&n;&t; */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|pushcl040
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|paddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pushcl040
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|paddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|pushcl040
c_func
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
multiline_comment|/* on 68040, invalidate cache lines for pages in the range */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|clear040
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|paddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
multiline_comment|/* 0 &lt; len &lt;= PAGE_SIZE */
id|clear040
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
)paren
op_ne
(paren
id|paddr
op_div
id|PAGE_SIZE
)paren
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|clear040
c_func
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I_AND_D
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
DECL|function|cache_push
r_void
id|cache_push
(paren
r_int
r_int
id|paddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|m68k_is040or060
)paren
(brace
multiline_comment|/*&n;         * on 68040 or 68060, push cache lines for pages in the range;&n;&t; * on the &squot;040 this also invalidates the pushed lines, but not on&n;&t; * the &squot;060!&n;&t; */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|push040
c_func
(paren
id|paddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|paddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|push040
c_func
(paren
id|paddr
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
(paren
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
)paren
op_ne
(paren
id|paddr
op_div
id|PAGE_SIZE
)paren
)paren
(brace
macro_line|#endif
r_if
c_cond
(paren
(paren
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|paddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|push040
c_func
(paren
id|paddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * 68030/68020 have no writeback cache. On the other hand,&n;     * cache_push is actually a superset of cache_clear (the lines&n;     * get written back and invalidated), so we should make sure&n;     * to perform the corresponding actions. After all, this is getting&n;     * called in places where we&squot;ve just loaded code, or whatever, so&n;     * flushing the icache is appropriate; flushing the dcache shouldn&squot;t&n;     * be required.&n;     */
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
DECL|function|cache_push_v
r_void
id|cache_push_v
(paren
r_int
r_int
id|vaddr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|m68k_is040or060
op_eq
l_int|4
)paren
(brace
multiline_comment|/* on 68040, push cache lines for pages in the range */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|pushv040
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pushv040
c_func
(paren
id|vaddr
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
(paren
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
)paren
op_ne
(paren
id|vaddr
op_div
id|PAGE_SIZE
)paren
)paren
(brace
macro_line|#endif
r_if
c_cond
(paren
(paren
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|vaddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|pushv040
c_func
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|m68k_is040or060
op_eq
l_int|6
)paren
(brace
multiline_comment|/* on 68040, push cache lines for pages in the range */
r_while
c_loop
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|pushv060
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pushv060
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
op_xor
id|vaddr
)paren
op_amp
id|PAGE_MASK
)paren
(brace
multiline_comment|/* a page boundary gets crossed at the end */
id|pushv060
c_func
(paren
id|vaddr
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* 68030/68020 have no writeback cache; still need to clear icache. */
r_else
multiline_comment|/* 68030 or 68020 */
id|asm
r_volatile
(paren
l_string|&quot;movec %/cacr,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;oriw %0,%/d0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/d0,%/cacr&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|FLUSH_I
)paren
suffix:colon
l_string|&quot;d0&quot;
)paren
suffix:semicolon
)brace
DECL|macro|clear040
macro_line|#undef clear040
DECL|macro|push040
macro_line|#undef push040
DECL|macro|pushv040
macro_line|#undef pushv040
DECL|macro|pushv060
macro_line|#undef pushv060
DECL|function|mm_phys_to_virt
r_int
r_int
id|mm_phys_to_virt
(paren
r_int
r_int
id|addr
)paren
(brace
r_return
id|PTOV
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|function|mm_end_of_chunk
r_int
id|mm_end_of_chunk
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_info.num_memory
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|boot_info.memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|boot_info.memory
(braket
id|i
)braket
dot
id|size
op_eq
id|addr
op_plus
id|len
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Map some physical address range into the kernel address space. The&n; * code is copied and adapted from map_chunk().&n; */
DECL|function|kernel_map
r_int
r_int
id|kernel_map
c_func
(paren
r_int
r_int
id|paddr
comma
r_int
r_int
id|size
comma
r_int
id|nocacheflag
comma
r_int
r_int
op_star
id|memavailp
)paren
(brace
DECL|macro|STEP_SIZE
mdefine_line|#define STEP_SIZE&t;(256*1024)
r_static
r_int
r_int
id|vaddr
op_assign
l_int|0xe0000000
suffix:semicolon
multiline_comment|/* safe place */
r_int
r_int
id|physaddr
comma
id|retaddr
suffix:semicolon
id|pte_t
op_star
id|ktablep
op_assign
l_int|NULL
suffix:semicolon
id|pmd_t
op_star
id|kpointerp
suffix:semicolon
id|pgd_t
op_star
id|page_dir
suffix:semicolon
r_int
id|pindex
suffix:semicolon
multiline_comment|/* index into pointer table */
r_int
id|prot
suffix:semicolon
multiline_comment|/* Round down &squot;paddr&squot; to 256 KB and adjust size */
id|physaddr
op_assign
id|paddr
op_amp
op_complement
(paren
id|STEP_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_add_assign
id|paddr
op_minus
id|physaddr
suffix:semicolon
id|retaddr
op_assign
id|vaddr
op_plus
(paren
id|paddr
op_minus
id|physaddr
)paren
suffix:semicolon
id|paddr
op_assign
id|physaddr
suffix:semicolon
multiline_comment|/* Round up the size to 256 KB. It doesn&squot;t hurt if too much is&n;&t; * mapped... */
id|size
op_assign
(paren
id|size
op_plus
id|STEP_SIZE
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|STEP_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m68k_is040or060
)paren
(brace
id|prot
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_GLOBAL040
suffix:semicolon
r_switch
c_cond
(paren
id|nocacheflag
)paren
(brace
r_case
id|KERNELMAP_FULL_CACHING
suffix:colon
id|prot
op_or_assign
id|_PAGE_CACHE040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_SER
suffix:colon
r_default
suffix:colon
id|prot
op_or_assign
id|_PAGE_NOCACHE_S
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_NONSER
suffix:colon
id|prot
op_or_assign
id|_PAGE_NOCACHE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NO_COPYBACK
suffix:colon
id|prot
op_or_assign
id|_PAGE_CACHE040W
suffix:semicolon
multiline_comment|/* prot |= 0; */
r_break
suffix:semicolon
)brace
)brace
r_else
id|prot
op_assign
id|_PAGE_PRESENT
op_or
(paren
(paren
id|nocacheflag
op_eq
id|KERNELMAP_FULL_CACHING
op_logical_or
id|nocacheflag
op_eq
id|KERNELMAP_NO_COPYBACK
)paren
ques
c_cond
l_int|0
suffix:colon
id|_PAGE_NOCACHE030
)paren
suffix:semicolon
id|page_dir
op_assign
id|pgd_offset_k
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_present
c_func
(paren
op_star
id|page_dir
)paren
)paren
(brace
id|kpointerp
op_assign
(paren
id|pmd_t
op_star
)paren
id|pgd_page
c_func
(paren
op_star
id|page_dir
)paren
suffix:semicolon
id|pindex
op_assign
(paren
id|vaddr
op_rshift
l_int|18
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|pindex
op_ne
l_int|0
op_logical_and
id|m68k_is040or060
)paren
(brace
r_if
c_cond
(paren
id|pmd_present
c_func
(paren
op_star
id|kpointerp
)paren
)paren
id|ktablep
op_assign
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|kpointerp
)paren
suffix:semicolon
r_else
(brace
id|ktablep
op_assign
id|kernel_page_table
(paren
id|memavailp
)paren
suffix:semicolon
multiline_comment|/* Make entries invalid */
id|memset
c_func
(paren
id|ktablep
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|PTRS_PER_PTE
)paren
suffix:semicolon
id|pmd_set
c_func
(paren
id|kpointerp
comma
id|ktablep
)paren
suffix:semicolon
)brace
id|ktablep
op_add_assign
(paren
id|pindex
op_amp
l_int|15
)paren
op_star
l_int|64
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* we need a new pointer table */
id|kpointerp
op_assign
id|get_kpointer_table
(paren
)paren
suffix:semicolon
id|pgd_set
c_func
(paren
id|page_dir
comma
(paren
id|pmd_t
op_star
)paren
id|kpointerp
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kpointerp
comma
l_int|0
comma
id|PTRS_PER_PMD
op_star
r_sizeof
(paren
id|pmd_t
)paren
)paren
suffix:semicolon
id|pindex
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|physaddr
op_assign
id|paddr
suffix:semicolon
id|physaddr
OL
id|paddr
op_plus
id|size
suffix:semicolon
id|vaddr
op_add_assign
id|STEP_SIZE
)paren
(brace
r_if
c_cond
(paren
id|pindex
OG
l_int|127
)paren
(brace
multiline_comment|/* we need a new pointer table */
id|kpointerp
op_assign
id|get_kpointer_table
(paren
)paren
suffix:semicolon
id|pgd_set
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|vaddr
)paren
comma
(paren
id|pmd_t
op_star
)paren
id|kpointerp
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kpointerp
comma
l_int|0
comma
id|PTRS_PER_PMD
op_star
r_sizeof
(paren
id|pmd_t
)paren
)paren
suffix:semicolon
id|pindex
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m68k_is040or060
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|ktable
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * 68040, use page tables pointed to by the&n;&t;&t;&t; * kernel pointer table.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|pindex
op_amp
l_int|15
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Need new page table every 4M on the &squot;040 */
id|ktablep
op_assign
id|kernel_page_table
(paren
id|memavailp
)paren
suffix:semicolon
multiline_comment|/* Make entries invalid */
id|memset
c_func
(paren
id|ktablep
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|PTRS_PER_PTE
)paren
suffix:semicolon
)brace
id|ktable
op_assign
id|VTOP
c_func
(paren
id|ktablep
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * initialize section of the page table mapping&n;&t;&t;&t; * this 1M portion.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pte_val
c_func
(paren
op_star
id|ktablep
op_increment
)paren
op_assign
id|physaddr
op_or
id|prot
suffix:semicolon
id|physaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * make the kernel pointer table point to the&n;&t;&t;&t; * kernel page table.&n;&t;&t;&t; */
(paren
(paren
r_int
r_int
op_star
)paren
id|kpointerp
)paren
(braket
id|pindex
op_increment
)braket
op_assign
id|ktable
op_or
id|_PAGE_TABLE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * 68030, use early termination page descriptors.&n;&t;&t;&t; * Each one points to 64 pages (256K).&n;&t;&t;&t; */
(paren
(paren
r_int
r_int
op_star
)paren
id|kpointerp
)paren
(braket
id|pindex
op_increment
)braket
op_assign
id|physaddr
op_or
id|prot
suffix:semicolon
id|physaddr
op_add_assign
l_int|64
op_star
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_return
id|retaddr
suffix:semicolon
)brace
DECL|function|set_cmode_pte
r_static
r_inline
r_void
id|set_cmode_pte
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ge
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|pte
op_increment
)paren
(brace
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_assign
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
op_complement
id|_PAGE_NOCACHE
)paren
op_or
id|cmode
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
DECL|function|set_cmode_pmd
r_static
r_inline
r_void
id|set_cmode_pmd
c_func
(paren
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_amp
id|_DESCTYPE_MASK
)paren
op_eq
id|_PAGE_PRESENT
)paren
(brace
multiline_comment|/* 68030 early termination descriptor */
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_amp
op_complement
id|_PAGE_NOCACHE
)paren
op_or
id|cmode
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &quot;normal&quot; tables */
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|pmd
op_increment
)paren
(brace
id|set_cmode_pte
c_func
(paren
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|cmode
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Set new cache mode for some kernel address space.&n; * The caller must push data for that range itself, if such data may already&n; * be in the cache.&n; */
DECL|function|kernel_set_cachemode
r_void
id|kernel_set_cachemode
c_func
(paren
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pgd_t
op_star
id|dir
op_assign
id|pgd_offset_k
c_func
(paren
id|address
)paren
suffix:semicolon
r_int
r_int
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|m68k_is040or060
)paren
(brace
r_switch
c_cond
(paren
id|cmode
)paren
(brace
r_case
id|KERNELMAP_FULL_CACHING
suffix:colon
id|cmode
op_assign
id|_PAGE_CACHE040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_SER
suffix:colon
r_default
suffix:colon
id|cmode
op_assign
id|_PAGE_NOCACHE_S
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_NONSER
suffix:colon
id|cmode
op_assign
id|_PAGE_NOCACHE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NO_COPYBACK
suffix:colon
id|cmode
op_assign
id|_PAGE_CACHE040W
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|cmode
op_assign
(paren
(paren
id|cmode
op_eq
id|KERNELMAP_FULL_CACHING
op_logical_or
id|cmode
op_eq
id|KERNELMAP_NO_COPYBACK
)paren
ques
c_cond
l_int|0
suffix:colon
id|_PAGE_NOCACHE030
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|dir
op_increment
)paren
(brace
id|set_cmode_pmd
c_func
(paren
id|dir
comma
id|address
comma
id|end
op_minus
id|address
comma
id|cmode
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
)brace
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
eof
