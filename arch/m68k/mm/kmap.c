multiline_comment|/*&n; *  linux/arch/m68k/mm/kmap.c&n; *&n; *  Copyright (C) 1997 Roman Hodek&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
r_extern
id|pte_t
op_star
id|kernel_page_table
(paren
r_int
r_int
op_star
id|memavailp
)paren
suffix:semicolon
multiline_comment|/* Granularity of kernel_map() allocations */
DECL|macro|KMAP_STEP
mdefine_line|#define KMAP_STEP&t;(256*1024)
multiline_comment|/* Size of pool of KMAP structures; that is needed, because kernel_map() can&n; * be called at times where kmalloc() isn&squot;t initialized yet. */
DECL|macro|KMAP_POOL_SIZE
mdefine_line|#define&t;KMAP_POOL_SIZE&t;16
multiline_comment|/* structure for maintainance of kmap regions */
DECL|struct|kmap
r_typedef
r_struct
id|kmap
(brace
DECL|member|next
DECL|member|prev
r_struct
id|kmap
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
multiline_comment|/* linking of list */
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* start address of region */
DECL|member|mapaddr
r_int
r_int
id|mapaddr
suffix:semicolon
multiline_comment|/* address returned to user */
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* size of region */
DECL|member|free
r_int
id|free
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* flag whether free or allocated */
DECL|member|kmalloced
r_int
id|kmalloced
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* flag whether got this from kmalloc() */
DECL|member|pool_alloc
r_int
id|pool_alloc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* flag whether got this is alloced in pool */
DECL|typedef|KMAP
)brace
id|KMAP
suffix:semicolon
DECL|variable|kmap_pool
id|KMAP
id|kmap_pool
(braket
id|KMAP_POOL_SIZE
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
comma
id|KMAP_START
comma
id|KMAP_START
comma
id|KMAP_END
op_minus
id|KMAP_START
comma
l_int|1
comma
l_int|0
comma
l_int|1
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * anchor of kmap region list&n; *&n; * The list is always ordered by addresses, and regions are always adjacent,&n; * i.e. there must be no holes between them!&n; */
DECL|variable|kmap_regions
id|KMAP
op_star
id|kmap_regions
op_assign
op_amp
id|kmap_pool
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* for protecting the kmap_regions list against races */
DECL|variable|kmap_sem
r_static
r_struct
id|semaphore
id|kmap_sem
op_assign
id|MUTEX
suffix:semicolon
multiline_comment|/*&n; * Low-level allocation and freeing of KMAP structures&n; */
DECL|function|alloc_kmap
r_static
id|KMAP
op_star
id|alloc_kmap
c_func
(paren
r_int
id|use_kmalloc
)paren
(brace
id|KMAP
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* first try to get from the pool if possible */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|KMAP_POOL_SIZE
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kmap_pool
(braket
id|i
)braket
dot
id|pool_alloc
)paren
(brace
id|kmap_pool
(braket
id|i
)braket
dot
id|kmalloced
op_assign
l_int|0
suffix:semicolon
id|kmap_pool
(braket
id|i
)braket
dot
id|pool_alloc
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|kmap_pool
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|use_kmalloc
op_logical_and
(paren
id|p
op_assign
(paren
id|KMAP
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|KMAP
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|p-&gt;kmalloced
op_assign
l_int|1
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|free_kmap
r_static
r_void
id|free_kmap
c_func
(paren
id|KMAP
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;kmalloced
)paren
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_else
id|p-&gt;pool_alloc
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a free region from the kmap address range&n; */
DECL|function|kmap_get_region
r_static
id|KMAP
op_star
id|kmap_get_region
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|use_kmalloc
)paren
(brace
id|KMAP
op_star
id|p
comma
op_star
id|q
suffix:semicolon
multiline_comment|/* look for a suitable free region */
r_for
c_loop
(paren
id|p
op_assign
id|kmap_regions
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
r_if
c_cond
(paren
id|p-&gt;free
op_logical_and
id|p-&gt;size
op_ge
id|size
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_map: address space for &quot;
l_string|&quot;allocations exhausted&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;size
OG
id|size
)paren
(brace
multiline_comment|/* if free region is bigger than we need, split off the rear free part&n;&t;&t; * into a new region */
r_if
c_cond
(paren
op_logical_neg
(paren
id|q
op_assign
id|alloc_kmap
c_func
(paren
id|use_kmalloc
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_map: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|q-&gt;addr
op_assign
id|p-&gt;addr
op_plus
id|size
suffix:semicolon
id|q-&gt;size
op_assign
id|p-&gt;size
op_minus
id|size
suffix:semicolon
id|p-&gt;size
op_assign
id|size
suffix:semicolon
id|q-&gt;free
op_assign
l_int|1
suffix:semicolon
id|q-&gt;prev
op_assign
id|p
suffix:semicolon
id|q-&gt;next
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
id|q
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;next
)paren
id|q-&gt;next-&gt;prev
op_assign
id|q
suffix:semicolon
)brace
id|p-&gt;free
op_assign
l_int|0
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a kernel_map region again&n; */
DECL|function|kmap_put_region
r_static
r_void
id|kmap_put_region
c_func
(paren
id|KMAP
op_star
id|p
)paren
(brace
id|KMAP
op_star
id|q
suffix:semicolon
id|p-&gt;free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* merge with previous region if possible */
id|q
op_assign
id|p-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|q
op_logical_and
id|q-&gt;free
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;addr
op_plus
id|q-&gt;size
op_ne
id|p-&gt;addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_malloc: allocation list destroyed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|q-&gt;size
op_add_assign
id|p-&gt;size
suffix:semicolon
id|q-&gt;next
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;next
)paren
id|p-&gt;next-&gt;prev
op_assign
id|q
suffix:semicolon
id|free_kmap
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|q
suffix:semicolon
)brace
multiline_comment|/* merge with following region if possible */
id|q
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|q
op_logical_and
id|q-&gt;free
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;addr
op_plus
id|p-&gt;size
op_ne
id|q-&gt;addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_malloc: allocation list destroyed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p-&gt;size
op_add_assign
id|q-&gt;size
suffix:semicolon
id|p-&gt;next
op_assign
id|q-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;next
)paren
id|q-&gt;next-&gt;prev
op_assign
id|p
suffix:semicolon
id|free_kmap
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * kernel_map() helpers&n; */
r_static
r_inline
id|pte_t
op_star
DECL|function|pte_alloc_kernel_map
id|pte_alloc_kernel_map
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
op_star
id|memavailp
)paren
(brace
id|address
op_assign
(paren
id|address
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_t
op_star
id|page
op_assign
id|kernel_page_table
c_func
(paren
id|memavailp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
(brace
id|pmd_set
c_func
(paren
id|pmd
comma
id|page
)paren
suffix:semicolon
id|memset
c_func
(paren
id|page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|page
op_plus
id|address
suffix:semicolon
)brace
id|pmd_set
c_func
(paren
id|pmd
comma
id|BAD_PAGETABLE
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memavailp
)paren
id|panic
c_func
(paren
l_string|&quot;kernel_map: slept during init?!?&quot;
)paren
suffix:semicolon
id|cache_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Bad pmd in pte_alloc_kernel_map: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_set
c_func
(paren
id|pmd
comma
id|BAD_PAGETABLE
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|address
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kernel_map_pte
id|kernel_map_pte
c_func
(paren
id|pte_t
op_star
id|pte
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
r_int
id|phys_addr
comma
id|pgprot_t
id|prot
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
r_do
(brace
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_assign
id|phys_addr
op_plus
id|pgprot_val
c_func
(paren
id|prot
)paren
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|phys_addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|kernel_map_pmd
id|kernel_map_pmd
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
r_int
id|phys_addr
comma
id|pgprot_t
id|prot
comma
r_int
r_int
op_star
id|memavailp
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
id|phys_addr
op_sub_assign
id|address
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_do
(brace
id|pte_t
op_star
id|pte
op_assign
id|pte_alloc_kernel_map
c_func
(paren
id|pmd
comma
id|address
comma
id|memavailp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|kernel_map_pte
c_func
(paren
id|pte
comma
id|address
comma
id|end
op_minus
id|address
comma
id|address
op_plus
id|phys_addr
comma
id|prot
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* On the 68030 we use early termination page descriptors.&n;&t;&t;   Each one points to 64 pages (256K). */
r_int
id|i
op_assign
(paren
id|address
op_rshift
(paren
id|PMD_SHIFT
op_minus
l_int|4
)paren
)paren
op_amp
l_int|15
suffix:semicolon
r_do
(brace
(paren
op_amp
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
(braket
id|i
op_increment
)braket
op_assign
(paren
id|address
op_plus
id|phys_addr
)paren
op_or
id|pgprot_val
c_func
(paren
id|prot
)paren
suffix:semicolon
id|address
op_add_assign
id|PMD_SIZE
op_div
l_int|16
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Map some physical address range into the kernel address space. The&n; * code is copied and adapted from map_chunk().&n; */
multiline_comment|/* Rewritten by Andreas Schwab to remove all races. */
DECL|function|kernel_map
r_int
r_int
id|kernel_map
c_func
(paren
r_int
r_int
id|phys_addr
comma
r_int
r_int
id|size
comma
r_int
id|cacheflag
comma
r_int
r_int
op_star
id|memavailp
)paren
(brace
r_int
r_int
id|retaddr
comma
id|from
comma
id|end
suffix:semicolon
id|pgd_t
op_star
id|dir
suffix:semicolon
id|pgprot_t
id|prot
suffix:semicolon
id|KMAP
op_star
id|kmap
suffix:semicolon
multiline_comment|/* Round down &squot;phys_addr&squot; to 256 KB and adjust size */
id|retaddr
op_assign
id|phys_addr
op_amp
(paren
id|KMAP_STEP
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_add_assign
id|retaddr
suffix:semicolon
id|phys_addr
op_and_assign
op_complement
(paren
id|KMAP_STEP
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Round up the size to 256 KB. It doesn&squot;t hurt if too much is&n;&t;   mapped... */
id|size
op_assign
(paren
id|size
op_plus
id|KMAP_STEP
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|KMAP_STEP
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|kmap_sem
)paren
suffix:semicolon
id|kmap
op_assign
id|kmap_get_region
c_func
(paren
id|size
comma
id|memavailp
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kmap
)paren
(brace
id|up
c_func
(paren
op_amp
id|kmap_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|from
op_assign
id|kmap-&gt;addr
suffix:semicolon
id|retaddr
op_add_assign
id|from
suffix:semicolon
id|kmap-&gt;mapaddr
op_assign
id|retaddr
suffix:semicolon
id|end
op_assign
id|from
op_plus
id|size
suffix:semicolon
id|up
c_func
(paren
op_amp
id|kmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
id|pgprot_val
c_func
(paren
id|prot
)paren
op_assign
(paren
id|_PAGE_PRESENT
op_or
id|_PAGE_GLOBAL040
op_or
id|_PAGE_ACCESSED
op_or
id|_PAGE_DIRTY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cacheflag
)paren
(brace
r_case
id|KERNELMAP_FULL_CACHING
suffix:colon
id|pgprot_val
c_func
(paren
id|prot
)paren
op_or_assign
id|_PAGE_CACHE040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_SER
suffix:colon
r_default
suffix:colon
id|pgprot_val
c_func
(paren
id|prot
)paren
op_or_assign
id|_PAGE_NOCACHE_S
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_NONSER
suffix:colon
id|pgprot_val
c_func
(paren
id|prot
)paren
op_or_assign
id|_PAGE_NOCACHE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NO_COPYBACK
suffix:colon
id|pgprot_val
c_func
(paren
id|prot
)paren
op_or_assign
id|_PAGE_CACHE040W
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|pgprot_val
c_func
(paren
id|prot
)paren
op_assign
(paren
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
op_or
id|_PAGE_DIRTY
op_or
(paren
(paren
id|cacheflag
op_eq
id|KERNELMAP_FULL_CACHING
op_logical_or
id|cacheflag
op_eq
id|KERNELMAP_NO_COPYBACK
)paren
ques
c_cond
l_int|0
suffix:colon
id|_PAGE_NOCACHE030
)paren
)paren
suffix:semicolon
id|phys_addr
op_sub_assign
id|from
suffix:semicolon
id|dir
op_assign
id|pgd_offset_k
c_func
(paren
id|from
)paren
suffix:semicolon
r_while
c_loop
(paren
id|from
OL
id|end
)paren
(brace
id|pmd_t
op_star
id|pmd
op_assign
id|pmd_alloc_kernel
c_func
(paren
id|dir
comma
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kernel_map_pmd
c_func
(paren
id|pmd
comma
id|from
comma
id|end
op_minus
id|from
comma
id|phys_addr
op_plus
id|from
comma
id|prot
comma
id|memavailp
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_map: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0UL
suffix:semicolon
)brace
id|from
op_assign
(paren
id|from
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|dir
op_increment
suffix:semicolon
)brace
r_return
id|retaddr
suffix:semicolon
)brace
multiline_comment|/*&n; * kernel_unmap() helpers&n; */
DECL|function|pte_free_kernel_unmap
r_static
r_inline
r_void
id|pte_free_kernel_unmap
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
r_int
r_int
id|page
op_assign
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
suffix:semicolon
id|mem_map_t
op_star
id|pagemap
op_assign
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
suffix:semicolon
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
id|cache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|pagemap
)paren
)paren
(brace
multiline_comment|/* need to unreserve pages that were allocated with memavailp != NULL;&n;&t;&t; * this works only if &squot;page&squot; is page-aligned */
r_if
c_cond
(paren
id|page
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|pagemap-&gt;flags
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pagemap-&gt;count
comma
l_int|1
)paren
suffix:semicolon
)brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This not only unmaps the requested region, but also loops over the whole&n; * pmd to determine whether the other pte&squot;s are clear (so that the page can be&n; * freed.) If so, it returns 1, 0 otherwise.&n; */
r_static
r_inline
r_int
DECL|function|kernel_unmap_pte_range
id|kernel_unmap_pte_range
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|addr2
comma
id|end
comma
id|end2
suffix:semicolon
r_int
id|all_clear
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_unmap_pte_range: bad pmd (%08lx)&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|addr2
op_assign
l_int|0
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|addr2
)paren
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
id|end2
op_assign
id|addr2
op_plus
id|PMD_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|addr2
OL
id|end2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pte_none
c_func
(paren
op_star
id|pte
)paren
)paren
(brace
r_if
c_cond
(paren
id|address
op_le
id|addr2
op_logical_and
id|addr2
OL
id|end
)paren
id|pte_clear
c_func
(paren
id|pte
)paren
suffix:semicolon
r_else
id|all_clear
op_assign
l_int|0
suffix:semicolon
)brace
op_increment
id|pte
suffix:semicolon
id|addr2
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
id|all_clear
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kernel_unmap_pmd_range
id|kernel_unmap_pmd_range
c_func
(paren
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_unmap_pmd_range: bad pgd (%08lx)&bslash;n&quot;
comma
id|pgd_val
c_func
(paren
op_star
id|dir
)paren
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|kernel_unmap_pte_range
c_func
(paren
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
)paren
)paren
id|pte_free_kernel_unmap
c_func
(paren
id|pmd
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* On the 68030 clear the early termination descriptors */
r_int
id|i
op_assign
(paren
id|address
op_rshift
(paren
id|PMD_SHIFT
op_minus
l_int|4
)paren
)paren
op_amp
l_int|15
suffix:semicolon
r_do
(brace
(paren
op_amp
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|address
op_add_assign
id|PMD_SIZE
op_div
l_int|16
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Unmap a kernel_map()ed region again&n; */
DECL|function|kernel_unmap
r_void
id|kernel_unmap
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
id|pgd_t
op_star
id|dir
suffix:semicolon
id|KMAP
op_star
id|p
suffix:semicolon
id|down
c_func
(paren
op_amp
id|kmap_sem
)paren
suffix:semicolon
multiline_comment|/* find region for &squot;addr&squot; in list; must search for mapaddr! */
r_for
c_loop
(paren
id|p
op_assign
id|kmap_regions
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;free
op_logical_and
id|p-&gt;mapaddr
op_eq
id|addr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kernel_unmap: trying to free invalid region&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|addr
op_assign
id|p-&gt;addr
suffix:semicolon
id|end
op_assign
id|addr
op_plus
id|p-&gt;size
suffix:semicolon
id|kmap_put_region
c_func
(paren
id|p
)paren
suffix:semicolon
id|dir
op_assign
id|pgd_offset_k
c_func
(paren
id|addr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|addr
OL
id|end
)paren
(brace
id|kernel_unmap_pmd_range
c_func
(paren
id|dir
comma
id|addr
comma
id|end
op_minus
id|addr
)paren
suffix:semicolon
id|addr
op_assign
(paren
id|addr
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|dir
op_increment
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|kmap_sem
)paren
suffix:semicolon
multiline_comment|/* flushing for a range would do, but there&squot;s no such function for kernel&n;&t; * address space... */
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * kernel_set_cachemode() helpers&n; */
DECL|function|set_cmode_pte
r_static
r_inline
r_void
id|set_cmode_pte
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ge
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|pte
op_increment
)paren
(brace
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_assign
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
op_complement
id|_PAGE_NOCACHE
)paren
op_or
id|cmode
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
DECL|function|set_cmode_pmd
r_static
r_inline
r_void
id|set_cmode_pmd
c_func
(paren
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_amp
id|_DESCTYPE_MASK
)paren
op_eq
id|_PAGE_PRESENT
)paren
(brace
multiline_comment|/* 68030 early termination descriptor */
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_amp
op_complement
id|_PAGE_NOCACHE
)paren
op_or
id|cmode
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &quot;normal&quot; tables */
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|pmd
op_increment
)paren
(brace
id|set_cmode_pte
c_func
(paren
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|cmode
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Set new cache mode for some kernel address space.&n; * The caller must push data for that range itself, if such data may already&n; * be in the cache.&n; */
DECL|function|kernel_set_cachemode
r_void
id|kernel_set_cachemode
c_func
(paren
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
id|cmode
)paren
(brace
id|pgd_t
op_star
id|dir
op_assign
id|pgd_offset_k
c_func
(paren
id|address
)paren
suffix:semicolon
r_int
r_int
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|CPU_IS_040_OR_060
)paren
(brace
r_switch
c_cond
(paren
id|cmode
)paren
(brace
r_case
id|KERNELMAP_FULL_CACHING
suffix:colon
id|cmode
op_assign
id|_PAGE_CACHE040
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_SER
suffix:colon
r_default
suffix:colon
id|cmode
op_assign
id|_PAGE_NOCACHE_S
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NOCACHE_NONSER
suffix:colon
id|cmode
op_assign
id|_PAGE_NOCACHE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KERNELMAP_NO_COPYBACK
suffix:colon
id|cmode
op_assign
id|_PAGE_CACHE040W
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|cmode
op_assign
(paren
(paren
id|cmode
op_eq
id|KERNELMAP_FULL_CACHING
op_logical_or
id|cmode
op_eq
id|KERNELMAP_NO_COPYBACK
)paren
ques
c_cond
l_int|0
suffix:colon
id|_PAGE_NOCACHE030
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|dir
op_increment
)paren
(brace
id|set_cmode_pmd
c_func
(paren
id|dir
comma
id|address
comma
id|end
op_minus
id|address
comma
id|cmode
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
)brace
multiline_comment|/* flushing for a range would do, but there&squot;s no such function for kernel&n;&t; * address space... */
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
eof
