multiline_comment|/* multi_arith.h: multi-precision integer arithmetic functions, needed&n;   to do extended-precision floating point.&n;&n;   (c) 1998 David Huggins-Daines.&n;&n;   Somewhat based on arch/alpha/math-emu/ieee-math.c, which is (c)&n;   David Mosberger-Tang.&n;&n;   You may copy, modify, and redistribute this file under the terms of&n;   the GNU General Public License, version 2, or any later version, at&n;   your convenience. */
multiline_comment|/* Note:&n;&n;   These are not general multi-precision math routines.  Rather, they&n;   implement the subset of integer arithmetic that we need in order to&n;   multiply, divide, and normalize 128-bit unsigned mantissae.  */
macro_line|#ifndef MULTI_ARITH_H
DECL|macro|MULTI_ARITH_H
mdefine_line|#define MULTI_ARITH_H
macro_line|#if 0&t;/* old code... */
multiline_comment|/* Unsigned only, because we don&squot;t need signs to multiply and divide. */
r_typedef
r_int
r_int
id|int128
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Word order */
r_enum
(brace
id|MSW128
comma
id|NMSW128
comma
id|NLSW128
comma
id|LSW128
)brace
suffix:semicolon
multiline_comment|/* big-endian */
mdefine_line|#define LO_WORD(ll) (((unsigned int *) &amp;ll)[1])
mdefine_line|#define HI_WORD(ll) (((unsigned int *) &amp;ll)[0])
multiline_comment|/* Convenience functions to stuff various integer values into int128s */
r_extern
r_inline
r_void
id|zero128
c_func
(paren
id|int128
id|a
)paren
(brace
id|a
(braket
id|LSW128
)braket
op_assign
id|a
(braket
id|NLSW128
)braket
op_assign
id|a
(braket
id|NMSW128
)braket
op_assign
id|a
(braket
id|MSW128
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Human-readable word order in the arguments */
r_extern
r_inline
r_void
id|set128
c_func
(paren
r_int
r_int
id|i3
comma
r_int
r_int
id|i2
comma
r_int
r_int
id|i1
comma
r_int
r_int
id|i0
comma
id|int128
id|a
)paren
(brace
id|a
(braket
id|LSW128
)braket
op_assign
id|i0
suffix:semicolon
id|a
(braket
id|NLSW128
)braket
op_assign
id|i1
suffix:semicolon
id|a
(braket
id|NMSW128
)braket
op_assign
id|i2
suffix:semicolon
id|a
(braket
id|MSW128
)braket
op_assign
id|i3
suffix:semicolon
)brace
multiline_comment|/* Convenience functions (for testing as well) */
r_extern
r_inline
r_void
id|int64_to_128
c_func
(paren
r_int
r_int
r_int
id|src
comma
id|int128
id|dest
)paren
(brace
id|dest
(braket
id|LSW128
)braket
op_assign
(paren
r_int
r_int
)paren
id|src
suffix:semicolon
id|dest
(braket
id|NLSW128
)braket
op_assign
id|src
op_rshift
l_int|32
suffix:semicolon
id|dest
(braket
id|NMSW128
)braket
op_assign
id|dest
(braket
id|MSW128
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|int128_to_64
c_func
(paren
r_const
id|int128
id|src
comma
r_int
r_int
r_int
op_star
id|dest
)paren
(brace
op_star
id|dest
op_assign
id|src
(braket
id|LSW128
)braket
op_or
(paren
r_int
r_int
)paren
id|src
(braket
id|NLSW128
)braket
op_lshift
l_int|32
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|put_i128
c_func
(paren
r_const
id|int128
id|a
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08x %08x %08x %08x&bslash;n&quot;
comma
id|a
(braket
id|MSW128
)braket
comma
id|a
(braket
id|NMSW128
)braket
comma
id|a
(braket
id|NLSW128
)braket
comma
id|a
(braket
id|LSW128
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Internal shifters:&n;&n;   Note that these are only good for 0 &lt; count &lt; 32.&n; */
r_extern
r_inline
r_void
id|_lsl128
c_func
(paren
r_int
r_int
id|count
comma
id|int128
id|a
)paren
(brace
id|a
(braket
id|MSW128
)braket
op_assign
(paren
id|a
(braket
id|MSW128
)braket
op_lshift
id|count
)paren
op_or
(paren
id|a
(braket
id|NMSW128
)braket
op_rshift
(paren
l_int|32
op_minus
id|count
)paren
)paren
suffix:semicolon
id|a
(braket
id|NMSW128
)braket
op_assign
(paren
id|a
(braket
id|NMSW128
)braket
op_lshift
id|count
)paren
op_or
(paren
id|a
(braket
id|NLSW128
)braket
op_rshift
(paren
l_int|32
op_minus
id|count
)paren
)paren
suffix:semicolon
id|a
(braket
id|NLSW128
)braket
op_assign
(paren
id|a
(braket
id|NLSW128
)braket
op_lshift
id|count
)paren
op_or
(paren
id|a
(braket
id|LSW128
)braket
op_rshift
(paren
l_int|32
op_minus
id|count
)paren
)paren
suffix:semicolon
id|a
(braket
id|LSW128
)braket
op_lshift_assign
id|count
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|_lsr128
c_func
(paren
r_int
r_int
id|count
comma
id|int128
id|a
)paren
(brace
id|a
(braket
id|LSW128
)braket
op_assign
(paren
id|a
(braket
id|LSW128
)braket
op_rshift
id|count
)paren
op_or
(paren
id|a
(braket
id|NLSW128
)braket
op_lshift
(paren
l_int|32
op_minus
id|count
)paren
)paren
suffix:semicolon
id|a
(braket
id|NLSW128
)braket
op_assign
(paren
id|a
(braket
id|NLSW128
)braket
op_rshift
id|count
)paren
op_or
(paren
id|a
(braket
id|NMSW128
)braket
op_lshift
(paren
l_int|32
op_minus
id|count
)paren
)paren
suffix:semicolon
id|a
(braket
id|NMSW128
)braket
op_assign
(paren
id|a
(braket
id|NMSW128
)braket
op_rshift
id|count
)paren
op_or
(paren
id|a
(braket
id|MSW128
)braket
op_lshift
(paren
l_int|32
op_minus
id|count
)paren
)paren
suffix:semicolon
id|a
(braket
id|MSW128
)braket
op_rshift_assign
id|count
suffix:semicolon
)brace
multiline_comment|/* Should be faster, one would hope */
r_extern
r_inline
r_void
id|lslone128
c_func
(paren
id|int128
id|a
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;lsl.l #1,%0&bslash;n&quot;
l_string|&quot;roxl.l #1,%1&bslash;n&quot;
l_string|&quot;roxl.l #1,%2&bslash;n&quot;
l_string|&quot;roxl.l #1,%3&bslash;n&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|LSW128
)braket
)paren
comma
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|NLSW128
)braket
)paren
comma
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|NMSW128
)braket
)paren
comma
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|MSW128
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|a
(braket
id|LSW128
)braket
)paren
comma
l_string|&quot;1&quot;
(paren
id|a
(braket
id|NLSW128
)braket
)paren
comma
l_string|&quot;2&quot;
(paren
id|a
(braket
id|NMSW128
)braket
)paren
comma
l_string|&quot;3&quot;
(paren
id|a
(braket
id|MSW128
)braket
)paren
)paren
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|lsrone128
c_func
(paren
id|int128
id|a
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;lsr.l #1,%0&bslash;n&quot;
l_string|&quot;roxr.l #1,%1&bslash;n&quot;
l_string|&quot;roxr.l #1,%2&bslash;n&quot;
l_string|&quot;roxr.l #1,%3&bslash;n&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|MSW128
)braket
)paren
comma
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|NMSW128
)braket
)paren
comma
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|NLSW128
)braket
)paren
comma
l_string|&quot;=d&quot;
(paren
id|a
(braket
id|LSW128
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|a
(braket
id|MSW128
)braket
)paren
comma
l_string|&quot;1&quot;
(paren
id|a
(braket
id|NMSW128
)braket
)paren
comma
l_string|&quot;2&quot;
(paren
id|a
(braket
id|NLSW128
)braket
)paren
comma
l_string|&quot;3&quot;
(paren
id|a
(braket
id|LSW128
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Generalized 128-bit shifters:&n;&n;   These bit-shift to a multiple of 32, then move whole longwords.  */
r_extern
r_inline
r_void
id|lsl128
c_func
(paren
r_int
r_int
id|count
comma
id|int128
id|a
)paren
(brace
r_int
id|wordcount
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|count
op_mod
l_int|32
)paren
id|_lsl128
c_func
(paren
id|count
op_mod
l_int|32
comma
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|wordcount
op_assign
id|count
op_div
l_int|32
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* argh, gak, endian-sensitive */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
op_minus
id|wordcount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|a
(braket
id|i
)braket
op_assign
id|a
(braket
id|i
op_plus
id|wordcount
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_ge
l_int|4
op_minus
id|wordcount
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|a
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_extern
r_inline
r_void
id|lsr128
c_func
(paren
r_int
r_int
id|count
comma
id|int128
id|a
)paren
(brace
r_int
id|wordcount
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|count
op_mod
l_int|32
)paren
id|_lsr128
c_func
(paren
id|count
op_mod
l_int|32
comma
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|wordcount
op_assign
id|count
op_div
l_int|32
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_ge
id|wordcount
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|a
(braket
id|i
)braket
op_assign
id|a
(braket
id|i
op_minus
id|wordcount
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wordcount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|a
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_extern
r_inline
r_int
id|orl128
c_func
(paren
r_int
id|a
comma
id|int128
id|b
)paren
(brace
id|b
(braket
id|LSW128
)braket
op_or_assign
id|a
suffix:semicolon
)brace
r_extern
r_inline
r_int
id|btsthi128
c_func
(paren
r_const
id|int128
id|a
)paren
(brace
r_return
id|a
(braket
id|MSW128
)braket
op_amp
l_int|0x80000000
suffix:semicolon
)brace
multiline_comment|/* test bits (numbered from 0 = LSB) up to and including &quot;top&quot; */
r_extern
r_inline
r_int
id|bftestlo128
c_func
(paren
r_int
id|top
comma
r_const
id|int128
id|a
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|top
OG
l_int|31
)paren
id|r
op_or_assign
id|a
(braket
id|LSW128
)braket
suffix:semicolon
r_if
c_cond
(paren
id|top
OG
l_int|63
)paren
id|r
op_or_assign
id|a
(braket
id|NLSW128
)braket
suffix:semicolon
r_if
c_cond
(paren
id|top
OG
l_int|95
)paren
id|r
op_or_assign
id|a
(braket
id|NMSW128
)braket
suffix:semicolon
id|r
op_or_assign
id|a
(braket
l_int|3
op_minus
(paren
id|top
op_div
l_int|32
)paren
)braket
op_amp
(paren
(paren
l_int|1
op_lshift
(paren
id|top
op_mod
l_int|32
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|r
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Aargh.  We need these because GCC is broken */
multiline_comment|/* FIXME: do them in assembly, for goodness&squot; sake! */
r_extern
r_inline
r_void
id|mask64
c_func
(paren
r_int
id|pos
comma
r_int
r_int
r_int
op_star
id|mask
)paren
(brace
op_star
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|32
)paren
(brace
id|LO_WORD
c_func
(paren
op_star
id|mask
)paren
op_assign
(paren
l_int|1
op_lshift
id|pos
)paren
op_minus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|LO_WORD
c_func
(paren
op_star
id|mask
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|HI_WORD
c_func
(paren
op_star
id|mask
)paren
op_assign
(paren
l_int|1
op_lshift
(paren
id|pos
op_minus
l_int|32
)paren
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|bset64
c_func
(paren
r_int
id|pos
comma
r_int
r_int
r_int
op_star
id|dest
)paren
(brace
multiline_comment|/* This conditional will be optimized away.  Thanks, GCC! */
r_if
c_cond
(paren
id|pos
OL
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;bset %1,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
)paren
suffix:colon
l_string|&quot;id&quot;
(paren
id|pos
)paren
)paren
suffix:semicolon
r_else
id|asm
r_volatile
(paren
l_string|&quot;bset %1,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
)paren
suffix:colon
l_string|&quot;id&quot;
(paren
id|pos
op_minus
l_int|32
)paren
)paren
suffix:semicolon
)brace
r_extern
r_inline
r_int
id|btst64
c_func
(paren
r_int
id|pos
comma
r_int
r_int
r_int
id|dest
)paren
(brace
r_if
c_cond
(paren
id|pos
OL
l_int|32
)paren
r_return
(paren
l_int|0
op_ne
(paren
id|LO_WORD
c_func
(paren
id|dest
)paren
op_amp
(paren
l_int|1
op_lshift
id|pos
)paren
)paren
)paren
suffix:semicolon
r_else
r_return
(paren
l_int|0
op_ne
(paren
id|HI_WORD
c_func
(paren
id|dest
)paren
op_amp
(paren
l_int|1
op_lshift
(paren
id|pos
op_minus
l_int|32
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|lsl64
c_func
(paren
r_int
id|count
comma
r_int
r_int
r_int
op_star
id|dest
)paren
(brace
r_if
c_cond
(paren
id|count
OL
l_int|32
)paren
(brace
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
op_assign
(paren
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
op_lshift
id|count
)paren
op_or
(paren
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
op_rshift
id|count
)paren
suffix:semicolon
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
op_lshift_assign
id|count
suffix:semicolon
r_return
suffix:semicolon
)brace
id|count
op_sub_assign
l_int|32
suffix:semicolon
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
op_assign
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
op_lshift
id|count
suffix:semicolon
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
op_assign
l_int|0
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|lsr64
c_func
(paren
r_int
id|count
comma
r_int
r_int
r_int
op_star
id|dest
)paren
(brace
r_if
c_cond
(paren
id|count
OL
l_int|32
)paren
(brace
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
op_assign
(paren
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
op_rshift
id|count
)paren
op_or
(paren
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
op_lshift
(paren
l_int|32
op_minus
id|count
)paren
)paren
suffix:semicolon
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
op_rshift_assign
id|count
suffix:semicolon
r_return
suffix:semicolon
)brace
id|count
op_sub_assign
l_int|32
suffix:semicolon
id|LO_WORD
c_func
(paren
op_star
id|dest
)paren
op_assign
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
op_rshift
id|count
suffix:semicolon
id|HI_WORD
c_func
(paren
op_star
id|dest
)paren
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fp_denormalize
r_extern
r_inline
r_void
id|fp_denormalize
c_func
(paren
r_struct
id|fp_ext
op_star
id|reg
comma
r_int
r_int
id|cnt
)paren
(brace
id|reg-&gt;exp
op_add_assign
id|cnt
suffix:semicolon
r_switch
c_cond
(paren
id|cnt
)paren
(brace
r_case
l_int|0
dot
dot
dot
l_int|8
suffix:colon
id|reg-&gt;lowmant
op_assign
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_lshift
(paren
l_int|8
op_minus
id|cnt
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_rshift
id|cnt
)paren
op_or
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_lshift
(paren
l_int|32
op_minus
id|cnt
)paren
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_rshift
id|cnt
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
dot
dot
dot
l_int|32
suffix:colon
id|reg-&gt;lowmant
op_assign
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_rshift
(paren
id|cnt
op_minus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_lshift
(paren
l_int|40
op_minus
id|cnt
)paren
)paren
id|reg-&gt;lowmant
op_or_assign
l_int|1
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_rshift
id|cnt
)paren
op_or
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_lshift
(paren
l_int|32
op_minus
id|cnt
)paren
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_rshift
id|cnt
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|33
dot
dot
dot
l_int|39
suffix:colon
id|asm
r_volatile
(paren
l_string|&quot;bfextu %1{%2,#8},%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|reg-&gt;lowmant
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;d&quot;
(paren
l_int|64
op_minus
id|cnt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_lshift
(paren
l_int|40
op_minus
id|cnt
)paren
)paren
id|reg-&gt;lowmant
op_or_assign
l_int|1
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_rshift
(paren
id|cnt
op_minus
l_int|32
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|40
dot
dot
dot
l_int|71
suffix:colon
id|reg-&gt;lowmant
op_assign
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_rshift
(paren
id|cnt
op_minus
l_int|40
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_lshift
(paren
l_int|72
op_minus
id|cnt
)paren
)paren
op_logical_or
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
)paren
id|reg-&gt;lowmant
op_or_assign
l_int|1
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_rshift
(paren
id|cnt
op_minus
l_int|32
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|reg-&gt;lowmant
op_assign
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_logical_or
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|fp_overnormalize
r_extern
r_inline
r_int
id|fp_overnormalize
c_func
(paren
r_struct
id|fp_ext
op_star
id|reg
)paren
(brace
r_int
id|shift
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
)paren
(brace
id|asm
(paren
l_string|&quot;bfffo %1{#0,#32},%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|shift
)paren
suffix:colon
l_string|&quot;dm&quot;
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_lshift
id|shift
)paren
op_or
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_lshift
id|shift
)paren
suffix:semicolon
)brace
r_else
(brace
id|asm
(paren
l_string|&quot;bfffo %1{#0,#32},%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|shift
)paren
suffix:colon
l_string|&quot;dm&quot;
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_lshift
id|shift
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|shift
op_add_assign
l_int|32
suffix:semicolon
)brace
r_return
id|shift
suffix:semicolon
)brace
DECL|function|fp_addmant
r_extern
r_inline
r_int
id|fp_addmant
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
r_int
id|carry
suffix:semicolon
multiline_comment|/* we assume here, gcc only insert move and a clr instr */
id|asm
r_volatile
(paren
l_string|&quot;add.b %1,%0&quot;
suffix:colon
l_string|&quot;=d,=g&quot;
(paren
id|dest-&gt;lowmant
)paren
suffix:colon
l_string|&quot;g,d&quot;
(paren
id|src-&gt;lowmant
)paren
comma
l_string|&quot;0,0&quot;
(paren
id|dest-&gt;lowmant
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;addx.l %1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|src-&gt;mant.m32
(braket
l_int|1
)braket
)paren
comma
l_string|&quot;0&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;addx.l %1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|src-&gt;mant.m32
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;0&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;addx.l %0,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|carry
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|carry
suffix:semicolon
)brace
DECL|function|fp_addcarry
r_extern
r_inline
r_int
id|fp_addcarry
c_func
(paren
r_struct
id|fp_ext
op_star
id|reg
)paren
(brace
r_if
c_cond
(paren
op_increment
id|reg-&gt;exp
op_eq
l_int|0x7fff
)paren
(brace
r_if
c_cond
(paren
id|reg-&gt;mant.m64
)paren
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_INEX2
)paren
suffix:semicolon
id|reg-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_OVFL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|reg-&gt;lowmant
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_lshift
l_int|7
)paren
op_or
(paren
id|reg-&gt;lowmant
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|1
)braket
op_rshift
l_int|1
)paren
op_or
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_lshift
l_int|31
)paren
suffix:semicolon
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
(paren
id|reg-&gt;mant.m32
(braket
l_int|0
)braket
op_rshift
l_int|1
)paren
op_or
l_int|0x80000000
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fp_submant
r_extern
r_inline
r_void
id|fp_submant
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src1
comma
r_struct
id|fp_ext
op_star
id|src2
)paren
(brace
multiline_comment|/* we assume here, gcc only insert move and a clr instr */
id|asm
r_volatile
(paren
l_string|&quot;sub.b %1,%0&quot;
suffix:colon
l_string|&quot;=d,=g&quot;
(paren
id|dest-&gt;lowmant
)paren
suffix:colon
l_string|&quot;g,d&quot;
(paren
id|src2-&gt;lowmant
)paren
comma
l_string|&quot;0,0&quot;
(paren
id|src1-&gt;lowmant
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;subx.l %1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|src2-&gt;mant.m32
(braket
l_int|1
)braket
)paren
comma
l_string|&quot;0&quot;
(paren
id|src1-&gt;mant.m32
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;subx.l %1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|src2-&gt;mant.m32
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;0&quot;
(paren
id|src1-&gt;mant.m32
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
DECL|macro|fp_mul64
mdefine_line|#define fp_mul64(desth, destl, src1, src2) ({&t;&t;&t;&t;&bslash;&n;&t;asm (&quot;mulu.l %2,%1:%0&quot; : &quot;=d&quot; (destl), &quot;=d&quot; (desth)&t;&t;&bslash;&n;&t;&t;: &quot;g&quot; (src1), &quot;0&quot; (src2));&t;&t;&t;&t;&bslash;&n;})
DECL|macro|fp_div64
mdefine_line|#define fp_div64(quot, rem, srch, srcl, div)&t;&t;&t;&t;&bslash;&n;&t;asm (&quot;divu.l %2,%1:%0&quot; : &quot;=d&quot; (quot), &quot;=d&quot; (rem)&t;&t;&bslash;&n;&t;&t;: &quot;dm&quot; (div), &quot;1&quot; (srch), &quot;0&quot; (srcl))
DECL|macro|fp_add64
mdefine_line|#define fp_add64(dest1, dest2, src1, src2) ({&t;&t;&t;&t;&bslash;&n;&t;asm (&quot;add.l %1,%0&quot; : &quot;=d,=dm&quot; (dest2)&t;&t;&t;&t;&bslash;&n;&t;&t;: &quot;dm,d&quot; (src2), &quot;0,0&quot; (dest2));&t;&t;&t;&bslash;&n;&t;asm (&quot;addx.l %1,%0&quot; : &quot;=d&quot; (dest1)&t;&t;&t;&t;&bslash;&n;&t;&t;: &quot;d&quot; (src1), &quot;0&quot; (dest1));&t;&t;&t;&t;&bslash;&n;})
DECL|macro|fp_addx96
mdefine_line|#define fp_addx96(dest, src) ({&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* we assume here, gcc only insert move and a clr instr */&t;&bslash;&n;&t;asm volatile (&quot;add.l %1,%0&quot; : &quot;=d,=g&quot; (dest-&gt;m32[2])&t;&t;&bslash;&n;&t;&t;: &quot;g,d&quot; (temp.m32[1]), &quot;0,0&quot; (dest-&gt;m32[2]));&t;&t;&bslash;&n;&t;asm volatile (&quot;addx.l %1,%0&quot; : &quot;=d&quot; (dest-&gt;m32[1])&t;&t;&bslash;&n;&t;&t;: &quot;d&quot; (temp.m32[0]), &quot;0&quot; (dest-&gt;m32[1]));&t;&t;&bslash;&n;&t;asm volatile (&quot;addx.l %1,%0&quot; : &quot;=d&quot; (dest-&gt;m32[0])&t;&t;&bslash;&n;&t;&t;: &quot;d&quot; (0), &quot;0&quot; (dest-&gt;m32[0]));&t;&t;&t;&t;&bslash;&n;})
DECL|macro|fp_sub64
mdefine_line|#define fp_sub64(dest, src) ({&t;&t;&t;&t;&t;&t;&bslash;&n;&t;asm (&quot;sub.l %1,%0&quot; : &quot;=d,=dm&quot; (dest.m32[1])&t;&t;&t;&bslash;&n;&t;&t;: &quot;dm,d&quot; (src.m32[1]), &quot;0,0&quot; (dest.m32[1]));&t;&t;&bslash;&n;&t;asm (&quot;subx.l %1,%0&quot; : &quot;=d&quot; (dest.m32[0])&t;&t;&t;&bslash;&n;&t;&t;: &quot;d&quot; (src.m32[0]), &quot;0&quot; (dest.m32[0]));&t;&t;&t;&bslash;&n;})
DECL|macro|fp_sub96c
mdefine_line|#define fp_sub96c(dest, srch, srcm, srcl) ({&t;&t;&t;&t;&bslash;&n;&t;char carry;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;asm (&quot;sub.l %1,%0&quot; : &quot;=d,=dm&quot; (dest.m32[2])&t;&t;&t;&bslash;&n;&t;&t;: &quot;dm,d&quot; (srcl), &quot;0,0&quot; (dest.m32[2]));&t;&t;&t;&bslash;&n;&t;asm (&quot;subx.l %1,%0&quot; : &quot;=d&quot; (dest.m32[1])&t;&t;&t;&bslash;&n;&t;&t;: &quot;d&quot; (srcm), &quot;0&quot; (dest.m32[1]));&t;&t;&t;&bslash;&n;&t;asm (&quot;subx.l %2,%1; scs %0&quot; : &quot;=d&quot; (carry), &quot;=d&quot; (dest.m32[0])&t;&bslash;&n;&t;&t;: &quot;d&quot; (srch), &quot;1&quot; (dest.m32[0]));&t;&t;&t;&bslash;&n;&t;carry;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|function|fp_multiplymant
r_extern
r_inline
r_void
id|fp_multiplymant
c_func
(paren
r_union
id|fp_mant128
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src1
comma
r_struct
id|fp_ext
op_star
id|src2
)paren
(brace
r_union
id|fp_mant64
id|temp
suffix:semicolon
id|fp_mul64
c_func
(paren
id|dest-&gt;m32
(braket
l_int|0
)braket
comma
id|dest-&gt;m32
(braket
l_int|1
)braket
comma
id|src1-&gt;mant.m32
(braket
l_int|0
)braket
comma
id|src2-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|fp_mul64
c_func
(paren
id|dest-&gt;m32
(braket
l_int|2
)braket
comma
id|dest-&gt;m32
(braket
l_int|3
)braket
comma
id|src1-&gt;mant.m32
(braket
l_int|1
)braket
comma
id|src2-&gt;mant.m32
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|fp_mul64
c_func
(paren
id|temp.m32
(braket
l_int|0
)braket
comma
id|temp.m32
(braket
l_int|1
)braket
comma
id|src1-&gt;mant.m32
(braket
l_int|0
)braket
comma
id|src2-&gt;mant.m32
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|fp_addx96
c_func
(paren
id|dest
comma
id|temp
)paren
suffix:semicolon
id|fp_mul64
c_func
(paren
id|temp.m32
(braket
l_int|0
)braket
comma
id|temp.m32
(braket
l_int|1
)braket
comma
id|src1-&gt;mant.m32
(braket
l_int|1
)braket
comma
id|src2-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|fp_addx96
c_func
(paren
id|dest
comma
id|temp
)paren
suffix:semicolon
)brace
DECL|function|fp_dividemant
r_extern
r_inline
r_void
id|fp_dividemant
c_func
(paren
r_union
id|fp_mant128
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
comma
r_struct
id|fp_ext
op_star
id|div
)paren
(brace
r_union
id|fp_mant128
id|tmp
suffix:semicolon
r_union
id|fp_mant64
id|tmp64
suffix:semicolon
r_int
r_int
op_star
id|mantp
op_assign
id|dest-&gt;m32
suffix:semicolon
r_int
r_int
id|fix
comma
id|rem
comma
id|first
comma
id|dummy
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* the algorithm below requires dest to be smaller than div,&n;&t;   but both have the high bit set */
r_if
c_cond
(paren
id|src-&gt;mant.m64
op_ge
id|div-&gt;mant.m64
)paren
(brace
id|fp_sub64
c_func
(paren
id|src-&gt;mant
comma
id|div-&gt;mant
)paren
suffix:semicolon
op_star
id|mantp
op_assign
l_int|1
suffix:semicolon
)brace
r_else
op_star
id|mantp
op_assign
l_int|0
suffix:semicolon
id|mantp
op_increment
suffix:semicolon
multiline_comment|/* basic idea behind this algorithm: we can&squot;t divide two 64bit numbers&n;&t;   (AB/CD) directly, but we can calculate AB/C0, but this means this&n;&t;   quotient is off by C0/CD, so we have to multiply the first result&n;&t;   to fix the result, after that we have nearly the correct result&n;&t;   and only a few corrections are needed. */
multiline_comment|/* C0/CD can be precalculated, but it&squot;s an 64bit division again, but&n;&t;   we can make it a bit easier, by dividing first through C so we get&n;&t;   10/1D and now only a single shift and the value fits into 32bit. */
id|fix
op_assign
l_int|0x80000000
suffix:semicolon
id|dummy
op_assign
id|div-&gt;mant.m32
(braket
l_int|1
)braket
op_div
id|div-&gt;mant.m32
(braket
l_int|0
)braket
op_plus
l_int|1
suffix:semicolon
id|dummy
op_assign
(paren
id|dummy
op_rshift
l_int|1
)paren
op_or
id|fix
suffix:semicolon
id|fp_div64
c_func
(paren
id|fix
comma
id|dummy
comma
id|fix
comma
l_int|0
comma
id|dummy
)paren
suffix:semicolon
id|fix
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
comma
id|mantp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|src-&gt;mant.m32
(braket
l_int|0
)braket
op_eq
id|div-&gt;mant.m32
(braket
l_int|0
)braket
)paren
(brace
id|fp_div64
c_func
(paren
id|first
comma
id|rem
comma
l_int|0
comma
id|src-&gt;mant.m32
(braket
l_int|1
)braket
comma
id|div-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|fp_mul64
c_func
(paren
op_star
id|mantp
comma
id|dummy
comma
id|first
comma
id|fix
)paren
suffix:semicolon
op_star
id|mantp
op_add_assign
id|fix
suffix:semicolon
)brace
r_else
(brace
id|fp_div64
c_func
(paren
id|first
comma
id|rem
comma
id|src-&gt;mant.m32
(braket
l_int|0
)braket
comma
id|src-&gt;mant.m32
(braket
l_int|1
)braket
comma
id|div-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|fp_mul64
c_func
(paren
op_star
id|mantp
comma
id|dummy
comma
id|first
comma
id|fix
)paren
suffix:semicolon
)brace
id|fp_mul64
c_func
(paren
id|tmp.m32
(braket
l_int|0
)braket
comma
id|tmp.m32
(braket
l_int|1
)braket
comma
id|div-&gt;mant.m32
(braket
l_int|0
)braket
comma
id|first
op_minus
op_star
id|mantp
)paren
suffix:semicolon
id|fp_add64
c_func
(paren
id|tmp.m32
(braket
l_int|0
)braket
comma
id|tmp.m32
(braket
l_int|1
)braket
comma
l_int|0
comma
id|rem
)paren
suffix:semicolon
id|tmp.m32
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|fp_mul64
c_func
(paren
id|tmp64.m32
(braket
l_int|0
)braket
comma
id|tmp64.m32
(braket
l_int|1
)braket
comma
op_star
id|mantp
comma
id|div-&gt;mant.m32
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|fp_sub96c
c_func
(paren
id|tmp
comma
l_int|0
comma
id|tmp64.m32
(braket
l_int|0
)braket
comma
id|tmp64.m32
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|src-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
id|tmp.m32
(braket
l_int|1
)braket
suffix:semicolon
id|src-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
id|tmp.m32
(braket
l_int|2
)braket
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|fp_sub96c
c_func
(paren
id|tmp
comma
l_int|0
comma
id|div-&gt;mant.m32
(braket
l_int|0
)braket
comma
id|div-&gt;mant.m32
(braket
l_int|1
)braket
)paren
)paren
(brace
id|src-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
id|tmp.m32
(braket
l_int|1
)braket
suffix:semicolon
id|src-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
id|tmp.m32
(braket
l_int|2
)braket
suffix:semicolon
op_star
id|mantp
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
r_extern
r_inline
r_int
r_int
id|fp_fls128
c_func
(paren
r_union
id|fp_mant128
op_star
id|src
)paren
(brace
r_int
r_int
id|data
suffix:semicolon
r_int
r_int
id|res
comma
id|off
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_assign
id|src-&gt;m32
(braket
l_int|0
)braket
)paren
)paren
id|off
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|data
op_assign
id|src-&gt;m32
(braket
l_int|1
)braket
)paren
)paren
id|off
op_assign
l_int|32
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|data
op_assign
id|src-&gt;m32
(braket
l_int|2
)braket
)paren
)paren
id|off
op_assign
l_int|64
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|data
op_assign
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
)paren
id|off
op_assign
l_int|96
suffix:semicolon
r_else
r_return
l_int|128
suffix:semicolon
id|asm
(paren
l_string|&quot;bfffo %1{#0,#32},%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|res
)paren
suffix:colon
l_string|&quot;dm&quot;
(paren
id|data
)paren
)paren
suffix:semicolon
r_return
id|res
op_plus
id|off
suffix:semicolon
)brace
r_extern
r_inline
r_void
id|fp_shiftmant128
c_func
(paren
r_union
id|fp_mant128
op_star
id|src
comma
r_int
id|shift
)paren
(brace
r_int
r_int
id|sticky
suffix:semicolon
r_switch
c_cond
(paren
id|shift
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
r_case
l_int|1
suffix:colon
id|asm
r_volatile
(paren
l_string|&quot;lsl.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;roxl.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;roxl.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;roxl.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
dot
dot
dot
l_int|31
suffix:colon
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_lshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_lshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_lshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_lshift
id|shift
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|32
dot
dot
dot
l_int|63
suffix:colon
id|shift
op_sub_assign
l_int|32
suffix:semicolon
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_lshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_lshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_lshift
id|shift
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|64
dot
dot
dot
l_int|95
suffix:colon
id|shift
op_sub_assign
l_int|64
suffix:semicolon
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_lshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_lshift
id|shift
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|96
dot
dot
dot
l_int|127
suffix:colon
id|shift
op_sub_assign
l_int|96
suffix:semicolon
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_lshift
id|shift
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
l_int|31
dot
dot
dot
op_minus
l_int|1
suffix:colon
id|shift
op_assign
op_minus
id|shift
suffix:semicolon
id|sticky
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
id|sticky
op_assign
l_int|1
suffix:semicolon
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_rshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
op_or
id|sticky
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_rshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_rshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_rshift
id|shift
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
l_int|63
dot
dot
dot
op_minus
l_int|32
suffix:colon
id|shift
op_assign
op_minus
id|shift
op_minus
l_int|32
suffix:semicolon
id|sticky
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
op_logical_or
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
id|sticky
op_assign
l_int|1
suffix:semicolon
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_rshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
op_or
id|sticky
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_rshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_rshift
id|shift
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
l_int|95
dot
dot
dot
op_minus
l_int|64
suffix:colon
id|shift
op_assign
op_minus
id|shift
op_minus
l_int|64
suffix:semicolon
id|sticky
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
op_logical_or
id|src-&gt;m32
(braket
l_int|2
)braket
op_logical_or
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
id|sticky
op_assign
l_int|1
suffix:semicolon
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
op_rshift
id|shift
)paren
op_or
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
op_or
id|sticky
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_rshift
id|shift
)paren
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
r_case
op_minus
l_int|127
dot
dot
dot
op_minus
l_int|96
suffix:colon
id|shift
op_assign
op_minus
id|shift
op_minus
l_int|96
suffix:semicolon
id|sticky
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_lshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
op_logical_or
id|src-&gt;m32
(braket
l_int|1
)braket
op_logical_or
id|src-&gt;m32
(braket
l_int|2
)braket
op_logical_or
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
id|sticky
op_assign
l_int|1
suffix:semicolon
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_rshift
id|shift
)paren
op_or
id|sticky
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shift
OL
l_int|0
op_logical_and
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
op_logical_or
id|src-&gt;m32
(braket
l_int|1
)braket
op_logical_or
id|src-&gt;m32
(braket
l_int|2
)braket
op_logical_or
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
)paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
l_int|1
suffix:semicolon
r_else
id|src-&gt;m32
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|src-&gt;m32
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|src-&gt;m32
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|src-&gt;m32
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fp_putmant128
r_extern
r_inline
r_void
id|fp_putmant128
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_union
id|fp_mant128
op_star
id|src
comma
r_int
id|shift
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|shift
)paren
(brace
r_case
l_int|0
suffix:colon
id|dest-&gt;mant.m64
op_assign
id|src-&gt;m64
(braket
l_int|0
)braket
suffix:semicolon
id|dest-&gt;lowmant
op_assign
id|src-&gt;m32
(braket
l_int|2
)braket
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_logical_or
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
)paren
id|dest-&gt;lowmant
op_or_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|asm
r_volatile
(paren
l_string|&quot;lsl.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;roxl.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;roxl.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|dest-&gt;lowmant
op_assign
id|tmp
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_logical_or
(paren
id|tmp
op_lshift
l_int|8
)paren
)paren
id|dest-&gt;lowmant
op_or_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|31
suffix:colon
id|asm
r_volatile
(paren
l_string|&quot;lsr.l #1,%1; roxr.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|src-&gt;m32
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;roxr.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;roxr.l #1,%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|dest-&gt;lowmant
op_assign
id|tmp
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_lshift
l_int|7
)paren
id|dest-&gt;lowmant
op_or_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
id|src-&gt;m32
(braket
l_int|1
)braket
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
id|src-&gt;m32
(braket
l_int|2
)braket
suffix:semicolon
id|dest-&gt;lowmant
op_assign
id|src-&gt;m32
(braket
l_int|3
)braket
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;m32
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
id|dest-&gt;lowmant
op_or_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#if 0 /* old code... */
r_extern
r_inline
r_int
id|fls
c_func
(paren
r_int
r_int
id|a
)paren
(brace
r_int
id|r
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;bfffo %1{#0,#32},%0&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|r
)paren
suffix:colon
l_string|&quot;md&quot;
(paren
id|a
)paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* fls = &quot;find last set&quot; (cf. ffs(3)) */
r_extern
r_inline
r_int
id|fls128
c_func
(paren
r_const
id|int128
id|a
)paren
(brace
r_if
c_cond
(paren
id|a
(braket
id|MSW128
)braket
)paren
r_return
id|fls
c_func
(paren
id|a
(braket
id|MSW128
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
id|NMSW128
)braket
)paren
r_return
id|fls
c_func
(paren
id|a
(braket
id|NMSW128
)braket
)paren
op_plus
l_int|32
suffix:semicolon
multiline_comment|/* XXX: it probably never gets beyond this point in actual&n;&t;   use, but that&squot;s indicative of a more general problem in the&n;&t;   algorithm (i.e. as per the actual 68881 implementation, we&n;&t;   really only need at most 67 bits of precision [plus&n;&t;   overflow]) so I&squot;m not going to fix it. */
r_if
c_cond
(paren
id|a
(braket
id|NLSW128
)braket
)paren
r_return
id|fls
c_func
(paren
id|a
(braket
id|NLSW128
)braket
)paren
op_plus
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
id|LSW128
)braket
)paren
r_return
id|fls
c_func
(paren
id|a
(braket
id|LSW128
)braket
)paren
op_plus
l_int|96
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_extern
r_inline
r_int
id|zerop128
c_func
(paren
r_const
id|int128
id|a
)paren
(brace
r_return
op_logical_neg
(paren
id|a
(braket
id|LSW128
)braket
op_or
id|a
(braket
id|NLSW128
)braket
op_or
id|a
(braket
id|NMSW128
)braket
op_or
id|a
(braket
id|MSW128
)braket
)paren
suffix:semicolon
)brace
r_extern
r_inline
r_int
id|nonzerop128
c_func
(paren
r_const
id|int128
id|a
)paren
(brace
r_return
(paren
id|a
(braket
id|LSW128
)braket
op_or
id|a
(braket
id|NLSW128
)braket
op_or
id|a
(braket
id|NMSW128
)braket
op_or
id|a
(braket
id|MSW128
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Addition and subtraction */
multiline_comment|/* Do these in &quot;pure&quot; assembly, because &quot;extended&quot; asm is unmanageable&n;   here */
r_extern
r_inline
r_void
id|add128
c_func
(paren
r_const
id|int128
id|a
comma
id|int128
id|b
)paren
(brace
multiline_comment|/* rotating carry flags */
r_int
r_int
id|carry
(braket
l_int|2
)braket
suffix:semicolon
id|carry
(braket
l_int|0
)braket
op_assign
id|a
(braket
id|LSW128
)braket
OG
(paren
l_int|0xffffffff
op_minus
id|b
(braket
id|LSW128
)braket
)paren
suffix:semicolon
id|b
(braket
id|LSW128
)braket
op_add_assign
id|a
(braket
id|LSW128
)braket
suffix:semicolon
id|carry
(braket
l_int|1
)braket
op_assign
id|a
(braket
id|NLSW128
)braket
OG
(paren
l_int|0xffffffff
op_minus
id|b
(braket
id|NLSW128
)braket
op_minus
id|carry
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|b
(braket
id|NLSW128
)braket
op_assign
id|a
(braket
id|NLSW128
)braket
op_plus
id|b
(braket
id|NLSW128
)braket
op_plus
id|carry
(braket
l_int|0
)braket
suffix:semicolon
id|carry
(braket
l_int|0
)braket
op_assign
id|a
(braket
id|NMSW128
)braket
OG
(paren
l_int|0xffffffff
op_minus
id|b
(braket
id|NMSW128
)braket
op_minus
id|carry
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|b
(braket
id|NMSW128
)braket
op_assign
id|a
(braket
id|NMSW128
)braket
op_plus
id|b
(braket
id|NMSW128
)braket
op_plus
id|carry
(braket
l_int|1
)braket
suffix:semicolon
id|b
(braket
id|MSW128
)braket
op_assign
id|a
(braket
id|MSW128
)braket
op_plus
id|b
(braket
id|MSW128
)braket
op_plus
id|carry
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* Note: assembler semantics: &quot;b -= a&quot; */
r_extern
r_inline
r_void
id|sub128
c_func
(paren
r_const
id|int128
id|a
comma
id|int128
id|b
)paren
(brace
multiline_comment|/* rotating borrow flags */
r_int
r_int
id|borrow
(braket
l_int|2
)braket
suffix:semicolon
id|borrow
(braket
l_int|0
)braket
op_assign
id|b
(braket
id|LSW128
)braket
OL
id|a
(braket
id|LSW128
)braket
suffix:semicolon
id|b
(braket
id|LSW128
)braket
op_sub_assign
id|a
(braket
id|LSW128
)braket
suffix:semicolon
id|borrow
(braket
l_int|1
)braket
op_assign
id|b
(braket
id|NLSW128
)braket
OL
id|a
(braket
id|NLSW128
)braket
op_plus
id|borrow
(braket
l_int|0
)braket
suffix:semicolon
id|b
(braket
id|NLSW128
)braket
op_assign
id|b
(braket
id|NLSW128
)braket
op_minus
id|a
(braket
id|NLSW128
)braket
op_minus
id|borrow
(braket
l_int|0
)braket
suffix:semicolon
id|borrow
(braket
l_int|0
)braket
op_assign
id|b
(braket
id|NMSW128
)braket
OL
id|a
(braket
id|NMSW128
)braket
op_plus
id|borrow
(braket
l_int|1
)braket
suffix:semicolon
id|b
(braket
id|NMSW128
)braket
op_assign
id|b
(braket
id|NMSW128
)braket
op_minus
id|a
(braket
id|NMSW128
)braket
op_minus
id|borrow
(braket
l_int|1
)braket
suffix:semicolon
id|b
(braket
id|MSW128
)braket
op_assign
id|b
(braket
id|MSW128
)braket
op_minus
id|a
(braket
id|MSW128
)braket
op_minus
id|borrow
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* Poor man&squot;s 64-bit expanding multiply */
r_extern
r_inline
r_void
id|mul64
c_func
(paren
r_int
r_int
r_int
id|a
comma
r_int
r_int
r_int
id|b
comma
id|int128
id|c
)paren
(brace
r_int
r_int
r_int
id|acc
suffix:semicolon
id|int128
id|acc128
suffix:semicolon
id|zero128
c_func
(paren
id|acc128
)paren
suffix:semicolon
id|zero128
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* first the low words */
r_if
c_cond
(paren
id|LO_WORD
c_func
(paren
id|a
)paren
op_logical_and
id|LO_WORD
c_func
(paren
id|b
)paren
)paren
(brace
id|acc
op_assign
(paren
r_int
r_int
)paren
id|LO_WORD
c_func
(paren
id|a
)paren
op_star
id|LO_WORD
c_func
(paren
id|b
)paren
suffix:semicolon
id|c
(braket
id|NLSW128
)braket
op_assign
id|HI_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
id|c
(braket
id|LSW128
)braket
op_assign
id|LO_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
)brace
multiline_comment|/* Next the high words */
r_if
c_cond
(paren
id|HI_WORD
c_func
(paren
id|a
)paren
op_logical_and
id|HI_WORD
c_func
(paren
id|b
)paren
)paren
(brace
id|acc
op_assign
(paren
r_int
r_int
)paren
id|HI_WORD
c_func
(paren
id|a
)paren
op_star
id|HI_WORD
c_func
(paren
id|b
)paren
suffix:semicolon
id|c
(braket
id|MSW128
)braket
op_assign
id|HI_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
id|c
(braket
id|NMSW128
)braket
op_assign
id|LO_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
)brace
multiline_comment|/* The middle words */
r_if
c_cond
(paren
id|LO_WORD
c_func
(paren
id|a
)paren
op_logical_and
id|HI_WORD
c_func
(paren
id|b
)paren
)paren
(brace
id|acc
op_assign
(paren
r_int
r_int
)paren
id|LO_WORD
c_func
(paren
id|a
)paren
op_star
id|HI_WORD
c_func
(paren
id|b
)paren
suffix:semicolon
id|acc128
(braket
id|NMSW128
)braket
op_assign
id|HI_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
id|acc128
(braket
id|NLSW128
)braket
op_assign
id|LO_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
id|add128
c_func
(paren
id|acc128
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/* The first and last words */
r_if
c_cond
(paren
id|HI_WORD
c_func
(paren
id|a
)paren
op_logical_and
id|LO_WORD
c_func
(paren
id|b
)paren
)paren
(brace
id|acc
op_assign
(paren
r_int
r_int
)paren
id|HI_WORD
c_func
(paren
id|a
)paren
op_star
id|LO_WORD
c_func
(paren
id|b
)paren
suffix:semicolon
id|acc128
(braket
id|NMSW128
)braket
op_assign
id|HI_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
id|acc128
(braket
id|NLSW128
)braket
op_assign
id|LO_WORD
c_func
(paren
id|acc
)paren
suffix:semicolon
id|add128
c_func
(paren
id|acc128
comma
id|c
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Note: unsigned */
r_extern
r_inline
r_int
id|cmp128
c_func
(paren
id|int128
id|a
comma
id|int128
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
(braket
id|MSW128
)braket
OL
id|b
(braket
id|MSW128
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
id|MSW128
)braket
OG
id|b
(braket
id|MSW128
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
id|NMSW128
)braket
OL
id|b
(braket
id|NMSW128
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
id|NMSW128
)braket
OG
id|b
(braket
id|NMSW128
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
id|NLSW128
)braket
OL
id|b
(braket
id|NLSW128
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
id|NLSW128
)braket
OG
id|b
(braket
id|NLSW128
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_return
(paren
r_int
)paren
id|a
(braket
id|LSW128
)braket
op_minus
id|b
(braket
id|LSW128
)braket
suffix:semicolon
)brace
r_inline
r_void
id|div128
c_func
(paren
id|int128
id|a
comma
id|int128
id|b
comma
id|int128
id|c
)paren
(brace
id|int128
id|mask
suffix:semicolon
multiline_comment|/* Algorithm:&n;&n;&t;   Shift the divisor until it&squot;s at least as big as the&n;&t;   dividend, keeping track of the position to which we&squot;ve&n;&t;   shifted it, i.e. the power of 2 which we&squot;ve multiplied it&n;&t;   by.&n;&n;&t;   Then, for this power of 2 (the mask), and every one smaller&n;&t;   than it, subtract the mask from the dividend and add it to&n;&t;   the quotient until the dividend is smaller than the raised&n;&t;   divisor.  At this point, divide the dividend and the mask&n;&t;   by 2 (i.e. shift one place to the right).  Lather, rinse,&n;&t;   and repeat, until there are no more powers of 2 left. */
multiline_comment|/* FIXME: needless to say, there&squot;s room for improvement here too. */
multiline_comment|/* Shift up */
multiline_comment|/* XXX: since it just has to be &quot;at least as big&quot;, we can&n;&t;   probably eliminate this horribly wasteful loop.  I will&n;&t;   have to prove this first, though */
id|set128
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
id|mask
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cmp128
c_func
(paren
id|b
comma
id|a
)paren
OL
l_int|0
op_logical_and
op_logical_neg
id|btsthi128
c_func
(paren
id|b
)paren
)paren
(brace
id|lslone128
c_func
(paren
id|b
)paren
suffix:semicolon
id|lslone128
c_func
(paren
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/* Shift down */
id|zero128
c_func
(paren
id|c
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|cmp128
c_func
(paren
id|a
comma
id|b
)paren
op_ge
l_int|0
)paren
(brace
id|sub128
c_func
(paren
id|b
comma
id|a
)paren
suffix:semicolon
id|add128
c_func
(paren
id|mask
comma
id|c
)paren
suffix:semicolon
)brace
id|lsrone128
c_func
(paren
id|mask
)paren
suffix:semicolon
id|lsrone128
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nonzerop128
c_func
(paren
id|mask
)paren
)paren
suffix:semicolon
multiline_comment|/* The remainder is in a... */
)brace
macro_line|#endif
macro_line|#endif&t;/* MULTI_ARITH_H */
eof
