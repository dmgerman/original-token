multiline_comment|/*&n;&n;   fp_arith.c: floating-point math routines for the Linux-m68k&n;   floating point emulator.&n;&n;   Copyright (c) 1998-1999 David Huggins-Daines.&n;&n;   Somewhat based on the AlphaLinux floating point emulator, by David&n;   Mosberger-Tang.&n;&n;   You may copy, modify, and redistribute this file under the terms of&n;   the GNU General Public License, version 2, or any later version, at&n;   your convenience.&n; */
macro_line|#include &quot;fp_emu.h&quot;
macro_line|#include &quot;multi_arith.h&quot;
macro_line|#include &quot;fp_arith.h&quot;
DECL|variable|fp_QNaN
r_const
r_struct
id|fp_ext
id|fp_QNaN
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0x7fff
comma
(brace
op_complement
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|fp_Inf
r_const
r_struct
id|fp_ext
id|fp_Inf
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0x7fff
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* let&squot;s start with the easy ones */
r_struct
id|fp_ext
op_star
DECL|function|fp_fabs
id|fp_fabs
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fabs&bslash;n&quot;
)paren
suffix:semicolon
id|fp_monadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
l_int|0
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fneg
id|fp_fneg
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fneg&bslash;n&quot;
)paren
suffix:semicolon
id|fp_monadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
op_logical_neg
id|dest-&gt;sign
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* Now, the slightly harder ones */
multiline_comment|/* fp_fadd: Implements the kernel of the FADD, FSADD, FDADD, FSUB,&n;   FDSUB, and FCMP instructions. */
r_struct
id|fp_ext
op_star
DECL|function|fp_fadd
id|fp_fadd
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
r_int
id|diff
suffix:semicolon
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fadd&bslash;n&quot;
)paren
suffix:semicolon
id|fp_dyadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
)paren
(brace
multiline_comment|/* infinity - infinity == NaN */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
op_logical_and
(paren
id|src-&gt;sign
op_ne
id|dest-&gt;sign
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
(brace
id|fp_copy_ext
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
(brace
r_if
c_cond
(paren
id|src-&gt;sign
op_ne
id|dest-&gt;sign
)paren
(brace
r_if
c_cond
(paren
id|FPDATA-&gt;rnd
op_eq
id|FPCR_ROUND_RM
)paren
id|dest-&gt;sign
op_assign
l_int|1
suffix:semicolon
r_else
id|dest-&gt;sign
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|fp_copy_ext
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|dest-&gt;lowmant
op_assign
id|src-&gt;lowmant
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|diff
op_assign
id|dest-&gt;exp
op_minus
id|src-&gt;exp
)paren
OG
l_int|0
)paren
id|fp_denormalize
c_func
(paren
id|src
comma
id|diff
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|diff
op_assign
op_minus
id|diff
)paren
OG
l_int|0
)paren
id|fp_denormalize
c_func
(paren
id|dest
comma
id|diff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;sign
op_eq
id|src-&gt;sign
)paren
(brace
r_if
c_cond
(paren
id|fp_addmant
c_func
(paren
id|dest
comma
id|src
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|fp_addcarry
c_func
(paren
id|dest
)paren
)paren
r_return
id|dest
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dest-&gt;mant.m64
OL
id|src-&gt;mant.m64
)paren
(brace
id|fp_submant
c_func
(paren
id|dest
comma
id|src
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
op_logical_neg
id|dest-&gt;sign
suffix:semicolon
)brace
r_else
id|fp_submant
c_func
(paren
id|dest
comma
id|dest
comma
id|src
)paren
suffix:semicolon
)brace
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* fp_fsub: Implementes the kernel of the FSUB, FSSUB, and FDSUB&n;   instructions.&n;&n;   Remember that the arguments are in assembler-syntax order! */
r_struct
id|fp_ext
op_star
DECL|function|fp_fsub
id|fp_fsub
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fsub &quot;
)paren
suffix:semicolon
id|src-&gt;sign
op_assign
op_logical_neg
id|src-&gt;sign
suffix:semicolon
r_return
id|fp_fadd
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fcmp
id|fp_fcmp
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fcmp &quot;
)paren
suffix:semicolon
id|FPDATA-&gt;temp
(braket
l_int|1
)braket
op_assign
op_star
id|dest
suffix:semicolon
id|src-&gt;sign
op_assign
op_logical_neg
id|src-&gt;sign
suffix:semicolon
r_return
id|fp_fadd
c_func
(paren
op_amp
id|FPDATA-&gt;temp
(braket
l_int|1
)braket
comma
id|src
)paren
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_ftst
id|fp_ftst
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;ftst&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|dest
suffix:semicolon
r_return
id|src
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fmul
id|fp_fmul
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
r_union
id|fp_mant128
id|temp
suffix:semicolon
r_int
id|exp
suffix:semicolon
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fmul&bslash;n&quot;
)paren
suffix:semicolon
id|fp_dyadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* calculate the correct sign now, as it&squot;s necessary for infinities */
id|dest-&gt;sign
op_assign
id|src-&gt;sign
op_xor
id|dest-&gt;sign
suffix:semicolon
multiline_comment|/* Handle infinities */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
r_else
id|fp_copy_ext
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* Of course, as we all know, zero * anything = zero.  You may&n;&t;   not have known that it might be a positive or negative&n;&t;   zero... */
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
op_logical_or
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
(brace
id|dest-&gt;exp
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;lowmant
op_assign
l_int|0
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|exp
op_assign
id|dest-&gt;exp
op_plus
id|src-&gt;exp
op_minus
l_int|0x3ffe
suffix:semicolon
multiline_comment|/* shift up the mantissa for denormalized numbers,&n;&t;   so that the highest bit is set, this makes the&n;&t;   shift of the result below easier */
r_if
c_cond
(paren
(paren
r_int
)paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_ge
l_int|0
)paren
id|exp
op_sub_assign
id|fp_overnormalize
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|src-&gt;mant.m32
(braket
l_int|0
)braket
op_ge
l_int|0
)paren
id|exp
op_sub_assign
id|fp_overnormalize
c_func
(paren
id|src
)paren
suffix:semicolon
multiline_comment|/* now, do a 64-bit multiply with expansion */
id|fp_multiplymant
c_func
(paren
op_amp
id|temp
comma
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* normalize it back to 64 bits and stuff it back into the&n;&t;   destination struct */
r_if
c_cond
(paren
(paren
r_int
)paren
id|temp.m32
(braket
l_int|0
)braket
OG
l_int|0
)paren
(brace
id|exp
op_decrement
suffix:semicolon
id|fp_putmant128
c_func
(paren
id|dest
comma
op_amp
id|temp
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|fp_putmant128
c_func
(paren
id|dest
comma
op_amp
id|temp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
l_int|0x7fff
)paren
(brace
id|fp_set_ovrflw
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|dest-&gt;exp
op_assign
id|exp
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
(brace
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_UNFL
)paren
suffix:semicolon
id|fp_denormalize
c_func
(paren
id|dest
comma
op_minus
id|exp
)paren
suffix:semicolon
)brace
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* fp_fdiv: Implements the &quot;kernel&quot; of the FDIV, FSDIV, FDDIV and&n;   FSGLDIV instructions.&n;&n;   Note that the order of the operands is counter-intuitive: instead&n;   of src / dest, the result is actually dest / src. */
r_struct
id|fp_ext
op_star
DECL|function|fp_fdiv
id|fp_fdiv
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
r_union
id|fp_mant128
id|temp
suffix:semicolon
r_int
id|exp
suffix:semicolon
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fdiv&bslash;n&quot;
)paren
suffix:semicolon
id|fp_dyadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* calculate the correct sign now, as it&squot;s necessary for infinities */
id|dest-&gt;sign
op_assign
id|src-&gt;sign
op_xor
id|dest-&gt;sign
suffix:semicolon
multiline_comment|/* Handle infinities */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
)paren
(brace
multiline_comment|/* infinity / infinity = NaN (quiet, as always) */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
multiline_comment|/* infinity / anything else = infinity (with approprate sign) */
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
(brace
multiline_comment|/* anything / infinity = zero (with appropriate sign) */
id|dest-&gt;exp
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;lowmant
op_assign
l_int|0
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* zeroes */
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
)paren
(brace
multiline_comment|/* zero / zero = NaN */
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
multiline_comment|/* zero / anything else = zero */
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
(brace
multiline_comment|/* anything / zero = infinity (with appropriate sign) */
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_DZ
)paren
suffix:semicolon
id|dest-&gt;exp
op_assign
l_int|0x7fff
suffix:semicolon
id|dest-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|exp
op_assign
id|dest-&gt;exp
op_minus
id|src-&gt;exp
op_plus
l_int|0x3fff
suffix:semicolon
multiline_comment|/* shift up the mantissa for denormalized numbers,&n;&t;   so that the highest bit is set, this makes lots&n;&t;   of things below easier */
r_if
c_cond
(paren
(paren
r_int
)paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_ge
l_int|0
)paren
id|exp
op_sub_assign
id|fp_overnormalize
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|src-&gt;mant.m32
(braket
l_int|0
)braket
op_ge
l_int|0
)paren
id|exp
op_sub_assign
id|fp_overnormalize
c_func
(paren
id|src
)paren
suffix:semicolon
multiline_comment|/* now, do the 64-bit divide */
id|fp_dividemant
c_func
(paren
op_amp
id|temp
comma
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* normalize it back to 64 bits and stuff it back into the&n;&t;   destination struct */
r_if
c_cond
(paren
op_logical_neg
id|temp.m32
(braket
l_int|0
)braket
)paren
(brace
id|exp
op_decrement
suffix:semicolon
id|fp_putmant128
c_func
(paren
id|dest
comma
op_amp
id|temp
comma
l_int|32
)paren
suffix:semicolon
)brace
r_else
id|fp_putmant128
c_func
(paren
id|dest
comma
op_amp
id|temp
comma
l_int|31
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
l_int|0x7fff
)paren
(brace
id|fp_set_ovrflw
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|dest-&gt;exp
op_assign
id|exp
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
(brace
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_UNFL
)paren
suffix:semicolon
id|fp_denormalize
c_func
(paren
id|dest
comma
op_minus
id|exp
)paren
suffix:semicolon
)brace
r_return
id|dest
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fsglmul
id|fp_fsglmul
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
r_int
id|exp
suffix:semicolon
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fsglmul&bslash;n&quot;
)paren
suffix:semicolon
id|fp_dyadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* calculate the correct sign now, as it&squot;s necessary for infinities */
id|dest-&gt;sign
op_assign
id|src-&gt;sign
op_xor
id|dest-&gt;sign
suffix:semicolon
multiline_comment|/* Handle infinities */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
r_else
id|fp_copy_ext
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* Of course, as we all know, zero * anything = zero.  You may&n;&t;   not have known that it might be a positive or negative&n;&t;   zero... */
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
op_logical_or
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
(brace
id|dest-&gt;exp
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;lowmant
op_assign
l_int|0
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|exp
op_assign
id|dest-&gt;exp
op_plus
id|src-&gt;exp
op_minus
l_int|0x3ffe
suffix:semicolon
multiline_comment|/* do a 32-bit multiply */
id|fp_mul64
c_func
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
comma
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
comma
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_amp
l_int|0xffffff00
comma
id|src-&gt;mant.m32
(braket
l_int|0
)braket
op_amp
l_int|0xffffff00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
l_int|0x7fff
)paren
(brace
id|fp_set_ovrflw
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|dest-&gt;exp
op_assign
id|exp
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
(brace
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_UNFL
)paren
suffix:semicolon
id|fp_denormalize
c_func
(paren
id|dest
comma
op_minus
id|exp
)paren
suffix:semicolon
)brace
r_return
id|dest
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fsgldiv
id|fp_fsgldiv
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
r_int
id|exp
suffix:semicolon
r_int
r_int
id|quot
comma
id|rem
suffix:semicolon
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fsgldiv&bslash;n&quot;
)paren
suffix:semicolon
id|fp_dyadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* calculate the correct sign now, as it&squot;s necessary for infinities */
id|dest-&gt;sign
op_assign
id|src-&gt;sign
op_xor
id|dest-&gt;sign
suffix:semicolon
multiline_comment|/* Handle infinities */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
)paren
(brace
multiline_comment|/* infinity / infinity = NaN (quiet, as always) */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
multiline_comment|/* infinity / anything else = infinity (with approprate sign) */
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
(brace
multiline_comment|/* anything / infinity = zero (with appropriate sign) */
id|dest-&gt;exp
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;lowmant
op_assign
l_int|0
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* zeroes */
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
)paren
(brace
multiline_comment|/* zero / zero = NaN */
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
multiline_comment|/* zero / anything else = zero */
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
(brace
multiline_comment|/* anything / zero = infinity (with appropriate sign) */
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_DZ
)paren
suffix:semicolon
id|dest-&gt;exp
op_assign
l_int|0x7fff
suffix:semicolon
id|dest-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|exp
op_assign
id|dest-&gt;exp
op_minus
id|src-&gt;exp
op_plus
l_int|0x3fff
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_and_assign
l_int|0xffffff00
suffix:semicolon
id|src-&gt;mant.m32
(braket
l_int|0
)braket
op_and_assign
l_int|0xffffff00
suffix:semicolon
multiline_comment|/* do the 32-bit divide */
r_if
c_cond
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_ge
id|src-&gt;mant.m32
(braket
l_int|0
)braket
)paren
(brace
id|fp_sub64
c_func
(paren
id|dest-&gt;mant
comma
id|src-&gt;mant
)paren
suffix:semicolon
id|fp_div64
c_func
(paren
id|quot
comma
id|rem
comma
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
comma
l_int|0
comma
id|src-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
l_int|0x80000000
op_or
(paren
id|quot
op_rshift
l_int|1
)paren
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
(paren
id|quot
op_amp
l_int|1
)paren
op_or
id|rem
suffix:semicolon
multiline_comment|/* only for rounding */
)brace
r_else
(brace
id|fp_div64
c_func
(paren
id|quot
comma
id|rem
comma
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
comma
l_int|0
comma
id|src-&gt;mant.m32
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
id|quot
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
id|rem
suffix:semicolon
multiline_comment|/* only for rounding */
id|exp
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exp
op_ge
l_int|0x7fff
)paren
(brace
id|fp_set_ovrflw
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|dest-&gt;exp
op_assign
id|exp
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
(brace
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_UNFL
)paren
suffix:semicolon
id|fp_denormalize
c_func
(paren
id|dest
comma
op_minus
id|exp
)paren
suffix:semicolon
)brace
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* fp_roundint: Internal rounding function for use by several of these&n;   emulated instructions.&n;&n;   This one rounds off the fractional part using the rounding mode&n;   specified. */
DECL|function|fp_roundint
r_static
r_void
id|fp_roundint
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_int
id|mode
)paren
(brace
r_union
id|fp_mant64
id|oldmant
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp_normalize_ext
c_func
(paren
id|dest
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* infinities and zeroes */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
op_logical_or
id|IS_ZERO
c_func
(paren
id|dest
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* first truncate the lower bits */
id|oldmant
op_assign
id|dest-&gt;mant
suffix:semicolon
r_switch
c_cond
(paren
id|dest-&gt;exp
)paren
(brace
r_case
l_int|0
dot
dot
dot
l_int|0x3ffe
suffix:colon
id|dest-&gt;mant.m64
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3fff
dot
dot
dot
l_int|0x401e
suffix:colon
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_and_assign
l_int|0xffffffffU
op_lshift
(paren
l_int|0x401e
op_minus
id|dest-&gt;exp
)paren
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|oldmant.m64
op_eq
id|dest-&gt;mant.m64
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x401f
dot
dot
dot
l_int|0x403e
suffix:colon
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
op_and_assign
l_int|0xffffffffU
op_lshift
(paren
l_int|0x403e
op_minus
id|dest-&gt;exp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldmant.m32
(braket
l_int|1
)braket
op_eq
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_INEX2
)paren
suffix:semicolon
multiline_comment|/* We might want to normalize upwards here... however, since&n;&t;   we know that this is only called on the output of fp_fdiv,&n;&t;   or with the input to fp_fint or fp_fintrz, and the inputs&n;&t;   to all these functions are either normal or denormalized&n;&t;   (no subnormals allowed!), there&squot;s really no need.&n;&n;&t;   In the case of fp_fdiv, observe that 0x80000000 / 0xffff =&n;&t;   0xffff8000, and the same holds for 128-bit / 64-bit. (i.e. the&n;&t;   smallest possible normal dividend and the largest possible normal&n;&t;   divisor will still produce a normal quotient, therefore, (normal&n;&t;   &lt;&lt; 64) / normal is normal in all cases) */
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|FPCR_ROUND_RN
suffix:colon
r_switch
c_cond
(paren
id|dest-&gt;exp
)paren
(brace
r_case
l_int|0
dot
dot
dot
l_int|0x3ffd
suffix:colon
r_return
suffix:semicolon
r_case
l_int|0x3ffe
suffix:colon
multiline_comment|/* As noted above, the input is always normal, so the&n;&t;&t;&t;   guard bit (bit 63) is always set.  therefore, the&n;&t;&t;&t;   only case in which we will NOT round to 1.0 is when&n;&t;&t;&t;   the input is exactly 0.5. */
r_if
c_cond
(paren
id|oldmant.m64
op_eq
(paren
l_int|1ULL
op_lshift
l_int|63
)paren
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3fff
dot
dot
dot
l_int|0x401d
suffix:colon
id|mask
op_assign
l_int|1
op_lshift
(paren
l_int|0x401d
op_minus
id|dest-&gt;exp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|oldmant.m32
(braket
l_int|0
)braket
op_amp
id|mask
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|oldmant.m32
(braket
l_int|0
)braket
op_amp
(paren
id|mask
op_lshift
l_int|1
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|oldmant.m32
(braket
l_int|0
)braket
op_lshift
(paren
id|dest-&gt;exp
op_minus
l_int|0x3ffd
)paren
)paren
op_logical_and
op_logical_neg
id|oldmant.m32
(braket
l_int|1
)braket
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x401e
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|oldmant.m32
(braket
l_int|1
)braket
op_ge
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|oldmant.m32
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|oldmant.m32
(braket
l_int|1
)braket
op_lshift
l_int|1
)paren
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x401f
dot
dot
dot
l_int|0x403d
suffix:colon
id|mask
op_assign
l_int|1
op_lshift
(paren
l_int|0x403d
op_minus
id|dest-&gt;exp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|oldmant.m32
(braket
l_int|1
)braket
op_amp
id|mask
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|oldmant.m32
(braket
l_int|1
)braket
op_amp
(paren
id|mask
op_lshift
l_int|1
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|oldmant.m32
(braket
l_int|1
)braket
op_lshift
(paren
id|dest-&gt;exp
op_minus
l_int|0x401d
)paren
)paren
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|FPCR_ROUND_RZ
suffix:colon
r_return
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|dest-&gt;sign
op_xor
(paren
id|mode
op_minus
id|FPCR_ROUND_RM
)paren
)paren
r_break
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dest-&gt;exp
)paren
(brace
r_case
l_int|0
dot
dot
dot
l_int|0x3ffe
suffix:colon
id|dest-&gt;exp
op_assign
l_int|0x3fff
suffix:semicolon
id|dest-&gt;mant.m64
op_assign
l_int|1ULL
op_lshift
l_int|63
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3fff
dot
dot
dot
l_int|0x401e
suffix:colon
id|mask
op_assign
l_int|1
op_lshift
(paren
l_int|0x401e
op_minus
id|dest-&gt;exp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_add_assign
id|mask
)paren
r_break
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
l_int|0x80000000
suffix:semicolon
id|dest-&gt;exp
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x401f
dot
dot
dot
l_int|0x403e
suffix:colon
id|mask
op_assign
l_int|1
op_lshift
(paren
l_int|0x403e
op_minus
id|dest-&gt;exp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;mant.m32
(braket
l_int|1
)braket
op_add_assign
id|mask
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_add_assign
l_int|1
)paren
r_break
suffix:semicolon
id|dest-&gt;mant.m32
(braket
l_int|0
)braket
op_assign
l_int|0x80000000
suffix:semicolon
id|dest-&gt;exp
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* modrem_kernel: Implementation of the FREM and FMOD instructions&n;   (which are exactly the same, except for the rounding used on the&n;   intermediate value) */
r_static
r_struct
id|fp_ext
op_star
DECL|function|modrem_kernel
id|modrem_kernel
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
comma
r_int
id|mode
)paren
(brace
r_struct
id|fp_ext
id|tmp
suffix:semicolon
id|fp_dyadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* Infinities and zeros */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
op_logical_or
id|IS_ZERO
c_func
(paren
id|src
)paren
)paren
(brace
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|dest
)paren
op_logical_or
id|IS_INF
c_func
(paren
id|src
)paren
)paren
r_return
id|dest
suffix:semicolon
multiline_comment|/* FIXME: there is almost certainly a smarter way to do this */
id|fp_copy_ext
c_func
(paren
op_amp
id|tmp
comma
id|dest
)paren
suffix:semicolon
id|fp_fdiv
c_func
(paren
op_amp
id|tmp
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* NOTE: src might be modified */
id|fp_roundint
c_func
(paren
op_amp
id|tmp
comma
id|mode
)paren
suffix:semicolon
id|fp_fmul
c_func
(paren
op_amp
id|tmp
comma
id|src
)paren
suffix:semicolon
id|fp_fsub
c_func
(paren
id|dest
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* set the quotient byte */
id|fp_set_quotient
c_func
(paren
(paren
id|dest-&gt;mant.m64
op_amp
l_int|0x7f
)paren
op_or
(paren
id|dest-&gt;sign
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* fp_fmod: Implements the kernel of the FMOD instruction.&n;&n;   Again, the argument order is backwards.  The result, as defined in&n;   the Motorola manuals, is:&n;&n;   fmod(src,dest) = (dest - (src * floor(dest / src))) */
r_struct
id|fp_ext
op_star
DECL|function|fp_fmod
id|fp_fmod
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fmod&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|modrem_kernel
c_func
(paren
id|dest
comma
id|src
comma
id|FPCR_ROUND_RZ
)paren
suffix:semicolon
)brace
multiline_comment|/* fp_frem: Implements the kernel of the FREM instruction.&n;&n;   frem(src,dest) = (dest - (src * round(dest / src)))&n; */
r_struct
id|fp_ext
op_star
DECL|function|fp_frem
id|fp_frem
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;frem&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|modrem_kernel
c_func
(paren
id|dest
comma
id|src
comma
id|FPCR_ROUND_RN
)paren
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fint
id|fp_fint
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fint&bslash;n&quot;
)paren
suffix:semicolon
id|fp_copy_ext
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
id|fp_roundint
c_func
(paren
id|dest
comma
id|FPDATA-&gt;rnd
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fintrz
id|fp_fintrz
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fintrz&bslash;n&quot;
)paren
suffix:semicolon
id|fp_copy_ext
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
id|fp_roundint
c_func
(paren
id|dest
comma
id|FPCR_ROUND_RZ
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_struct
id|fp_ext
op_star
DECL|function|fp_fscale
id|fp_fscale
c_func
(paren
r_struct
id|fp_ext
op_star
id|dest
comma
r_struct
id|fp_ext
op_star
id|src
)paren
(brace
r_int
id|scale
comma
id|oldround
suffix:semicolon
id|dprint
c_func
(paren
id|PINSTR
comma
l_string|&quot;fscale&bslash;n&quot;
)paren
suffix:semicolon
id|fp_dyadic_check
c_func
(paren
id|dest
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* Infinities */
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|src
)paren
)paren
(brace
id|fp_set_nan
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_INF
c_func
(paren
id|dest
)paren
)paren
r_return
id|dest
suffix:semicolon
multiline_comment|/* zeroes */
r_if
c_cond
(paren
id|IS_ZERO
c_func
(paren
id|src
)paren
op_logical_or
id|IS_ZERO
c_func
(paren
id|dest
)paren
)paren
r_return
id|dest
suffix:semicolon
multiline_comment|/* Source exponent out of range */
r_if
c_cond
(paren
id|src-&gt;exp
op_ge
l_int|0x400c
)paren
(brace
id|fp_set_ovrflw
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* src must be rounded with round to zero. */
id|oldround
op_assign
id|FPDATA-&gt;rnd
suffix:semicolon
id|FPDATA-&gt;rnd
op_assign
id|FPCR_ROUND_RZ
suffix:semicolon
id|scale
op_assign
id|fp_conv_ext2long
c_func
(paren
id|src
)paren
suffix:semicolon
id|FPDATA-&gt;rnd
op_assign
id|oldround
suffix:semicolon
multiline_comment|/* new exponent */
id|scale
op_add_assign
id|dest-&gt;exp
suffix:semicolon
r_if
c_cond
(paren
id|scale
op_ge
l_int|0x7fff
)paren
(brace
id|fp_set_ovrflw
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scale
op_le
l_int|0
)paren
(brace
id|fp_set_sr
c_func
(paren
id|FPSR_EXC_UNFL
)paren
suffix:semicolon
id|fp_denormalize
c_func
(paren
id|dest
comma
op_minus
id|scale
)paren
suffix:semicolon
)brace
r_else
id|dest-&gt;exp
op_assign
id|scale
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
eof
