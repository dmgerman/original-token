multiline_comment|/*&n; *&t;MACII&t;ADB keyboard handler.&n; *&t;&t;Copyright (c) 1997 Alan Cox&n; *&n; *&t;Derived from code &n; *&t;&t;Copyright (C) 1996 Paul Mackerras.&n; *&n; *&t;MSch (9/97) Partial rewrite of interrupt handler to MacII style&n; *&t;&t;ADB handshake, based on:&n; *&t;&t;&t;- Guide to Mac Hardware&n; *&t;&t;&t;- Guido Koerber&squot;s session with a logic analyzer&n; *&n; *&t;MSch (1/98) Integrated start of IIsi driver by Robert Thompson&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &quot;via6522.h&quot;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/adb.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;asm/macints.h&gt;
DECL|macro|MACII
mdefine_line|#define MACII&t;&t;/* For now - will be a switch */
multiline_comment|/* Bits in B data register: all active low */
DECL|macro|TREQ
mdefine_line|#define TREQ&t;&t;0x08&t;&t;/* Transfer request (input) */
DECL|macro|TACK
mdefine_line|#define TACK&t;&t;0x10&t;&t;/* Transfer acknowledge (output) */
DECL|macro|TIP
mdefine_line|#define TIP&t;&t;0x20&t;&t;/* Transfer in progress (output) */
multiline_comment|/* Bits in B data register: ADB transaction states MacII */
DECL|macro|ST_MASK
mdefine_line|#define ST_MASK&t;&t;0x30&t;&t;/* mask for selecting ADB state bits */
multiline_comment|/* ADB transaction states according to GMHW */
DECL|macro|ST_CMD
mdefine_line|#define ST_CMD&t;&t;0x00&t;&t;/* ADB state: command byte */
DECL|macro|ST_EVEN
mdefine_line|#define ST_EVEN&t;&t;0x10&t;&t;/* ADB state: even data byte */
DECL|macro|ST_ODD
mdefine_line|#define ST_ODD&t;&t;0x20&t;&t;/* ADB state: odd data byte */
DECL|macro|ST_IDLE
mdefine_line|#define ST_IDLE&t;&t;0x30&t;&t;/* ADB state: idle, nothing to send */
multiline_comment|/* Bits in ACR */
DECL|macro|SR_CTRL
mdefine_line|#define SR_CTRL&t;&t;0x1c&t;&t;/* Shift register control bits */
macro_line|#ifdef USE_ORIG
DECL|macro|SR_EXT
mdefine_line|#define SR_EXT&t;&t;0x1c&t;&t;/* Shift on external clock */
macro_line|#else
DECL|macro|SR_EXT
mdefine_line|#define SR_EXT&t;&t;0x0c&t;&t;/* Shift on external clock */
macro_line|#endif
DECL|macro|SR_OUT
mdefine_line|#define SR_OUT&t;&t;0x10&t;&t;/* Shift out if 1 */
multiline_comment|/* Bits in IFR and IER */
DECL|macro|IER_SET
mdefine_line|#define IER_SET&t;&t;0x80&t;&t;/* set bits in IER */
DECL|macro|IER_CLR
mdefine_line|#define IER_CLR&t;&t;0&t;&t;/* clear bits in IER */
DECL|macro|SR_INT
mdefine_line|#define SR_INT&t;&t;0x04&t;&t;/* Shift register full/empty */
DECL|macro|SR_DATA
mdefine_line|#define SR_DATA&t;&t;0x08&t;&t;/* Shift register data */
DECL|macro|SR_CLOCK
mdefine_line|#define SR_CLOCK&t;0x10&t;&t;/* Shift register clock */
multiline_comment|/* JRT */
DECL|macro|ADB_DELAY
mdefine_line|#define ADB_DELAY 150
DECL|struct|adb_handler
r_static
r_struct
id|adb_handler
(brace
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
r_char
op_star
comma
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|variable|adb_handler
)brace
id|adb_handler
(braket
l_int|16
)braket
suffix:semicolon
DECL|enum|adb_state
r_static
r_enum
id|adb_state
(brace
DECL|enumerator|idle
id|idle
comma
DECL|enumerator|sent_first_byte
id|sent_first_byte
comma
DECL|enumerator|sending
id|sending
comma
DECL|enumerator|reading
id|reading
comma
DECL|enumerator|read_done
id|read_done
comma
DECL|enumerator|awaiting_reply
id|awaiting_reply
DECL|variable|adb_state
)brace
id|adb_state
suffix:semicolon
DECL|variable|current_req
r_static
r_struct
id|adb_request
op_star
id|current_req
suffix:semicolon
DECL|variable|last_req
r_static
r_struct
id|adb_request
op_star
id|last_req
suffix:semicolon
DECL|variable|cuda_rbuf
r_static
r_int
r_char
id|cuda_rbuf
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|reply_ptr
r_static
r_int
r_char
op_star
id|reply_ptr
suffix:semicolon
DECL|variable|reply_len
r_static
r_int
id|reply_len
suffix:semicolon
DECL|variable|reading_reply
r_static
r_int
id|reading_reply
suffix:semicolon
DECL|variable|data_index
r_static
r_int
id|data_index
suffix:semicolon
DECL|variable|first_byte
r_static
r_int
id|first_byte
suffix:semicolon
DECL|variable|prefix_len
r_static
r_int
id|prefix_len
suffix:semicolon
DECL|variable|status
r_static
r_int
id|status
op_assign
id|ST_IDLE
op_or
id|TREQ
suffix:semicolon
DECL|variable|last_status
r_static
r_int
id|last_status
suffix:semicolon
DECL|variable|driver_running
r_static
r_int
id|driver_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*static int adb_delay;*/
DECL|variable|in_keybinit
r_int
id|in_keybinit
op_assign
l_int|1
suffix:semicolon
r_static
r_void
id|adb_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|adb_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_extern
r_void
id|adb_cuda_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_extern
r_void
id|adb_clock_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_extern
r_void
id|adb_data_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|adb_input
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|nb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|adb_hw_setup_IIsi
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|adb_hw_setup_cuda
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * debug level 10 required for ADB logging (should be &amp;&amp; debug_adb, ideally)&n; */
r_extern
r_int
id|console_loglevel
suffix:semicolon
multiline_comment|/*&n; * Misc. defines for testing - should go to header :-(&n; */
DECL|macro|ADBDEBUG_STATUS
mdefine_line|#define ADBDEBUG_STATUS&t;&t;(1)
DECL|macro|ADBDEBUG_STATE
mdefine_line|#define ADBDEBUG_STATE&t;&t;(2)
DECL|macro|ADBDEBUG_READ
mdefine_line|#define ADBDEBUG_READ&t;&t;(4)
DECL|macro|ADBDEBUG_WRITE
mdefine_line|#define ADBDEBUG_WRITE&t;&t;(8)
DECL|macro|ADBDEBUG_START
mdefine_line|#define ADBDEBUG_START&t;&t;(16)
DECL|macro|ADBDEBUG_RETRY
mdefine_line|#define ADBDEBUG_RETRY&t;&t;(32)
DECL|macro|ADBDEBUG_POLL
mdefine_line|#define ADBDEBUG_POLL&t;&t;(64)
DECL|macro|ADBDEBUG_INT
mdefine_line|#define ADBDEBUG_INT&t;&t;(128)
DECL|macro|ADBDEBUG_PROT
mdefine_line|#define ADBDEBUG_PROT&t;&t;(256)
DECL|macro|ADBDEBUG_SRQ
mdefine_line|#define ADBDEBUG_SRQ&t;&t;(512)
DECL|macro|ADBDEBUG_REQUEST
mdefine_line|#define ADBDEBUG_REQUEST&t;(1024)
DECL|macro|ADBDEBUG_INPUT
mdefine_line|#define ADBDEBUG_INPUT&t;&t;(2048)
DECL|macro|ADBDEBUG_DEVICE
mdefine_line|#define ADBDEBUG_DEVICE&t;&t;(4096)
DECL|macro|ADBDEBUG_IISI
mdefine_line|#define ADBDEBUG_IISI&t;&t;(8192)
multiline_comment|/*#define DEBUG_ADB*/
macro_line|#ifdef DEBUG_ADB
DECL|macro|ADBDEBUG
mdefine_line|#define ADBDEBUG&t;(ADBDEBUG_INPUT | ADBDEBUG_READ | ADBDEBUG_START | ADBDEBUG_WRITE | ADBDEBUG_SRQ | ADBDEBUG_REQUEST)
macro_line|#else
DECL|macro|ADBDEBUG
mdefine_line|#define ADBDEBUG&t;(0)
macro_line|#endif
DECL|macro|TRY_CUDA
mdefine_line|#define TRY_CUDA
DECL|function|adb_bus_init
r_void
id|adb_bus_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|c
comma
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Setup ADB&n;&t; */
r_switch
c_cond
(paren
id|macintosh_config-&gt;adb_type
)paren
(brace
r_case
id|MAC_ADB_II
suffix:colon
id|printk
c_func
(paren
l_string|&quot;adb: MacII style keyboard/mouse driver.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the lines up. We want TREQ as input TACK|TIP as output */
id|via_write
c_func
(paren
id|via1
comma
id|vDirB
comma
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vDirB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
op_amp
op_complement
id|TREQ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Docs suggest TREQ should be output - that seems nuts&n;&t;&t;&t; * BSD agrees here :-)&n;&t;&t;&t; * Setup vPCR ??&n;&t;&t;&t; */
macro_line|#ifdef USE_ORIG
multiline_comment|/* Lower the bus signals (MacII is active low it seems ???) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Corresponding state: idle (clear state bits) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
)paren
suffix:semicolon
id|last_status
op_assign
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Shift register on input */
id|c
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
suffix:semicolon
id|c
op_and_assign
op_complement
id|SR_CTRL
suffix:semicolon
multiline_comment|/* Clear shift register bits */
id|c
op_or_assign
id|SR_EXT
suffix:semicolon
multiline_comment|/* Shift on external clock; out or in? */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Wipe any pending data and int */
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* This is interrupts on enable SR for keyboard */
id|via_write
c_func
(paren
id|via1
comma
id|vIER
comma
id|IER_SET
op_or
id|SR_INT
)paren
suffix:semicolon
multiline_comment|/* This clears the interrupt bit */
id|via_write
c_func
(paren
id|via1
comma
id|vIFR
comma
id|SR_INT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; *&t;Ok we probably ;) have a ready to use adb bus. Its also&n;&t;&t; &t; *&t;hopefully idle (Im assuming the mac didnt leave a half&n;&t;&t; &t; *&t;complete transaction on booting us).&n; &t;&t;&t; */
id|request_irq
c_func
(paren
id|IRQ_MAC_ADB
comma
id|adb_interrupt
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;adb interrupt&quot;
comma
id|adb_interrupt
)paren
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Unsupported; but later code doesn&squot;t notice !!&n;&t;&t;&t; */
r_case
id|MAC_ADB_CUDA
suffix:colon
id|printk
c_func
(paren
l_string|&quot;adb: CUDA interface.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* don&squot;t know what to set up here ... */
id|adb_state
op_assign
id|idle
suffix:semicolon
multiline_comment|/* Set the lines up. We want TREQ as input TACK|TIP as output */
id|via_write
c_func
(paren
id|via1
comma
id|vDirB
comma
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vDirB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
op_amp
op_complement
id|TREQ
)paren
)paren
suffix:semicolon
macro_line|#endif
id|adb_hw_setup_cuda
c_func
(paren
)paren
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
id|request_irq
c_func
(paren
id|IRQ_MAC_ADB
comma
id|adb_cuda_interrupt
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;adb CUDA interrupt&quot;
comma
id|adb_cuda_interrupt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC_ADB_IISI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;adb: Using IIsi hardware.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tDEBUG_JRT&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the lines up. We want TREQ as input TACK|TIP as output */
id|via_write
c_func
(paren
id|via1
comma
id|vDirB
comma
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vDirB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
op_amp
op_complement
id|TREQ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * MSch: I&squot;m pretty sure the setup is mildly wrong&n;&t;&t;&t; * for the IIsi. &n;&t;&t;&t; */
multiline_comment|/* Initial state: idle (clear state bits) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TIP
op_or
id|TACK
)paren
)paren
)paren
suffix:semicolon
id|last_status
op_assign
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
suffix:semicolon
multiline_comment|/* Shift register on input */
id|c
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
suffix:semicolon
id|c
op_and_assign
op_complement
id|SR_CTRL
suffix:semicolon
multiline_comment|/* Clear shift register bits */
id|c
op_or_assign
id|SR_EXT
suffix:semicolon
multiline_comment|/* Shift on external clock; out or in? */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Wipe any pending data and int */
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* This is interrupts on enable SR for keyboard */
id|via_write
c_func
(paren
id|via1
comma
id|vIER
comma
id|IER_SET
op_or
id|SR_INT
)paren
suffix:semicolon
multiline_comment|/* This clears the interrupt bit */
id|via_write
c_func
(paren
id|via1
comma
id|vIFR
comma
id|SR_INT
)paren
suffix:semicolon
multiline_comment|/* get those pesky clock ticks we missed while booting */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|60
suffix:semicolon
id|i
op_increment
)paren
(brace
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
id|adb_hw_setup_IIsi
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|60
)paren
id|printk
c_func
(paren
l_string|&quot;adb_IIsi: maybe bus jammed ??&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; &t; *&t;Ok we probably ;) have a ready to use adb bus. Its also&n; &t;&t;&t; */
id|request_irq
c_func
(paren
id|IRQ_MAC_ADB
comma
id|adb_cuda_interrupt
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;adb interrupt&quot;
comma
id|adb_cuda_interrupt
)paren
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;adb: Unknown hardware interface.&bslash;n&quot;
)paren
suffix:semicolon
id|nosupp
suffix:colon
id|printk
c_func
(paren
l_string|&quot;adb: Interface unsupported.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX: interrupt only registered if supported HW !!&n;&t; * -&gt; unsupported HW will just time out on keyb_init!&n;&t; */
macro_line|#if 0
id|request_irq
c_func
(paren
id|IRQ_MAC_ADB
comma
id|adb_interrupt
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;adb interrupt&quot;
comma
id|adb_interrupt
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_ADB_INTS
id|request_irq
c_func
(paren
id|IRQ_MAC_ADB_CL
comma
id|adb_clock_interrupt
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;adb clock interrupt&quot;
comma
id|adb_clock_interrupt
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|IRQ_MAC_ADB_SD
comma
id|adb_data_interrupt
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;adb data interrupt&quot;
comma
id|adb_data_interrupt
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;adb: init done.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|adb_hw_setup_cuda
r_void
id|adb_hw_setup_cuda
c_func
(paren
r_void
)paren
(brace
r_int
id|x
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CUDA: HW Setup:&quot;
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;  1,&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the direction of the cuda signals, TIP+TACK are output TREQ is an input */
id|via_write
c_func
(paren
id|via1
comma
id|vDirB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vDirB
)paren
op_or
id|TIP
op_or
id|TACK
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vDirB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vDirB
)paren
op_amp
op_complement
id|TREQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;2,&quot;
)paren
suffix:semicolon
multiline_comment|/* Set the clock control. Set to shift data in by external clock CB1 */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_EXT
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;3,&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear any possible Cuda interrupt */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;4,&quot;
)paren
suffix:semicolon
multiline_comment|/* Terminate transaction and set idle state */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
op_or
id|TACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;5,&quot;
)paren
suffix:semicolon
multiline_comment|/* Delay 4 mS for ADB reset to complete */
id|udelay
c_func
(paren
l_int|4000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;6,&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear pending interrupts... */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;7,&quot;
)paren
suffix:semicolon
multiline_comment|/* Issue a sync transaction, TACK asserted while TIP negated */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;8,&quot;
)paren
suffix:semicolon
multiline_comment|/* Wait for the sync acknowledgement, Cuda to assert TREQ */
r_while
c_loop
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
op_ne
l_int|0
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;9,&quot;
)paren
suffix:semicolon
multiline_comment|/* Wait for the sync acknowledment interrupt */
r_while
c_loop
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vIFR
)paren
op_amp
id|SR_INT
)paren
op_eq
l_int|0
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;10,&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear pending interrupts... */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;11,&quot;
)paren
suffix:semicolon
multiline_comment|/* Terminate the sync cycle by negating TACK */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;12,&quot;
)paren
suffix:semicolon
multiline_comment|/* Wait for the sync termination acknowledgement, Cuda to negate TREQ */
r_while
c_loop
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
op_eq
l_int|0
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;13,&quot;
)paren
suffix:semicolon
multiline_comment|/* Wait for the sync termination acknowledment interrupt */
r_while
c_loop
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vIFR
)paren
op_amp
id|SR_INT
)paren
op_eq
l_int|0
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;14,&quot;
)paren
suffix:semicolon
multiline_comment|/* Terminate transaction and set idle state, TIP+TACK negate */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;15 !&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear pending interrupts... */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCUDA: HW Setup done!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|adb_hw_setup_IIsi
r_void
id|adb_hw_setup_IIsi
c_func
(paren
r_void
)paren
(brace
r_int
id|dummy
suffix:semicolon
r_int
id|poll_timeout
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;adb_IIsi: cleanup!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* disable SR int. */
id|via_write
c_func
(paren
id|via1
comma
id|vIER
comma
id|IER_CLR
op_or
id|SR_INT
)paren
suffix:semicolon
multiline_comment|/* set SR to shift in */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* this is required, especially on faster machines */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
)paren
(brace
multiline_comment|/* IRQ on */
multiline_comment|/* start frame */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* poll for ADB interrupt and watch for timeout */
multiline_comment|/* if time out, keep going in hopes of not hanging the&n;&t;&t;&t; * ADB chip - I think */
id|poll_timeout
op_assign
id|ADB_DELAY
op_star
l_int|5
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vIFR
)paren
op_amp
id|SR_INT
)paren
op_logical_and
(paren
id|poll_timeout
op_decrement
OG
l_int|0
)paren
)paren
id|dummy
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
suffix:semicolon
id|dummy
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* reset interrupt flag */
multiline_comment|/* perhaps put in a check here that ignores all data&n;&t;&t;&t; * after the first ADB_MAX_MSG_LENGTH bytes ??? */
multiline_comment|/* end of frame reached ?? */
r_if
c_cond
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
r_break
suffix:semicolon
multiline_comment|/* set ACK */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
multiline_comment|/* delay */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* clear ACK */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
)brace
multiline_comment|/* end frame */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TIP
)paren
suffix:semicolon
multiline_comment|/* probably don&squot;t need to delay this long */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
)brace
multiline_comment|/* re-enable SR int. */
id|via_write
c_func
(paren
id|via1
comma
id|vIER
comma
id|IER_SET
op_or
id|SR_INT
)paren
suffix:semicolon
)brace
DECL|macro|WAIT_FOR
mdefine_line|#define WAIT_FOR(cond, what)&t;&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;for (x = 1000; !(cond); --x) {&t;&t;&t;&bslash;&n;&t;    if (x == 0) {&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;Timeout waiting for &quot; what);&t;&bslash;&n;&t;&t;return 0;&t;&t;&t;&t;&bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    __delay(100*160);&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;    } while (0)
multiline_comment|/* &n; *&t;Construct and send an adb request &n; *&t;This function is the main entry point into the ADB driver from &n; *&t;kernel code; it takes the request data supplied and populates the&n; *&t;adb_request structure.&n; *&t;In order to keep this interface independent from any assumption about&n; *&t;the underlying ADB hardware, we take requests in CUDA format here, &n; *&t;the ADB packet &squot;prefixed&squot; with a packet type code.&n; *&t;Non-CUDA hardware is confused by this, so we strip the packet type&n; *&t;here depending on hardware type ...&n; */
DECL|function|adb_request
r_int
id|adb_request
c_func
(paren
r_struct
id|adb_request
op_star
id|req
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|adb_request
op_star
)paren
comma
r_int
id|nbytes
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_int
id|i
comma
id|start
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|nbytes
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * skip first byte if not CUDA &n;&t; */
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
id|start
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_int
)paren
suffix:semicolon
id|nbytes
op_decrement
suffix:semicolon
)brace
id|req-&gt;nbytes
op_assign
id|nbytes
suffix:semicolon
id|req-&gt;done
op_assign
id|done
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_REQUEST)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_request, data bytes: &quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbytes
suffix:semicolon
op_increment
id|i
)paren
(brace
id|req-&gt;data
(braket
id|i
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_int
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_REQUEST)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
id|req-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_REQUEST)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; !&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * XXX: This might be fatal if no reply is generated (i.e. Listen) ! &n;&t; * Currently, the interrupt handler &squot;fakes&squot; a reply on non-TALK &n;&t; * commands for this reason.&n;&t; * Also, we need a CUDA_AUTOPOLL emulation here for non-CUDA &n;&t; * Macs, and some mechanism to remember the last issued TALK&n;&t; * request for resending it repeatedly on timeout!&n;&t; */
id|req-&gt;reply_expected
op_assign
l_int|1
suffix:semicolon
r_return
id|adb_send_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Construct an adb request for later sending&n; *&t;This function only populates the adb_request structure, without &n; *&t;actually queueing it.&n; *&t;Reason: Poll requests and Talk requests need to be handled in a way&n; *&t;different from &squot;user&squot; requests; no reply_expected is set and &n; *&t;Poll requests need to be placed at the head of the request queue.&n; *&t;Using adb_request results in implicit queueing at the tail of the &n; *&t;request queue (duplicating the Poll) with reply_expected set.&n; *&t;No adjustment of packet data is necessary, as this mechanisnm is not&n; *&t;used by CUDA hardware (Autopoll used instead).&n; */
DECL|function|adb_build_request
r_int
id|adb_build_request
c_func
(paren
r_struct
id|adb_request
op_star
id|req
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|adb_request
op_star
)paren
comma
r_int
id|nbytes
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_int
id|i
suffix:semicolon
id|req-&gt;nbytes
op_assign
id|nbytes
suffix:semicolon
id|req-&gt;done
op_assign
id|done
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|nbytes
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_REQUEST)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb__build_request, data bytes: &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * skip first byte if not CUDA ?&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbytes
suffix:semicolon
op_increment
id|i
)paren
(brace
id|req-&gt;data
(braket
id|i
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_int
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_REQUEST)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
id|req-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_REQUEST)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; !&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
id|req-&gt;reply_expected
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ADB poll (Talk, tagged on the front of the request queue)&n; */
DECL|function|adb_queue_poll
r_void
id|adb_queue_poll
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|pod
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|in_poll
op_assign
l_int|0
suffix:semicolon
r_static
r_struct
id|adb_request
id|r
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|in_poll
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Double poll!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|in_poll
op_increment
suffix:semicolon
id|pod
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pod
OG
l_int|7
)paren
(brace
multiline_comment|/* 15 */
id|pod
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_POLL)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb: Polling %d&bslash;n&quot;
comma
id|pod
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
multiline_comment|/* XXX: that&squot;s a TALK, register 0, MacII version */
id|adb_build_request
c_func
(paren
op_amp
id|r
comma
l_int|NULL
comma
l_int|1
comma
(paren
id|pod
op_lshift
l_int|4
op_or
l_int|0xC
)paren
)paren
suffix:semicolon
r_else
multiline_comment|/* CUDA etc. version */
id|adb_build_request
c_func
(paren
op_amp
id|r
comma
l_int|NULL
comma
l_int|2
comma
l_int|0
comma
(paren
id|pod
op_lshift
l_int|4
op_or
l_int|0xC
)paren
)paren
suffix:semicolon
id|r.reply_expected
op_assign
l_int|0
suffix:semicolon
id|r.done
op_assign
l_int|NULL
suffix:semicolon
id|r.sent
op_assign
l_int|0
suffix:semicolon
id|r.got_reply
op_assign
l_int|0
suffix:semicolon
id|r.reply_len
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Poll inserted at head of queue ... */
id|r.next
op_assign
id|current_req
suffix:semicolon
id|current_req
op_assign
op_amp
id|r
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|adb_start
c_func
(paren
)paren
suffix:semicolon
id|in_poll
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an ADB retransmit (Talk, appended to the request queue)&n; */
DECL|function|adb_retransmit
r_void
id|adb_retransmit
c_func
(paren
r_int
id|device
)paren
(brace
r_static
r_int
id|in_retransmit
op_assign
l_int|0
suffix:semicolon
r_static
r_struct
id|adb_request
id|rt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|in_retransmit
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Double retransmit!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|in_retransmit
op_increment
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_POLL)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb: Sending retransmit: %d&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* MacII version */
id|adb_build_request
c_func
(paren
op_amp
id|rt
comma
l_int|NULL
comma
l_int|1
comma
(paren
id|device
op_lshift
l_int|4
op_or
l_int|0xC
)paren
)paren
suffix:semicolon
id|rt.reply_expected
op_assign
l_int|0
suffix:semicolon
id|rt.done
op_assign
l_int|NULL
suffix:semicolon
id|rt.sent
op_assign
l_int|0
suffix:semicolon
id|rt.got_reply
op_assign
l_int|0
suffix:semicolon
id|rt.reply_len
op_assign
l_int|0
suffix:semicolon
id|rt.next
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Retransmit inserted at tail of queue ... */
r_if
c_cond
(paren
id|current_req
op_ne
l_int|NULL
)paren
(brace
id|last_req-&gt;next
op_assign
op_amp
id|rt
suffix:semicolon
id|last_req
op_assign
op_amp
id|rt
suffix:semicolon
)brace
r_else
(brace
id|current_req
op_assign
op_amp
id|rt
suffix:semicolon
id|last_req
op_assign
op_amp
id|rt
suffix:semicolon
)brace
multiline_comment|/* always restart driver (send_retransmit used in place of adb_start!)*/
r_if
c_cond
(paren
id|adb_state
op_eq
id|idle
)paren
id|adb_start
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|in_retransmit
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue an ADB request; start ADB transfer if necessary&n; */
DECL|function|adb_send_request
r_int
id|adb_send_request
c_func
(paren
r_struct
id|adb_request
op_star
id|req
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|req-&gt;next
op_assign
l_int|0
suffix:semicolon
id|req-&gt;sent
op_assign
l_int|0
suffix:semicolon
id|req-&gt;got_reply
op_assign
l_int|0
suffix:semicolon
id|req-&gt;reply_len
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_req
op_ne
l_int|NULL
)paren
(brace
id|last_req-&gt;next
op_assign
id|req
suffix:semicolon
id|last_req
op_assign
id|req
suffix:semicolon
)brace
r_else
(brace
id|current_req
op_assign
id|req
suffix:semicolon
id|last_req
op_assign
id|req
suffix:semicolon
r_if
c_cond
(paren
id|adb_state
op_eq
id|idle
)paren
id|adb_start
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nclock
DECL|variable|ndata
r_static
r_int
id|nclock
comma
id|ndata
suffix:semicolon
DECL|variable|need_poll
r_static
r_int
id|need_poll
op_assign
l_int|0
suffix:semicolon
DECL|variable|command_byte
r_static
r_int
id|command_byte
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_reply
r_static
r_int
id|last_reply
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_active
r_static
r_int
id|last_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|retry_req
r_static
r_struct
id|adb_request
op_star
id|retry_req
suffix:semicolon
multiline_comment|/*&n; * Start sending ADB packet &n; */
DECL|function|adb_start
r_static
r_void
id|adb_start
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|adb_request
op_star
id|req
suffix:semicolon
multiline_comment|/*&n;&t; * We get here on three &squot;sane&squot; conditions:&n;&t; * 1) called from send_adb_request, if adb_state == idle&n;&t; * 2) called from within adb_interrupt, if adb_state == idle &n;&t; *    (after receiving, or after sending a LISTEN) &n;&t; * 3) called from within adb_interrupt, if adb_state == sending &n;&t; *    and no reply is expected (immediate next command).&n;&t; * Maybe we get here on SRQ as well ??&n;&t; */
multiline_comment|/* get the packet to send */
id|req
op_assign
id|current_req
suffix:semicolon
multiline_comment|/* assert adb_state == idle */
r_if
c_cond
(paren
id|adb_state
op_ne
id|idle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ADB: adb_start called while driver busy (%p %x %x)!&bslash;n&quot;
comma
id|req
comma
id|adb_state
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_START)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_start: request %p &quot;
comma
id|req
)paren
suffix:semicolon
macro_line|#endif
id|nclock
op_assign
l_int|0
suffix:semicolon
id|ndata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * IRQ signaled ?? (means ADB controller wants to send, or might &n;&t; * be end of packet if we were reading)&n;&t; */
r_if
c_cond
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|macintosh_config-&gt;adb_type
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;FIXME - we need to restart this on a timer&n;&t;&t;&t; *&t;or a collision at boot hangs us.&n;&t;&t;&t; *&t;Never set adb_state to idle here, or adb_start &n;&t;&t;&t; *&t;won&squot;t be called again from send_request!&n;&t;&t;&t; *&t;(need to re-check other cases ...)&n;&t;&t;&t; */
r_case
id|MAC_ADB_CUDA
suffix:colon
multiline_comment|/* printk(&quot;device busy - fail&bslash;n&quot;); */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* a byte is coming in from the CUDA */
r_return
suffix:semicolon
r_case
id|MAC_ADB_IISI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;adb_start: device busy - fail&bslash;n&quot;
)paren
suffix:semicolon
id|retry_req
op_assign
id|req
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|MAC_ADB_II
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * if the interrupt handler set the need_poll&n;&t;&t;&t;&t; * flag, it&squot;s hopefully a SRQ poll or re-Talk&n;&t;&t;&t;&t; * so we try to send here anyway&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|need_poll
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;device busy - retry %p state %d status %x!&bslash;n&quot;
comma
id|req
comma
id|adb_state
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
suffix:semicolon
id|retry_req
op_assign
id|req
suffix:semicolon
multiline_comment|/* set ADB status here ? */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_START)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;device busy - polling; state %d status %x!&bslash;n&quot;
comma
id|adb_state
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
suffix:semicolon
macro_line|#endif
id|need_poll
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * Bus idle ?? Not sure about this one; SRQ might need ST_CMD here!&n;&t; * OTOH: setting ST_CMD in the interrupt routine would make the &n;&t; * ADB contoller shift in before this routine starts shifting out ...&n;&t; */
r_if
c_cond
(paren
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|ST_MASK
)paren
op_ne
id|ST_IDLE
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB bus not idle (%x), retry later!&bslash;n&quot;
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
suffix:semicolon
macro_line|#endif
id|retry_req
op_assign
id|req
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Another retry pending? (sanity check)&n;&t; */
r_if
c_cond
(paren
id|retry_req
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_RETRY)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
r_if
c_cond
(paren
id|retry_req
op_eq
id|req
)paren
multiline_comment|/* new requests are appended at tail of request queue */
id|printk
c_func
(paren
l_string|&quot;adb_start: retry %p pending ! &bslash;n&quot;
comma
id|req
)paren
suffix:semicolon
r_else
multiline_comment|/* poll requests are added to the head of queue */
id|printk
c_func
(paren
l_string|&quot;adb_start: retry %p pending, req %p (poll?) current! &bslash;n&quot;
comma
id|retry_req
comma
id|req
)paren
suffix:semicolon
macro_line|#endif
id|retry_req
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Seems OK, go for it!&n;&t; */
r_switch
c_cond
(paren
id|macintosh_config-&gt;adb_type
)paren
(brace
r_case
id|MAC_ADB_CUDA
suffix:colon
multiline_comment|/* store command byte (first byte is &squot;type&squot; byte) */
id|command_byte
op_assign
id|req-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* set the shift register to shift out and send a byte */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TIP
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC_ADB_IISI
suffix:colon
multiline_comment|/* store command byte (first byte is &squot;type&squot; byte) */
id|command_byte
op_assign
id|req-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* set ADB state to &squot;active&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
multiline_comment|/* switch ACK off (in case it was left on) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
multiline_comment|/* set the shift register to shift out and send a byte */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* signal &squot;byte ready&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC_ADB_II
suffix:colon
multiline_comment|/* store command byte */
id|command_byte
op_assign
id|req-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Output mode */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* Load data */
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef USE_ORIG
multiline_comment|/* Turn off TIP/TACK - this should tell the external logic to&n;&t;&t;&t;   start the external shift clock */
multiline_comment|/*&t;&t;&t;via_write(via1, vBufB, via_read(via1, vBufB)&amp;~(TIP|TACK));*/
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
(paren
id|TIP
op_or
id|TACK
)paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* set ADB state to &squot;command&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_CMD
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|adb_state
op_assign
id|sent_first_byte
suffix:semicolon
id|data_index
op_assign
l_int|1
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_START)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;sent first byte of %d: %x, (%x %x) ... &quot;
comma
id|req-&gt;nbytes
comma
id|req-&gt;data
(braket
l_int|0
)braket
comma
id|adb_state
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Poll the ADB state (maybe obsolete now that interrupt-driven ADB runs)&n; */
DECL|function|adb_poll
r_void
id|adb_poll
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vIFR
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_POLL)
macro_line|#ifdef DEBUG_ADB_INTS
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;adb_poll: IFR %x state %x cl %d dat %d &quot;
comma
id|c
comma
id|adb_state
comma
id|nclock
comma
id|ndata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
(paren
id|SR_CLOCK
op_or
id|SR_DATA
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_amp
id|SR_CLOCK
)paren
id|printk
c_func
(paren
l_string|&quot;adb clock event &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|SR_DATA
)paren
id|printk
c_func
(paren
l_string|&quot;adb data event &quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_poll: IFR %x state %x &quot;
comma
id|c
comma
id|adb_state
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;r&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|c
op_amp
id|SR_INT
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_POLL)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_poll: adb interrupt event&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|adb_interrupt
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Debugging gimmicks&n; */
DECL|function|adb_clock_interrupt
r_void
id|adb_clock_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|nclock
op_increment
suffix:semicolon
)brace
DECL|function|adb_data_interrupt
r_void
id|adb_data_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ndata
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * The notorious ADB interrupt handler - does all of the protocol handling, &n; * except for starting new send operations. Relies heavily on the ADB &n; * controller sending and receiving data, thereby generating SR interrupts&n; * for us. This means there has to be always activity on the ADB bus, otherwise&n; * the whole process dies and has to be re-kicked by sending TALK requests ...&n; * CUDA-based Macs seem to solve this with the autopoll option, for MacII-type&n; * ADB the problem isn&squot;t solved yet (retransmit of the latest active TALK seems&n; * a good choice; either on timeout or on a timer interrupt).&n; *&n; * The basic ADB state machine was left unchanged from the original MacII code&n; * by Alan Cox, which was based on the CUDA driver for PowerMac. &n; * The syntax of the ADB status lines seems to be totally different on MacII, &n; * though. MacII uses the states Command -&gt; Even -&gt; Odd -&gt; Even -&gt;...-&gt; Idle for&n; * sending, and Idle -&gt; Even -&gt; Odd -&gt; Even -&gt;...-&gt; Idle for receiving. Start &n; * and end of a receive packet are signaled by asserting /IRQ on the interrupt&n; * line. Timeouts are signaled by a sequence of 4 0xFF, with /IRQ asserted on &n; * every other byte. SRQ is probably signaled by 3 or more 0xFF tacked on the &n; * end of a packet. (Thanks to Guido Koerber for eavesdropping on the ADB &n; * protocol with a logic analyzer!!)&n; * CUDA seems to use /TIP -&gt; /TIP | TACK -&gt; /TIP -&gt; /TIP | TACK ... -&gt; TIP|TACK&n; * for sending, and /TIP -&gt; /TIP | TACK -&gt; /TIP -&gt; /TIP | TACK ... -&gt; TIP for&n; * receiving. No clue how timeouts are handled; SRQ seems to be sent as a &n; * separate packet. Quite a few changes have been made outside the handshake &n; * code, so I don&squot;t know if the CUDA code still behaves as before. &n; *&n; * Note: As of 21/10/97, the MacII ADB part works including timeout detection&n; * and retransmit (Talk to the last active device). Cleanup of code and &n; * testing of the CUDA functionality is required, though. &n; * Note2: As of 13/12/97, CUDA support is definitely broken ...&n; * Note3: As of 21/12/97, CUDA works on a P475. What was broken? The assumption&n; * that Q700 and Q800 use CUDA :-(&n; *&n; * 27/01/98: IIsi driver implemented (thanks to Robert Thompson for the &n; * initial bits). See adb_cuda_interrupts ...&n; *&n; * Next TODO: implementation of IIsi ADB protocol (maybe the USE_ORIG &n; * conditionals can be a start?)&n; */
DECL|function|adb_interrupt
r_void
id|adb_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|x
comma
id|adbdir
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|adb_request
op_star
id|req
suffix:semicolon
id|last_status
op_assign
id|status
suffix:semicolon
multiline_comment|/* prevent races due to SCSI enabling ints */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_running
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|driver_running
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef USE_ORIG
id|status
op_assign
(paren
op_complement
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|TIP
op_or
id|TREQ
)paren
)paren
op_or
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
id|SR_OUT
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
id|status
op_assign
(paren
op_complement
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|TIP
op_or
id|TREQ
)paren
)paren
op_or
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
id|SR_OUT
)paren
suffix:semicolon
r_else
multiline_comment|/* status bits (0x8-&gt;0x20) and direction (0x10 ??) CLASH !! */
id|status
op_assign
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|ST_MASK
op_or
id|TREQ
)paren
)paren
suffix:semicolon
macro_line|#endif
id|adbdir
op_assign
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
id|SR_OUT
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_INT)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_interrupt: state=%d status=%x last=%x direction=%x&bslash;n&quot;
comma
id|adb_state
comma
id|status
comma
id|last_status
comma
id|adbdir
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|adb_state
)paren
(brace
r_case
id|idle
suffix:colon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
multiline_comment|/* CUDA has sent us the first byte of data - unsolicited */
r_if
c_cond
(paren
id|status
op_ne
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;cuda: state=idle, status=%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TIP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
multiline_comment|/* set SR to IN (??? no byte received else) */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* signal start of frame */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
multiline_comment|/* read first byte */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_macIIsi : receiving unsol. packet: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ACK adb chip */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
r_if
c_cond
(paren
id|status
op_eq
id|TREQ
op_logical_and
op_logical_neg
id|adbdir
)paren
multiline_comment|/* that&squot;s: not IRQ, idle, input -&gt; weird */
id|printk
c_func
(paren
l_string|&quot;adb_macII: idle, status=%x dir=%x&bslash;n&quot;
comma
id|status
comma
id|adbdir
)paren
suffix:semicolon
macro_line|#endif
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_macII: receiving unsol. packet: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set ADB state = even for first data byte */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
)paren
suffix:semicolon
)brace
id|adb_state
op_assign
id|reading
suffix:semicolon
id|reply_ptr
op_assign
id|cuda_rbuf
suffix:semicolon
id|reply_len
op_assign
l_int|0
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
id|prefix_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
op_star
id|reply_ptr
op_increment
op_assign
id|ADB_PACKET
suffix:semicolon
op_star
id|reply_ptr
op_increment
op_assign
id|first_byte
suffix:semicolon
op_star
id|reply_ptr
op_increment
op_assign
id|command_byte
suffix:semicolon
multiline_comment|/*first_byte;*/
id|reply_len
op_assign
l_int|3
suffix:semicolon
id|prefix_len
op_assign
l_int|3
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|awaiting_reply
suffix:colon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
multiline_comment|/* CUDA has sent us the first byte of data of a reply */
r_if
c_cond
(paren
id|status
op_ne
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;cuda: state=awaiting_reply, status=%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TIP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* set SR to IN */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* signal start of frame */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
multiline_comment|/* read first byte */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_macIIsi: reading reply: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
(brace
id|ending
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|ending
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* ACK adb chip */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
multiline_comment|/* handshake etc. for II ?? */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_macII: reading reply: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set ADB state = even for first data byte */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
)paren
suffix:semicolon
)brace
id|adb_state
op_assign
id|reading
suffix:semicolon
id|reply_ptr
op_assign
id|current_req-&gt;reply
suffix:semicolon
id|reading_reply
op_assign
l_int|1
suffix:semicolon
id|reply_len
op_assign
l_int|0
suffix:semicolon
id|prefix_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
op_star
id|reply_ptr
op_increment
op_assign
id|ADB_PACKET
suffix:semicolon
op_star
id|reply_ptr
op_increment
op_assign
id|first_byte
suffix:semicolon
op_star
id|reply_ptr
op_increment
op_assign
id|first_byte
suffix:semicolon
multiline_comment|/* should be command  byte */
id|reply_len
op_assign
l_int|3
suffix:semicolon
id|prefix_len
op_assign
l_int|3
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|sent_first_byte
suffix:colon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; sending: %x (%x %x) &quot;
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|TREQ
op_plus
id|TIP
op_plus
id|SR_OUT
)paren
(brace
multiline_comment|/* collision */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
op_or
id|TACK
)paren
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assert status == TIP + SR_OUT */
r_if
c_cond
(paren
id|status
op_ne
id|TIP
op_plus
id|SR_OUT
)paren
id|printk
c_func
(paren
l_string|&quot;cuda: state=sent_first_byte status=%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
id|data_index
op_assign
l_int|2
suffix:semicolon
id|adb_state
op_assign
id|sending
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* switch ACK off */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
)paren
(brace
multiline_comment|/* collision */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_macIIsi: send collison, aborting!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set shift in */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* clear SR int. */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* set ADB state to &squot;idle&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TIP
op_or
id|TACK
)paren
)paren
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* delay */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* set the shift register to shift out and send a byte */
macro_line|#if 0
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* signal &squot;byte ready&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|data_index
op_assign
l_int|2
suffix:semicolon
id|adb_state
op_assign
id|sending
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
multiline_comment|/* how to detect a collision here ?? */
multiline_comment|/* maybe we&squot;re already done (Talk, or Poll)? */
r_if
c_cond
(paren
id|data_index
op_ge
id|current_req-&gt;nbytes
)paren
(brace
multiline_comment|/* assert it&squot;s a Talk ?? */
r_if
c_cond
(paren
(paren
id|command_byte
op_amp
l_int|0xc
)paren
op_ne
l_int|0xc
op_logical_and
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: single byte command, no Talk: %x!&bslash;n&quot;
comma
id|command_byte
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; -&gt; end (%d of %d) (%x %x)!&bslash;n&quot;
comma
id|data_index
comma
id|current_req-&gt;nbytes
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
id|current_req-&gt;sent
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|current_req-&gt;reply_expected
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: reply expected on poll!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|adb_state
op_assign
id|awaiting_reply
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: no reply for poll, not calling done()!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|req
op_assign
id|current_req
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
macro_line|#if 0&t;/* XXX Not sure about that one ... probably better enabled */
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
macro_line|#endif
id|adb_state
op_assign
id|idle
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set to shift in */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* set ADB state idle - might get SRQ */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_eq
(paren
id|ST_CMD
op_or
id|TREQ
)paren
op_logical_and
id|adbdir
op_eq
id|SR_OUT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;adb_macII: sent_first_byte, weird status=%x dir=%x&bslash;n&quot;
comma
id|status
comma
id|adbdir
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* SR already set to shift out; send byte */
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* set state to ST_EVEN (first byte was: ST_CMD) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
)paren
suffix:semicolon
id|data_index
op_assign
l_int|2
suffix:semicolon
id|adb_state
op_assign
id|sending
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|sending
suffix:colon
id|req
op_assign
id|current_req
suffix:semicolon
r_if
c_cond
(paren
id|data_index
op_ge
id|req-&gt;nbytes
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; -&gt; end (%d of %d) (%x %x)!&bslash;n&quot;
comma
id|data_index
op_minus
l_int|1
comma
id|req-&gt;nbytes
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* end of packet */
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* XXX maybe clear ACK here ??? */
multiline_comment|/* switch ACK off */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
multiline_comment|/* delay */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* set the shift register to shift in */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* clear SR int. */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* set ADB state &squot;idle&squot; (end of frame) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TACK
op_or
id|TIP
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * XXX Not sure: maybe only switch to &n;&t;&t;&t;&t;&t; * input mode on Talk ??&n;&t;&t;&t;&t;&t; */
multiline_comment|/* set to shift in */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* set ADB state idle - might get SRQ */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
)paren
suffix:semicolon
)brace
id|req-&gt;sent
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;reply_expected
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * maybe fake a reply here on Listen ?? &n;&t;&t;&t;&t;&t; * Otherwise, a Listen hangs on success&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
op_logical_and
(paren
(paren
id|req-&gt;data
(braket
l_int|0
)braket
op_amp
l_int|0xc
)paren
op_eq
l_int|0xc
)paren
)paren
id|adb_state
op_assign
id|awaiting_reply
suffix:semicolon
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_ne
id|MAC_ADB_II
op_logical_and
(paren
id|req-&gt;data
(braket
l_int|0
)braket
op_eq
l_int|0x0
)paren
op_logical_and
(paren
(paren
id|req-&gt;data
(braket
l_int|1
)braket
op_amp
l_int|0xc
)paren
op_eq
l_int|0xc
)paren
)paren
id|adb_state
op_assign
id|awaiting_reply
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Reply expected, but none&n;&t;&t;&t;&t;&t;&t; * possible -&gt; fake reply.&n;&t;&t;&t;&t;&t;&t; * Problem: sending next command&n;&t;&t;&t;&t;&t;&t; * should probably be done &n;&t;&t;&t;&t;&t;&t; * without setting bus to &squot;idle&squot;!&n;&t;&t;&t;&t;&t;&t; * (except if no more commands)&n;&t;&t;&t;&t;&t;&t; */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_PROT)
id|printk
c_func
(paren
l_string|&quot;ADB: reply expected on Listen, faking reply&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* make it look weird */
multiline_comment|/* XXX: return reply_len -1? */
multiline_comment|/* XXX: fake ADB header? */
id|req-&gt;reply
(braket
l_int|0
)braket
op_assign
id|req-&gt;reply
(braket
l_int|1
)braket
op_assign
id|req-&gt;reply
(braket
l_int|2
)braket
op_assign
l_int|0xFF
suffix:semicolon
id|req-&gt;reply_len
op_assign
l_int|3
suffix:semicolon
id|req-&gt;got_reply
op_assign
l_int|1
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * ready with this one, run &n;&t;&t;&t;&t;&t;&t; * next command or repeat last&n;&t;&t;&t;&t;&t;&t; * Talk (=idle on II)&n;&t;&t;&t;&t;&t;&t; */
multiline_comment|/* set state to idle !! */
id|adb_state
op_assign
id|idle
suffix:semicolon
r_if
c_cond
(paren
id|current_req
op_logical_or
id|retry_req
)paren
id|adb_start
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* not sure about this */
multiline_comment|/* &n;&t;&t;&t;&t;&t; * MS: Must set idle, no new request &n;&t;&t;&t;&t;&t; *     started else !&n;&t;&t;&t;&t;&t; */
id|adb_state
op_assign
id|idle
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * requires setting ADB state to idle,&n;&t;&t;&t;&t;&t; * maybe read a byte ! (done above)&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|current_req
op_logical_or
id|retry_req
)paren
id|adb_start
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; %x (%x %x) &quot;
comma
id|req-&gt;data
(braket
id|data_index
)braket
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
id|data_index
op_increment
)braket
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* switch ACK off */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
multiline_comment|/* delay */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* XXX: need to check for collision?? */
multiline_comment|/* set the shift register to shift out and send a byte */
macro_line|#if 0
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
id|data_index
op_increment
)braket
)paren
suffix:semicolon
multiline_comment|/* signal &squot;byte ready&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
id|data_index
op_increment
)braket
)paren
suffix:semicolon
multiline_comment|/* invert state bits, toggle ODD/EVEN */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|x
op_amp
op_complement
id|ST_MASK
)paren
op_or
op_complement
(paren
id|x
op_amp
id|ST_MASK
)paren
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|reading
suffix:colon
multiline_comment|/* timeout / SRQ handling for II hw */
macro_line|#ifdef POLL_ON_TIMEOUT
r_if
c_cond
(paren
(paren
id|reply_len
op_minus
id|prefix_len
)paren
op_eq
l_int|3
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|3
comma
l_string|&quot;&bslash;xFF&bslash;xFF&bslash;xFF&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
macro_line|#else
r_if
c_cond
(paren
(paren
id|first_byte
op_eq
l_int|0xFF
op_logical_and
(paren
id|reply_len
op_minus
id|prefix_len
)paren
op_eq
l_int|2
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|2
comma
l_string|&quot;&bslash;xFF&bslash;xFF&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|reply_len
op_minus
id|prefix_len
)paren
op_eq
l_int|3
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|3
comma
l_string|&quot;&bslash;xFF&bslash;xFF&bslash;xFF&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
)paren
macro_line|#endif
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * possible timeout (in fact, most probably a &n;&t;&t;&t;&t; * timeout, since SRQ can&squot;t be signaled without&n;&t;&t;&t;&t; * transfer on the bus).&n;&t;&t;&t;&t; * The last three bytes seen were FF, together &n;&t;&t;&t;&t; * with the starting byte (in case we started&n;&t;&t;&t;&t; * on &squot;idle&squot; or &squot;awaiting_reply&squot;) this probably&n;&t;&t;&t;&t; * makes four. So this is mostl likely #5!&n;&t;&t;&t;&t; * The timeout signal is a pattern 1 0 1 0 0..&n;&t;&t;&t;&t; * on /INT, meaning we missed it :-(&n;&t;&t;&t;&t; */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ne
l_int|0xFF
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: mistaken timeout/SRQ!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * ADB status bits: either even or odd.&n;&t;&t;&t;&t; * adb_state: need to set &squot;idle&squot; here.&n;&t;&t;&t;&t; * Maybe saner: set &squot;need_poll&squot; or &n;&t;&t;&t;&t; * &squot;need_resend&squot; here, fall through to &n;&t;&t;&t;&t; * read_done ??&n;&t;&t;&t;&t; */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; -&gt; read aborted: %x (%x %x)!&bslash;n&quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0&t;/* XXX leave status unchanged!! - need to check this again! */
multiline_comment|/* XXX Only touch status on II !!! */
multiline_comment|/* set ADB state to idle (required by adb_start()) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;&t; * What if the timeout happens on reading a &n;&t;&t;&t;&t; * reply ?? Assemble error reply and call &n;&t;&t;&t;&t; * current_request-&gt;done()? Keep request &n;&t;&t;&t;&t; * on queue?&n;&t;&t;&t;&t; */
multiline_comment|/* prevent &squot;busy&squot; in adb_start() */
id|need_poll
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Timeout: /IRQ alternates high/low during &n;&t;&t;&t;&t; *          4 &squot;FF&squot; bytes (1 0 1 0 0...)&n;&t;&t;&t;&t; *&t;    We&squot;re on byte 5, so we need one &n;&t;&t;&t;&t; *&t;    more backlog here (TBI) ....&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|TREQ
)paren
op_ne
(paren
id|last_status
op_amp
id|TREQ
)paren
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_SRQ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: reply timeout, resending!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;&t;&t; * first byte received should be the &n;&t;&t;&t;&t;&t; * command byte timing out !!&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|first_byte
op_ne
l_int|0xff
)paren
id|command_byte
op_assign
id|first_byte
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * compute target for retransmit: if&n;&t;&t;&t;&t;&t; * last_active is set, use that one, &n;&t;&t;&t;&t;&t; * else use command_byte&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|last_active
op_eq
op_minus
l_int|1
)paren
id|last_active
op_assign
(paren
id|command_byte
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
multiline_comment|/* resend if TALK, don&squot;t poll! */
r_if
c_cond
(paren
id|current_req
)paren
id|adb_start
c_func
(paren
)paren
suffix:semicolon
r_else
multiline_comment|/* &n;&t;&t;&t;&t;&t; * XXX: need to count the timeouts ?? &n;&t;&t;&t;&t;&t; * restart last active TALK ??&n;&t;&t;&t;&t;&t; * If no current_req, reuse old one!&n;&t;&t;&t;&t;&t; */
id|adb_retransmit
c_func
(paren
id|last_active
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * SRQ: NetBSD suggests /IRQ is asserted!?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_amp
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: SRQ signature w/o /INT!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_SRQ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: empty SRQ packet!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Terminate the SRQ packet and poll */
id|adb_state
op_assign
id|idle
suffix:semicolon
id|adb_queue_poll
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Leave ADB status lines unchanged (means /IRQ&n;&t;&t;&t;&t; * will still be low when entering adb_start!)&n;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
multiline_comment|/* end timeout / SRQ handling for II hw. */
r_if
c_cond
(paren
(paren
id|reply_len
op_minus
id|prefix_len
)paren
OG
l_int|3
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|3
comma
l_string|&quot;&bslash;xFF&bslash;xFF&bslash;xFF&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* SRQ tacked on data packet */
multiline_comment|/* Check /IRQ here ?? */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_SRQ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;nADB: Packet with SRQ!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Terminate the packet (SRQ never ends) */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|adb_state
op_assign
id|read_done
suffix:semicolon
id|reply_len
op_sub_assign
l_int|3
suffix:semicolon
id|reply_ptr
op_sub_assign
l_int|3
suffix:semicolon
id|need_poll
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* need to continue; next byte not seen else */
multiline_comment|/* &n;&t;&t;&t;&t; * XXX: not at all sure here; maybe need to &n;&t;&t;&t;&t; * send away the reply and poll immediately?&n;&t;&t;&t;&t; */
)brace
r_else
(brace
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
id|reply_len
OG
l_int|15
)paren
(brace
id|reply_len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* read byte */
op_star
id|reply_ptr
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|x
op_assign
op_star
id|reply_ptr
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; %x (%x %x) &quot;
comma
op_star
id|reply_ptr
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
id|reply_ptr
op_increment
suffix:semicolon
id|reply_len
op_increment
suffix:semicolon
)brace
multiline_comment|/* The usual handshake ... */
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|TIP
)paren
(brace
multiline_comment|/* that&squot;s all folks */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
suffix:semicolon
id|adb_state
op_assign
id|read_done
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assert status == TIP | TREQ */
r_if
c_cond
(paren
id|status
op_ne
id|TIP
op_plus
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;cuda: state=reading status=%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* ACK adb chip (maybe check for end first?) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
multiline_comment|/* end of frame?? */
r_if
c_cond
(paren
id|status
op_amp
id|TREQ
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_IIsi: end of frame!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* that&squot;s all folks */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TACK
op_or
id|TIP
)paren
)paren
suffix:semicolon
id|adb_state
op_assign
id|read_done
suffix:semicolon
multiline_comment|/* maybe process read_done here?? Handshake anyway?? */
)brace
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * NetBSD hints that the next to last byte &n;&t;&t;&t;&t; * is sent with IRQ !! &n;&t;&t;&t;&t; * Guido found out it&squot;s the last one (0x0),&n;&t;&t;&t;&t; * but IRQ should be asserted already.&n;&t;&t;&t;&t; * Problem with timeout detection: First&n;&t;&t;&t;&t; * transition to /IRQ might be second &n;&t;&t;&t;&t; * byte of timeout packet! &n;&t;&t;&t;&t; * Timeouts are signaled by 4x FF.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|TREQ
)paren
op_logical_and
id|x
op_eq
l_int|0x00
)paren
multiline_comment|/* != 0xFF */
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; -&gt; read done!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0&t;&t;/* XXX: we take one more byte (why?), so handshake! */
multiline_comment|/* set ADB state to idle */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* invert state bits, toggle ODD/EVEN */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|x
op_amp
op_complement
id|ST_MASK
)paren
op_or
op_complement
(paren
id|x
op_amp
id|ST_MASK
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* adjust packet length */
id|reply_len
op_decrement
suffix:semicolon
id|reply_ptr
op_decrement
suffix:semicolon
id|adb_state
op_assign
id|read_done
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
r_if
c_cond
(paren
id|status
op_ne
id|TIP
op_plus
id|TREQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;macII_adb: state=reading status=%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* not caught: ST_CMD */
multiline_comment|/* required for re-entry &squot;reading&squot;! */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|ST_MASK
)paren
op_eq
id|ST_IDLE
)paren
(brace
multiline_comment|/* (in)sanity check - set even */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_EVEN
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* invert state bits, toggle ODD/EVEN */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|x
op_amp
op_complement
id|ST_MASK
)paren
op_or
op_complement
(paren
id|x
op_amp
id|ST_MASK
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|read_done
suffix:colon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: read done: %x (%x %x)!&bslash;n&quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|reading_reply
)paren
(brace
id|req
op_assign
id|current_req
suffix:semicolon
id|req-&gt;reply_len
op_assign
id|reply_ptr
op_minus
id|req-&gt;reply
suffix:semicolon
id|req-&gt;got_reply
op_assign
l_int|1
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
)brace
r_else
(brace
id|adb_input
c_func
(paren
id|cuda_rbuf
comma
id|reply_ptr
op_minus
id|cuda_rbuf
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * remember this device ID; it&squot;s the latest we got a &n;&t;&t;&t; * reply from!&n;&t;&t;&t; */
id|last_reply
op_assign
id|command_byte
suffix:semicolon
id|last_active
op_assign
(paren
id|command_byte
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Assert status = ST_IDLE ??&n;&t;&t;&t; */
multiline_comment|/* &n;&t;&t;&t; * SRQ seen before, initiate poll now&n;&t;&t;&t; */
r_if
c_cond
(paren
id|need_poll
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_POLL)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;ADB: initiate poll!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|adb_state
op_assign
id|idle
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * set ADB status bits?? (unchanged above!)&n;&t;&t;&t;&t; */
id|adb_queue_poll
c_func
(paren
)paren
suffix:semicolon
id|need_poll
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hope this is ok; queue_poll runs adb_start */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * /IRQ seen, so the ADB controller has data for us&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|TREQ
)paren
)paren
(brace
multiline_comment|/* set ADB state to idle */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|ST_MASK
)paren
op_or
id|ST_IDLE
)paren
suffix:semicolon
id|adb_state
op_assign
id|reading
suffix:semicolon
id|reply_ptr
op_assign
id|cuda_rbuf
suffix:semicolon
id|reply_len
op_assign
l_int|0
suffix:semicolon
id|prefix_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
op_star
id|reply_ptr
op_increment
op_assign
id|ADB_PACKET
suffix:semicolon
op_star
id|reply_ptr
op_increment
op_assign
id|command_byte
suffix:semicolon
id|reply_len
op_assign
l_int|2
suffix:semicolon
id|prefix_len
op_assign
l_int|2
suffix:semicolon
)brace
id|reading_reply
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * no IRQ, send next packet or wait&n;&t;&t;&t;&t; */
id|adb_state
op_assign
id|idle
suffix:semicolon
r_if
c_cond
(paren
id|current_req
)paren
id|adb_start
c_func
(paren
)paren
suffix:semicolon
r_else
id|adb_retransmit
c_func
(paren
id|last_active
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATE)
id|printk
c_func
(paren
l_string|&quot;adb_interrupt: unknown adb_state %d?&bslash;n&quot;
comma
id|adb_state
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* reset mutex and interrupts */
id|driver_running
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Restart of CUDA support: please modify this interrupt handler while &n; * working at the Quadra etc. ADB driver. We can try to merge them later, or&n; * remove the CUDA stuff from the MacII handler&n; *&n; * MSch 27/01/98: Implemented IIsi driver based on initial code by Robert &n; * Thompson and hints from the NetBSD driver. CUDA and IIsi seem more closely&n; * related than to the MacII code, so merging all three might be a bad&n; * idea.&n; */
DECL|function|adb_cuda_interrupt
r_void
id|adb_cuda_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|arg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|x
comma
id|status
suffix:semicolon
r_struct
id|adb_request
op_star
id|req
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|status
op_assign
(paren
op_complement
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|TIP
op_or
id|TREQ
)paren
)paren
op_or
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
id|SR_OUT
)paren
suffix:semicolon
)brace
r_else
id|status
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
(paren
id|TIP
op_or
id|TREQ
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_INT)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_interrupt: state=%d status=%x&bslash;n&quot;
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|adb_state
)paren
(brace
r_case
id|idle
suffix:colon
id|first_byte
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
multiline_comment|/* CUDA has sent us the first byte of data - unsolicited */
r_if
c_cond
(paren
id|status
op_ne
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;cuda: state=idle, status=%x want=%x&bslash;n&quot;
comma
id|status
comma
id|TREQ
)paren
suffix:semicolon
macro_line|#endif
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_cuda: receiving unsol. packet: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TIP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
multiline_comment|/* set SR to IN */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* signal start of frame */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
multiline_comment|/* read first byte */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_IIsi : receiving unsol. packet: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ACK adb chip */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
r_if
c_cond
(paren
id|status
op_ne
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;adb_macII: state=idle status=%x want=%x&bslash;n&quot;
comma
id|status
comma
id|TREQ
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TIP
op_or
id|TACK
)paren
)paren
suffix:semicolon
)brace
id|adb_state
op_assign
id|reading
suffix:semicolon
id|reply_ptr
op_assign
id|cuda_rbuf
suffix:semicolon
id|reply_len
op_assign
l_int|0
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|awaiting_reply
suffix:colon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
multiline_comment|/* CUDA has sent us the first byte of data of a reply */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
r_if
c_cond
(paren
id|status
op_ne
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;cuda: state=awaiting_reply, status=%x want=%x&bslash;n&quot;
comma
id|status
comma
id|TREQ
)paren
suffix:semicolon
macro_line|#endif
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_cuda: reading reply: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TIP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* udelay(150);*/
multiline_comment|/* set SR to IN */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* signal start of frame */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
multiline_comment|/* read first byte */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|first_byte
op_assign
id|x
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_IIsi: reading reply: %x (%x %x) &quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
(brace
id|ending
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|ending
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* ACK adb chip */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
)brace
id|adb_state
op_assign
id|reading
suffix:semicolon
id|reply_ptr
op_assign
id|current_req-&gt;reply
suffix:semicolon
id|reading_reply
op_assign
l_int|1
suffix:semicolon
id|reply_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sent_first_byte
suffix:colon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; sending: %x (%x %x) &quot;
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|status
op_eq
id|TREQ
op_plus
id|TIP
op_plus
id|SR_OUT
)paren
(brace
multiline_comment|/* collision */
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_cuda: send collision!&bslash;n&quot;
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
op_or
id|TACK
)paren
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assert status == TIP + SR_OUT */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
r_if
c_cond
(paren
id|status
op_ne
id|TIP
op_plus
id|SR_OUT
)paren
id|printk
c_func
(paren
l_string|&quot;adb_cuda: state=sent_first_byte status=%x want=%x&bslash;n&quot;
comma
id|status
comma
id|TIP
op_plus
id|SR_OUT
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
id|data_index
op_assign
l_int|2
suffix:semicolon
id|adb_state
op_assign
id|sending
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* switch ACK off */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
id|TREQ
)paren
)paren
(brace
multiline_comment|/* collision */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_macIIsi: send collison, aborting!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set shift in */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* clear SR int. */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* set ADB state to &squot;idle&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TIP
op_or
id|TACK
)paren
)paren
suffix:semicolon
id|adb_state
op_assign
id|idle
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* delay */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* set the shift register to shift out and send a byte */
macro_line|#if 0
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* signal &squot;byte ready&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|data_index
op_assign
l_int|2
suffix:semicolon
id|adb_state
op_assign
id|sending
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
r_if
c_cond
(paren
id|status
op_ne
id|TIP
op_plus
id|SR_OUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;adb_macII: state=send_first_byte status=%x want=%x&bslash;n&quot;
comma
id|status
comma
id|TIP
op_plus
id|SR_OUT
)paren
suffix:semicolon
)brace
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|current_req-&gt;data
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
id|data_index
op_assign
l_int|2
suffix:semicolon
id|adb_state
op_assign
id|sending
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|sending
suffix:colon
id|req
op_assign
id|current_req
suffix:semicolon
r_if
c_cond
(paren
id|data_index
op_ge
id|req-&gt;nbytes
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; -&gt; end (%d of %d) (%x %x)!&bslash;n&quot;
comma
id|data_index
op_minus
l_int|1
comma
id|req-&gt;nbytes
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* XXX maybe clear ACK here ??? */
multiline_comment|/* switch ACK off */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
multiline_comment|/* delay */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* set the shift register to shift in */
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
multiline_comment|/* clear SR int. */
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
multiline_comment|/* set ADB state &squot;idle&squot; (end of frame) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TACK
op_or
id|TIP
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_amp
op_complement
id|SR_OUT
)paren
suffix:semicolon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
suffix:semicolon
)brace
id|req-&gt;sent
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;reply_expected
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * maybe fake a reply here on Listen ?? &n;&t;&t;&t;&t;&t; * Otherwise, a Listen hangs on success&n;&t;&t;&t;&t;&t; * CUDA+IIsi: only ADB Talk considered&n;&t;&t;&t;&t;&t; * RTC/PRAM read (0x1 0x3) to follow.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|req-&gt;data
(braket
l_int|0
)braket
op_eq
l_int|0x0
)paren
op_logical_and
(paren
(paren
id|req-&gt;data
(braket
l_int|1
)braket
op_amp
l_int|0xc
)paren
op_eq
l_int|0xc
)paren
)paren
id|adb_state
op_assign
id|awaiting_reply
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Reply expected, but none&n;&t;&t;&t;&t;&t;&t; * possible -&gt; fake reply.&n;&t;&t;&t;&t;&t;&t; */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_PROT)
id|printk
c_func
(paren
l_string|&quot;ADB: reply expected on Listen, faking reply&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* make it look weird */
multiline_comment|/* XXX: return reply_len -1? */
multiline_comment|/* XXX: fake ADB header? */
id|req-&gt;reply
(braket
l_int|0
)braket
op_assign
id|req-&gt;reply
(braket
l_int|1
)braket
op_assign
id|req-&gt;reply
(braket
l_int|2
)braket
op_assign
l_int|0xFF
suffix:semicolon
id|req-&gt;reply_len
op_assign
l_int|3
suffix:semicolon
id|req-&gt;got_reply
op_assign
l_int|1
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * ready with this one, run &n;&t;&t;&t;&t;&t;&t; * next command !&n;&t;&t;&t;&t;&t;&t; */
multiline_comment|/* set state to idle !! */
id|adb_state
op_assign
id|idle
suffix:semicolon
r_if
c_cond
(paren
id|current_req
op_logical_or
id|retry_req
)paren
id|adb_start
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* not sure about this */
id|adb_state
op_assign
id|idle
suffix:semicolon
id|adb_start
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_WRITE)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; %x (%x %x) &quot;
comma
id|req-&gt;data
(braket
id|data_index
)braket
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
id|data_index
op_increment
)braket
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* switch ACK off */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
multiline_comment|/* delay */
id|udelay
c_func
(paren
id|ADB_DELAY
)paren
suffix:semicolon
multiline_comment|/* XXX: need to check for collision?? */
multiline_comment|/* set the shift register to shift out and send a byte */
macro_line|#if 0
id|via_write
c_func
(paren
id|via1
comma
id|vACR
comma
id|via_read
c_func
(paren
id|via1
comma
id|vACR
)paren
op_or
id|SR_OUT
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
id|data_index
op_increment
)braket
)paren
suffix:semicolon
multiline_comment|/* signal &squot;byte ready&squot; */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vSR
comma
id|req-&gt;data
(braket
id|data_index
op_increment
)braket
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|reading
suffix:colon
r_if
c_cond
(paren
id|reply_len
op_eq
l_int|3
op_logical_and
id|memcmp
c_func
(paren
id|reply_ptr
op_minus
l_int|3
comma
l_string|&quot;&bslash;xFF&bslash;xFF&bslash;xFF&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Terminate the SRQ packet */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_SRQ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb: Got an SRQ&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|adb_state
op_assign
id|idle
suffix:semicolon
id|adb_queue_poll
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Sanity check - botched in orig. code! */
r_if
c_cond
(paren
id|reply_len
OG
l_int|15
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;adb_cuda: reply buffer overrun!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* wrap buffer */
id|reply_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reading_reply
)paren
id|reply_ptr
op_assign
id|current_req-&gt;reply
suffix:semicolon
r_else
id|reply_ptr
op_assign
id|cuda_rbuf
suffix:semicolon
)brace
op_star
id|reply_ptr
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot; %x (%x %x) &quot;
comma
op_star
id|reply_ptr
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
id|reply_ptr
op_increment
suffix:semicolon
id|reply_len
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|TIP
)paren
(brace
multiline_comment|/* that&squot;s all folks */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
suffix:semicolon
id|adb_state
op_assign
id|read_done
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assert status == TIP | TREQ */
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
r_if
c_cond
(paren
id|status
op_ne
id|TIP
op_plus
id|TREQ
)paren
id|printk
c_func
(paren
l_string|&quot;cuda: state=reading status=%x want=%x&bslash;n&quot;
comma
id|status
comma
id|TIP
op_plus
id|TREQ
)paren
suffix:semicolon
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
(brace
multiline_comment|/* ACK adb chip (maybe check for end first?) */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TACK
)paren
suffix:semicolon
multiline_comment|/* end of frame?? */
r_if
c_cond
(paren
id|status
op_amp
id|TREQ
)paren
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb_IIsi: end of frame!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* that&squot;s all folks */
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
(paren
id|TACK
op_or
id|TIP
)paren
)paren
suffix:semicolon
id|adb_state
op_assign
id|read_done
suffix:semicolon
multiline_comment|/* XXX maybe process read_done here?? &n;&t;&t;&t;&t;&t;   Handshake anyway?? */
)brace
)brace
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|TIP
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TACK
op_or
id|TIP
)paren
suffix:semicolon
id|adb_state
op_assign
id|read_done
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_STATUS)
r_if
c_cond
(paren
id|status
op_ne
id|TIP
op_plus
id|TREQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;macII_adb: state=reading status=%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_xor
id|TACK
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* fall through for IIsi on end of frame */
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_ne
id|MAC_ADB_IISI
op_logical_or
id|adb_state
op_ne
id|read_done
)paren
r_break
suffix:semicolon
r_case
id|read_done
suffix:colon
id|x
op_assign
id|via_read
c_func
(paren
id|via1
comma
id|vSR
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_READ)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
id|printk
c_func
(paren
l_string|&quot;adb: read done: %x (%x %x)!&bslash;n&quot;
comma
id|x
comma
id|adb_state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|reading_reply
)paren
(brace
id|req
op_assign
id|current_req
suffix:semicolon
id|req-&gt;reply_len
op_assign
id|reply_ptr
op_minus
id|req-&gt;reply
suffix:semicolon
id|req-&gt;got_reply
op_assign
l_int|1
suffix:semicolon
id|current_req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;done
)paren
(paren
op_star
id|req-&gt;done
)paren
(paren
id|req
)paren
suffix:semicolon
)brace
r_else
(brace
id|adb_input
c_func
(paren
id|cuda_rbuf
comma
id|reply_ptr
op_minus
id|cuda_rbuf
comma
id|regs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
op_logical_and
id|status
op_amp
id|TREQ
)paren
(brace
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_amp
op_complement
id|TIP
)paren
suffix:semicolon
id|adb_state
op_assign
id|reading
suffix:semicolon
id|reply_ptr
op_assign
id|cuda_rbuf
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
op_logical_and
op_logical_neg
(paren
id|status
op_amp
id|TREQ
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via1
comma
id|vBufB
comma
id|via_read
c_func
(paren
id|via1
comma
id|vBufB
)paren
op_or
id|TIP
)paren
suffix:semicolon
id|adb_state
op_assign
id|reading
suffix:semicolon
id|reply_ptr
op_assign
id|cuda_rbuf
suffix:semicolon
id|reading_reply
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|adb_state
op_assign
id|idle
suffix:semicolon
id|adb_start
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;adb_cuda_interrupt: unknown adb_state %d?&bslash;n&quot;
comma
id|adb_state
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The &squot;reply delivery&squot; routine; determines which device sent the &n; *&t;request and calls the appropriate handler. &n; *&t;Reply data are expected in CUDA format (again, argh...) so we need&n; *&t;to fake this in the interrupt handler for MacII.&n; *&t;Only one handler per device ID is currently possible.&n; *&t;XXX: is the ID field here representing the default or real ID?&n; */
DECL|function|adb_input
r_static
r_void
id|adb_input
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|nb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
comma
id|id
suffix:semicolon
r_switch
c_cond
(paren
id|buf
(braket
l_int|0
)braket
)paren
(brace
r_case
id|ADB_PACKET
suffix:colon
multiline_comment|/* what&squot;s in buf[1] ?? */
id|id
op_assign
id|buf
(braket
l_int|2
)braket
op_rshift
l_int|4
suffix:semicolon
macro_line|#if 0
id|xmon_printf
c_func
(paren
l_string|&quot;adb packet: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nb
suffix:semicolon
op_increment
id|i
)paren
id|xmon_printf
c_func
(paren
l_string|&quot; %x&quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|xmon_printf
c_func
(paren
l_string|&quot;, id = %d&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_INPUT)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;adb_input: adb packet &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nb
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; %x&quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, id = %d&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|adb_handler
(braket
id|id
)braket
dot
id|handler
op_ne
l_int|0
)paren
(brace
(paren
op_star
id|adb_handler
(braket
id|id
)braket
dot
id|handler
)paren
(paren
id|buf
comma
id|nb
comma
id|regs
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_INPUT)
r_if
c_cond
(paren
id|console_loglevel
op_eq
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;adb_input: data from via (%d bytes):&quot;
comma
id|nb
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nb
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; %.2x&quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
multiline_comment|/* Ultimately this should return the number of devices with&n;   the given default id. */
DECL|function|adb_register
r_int
id|adb_register
c_func
(paren
r_int
id|default_id
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
r_char
op_star
comma
r_int
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_if
c_cond
(paren
id|adb_handler
(braket
id|default_id
)braket
dot
id|handler
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Two handlers for ADB device %d&bslash;n&quot;
comma
id|default_id
)paren
suffix:semicolon
id|adb_handler
(braket
id|default_id
)braket
dot
id|handler
op_assign
id|handler
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * /dev/adb device driver.&n; */
DECL|macro|ADB_MAJOR
mdefine_line|#define ADB_MAJOR&t;56&t;/* major number for /dev/adb */
DECL|macro|ADB_MAX_MINOR
mdefine_line|#define ADB_MAX_MINOR&t;64&t;/* range of ADB minors */
DECL|macro|ADB_TYPE_SHIFT
mdefine_line|#define ADB_TYPE_SHIFT&t;4&t;/* # bits for device ID/type in subdevices */
DECL|macro|ADB_TYPE_RAW
mdefine_line|#define ADB_TYPE_RAW&t;0&t;/* raw device; unbuffered */
DECL|macro|ADB_TYPE_BUFF
mdefine_line|#define ADB_TYPE_BUFF&t;1&t;/* raw device; buffered */
DECL|macro|ADB_TYPE_COOKED
mdefine_line|#define ADB_TYPE_COOKED&t;2&t;/* &squot;cooked&squot; device */
r_extern
r_void
id|adbdev_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|struct|adbdev_state
r_struct
id|adbdev_state
(brace
DECL|member|req
r_struct
id|adb_request
id|req
suffix:semicolon
)brace
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|adb_wait
)paren
suffix:semicolon
DECL|function|adb_wait_reply
r_static
r_int
id|adb_wait_reply
c_func
(paren
r_struct
id|adbdev_state
op_star
id|state
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|adb_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|state-&gt;req.got_reply
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|adb_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|adb_write_done
r_static
r_void
id|adb_write_done
c_func
(paren
r_struct
id|adb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;got_reply
)paren
(brace
id|req-&gt;reply_len
op_assign
l_int|0
suffix:semicolon
id|req-&gt;got_reply
op_assign
l_int|1
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|adb_wait
)paren
suffix:semicolon
)brace
DECL|variable|adb_raw
r_struct
id|file_operations
op_star
id|adb_raw
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|adb_buffered
r_struct
id|file_operations
op_star
id|adb_buffered
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|adb_cooked
r_struct
id|file_operations
op_star
id|adb_cooked
(braket
l_int|16
)braket
suffix:semicolon
DECL|function|adb_open
r_static
r_int
id|adb_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|adb_type
comma
id|adb_subtype
suffix:semicolon
r_struct
id|adbdev_state
op_star
id|state
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
OG
id|ADB_MAX_MINOR
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_switch
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|ADB_TYPE_SHIFT
)paren
(brace
r_case
id|ADB_TYPE_RAW
suffix:colon
multiline_comment|/* see code below */
r_break
suffix:semicolon
r_case
id|ADB_TYPE_BUFF
suffix:colon
multiline_comment|/* TBI */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_case
id|ADB_TYPE_COOKED
suffix:colon
multiline_comment|/* subtypes such as kbd, mouse, ... */
id|adb_subtype
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
op_complement
id|ADB_TYPE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_op
op_assign
id|adb_cooked
(braket
id|adb_subtype
)braket
)paren
)paren
r_return
id|file-&gt;f_op
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|adbdev_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|file-&gt;private_data
op_assign
id|state
suffix:semicolon
id|state-&gt;req.reply_expected
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|adb_release
r_static
r_void
id|adb_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|adbdev_state
op_star
id|state
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;req.reply_expected
op_logical_and
op_logical_neg
id|state-&gt;req.got_reply
)paren
r_if
c_cond
(paren
id|adb_wait_reply
c_func
(paren
id|state
comma
id|file
)paren
)paren
r_return
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|adb_lseek
r_static
r_int
id|adb_lseek
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|off_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
DECL|function|adb_read
r_static
r_int
id|adb_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|adbdev_state
op_star
id|state
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
r_sizeof
(paren
id|state-&gt;req.reply
)paren
)paren
id|count
op_assign
r_sizeof
(paren
id|state-&gt;req.reply
)paren
suffix:semicolon
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;req.reply_expected
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|adb_wait_reply
c_func
(paren
id|state
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|state-&gt;req.reply_expected
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|state-&gt;req.reply_len
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
id|state-&gt;req.reply
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|adb_write
r_static
r_int
id|adb_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
r_struct
id|adbdev_state
op_star
id|state
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|count
template_param
r_sizeof
(paren
id|state-&gt;req.data
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;req.reply_expected
op_logical_and
op_logical_neg
id|state-&gt;req.got_reply
)paren
(brace
multiline_comment|/* A previous request is still being processed.&n;&t;&t;   Wait for it to finish. */
id|ret
op_assign
id|adb_wait_reply
c_func
(paren
id|state
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
id|state-&gt;req.nbytes
op_assign
id|count
suffix:semicolon
id|state-&gt;req.done
op_assign
id|adb_write_done
suffix:semicolon
id|state-&gt;req.got_reply
op_assign
l_int|0
suffix:semicolon
id|copy_from_user
c_func
(paren
id|state-&gt;req.data
comma
id|buf
comma
id|count
)paren
suffix:semicolon
macro_line|#if 0
r_switch
c_cond
(paren
id|adb_hardware
)paren
(brace
r_case
id|ADB_NONE
suffix:colon
r_return
op_minus
id|ENXIO
suffix:semicolon
r_case
id|ADB_VIACUDA
suffix:colon
id|state-&gt;req.reply_expected
op_assign
l_int|1
suffix:semicolon
id|cuda_send_request
c_func
(paren
op_amp
id|state-&gt;req
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|state-&gt;req.data
(braket
l_int|0
)braket
op_ne
id|ADB_PACKET
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|state-&gt;req.nbytes
suffix:semicolon
op_increment
id|i
)paren
id|state-&gt;req.data
(braket
id|i
)braket
op_assign
id|state-&gt;req.data
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|state-&gt;req.reply_expected
op_assign
(paren
(paren
id|state-&gt;req.data
(braket
l_int|0
)braket
op_amp
l_int|0xc
)paren
op_eq
l_int|0xc
)paren
suffix:semicolon
id|adb_send_request
c_func
(paren
op_amp
id|state-&gt;req
)paren
suffix:semicolon
macro_line|#if 0
r_break
suffix:semicolon
)brace
macro_line|#endif
r_return
id|count
suffix:semicolon
)brace
DECL|variable|adb_fops
r_static
r_struct
id|file_operations
id|adb_fops
op_assign
(brace
id|adb_lseek
comma
id|adb_read
comma
id|adb_write
comma
l_int|NULL
comma
multiline_comment|/* no readdir */
l_int|NULL
comma
multiline_comment|/* no poll yet */
l_int|NULL
comma
multiline_comment|/* no ioctl yet */
l_int|NULL
comma
multiline_comment|/* no mmap */
id|adb_open
comma
l_int|NULL
comma
multiline_comment|/* flush */
id|adb_release
)brace
suffix:semicolon
DECL|function|adbdev_register
r_int
id|adbdev_register
c_func
(paren
r_int
id|subtype
comma
r_struct
id|file_operations
op_star
id|fops
)paren
(brace
r_if
c_cond
(paren
id|subtype
template_param
l_int|15
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|adb_cooked
(braket
id|subtype
)braket
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|adb_cooked
(braket
id|subtype
)braket
op_assign
id|fops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|adbdev_unregister
r_int
id|adbdev_unregister
c_func
(paren
r_int
id|subtype
)paren
(brace
r_if
c_cond
(paren
id|subtype
template_param
l_int|15
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adb_cooked
(braket
id|subtype
)braket
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|adb_cooked
(braket
id|subtype
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|adbdev_init
r_void
id|adbdev_init
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|ADB_MAJOR
comma
l_string|&quot;adb&quot;
comma
op_amp
id|adb_fops
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;adb: unable to get major %d&bslash;n&quot;
comma
id|ADB_MAJOR
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* old ADB device */
multiline_comment|/*&n; * Here are the file operations we export for /dev/adb.&n; */
mdefine_line|#define ADB_MINOR&t;140&t;/* /dev/adb is c 10 140 */
r_extern
r_void
id|adbdev_inits
c_func
(paren
r_void
)paren
suffix:semicolon
r_struct
id|adbdev_state
(brace
r_struct
id|adb_request
id|req
suffix:semicolon
)brace
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|adb_wait
)paren
suffix:semicolon
r_static
r_int
id|adb_wait_reply
c_func
(paren
r_struct
id|adbdev_state
op_star
id|state
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
macro_line|#if (ADBDEBUG &amp; ADBDEBUG_DEVICE)
id|printk
c_func
(paren
l_string|&quot;ADB request: wait_reply (blocking ... &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|add_wait_queue
c_func
(paren
op_amp
id|adb_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|state-&gt;req.got_reply
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|adb_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
id|adb_write_done
c_func
(paren
r_struct
id|adb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;got_reply
)paren
(brace
id|req-&gt;reply_len
op_assign
l_int|0
suffix:semicolon
id|req-&gt;got_reply
op_assign
l_int|1
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|adb_wait
)paren
suffix:semicolon
)brace
r_static
r_int
id|adb_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|adbdev_state
op_star
id|state
suffix:semicolon
id|state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|adbdev_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|file-&gt;private_data
op_assign
id|state
suffix:semicolon
id|state-&gt;req.reply_expected
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|adb_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|adbdev_state
op_star
id|state
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;req.reply_expected
op_logical_and
op_logical_neg
id|state-&gt;req.got_reply
)paren
r_if
c_cond
(paren
id|adb_wait_reply
c_func
(paren
id|state
comma
id|file
)paren
)paren
r_return
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
id|adb_lseek
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|off_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
r_static
r_int
id|adb_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|adbdev_state
op_star
id|state
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|2
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
r_sizeof
(paren
id|state-&gt;req.reply
)paren
)paren
id|count
op_assign
r_sizeof
(paren
id|state-&gt;req.reply
)paren
suffix:semicolon
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;req.reply_expected
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|adb_wait_reply
c_func
(paren
id|state
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|state-&gt;req.reply_len
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|buf
comma
id|state-&gt;req.reply
comma
id|ret
)paren
suffix:semicolon
id|state-&gt;req.reply_expected
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
id|adb_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|adbdev_state
op_star
id|state
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|count
template_param
r_sizeof
(paren
id|state-&gt;req.data
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;req.reply_expected
op_logical_and
op_logical_neg
id|state-&gt;req.got_reply
)paren
(brace
multiline_comment|/* A previous request is still being processed.&n;&t;&t;   Wait for it to finish. */
id|ret
op_assign
id|adb_wait_reply
c_func
(paren
id|state
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
id|state-&gt;req.nbytes
op_assign
id|count
suffix:semicolon
id|state-&gt;req.done
op_assign
id|adb_write_done
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|state-&gt;req.data
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|state-&gt;req.reply_expected
op_assign
l_int|1
suffix:semicolon
id|state-&gt;req.got_reply
op_assign
l_int|0
suffix:semicolon
id|adb_send_request
c_func
(paren
op_amp
id|state-&gt;req
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
r_struct
id|file_operations
id|adb_fops
op_assign
(brace
id|adb_lseek
comma
id|adb_read
comma
id|adb_write
comma
l_int|NULL
comma
multiline_comment|/* no readdir */
l_int|NULL
comma
multiline_comment|/* no select */
l_int|NULL
comma
multiline_comment|/* no ioctl */
l_int|NULL
comma
multiline_comment|/* no mmap */
id|adb_open
comma
l_int|NULL
comma
multiline_comment|/* flush */
id|adb_release
)brace
suffix:semicolon
r_static
r_struct
id|miscdevice
id|adb_dev
op_assign
(brace
id|ADB_MINOR
comma
l_string|&quot;adb&quot;
comma
op_amp
id|adb_fops
)brace
suffix:semicolon
r_void
id|adbdev_init
c_func
(paren
r_void
)paren
(brace
id|misc_register
c_func
(paren
op_amp
id|adb_dev
)paren
suffix:semicolon
)brace
macro_line|#endif /* old ADB device */
eof
