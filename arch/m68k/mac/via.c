multiline_comment|/*&n; *&t;6522 Versatile Interface Adapter (VIA)&n; *&n; *&t;There are two of these on the Mac II. Some IRQ&squot;s are vectored&n; *&t;via them as are assorted bits and bobs - eg RTC, ADB.&n; *&n; * CSA: Motorola seems to have removed documentation on the 6522 from&n; * their web site; try&n; *     http://nerini.drf.com/vectrex/other/text/chips/6522/&n; *     http://www.zymurgy.net/classic/vic20/vicdet1.htm&n; * and&n; *     http://193.23.168.87/mikro_laborversuche/via_iobaustein/via6522_1.html&n; * for info.  A full-text web search on 6522 AND VIA will probably also&n; * net some usefulness. &lt;cananian@alumni.princeton.edu&gt; 20apr1999&n; *&n; * PRAM/RTC access algorithms are from the NetBSD RTC toolkit version 1.08b&n; * by Erik Vogan and adapted to Linux by Joshua M. Thompson (funaho@jurai.org)&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt; 
macro_line|#include &lt;asm/macintosh.h&gt; 
macro_line|#include &lt;asm/macints.h&gt;
macro_line|#include &lt;asm/machw.h&gt; 
macro_line|#include &lt;asm/mac_via.h&gt;
macro_line|#include &lt;asm/mac_psc.h&gt;
DECL|variable|via1
DECL|variable|via2
r_volatile
id|__u8
op_star
id|via1
comma
op_star
id|via2
suffix:semicolon
macro_line|#if 0
multiline_comment|/* See note in mac_via.h about how this is possibly not useful */
r_volatile
r_int
op_star
id|via_memory_bogon
op_assign
(paren
r_int
op_star
)paren
op_amp
id|via_memory_bogon
suffix:semicolon
macro_line|#endif
DECL|variable|rbv_present
DECL|variable|via_alt_mapping
r_int
id|rbv_present
comma
id|via_alt_mapping
suffix:semicolon
DECL|variable|rbv_clear
id|__u8
id|rbv_clear
suffix:semicolon
multiline_comment|/*&n; * Globals for accessing the VIA chip registers without having to&n; * check if we&squot;re hitting a real VIA or an RBV. Normally you could&n; * just hit the combined register (ie, vIER|rIER) but that seems to&n; * break on AV Macs...probably because they actually decode more than&n; * eight address bits. Why can&squot;t Apple engineers at least be&n; * _consistantly_ lazy?                          - 1999-05-21 (jmt)&n; */
DECL|variable|gIER
DECL|variable|gIFR
DECL|variable|gBufA
DECL|variable|gBufB
r_static
r_int
id|gIER
comma
id|gIFR
comma
id|gBufA
comma
id|gBufB
suffix:semicolon
multiline_comment|/*&n; * Timer defs.&n; */
DECL|macro|TICK_SIZE
mdefine_line|#define TICK_SIZE&t;&t;10000
DECL|macro|MAC_CLOCK_TICK
mdefine_line|#define MAC_CLOCK_TICK&t;&t;(783300/HZ)&t;&t;/* ticks per HZ */
DECL|macro|MAC_CLOCK_LOW
mdefine_line|#define MAC_CLOCK_LOW&t;&t;(MAC_CLOCK_TICK&amp;0xFF)
DECL|macro|MAC_CLOCK_HIGH
mdefine_line|#define MAC_CLOCK_HIGH&t;&t;(MAC_CLOCK_TICK&gt;&gt;8)
DECL|variable|nubus_active
r_static
r_int
id|nubus_active
suffix:semicolon
r_void
id|via_debug_dump
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|via1_irq
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_void
id|via2_irq
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_void
id|via_nubus_irq
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_void
id|via_irq_enable
c_func
(paren
r_int
id|irq
)paren
suffix:semicolon
r_void
id|via_irq_disable
c_func
(paren
r_int
id|irq
)paren
suffix:semicolon
r_void
id|via_irq_clear
c_func
(paren
r_int
id|irq
)paren
suffix:semicolon
r_extern
r_void
id|mac_bang
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_void
id|mac_SCC_handler
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
id|console_loglevel
suffix:semicolon
r_extern
r_int
id|oss_present
suffix:semicolon
multiline_comment|/*&n; * Initialize the VIAs&n; *&n; * First we figure out where they actually _are_ as well as what type of&n; * VIA we have for VIA2 (it could be a real VIA or an RBV or even an OSS.)&n; * Then we pretty much clear them out and disable all IRQ sources.&n; *&n; * Note: the OSS is actually &quot;detected&quot; here and not in oss_init(). It just&n; *&t; seems more logical to do it here since via_init() needs to know&n; *&t; these things anyways.&n; */
DECL|function|via_init
r_void
id|__init
id|via_init
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|macintosh_config-&gt;via_type
)paren
(brace
multiline_comment|/* IIci, IIsi, IIvx, IIvi (P6xx), LC series */
r_case
id|MAC_VIA_IIci
suffix:colon
id|via1
op_assign
(paren
r_void
op_star
)paren
id|VIA1_BASE
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_IIFX
)paren
(brace
id|via2
op_assign
l_int|NULL
suffix:semicolon
id|rbv_present
op_assign
l_int|0
suffix:semicolon
id|oss_present
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|via2
op_assign
(paren
r_void
op_star
)paren
id|RBV_BASE
suffix:semicolon
id|rbv_present
op_assign
l_int|1
suffix:semicolon
id|oss_present
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_LCIII
)paren
(brace
id|rbv_clear
op_assign
l_int|0x00
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* on most RBVs (&amp; unlike the VIAs), you   */
multiline_comment|/* need to set bit 7 when you write to IFR */
multiline_comment|/* in order for your clear to occur.       */
id|rbv_clear
op_assign
l_int|0x80
suffix:semicolon
)brace
id|gIER
op_assign
id|rIER
suffix:semicolon
id|gIFR
op_assign
id|rIFR
suffix:semicolon
id|gBufA
op_assign
id|rSIFR
suffix:semicolon
id|gBufB
op_assign
id|rBufB
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Quadra and early MacIIs agree on the VIA locations */
r_case
id|MAC_VIA_QUADRA
suffix:colon
r_case
id|MAC_VIA_II
suffix:colon
id|via1
op_assign
(paren
r_void
op_star
)paren
id|VIA1_BASE
suffix:semicolon
id|via2
op_assign
(paren
r_void
op_star
)paren
id|VIA2_BASE
suffix:semicolon
id|rbv_present
op_assign
l_int|0
suffix:semicolon
id|oss_present
op_assign
l_int|0
suffix:semicolon
id|rbv_clear
op_assign
l_int|0x00
suffix:semicolon
id|gIER
op_assign
id|vIER
suffix:semicolon
id|gIFR
op_assign
id|vIFR
suffix:semicolon
id|gBufA
op_assign
id|vBufA
suffix:semicolon
id|gBufB
op_assign
id|vBufB
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;UNKNOWN VIA TYPE&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;VIA1 at %p is a 6522 or clone&bslash;n&quot;
comma
id|via1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VIA2 at %p is &quot;
comma
id|via2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;an RBV&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|oss_present
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;an OSS&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;a 6522 or clone&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_VIA
id|via_debug_dump
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Shut down all IRQ sources, reset the timers, and&n;&t; * kill the timer latch on VIA1.&n;&t; */
id|via1
(braket
id|vIER
)braket
op_assign
l_int|0x7F
suffix:semicolon
id|via1
(braket
id|vIFR
)braket
op_assign
l_int|0x7F
suffix:semicolon
id|via1
(braket
id|vT1LL
)braket
op_assign
l_int|0
suffix:semicolon
id|via1
(braket
id|vT1LH
)braket
op_assign
l_int|0
suffix:semicolon
id|via1
(braket
id|vT1CL
)braket
op_assign
l_int|0
suffix:semicolon
id|via1
(braket
id|vT1CH
)braket
op_assign
l_int|0
suffix:semicolon
id|via1
(braket
id|vT2CL
)braket
op_assign
l_int|0
suffix:semicolon
id|via1
(braket
id|vT2CH
)braket
op_assign
l_int|0
suffix:semicolon
id|via1
(braket
id|vACR
)braket
op_and_assign
l_int|0x3F
suffix:semicolon
multiline_comment|/* &n;&t; * SE/30: disable video IRQ&n;&t; * XXX: testing for SE/30 VBL&n;&t; */
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_SE30
)paren
(brace
id|via1
(braket
id|vDirB
)braket
op_or_assign
l_int|0x40
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_or_assign
l_int|0x40
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set the RTC bits to a known state: all lines to outputs and&n;&t; * RTC disabled (yes that&squot;s 0 to enable and 1 to disable).&n;&t; */
id|via1
(braket
id|vDirB
)braket
op_or_assign
(paren
id|VIA1B_vRTCEnb
op_or
id|VIA1B_vRTCClk
op_or
id|VIA1B_vRTCData
)paren
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_or_assign
(paren
id|VIA1B_vRTCEnb
op_or
id|VIA1B_vRTCClk
)paren
suffix:semicolon
multiline_comment|/* Everything below this point is VIA2/RBV only... */
r_if
c_cond
(paren
id|oss_present
)paren
r_return
suffix:semicolon
macro_line|#if 1
multiline_comment|/* Some machines support an alternate IRQ mapping that spreads  */
multiline_comment|/* Ethernet and Sound out to their own autolevel IRQs and moves */
multiline_comment|/* VIA1 to level 6. A/UX uses this mapping and we do too.  Note */
multiline_comment|/* that the IIfx emulates this alternate mapping using the OSS. */
r_switch
c_cond
(paren
id|macintosh_config-&gt;ident
)paren
(brace
r_case
id|MAC_MODEL_C610
suffix:colon
r_case
id|MAC_MODEL_Q610
suffix:colon
r_case
id|MAC_MODEL_C650
suffix:colon
r_case
id|MAC_MODEL_Q650
suffix:colon
r_case
id|MAC_MODEL_Q700
suffix:colon
r_case
id|MAC_MODEL_Q800
suffix:colon
r_case
id|MAC_MODEL_Q900
suffix:colon
r_case
id|MAC_MODEL_Q950
suffix:colon
id|via_alt_mapping
op_assign
l_int|1
suffix:semicolon
id|via1
(braket
id|vDirB
)braket
op_or_assign
l_int|0x40
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_and_assign
op_complement
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|via_alt_mapping
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* The alernate IRQ mapping seems to just not work. Anyone with a   */
multiline_comment|/* supported machine is welcome to take a stab at fixing it. It     */
multiline_comment|/* _should_ work on the following Quadras: 610,650,700,800,900,950  */
multiline_comment|/*                                               - 1999-06-12 (jmt) */
id|via_alt_mapping
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Now initialize VIA2. For RBV we just kill all interrupts;&n;&t; * for a regular VIA we also reset the timers and stuff.&n;&t; */
id|via2
(braket
id|gIER
)braket
op_assign
l_int|0x7F
suffix:semicolon
id|via2
(braket
id|gIFR
)braket
op_assign
l_int|0x7F
op_or
id|rbv_clear
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rbv_present
)paren
(brace
id|via2
(braket
id|vT1LL
)braket
op_assign
l_int|0
suffix:semicolon
id|via2
(braket
id|vT1LH
)braket
op_assign
l_int|0
suffix:semicolon
id|via2
(braket
id|vT1CL
)braket
op_assign
l_int|0
suffix:semicolon
id|via2
(braket
id|vT1CH
)braket
op_assign
l_int|0
suffix:semicolon
id|via2
(braket
id|vT2CL
)braket
op_assign
l_int|0
suffix:semicolon
id|via2
(braket
id|vT2CH
)braket
op_assign
l_int|0
suffix:semicolon
id|via2
(braket
id|vACR
)braket
op_and_assign
l_int|0x3F
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Start the 100 Hz clock&n; */
DECL|function|via_init_clock
r_void
id|__init
id|via_init_clock
c_func
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
id|via1
(braket
id|vACR
)braket
op_or_assign
l_int|0x40
suffix:semicolon
id|via1
(braket
id|vT1LL
)braket
op_assign
id|MAC_CLOCK_LOW
suffix:semicolon
id|via1
(braket
id|vT1LH
)braket
op_assign
id|MAC_CLOCK_HIGH
suffix:semicolon
id|via1
(braket
id|vT1CL
)braket
op_assign
id|MAC_CLOCK_LOW
suffix:semicolon
id|via1
(braket
id|vT1CH
)braket
op_assign
id|MAC_CLOCK_HIGH
suffix:semicolon
id|request_irq
c_func
(paren
id|IRQ_MAC_TIMER_1
comma
id|func
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;timer&quot;
comma
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Register the interrupt dispatchers for VIA or RBV machines only.&n; */
DECL|function|via_register_interrupts
r_void
id|__init
id|via_register_interrupts
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|via_alt_mapping
)paren
(brace
id|request_irq
c_func
(paren
id|IRQ_AUTO_1
comma
id|via1_irq
comma
id|IRQ_FLG_LOCK
op_or
id|IRQ_FLG_FAST
comma
l_string|&quot;Software IRQ&quot;
comma
(paren
r_void
op_star
)paren
id|via1
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|IRQ_AUTO_6
comma
id|via1_irq
comma
id|IRQ_FLG_LOCK
op_or
id|IRQ_FLG_FAST
comma
l_string|&quot;VIA1 Dispatch&quot;
comma
(paren
r_void
op_star
)paren
id|via1
)paren
suffix:semicolon
)brace
r_else
(brace
id|request_irq
c_func
(paren
id|IRQ_AUTO_1
comma
id|via1_irq
comma
id|IRQ_FLG_LOCK
op_or
id|IRQ_FLG_FAST
comma
l_string|&quot;VIA1 Dispatch&quot;
comma
(paren
r_void
op_star
)paren
id|via1
)paren
suffix:semicolon
macro_line|#if 0 /* interferes with serial on some machines */
r_if
c_cond
(paren
op_logical_neg
id|psc_present
)paren
(brace
id|request_irq
c_func
(paren
id|IRQ_AUTO_6
comma
id|mac_bang
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;Off Switch&quot;
comma
id|mac_bang
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|request_irq
c_func
(paren
id|IRQ_AUTO_2
comma
id|via2_irq
comma
id|IRQ_FLG_LOCK
op_or
id|IRQ_FLG_FAST
comma
l_string|&quot;VIA2 Dispatch&quot;
comma
(paren
r_void
op_star
)paren
id|via2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|psc_present
)paren
(brace
id|request_irq
c_func
(paren
id|IRQ_AUTO_4
comma
id|mac_SCC_handler
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;SCC Dispatch&quot;
comma
id|mac_SCC_handler
)paren
suffix:semicolon
)brace
id|request_irq
c_func
(paren
id|IRQ_MAC_NUBUS
comma
id|via_nubus_irq
comma
id|IRQ_FLG_LOCK
op_or
id|IRQ_FLG_FAST
comma
l_string|&quot;Nubus Dispatch&quot;
comma
(paren
r_void
op_star
)paren
id|via2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Debugging dump, used in various places to see what&squot;s going on.&n; */
DECL|function|via_debug_dump
r_void
id|via_debug_dump
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VIA1: DDRA = 0x%02X DDRB = 0x%02X ACR = 0x%02X&bslash;n&quot;
comma
(paren
id|uint
)paren
id|via1
(braket
id|vDirA
)braket
comma
(paren
id|uint
)paren
id|via1
(braket
id|vDirB
)braket
comma
(paren
id|uint
)paren
id|via1
(braket
id|vACR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;         PCR = 0x%02X  IFR = 0x%02X IER = 0x%02X&bslash;n&quot;
comma
(paren
id|uint
)paren
id|via1
(braket
id|vPCR
)braket
comma
(paren
id|uint
)paren
id|via1
(braket
id|vIFR
)braket
comma
(paren
id|uint
)paren
id|via1
(braket
id|vIER
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oss_present
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VIA2: &lt;OSS&gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VIA2:  IFR = 0x%02X  IER = 0x%02X&bslash;n&quot;
comma
(paren
id|uint
)paren
id|via2
(braket
id|rIFR
)braket
comma
(paren
id|uint
)paren
id|via2
(braket
id|rIER
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      SIFR = 0x%02X SIER = 0x%02X&bslash;n&quot;
comma
(paren
id|uint
)paren
id|via2
(braket
id|rSIFR
)braket
comma
(paren
id|uint
)paren
id|via2
(braket
id|rSIER
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;VIA2: DDRA = 0x%02X DDRB = 0x%02X ACR = 0x%02X&bslash;n&quot;
comma
(paren
id|uint
)paren
id|via2
(braket
id|vDirA
)braket
comma
(paren
id|uint
)paren
id|via2
(braket
id|vDirB
)braket
comma
(paren
id|uint
)paren
id|via2
(braket
id|vACR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;         PCR = 0x%02X  IFR = 0x%02X IER = 0x%02X&bslash;n&quot;
comma
(paren
id|uint
)paren
id|via2
(braket
id|vPCR
)braket
comma
(paren
id|uint
)paren
id|via2
(braket
id|vIFR
)braket
comma
(paren
id|uint
)paren
id|via2
(braket
id|vIER
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is always executed with interrupts disabled.&n; *&n; * TBI: get time offset between scheduling timer ticks&n; */
DECL|function|mac_gettimeoffset
r_int
r_int
id|mac_gettimeoffset
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
comma
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* read VIA1 timer 2 current value */
id|ticks
op_assign
id|via1
(braket
id|vT1CL
)braket
op_or
(paren
id|via1
(braket
id|vT1CH
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* The probability of underflow is less than 2% */
r_if
c_cond
(paren
id|ticks
OG
id|MAC_CLOCK_TICK
op_minus
id|MAC_CLOCK_TICK
op_div
l_int|50
)paren
multiline_comment|/* Check for pending timer interrupt in VIA1 IFR */
r_if
c_cond
(paren
id|via1
(braket
id|vIFR
)braket
op_amp
l_int|0x40
)paren
id|offset
op_assign
id|TICK_SIZE
suffix:semicolon
id|ticks
op_assign
id|MAC_CLOCK_TICK
op_minus
id|ticks
suffix:semicolon
id|ticks
op_assign
id|ticks
op_star
l_int|10000L
op_div
id|MAC_CLOCK_TICK
suffix:semicolon
r_return
id|ticks
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush the L2 cache on Macs that have it by flipping&n; * the system into 24-bit mode for an instant.&n; */
DECL|function|via_flush_cache
r_void
id|via_flush_cache
c_func
(paren
r_void
)paren
(brace
id|via2
(braket
id|gBufB
)braket
op_and_assign
op_complement
id|VIA2B_vMode32
suffix:semicolon
id|via2
(braket
id|gBufB
)braket
op_or_assign
id|VIA2B_vMode32
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the status of the L2 cache on a IIci&n; */
DECL|function|via_get_cache_disable
r_int
id|via_get_cache_disable
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Safeguard against being called accidentally */
r_if
c_cond
(paren
op_logical_neg
id|via2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;via_get_cache_disable called on a non-VIA machine!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
(paren
r_int
)paren
id|via2
(braket
id|gBufB
)braket
op_amp
id|VIA2B_vCDis
suffix:semicolon
)brace
multiline_comment|/*&n; * VIA-based power switch, for machines that support it.&n; */
DECL|function|via_poweroff
r_void
id|via_poweroff
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
id|via2
(braket
id|rBufB
)braket
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Direction of vDirB is output */
id|via2
(braket
id|vDirB
)braket
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Send a value of 0 on that line */
id|via2
(braket
id|vBufB
)braket
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
multiline_comment|/* Otherwise it prints &quot;It is now..&quot; then shuts off */
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/* We should never make it this far... */
id|printk
(paren
l_string|&quot;It is now safe to switch off your machine.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Initialize VIA2 for Nubus access&n; */
DECL|function|via_nubus_init
r_void
id|__init
id|via_nubus_init
c_func
(paren
r_void
)paren
(brace
id|nubus_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unlock nubus transactions */
r_if
c_cond
(paren
op_logical_neg
id|rbv_present
)paren
(brace
multiline_comment|/* set the line to be an output on non-RBV machines */
id|via2
(braket
id|vDirB
)braket
op_or_assign
l_int|0x02
suffix:semicolon
)brace
id|via2
(braket
id|gBufB
)braket
op_or_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* disable nubus slot interrupts. */
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
id|via2
(braket
id|rSIER
)braket
op_assign
l_int|0x7F
suffix:semicolon
multiline_comment|/* like VIA; bit 7=clr,set */
)brace
r_else
(brace
id|via2
(braket
id|vBufA
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* active low irqs, force high */
id|via2
(braket
id|vDirA
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* ddr to output. */
)brace
)brace
multiline_comment|/*&n; * The generic VIA interrupt routines (shamelessly stolen from Alan Cox&squot;s&n; * via6522.c :-), disable/pending masks added.&n; *&n; * The new interrupt architecture in macints.c takes care of a lot of the&n; * gruntwork for us, including tallying the interrupts and calling the&n; * handlers on the linked list. All we need to do here is basically generate&n; * the machspec interrupt number after clearing the interrupt.&n; */
DECL|function|via1_irq
r_void
id|via1_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq_bit
comma
id|i
suffix:semicolon
r_int
r_char
id|events
comma
id|mask
suffix:semicolon
id|irq
op_sub_assign
id|VEC_SPUR
suffix:semicolon
id|mask
op_assign
id|via1
(braket
id|vIER
)braket
op_amp
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|events
op_assign
id|via1
(braket
id|vIFR
)braket
op_amp
id|mask
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|irq_bit
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
comma
id|irq_bit
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|events
op_amp
id|irq_bit
)paren
(brace
id|via1
(braket
id|vIER
)braket
op_assign
id|irq_bit
suffix:semicolon
id|mac_do_irq_list
c_func
(paren
id|VIA1_SOURCE_BASE
op_plus
id|i
comma
id|regs
)paren
suffix:semicolon
id|via1
(braket
id|vIFR
)braket
op_assign
id|irq_bit
suffix:semicolon
id|via1
(braket
id|vIER
)braket
op_assign
id|irq_bit
op_or
l_int|0x80
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|oss_present
)paren
(brace
multiline_comment|/* This (still) seems to be necessary to get IDE&n;&t;&t;   working.  However, if you enable VBL interrupts,&n;&t;&t;   you&squot;re screwed... */
multiline_comment|/* FIXME: should we check the SLOTIRQ bit before&n;                   pulling this stunt? */
multiline_comment|/* No, it won&squot;t be set. that&squot;s why we&squot;re doing this. */
id|via_irq_disable
c_func
(paren
id|IRQ_MAC_NUBUS
)paren
suffix:semicolon
id|via_irq_clear
c_func
(paren
id|IRQ_MAC_NUBUS
)paren
suffix:semicolon
id|mac_do_irq_list
c_func
(paren
id|IRQ_MAC_NUBUS
comma
id|regs
)paren
suffix:semicolon
id|via_irq_enable
c_func
(paren
id|IRQ_MAC_NUBUS
)paren
suffix:semicolon
)brace
)brace
DECL|function|via2_irq
r_void
id|via2_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq_bit
comma
id|i
suffix:semicolon
r_int
r_char
id|events
comma
id|mask
suffix:semicolon
id|irq
op_sub_assign
id|VEC_SPUR
suffix:semicolon
id|mask
op_assign
id|via2
(braket
id|gIER
)braket
op_amp
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|events
op_assign
id|via2
(braket
id|gIFR
)braket
op_amp
id|mask
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|irq_bit
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
comma
id|irq_bit
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|events
op_amp
id|irq_bit
)paren
(brace
id|via2
(braket
id|gIER
)braket
op_assign
id|irq_bit
suffix:semicolon
id|mac_do_irq_list
c_func
(paren
id|VIA2_SOURCE_BASE
op_plus
id|i
comma
id|regs
)paren
suffix:semicolon
id|via2
(braket
id|gIFR
)braket
op_assign
id|irq_bit
op_or
id|rbv_clear
suffix:semicolon
id|via2
(braket
id|gIER
)braket
op_assign
id|irq_bit
op_or
l_int|0x80
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Dispatch Nubus interrupts. We are called as a secondary dispatch by the&n; * VIA2 dispatcher as a fast interrupt handler.&n; */
DECL|function|via_nubus_irq
r_void
id|via_nubus_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq_bit
comma
id|i
suffix:semicolon
r_int
r_char
id|events
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|events
op_assign
op_complement
id|via2
(braket
id|gBufA
)braket
op_amp
id|nubus_active
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|irq_bit
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
comma
id|irq_bit
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|events
op_amp
id|irq_bit
)paren
(brace
id|via_irq_disable
c_func
(paren
id|NUBUS_SOURCE_BASE
op_plus
id|i
)paren
suffix:semicolon
id|mac_do_irq_list
c_func
(paren
id|NUBUS_SOURCE_BASE
op_plus
id|i
comma
id|regs
)paren
suffix:semicolon
id|via_irq_enable
c_func
(paren
id|NUBUS_SOURCE_BASE
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|via_irq_enable
r_void
id|via_irq_enable
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|irq_src
op_assign
id|IRQ_SRC
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_idx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_bit
op_assign
l_int|1
op_lshift
id|irq_idx
suffix:semicolon
macro_line|#ifdef DEBUG_IRQUSE
id|printk
c_func
(paren
l_string|&quot;via_irq_enable(%d)&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|1
)paren
(brace
id|via1
(braket
id|vIER
)braket
op_assign
id|irq_bit
op_or
l_int|0x80
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set vPCR for SCSI interrupts (but not on RBV)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|irq_idx
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|rbv_present
)paren
(brace
r_if
c_cond
(paren
id|macintosh_config-&gt;scsi_type
op_eq
id|MAC_SCSI_OLD
)paren
(brace
multiline_comment|/* CB2 (IRQ) indep. input, positive edge */
multiline_comment|/* CA2 (DRQ) indep. input, positive edge */
id|via2
(braket
id|vPCR
)braket
op_assign
l_int|0x66
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* CB2 (IRQ) indep. input, negative edge */
multiline_comment|/* CA2 (DRQ) indep. input, negative edge */
id|via2
(braket
id|vPCR
)braket
op_assign
l_int|0x22
suffix:semicolon
)brace
)brace
id|via2
(braket
id|gIER
)braket
op_assign
id|irq_bit
op_or
l_int|0x80
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
multiline_comment|/* enable the slot interrupt. SIER works like IER. */
id|via2
(braket
id|rSIER
)braket
op_assign
id|IER_SET_BIT
c_func
(paren
id|irq_idx
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Make sure the bit is an input, to enable the irq */
id|via2
(braket
id|vDirA
)braket
op_and_assign
op_complement
id|irq_bit
suffix:semicolon
)brace
id|nubus_active
op_or_assign
id|irq_bit
suffix:semicolon
)brace
)brace
DECL|function|via_irq_disable
r_void
id|via_irq_disable
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|irq_src
op_assign
id|IRQ_SRC
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_idx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_bit
op_assign
l_int|1
op_lshift
id|irq_idx
suffix:semicolon
macro_line|#ifdef DEBUG_IRQUSE
id|printk
c_func
(paren
l_string|&quot;via_irq_disable(%d)&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|1
)paren
(brace
id|via1
(braket
id|vIER
)braket
op_assign
id|irq_bit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|2
)paren
(brace
id|via2
(braket
id|gIER
)braket
op_assign
id|irq_bit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
multiline_comment|/* disable the slot interrupt.  SIER works like IER. */
id|via2
(braket
id|rSIER
)braket
op_assign
id|IER_CLR_BIT
c_func
(paren
id|irq_idx
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* disable the nubus irq by changing dir to output */
id|via2
(braket
id|vDirA
)braket
op_or_assign
id|irq_bit
suffix:semicolon
)brace
id|nubus_active
op_and_assign
op_complement
id|irq_bit
suffix:semicolon
)brace
)brace
DECL|function|via_irq_clear
r_void
id|via_irq_clear
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|irq_src
op_assign
id|IRQ_SRC
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_idx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_bit
op_assign
l_int|1
op_lshift
id|irq_idx
suffix:semicolon
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|1
)paren
(brace
id|via1
(braket
id|vIFR
)braket
op_assign
id|irq_bit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|2
)paren
(brace
id|via2
(braket
id|gIFR
)braket
op_assign
id|irq_bit
op_or
id|rbv_clear
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|7
)paren
(brace
multiline_comment|/* FIXME: hmm.. */
)brace
)brace
multiline_comment|/*&n; * Returns nonzero if an interrupt is pending on the given&n; * VIA/IRQ combination.&n; */
DECL|function|via_irq_pending
r_int
id|via_irq_pending
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|irq_src
op_assign
id|IRQ_SRC
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_idx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
id|irq_bit
op_assign
l_int|1
op_lshift
id|irq_idx
suffix:semicolon
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|1
)paren
(brace
r_return
id|via1
(braket
id|vIFR
)braket
op_amp
id|irq_bit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|2
)paren
(brace
r_return
id|via2
(braket
id|gIFR
)braket
op_amp
id|irq_bit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_src
op_eq
l_int|7
)paren
(brace
r_return
op_complement
id|via2
(braket
id|gBufA
)braket
op_amp
id|irq_bit
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|via_scsi_clear
r_void
id|via_scsi_clear
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_char
id|deep_magic
suffix:semicolon
macro_line|#ifdef DEBUG_IRQUSE
id|printk
c_func
(paren
l_string|&quot;via_scsi_clear()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We handle this in oss.c , but this gets called in mac_scsinew.c */
r_if
c_cond
(paren
id|oss_present
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
id|via2
(braket
id|rIFR
)braket
op_assign
(paren
l_int|1
op_lshift
l_int|3
)paren
op_or
(paren
l_int|1
op_lshift
l_int|0
)paren
op_or
id|rbv_clear
suffix:semicolon
id|deep_magic
op_assign
id|via2
(braket
id|rBufB
)braket
suffix:semicolon
)brace
r_else
(brace
id|deep_magic
op_assign
id|via2
(braket
id|vBufB
)braket
suffix:semicolon
)brace
id|mac_enable_irq
c_func
(paren
id|IRQ_MAC_SCSI
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PRAM/RTC access routines&n; *&n; * Must be called with interrupts disabled and&n; * the RTC should be enabled.&n; */
DECL|function|via_pram_readbyte
r_static
id|__u8
id|via_pram_readbyte
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|reg
suffix:semicolon
id|__u8
id|data
suffix:semicolon
id|reg
op_assign
id|via1
(braket
id|vBufB
)braket
op_amp
op_complement
id|VIA1B_vRTCClk
suffix:semicolon
multiline_comment|/* Set the RTC data line to be an input. */
id|via1
(braket
id|vDirB
)braket
op_and_assign
op_complement
id|VIA1B_vRTCData
suffix:semicolon
multiline_comment|/* The bits of the byte come out in MSB order */
id|data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
op_or
id|VIA1B_vRTCClk
suffix:semicolon
id|data
op_assign
(paren
id|data
op_lshift
l_int|1
)paren
op_or
(paren
id|via1
(braket
id|vBufB
)braket
op_amp
id|VIA1B_vRTCData
)paren
suffix:semicolon
)brace
multiline_comment|/* Return RTC data line to output state */
id|via1
(braket
id|vDirB
)braket
op_or_assign
id|VIA1B_vRTCData
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|via_pram_writebyte
r_static
r_void
id|via_pram_writebyte
c_func
(paren
id|__u8
id|data
)paren
(brace
r_int
id|i
comma
id|reg
comma
id|bit
suffix:semicolon
id|reg
op_assign
id|via1
(braket
id|vBufB
)braket
op_amp
op_complement
(paren
id|VIA1B_vRTCClk
op_or
id|VIA1B_vRTCData
)paren
suffix:semicolon
multiline_comment|/* The bits of the byte go in in MSB order */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bit
op_assign
id|data
op_amp
l_int|0x80
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|data
op_lshift_assign
l_int|1
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
op_or
id|bit
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
op_or
id|bit
op_or
id|VIA1B_vRTCClk
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Execute a PRAM/RTC command. For read commands&n; * data should point to a one-byte buffer for the&n; * resulting data. For write commands it should point&n; * to the data byte to for the command.&n; *&n; * This function disables all interrupts while running.&n; */
DECL|function|via_pram_command
r_void
id|via_pram_command
c_func
(paren
r_int
id|command
comma
id|__u8
op_star
id|data
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
r_int
id|is_read
suffix:semicolon
id|save_flags
c_func
(paren
id|cpu_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Enable the RTC and make sure the strobe line is high */
id|via1
(braket
id|vBufB
)braket
op_assign
(paren
id|via1
(braket
id|vBufB
)braket
op_or
id|VIA1B_vRTCClk
)paren
op_amp
op_complement
id|VIA1B_vRTCEnb
suffix:semicolon
r_if
c_cond
(paren
id|command
op_amp
l_int|0xFF00
)paren
(brace
multiline_comment|/* extended (two-byte) command */
id|via_pram_writebyte
c_func
(paren
(paren
id|command
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|via_pram_writebyte
c_func
(paren
id|command
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|is_read
op_assign
id|command
op_amp
l_int|0x8000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one-byte command */
id|via_pram_writebyte
c_func
(paren
id|command
)paren
suffix:semicolon
id|is_read
op_assign
id|command
op_amp
l_int|0x80
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_read
)paren
(brace
op_star
id|data
op_assign
id|via_pram_readbyte
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|via_pram_writebyte
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/* All done, disable the RTC */
id|via1
(braket
id|vBufB
)braket
op_or_assign
id|VIA1B_vRTCEnb
suffix:semicolon
id|restore_flags
c_func
(paren
id|cpu_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the current time in seconds since January 1, 1904.&n; *&n; * This only works on machines with the VIA-based PRAM/RTC, which&n; * is basically any machine with Mac II-style ADB.&n; */
DECL|function|via_read_time
id|__u32
id|via_read_time
c_func
(paren
r_void
)paren
(brace
r_union
(brace
id|__u8
id|cdata
(braket
l_int|4
)braket
suffix:semicolon
id|__u32
id|idata
suffix:semicolon
)brace
id|result
comma
id|last_result
suffix:semicolon
r_int
id|ct
suffix:semicolon
multiline_comment|/*&n;&t; * The NetBSD guys say to loop until you get the same reading&n;&t; * twice in a row.&n;&t; */
id|ct
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_increment
id|ct
OG
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;via_read_time: couldn&squot;t get valid time, &quot;
l_string|&quot;last read = 0x%08X and 0x%08X&bslash;n&quot;
comma
id|last_result.idata
comma
id|result.idata
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|last_result.idata
op_assign
id|result.idata
suffix:semicolon
id|result.idata
op_assign
l_int|0
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x81
comma
op_amp
id|result.cdata
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x85
comma
op_amp
id|result.cdata
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x89
comma
op_amp
id|result.cdata
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x8D
comma
op_amp
id|result.cdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result.idata
op_ne
id|last_result.idata
)paren
suffix:semicolon
r_return
id|result.idata
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the current time to a number of seconds since January 1, 1904.&n; *&n; * This only works on machines with the VIA-based PRAM/RTC, which&n; * is basically any machine with Mac II-style ADB.&n; */
DECL|function|via_write_time
r_void
id|via_write_time
c_func
(paren
id|__u32
id|time
)paren
(brace
r_union
(brace
id|__u8
id|cdata
(braket
l_int|4
)braket
suffix:semicolon
id|__u32
id|idata
suffix:semicolon
)brace
id|data
suffix:semicolon
id|__u8
id|temp
suffix:semicolon
multiline_comment|/* Clear the write protect bit */
id|temp
op_assign
l_int|0x55
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x35
comma
op_amp
id|temp
)paren
suffix:semicolon
id|data.idata
op_assign
id|time
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x01
comma
op_amp
id|data.cdata
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x05
comma
op_amp
id|data.cdata
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x09
comma
op_amp
id|data.cdata
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x0D
comma
op_amp
id|data.cdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Set the write protect bit */
id|temp
op_assign
l_int|0xD5
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x35
comma
op_amp
id|temp
)paren
suffix:semicolon
)brace
eof
