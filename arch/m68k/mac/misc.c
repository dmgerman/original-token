multiline_comment|/*&n; * Miscellaneous Mac68K-specific stuff &n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;linux/cuda.h&gt;
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;asm/mac_via.h&gt;
macro_line|#include &lt;asm/mac_oss.h&gt;
DECL|macro|BOOTINFO_COMPAT_1_0
mdefine_line|#define BOOTINFO_COMPAT_1_0
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
multiline_comment|/* Offset between Unix time (1970-based) and Mac time (1904-based) */
DECL|macro|RTC_OFFSET
mdefine_line|#define RTC_OFFSET 2082844800
r_extern
r_struct
id|mac_booter_data
id|mac_bi_data
suffix:semicolon
DECL|variable|rom_reset
r_static
r_void
(paren
op_star
id|rom_reset
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Return the current time as the number of seconds since January 1, 1904.&n; */
DECL|function|adb_read_time
r_static
r_int
id|adb_read_time
c_func
(paren
r_void
)paren
(brace
r_volatile
r_struct
id|adb_request
id|req
suffix:semicolon
r_int
id|time
suffix:semicolon
id|adb_request
c_func
(paren
(paren
r_struct
id|adb_request
op_star
)paren
op_amp
id|req
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|2
comma
id|CUDA_PACKET
comma
id|CUDA_GET_TIME
)paren
suffix:semicolon
id|time
op_assign
(paren
id|req.reply
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|req.reply
(braket
l_int|4
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|req.reply
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|req.reply
(braket
l_int|6
)braket
suffix:semicolon
r_return
id|time
op_minus
id|RTC_OFFSET
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the current system time&n; */
DECL|function|adb_write_time
r_static
r_void
id|adb_write_time
c_func
(paren
r_int
id|data
)paren
(brace
r_volatile
r_struct
id|adb_request
id|req
suffix:semicolon
id|data
op_add_assign
id|RTC_OFFSET
suffix:semicolon
id|adb_request
c_func
(paren
(paren
r_struct
id|adb_request
op_star
)paren
op_amp
id|req
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|6
comma
id|CUDA_PACKET
comma
id|CUDA_SET_TIME
comma
(paren
id|data
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
comma
(paren
id|data
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
comma
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|data
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a byte from the NVRAM&n; */
DECL|function|adb_read_pram
r_static
id|__u8
id|adb_read_pram
c_func
(paren
r_int
id|offset
)paren
(brace
r_volatile
r_struct
id|adb_request
id|req
suffix:semicolon
id|adb_request
c_func
(paren
(paren
r_struct
id|adb_request
op_star
)paren
op_amp
id|req
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|4
comma
id|CUDA_PACKET
comma
id|CUDA_GET_PRAM
comma
(paren
id|offset
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|offset
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_return
id|req.reply
(braket
l_int|3
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a byte to the NVRAM&n; */
DECL|function|adb_write_pram
r_static
r_void
id|adb_write_pram
c_func
(paren
r_int
id|offset
comma
id|__u8
id|data
)paren
(brace
r_volatile
r_struct
id|adb_request
id|req
suffix:semicolon
id|adb_request
c_func
(paren
(paren
r_struct
id|adb_request
op_star
)paren
op_amp
id|req
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|5
comma
id|CUDA_PACKET
comma
id|CUDA_SET_PRAM
comma
(paren
id|offset
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|offset
op_amp
l_int|0xFF
comma
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * VIA PRAM/RTC access routines&n; *&n; * Must be called with interrupts disabled and&n; * the RTC should be enabled.&n; */
DECL|function|via_pram_readbyte
r_static
id|__u8
id|via_pram_readbyte
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|reg
suffix:semicolon
id|__u8
id|data
suffix:semicolon
id|reg
op_assign
id|via1
(braket
id|vBufB
)braket
op_amp
op_complement
id|VIA1B_vRTCClk
suffix:semicolon
multiline_comment|/* Set the RTC data line to be an input. */
id|via1
(braket
id|vDirB
)braket
op_and_assign
op_complement
id|VIA1B_vRTCData
suffix:semicolon
multiline_comment|/* The bits of the byte come out in MSB order */
id|data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
op_or
id|VIA1B_vRTCClk
suffix:semicolon
id|data
op_assign
(paren
id|data
op_lshift
l_int|1
)paren
op_or
(paren
id|via1
(braket
id|vBufB
)braket
op_amp
id|VIA1B_vRTCData
)paren
suffix:semicolon
)brace
multiline_comment|/* Return RTC data line to output state */
id|via1
(braket
id|vDirB
)braket
op_or_assign
id|VIA1B_vRTCData
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|via_pram_writebyte
r_static
r_void
id|via_pram_writebyte
c_func
(paren
id|__u8
id|data
)paren
(brace
r_int
id|i
comma
id|reg
comma
id|bit
suffix:semicolon
id|reg
op_assign
id|via1
(braket
id|vBufB
)braket
op_amp
op_complement
(paren
id|VIA1B_vRTCClk
op_or
id|VIA1B_vRTCData
)paren
suffix:semicolon
multiline_comment|/* The bits of the byte go in in MSB order */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bit
op_assign
id|data
op_amp
l_int|0x80
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|data
op_lshift_assign
l_int|1
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
op_or
id|bit
suffix:semicolon
id|via1
(braket
id|vBufB
)braket
op_assign
id|reg
op_or
id|bit
op_or
id|VIA1B_vRTCClk
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Execute a VIA PRAM/RTC command. For read commands&n; * data should point to a one-byte buffer for the&n; * resulting data. For write commands it should point&n; * to the data byte to for the command.&n; *&n; * This function disables all interrupts while running.&n; */
DECL|function|via_pram_command
r_static
r_void
id|via_pram_command
c_func
(paren
r_int
id|command
comma
id|__u8
op_star
id|data
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
r_int
id|is_read
suffix:semicolon
id|save_flags
c_func
(paren
id|cpu_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Enable the RTC and make sure the strobe line is high */
id|via1
(braket
id|vBufB
)braket
op_assign
(paren
id|via1
(braket
id|vBufB
)braket
op_or
id|VIA1B_vRTCClk
)paren
op_amp
op_complement
id|VIA1B_vRTCEnb
suffix:semicolon
r_if
c_cond
(paren
id|command
op_amp
l_int|0xFF00
)paren
(brace
multiline_comment|/* extended (two-byte) command */
id|via_pram_writebyte
c_func
(paren
(paren
id|command
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|via_pram_writebyte
c_func
(paren
id|command
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|is_read
op_assign
id|command
op_amp
l_int|0x8000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one-byte command */
id|via_pram_writebyte
c_func
(paren
id|command
)paren
suffix:semicolon
id|is_read
op_assign
id|command
op_amp
l_int|0x80
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_read
)paren
(brace
op_star
id|data
op_assign
id|via_pram_readbyte
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|via_pram_writebyte
c_func
(paren
op_star
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/* All done, disable the RTC */
id|via1
(braket
id|vBufB
)braket
op_or_assign
id|VIA1B_vRTCEnb
suffix:semicolon
id|restore_flags
c_func
(paren
id|cpu_flags
)paren
suffix:semicolon
)brace
DECL|function|via_read_pram
r_static
id|__u8
id|via_read_pram
c_func
(paren
r_int
id|offset
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|via_write_pram
r_static
r_void
id|via_write_pram
c_func
(paren
r_int
id|offset
comma
id|__u8
id|data
)paren
(brace
)brace
multiline_comment|/*&n; * Return the current time in seconds since January 1, 1904.&n; *&n; * This only works on machines with the VIA-based PRAM/RTC, which&n; * is basically any machine with Mac II-style ADB.&n; */
DECL|function|via_read_time
r_static
r_int
id|via_read_time
c_func
(paren
r_void
)paren
(brace
r_union
(brace
id|__u8
id|cdata
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|idata
suffix:semicolon
)brace
id|result
comma
id|last_result
suffix:semicolon
r_int
id|ct
suffix:semicolon
multiline_comment|/*&n;&t; * The NetBSD guys say to loop until you get the same reading&n;&t; * twice in a row.&n;&t; */
id|ct
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_increment
id|ct
OG
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;via_read_time: couldn&squot;t get valid time, &quot;
l_string|&quot;last read = 0x%08X and 0x%08X&bslash;n&quot;
comma
id|last_result.idata
comma
id|result.idata
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|last_result.idata
op_assign
id|result.idata
suffix:semicolon
id|result.idata
op_assign
l_int|0
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x81
comma
op_amp
id|result.cdata
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x85
comma
op_amp
id|result.cdata
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x89
comma
op_amp
id|result.cdata
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x8D
comma
op_amp
id|result.cdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result.idata
op_ne
id|last_result.idata
)paren
suffix:semicolon
r_return
id|result.idata
op_minus
id|RTC_OFFSET
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the current time to a number of seconds since January 1, 1904.&n; *&n; * This only works on machines with the VIA-based PRAM/RTC, which&n; * is basically any machine with Mac II-style ADB.&n; */
DECL|function|via_write_time
r_static
r_void
id|via_write_time
c_func
(paren
r_int
id|time
)paren
(brace
r_union
(brace
id|__u8
id|cdata
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|idata
suffix:semicolon
)brace
id|data
suffix:semicolon
id|__u8
id|temp
suffix:semicolon
multiline_comment|/* Clear the write protect bit */
id|temp
op_assign
l_int|0x55
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x35
comma
op_amp
id|temp
)paren
suffix:semicolon
id|data.idata
op_assign
id|time
op_plus
id|RTC_OFFSET
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x01
comma
op_amp
id|data.cdata
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x05
comma
op_amp
id|data.cdata
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x09
comma
op_amp
id|data.cdata
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x0D
comma
op_amp
id|data.cdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Set the write protect bit */
id|temp
op_assign
l_int|0xD5
suffix:semicolon
id|via_pram_command
c_func
(paren
l_int|0x35
comma
op_amp
id|temp
)paren
suffix:semicolon
)brace
DECL|function|via_shutdown
r_static
r_void
id|via_shutdown
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rbv_present
)paren
(brace
id|via2
(braket
id|rBufB
)braket
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Direction of vDirB is output */
id|via2
(braket
id|vDirB
)braket
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Send a value of 0 on that line */
id|via2
(braket
id|vBufB
)braket
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * FIXME: not sure how this is supposed to work exactly...&n; */
DECL|function|oss_shutdown
r_static
r_void
id|oss_shutdown
c_func
(paren
r_void
)paren
(brace
id|oss-&gt;rom_ctrl
op_assign
id|OSS_POWEROFF
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ADB_CUDA
DECL|function|cuda_restart
r_static
r_void
id|cuda_restart
c_func
(paren
r_void
)paren
(brace
id|adb_request
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|2
comma
id|CUDA_PACKET
comma
id|CUDA_RESET_SYSTEM
)paren
suffix:semicolon
)brace
DECL|function|cuda_shutdown
r_static
r_void
id|cuda_shutdown
c_func
(paren
r_void
)paren
(brace
id|adb_request
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|2
comma
id|CUDA_PACKET
comma
id|CUDA_POWERDOWN
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ADB_CUDA */
macro_line|#ifdef CONFIG_ADB_PMU
DECL|function|pmu_restart
r_void
id|pmu_restart
c_func
(paren
r_void
)paren
(brace
id|adb_request
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|3
comma
id|PMU_PACKET
comma
id|PMU_SET_INTR_MASK
comma
id|PMU_INT_ADB
op_or
id|PMU_INT_TICK
)paren
suffix:semicolon
id|adb_request
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|2
comma
id|PMU_PACKET
comma
id|PMU_RESET
)paren
suffix:semicolon
)brace
DECL|function|pmu_shutdown
r_void
id|pmu_shutdown
c_func
(paren
r_void
)paren
(brace
id|adb_request
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|3
comma
id|PMU_PACKET
comma
id|PMU_SET_INTR_MASK
comma
id|PMU_INT_ADB
op_or
id|PMU_INT_TICK
)paren
suffix:semicolon
id|adb_request
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|ADBREQ_RAW
op_or
id|ADBREQ_SYNC
comma
l_int|6
comma
id|PMU_PACKET
comma
id|PMU_SHUTDOWN
comma
l_char|&squot;M&squot;
comma
l_char|&squot;A&squot;
comma
l_char|&squot;T&squot;
comma
l_char|&squot;T&squot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ADB_PMU */
multiline_comment|/*&n; *-------------------------------------------------------------------&n; * Below this point are the generic routines; they&squot;ll dispatch to the&n; * correct routine for the hardware on which we&squot;re running.&n; *-------------------------------------------------------------------&n; */
DECL|function|mac_pram_read
r_void
id|mac_pram_read
c_func
(paren
r_int
id|offset
comma
id|__u8
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
id|__u8
(paren
op_star
id|func
)paren
(paren
r_int
)paren
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB1
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB2
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|func
op_assign
id|adb_read_pram
suffix:semicolon
)brace
r_else
(brace
id|func
op_assign
id|via_read_pram
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buffer
(braket
id|i
)braket
op_assign
(paren
op_star
id|func
)paren
(paren
id|offset
op_increment
)paren
suffix:semicolon
)brace
)brace
DECL|function|mac_pram_write
r_void
id|mac_pram_write
c_func
(paren
r_int
id|offset
comma
id|__u8
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_void
(paren
op_star
id|func
)paren
(paren
r_int
comma
id|__u8
)paren
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB1
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB2
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|func
op_assign
id|adb_write_pram
suffix:semicolon
)brace
r_else
(brace
id|func
op_assign
id|via_write_pram
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
op_star
id|func
)paren
(paren
id|offset
op_increment
comma
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|mac_poweroff
r_void
id|mac_poweroff
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * MAC_ADB_IISI may need to be moved up here if it doesn&squot;t actually&n;&t; * work using the ADB packet method.  --David Kilzer&n;&t; */
r_if
c_cond
(paren
id|oss_present
)paren
(brace
id|oss_shutdown
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
id|via_shutdown
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ADB_CUDA
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|cuda_shutdown
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ADB_PMU
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB1
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB2
)paren
(brace
id|pmu_shutdown
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;It is now safe to turn off your Macintosh.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|mac_reset
r_void
id|mac_reset
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
r_int
r_int
id|cpu_flags
suffix:semicolon
multiline_comment|/* need ROMBASE in booter */
multiline_comment|/* indeed, plus need to MAP THE ROM !! */
r_if
c_cond
(paren
id|mac_bi_data.rombase
op_eq
l_int|0
)paren
id|mac_bi_data.rombase
op_assign
l_int|0x40800000
suffix:semicolon
multiline_comment|/* works on some */
id|rom_reset
op_assign
(paren
r_void
op_star
)paren
(paren
id|mac_bi_data.rombase
op_plus
l_int|0xa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_SE30
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * MSch: Machines known to crash on ROM reset ...&n;&t;&t;&t; */
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|cpu_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|rom_reset
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|cpu_flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ADB_CUDA
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
(brace
id|cuda_restart
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ADB_PMU
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB1
op_logical_or
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB2
)paren
(brace
id|pmu_restart
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|CPU_IS_030
)paren
(brace
multiline_comment|/* 030-specific reset routine.  The idea is general, but the&n;&t;&t; * specific registers to reset are &squot;030-specific.  Until I&n;&t;&t; * have a non-030 machine, I can&squot;t test anything else.&n;&t;&t; *  -- C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;&n;&t;&t; */
r_int
r_int
id|rombase
op_assign
l_int|0x40000000
suffix:semicolon
multiline_comment|/* make a 1-to-1 mapping, using the transparent tran. reg. */
r_int
r_int
id|virt
op_assign
(paren
r_int
r_int
)paren
id|mac_reset
suffix:semicolon
r_int
r_int
id|phys
op_assign
id|virt_to_phys
c_func
(paren
id|mac_reset
)paren
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|phys
op_minus
id|virt
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* lets not screw this up, ok? */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.chip 68030&bslash;n&bslash;t&quot;
l_string|&quot;pmove %0,%/tt0&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
(paren
id|phys
op_amp
l_int|0xFF000000
)paren
op_or
l_int|0x8777
)paren
)paren
suffix:semicolon
multiline_comment|/* Now jump to physical address so we can disable MMU */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.chip 68030&bslash;n&bslash;t&quot;
l_string|&quot;lea %/pc@(1f),%/a0&bslash;n&bslash;t&quot;
l_string|&quot;addl %0,%/a0&bslash;n&bslash;t&quot;
multiline_comment|/* fixup target address and stack ptr */
l_string|&quot;addl %0,%/sp&bslash;n&bslash;t&quot;
l_string|&quot;pflusha&bslash;n&bslash;t&quot;
l_string|&quot;jmp %/a0@&bslash;n&bslash;t&quot;
multiline_comment|/* jump into physical memory */
l_string|&quot;0:.long 0&bslash;n&bslash;t&quot;
multiline_comment|/* a constant zero. */
multiline_comment|/* OK.  Now reset everything and jump to reset vector. */
l_string|&quot;1:&bslash;n&bslash;t&quot;
l_string|&quot;lea %/pc@(0b),%/a0&bslash;n&bslash;t&quot;
l_string|&quot;pmove %/a0@, %/tc&bslash;n&bslash;t&quot;
multiline_comment|/* disable mmu */
l_string|&quot;pmove %/a0@, %/tt0&bslash;n&bslash;t&quot;
multiline_comment|/* disable tt0 */
l_string|&quot;pmove %/a0@, %/tt1&bslash;n&bslash;t&quot;
multiline_comment|/* disable tt1 */
l_string|&quot;movel #0, %/a0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/a0, %/vbr&bslash;n&bslash;t&quot;
multiline_comment|/* clear vector base register */
l_string|&quot;movec %/a0, %/cacr&bslash;n&bslash;t&quot;
multiline_comment|/* disable caches */
l_string|&quot;movel #0x0808,%/a0&bslash;n&bslash;t&quot;
l_string|&quot;movec %/a0, %/cacr&bslash;n&bslash;t&quot;
multiline_comment|/* flush i&amp;d caches */
l_string|&quot;movew #0x2700,%/sr&bslash;n&bslash;t&quot;
multiline_comment|/* set up status register */
l_string|&quot;movel %1@(0x0),%/a0&bslash;n&bslash;t&quot;
multiline_comment|/* load interrupt stack pointer */
l_string|&quot;movec %/a0, %/isp&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@(0x4),%/a0&bslash;n&bslash;t&quot;
multiline_comment|/* load reset vector */
l_string|&quot;reset&bslash;n&bslash;t&quot;
multiline_comment|/* reset external devices */
l_string|&quot;jmp %/a0@&bslash;n&bslash;t&quot;
multiline_comment|/* jump to the reset vector */
l_string|&quot;.chip 68k&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|offset
)paren
comma
l_string|&quot;a&quot;
(paren
id|rombase
)paren
suffix:colon
l_string|&quot;a0&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* should never get here */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Restart failed.  Please restart manually.&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function translates seconds since 1970 into a proper date.&n; *&n; * Algorithm cribbed from glibc2.1, __offtime().&n; */
DECL|macro|SECS_PER_MINUTE
mdefine_line|#define SECS_PER_MINUTE (60)
DECL|macro|SECS_PER_HOUR
mdefine_line|#define SECS_PER_HOUR  (SECS_PER_MINUTE * 60)
DECL|macro|SECS_PER_DAY
mdefine_line|#define SECS_PER_DAY   (SECS_PER_HOUR * 24)
DECL|function|unmktime
r_static
r_void
id|unmktime
c_func
(paren
r_int
r_int
id|time
comma
r_int
id|offset
comma
r_int
op_star
id|yearp
comma
r_int
op_star
id|monp
comma
r_int
op_star
id|dayp
comma
r_int
op_star
id|hourp
comma
r_int
op_star
id|minp
comma
r_int
op_star
id|secp
)paren
(brace
multiline_comment|/* How many days come before each month (0-12).  */
r_static
r_const
r_int
r_int
r_int
id|__mon_yday
(braket
l_int|2
)braket
(braket
l_int|13
)braket
op_assign
(brace
multiline_comment|/* Normal years.  */
(brace
l_int|0
comma
l_int|31
comma
l_int|59
comma
l_int|90
comma
l_int|120
comma
l_int|151
comma
l_int|181
comma
l_int|212
comma
l_int|243
comma
l_int|273
comma
l_int|304
comma
l_int|334
comma
l_int|365
)brace
comma
multiline_comment|/* Leap years.  */
(brace
l_int|0
comma
l_int|31
comma
l_int|60
comma
l_int|91
comma
l_int|121
comma
l_int|152
comma
l_int|182
comma
l_int|213
comma
l_int|244
comma
l_int|274
comma
l_int|305
comma
l_int|335
comma
l_int|366
)brace
)brace
suffix:semicolon
r_int
r_int
id|days
comma
id|rem
comma
id|y
comma
id|wday
comma
id|yday
suffix:semicolon
r_const
r_int
r_int
r_int
op_star
id|ip
suffix:semicolon
id|days
op_assign
id|time
op_div
id|SECS_PER_DAY
suffix:semicolon
id|rem
op_assign
id|time
op_mod
id|SECS_PER_DAY
suffix:semicolon
id|rem
op_add_assign
id|offset
suffix:semicolon
r_while
c_loop
(paren
id|rem
OL
l_int|0
)paren
(brace
id|rem
op_add_assign
id|SECS_PER_DAY
suffix:semicolon
op_decrement
id|days
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rem
op_ge
id|SECS_PER_DAY
)paren
(brace
id|rem
op_sub_assign
id|SECS_PER_DAY
suffix:semicolon
op_increment
id|days
suffix:semicolon
)brace
op_star
id|hourp
op_assign
id|rem
op_div
id|SECS_PER_HOUR
suffix:semicolon
id|rem
op_mod_assign
id|SECS_PER_HOUR
suffix:semicolon
op_star
id|minp
op_assign
id|rem
op_div
id|SECS_PER_MINUTE
suffix:semicolon
op_star
id|secp
op_assign
id|rem
op_mod
id|SECS_PER_MINUTE
suffix:semicolon
multiline_comment|/* January 1, 1970 was a Thursday. */
id|wday
op_assign
(paren
l_int|4
op_plus
id|days
)paren
op_mod
l_int|7
suffix:semicolon
multiline_comment|/* Day in the week. Not currently used */
r_if
c_cond
(paren
id|wday
OL
l_int|0
)paren
id|wday
op_add_assign
l_int|7
suffix:semicolon
id|y
op_assign
l_int|1970
suffix:semicolon
DECL|macro|DIV
mdefine_line|#define DIV(a, b) ((a) / (b) - ((a) % (b) &lt; 0))
DECL|macro|LEAPS_THRU_END_OF
mdefine_line|#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))
DECL|macro|__isleap
mdefine_line|#define __isleap(year)&t;&bslash;&n;  ((year) % 4 == 0 &amp;&amp; ((year) % 100 != 0 || (year) % 400 == 0))
r_while
c_loop
(paren
id|days
OL
l_int|0
op_logical_or
id|days
op_ge
(paren
id|__isleap
(paren
id|y
)paren
ques
c_cond
l_int|366
suffix:colon
l_int|365
)paren
)paren
(brace
multiline_comment|/* Guess a corrected year, assuming 365 days per year.  */
r_int
r_int
id|yg
op_assign
id|y
op_plus
id|days
op_div
l_int|365
op_minus
(paren
id|days
op_mod
l_int|365
OL
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Adjust DAYS and Y to match the guessed year.  */
id|days
op_sub_assign
(paren
(paren
id|yg
op_minus
id|y
)paren
op_star
l_int|365
op_plus
id|LEAPS_THRU_END_OF
(paren
id|yg
op_minus
l_int|1
)paren
op_minus
id|LEAPS_THRU_END_OF
(paren
id|y
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|y
op_assign
id|yg
suffix:semicolon
)brace
op_star
id|yearp
op_assign
id|y
op_minus
l_int|1900
suffix:semicolon
id|yday
op_assign
id|days
suffix:semicolon
multiline_comment|/* day in the year.  Not currently used. */
id|ip
op_assign
id|__mon_yday
(braket
id|__isleap
c_func
(paren
id|y
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|y
op_assign
l_int|11
suffix:semicolon
id|days
OL
(paren
r_int
r_int
)paren
id|ip
(braket
id|y
)braket
suffix:semicolon
op_decrement
id|y
)paren
r_continue
suffix:semicolon
id|days
op_sub_assign
id|ip
(braket
id|y
)braket
suffix:semicolon
op_star
id|monp
op_assign
id|y
suffix:semicolon
op_star
id|dayp
op_assign
id|days
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* day in the month */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the boot time for use in initializing the kernel clock.&n; *&n; * I&squot;d like to read the hardware clock here but many machines read&n; * the PRAM through ADB, and interrupts aren&squot;t initialized when this&n; * is called so ADB obviously won&squot;t work.&n; */
DECL|function|mac_gettod
r_void
id|mac_gettod
c_func
(paren
r_int
op_star
id|yearp
comma
r_int
op_star
id|monp
comma
r_int
op_star
id|dayp
comma
r_int
op_star
id|hourp
comma
r_int
op_star
id|minp
comma
r_int
op_star
id|secp
)paren
(brace
multiline_comment|/* Yes the GMT bias is backwards.  It looks like Penguin is&n;           screwing up the boottime it gives us... This works for me&n;           in Canada/Eastern but it might be wrong everywhere else. */
id|unmktime
c_func
(paren
id|mac_bi_data.boottime
comma
op_minus
id|mac_bi_data.gmtbias
op_star
l_int|60
comma
id|yearp
comma
id|monp
comma
id|dayp
comma
id|hourp
comma
id|minp
comma
id|secp
)paren
suffix:semicolon
multiline_comment|/* For some reason this is off by one */
op_star
id|monp
op_assign
op_star
id|monp
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * Read/write the hardware clock.&n; */
DECL|function|mac_hwclk
r_int
id|mac_hwclk
c_func
(paren
r_int
id|op
comma
r_struct
id|hwclk_time
op_star
id|t
)paren
(brace
r_int
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* read */
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
id|now
op_assign
id|via_read_time
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
op_logical_or
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB1
)paren
op_logical_or
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB2
)paren
op_logical_or
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
)paren
(brace
id|now
op_assign
id|adb_read_time
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IOP
)paren
(brace
id|now
op_assign
id|via_read_time
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|now
op_assign
l_int|0
suffix:semicolon
)brace
id|t-&gt;wday
op_assign
l_int|0
suffix:semicolon
id|unmktime
c_func
(paren
id|now
comma
l_int|0
comma
op_amp
id|t-&gt;year
comma
op_amp
id|t-&gt;mon
comma
op_amp
id|t-&gt;day
comma
op_amp
id|t-&gt;hour
comma
op_amp
id|t-&gt;min
comma
op_amp
id|t-&gt;sec
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mac_hwclk: read %04d-%02d-%-2d %02d:%02d:%02d&bslash;n&quot;
comma
id|t-&gt;year
op_plus
l_int|1900
comma
id|t-&gt;mon
op_plus
l_int|1
comma
id|t-&gt;day
comma
id|t-&gt;hour
comma
id|t-&gt;min
comma
id|t-&gt;sec
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* write */
id|printk
c_func
(paren
l_string|&quot;mac_hwclk: tried to write %04d-%02d-%-2d %02d:%02d:%02d&bslash;n&quot;
comma
id|t-&gt;year
op_plus
l_int|1900
comma
id|t-&gt;mon
op_plus
l_int|1
comma
id|t-&gt;day
comma
id|t-&gt;hour
comma
id|t-&gt;min
comma
id|t-&gt;sec
)paren
suffix:semicolon
macro_line|#if 0&t;/* it trashes my rtc */
id|now
op_assign
id|mktime
c_func
(paren
id|t-&gt;year
op_plus
l_int|1900
comma
id|t-&gt;mon
op_plus
l_int|1
comma
id|t-&gt;day
comma
id|t-&gt;hour
comma
id|t-&gt;min
comma
id|t-&gt;sec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_II
)paren
(brace
id|via_write_time
c_func
(paren
id|now
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IISI
)paren
op_logical_or
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB1
)paren
op_logical_or
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_PB2
)paren
op_logical_or
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_CUDA
)paren
)paren
(brace
id|adb_write_time
c_func
(paren
id|now
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|macintosh_config-&gt;adb_type
op_eq
id|MAC_ADB_IOP
)paren
(brace
id|via_write_time
c_func
(paren
id|now
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Set minutes/seconds in the hardware clock&n; */
DECL|function|mac_set_clock_mmss
r_int
id|mac_set_clock_mmss
(paren
r_int
r_int
id|nowtime
)paren
(brace
r_struct
id|hwclk_time
id|now
suffix:semicolon
id|mac_hwclk
c_func
(paren
l_int|0
comma
op_amp
id|now
)paren
suffix:semicolon
id|now.sec
op_assign
id|nowtime
op_mod
l_int|60
suffix:semicolon
id|now.min
op_assign
(paren
id|nowtime
op_div
l_int|60
)paren
op_mod
l_int|60
suffix:semicolon
id|mac_hwclk
c_func
(paren
l_int|1
comma
op_amp
id|now
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
