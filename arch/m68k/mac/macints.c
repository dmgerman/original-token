multiline_comment|/*&n; *&t;Macintosh interrupts&n; *&n; * General design:&n; * In contrary to the Amiga and Atari platforms, the Mac hardware seems to &n; * exclusively use the autovector interrupts (the &squot;generic level0-level7&squot; &n; * interrupts with exception vectors 0x19-0x1f). The following interrupt levels&n; * are used:&n; *&t;1&t;- VIA1&n; *&t;&t;  - slot 0: one second interrupt&n; *&t;&t;  - slot 1: VBlank&n; *&t;&t;  - slot 2: ADB data ready (SR full)&n; *&t;&t;  - slot 3: ADB data  (CB2)&n; *&t;&t;  - slot 4: ADB clock (CB1)&n; *&t;&t;  - slot 5: timer 2&n; *&t;&t;  - slot 6: timer 1&n; *&t;&t;  - slot 7: status of IRQ; signals &squot;any enabled int.&squot;&n; *&n; *&t;2&t;- VIA2, RBV or OSS&n; *&t;&t;  - slot 0: SCSI DRQ&n; *&t;&t;  - slot 1: NUBUS IRQ&n; *&t;&t;  - slot 3: SCSI IRQ&n; *&n; *&t;4&t;- SCC&n; *&t;&t;  - subdivided into Channel B and Channel A interrupts &n; *&n; *&t;6&t;- Off switch (??)&n; *&n; *&t;7&t;- Debug output&n; *&n; * AV Macs only, handled by PSC:&n; *&n; *&t;3&t;- MACE ethernet IRQ (DMA complete on level 4)&n; *&n; *&t;5&t;- DSP ?? &n; *&n; * Using the autovector irq numbers for Linux/m68k hardware interrupts without&n; * the IRQ_MACHSPEC bit set would interfere with the general m68k interrupt &n; * handling in kernel versions 2.0.x, so the following strategy is used:&n; *&n; * - mac_init_IRQ installs the low-level entry points for the via1 and via2 &n; *   exception vectors and the corresponding handlers (C functions); these &n; *   entry points just add the machspec bit and call the handlers proper.&n; *   (in principle, the C functions can be installed as the exception vectors &n; *   directly, as they are hardcoded anyway; that&squot;s the current method). &n; *&n; * - via[12]_irq determine what interrupt sources have triggered the interrupt,&n; *   and call the corresponding device interrupt handlers. &n; *   (currently, via1_irq and via2_irq just call via_irq, passing the via base&n; *   address. RBV interrupts are handled by (you guessed it) rbv_irq).&n; *   Some interrupt functions want to have the interrupt number passed, so &n; *   via_irq and rbv_irq need to generate the &squot;fake&squot; numbers from scratch.&n; *&n; * - for the request/free/enable/disable business, interrupt sources are &n; *   numbered internally (suggestion: keep irq 0-7 unused :-). One bit in the &n; *   irq number specifies the via# to use, i.e. via1 interrupts are 8-16, &n; *   via2 interrupts 17-32, rbv interrupts ...&n; *   The device interrupt table and the irq_enable bitmap is maintained by &n; *   the machspec interrupt code; all device drivers should only use these &n; *   functions ! &n; *&n; * - For future porting to version 2.1 (and removing of the machspec bit) it &n; *   should be sufficient to use the same numbers (everything &gt; 7 is assumed &n; *   to be machspec, according to Jes!).&n; *&n; *   TODO:&n; * - integrate Nubus interrupts in request/free_irq&n; *&n; * - &n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt; /* for intr_count */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/machw.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &quot;via6522.h&quot;
macro_line|#include &lt;asm/macints.h&gt;
multiline_comment|/*&n; * Interrupt handler and parameter types&n; */
DECL|struct|irqhandler
r_struct
id|irqhandler
(brace
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|member|dev_id
r_void
op_star
id|dev_id
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|irqparam
r_struct
id|irqparam
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|devname
r_const
r_char
op_star
id|devname
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|irqflags
r_struct
id|irqflags
(brace
DECL|member|disabled
r_int
r_int
id|disabled
suffix:semicolon
DECL|member|pending
r_int
r_int
id|pending
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Array with irq&squot;s and their parameter data. &n; */
DECL|variable|via1_handler
r_static
r_struct
id|irqhandler
id|via1_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|via2_handler
r_static
r_struct
id|irqhandler
id|via2_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|rbv_handler
r_static
r_struct
id|irqhandler
id|rbv_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc3_handler
r_static
r_struct
id|irqhandler
id|psc3_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|scc_handler
r_static
r_struct
id|irqhandler
id|scc_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc5_handler
r_static
r_struct
id|irqhandler
id|psc5_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc6_handler
r_static
r_struct
id|irqhandler
id|psc6_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|nubus_handler
r_static
r_struct
id|irqhandler
id|nubus_handler
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|handler_table
r_static
r_struct
id|irqhandler
op_star
id|handler_table
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n; * This array hold the rest of parameters of int handlers: type&n; * (slow,fast,prio) and the name of the handler. These values are only&n; * accessed from C&n; */
DECL|variable|via1_param
r_static
r_struct
id|irqparam
id|via1_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|via2_param
r_static
r_struct
id|irqparam
id|via2_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|rbv_param
r_static
r_struct
id|irqparam
id|rbv_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc3_param
r_static
r_struct
id|irqparam
id|psc3_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|scc_param
r_static
r_struct
id|irqparam
id|scc_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc5_param
r_static
r_struct
id|irqparam
id|psc5_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc6_param
r_static
r_struct
id|irqparam
id|psc6_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|nubus_param
r_static
r_struct
id|irqparam
id|nubus_param
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|param_table
r_static
r_struct
id|irqparam
op_star
id|param_table
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n; * This array holds the &squot;disabled&squot; and &squot;pending&squot; software flags maintained&n; * by mac_{enable,disable}_irq and the generic via_irq function.&n; */
DECL|variable|irq_flags
r_static
r_struct
id|irqflags
id|irq_flags
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n; * This array holds the pointers to the various VIA or other interrupt &n; * controllers, indexed by interrupt level&n; */
DECL|variable|via_table
r_static
r_volatile
r_int
r_char
op_star
id|via_table
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n; * Arrays with irq statistics&n; */
DECL|variable|via1_irqs
r_static
r_int
r_int
id|via1_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|via2_irqs
r_static
r_int
r_int
id|via2_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|rbv_irqs
r_static
r_int
r_int
id|rbv_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc3_irqs
r_static
r_int
r_int
id|psc3_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|scc_irqs
r_static
r_int
r_int
id|scc_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc5_irqs
r_static
r_int
r_int
id|psc5_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|psc6_irqs
r_static
r_int
r_int
id|psc6_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|nubus_irqs
r_static
r_int
r_int
id|nubus_irqs
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|mac_irqs
r_static
r_int
r_int
op_star
id|mac_irqs
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/*&n; * VIA2 / RBV register base pointers&n; */
DECL|variable|via2_regp
r_volatile
r_int
r_char
op_star
id|via2_regp
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|VIA2_BAS
suffix:semicolon
DECL|variable|rbv_regp
r_volatile
r_int
r_char
op_star
id|rbv_regp
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|VIA2_BAS_IIci
suffix:semicolon
DECL|variable|oss_regp
r_volatile
r_int
r_char
op_star
id|oss_regp
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|OSS_BAS
suffix:semicolon
DECL|variable|psc_regp
r_volatile
r_int
r_char
op_star
id|psc_regp
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|PSC_BAS
suffix:semicolon
multiline_comment|/*&n; * Flags to control via2 / rbv behaviour&n; */
DECL|variable|via2_is_rbv
r_static
r_int
id|via2_is_rbv
op_assign
l_int|0
suffix:semicolon
DECL|variable|via2_is_oss
r_static
r_int
id|via2_is_oss
op_assign
l_int|0
suffix:semicolon
DECL|variable|rbv_clear
r_static
r_int
id|rbv_clear
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fake VIA2 to OSS bit mapping */
DECL|variable|oss_map
r_static
r_int
id|oss_map
(braket
l_int|8
)braket
op_assign
(brace
l_int|2
comma
l_int|7
comma
l_int|0
comma
l_int|1
comma
l_int|3
comma
l_int|4
comma
l_int|5
)brace
suffix:semicolon
r_void
id|oss_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|oss_do_nubus
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/* PSC ints */
r_void
id|psc_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; * console_loglevel determines NMI handler function&n; */
r_extern
r_int
id|console_loglevel
suffix:semicolon
multiline_comment|/*&n; * ADB test hooks&n; */
r_extern
r_int
id|in_keybinit
suffix:semicolon
r_void
id|adb_queue_poll
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Defined in entry.S; only increments &squot;num_spurious&squot; */
id|asmlinkage
r_void
id|bad_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|nubus_wtf
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|via
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_void
id|mac_nmi_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_void
id|mac_debug_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|via_do_nubus
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|via
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*#define DEBUG_VIA*/
DECL|function|mac_init_IRQ
r_void
id|mac_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef DEBUG_MACINTS
id|printk
c_func
(paren
l_string|&quot;Mac interrupt stuff initializing ...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|via2_regp
op_assign
(paren
r_int
r_char
op_star
)paren
id|VIA2_BAS
suffix:semicolon
id|rbv_regp
op_assign
(paren
r_int
r_char
op_star
)paren
id|VIA2_BAS_IIci
suffix:semicolon
multiline_comment|/* initialize the hardwired (primary, autovector) IRQs */
multiline_comment|/* level 1 IRQ: VIA1, always present */
id|sys_request_irq
c_func
(paren
l_int|1
comma
id|via1_irq
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;via1&quot;
comma
id|via1_irq
)paren
suffix:semicolon
multiline_comment|/* via2 or rbv?? */
r_if
c_cond
(paren
id|macintosh_config-&gt;via_type
op_eq
id|MAC_VIA_IIci
)paren
(brace
multiline_comment|/*&n;&t;&t; * A word of caution: the definitions here only affect interrupt&n;&t;&t; * handling, see via6522.c for yet another file to change&n;&t;&t; * base addresses and RBV flags&n;&t;&t; */
multiline_comment|/* yes, this is messy - the IIfx deserves a class of his own */
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_IIFX
)paren
(brace
multiline_comment|/* no real VIA2, the OSS seems _very_different */
id|via2_is_oss
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* IIfx has OSS, at a different base address than RBV */
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_IIFX
)paren
id|rbv_regp
op_assign
(paren
r_int
r_char
op_star
)paren
id|OSS_BAS
suffix:semicolon
id|sys_request_irq
c_func
(paren
l_int|2
comma
id|oss_irq
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;oss&quot;
comma
id|oss_irq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* VIA2 is part of the RBV: different base, other offsets */
id|via2_is_rbv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* LC III weirdness: IFR seems to behave like VIA2 */
multiline_comment|/* FIXME: maybe also for LC II ?? */
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_LCIII
)paren
(brace
id|rbv_clear
op_assign
l_int|0x0
suffix:semicolon
)brace
r_else
(brace
id|rbv_clear
op_assign
l_int|0x80
suffix:semicolon
)brace
multiline_comment|/* level 2 IRQ: RBV/OSS; we only care about RBV for now */
id|sys_request_irq
c_func
(paren
l_int|2
comma
id|rbv_irq
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;rbv&quot;
comma
id|rbv_irq
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* level 2 IRQ: VIA2 */
id|sys_request_irq
c_func
(paren
l_int|2
comma
id|via2_irq
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;via2&quot;
comma
id|via2_irq
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * level 4 IRQ: SCC - use &squot;master&squot; interrupt routine that calls the &n;&t; *&t;&t;registered channel-specific interrupts in turn.&n;&t; *&t;&t;Currently, one interrupt per channel is used, solely&n;&t; *&t;&t;to pass the correct async_info as parameter!&n;&t; */
macro_line|#if 0&t;/* want to install debug/SCC shutup routine until SCC init */
id|sys_request_irq
c_func
(paren
l_int|4
comma
id|mac_SCC_handler
comma
id|IRQ_FLG_STD
comma
l_string|&quot;INT4&quot;
comma
id|mac_SCC_handler
)paren
suffix:semicolon
macro_line|#else
id|sys_request_irq
c_func
(paren
l_int|4
comma
id|mac_debug_handler
comma
id|IRQ_FLG_STD
comma
l_string|&quot;INT4&quot;
comma
id|mac_debug_handler
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Alan uses IRQ 5 for SCC ?? */
id|sys_request_irq
c_func
(paren
l_int|5
comma
id|mac_debug_handler
comma
id|IRQ_FLG_STD
comma
l_string|&quot;INT5&quot;
comma
id|mac_debug_handler
)paren
suffix:semicolon
multiline_comment|/* level 6 */
id|sys_request_irq
c_func
(paren
l_int|6
comma
id|mac_bang
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;offswitch&quot;
comma
id|mac_bang
)paren
suffix:semicolon
multiline_comment|/* level 7 (or NMI) : debug stuff */
id|sys_request_irq
c_func
(paren
l_int|7
comma
id|mac_nmi_handler
comma
id|IRQ_FLG_STD
comma
l_string|&quot;NMI&quot;
comma
id|mac_nmi_handler
)paren
suffix:semicolon
multiline_comment|/* initialize the handler tables for VIAs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|via1_handler
(braket
id|i
)braket
dot
id|handler
op_assign
id|mac_default_handler
suffix:semicolon
id|via1_handler
(braket
id|i
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|via1_param
(braket
id|i
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|via1_param
(braket
id|i
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
id|via2_handler
(braket
id|i
)braket
dot
id|handler
op_assign
id|mac_default_handler
suffix:semicolon
id|via2_handler
(braket
id|i
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|via2_param
(braket
id|i
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|via2_param
(braket
id|i
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
id|rbv_handler
(braket
id|i
)braket
dot
id|handler
op_assign
id|mac_default_handler
suffix:semicolon
id|rbv_handler
(braket
id|i
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|rbv_param
(braket
id|i
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|rbv_param
(braket
id|i
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
id|scc_handler
(braket
id|i
)braket
dot
id|handler
op_assign
id|mac_default_handler
suffix:semicolon
id|scc_handler
(braket
id|i
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|scc_param
(braket
id|i
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|scc_param
(braket
id|i
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NUBUS interrupts routed through VIA2 slot 2 - special */
id|nubus_handler
(braket
id|i
)braket
dot
id|handler
op_assign
id|nubus_wtf
suffix:semicolon
id|nubus_handler
(braket
id|i
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|nubus_param
(braket
id|i
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|nubus_param
(braket
id|i
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* initialize the handler tables (level 1 -&gt; via_handler[0] !!!) */
id|via_table
(braket
l_int|0
)braket
op_assign
id|via1_regp
suffix:semicolon
id|handler_table
(braket
l_int|0
)braket
op_assign
op_amp
id|via1_handler
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|0
)braket
op_assign
op_amp
id|via1_param
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|0
)braket
op_assign
op_amp
id|via1_irqs
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|via2_is_rbv
)paren
(brace
id|via_table
(braket
l_int|1
)braket
op_assign
id|rbv_regp
suffix:semicolon
id|handler_table
(braket
l_int|1
)braket
op_assign
op_amp
id|rbv_handler
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|1
)braket
op_assign
op_amp
id|rbv_param
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|1
)braket
op_assign
op_amp
id|rbv_irqs
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|via_table
(braket
l_int|1
)braket
op_assign
id|via2_regp
suffix:semicolon
id|handler_table
(braket
l_int|1
)braket
op_assign
op_amp
id|via2_handler
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|1
)braket
op_assign
op_amp
id|via2_param
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|1
)braket
op_assign
op_amp
id|via2_irqs
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|via_table
(braket
l_int|2
)braket
op_assign
l_int|NULL
suffix:semicolon
id|via_table
(braket
l_int|3
)braket
op_assign
l_int|NULL
suffix:semicolon
id|handler_table
(braket
l_int|2
)braket
op_assign
op_amp
id|rbv_handler
(braket
l_int|0
)braket
suffix:semicolon
id|handler_table
(braket
l_int|3
)braket
op_assign
op_amp
id|scc_handler
(braket
l_int|0
)braket
suffix:semicolon
id|handler_table
(braket
l_int|4
)braket
op_assign
l_int|NULL
suffix:semicolon
id|handler_table
(braket
l_int|5
)braket
op_assign
l_int|NULL
suffix:semicolon
id|handler_table
(braket
l_int|6
)braket
op_assign
l_int|NULL
suffix:semicolon
id|handler_table
(braket
l_int|7
)braket
op_assign
op_amp
id|nubus_handler
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|2
)braket
op_assign
op_amp
id|rbv_param
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|3
)braket
op_assign
op_amp
id|scc_param
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|7
)braket
op_assign
op_amp
id|nubus_param
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|2
)braket
op_assign
op_amp
id|rbv_irqs
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|3
)braket
op_assign
op_amp
id|scc_irqs
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|7
)braket
op_assign
op_amp
id|nubus_irqs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;AV Macs: shutup the PSC ints&n;&t; */
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_C660
op_logical_or
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_Q840
)paren
(brace
id|psc_init
c_func
(paren
)paren
suffix:semicolon
id|handler_table
(braket
l_int|2
)braket
op_assign
op_amp
id|psc3_handler
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* handler_table[3] = &amp;psc4_handler[0]; */
id|handler_table
(braket
l_int|4
)braket
op_assign
op_amp
id|psc5_handler
(braket
l_int|0
)braket
suffix:semicolon
id|handler_table
(braket
l_int|5
)braket
op_assign
op_amp
id|psc6_handler
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|2
)braket
op_assign
op_amp
id|psc3_param
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* param_table[3]   = &amp;psc4_param[0]; */
id|param_table
(braket
l_int|4
)braket
op_assign
op_amp
id|psc5_param
(braket
l_int|0
)braket
suffix:semicolon
id|param_table
(braket
l_int|5
)braket
op_assign
op_amp
id|psc6_param
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|2
)braket
op_assign
op_amp
id|psc3_irqs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* mac_irqs[3]&t; = &amp;psc4_irqs[0]; */
id|mac_irqs
(braket
l_int|4
)braket
op_assign
op_amp
id|psc5_irqs
(braket
l_int|0
)braket
suffix:semicolon
id|mac_irqs
(braket
l_int|5
)braket
op_assign
op_amp
id|psc6_irqs
(braket
l_int|0
)braket
suffix:semicolon
id|sys_request_irq
c_func
(paren
l_int|3
comma
id|psc_irq
comma
id|IRQ_FLG_STD
comma
l_string|&quot;PSC3&quot;
comma
id|psc_irq
)paren
suffix:semicolon
id|sys_request_irq
c_func
(paren
l_int|4
comma
id|psc_irq
comma
id|IRQ_FLG_STD
comma
l_string|&quot;PSC4&quot;
comma
id|psc_irq
)paren
suffix:semicolon
id|sys_request_irq
c_func
(paren
l_int|5
comma
id|psc_irq
comma
id|IRQ_FLG_STD
comma
l_string|&quot;PSC5&quot;
comma
id|psc_irq
)paren
suffix:semicolon
id|sys_request_irq
c_func
(paren
l_int|6
comma
id|psc_irq
comma
id|IRQ_FLG_STD
comma
l_string|&quot;PSC6&quot;
comma
id|psc_irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MACINTS
id|printk
c_func
(paren
l_string|&quot;Mac interrupt init done!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;We have no machine specific interrupts on a macintoy&n; *      Yet, we need to register/unregister interrupts ... :-)&n; *      Currently unimplemented: Test for valid irq number, chained irqs,&n; *      Nubus interrupts (use nubus_request_irq!).&n; */
DECL|function|mac_request_irq
r_int
id|mac_request_irq
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
r_struct
id|irqhandler
op_star
id|via_handler
suffix:semicolon
r_struct
id|irqparam
op_star
id|via_param
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|via
suffix:semicolon
macro_line|#ifdef DEBUG_MACINTS
id|printk
(paren
l_string|&quot;%s: IRQ %d on VIA%d[%d] requested from %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|srcidx
op_plus
l_int|1
comma
id|irqidx
comma
id|devname
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|flags
template_param
id|IRQ_TYPE_PRIO
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Bad irq type %ld requested from %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|flags
comma
id|devname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* figure out what VIA is handling this irq */
r_if
c_cond
(paren
id|irq
OL
id|IRQ_IDX
c_func
(paren
id|IRQ_VIA1_1
)paren
op_logical_or
id|irq
op_ge
id|IRQ_IDX
c_func
(paren
id|IRQ_NUBUS_1
)paren
)paren
(brace
multiline_comment|/* non-via irqs unimplemented */
id|printk
(paren
l_string|&quot;%s: Bad irq source %d on VIA %d requested from %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|srcidx
comma
id|devname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* figure out if SCC pseudo-irq (redundant ??) */
r_if
c_cond
(paren
id|irq
op_ge
id|IRQ_IDX
c_func
(paren
id|IRQ_SCC
)paren
op_logical_and
id|irq
OL
id|IRQ_IDX
c_func
(paren
id|IRQ_PSC5_0
)paren
)paren
(brace
multiline_comment|/* set specific SCC handler */
id|scc_handler
(braket
id|irqidx
)braket
dot
id|handler
op_assign
id|handler
suffix:semicolon
id|scc_handler
(braket
id|irqidx
)braket
dot
id|dev_id
op_assign
id|dev_id
suffix:semicolon
id|scc_param
(braket
id|irqidx
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
id|scc_param
(braket
id|irqidx
)braket
dot
id|devname
op_assign
id|devname
suffix:semicolon
multiline_comment|/* and done! */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* add similar hack for Nubus pseudo-irq here - hide nubus_request_irq */
id|via
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|via_table
(braket
id|srcidx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|via
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|via_handler
op_assign
id|handler_table
(braket
id|srcidx
)braket
suffix:semicolon
id|via_param
op_assign
id|param_table
(braket
id|srcidx
)braket
suffix:semicolon
multiline_comment|/* check for conflicts or possible replacement */
multiline_comment|/* set the handler - no chained irqs yet !! */
id|via_handler
(braket
id|irqidx
)braket
dot
id|handler
op_assign
id|handler
suffix:semicolon
id|via_handler
(braket
id|irqidx
)braket
dot
id|dev_id
op_assign
id|dev_id
suffix:semicolon
id|via_param
(braket
id|irqidx
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
id|via_param
(braket
id|irqidx
)braket
dot
id|devname
op_assign
id|devname
suffix:semicolon
multiline_comment|/* and turn it on ... careful, that&squot;s VIA only ... */
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|via
comma
id|rIER
comma
id|via_read
c_func
(paren
id|via
comma
id|rIER
)paren
op_or
l_int|0x80
op_or
(paren
l_int|1
op_lshift
(paren
id|irqidx
)paren
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_oss
)paren
id|via_write
c_func
(paren
id|oss_regp
comma
id|oss_map
(braket
id|irqidx
)braket
op_plus
l_int|8
comma
l_int|2
)paren
suffix:semicolon
r_else
id|via_write
c_func
(paren
id|via
comma
id|vIER
comma
id|via_read
c_func
(paren
id|via
comma
id|vIER
)paren
op_or
l_int|0x80
op_or
(paren
l_int|1
op_lshift
(paren
id|irqidx
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|IRQ_IDX
c_func
(paren
id|IRQ_MAC_SCSI
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set vPCR for SCSI interrupts. (what about RBV here?)&n;&t;&t; * 980429 MS: RBV is ok, OSS seems to be differentt&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|via2_is_oss
)paren
multiline_comment|/* CB2 (IRQ) indep. interrupt input, positive edge */
multiline_comment|/* CA2 (DRQ) indep. interrupt input, positive edge */
id|via_write
c_func
(paren
id|via
comma
id|vPCR
comma
l_int|0x66
)paren
suffix:semicolon
macro_line|#if 0
r_else
multiline_comment|/* CB2 (IRQ) indep. interrupt input, negative edge */
multiline_comment|/* CA2 (DRQ) indep. interrupt input, negative edge */
id|via_write
c_func
(paren
id|via
comma
id|vPCR
comma
l_int|0x22
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mac_free_irq
r_void
id|mac_free_irq
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
r_struct
id|irqhandler
op_star
id|via_handler
suffix:semicolon
r_struct
id|irqparam
op_star
id|via_param
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|via
suffix:semicolon
macro_line|#ifdef DEBUG_MACINTS
id|printk
(paren
l_string|&quot;%s: IRQ %d on VIA%d[%d] freed&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|irq
comma
id|srcidx
op_plus
l_int|1
comma
id|irqidx
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* figure out what VIA is handling this irq */
r_if
c_cond
(paren
id|irq
OL
id|IRQ_IDX
c_func
(paren
id|IRQ_VIA1_1
)paren
op_logical_or
id|irq
op_ge
id|IRQ_IDX
c_func
(paren
id|IRQ_NUBUS_1
)paren
)paren
(brace
multiline_comment|/* non-via irqs unimplemented */
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* figure out if SCC pseudo-irq */
r_if
c_cond
(paren
id|irq
op_ge
id|IRQ_IDX
c_func
(paren
id|IRQ_SCC
)paren
op_logical_and
id|irq
OL
id|IRQ_IDX
c_func
(paren
id|IRQ_PSC5_0
)paren
)paren
(brace
multiline_comment|/* clear specific SCC handler */
id|scc_handler
(braket
id|irqidx
)braket
dot
id|handler
op_assign
id|mac_default_handler
suffix:semicolon
id|scc_handler
(braket
id|irqidx
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|scc_param
(braket
id|irqidx
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|scc_param
(braket
id|irqidx
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* and done! */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|via
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|via_table
(braket
id|srcidx
)braket
suffix:semicolon
id|via_handler
op_assign
id|handler_table
(braket
id|srcidx
)braket
suffix:semicolon
id|via_param
op_assign
id|param_table
(braket
id|srcidx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|via
op_logical_or
(paren
id|via_handler
(braket
id|irqidx
)braket
dot
id|dev_id
op_ne
id|dev_id
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_goto
id|not_found
suffix:semicolon
)brace
multiline_comment|/* clear the handler - no chained irqs yet !! */
id|via_handler
(braket
id|irqidx
)braket
dot
id|handler
op_assign
id|mac_default_handler
suffix:semicolon
id|via_handler
(braket
id|irqidx
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|via_param
(braket
id|irqidx
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|via_param
(braket
id|irqidx
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* and turn it off */
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|via
comma
id|rIER
comma
(paren
id|via_read
c_func
(paren
id|via
comma
id|rIER
)paren
op_amp
(paren
l_int|1
op_lshift
id|irqidx
)paren
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_oss
)paren
id|via_write
c_func
(paren
id|oss_regp
comma
id|oss_map
(braket
id|irqidx
)braket
op_plus
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_else
id|via_write
c_func
(paren
id|via
comma
id|vIER
comma
(paren
id|via_read
c_func
(paren
id|via
comma
id|vIER
)paren
op_amp
(paren
l_int|1
op_lshift
id|irqidx
)paren
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|not_found
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: tried to remove invalid irq&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * {en,dis}able_irq have the usual semantics of temporary blocking the&n; * interrupt, but not loosing requests that happen between disabling and&n; * enabling. On Atari, this is done with the MFP mask registers.&n; *&n; * On the Mac, this isn&squot;t possible: there is no VIA mask register. &n; * Needs to be implemented in software, setting &squot;mask&squot; bits in a separate&n; * struct for each interrupt controller. These mask bits need to be checked&n; * by the VIA interrupt routine which should ignore requests for masked IRQs &n; * (after possibly ack&squot;ing them).&n; *&n; * On second thought: some of the IRQ sources _can_ be turned off via bits&n; * in the VIA output registers. Need to check this ...&n; *&n; * TBI: According to the VIA docs, clearing a bit in the IER has the effect of &n; * blocking generation of the interrupt, but the internal interrupt condition &n; * is preserved. So the IER might be used as mask register here, and turnon_irq&n; * would need to clear the interrupt bit in the IFR to prevent getting an &n; * interrupt at all.&n; *&n; * Implementation note: the irq no&squot;s here are the _machspec_ irqs, hence the &n; * hack with srcidx to figure out which VIA/RBV handles the interrupt. &n; * That&squot;s fundamentally different when it comes to the interrupt handlers &n; * proper: these get the interrupt level no. as argument, all information about&n; * which source triggered the int. is buried in the VIA IFR ... The int. level &n; * points us to the proper handler, so we could do a sanity check there ...&n; */
DECL|function|mac_enable_irq
r_void
id|mac_enable_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|irqidx
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Call handler here if irq_flags[srcidx].pending &amp; 1&lt;&lt;irqidx ?? &n;&t; * The structure of via_irq prevents this, sort of: it warns if&n;&t; * no true events are pending. Maybe that&squot;s being changed ...&n;&t; * Other problem: is it always possible to call an interrupt handler, &n;&t; * or should that depend on the current interrupt level?&n;&t; */
)brace
DECL|function|mac_disable_irq
r_void
id|mac_disable_irq
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_or_assign
(paren
l_int|1
op_lshift
id|irqidx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * In opposite to {en,dis}able_irq, requests between turn{off,on}_irq are not&n; * &quot;stored&quot;. This is done with the VIA interrupt enable register&n; */
DECL|function|mac_turnon_irq
r_void
id|mac_turnon_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|via
suffix:semicolon
id|via
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|via_table
(braket
id|srcidx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|via
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|via
comma
id|rIER
comma
id|via_read
c_func
(paren
id|via
comma
id|rIER
)paren
op_or
l_int|0x80
op_or
(paren
l_int|1
op_lshift
(paren
id|irqidx
)paren
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_oss
)paren
id|via_write
c_func
(paren
id|oss_regp
comma
id|oss_map
(braket
id|irqidx
)braket
op_plus
l_int|8
comma
l_int|2
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srcidx
op_ge
id|SRC_VIA2
)paren
id|via_write
c_func
(paren
id|via
comma
(paren
l_int|0x104
op_plus
l_int|0x10
op_star
id|srcidx
)paren
comma
id|via_read
c_func
(paren
id|via
comma
(paren
l_int|0x104
op_plus
l_int|0x10
op_star
id|srcidx
)paren
)paren
op_or
l_int|0x80
op_or
(paren
l_int|1
op_lshift
(paren
id|irqidx
)paren
)paren
)paren
suffix:semicolon
r_else
id|via_write
c_func
(paren
id|via
comma
id|vIER
comma
id|via_read
c_func
(paren
id|via
comma
id|vIER
)paren
op_or
l_int|0x80
op_or
(paren
l_int|1
op_lshift
(paren
id|irqidx
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|mac_turnoff_irq
r_void
id|mac_turnoff_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|via
suffix:semicolon
id|via
op_assign
(paren
r_volatile
r_int
r_char
op_star
)paren
id|via_table
(braket
id|srcidx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|via
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|via
comma
id|rIER
comma
(paren
id|via_read
c_func
(paren
id|via
comma
id|rIER
)paren
op_amp
(paren
l_int|1
op_lshift
id|irqidx
)paren
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srcidx
op_eq
id|SRC_VIA2
op_logical_and
id|via2_is_oss
)paren
id|via_write
c_func
(paren
id|oss_regp
comma
id|oss_map
(braket
id|irqidx
)braket
op_plus
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srcidx
op_ge
id|SRC_VIA2
)paren
id|via_write
c_func
(paren
id|via
comma
(paren
l_int|0x104
op_plus
l_int|0x10
op_star
id|srcidx
)paren
comma
id|via_read
c_func
(paren
id|via
comma
(paren
l_int|0x104
op_plus
l_int|0x10
op_star
id|srcidx
)paren
)paren
op_or
(paren
l_int|1
op_lshift
(paren
id|irqidx
)paren
)paren
)paren
suffix:semicolon
r_else
id|via_write
c_func
(paren
id|via
comma
id|vIER
comma
(paren
id|via_read
c_func
(paren
id|via
comma
id|vIER
)paren
op_amp
(paren
l_int|1
op_lshift
id|irqidx
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * These functions currently only handle the software-maintained irq pending&n; * list for disabled irqs - manipulating the actual irq flags in the via would&n; * require clearing single bits in the via, such as (probably) &n; * via_write(via, vIFR, (via_read(via, vIFR)&amp;(1&lt;&lt;irqidx))); - don&squot;t know if &n; * this has side-effects ...&n; */
DECL|function|mac_clear_pending_irq
r_void
id|mac_clear_pending_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|irqidx
)paren
suffix:semicolon
)brace
DECL|function|mac_irq_pending
r_int
id|mac_irq_pending
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|srcidx
op_assign
(paren
(paren
id|irq
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|irqidx
op_assign
(paren
id|irq
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
r_return
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|irqidx
)paren
)paren
suffix:semicolon
)brace
DECL|function|mac_get_irq_list
r_int
id|mac_get_irq_list
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|srcidx
comma
id|irqidx
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|VIA1_SOURCE_BASE
suffix:semicolon
id|i
OL
id|NUM_MAC_SOURCES
op_plus
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|srcidx
op_assign
(paren
(paren
id|i
op_amp
id|IRQ_SRC_MASK
)paren
op_rshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
id|irqidx
op_assign
(paren
id|i
op_amp
id|IRQ_IDX_MASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Not present: skip&n;&t;&t; */
r_if
c_cond
(paren
id|mac_irqs
(braket
id|srcidx
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* &n;&t;&t; * never used by VIAs, unused by others so far, counts &n;&t;&t; * the magic &squot;nothing pending&squot; cases ...&n;&t;&t; */
r_if
c_cond
(paren
id|irqidx
op_eq
l_int|7
op_logical_and
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Level %01d: %10u (spurious) &bslash;n&quot;
comma
id|srcidx
comma
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Nothing registered for this IPL: skip&n;&t;&t; */
r_if
c_cond
(paren
id|handler_table
(braket
id|srcidx
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No handler installed: skip&n;&t;&t; */
r_if
c_cond
(paren
id|handler_table
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
dot
id|handler
op_eq
id|mac_default_handler
op_logical_or
id|handler_table
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
dot
id|handler
op_eq
id|nubus_wtf
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|VIA2_SOURCE_BASE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;via1  %01d: %10u &quot;
comma
id|irqidx
comma
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
OL
id|RBV_SOURCE_BASE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;via2  %01d: %10u &quot;
comma
id|irqidx
comma
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
OL
id|MAC_SCC_SOURCE_BASE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;rbv   %01d: %10u &quot;
comma
id|irqidx
comma
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
OL
id|NUBUS_SOURCE_BASE
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;scc   %01d: %10u &quot;
comma
id|irqidx
comma
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
)paren
suffix:semicolon
r_else
multiline_comment|/* Nubus */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;nubus %01d: %10u &quot;
comma
id|irqidx
comma
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|param_table
(braket
id|srcidx
)braket
(braket
id|irqidx
)braket
dot
id|devname
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_spurious
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;spurio.: %10u&bslash;n&quot;
comma
id|num_spurious
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|via_scsi_clear
r_void
id|via_scsi_clear
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_char
id|deep_magic
suffix:semicolon
r_if
c_cond
(paren
id|via2_is_rbv
)paren
(brace
id|via_write
c_func
(paren
id|rbv_regp
comma
id|rIFR
comma
(paren
l_int|1
op_lshift
l_int|3
)paren
op_or
(paren
l_int|1
op_lshift
l_int|0
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
id|deep_magic
op_assign
id|via_read
c_func
(paren
id|rbv_regp
comma
id|rBufB
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|via2_is_oss
)paren
(brace
multiline_comment|/* nothing */
multiline_comment|/* via_write(oss_regp, 9, 0) */
suffix:semicolon
)brace
r_else
id|deep_magic
op_assign
id|via_read
c_func
(paren
id|via2_regp
comma
id|vBufB
)paren
suffix:semicolon
id|mac_enable_irq
c_func
(paren
id|IRQ_IDX
c_func
(paren
id|IRQ_MAC_SCSI
)paren
)paren
suffix:semicolon
)brace
DECL|function|mac_default_handler
r_void
id|mac_default_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef DEBUG_VIA
id|printk
c_func
(paren
l_string|&quot;Unexpected IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|num_debug
r_static
r_int
id|num_debug
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|mac_debug_handler
r_void
id|mac_debug_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|num_debug
(braket
id|irq
)braket
OL
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEBUG: Unexpected IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|num_debug
(braket
id|irq
)braket
op_increment
suffix:semicolon
)brace
)brace
r_void
id|scsi_mac_debug
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|scsi_mac_polled
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|mac_nmi_handler
r_void
id|mac_nmi_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* &n;&t; * generate debug output on NMI switch if &squot;debug&squot; kernel option given&n;&t; * (only works with Penguin!)&n;&t; */
macro_line|#if 0
id|scsi_mac_debug
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PC: %08lx&bslash;nSR: %04x  SP: %p&bslash;n&quot;
comma
id|fp-&gt;pc
comma
id|fp-&gt;sr
comma
id|fp
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|scsi_mac_polled
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|console_loglevel
op_ge
l_int|8
)paren
(brace
macro_line|#if 0
id|show_state
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PC: %08lx&bslash;nSR: %04x  SP: %p&bslash;n&quot;
comma
id|fp-&gt;pc
comma
id|fp-&gt;sr
comma
id|fp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;d0: %08lx    d1: %08lx    d2: %08lx    d3: %08lx&bslash;n&quot;
comma
id|fp-&gt;d0
comma
id|fp-&gt;d1
comma
id|fp-&gt;d2
comma
id|fp-&gt;d3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx&bslash;n&quot;
comma
id|fp-&gt;d4
comma
id|fp-&gt;d5
comma
id|fp-&gt;a0
comma
id|fp-&gt;a1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|STACK_MAGIC
op_ne
op_star
(paren
r_int
r_int
op_star
)paren
id|current-&gt;kernel_stack_page
)paren
id|printk
c_func
(paren
l_string|&quot;Corrupted stack page&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, stackpage=%08lx)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|current-&gt;kernel_stack_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_count
op_eq
l_int|1
)paren
id|dump_stack
c_func
(paren
(paren
r_struct
id|frame
op_star
)paren
id|fp
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* printk(&quot;NMI &quot;); */
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * The generic VIA interrupt routines (shamelessly stolen from Alan Cox&squot;s&n; * via6522.c :-), disable/pending masks added.&n; * The int *viaidx etc. is just to keep the prototype happy ...&n; */
DECL|function|via_irq
r_static
r_void
id|via_irq
c_func
(paren
r_int
r_char
op_star
id|via
comma
r_int
op_star
id|viaidx
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|vIFR
)paren
op_amp
id|via_read
c_func
(paren
id|via
comma
id|vIER
)paren
)paren
op_amp
l_int|0x7F
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqhandler
op_star
id|via_handler
op_assign
id|handler_table
(braket
op_star
id|viaidx
)braket
suffix:semicolon
r_struct
id|irqparam
op_star
id|via_param
op_assign
id|param_table
(braket
op_star
id|viaidx
)braket
suffix:semicolon
r_int
r_int
op_star
id|via_irqs
op_assign
id|mac_irqs
(braket
op_star
id|viaidx
)braket
suffix:semicolon
multiline_comment|/* to be changed, possibly: for each non&squot;masked&squot;, enabled IRQ, read &n;&t; * flag bit, ack and call handler ...&n;         * Currently: all pending irqs ack&squot;ed en bloc.&n;&t; * If ack for masked IRQ required: keep &squot;pending&squot; info separate.&n;&t; */
multiline_comment|/* shouldn&squot;t we disable interrupts here ?? */
multiline_comment|/*&n;&t; *&t;Shouldnt happen&n;&t; */
r_if
c_cond
(paren
id|events
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_VIA
multiline_comment|/* should go away; mostly missing timer ticks and ADB events */
id|printk
c_func
(paren
l_string|&quot;via%d_irq: nothing pending, flags %x mask %x!&bslash;n&quot;
comma
op_star
id|viaidx
op_plus
l_int|1
comma
id|via_read
c_func
(paren
id|via
comma
id|vIFR
)paren
comma
id|via_read
c_func
(paren
id|via
comma
id|vIER
)paren
)paren
suffix:semicolon
macro_line|#endif
id|via_irqs
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_VIA&t;
multiline_comment|/*&n;&t; * limited verbosity for VIA interrupts&n;&t; */
macro_line|#if 0
r_if
c_cond
(paren
(paren
op_star
id|viaidx
op_eq
l_int|0
op_logical_and
id|events
op_ne
l_int|1
op_lshift
l_int|6
)paren
multiline_comment|/* timer int */
op_logical_or
(paren
op_star
id|viaidx
op_eq
l_int|1
op_logical_and
id|events
op_ne
l_int|1
op_lshift
l_int|3
)paren
)paren
multiline_comment|/* SCSI IRQ */
macro_line|#else
r_if
c_cond
(paren
op_star
id|viaidx
op_eq
l_int|0
op_logical_and
(paren
id|events
op_amp
l_int|1
op_lshift
l_int|2
)paren
)paren
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;via_irq: irq %d events %x !&bslash;n&quot;
comma
(paren
op_star
id|viaidx
)paren
op_plus
l_int|1
comma
id|events
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
multiline_comment|/*&n;&t;&t; *&t;Clear the pending flag&n;&t;&t; */
id|via_write
c_func
(paren
id|via
comma
id|vIFR
comma
id|events
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Now see what bits are raised&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* determine machspec. irq no. */
r_int
id|irq
op_assign
(paren
(paren
op_star
id|viaidx
)paren
op_plus
l_int|1
)paren
op_star
l_int|8
op_plus
id|i
suffix:semicolon
multiline_comment|/* call corresponding handlers */
r_if
c_cond
(paren
id|events
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
id|irq_flags
(braket
op_star
id|viaidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|irq_flags
(braket
op_star
id|viaidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|via_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq disabled -&gt; mark pending */
id|irq_flags
(braket
op_star
id|viaidx
)braket
dot
id|pending
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|via_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq enabled -&gt; call handler */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* and call handlers for pending irqs - first ?? */
r_if
c_cond
(paren
(paren
id|irq_flags
(braket
op_star
id|viaidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|irq_flags
(braket
op_star
id|viaidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
multiline_comment|/* call handler for re-enabled irq */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* and clear pending flag :-) */
id|irq_flags
(braket
op_star
id|viaidx
)braket
dot
id|pending
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;And done ... check for more punishment!&n;&t;&t; */
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|vIFR
)paren
op_amp
id|via_read
c_func
(paren
id|via
comma
id|vIER
)paren
)paren
op_amp
l_int|0x7F
suffix:semicolon
id|ct
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_logical_and
id|ct
OG
l_int|8
)paren
(brace
macro_line|#ifdef DEBUG_VIA
id|printk
c_func
(paren
l_string|&quot;via%d: stuck events %x&bslash;n&quot;
comma
(paren
op_star
id|viaidx
)paren
op_plus
l_int|1
comma
id|events
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|events
)paren
(brace
suffix:semicolon
)brace
macro_line|#if 0
id|scsi_mac_polled
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Caution: the following stuff is called from process_int as _autovector_ &n; * system interrupts. So irq is always in the range 0-7 :-( and the selection&n; * of the appropriate VIA is up to the irq handler here based on the autovec &n; * irq number. There&squot;s no information whatsoever about which source on the VIA&n; * triggered the int - and that&squot;s what the machspec irq no&squot;s are about. &n; * Broken design :-((((&n; */
multiline_comment|/*&n; *&t;System interrupts&n; */
DECL|function|via1_irq
r_void
id|via1_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|srcidx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
op_minus
l_int|1
suffix:semicolon
id|via_irq
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|via1_regp
comma
op_amp
id|srcidx
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Nubus / SCSI interrupts, VIA style (could be wrapped into via1_irq or&n; *&t;via_irq directly by selecting the regp based on the irq!)&n; */
DECL|function|via2_irq
r_void
id|via2_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|srcidx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
op_minus
l_int|1
suffix:semicolon
id|via_irq
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|via2_regp
comma
op_amp
id|srcidx
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Nubus / SCSI interrupts; RBV style&n; *&t;The RBV is different. RBV appears to stand for randomly broken&n; *&t;VIA (or even real broken VIA).&n; */
DECL|function|rbv_irq
r_void
id|rbv_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|srcidx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* MUST be 1 !! */
r_volatile
r_int
r_char
op_star
id|via
op_assign
id|rbv_regp
suffix:semicolon
r_int
r_char
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|rIFR
)paren
op_amp
id|via_read
c_func
(paren
id|via
comma
id|rIER
)paren
)paren
op_amp
l_int|0x7F
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqhandler
op_star
id|via_handler
op_assign
id|handler_table
(braket
id|srcidx
)braket
suffix:semicolon
r_struct
id|irqparam
op_star
id|via_param
op_assign
id|param_table
(braket
id|srcidx
)braket
suffix:semicolon
multiline_comment|/* shouldn&squot;t we disable interrupts here ?? */
multiline_comment|/*&n;&t; *&t;Shouldnt happen&n;&t; */
r_if
c_cond
(paren
id|events
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_VIA
id|printk
c_func
(paren
l_string|&quot;rbv_irq: nothing pending, flags %x mask %x!&bslash;n&quot;
comma
id|via_read
c_func
(paren
id|via
comma
id|rIFR
)paren
comma
id|via_read
c_func
(paren
id|via
comma
id|rIER
)paren
)paren
suffix:semicolon
macro_line|#endif
id|rbv_irqs
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_VIA&t;
multiline_comment|/*&n;&t; * limited verbosity for RBV interrupts (add more if needed)&n;&t; */
r_if
c_cond
(paren
id|srcidx
op_eq
l_int|1
op_logical_and
id|events
op_ne
l_int|1
op_lshift
l_int|3
)paren
multiline_comment|/* SCSI IRQ */
id|printk
c_func
(paren
l_string|&quot;rbv_irq: irq %d (%d) events %x !&bslash;n&quot;
comma
id|irq
comma
id|srcidx
op_plus
l_int|1
comma
id|events
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* to be changed, possibly: for each non&squot;masked&squot;, enabled IRQ, read &n;&t; * flag bit, ack and call handler ...&n;         * Currently: all pending irqs ack&squot;ed en bloc.&n;&t; * If ack for masked IRQ required: keep &squot;pending&squot; info separate.&n;&t; */
r_do
(brace
multiline_comment|/*&n;&t;&t; *&t;Clear the pending flag&n;&t;&t; */
id|via_write
c_func
(paren
id|via
comma
id|rIFR
comma
id|events
op_or
id|rbv_clear
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Now see what bits are raised&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* determine machspec. irq no. */
r_int
id|irq
op_assign
(paren
id|srcidx
op_plus
l_int|1
)paren
op_star
l_int|8
op_plus
id|i
suffix:semicolon
multiline_comment|/* call corresponding handlers */
r_if
c_cond
(paren
id|events
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|rbv_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq disabled -&gt; mark pending */
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|rbv_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq enabled -&gt; call handler */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* and call handlers for pending irqs - first ?? */
r_if
c_cond
(paren
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
multiline_comment|/* call handler for re-enabled irq */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* and clear pending flag :-) */
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;And done ... check for more punishment!&n;&t;&t; */
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|rIFR
)paren
op_amp
id|via_read
c_func
(paren
id|via
comma
id|rIER
)paren
)paren
op_amp
l_int|0x7F
suffix:semicolon
id|ct
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_logical_and
id|ct
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rbv: stuck events %x&bslash;n&quot;
comma
id|events
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|events
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rbv - bashing source %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via
comma
id|rIER
comma
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via
comma
id|rIFR
comma
(paren
l_int|1
op_lshift
id|i
)paren
op_or
id|rbv_clear
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|events
)paren
(brace
suffix:semicolon
)brace
macro_line|#if 0
id|scsi_mac_polled
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Unexpected via interrupt&n; */
DECL|function|via_wtf
r_void
id|via_wtf
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|via
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef DEBUG_VIA
id|printk
c_func
(paren
l_string|&quot;Unexpected event %d on via %p&bslash;n&quot;
comma
id|slot
comma
id|via
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Nubus / SCSI interrupts; OSS style&n; *&t;The OSS is even more different than the RBV. OSS appears to stand for &n; *&t;Obscenely Screwed Silicon ... &n; *&n; *&t;Latest NetBSD sources suggest the OSS should behave like a RBV, but &n; *&t;that&squot;s probably true for the 0x203 offset (Nubus/ADB-SWIM IOP) at best&n; */
DECL|function|oss_irq
r_void
id|oss_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|srcidx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* MUST be 1 !! */
r_volatile
r_int
r_char
op_star
id|via
op_assign
id|oss_regp
suffix:semicolon
r_int
r_char
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|oIFR
)paren
)paren
op_amp
l_int|0x03
suffix:semicolon
r_int
r_char
id|nub_ev
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|nIFR
)paren
)paren
op_amp
l_int|0x4F
suffix:semicolon
r_int
r_char
id|adb_ev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqhandler
op_star
id|via_handler
op_assign
id|handler_table
(braket
id|srcidx
)braket
suffix:semicolon
r_struct
id|irqparam
op_star
id|via_param
op_assign
id|param_table
(braket
id|srcidx
)braket
suffix:semicolon
multiline_comment|/* shouldn&squot;t we disable interrupts here ?? */
id|adb_ev
op_assign
id|nub_ev
op_amp
l_int|0x40
suffix:semicolon
id|nub_ev
op_and_assign
l_int|0x3F
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Shouldnt happen&n;&t; */
r_if
c_cond
(paren
id|events
op_eq
l_int|0
op_logical_and
id|adb_ev
op_eq
l_int|0
op_logical_and
id|nub_ev
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oss_irq: nothing pending, flags %x %x!&bslash;n&quot;
comma
id|via_read
c_func
(paren
id|via
comma
id|oIFR
)paren
comma
id|via_read
c_func
(paren
id|via
comma
id|nIFR
)paren
)paren
suffix:semicolon
id|rbv_irqs
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_VIA&t;
multiline_comment|/*&n;&t; * limited verbosity for RBV interrupts (add more if needed)&n;&t; */
r_if
c_cond
(paren
id|events
op_ne
l_int|1
op_lshift
l_int|3
)paren
multiline_comment|/* SCSI IRQ */
id|printk
c_func
(paren
l_string|&quot;oss_irq: irq %d events %x %x %x !&bslash;n&quot;
comma
id|irq
comma
id|srcidx
op_plus
l_int|1
comma
id|events
comma
id|adb_ev
comma
id|nub_ev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * OSS priorities: call ADB handler first if registered, other events,&n;&t; * then Nubus &n;&t; * ADB: yet to be implemented!&n;&t; */
multiline_comment|/*&n;&t; * ADB: try to shutup the IOP &n;&t; */
r_if
c_cond
(paren
id|adb_ev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Hands off ! Don&squot;t press this button ever again !!!&bslash;n&quot;
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via
comma
l_int|6
comma
l_int|0
)paren
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/*&n;&t;&t; *&t;Clear the pending flags&n;&t;&t; *&t;How exactly is that supposed to work ??&n;&t;&t; */
multiline_comment|/*&n;&t;&t; *&t;Now see what bits are raised&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* HACK HACK: map to bit number in OSS register */
r_int
id|irqidx
op_assign
id|oss_map
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* determine machspec. irq no. */
r_int
id|irq
op_assign
(paren
id|srcidx
op_plus
l_int|1
)paren
op_star
l_int|8
op_plus
id|i
suffix:semicolon
multiline_comment|/* call corresponding handlers */
r_if
c_cond
(paren
(paren
id|events
op_amp
(paren
l_int|1
op_lshift
id|irqidx
)paren
)paren
op_logical_and
multiline_comment|/* bit set*/
(paren
id|via_read
c_func
(paren
id|via
comma
id|irqidx
op_plus
l_int|8
)paren
op_amp
l_int|0x7
)paren
)paren
(brace
multiline_comment|/* irq enabled */
r_if
c_cond
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|rbv_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq disabled -&gt; mark pending */
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|rbv_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq enabled -&gt; call handler */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* and call handlers for pending irqs - first ?? */
r_if
c_cond
(paren
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
multiline_comment|/* call handler for re-enabled irq */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* and clear pending flag :-) */
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;And done ... check for more punishment!&n;&t;&t; */
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|oIFR
)paren
multiline_comment|/*&amp;via_read(via,rIER)*/
)paren
op_amp
l_int|0x03
suffix:semicolon
id|ct
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_logical_and
id|ct
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oss: stuck events %x&bslash;n&quot;
comma
id|events
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|events
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oss - bashing source %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* that should disable it */
id|via_write
c_func
(paren
id|via
comma
l_int|8
op_plus
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|events
)paren
(brace
suffix:semicolon
)brace
macro_line|#if 0
id|scsi_mac_polled
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nub_ev
)paren
id|oss_do_nubus
c_func
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Unexpected slot interrupt&n; */
DECL|function|nubus_wtf
r_void
id|nubus_wtf
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|via
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef DEBUG_VIA_NUBUS
id|printk
c_func
(paren
l_string|&quot;Unexpected interrupt on nubus slot %d&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;SCC master interrupt handler; sole purpose: pass the registered &n; *&t;async struct to the SCC handler proper.&n; */
DECL|function|mac_SCC_handler
r_void
id|mac_SCC_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* 1+2: compatibility with PSC ! */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* currently only these two used */
r_if
c_cond
(paren
id|scc_handler
(braket
id|i
)braket
dot
id|handler
op_ne
id|mac_default_handler
)paren
(paren
id|scc_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|i
comma
id|scc_handler
(braket
id|i
)braket
dot
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;PSC interrupt handler&n; */
DECL|function|psc_irq
r_void
id|psc_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|srcidx
op_assign
id|IRQ_IDX
c_func
(paren
id|irq
)paren
op_minus
l_int|1
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|via
op_assign
id|psc_regp
suffix:semicolon
r_int
r_int
id|pIFR
op_assign
l_int|0x100
op_plus
l_int|0x10
op_star
id|srcidx
suffix:semicolon
r_int
r_int
id|pIER
op_assign
l_int|0x104
op_plus
l_int|0x10
op_star
id|srcidx
suffix:semicolon
r_int
r_char
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|pIFR
)paren
op_amp
id|via_read
c_func
(paren
id|via
comma
id|pIER
)paren
)paren
op_amp
l_int|0xF
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqhandler
op_star
id|via_handler
op_assign
id|handler_table
(braket
id|srcidx
)braket
suffix:semicolon
r_struct
id|irqparam
op_star
id|via_param
op_assign
id|param_table
(braket
id|srcidx
)braket
suffix:semicolon
multiline_comment|/* shouldn&squot;t we disable interrupts here ?? */
multiline_comment|/*&n;&t; *&t;Shouldnt happen&n;&t; */
r_if
c_cond
(paren
id|events
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_VIA
id|printk
c_func
(paren
l_string|&quot;rbv_irq: nothing pending, flags %x mask %x!&bslash;n&quot;
comma
id|via_read
c_func
(paren
id|via
comma
id|pIFR
)paren
comma
id|via_read
c_func
(paren
id|via
comma
id|pIER
)paren
)paren
suffix:semicolon
macro_line|#endif
id|mac_irqs
(braket
id|srcidx
)braket
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_VIA&t;
multiline_comment|/*&n;&t; * limited verbosity for RBV interrupts (add more if needed)&n;&t; */
r_if
c_cond
(paren
id|srcidx
op_eq
l_int|1
op_logical_and
id|events
op_ne
l_int|1
op_lshift
l_int|3
op_logical_and
id|events
op_ne
l_int|1
op_lshift
l_int|1
)paren
multiline_comment|/* SCSI IRQ */
id|printk
c_func
(paren
l_string|&quot;psc_irq: irq %d events %x !&bslash;n&quot;
comma
id|irq
comma
id|srcidx
op_plus
l_int|1
comma
id|events
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* to be changed, possibly: for each non&squot;masked&squot;, enabled IRQ, read &n;&t; * flag bit, ack and call handler ...&n;         * Currently: all pending irqs ack&squot;ed en bloc.&n;&t; * If ack for masked IRQ required: keep &squot;pending&squot; info separate.&n;&t; */
r_do
(brace
multiline_comment|/*&n;&t;&t; *&t;Clear the pending flag&n;&t;&t; */
multiline_comment|/* via_write(via, pIFR, events); */
multiline_comment|/*&n;&t;&t; *&t;Now see what bits are raised&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* determine machspec. irq no. */
r_int
id|irq
op_assign
(paren
id|srcidx
op_plus
l_int|1
)paren
op_star
l_int|8
op_plus
id|i
suffix:semicolon
multiline_comment|/* call corresponding handlers */
r_if
c_cond
(paren
id|events
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq disabled -&gt; mark pending */
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|mac_irqs
(braket
id|srcidx
)braket
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* irq enabled -&gt; call handler */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* and call handlers for pending irqs - first ?? */
r_if
c_cond
(paren
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|irq_flags
(braket
id|srcidx
)braket
dot
id|disabled
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
multiline_comment|/* call handler for re-enabled irq */
(paren
id|via_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|irq
comma
id|via
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* and clear pending flag :-) */
id|irq_flags
(braket
id|srcidx
)braket
dot
id|pending
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;And done ... check for more punishment!&n;&t;&t; */
id|events
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|pIFR
)paren
op_amp
id|via_read
c_func
(paren
id|via
comma
id|pIER
)paren
)paren
op_amp
l_int|0x7F
suffix:semicolon
id|ct
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_logical_and
id|ct
OG
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;psc: stuck events %x&bslash;n&quot;
comma
id|events
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|events
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;psc - bashing source %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via
comma
id|pIER
comma
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
multiline_comment|/* via_write(via, pIFR, (1&lt;&lt;i)); */
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|events
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Nubus handling&n; *      Caution: slot numbers are currently &squot;hardcoded&squot; to the range 9-15!&n; *      In general, the same request_irq() functions as above can be used if&n; *      the interrupt numbers specifed in macints.h are used.&n; */
DECL|variable|nubus_active
r_static
r_int
id|nubus_active
op_assign
l_int|0
suffix:semicolon
DECL|function|nubus_request_irq
r_int
id|nubus_request_irq
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|dev_id
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
id|slot
op_sub_assign
l_int|9
suffix:semicolon
multiline_comment|/*&t;printk(&quot;Nubus request irq for slot %d&bslash;n&quot;,slot);*/
r_if
c_cond
(paren
id|nubus_handler
(braket
id|slot
)braket
dot
id|handler
op_ne
id|nubus_wtf
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|nubus_handler
(braket
id|slot
)braket
dot
id|handler
op_assign
id|handler
suffix:semicolon
id|nubus_handler
(braket
id|slot
)braket
dot
id|dev_id
op_assign
id|dev_id
suffix:semicolon
id|nubus_param
(braket
id|slot
)braket
dot
id|flags
op_assign
id|IRQ_FLG_LOCK
suffix:semicolon
id|nubus_param
(braket
id|slot
)braket
dot
id|devname
op_assign
l_string|&quot;nubus slot&quot;
suffix:semicolon
multiline_comment|/* &n;&t; * if no nubus int. was active previously: register the main nubus irq&n;&t; * handler now!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|nubus_active
op_logical_and
op_logical_neg
id|via2_is_oss
)paren
(brace
id|request_irq
c_func
(paren
id|IRQ_MAC_NUBUS
comma
id|via_do_nubus
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;nubus dispatch&quot;
comma
id|via_do_nubus
)paren
suffix:semicolon
)brace
id|nubus_active
op_or_assign
l_int|1
op_lshift
id|slot
suffix:semicolon
multiline_comment|/*&t;printk(&quot;program slot %d&bslash;n&quot;,slot);*/
multiline_comment|/*&t;printk(&quot;via2=%p&bslash;n&quot;,via2);*/
macro_line|#if 0
id|via_write
c_func
(paren
id|via2
comma
id|vDirA
comma
id|via_read
c_func
(paren
id|via2
comma
id|vDirA
)paren
op_or
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via2
comma
id|vBufA
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;&t;
r_if
c_cond
(paren
id|via2_is_oss
)paren
id|via_write
c_func
(paren
id|oss_regp
comma
id|slot
comma
l_int|2
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|via2_is_rbv
)paren
(brace
multiline_comment|/* Make sure the bit is an input */
id|via_write
c_func
(paren
id|via2_regp
comma
id|vDirA
comma
id|via_read
c_func
(paren
id|via2_regp
comma
id|vDirA
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;printk(&quot;nubus irq on&bslash;n&quot;);*/
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nubus_free_irq
r_int
id|nubus_free_irq
c_func
(paren
r_int
id|slot
)paren
(brace
id|slot
op_sub_assign
l_int|9
suffix:semicolon
id|nubus_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|slot
)paren
suffix:semicolon
id|nubus_handler
(braket
id|slot
)braket
dot
id|handler
op_assign
id|nubus_wtf
suffix:semicolon
id|nubus_handler
(braket
id|slot
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
id|nubus_param
(braket
id|slot
)braket
dot
id|flags
op_assign
id|IRQ_FLG_STD
suffix:semicolon
id|nubus_param
(braket
id|slot
)braket
dot
id|devname
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|rbv_regp
comma
id|rBufA
comma
l_int|1
op_lshift
id|slot
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|via2_is_oss
)paren
id|via_write
c_func
(paren
id|oss_regp
comma
id|slot
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|via_write
c_func
(paren
id|via2_regp
comma
id|vDirA
comma
id|via_read
c_func
(paren
id|via2_regp
comma
id|vDirA
)paren
op_or
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via2_regp
comma
id|vBufA
comma
l_int|1
op_lshift
id|slot
)paren
suffix:semicolon
id|via_write
c_func
(paren
id|via2_regp
comma
id|vDirA
comma
id|via_read
c_func
(paren
id|via2_regp
comma
id|vDirA
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|slot
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_MAC_IDE
multiline_comment|/*&n; * IDE interrupt hook&n; */
r_extern
r_void
(paren
op_star
id|mac_ide_intr_hook
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Nubus dispatch handler - VIA/RBV style&n; */
DECL|function|via_do_nubus
r_static
r_void
id|via_do_nubus
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|via
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|map
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&t;printk(&quot;nubus interrupt&bslash;n&quot;);*/
multiline_comment|/* lock the nubus interrupt */
r_if
c_cond
(paren
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|rbv_regp
comma
id|rIFR
comma
l_int|0x82
)paren
suffix:semicolon
r_else
id|via_write
c_func
(paren
id|via2_regp
comma
id|vIFR
comma
l_int|0x82
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_MAC_IDE
multiline_comment|/* IDE hack */
r_if
c_cond
(paren
id|mac_ide_intr_hook
)paren
multiline_comment|/* &squot;slot&squot; is lacking the machspec bit in 2.0 */
multiline_comment|/* need to pass proper dev_id = hwgroup here */
id|mac_ide_intr_hook
c_func
(paren
id|IRQ_MAC_NUBUS
comma
id|via
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|via2_is_rbv
)paren
id|map
op_assign
op_complement
id|via_read
c_func
(paren
id|rbv_regp
comma
id|rBufA
)paren
suffix:semicolon
r_else
id|map
op_assign
op_complement
id|via_read
c_func
(paren
id|via2_regp
comma
id|vBufA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|map
op_assign
(paren
id|map
op_amp
id|nubus_active
)paren
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_NUBUS_INT
id|printk
c_func
(paren
l_string|&quot;nubus_irq: nothing pending, map %x mask %x&bslash;n&quot;
comma
id|map
comma
id|nubus_active
)paren
suffix:semicolon
macro_line|#endif
id|nubus_irqs
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_NUBUS_INT
id|printk
c_func
(paren
l_string|&quot;nubus_irq: map %x mask %x&bslash;n&quot;
comma
id|map
comma
id|nubus_active
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ct
op_increment
OG
l_int|2
)paren
(brace
macro_line|#ifdef DEBUG_NUBUS_INT
id|printk
c_func
(paren
l_string|&quot;nubus stuck events - %d/%d&bslash;n&quot;
comma
id|map
comma
id|nubus_active
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|nubus_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
(paren
id|nubus_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
id|i
op_plus
l_int|9
comma
id|nubus_handler
(braket
id|i
)braket
dot
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* clear it */
r_if
c_cond
(paren
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|rbv_regp
comma
id|rIFR
comma
l_int|0x02
)paren
suffix:semicolon
r_else
id|via_write
c_func
(paren
id|via2_regp
comma
id|vIFR
comma
l_int|0x02
)paren
suffix:semicolon
)brace
multiline_comment|/* And done */
)brace
multiline_comment|/*&n; * Nubus dispatch handler - OSS style&n; */
DECL|function|oss_do_nubus
r_static
r_void
id|oss_do_nubus
c_func
(paren
r_int
id|slot
comma
r_void
op_star
id|via
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|map
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&t;printk(&quot;nubus interrupt&bslash;n&quot;);*/
macro_line|#if 0
multiline_comment|/* lock the nubus interrupt */
r_if
c_cond
(paren
id|via2_is_rbv
)paren
id|via_write
c_func
(paren
id|rbv_regp
comma
id|rIFR
comma
l_int|0x82
)paren
suffix:semicolon
r_else
id|via_write
c_func
(paren
id|via2_regp
comma
id|vIFR
comma
l_int|0x82
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* IDE hack for Quadra: uses Nubus interrupt without any slot bit set */
r_if
c_cond
(paren
id|mac_ide_intr_hook
)paren
id|mac_ide_intr_hook
c_func
(paren
id|IRQ_MAC_NUBUS
comma
id|via
comma
id|regs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* pending events */
id|map
op_assign
(paren
id|via_read
c_func
(paren
id|via
comma
id|nIFR
)paren
)paren
op_amp
l_int|0x3F
suffix:semicolon
macro_line|#ifdef DEBUG_VIA_NUBUS
id|printk
c_func
(paren
l_string|&quot;nubus_irq: map %x mask %x&bslash;n&quot;
comma
id|map
comma
id|nubus_active
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|map
op_assign
(paren
id|map
op_amp
id|nubus_active
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mac_ide_intr_hook
)paren
id|printk
c_func
(paren
l_string|&quot;nubus_irq: nothing pending, map %x mask %x&bslash;n&quot;
comma
id|map
comma
id|nubus_active
)paren
suffix:semicolon
id|nubus_irqs
(braket
l_int|7
)braket
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ct
op_increment
OG
l_int|2
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;nubus stuck events - %d/%d&bslash;n&quot;
comma
id|map
comma
id|nubus_active
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|nubus_irqs
(braket
id|i
)braket
op_increment
suffix:semicolon
multiline_comment|/* call handler */
(paren
id|nubus_handler
(braket
id|i
)braket
dot
id|handler
)paren
(paren
(paren
id|i
op_plus
l_int|9
)paren
comma
id|nubus_handler
(braket
id|i
)braket
dot
id|dev_id
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* clear interrupt ?? */
macro_line|#if 0
id|via_write
c_func
(paren
id|oss_regp
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/* clear it */
macro_line|#if 0
id|via_write
c_func
(paren
id|oss_regp
comma
id|nIFR
comma
id|map
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* And done */
)brace
eof
