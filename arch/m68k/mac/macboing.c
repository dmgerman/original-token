multiline_comment|/*&n; *&t;Mac bong noise generator. Note - we ought to put a boingy noise&n; *&t;here 8)&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;asm/mac_asc.h&gt;
DECL|variable|sine_data
r_static
r_const
r_int
r_char
id|sine_data
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|39
comma
l_int|75
comma
l_int|103
comma
l_int|121
comma
l_int|127
comma
l_int|121
comma
l_int|103
comma
l_int|75
comma
l_int|39
comma
l_int|0
comma
op_minus
l_int|39
comma
op_minus
l_int|75
comma
op_minus
l_int|103
comma
op_minus
l_int|121
comma
op_minus
l_int|127
comma
op_minus
l_int|121
comma
op_minus
l_int|103
comma
op_minus
l_int|75
comma
op_minus
l_int|39
)brace
suffix:semicolon
DECL|macro|DATA_SIZE
mdefine_line|#define DATA_SIZE&t;(sizeof(sine_data)/sizeof(sine_data[0]))
r_static
r_void
id|nosound
c_func
(paren
r_int
r_int
id|ignored
)paren
suffix:semicolon
DECL|variable|sound_timer
r_static
r_struct
id|timer_list
id|sound_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|nosound
)brace
suffix:semicolon
DECL|variable|asc_base
r_static
r_volatile
r_int
r_char
op_star
id|asc_base
op_assign
(paren
r_void
op_star
)paren
l_int|0x50F14000
suffix:semicolon
DECL|function|mac_mksound
r_void
id|mac_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
(brace
r_static
r_int
id|inited
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|samples
op_assign
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_C660
op_logical_or
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_Q840
)paren
(brace
multiline_comment|/*&n;&t;&t; * The Quadra 660AV and 840AV use the &quot;Singer&quot; custom ASIC for sound I/O.&n;&t;&t; * It appears to be similar to the &quot;AWACS&quot; custom ASIC in the Power Mac &n;&t;&t; * [678]100.  Because Singer and AWACS may have a similar hardware &n;&t;&t; * interface, this would imply that the code in drivers/sound/dmasound.c &n;&t;&t; * for AWACS could be used as a basis for Singer support.  All we have to&n;&t;&t; * do is figure out how to do DMA on the 660AV/840AV through the PSC and &n;&t;&t; * figure out where the Singer hardware sits in memory. (I&squot;d look in the&n;&t;&t; * vicinity of the AWACS location in a Power Mac [678]100 first, or the &n;&t;&t; * current location of the Apple Sound Chip--ASC--in other Macs.)  The &n;&t;&t; * Power Mac [678]100 info can be found in MkLinux Mach kernel sources.&n;&t;&t; *&n;&t;&t; * Quoted from Apple&squot;s Tech Info Library, article number 16405:&n;&t;&t; *   &quot;Among desktop Macintosh computers, only the 660AV, 840AV, and Power&n;&t;&t; *   Macintosh models have 16-bit audio input and output capability &n;&t;&t; *   because of the AT&amp;T DSP3210 hardware circuitry and the 16-bit Singer&n;&t;&t; *   codec circuitry in the AVs.  The Audio Waveform Amplifier and&n;&t;&t; *   Converter (AWAC) chip in the Power Macintosh performs the same &n;&t;&t; *   16-bit I/O functionality.  The PowerBook 500 series computers&n;&t;&t; *   support 16-bit stereo output, but only mono input.&quot;&n;&t;&t; *&n;&t;&t; *   http://til.info.apple.com/techinfo.nsf/artnum/n16405&n;&t;&t; *&n;&t;&t; * --David Kilzer&n;&t;&t; */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|inited
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|j
op_assign
l_int|0
suffix:semicolon
r_int
id|k
op_assign
l_int|0
suffix:semicolon
r_int
id|l
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;The IIfx strikes again!&n;&t;&t; */
r_if
c_cond
(paren
id|macintosh_config-&gt;ident
op_eq
id|MAC_MODEL_IIFX
)paren
(brace
id|asc_base
op_assign
(paren
r_void
op_star
)paren
l_int|0x50010000
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|samples
suffix:semicolon
id|i
op_increment
)paren
(brace
id|asc_base
(braket
id|i
)braket
op_assign
id|sine_data
(braket
id|j
)braket
suffix:semicolon
id|asc_base
(braket
id|i
op_plus
l_int|512
)braket
op_assign
id|sine_data
(braket
id|j
)braket
suffix:semicolon
id|asc_base
(braket
id|i
op_plus
l_int|1024
)braket
op_assign
id|sine_data
(braket
id|j
)braket
suffix:semicolon
id|asc_base
(braket
id|i
op_plus
l_int|1536
)braket
op_assign
id|sine_data
(braket
id|j
)braket
suffix:semicolon
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|DATA_SIZE
)paren
(brace
id|j
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_amp
l_int|1
)paren
(brace
id|k
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
id|DATA_SIZE
)paren
(brace
id|k
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|3
)paren
op_eq
l_int|3
)paren
(brace
id|l
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
op_eq
id|DATA_SIZE
)paren
(brace
id|l
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|inited
op_assign
l_int|1
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hz
OG
l_int|20
op_logical_and
id|hz
OL
l_int|32767
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_long
id|asc_pulses
op_assign
(paren
(paren
id|hz
op_lshift
l_int|5
)paren
op_star
id|samples
)paren
op_div
l_int|468
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|0
)paren
)braket
op_assign
l_int|0x00
suffix:semicolon
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|1
)paren
)braket
op_assign
l_int|20
suffix:semicolon
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|2
)paren
)braket
op_assign
l_int|0x00
suffix:semicolon
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|3
)paren
)braket
op_assign
l_int|20
suffix:semicolon
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|4
)paren
)braket
op_assign
(paren
id|asc_pulses
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|5
)paren
)braket
op_assign
(paren
id|asc_pulses
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|6
)paren
)braket
op_assign
(paren
id|asc_pulses
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|asc_base
(braket
id|ASC_FREQ
c_func
(paren
id|i
comma
l_int|7
)paren
)braket
op_assign
(paren
id|asc_pulses
op_rshift
l_int|0
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
id|asc_base
(braket
id|ASC_CHAN
)braket
op_assign
l_int|0x03
suffix:semicolon
id|asc_base
(braket
id|ASC_VOLUME
)braket
op_assign
l_int|128
suffix:semicolon
id|asc_base
(braket
id|ASC_MODE
)braket
op_assign
id|ASC_MODE_SAMPLE
suffix:semicolon
id|asc_base
(braket
id|ASC_ENABLE
)braket
op_assign
id|ASC_ENABLE_SAMPLE
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
id|sound_timer.expires
op_assign
id|jiffies
op_plus
id|ticks
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|nosound
r_static
r_void
id|nosound
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
id|asc_base
(braket
id|ASC_ENABLE
)braket
op_assign
l_int|0
suffix:semicolon
)brace
eof
