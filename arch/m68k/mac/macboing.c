multiline_comment|/*&n; *&t;Mac bong noise generator. Note - we ought to put a boingy noise&n; *&t;here 8)&n; *&t; &n; *&t;----------------------------------------------------------------------&n; *&t;16.11.98:&n; *&t;rewrote some functions, added support for Enhanced ASC (Quadras)&n; *&t;after the NetBSD asc.c console bell patch by Colin Wood/Frederick Bruck&n; *&t;Juergen Mellinger (juergen.mellinger@t-online.de)&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/macintosh.h&gt;
macro_line|#include &lt;asm/mac_asc.h&gt;
DECL|variable|mac_asc_inited
r_static
r_int
id|mac_asc_inited
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * dumb triangular wave table&n; */
DECL|variable|mac_asc_wave_tab
r_static
id|__u8
id|mac_asc_wave_tab
(braket
l_int|0x800
)braket
suffix:semicolon
multiline_comment|/*&n; * Alan&squot;s original sine table; needs interpolating to 0x800 &n; * (hint: interpolate or hardwire [0 -&gt; Pi/2[, it&squot;s symmetric) &n; */
DECL|variable|sine_data
r_static
r_const
r_int
r_char
id|sine_data
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|39
comma
l_int|75
comma
l_int|103
comma
l_int|121
comma
l_int|127
comma
l_int|121
comma
l_int|103
comma
l_int|75
comma
l_int|39
comma
l_int|0
comma
op_minus
l_int|39
comma
op_minus
l_int|75
comma
op_minus
l_int|103
comma
op_minus
l_int|121
comma
op_minus
l_int|127
comma
op_minus
l_int|121
comma
op_minus
l_int|103
comma
op_minus
l_int|75
comma
op_minus
l_int|39
)brace
suffix:semicolon
multiline_comment|/*&n; * where the ASC hides ...&n; */
DECL|variable|mac_asc_regs
r_static
r_volatile
id|__u8
op_star
id|mac_asc_regs
op_assign
(paren
r_void
op_star
)paren
l_int|0x50F14000
suffix:semicolon
multiline_comment|/* &n; * sample rate; is this a good default value? &n; */
DECL|variable|mac_asc_samplespersec
r_static
r_int
r_int
id|mac_asc_samplespersec
op_assign
l_int|11050
suffix:semicolon
DECL|variable|mac_bell_duration
r_static
r_int
id|mac_bell_duration
op_assign
l_int|0
suffix:semicolon
DECL|variable|mac_bell_phase
r_static
r_int
r_int
id|mac_bell_phase
suffix:semicolon
multiline_comment|/* 0..2*Pi -&gt; 0..0x800 (wavetable size) */
DECL|variable|mac_bell_phasepersample
r_static
r_int
r_int
id|mac_bell_phasepersample
suffix:semicolon
multiline_comment|/*&n; * some function protos &n; */
r_static
r_void
id|mac_init_asc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mac_nosound
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|mac_quadra_start_bell
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|mac_quadra_ring_bell
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|mac_av_start_bell
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|variable|mac_special_bell
r_static
r_void
(paren
op_star
id|mac_special_bell
)paren
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * our timer to start/continue/stop the bell&n; */
DECL|variable|mac_sound_timer
r_static
r_struct
id|timer_list
id|mac_sound_timer
op_assign
(brace
id|function
suffix:colon
id|mac_nosound
)brace
suffix:semicolon
multiline_comment|/*&n; * Sort of initialize the sound chip (called from mac_mksound on the first&n; * beep).&n; */
DECL|function|mac_init_asc
r_static
r_void
id|mac_init_asc
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* &n;&t; * do some machine specific initialization &n;&t; * BTW:&n;&t; * the NetBSD Quadra patch identifies the Enhanced Apple Sound Chip via&n;&t; * &t;mac_asc_regs[ 0x800 ] &amp; 0xF0 != 0&n;&t; * this makes no sense here, because we have to set the default sample&n;&t; * rate anyway if we want correct frequencies&n;&t; */
r_switch
c_cond
(paren
id|macintosh_config-&gt;ident
)paren
(brace
r_case
id|MAC_MODEL_IIFX
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * The IIfx is always special ...&n;&t;&t;&t; */
id|mac_asc_regs
op_assign
(paren
r_void
op_star
)paren
l_int|0x50010000
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * not sure about how correct this list is &n;&t;&t;&t; * machines with the EASC enhanced apple sound chip &n;&t;&t;&t; */
r_case
id|MAC_MODEL_Q630
suffix:colon
r_case
id|MAC_MODEL_P475
suffix:colon
id|mac_special_bell
op_assign
id|mac_quadra_start_bell
suffix:semicolon
id|mac_asc_samplespersec
op_assign
l_int|22150
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC_MODEL_C660
suffix:colon
r_case
id|MAC_MODEL_Q840
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * The Quadra 660AV and 840AV use the &quot;Singer&quot; custom ASIC for sound I/O.&n;&t;&t;&t; * It appears to be similar to the &quot;AWACS&quot; custom ASIC in the Power Mac &n;&t;&t;&t; * [678]100.  Because Singer and AWACS may have a similar hardware &n;&t;&t;&t; * interface, this would imply that the code in drivers/sound/dmasound.c &n;&t;&t;&t; * for AWACS could be used as a basis for Singer support.  All we have to&n;&t;&t;&t; * do is figure out how to do DMA on the 660AV/840AV through the PSC and &n;&t;&t;&t; * figure out where the Singer hardware sits in memory. (I&squot;d look in the&n;&t;&t;&t; * vicinity of the AWACS location in a Power Mac [678]100 first, or the &n;&t;&t;&t; * current location of the Apple Sound Chip--ASC--in other Macs.)  The &n;&t;&t;&t; * Power Mac [678]100 info can be found in MkLinux Mach kernel sources.&n;&t;&t;&t; *&n;&t;&t;&t; * Quoted from Apple&squot;s Tech Info Library, article number 16405:&n;&t;&t;&t; *   &quot;Among desktop Macintosh computers, only the 660AV, 840AV, and Power&n;&t;&t;&t; *   Macintosh models have 16-bit audio input and output capability&n;&t;&t;&t; *   because of the AT&amp;T DSP3210 hardware circuitry and the 16-bit Singer&n;&t;&t;&t; *   codec circuitry in the AVs.  The Audio Waveform Amplifier and&n;&t;&t;&t; *   Converter (AWAC) chip in the Power Macintosh performs the same &n;&t;&t;&t; *   16-bit I/O functionality.  The PowerBook 500 series computers&n;&t;&t;&t; *   support 16-bit stereo output, but only mono input.&quot;&n;&t;&t;&t; *&n;&t;&t;&t; *   http://til.info.apple.com/techinfo.nsf/artnum/n16405&n;&t;&t;&t; *&n;&t;&t;&t; * --David Kilzer&n;&t;&t;&t; */
id|mac_special_bell
op_assign
id|mac_av_start_bell
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAC_MODEL_Q650
suffix:colon
r_case
id|MAC_MODEL_Q700
suffix:colon
r_case
id|MAC_MODEL_Q800
suffix:colon
r_case
id|MAC_MODEL_Q900
suffix:colon
r_case
id|MAC_MODEL_Q950
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Currently not implemented!&n;&t;&t;&t; */
id|mac_special_bell
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Every switch needs a default&n;&t;&t;&t; */
id|mac_special_bell
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * init the wave table with a simple triangular wave &n;&t; * A sine wave would sure be nicer here ...&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x400
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac_asc_wave_tab
(braket
id|i
)braket
op_assign
id|i
op_div
l_int|4
suffix:semicolon
id|mac_asc_wave_tab
(braket
id|i
op_plus
l_int|0x400
)braket
op_assign
l_int|0xFF
op_minus
id|i
op_div
l_int|4
suffix:semicolon
)brace
id|mac_asc_inited
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Called to make noise; current single entry to the boing driver. &n; * Does the job for simple ASC, calls other routines else.&n; * XXX Fixme:&n; * Should be split into asc_mksound, easc_mksound, av_mksound and &n; * function pointer set in mac_init_asc which would be called at &n; * init time. &n; * _This_ is rather ugly ...&n; */
DECL|function|mac_mksound
r_void
id|mac_mksound
c_func
(paren
r_int
r_int
id|freq
comma
r_int
r_int
id|length
)paren
(brace
id|__u32
id|cfreq
op_assign
(paren
id|freq
op_lshift
l_int|5
)paren
op_div
l_int|468
suffix:semicolon
id|__u32
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|mac_special_bell
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Do nothing */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mac_asc_inited
)paren
id|mac_init_asc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mac_special_bell
)paren
(brace
id|mac_special_bell
c_func
(paren
id|freq
comma
id|length
comma
l_int|128
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|freq
template_param
l_int|20000
op_logical_or
id|length
op_eq
l_int|0
)paren
(brace
id|mac_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|mac_sound_timer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x800
suffix:semicolon
id|i
op_increment
)paren
id|mac_asc_regs
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x800
suffix:semicolon
id|i
op_increment
)paren
id|mac_asc_regs
(braket
id|i
)braket
op_assign
id|mac_asc_wave_tab
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
op_star
(paren
id|__u32
op_star
)paren
(paren
(paren
id|__u32
)paren
id|mac_asc_regs
op_plus
id|ASC_CONTROL
op_plus
l_int|0x814
op_plus
l_int|8
op_star
id|i
)paren
op_assign
id|cfreq
suffix:semicolon
id|mac_asc_regs
(braket
l_int|0x807
)braket
op_assign
l_int|0
suffix:semicolon
id|mac_asc_regs
(braket
id|ASC_VOLUME
)braket
op_assign
l_int|128
suffix:semicolon
id|mac_asc_regs
(braket
l_int|0x805
)braket
op_assign
l_int|0
suffix:semicolon
id|mac_asc_regs
(braket
l_int|0x80F
)braket
op_assign
l_int|0
suffix:semicolon
id|mac_asc_regs
(braket
id|ASC_MODE
)braket
op_assign
id|ASC_MODE_SAMPLE
suffix:semicolon
id|mac_asc_regs
(braket
id|ASC_ENABLE
)braket
op_assign
id|ASC_ENABLE_SAMPLE
suffix:semicolon
id|mac_sound_timer.expires
op_assign
id|jiffies
op_plus
id|length
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|mac_sound_timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * regular ASC: stop whining ..&n; */
DECL|function|mac_nosound
r_static
r_void
id|mac_nosound
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
id|mac_asc_regs
(braket
id|ASC_ENABLE
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * EASC entry; init EASC, don&squot;t load wavetable, schedule &squot;start whining&squot;.&n; */
DECL|function|mac_quadra_start_bell
r_static
r_void
id|mac_quadra_start_bell
c_func
(paren
r_int
r_int
id|freq
comma
r_int
r_int
id|length
comma
r_int
r_int
id|volume
)paren
(brace
id|__u32
id|flags
suffix:semicolon
multiline_comment|/* if the bell is already ringing, ring longer */
r_if
c_cond
(paren
id|mac_bell_duration
OG
l_int|0
)paren
(brace
id|mac_bell_duration
op_add_assign
id|length
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mac_bell_duration
op_assign
id|length
suffix:semicolon
id|mac_bell_phase
op_assign
l_int|0
suffix:semicolon
id|mac_bell_phasepersample
op_assign
(paren
id|freq
op_star
r_sizeof
(paren
id|mac_asc_wave_tab
)paren
)paren
op_div
id|mac_asc_samplespersec
suffix:semicolon
multiline_comment|/* this is reasonably big for small frequencies */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set the volume */
id|mac_asc_regs
(braket
l_int|0x806
)braket
op_assign
id|volume
suffix:semicolon
multiline_comment|/* set up the ASC registers */
r_if
c_cond
(paren
id|mac_asc_regs
(braket
l_int|0x801
)braket
op_ne
l_int|1
)paren
(brace
multiline_comment|/* select mono mode */
id|mac_asc_regs
(braket
l_int|0x807
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* select sampled sound mode */
id|mac_asc_regs
(braket
l_int|0x802
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ??? */
id|mac_asc_regs
(braket
l_int|0x801
)braket
op_assign
l_int|1
suffix:semicolon
id|mac_asc_regs
(braket
l_int|0x803
)braket
op_or_assign
l_int|0x80
suffix:semicolon
id|mac_asc_regs
(braket
l_int|0x803
)braket
op_and_assign
l_int|0x7F
suffix:semicolon
)brace
id|mac_sound_timer.function
op_assign
id|mac_quadra_ring_bell
suffix:semicolon
id|mac_sound_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|mac_sound_timer
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * EASC &squot;start/continue whining&squot;; I&squot;m not sure why the above function didn&squot;t&n; * already load the wave table, or at least call this one... &n; * This piece keeps reloading the wave table until done.&n; */
DECL|function|mac_quadra_ring_bell
r_static
r_void
id|mac_quadra_ring_bell
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
r_int
id|i
comma
id|count
op_assign
id|mac_asc_samplespersec
op_div
id|HZ
suffix:semicolon
id|__u32
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * we neither want a sound buffer overflow nor underflow, so we need to match&n;&t; * the number of samples per timer interrupt as exactly as possible.&n;&t; * using the asc interrupt will give better results in the future&n;&t; * ...and the possibility to use a real sample (a boingy noise, maybe...)&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|mac_sound_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mac_bell_duration
op_decrement
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac_bell_phase
op_add_assign
id|mac_bell_phasepersample
suffix:semicolon
id|mac_asc_regs
(braket
l_int|0
)braket
op_assign
id|mac_asc_wave_tab
(braket
id|mac_bell_phase
op_amp
(paren
r_sizeof
(paren
id|mac_asc_wave_tab
)paren
op_minus
l_int|1
)paren
)braket
suffix:semicolon
)brace
id|mac_sound_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|mac_sound_timer
)paren
suffix:semicolon
)brace
r_else
id|mac_asc_regs
(braket
l_int|0x801
)braket
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * AV code - please fill in.&n; */
DECL|function|mac_av_start_bell
r_static
r_void
id|mac_av_start_bell
c_func
(paren
r_int
r_int
id|freq
comma
r_int
r_int
id|length
comma
r_int
r_int
id|volume
)paren
(brace
)brace
eof
