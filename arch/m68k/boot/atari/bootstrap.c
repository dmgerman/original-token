multiline_comment|/*&n;** bootstrap.c -- Load and launch the Atari Linux kernel&n;**&n;** Copyright 1993 by Arjan Knor&n;**&n;** This file is subject to the terms and conditions of the GNU General Public&n;** License.  See the file README.legal in the main directory of this archive&n;** for more details.&n;**&n;** History:&n;**  10 Dec 1995 BOOTP/TFTP support (Roman)&n;**&t;03 Oct 1995 Allow kernel to be loaded to TT ram again (Andreas)&n;**&t;11 Jul 1995 Add support for ELF format kernel (Andreas)&n;**&t;16 Jun 1995 Adapted to Linux 1.2: kernel always loaded into ST ram&n;**&t;&t;    (Andreas)&n;**      14 Nov 1994 YANML (Yet Another New Memory Layout :-) kernel&n;**&t;&t;    start address is KSTART_ADDR + PAGE_SIZE, this&n;**&t;&t;    does not need the ugly kludge with&n;**&t;&t;    -fwritable-strings (++andreas)&n;**      09 Sep 1994 Adapted to the new memory layout: All the boot_info entry&n;**                  mentions all ST-Ram and the mover is located somewhere&n;**                  in the middle of memory (roman)&n;**                  Added the default arguments file known from the other&n;**                  bootstrap version&n;**      19 Feb 1994 Changed everything so that it works? (rdv)&n;**      14 Mar 1994 New mini-copy routine used (rdv)&n;*/
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;stddef.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &quot;sysvars.h&quot;
macro_line|#include &lt;osbind.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/file.h&gt;
multiline_comment|/* linux specific include files */
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;asm/page.h&gt;
DECL|macro|_LINUX_TYPES_H
mdefine_line|#define _LINUX_TYPES_H&t;&t;/* Hack to prevent including &lt;linux/types.h&gt; */
macro_line|#include &lt;asm/bootinfo.h&gt;
multiline_comment|/* Atari bootstrap include file */
macro_line|#include &quot;bootstrap.h&quot;
DECL|macro|MIN_RAMSIZE
mdefine_line|#define MIN_RAMSIZE     (3)&t;/* 3 MB */
DECL|macro|TEMP_STACKSIZE
mdefine_line|#define TEMP_STACKSIZE 256
r_extern
r_char
op_star
id|optarg
suffix:semicolon
r_extern
r_int
id|optind
suffix:semicolon
r_static
r_void
id|get_default_args
c_func
(paren
r_int
op_star
id|argc
comma
r_char
op_star
op_star
op_star
id|argv
)paren
suffix:semicolon
multiline_comment|/* This is missing in &lt;unistd.h&gt; */
r_extern
r_int
id|sync
(paren
r_void
)paren
suffix:semicolon
DECL|variable|bi
r_struct
id|bootinfo
id|bi
suffix:semicolon
DECL|variable|cookiejar
id|u_long
op_star
id|cookiejar
suffix:semicolon
DECL|variable|userstk
id|u_long
id|userstk
suffix:semicolon
multiline_comment|/* getcookie -- function to get the value of the given cookie. */
DECL|function|getcookie
r_static
r_int
id|getcookie
c_func
(paren
r_char
op_star
id|cookie
comma
id|u_long
op_star
id|value
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cookiejar
(braket
id|i
)braket
op_ne
l_int|0L
)paren
(brace
r_if
c_cond
(paren
id|cookiejar
(braket
id|i
)braket
op_eq
op_star
(paren
id|u_long
op_star
)paren
id|cookie
)paren
(brace
op_star
id|value
op_assign
id|cookiejar
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|i
op_add_assign
l_int|2
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|usage
r_static
r_void
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage:&bslash;n&quot;
l_string|&quot;&bslash;tbootstrap [-dst] [-k kernel_executable] [-r ramdisk_file]&quot;
l_string|&quot; [option...]&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the kernel and the ramdisk to their final resting places.&n; *&n; * I assume that the kernel data and the ramdisk reside somewhere&n; * in the middle of the memory.&n; *&n; * This program itself should be somewhere in the first 4096 bytes of memory&n; * where the kernel never will be. In this way it can never be overwritten&n; * by itself.&n; *&n; * At this point the registers have:&n; * a0: the start of the final kernel&n; * a1: the start of the current kernel&n; * a2: the end of the final ramdisk&n; * a3: the end of the current ramdisk&n; * d0: the kernel size&n; * d1: the ramdisk size &n; */
id|asm
(paren
"&quot;"
dot
id|text
dot
id|globl
id|_copyall
comma
id|_copyallend
id|_copyall
suffix:colon
id|movel
id|a0
comma
id|a4
multiline_comment|/* save the start of the kernel for booting */
l_int|1
suffix:colon
id|movel
id|a1
"@"
op_plus
comma
id|a0
"@"
op_plus
multiline_comment|/* copy the kernel starting at the beginning */
id|subql
macro_line|#4,d0
id|jcc
l_int|1
id|b
id|tstl
id|d1
id|beq
l_float|3f
l_int|2
suffix:colon
id|movel
id|a3
"@"
op_minus
comma
id|a2
"@"
op_minus
multiline_comment|/* copy the ramdisk starting at the end */
id|subql
macro_line|#4,d1
id|jcc
l_int|2
id|b
l_int|3
suffix:colon
id|jmp
id|a4
"@"
multiline_comment|/* jump to the start of the kernel */
id|_copyallend
suffix:colon
"&quot;"
)paren
suffix:semicolon
r_extern
r_char
id|copyall
comma
id|copyallend
suffix:semicolon
multiline_comment|/* Test for a Medusa: This is the only machine on which address 0 is&n; * writeable!&n; * ...err! On the Afterburner040 (for the Falcon) it&squot;s the same... So we do&n; * another test with 0x00ff82fe, that gives a bus error on the Falcon, but is&n; * in the range where the Medusa always asserts DTACK.&n; */
DECL|function|test_medusa
r_int
id|test_medusa
c_func
(paren
r_void
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel&t;0x8,a0&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;sp,a1&bslash;n&bslash;t&quot;
l_string|&quot;moveb&t;0x0,d1&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;#Lberr,0x8&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%0&bslash;n&bslash;t&quot;
l_string|&quot;clrb&t;&t;0x0&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveb&t;d1,0x0&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;tstb&t;&t;0x00ff82fe&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#1,%0&bslash;n&quot;
l_string|&quot;Lberr:&bslash;t&quot;
l_string|&quot;movel&t;a1,sp&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;a0,0x8&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|rv
)paren
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;d1&quot;
comma
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|get_medusa_bank_sizes
r_void
id|get_medusa_bank_sizes
c_func
(paren
id|u_long
op_star
id|bank1
comma
id|u_long
op_star
id|bank2
)paren
(brace
r_static
id|u_long
id|save_addr
suffix:semicolon
id|u_long
id|test_base
comma
id|saved_contents
(braket
l_int|16
)braket
suffix:semicolon
DECL|macro|TESTADDR
mdefine_line|#define&t;TESTADDR(i)&t;(*((u_long *)((char *)test_base + i*8*MB)))
DECL|macro|TESTPAT
mdefine_line|#define&t;TESTPAT&t;&t;0x12345678
r_int
r_int
id|oldflags
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* This ensures at least that none of the test addresses conflicts&n;&t; * with the test code itself */
id|test_base
op_assign
(paren
(paren
r_int
r_int
)paren
op_amp
id|save_addr
op_amp
l_int|0x007fffff
)paren
op_or
l_int|0x20000000
suffix:semicolon
op_star
id|bank1
op_assign
op_star
id|bank2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Interrupts must be disabled because arbitrary addresses may be&n;&t; * temporarily overwritten, even code of an interrupt handler */
id|__asm__
id|__volatile__
(paren
l_string|&quot;movew sr,%0; oriw #0x700,sr&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|oldflags
)paren
suffix:colon
)paren
suffix:semicolon
id|disable_cache
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* save contents of the test addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|saved_contents
(braket
id|i
)braket
op_assign
id|TESTADDR
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* write 0s into all test addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TESTADDR
c_func
(paren
id|i
)paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* test for bank 1 */
macro_line|#if 0
multiline_comment|/* This is Freddi&squot;s original test, but it didn&squot;t work. */
id|TESTADDR
c_func
(paren
l_int|0
)paren
op_assign
id|TESTADDR
c_func
(paren
l_int|1
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|1
)paren
op_eq
id|TESTPAT
)paren
(brace
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|2
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|8
op_star
id|MB
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|3
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank1
op_assign
l_int|32
op_star
id|MB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|2
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|0
suffix:semicolon
r_else
op_star
id|bank1
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
)brace
macro_line|#else
id|TESTADDR
c_func
(paren
l_int|0
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|1
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|8
op_star
id|MB
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|2
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|4
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|32
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank1
op_assign
l_int|64
op_star
id|MB
suffix:semicolon
macro_line|#endif
multiline_comment|/* test for bank2 */
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|8
)paren
op_ne
l_int|0
)paren
op_star
id|bank2
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|TESTADDR
c_func
(paren
l_int|8
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|9
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|10
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank2
op_assign
l_int|8
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank2
op_assign
l_int|32
op_star
id|MB
suffix:semicolon
)brace
r_else
(brace
id|TESTADDR
c_func
(paren
l_int|9
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|10
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank2
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank2
op_assign
l_int|64
op_star
id|MB
suffix:semicolon
)brace
)brace
multiline_comment|/* restore contents of the test addresses and restore interrupt mask */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TESTADDR
c_func
(paren
id|i
)paren
op_assign
id|saved_contents
(braket
id|i
)braket
suffix:semicolon
)brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;movew %0,sr&quot;
suffix:colon
suffix:colon
l_string|&quot;g&quot;
(paren
id|oldflags
)paren
)paren
suffix:semicolon
)brace
DECL|macro|TESTADDR
macro_line|#undef TESTADDR
DECL|macro|TESTPAT
macro_line|#undef TESTPAT
macro_line|#ifdef USE_BOOTP
macro_line|# include &quot;bootp.h&quot;
macro_line|#else
DECL|macro|kread
macro_line|# define kread&t;read
DECL|macro|klseek
macro_line|# define klseek&t;lseek
DECL|macro|kclose
macro_line|# define kclose&t;close
macro_line|#endif
multiline_comment|/* ++andreas: this must be inline due to Super */
r_static
r_inline
r_void
id|boot_exit
(paren
r_int
)paren
id|__attribute__
(paren
(paren
id|noreturn
)paren
)paren
suffix:semicolon
DECL|function|boot_exit
r_static
r_inline
r_void
id|boot_exit
c_func
(paren
r_int
id|status
)paren
(brace
multiline_comment|/* first go back to user mode */
(paren
r_void
)paren
id|Super
c_func
(paren
id|userstk
)paren
suffix:semicolon
id|getchar
c_func
(paren
)paren
suffix:semicolon
m_exit
(paren
id|status
)paren
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|debugflag
op_assign
l_int|0
comma
id|ch
comma
id|kfd
comma
id|rfd
op_assign
op_minus
l_int|1
comma
id|i
comma
id|ignore_ttram
op_assign
l_int|0
suffix:semicolon
r_int
id|load_to_stram
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|ramdisk_name
comma
op_star
id|kernel_name
comma
op_star
id|memptr
suffix:semicolon
id|u_long
id|ST_ramsize
comma
id|TT_ramsize
comma
id|memreq
suffix:semicolon
id|u_long
id|cpu_type
comma
id|fpu_type
comma
id|mch_type
comma
id|mint
suffix:semicolon
r_struct
id|exec
id|kexec
suffix:semicolon
r_int
id|elf_kernel
op_assign
l_int|0
suffix:semicolon
id|Elf32_Ehdr
id|kexec_elf
suffix:semicolon
id|Elf32_Phdr
op_star
id|kernel_phdrs
op_assign
l_int|NULL
suffix:semicolon
id|u_long
id|start_mem
comma
id|mem_size
comma
id|rd_size
comma
id|text_offset
op_assign
l_int|0
comma
id|kernel_size
suffix:semicolon
macro_line|#ifdef USE_BOOTP
r_int
id|prefer_bootp
op_assign
l_int|1
comma
id|kname_set
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ramdisk_name
op_assign
l_int|NULL
suffix:semicolon
id|kernel_name
op_assign
l_string|&quot;vmlinux&quot;
suffix:semicolon
multiline_comment|/* print the startup message */
id|puts
c_func
(paren
l_string|&quot;&bslash;fLinux/68k Atari Bootstrap version 1.6&quot;
macro_line|#ifdef USE_BOOTP
l_string|&quot; (with BOOTP)&quot;
macro_line|#endif
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;Copyright 1993,1994 by Arjan Knor, Robert de Vries, Roman Hodek, Andreas Schwab&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ++roman: If no arguments on the command line, read them from&n;&t; * file */
r_if
c_cond
(paren
id|argc
op_eq
l_int|1
)paren
id|get_default_args
c_func
(paren
op_amp
id|argc
comma
op_amp
id|argv
)paren
suffix:semicolon
multiline_comment|/* machine is Atari */
id|bi.machtype
op_assign
id|MACH_ATARI
suffix:semicolon
multiline_comment|/* check arguments */
macro_line|#ifdef USE_BOOTP
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;bdtsk:r:&quot;
)paren
)paren
op_ne
id|EOF
)paren
macro_line|#else
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;dtsk:r:&quot;
)paren
)paren
op_ne
id|EOF
)paren
macro_line|#endif
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
id|debugflag
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|ignore_ttram
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|load_to_stram
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;k&squot;
suffix:colon
id|kernel_name
op_assign
id|optarg
suffix:semicolon
macro_line|#ifdef USE_BOOTP
id|kname_set
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|ramdisk_name
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef USE_BOOTP
r_case
l_char|&squot;b&squot;
suffix:colon
id|prefer_bootp
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_char|&squot;?&squot;
suffix:colon
r_default
suffix:colon
id|usage
c_func
(paren
)paren
suffix:semicolon
)brace
id|argc
op_sub_assign
id|optind
suffix:semicolon
id|argv
op_add_assign
id|optind
suffix:semicolon
multiline_comment|/* We have to access some system variables to get&n;     * the information we need, so we must switch to&n;     * supervisor mode first.&n;     */
id|userstk
op_assign
id|Super
c_func
(paren
l_int|0L
)paren
suffix:semicolon
multiline_comment|/* get the info we need from the cookie-jar */
id|cookiejar
op_assign
op_star
id|_p_cookies
suffix:semicolon
r_if
c_cond
(paren
id|cookiejar
op_eq
l_int|0L
)paren
(brace
multiline_comment|/* if we find no cookies, it&squot;s probably an ST */
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Error: No cookiejar found. Is this an ST?&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* Exit if MiNT/MultiTOS is running.  */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;MiNT&quot;
comma
op_amp
id|mint
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Warning: MiNT is running&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
id|puts
c_func
(paren
l_string|&quot;Linux cannot be started when MiNT is running. Aborting...&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* get _CPU, _FPU and _MCH */
id|getcookie
c_func
(paren
l_string|&quot;_CPU&quot;
comma
op_amp
id|cpu_type
)paren
suffix:semicolon
id|getcookie
c_func
(paren
l_string|&quot;_FPU&quot;
comma
op_amp
id|fpu_type
)paren
suffix:semicolon
id|getcookie
c_func
(paren
l_string|&quot;_MCH&quot;
comma
op_amp
id|mch_type
)paren
suffix:semicolon
multiline_comment|/* check if we are on a 68030/40 with FPU */
r_if
c_cond
(paren
(paren
id|cpu_type
op_ne
l_int|30
op_logical_and
id|cpu_type
op_ne
l_int|40
op_logical_and
id|cpu_type
op_ne
l_int|60
)paren
op_logical_or
(paren
id|fpu_type
op_rshift
l_int|16
)paren
OL
l_int|2
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Machine type currently not supported. Aborting...&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cpu_type
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|10
suffix:colon
r_break
suffix:semicolon
r_case
l_int|20
suffix:colon
id|bi.cputype
op_assign
id|CPU_68020
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|30
suffix:colon
id|bi.cputype
op_assign
id|CPU_68030
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|40
suffix:colon
id|bi.cputype
op_assign
id|CPU_68040
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|60
suffix:colon
id|bi.cputype
op_assign
id|CPU_68060
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Error: Unknown CPU type. Aborting...&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;CPU: %ld; &quot;
comma
id|cpu_type
op_plus
l_int|68000
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;FPU: &quot;
)paren
suffix:semicolon
multiline_comment|/* check for FPU; in case of a &squot;040 or &squot;060, don&squot;t look at _FPU itself,&n;     * some software may set it to wrong values (68882 or the like) */
r_if
c_cond
(paren
id|cpu_type
op_eq
l_int|40
)paren
(brace
id|bi.cputype
op_or_assign
id|FPU_68040
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68040&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cpu_type
op_eq
l_int|60
)paren
(brace
id|bi.cputype
op_or_assign
id|FPU_68060
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68060&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
(paren
id|fpu_type
op_rshift
l_int|16
)paren
op_amp
l_int|6
)paren
(brace
r_case
l_int|0
suffix:colon
id|puts
c_func
(paren
l_string|&quot;not present&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* try to determine real type */
r_if
c_cond
(paren
id|fpu_idle_frame_size
(paren
)paren
op_ne
l_int|0x18
)paren
r_goto
id|m68882
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|4
suffix:colon
id|bi.cputype
op_or_assign
id|FPU_68881
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68881&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|m68882
suffix:colon
id|bi.cputype
op_or_assign
id|FPU_68882
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68882&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Unknown FPU type. Assuming no FPU.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
op_amp
id|bi.bi_atari.hw_present
comma
l_int|0
comma
r_sizeof
(paren
id|bi.bi_atari.hw_present
)paren
)paren
suffix:semicolon
multiline_comment|/* Get the amounts of ST- and TT-RAM. */
multiline_comment|/* The size must be a multiple of 1MB. */
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_medusa
c_func
(paren
)paren
)paren
(brace
r_struct
(brace
r_int
r_int
id|version
suffix:semicolon
multiline_comment|/* version - currently 1 */
r_int
r_int
id|fr_start
suffix:semicolon
multiline_comment|/* start addr FastRAM */
r_int
r_int
id|fr_len
suffix:semicolon
multiline_comment|/* length FastRAM */
)brace
op_star
id|magn_cookie
suffix:semicolon
r_struct
(brace
r_int
r_int
id|version
suffix:semicolon
r_int
r_int
id|fr_start
suffix:semicolon
multiline_comment|/* start addr */
r_int
r_int
id|fr_len
suffix:semicolon
multiline_comment|/* length */
)brace
op_star
id|fx_cookie
suffix:semicolon
id|TT_ramsize
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ignore_ttram
)paren
(brace
multiline_comment|/* &quot;Original&quot; or properly emulated TT-Ram */
r_if
c_cond
(paren
op_star
id|ramtop
)paren
(brace
multiline_comment|/* the &squot;ramtop&squot; variable at 0x05a4 is not&n;&t;&t; * officially documented. We use it anyway&n;&t;&t; * because it is the only way to get the TTram size.&n;&t;&t; * (It is zero if there is no TTram.)&n;&t;&t; */
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|TT_RAM_BASE
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
(paren
op_star
id|ramtop
op_minus
id|TT_RAM_BASE
)paren
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|TT_ramsize
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;TT-RAM: %ld Mb; &quot;
comma
id|TT_ramsize
)paren
suffix:semicolon
)brace
multiline_comment|/* test for MAGNUM alternate RAM&n;&t;     * added 26.9.1995 M. Schwingen, rincewind@discworld.oche.de&n;&t;     */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;MAGN&quot;
comma
(paren
id|u_long
op_star
)paren
op_amp
id|magn_cookie
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|magn_cookie-&gt;fr_start
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|magn_cookie-&gt;fr_len
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|TT_ramsize
op_add_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;MAGNUM alternate RAM: %ld Mb; &quot;
comma
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* BlowUps FX */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;BPFX&quot;
comma
(paren
id|u_long
op_star
)paren
op_amp
id|fx_cookie
)paren
op_ne
op_minus
l_int|1
op_logical_and
id|fx_cookie
)paren
(brace
multiline_comment|/* if fx is set (cookie call above),&n;&t;&t; * we assume that BlowUps FX-card&n;&t;&t; * is installed. (Nat!)&n;&t;&t; */
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|fx_cookie-&gt;fr_start
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|fx_cookie-&gt;fr_len
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;FX alternate RAM: %ld Mb; &quot;
comma
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
op_star
id|phystop
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|ST_ramsize
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ST-RAM: %ld Mb&bslash;n&quot;
comma
id|ST_ramsize
)paren
suffix:semicolon
id|bi.num_memory
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|load_to_stram
op_logical_and
id|i
OG
l_int|1
)paren
(brace
multiline_comment|/* Put ST-RAM first in the list of mem blocks */
r_struct
id|mem_info
id|temp
op_assign
id|bi.memory
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|bi.memory
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|bi.memory
(braket
l_int|0
)braket
suffix:semicolon
id|bi.memory
(braket
l_int|0
)braket
op_assign
id|temp
suffix:semicolon
)brace
)brace
r_else
(brace
id|u_long
id|bank1
comma
id|bank2
comma
id|medusa_st_ram
suffix:semicolon
id|get_medusa_bank_sizes
c_func
(paren
op_amp
id|bank1
comma
op_amp
id|bank2
)paren
suffix:semicolon
id|medusa_st_ram
op_assign
op_star
id|phystop
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|bank1
op_sub_assign
id|medusa_st_ram
suffix:semicolon
id|TT_ramsize
op_assign
l_int|0
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|medusa_st_ram
suffix:semicolon
id|ST_ramsize
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Medusa pseudo ST-RAM from bank 1: %ld Mb; &quot;
comma
id|ST_ramsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ignore_ttram
op_logical_and
id|bank1
OG
l_int|0
)paren
(brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0x20000000
op_plus
id|medusa_st_ram
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|bank1
suffix:semicolon
id|TT_ramsize
op_add_assign
id|bank1
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;TT-RAM bank 1: %ld Mb; &quot;
comma
id|bank1
op_div
id|MB
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ignore_ttram
op_logical_and
id|bank2
OG
l_int|0
)paren
(brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0x24000000
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|bank2
suffix:semicolon
id|TT_ramsize
op_add_assign
id|bank2
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;TT-RAM bank 2: %ld Mb; &quot;
comma
id|bank2
op_div
id|MB
)paren
suffix:semicolon
)brace
id|bi.num_memory
op_assign
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* verify that there is enough RAM; ST- and TT-RAM combined */
r_if
c_cond
(paren
id|ST_ramsize
op_plus
id|TT_ramsize
OL
id|MIN_RAMSIZE
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Not enough RAM. Aborting...&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;
multiline_comment|/* Get language/keyboard info */
multiline_comment|/* TODO: do we need this ? */
multiline_comment|/* Could be used to auto-select keyboard map later on. (rdv) */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;_AKP&quot;
comma
op_amp
id|language
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Get the language info from the OS-header */
id|os_header
op_assign
op_star
id|_sysbase
suffix:semicolon
id|os_header
op_assign
id|os_header-&gt;os_beg
suffix:semicolon
id|lang
op_assign
(paren
id|os_header-&gt;os_conf
)paren
op_rshift
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Language: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lang
)paren
(brace
r_case
id|HOL
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Dutch&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Own country first :-) */
r_case
id|USA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;American&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWG
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Switzerland (German)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FRG
suffix:colon
id|puts
c_func
(paren
l_string|&quot;German&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FRA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;French&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWF
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Switzerland (French)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UK
suffix:colon
id|puts
c_func
(paren
l_string|&quot;English&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Spanish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ITA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Italian&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWE
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Swedish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TUR
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Turkey&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIN
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Finnish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NOR
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Norwegian&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEN
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Danish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAU
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Saudi-Arabian&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Language: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|language
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|1
suffix:colon
id|printf
c_func
(paren
l_string|&quot;German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printf
c_func
(paren
l_string|&quot;French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Spanish &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Italian &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;English &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Keyboard type :&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|language
op_rshift
l_int|8
)paren
(brace
r_case
l_int|1
suffix:colon
id|printf
c_func
(paren
l_string|&quot;German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printf
c_func
(paren
l_string|&quot;French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Spanish &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Italian &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;English &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Pass contents of the _MCH cookie to the kernel */
id|bi.bi_atari.mch_cookie
op_assign
id|mch_type
suffix:semicolon
multiline_comment|/*&n;     * Copy command line options into the kernel command line.&n;     */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_plus
id|strlen
c_func
(paren
op_star
id|argv
)paren
op_plus
l_int|1
)paren
OL
id|CL_SIZE
)paren
(brace
id|i
op_add_assign
id|strlen
c_func
(paren
op_star
id|argv
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bi.command_line
(braket
l_int|0
)braket
)paren
id|strcat
(paren
id|bi.command_line
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|strcat
(paren
id|bi.command_line
comma
op_star
id|argv
op_increment
)paren
suffix:semicolon
)brace
)brace
id|printf
(paren
l_string|&quot;Command line is &squot;%s&squot;&bslash;n&quot;
comma
id|bi.command_line
)paren
suffix:semicolon
id|start_mem
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|addr
suffix:semicolon
id|mem_size
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
multiline_comment|/* tell us where the kernel will go */
id|printf
c_func
(paren
l_string|&quot;&bslash;nThe kernel will be located at 0x%08lx&bslash;n&quot;
comma
id|start_mem
)paren
suffix:semicolon
macro_line|#ifdef TEST
multiline_comment|/*&n;    ** Temporary exit point for testing&n;    */
id|boot_exit
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* TEST */
macro_line|#ifdef USE_BOOTP
id|kfd
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|prefer_bootp
)paren
(brace
multiline_comment|/* First try to get a remote kernel, then use a local kernel (if&n;&t; * present) */
r_if
c_cond
(paren
id|get_remote_kernel
c_func
(paren
id|kname_set
ques
c_cond
id|kernel_name
suffix:colon
l_int|NULL
)paren
OL
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nremote boot failed; trying local kernel&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|kfd
op_assign
id|open
(paren
id|kernel_name
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to open kernel file %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Try BOOTP if local kernel cannot be opened */
r_if
c_cond
(paren
(paren
id|kfd
op_assign
id|open
(paren
id|kernel_name
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nlocal kernel failed; trying remote boot&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_remote_kernel
c_func
(paren
id|kname_set
ques
c_cond
id|kernel_name
suffix:colon
l_int|NULL
)paren
OL
l_int|0
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to remote boot and &quot;
l_string|&quot;to open kernel file %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#else
multiline_comment|/* open kernel executable and read exec header */
r_if
c_cond
(paren
(paren
id|kfd
op_assign
id|open
(paren
id|kernel_name
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to open kernel file %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
op_amp
id|kexec
comma
r_sizeof
(paren
id|kexec
)paren
)paren
op_ne
r_sizeof
(paren
id|kexec
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to read exec header from %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
(brace
r_case
id|ZMAGIC
suffix:colon
id|text_offset
op_assign
id|N_TXTOFF
c_func
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QMAGIC
suffix:colon
id|text_offset
op_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
multiline_comment|/* the text size includes the exec header; remove this */
id|kexec.a_text
op_sub_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Try to parse it as an ELF header */
id|klseek
(paren
id|kfd
comma
l_int|0
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
op_amp
id|kexec_elf
comma
r_sizeof
(paren
id|kexec_elf
)paren
)paren
op_eq
r_sizeof
(paren
id|kexec_elf
)paren
op_logical_and
id|memcmp
(paren
op_amp
id|kexec_elf.e_ident
(braket
id|EI_MAG0
)braket
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_eq
l_int|0
)paren
(brace
id|elf_kernel
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* A few plausibility checks */
r_if
c_cond
(paren
id|kexec_elf.e_type
op_ne
id|ET_EXEC
op_logical_or
id|kexec_elf.e_machine
op_ne
id|EM_68K
op_logical_or
id|kexec_elf.e_version
op_ne
id|EV_CURRENT
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Invalid ELF header contents in kernel&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* Load the program headers */
id|kernel_phdrs
op_assign
(paren
id|Elf32_Phdr
op_star
)paren
id|Malloc
(paren
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
id|Elf32_Phdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kernel_phdrs
op_eq
l_int|NULL
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to allocate memory for program headers&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|klseek
(paren
id|kfd
comma
id|kexec_elf.e_phoff
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
id|kernel_phdrs
comma
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
op_star
id|kernel_phdrs
)paren
)paren
op_ne
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
op_star
id|kernel_phdrs
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to read program headers from %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Wrong magic number %lo in kernel header&bslash;n&quot;
comma
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* Load the kernel one page after start of mem */
id|start_mem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|mem_size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Align bss size to multiple of four */
r_if
c_cond
(paren
op_logical_neg
id|elf_kernel
)paren
id|kexec.a_bss
op_assign
(paren
id|kexec.a_bss
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* init ramdisk */
r_if
c_cond
(paren
id|ramdisk_name
)paren
(brace
r_if
c_cond
(paren
(paren
id|rfd
op_assign
id|open
c_func
(paren
id|ramdisk_name
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Unable to open ramdisk file %s&bslash;n&quot;
comma
id|ramdisk_name
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|bi.ramdisk_size
op_assign
(paren
id|lseek
c_func
(paren
id|rfd
comma
l_int|0
comma
id|SEEK_END
)paren
op_plus
l_int|1023
)paren
op_div
l_int|1024
suffix:semicolon
)brace
r_else
id|bi.ramdisk_size
op_assign
l_int|0
suffix:semicolon
id|rd_size
op_assign
id|bi.ramdisk_size
op_lshift
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|mem_size
op_minus
id|rd_size
template_param
l_int|1
)paren
multiline_comment|/* If running low on ST ram load ramdisk into alternate ram.  */
id|bi.ramdisk_addr
op_assign
(paren
id|u_long
)paren
id|bi.memory
(braket
l_int|1
)braket
dot
id|addr
op_plus
id|bi.memory
(braket
l_int|1
)braket
dot
id|size
op_minus
id|rd_size
suffix:semicolon
r_else
multiline_comment|/* Else hopefully there is enough ST ram. */
id|bi.ramdisk_addr
op_assign
(paren
id|u_long
)paren
id|start_mem
op_plus
id|mem_size
op_minus
id|rd_size
suffix:semicolon
multiline_comment|/* calculate the total required amount of memory */
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
id|u_long
id|min_addr
op_assign
l_int|0xffffffff
comma
id|max_addr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|min_addr
OG
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
)paren
id|min_addr
op_assign
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|max_addr
OL
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
)paren
id|max_addr
op_assign
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
suffix:semicolon
)brace
multiline_comment|/* This is needed for newer linkers that include the header in&n;&t;   the first segment.  */
r_if
c_cond
(paren
id|min_addr
op_eq
l_int|0
)paren
(brace
id|min_addr
op_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_offset
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_filesz
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_memsz
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|kernel_size
op_assign
id|max_addr
op_minus
id|min_addr
suffix:semicolon
)brace
r_else
id|kernel_size
op_assign
id|kexec.a_text
op_plus
id|kexec.a_data
op_plus
id|kexec.a_bss
suffix:semicolon
id|memreq
op_assign
id|kernel_size
op_plus
r_sizeof
(paren
id|bi
)paren
op_plus
id|rd_size
suffix:semicolon
multiline_comment|/* allocate RAM for the kernel */
r_if
c_cond
(paren
op_logical_neg
(paren
id|memptr
op_assign
(paren
r_char
op_star
)paren
id|Malloc
(paren
id|memreq
)paren
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to allocate memory for kernel and ramdisk&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;kernel at address %lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|memptr
)paren
suffix:semicolon
(paren
r_void
)paren
id|memset
c_func
(paren
id|memptr
comma
l_int|0
comma
id|memreq
)paren
suffix:semicolon
multiline_comment|/* read the text and data segments from the kernel image */
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|klseek
(paren
id|kfd
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_offset
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to segment %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
id|memptr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_minus
id|PAGE_SIZE
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_filesz
)paren
op_ne
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_filesz
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read segment %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|klseek
(paren
id|kfd
comma
id|text_offset
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to text&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
id|memptr
comma
id|kexec.a_text
)paren
op_ne
id|kexec.a_text
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read text&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* data follows immediately after text */
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
id|memptr
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
op_ne
id|kexec.a_data
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read data&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
id|kclose
(paren
id|kfd
)paren
suffix:semicolon
multiline_comment|/* copy the boot_info struct to the end of the kernel image */
id|memcpy
(paren
(paren
r_void
op_star
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
comma
op_amp
id|bi
comma
r_sizeof
(paren
id|bi
)paren
)paren
suffix:semicolon
multiline_comment|/* read the ramdisk image */
r_if
c_cond
(paren
id|rfd
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|lseek
(paren
id|rfd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to beginning of ramdisk file&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read
(paren
id|rfd
comma
id|memptr
op_plus
id|kernel_size
op_plus
r_sizeof
(paren
id|bi
)paren
comma
id|rd_size
)paren
op_ne
id|rd_size
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read ramdisk file&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|close
(paren
id|rfd
)paren
suffix:semicolon
)brace
multiline_comment|/* for those who want to debug */
r_if
c_cond
(paren
id|debugflag
)paren
(brace
r_if
c_cond
(paren
id|bi.ramdisk_size
)paren
id|printf
(paren
l_string|&quot;RAM disk at %#lx, size is %ldK&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|memptr
op_plus
id|kernel_size
comma
id|bi.ramdisk_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
(paren
l_string|&quot;Kernel segment %d at %#lx, size %ld&bslash;n&quot;
comma
id|i
comma
id|start_mem
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_minus
id|PAGE_SIZE
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printf
(paren
l_string|&quot;&bslash;nKernel text at %#lx, code size %d&bslash;n&quot;
comma
id|start_mem
comma
id|kexec.a_text
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Kernel data at %#lx, data size %d&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Kernel bss  at %#lx, bss  size %d&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
comma
id|kexec.a_bss
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;&bslash;nboot_info is at %#lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|kernel_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;nKernel entry is %#lx&bslash;n&quot;
comma
id|elf_kernel
ques
c_cond
id|kexec_elf.e_entry
suffix:colon
id|kexec.a_entry
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk dest top is %#lx&bslash;n&quot;
comma
id|bi.ramdisk_addr
op_plus
id|rd_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk lower limit is %#lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk src top is %#lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
op_plus
id|rd_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Type a key to continue the Linux boot...&quot;
)paren
suffix:semicolon
id|fflush
(paren
id|stdout
)paren
suffix:semicolon
id|getchar
c_func
(paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Booting Linux...&bslash;n&quot;
)paren
suffix:semicolon
id|sync
(paren
)paren
suffix:semicolon
multiline_comment|/* turn off interrupts... */
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* turn off caches... */
id|disable_cache
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ..and any MMU translation */
id|disable_mmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ++guenther: allow reset if launched with MiNT */
op_star
(paren
r_int
op_star
)paren
l_int|0x426
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* copy mover code to a safe place if needed */
id|memcpy
(paren
(paren
r_void
op_star
)paren
l_int|0x400
comma
op_amp
id|copyall
comma
op_amp
id|copyallend
op_minus
op_amp
id|copyall
)paren
suffix:semicolon
multiline_comment|/* setup stack */
id|change_stack
(paren
(paren
r_void
op_star
)paren
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;     * On the Atari you can have two situations:&n;     * 1. One piece of contiguous RAM (Falcon)&n;     * 2. Two pieces of contiguous RAM (TT)&n;     * In case 2 you can load your program into ST-ram and load your data in&n;     * any old RAM you have left.&n;     * In case 1 you could overwrite your own program when copying the&n;     * kernel and ramdisk to their final positions.&n;     * To solve this the mover code is copied to a safe place first.&n;     * Then this program jumps to the mover code. After the mover code&n;     * has finished it jumps to the start of the kernel in its new position.&n;     * I thought the memory just after the interrupt vector table was a safe&n;     * place because it is used by TOS to store some system variables.&n;     * This range goes from 0x400 to approx. 0x5B0.&n;     * This is more than enough for the miniscule mover routine (16 bytes).&n;     */
id|jump_to_mover
c_func
(paren
(paren
r_char
op_star
)paren
id|start_mem
comma
id|memptr
comma
(paren
r_char
op_star
)paren
id|bi.ramdisk_addr
op_plus
id|rd_size
comma
id|memptr
op_plus
id|memreq
comma
id|kernel_size
op_plus
r_sizeof
(paren
id|bi
)paren
comma
id|rd_size
comma
(paren
r_void
op_star
)paren
l_int|0x400
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
DECL|macro|MAXARGS
mdefine_line|#define&t;MAXARGS&t;&t;30
DECL|function|get_default_args
r_static
r_void
id|get_default_args
c_func
(paren
r_int
op_star
id|argc
comma
r_char
op_star
op_star
op_star
id|argv
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_static
r_char
op_star
id|nargv
(braket
id|MAXARGS
)braket
suffix:semicolon
r_char
id|arg
(braket
l_int|256
)braket
comma
op_star
id|p
suffix:semicolon
r_int
id|c
comma
id|quote
comma
id|state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen
c_func
(paren
l_string|&quot;bootargs&quot;
comma
l_string|&quot;r&quot;
)paren
)paren
)paren
r_return
suffix:semicolon
op_star
id|argc
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
op_star
op_star
id|argv
)paren
id|nargv
(braket
l_int|0
)braket
op_assign
op_star
op_star
id|argv
suffix:semicolon
r_else
id|nargv
(braket
l_int|0
)braket
op_assign
l_string|&quot;bootstrap&quot;
suffix:semicolon
op_star
id|argv
op_assign
id|nargv
suffix:semicolon
id|quote
op_assign
id|state
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|arg
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|fgetc
c_func
(paren
id|f
)paren
)paren
op_ne
id|EOF
)paren
(brace
r_if
c_cond
(paren
id|state
op_eq
l_int|0
)paren
(brace
multiline_comment|/* outside args, skip whitespace */
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|state
op_assign
l_int|1
suffix:semicolon
id|p
op_assign
id|arg
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/* inside an arg: copy it into &squot;arg&squot;, obeying quoting */
r_if
c_cond
(paren
op_logical_neg
id|quote
op_logical_and
(paren
id|c
op_eq
l_char|&squot;&bslash;&squot;&squot;
op_logical_or
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
)paren
id|quote
op_assign
id|c
suffix:semicolon
r_else
r_if
c_cond
(paren
id|quote
op_logical_and
id|c
op_eq
id|quote
)paren
id|quote
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|quote
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
multiline_comment|/* end of this arg */
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|nargv
(braket
(paren
op_star
id|argc
)paren
op_increment
)braket
op_assign
id|strdup
c_func
(paren
id|arg
)paren
suffix:semicolon
id|state
op_assign
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/* last arg finished by EOF! */
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|nargv
(braket
(paren
op_star
id|argc
)paren
op_increment
)braket
op_assign
id|strdup
c_func
(paren
id|arg
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
id|nargv
(braket
op_star
id|argc
)braket
op_assign
l_int|0
suffix:semicolon
)brace
eof
