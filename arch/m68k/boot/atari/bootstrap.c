multiline_comment|/*&n;** bootstrap.c -- Load and launch the Atari Linux kernel&n;**&n;** Copyright 1993 by Arjan Knor&n;**&n;** This file is subject to the terms and conditions of the GNU General Public&n;** License.  See the file COPYING in the main directory of this archive&n;** for more details.&n;**&n;** History:&n;**&t;01 Feb 1997 Implemented kernel decompression (Roman)&n;**&t;28 Nov 1996 Fixed and tested previous change (James)&n;**&t;27 Nov 1996 Compatibility with bootinfo interface version 1.0 (Geert)&n;**&t;12 Nov 1996 Fixed and tested previous change (Andreas)&n;**&t;18 Aug 1996 Updated for the new boot information structure (untested!)&n;**&t;&t;    (Geert)&n;**&t;10 Dec 1995 BOOTP/TFTP support (Roman)&n;**&t;03 Oct 1995 Allow kernel to be loaded to TT ram again (Andreas)&n;**&t;11 Jul 1995 Add support for ELF format kernel (Andreas)&n;**&t;16 Jun 1995 Adapted to Linux 1.2: kernel always loaded into ST ram&n;**&t;&t;    (Andreas)&n;**      14 Nov 1994 YANML (Yet Another New Memory Layout :-) kernel&n;**&t;&t;    start address is KSTART_ADDR + PAGE_SIZE, this&n;**&t;&t;    does not need the ugly kludge with&n;**&t;&t;    -fwritable-strings (++andreas)&n;**      09 Sep 1994 Adapted to the new memory layout: All the boot_info entry&n;**                  mentions all ST-Ram and the mover is located somewhere&n;**                  in the middle of memory (roman)&n;**                  Added the default arguments file known from the other&n;**                  bootstrap version&n;**      19 Feb 1994 Changed everything so that it works? (rdv)&n;**      14 Mar 1994 New mini-copy routine used (rdv)&n;*/
DECL|macro|BOOTINFO_COMPAT_1_0
mdefine_line|#define BOOTINFO_COMPAT_1_0&t;/* bootinfo interface version 1.0 compatible */
multiline_comment|/* support compressed kernels? */
DECL|macro|ZKERNEL
mdefine_line|#define ZKERNEL
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;stddef.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &quot;sysvars.h&quot;
macro_line|#include &lt;osbind.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/file.h&gt;
multiline_comment|/* linux specific include files */
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;asm/page.h&gt;
DECL|macro|_LINUX_TYPES_H
mdefine_line|#define _LINUX_TYPES_H&t;&t;/* Hack to prevent including &lt;linux/types.h&gt; */
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
multiline_comment|/* Atari bootstrap include file */
macro_line|#include &quot;bootstrap.h&quot;
DECL|macro|MIN_RAMSIZE
mdefine_line|#define MIN_RAMSIZE     (3)&t;/* 3 MB */
DECL|macro|TEMP_STACKSIZE
mdefine_line|#define TEMP_STACKSIZE 256
r_extern
r_char
op_star
id|optarg
suffix:semicolon
r_extern
r_int
id|optind
suffix:semicolon
r_static
r_void
id|get_default_args
c_func
(paren
r_int
op_star
id|argc
comma
r_char
op_star
op_star
op_star
id|argv
)paren
suffix:semicolon
r_static
r_int
id|create_bootinfo
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_static
r_int
id|create_compat_bootinfo
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
r_static
r_int
id|add_bi_record
c_func
(paren
id|u_short
id|tag
comma
id|u_short
id|size
comma
r_const
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|add_bi_string
c_func
(paren
id|u_short
id|tag
comma
r_const
id|u_char
op_star
id|s
)paren
suffix:semicolon
multiline_comment|/* This is missing in &lt;unistd.h&gt; */
r_extern
r_int
id|sync
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Bootinfo */
DECL|variable|bi
r_static
r_struct
id|atari_bootinfo
id|bi
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
DECL|variable|compat_bootinfo
r_static
r_struct
id|compat_bootinfo
id|compat_bootinfo
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
DECL|macro|MAX_BI_SIZE
mdefine_line|#define MAX_BI_SIZE     (4096)
DECL|variable|bi_size
r_static
id|u_long
id|bi_size
suffix:semicolon
r_static
r_union
(brace
DECL|member|record
r_struct
id|bi_record
id|record
suffix:semicolon
DECL|member|fake
id|u_char
id|fake
(braket
id|MAX_BI_SIZE
)braket
suffix:semicolon
DECL|variable|bi_union
)brace
id|bi_union
suffix:semicolon
DECL|variable|cookiejar
id|u_long
op_star
id|cookiejar
suffix:semicolon
DECL|variable|userstk
id|u_long
id|userstk
suffix:semicolon
multiline_comment|/* getcookie -- function to get the value of the given cookie. */
DECL|function|getcookie
r_static
r_int
id|getcookie
c_func
(paren
r_char
op_star
id|cookie
comma
id|u_long
op_star
id|value
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cookiejar
(braket
id|i
)braket
op_ne
l_int|0L
)paren
(brace
r_if
c_cond
(paren
id|cookiejar
(braket
id|i
)braket
op_eq
op_star
(paren
id|u_long
op_star
)paren
id|cookie
)paren
(brace
op_star
id|value
op_assign
id|cookiejar
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|i
op_add_assign
l_int|2
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|usage
r_static
r_void
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage:&bslash;n&quot;
l_string|&quot;&bslash;tbootstrap [-dst] [-k kernel_executable] [-r ramdisk_file]&quot;
l_string|&quot; [option...]&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the kernel and the ramdisk to their final resting places.&n; *&n; * I assume that the kernel data and the ramdisk reside somewhere&n; * in the middle of the memory.&n; *&n; * This program itself should be somewhere in the first 4096 bytes of memory&n; * where the kernel never will be. In this way it can never be overwritten&n; * by itself.&n; *&n; * At this point the registers have:&n; * a0: the start of the final kernel&n; * a1: the start of the current kernel&n; * a2: the end of the final ramdisk&n; * a3: the end of the current ramdisk&n; * d0: the kernel size&n; * d1: the ramdisk size &n; */
id|asm
(paren
"&quot;"
dot
id|text
dot
id|globl
id|_copyall
comma
id|_copyallend
id|_copyall
suffix:colon
id|movel
id|a0
comma
id|a4
multiline_comment|/* save the start of the kernel for booting */
l_int|1
suffix:colon
id|movel
id|a1
"@"
op_plus
comma
id|a0
"@"
op_plus
multiline_comment|/* copy the kernel starting at the beginning */
id|subql
macro_line|#4,d0
id|jcc
l_int|1
id|b
id|tstl
id|d1
id|beq
l_float|3f
l_int|2
suffix:colon
id|movel
id|a3
"@"
op_minus
comma
id|a2
"@"
op_minus
multiline_comment|/* copy the ramdisk starting at the end */
id|subql
macro_line|#4,d1
id|jcc
l_int|2
id|b
l_int|3
suffix:colon
id|jmp
id|a4
"@"
multiline_comment|/* jump to the start of the kernel */
id|_copyallend
suffix:colon
"&quot;"
)paren
suffix:semicolon
r_extern
r_char
id|copyall
comma
id|copyallend
suffix:semicolon
multiline_comment|/* Test for a Medusa: This is the only machine on which address 0 is&n; * writeable!&n; * ...err! On the Afterburner040 (for the Falcon) it&squot;s the same... So we do&n; * another test with 0x00ff82fe, that gives a bus error on the Falcon, but is&n; * in the range where the Medusa always asserts DTACK.&n; * On the Hades address 0 is writeable as well and it asserts DTACK on&n; * address 0x00ff82fe. To test if the machine is a Hades, address 0xb0000000&n; * is tested. On the Medusa this gives a bus error.&n; */
DECL|function|test_medusa
r_int
id|test_medusa
c_func
(paren
r_void
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel&t;0x8,a0&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;sp,a1&bslash;n&bslash;t&quot;
l_string|&quot;moveb&t;0x0,d1&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;#Lberr,0x8&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%0&bslash;n&bslash;t&quot;
l_string|&quot;clrb&t;&t;0x0&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveb&t;d1,0x0&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;tstb&t;&t;0x00ff82fe&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#1,%0&bslash;n&bslash;t&quot;
l_string|&quot;tstb&t;&t;0xb0000000&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%0&bslash;n&quot;
l_string|&quot;Lberr:&bslash;t&quot;
l_string|&quot;movel&t;a1,sp&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;a0,0x8&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|rv
)paren
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;d1&quot;
comma
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Test if FPU instructions are executed in hardware, or if they&squot;re&n;   emulated in software.  For this, the F-line vector is temporarily&n;   replaced. */
DECL|function|test_software_fpu
r_int
id|test_software_fpu
c_func
(paren
r_void
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;movel&t;0x2c,a0&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;sp,a1&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;#Lfline,0x2c&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#1,%0&bslash;n&bslash;t&quot;
l_string|&quot;fnop &t;&bslash;n&bslash;t&quot;
l_string|&quot;nop&t;&t;&bslash;n&bslash;t&quot;
l_string|&quot;moveq&t;#0,%0&bslash;n&quot;
l_string|&quot;Lfline:&bslash;t&quot;
l_string|&quot;movel&t;a1,sp&bslash;n&bslash;t&quot;
l_string|&quot;movel&t;a0,0x2c&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|rv
)paren
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|get_medusa_bank_sizes
r_void
id|get_medusa_bank_sizes
c_func
(paren
id|u_long
op_star
id|bank1
comma
id|u_long
op_star
id|bank2
)paren
(brace
r_static
id|u_long
id|save_addr
suffix:semicolon
id|u_long
id|test_base
comma
id|saved_contents
(braket
l_int|16
)braket
suffix:semicolon
DECL|macro|TESTADDR
mdefine_line|#define&t;TESTADDR(i)&t;(*((u_long *)((char *)test_base + i*8*MB)))
DECL|macro|TESTPAT
mdefine_line|#define&t;TESTPAT&t;&t;0x12345678
r_int
r_int
id|oldflags
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* This ensures at least that none of the test addresses conflicts&n;&t; * with the test code itself */
id|test_base
op_assign
(paren
(paren
r_int
r_int
)paren
op_amp
id|save_addr
op_amp
l_int|0x007fffff
)paren
op_or
l_int|0x20000000
suffix:semicolon
op_star
id|bank1
op_assign
op_star
id|bank2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Interrupts must be disabled because arbitrary addresses may be&n;&t; * temporarily overwritten, even code of an interrupt handler */
id|__asm__
id|__volatile__
(paren
l_string|&quot;movew sr,%0; oriw #0x700,sr&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|oldflags
)paren
suffix:colon
)paren
suffix:semicolon
id|disable_cache
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* save contents of the test addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|saved_contents
(braket
id|i
)braket
op_assign
id|TESTADDR
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* write 0s into all test addresses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TESTADDR
c_func
(paren
id|i
)paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* test for bank 1 */
macro_line|#if 0
multiline_comment|/* This is Freddi&squot;s original test, but it didn&squot;t work. */
id|TESTADDR
c_func
(paren
l_int|0
)paren
op_assign
id|TESTADDR
c_func
(paren
l_int|1
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|1
)paren
op_eq
id|TESTPAT
)paren
(brace
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|2
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|8
op_star
id|MB
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|3
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank1
op_assign
l_int|32
op_star
id|MB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|2
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|0
suffix:semicolon
r_else
op_star
id|bank1
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
)brace
macro_line|#else
id|TESTADDR
c_func
(paren
l_int|0
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|1
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|8
op_star
id|MB
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|2
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|4
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank1
op_assign
l_int|32
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank1
op_assign
l_int|64
op_star
id|MB
suffix:semicolon
macro_line|#endif
multiline_comment|/* test for bank2 */
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|8
)paren
op_ne
l_int|0
)paren
op_star
id|bank2
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|TESTADDR
c_func
(paren
l_int|8
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|9
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|10
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank2
op_assign
l_int|8
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank2
op_assign
l_int|32
op_star
id|MB
suffix:semicolon
)brace
r_else
(brace
id|TESTADDR
c_func
(paren
l_int|9
)paren
op_assign
id|TESTPAT
suffix:semicolon
r_if
c_cond
(paren
id|TESTADDR
c_func
(paren
l_int|10
)paren
op_eq
id|TESTPAT
)paren
op_star
id|bank2
op_assign
l_int|16
op_star
id|MB
suffix:semicolon
r_else
op_star
id|bank2
op_assign
l_int|64
op_star
id|MB
suffix:semicolon
)brace
)brace
multiline_comment|/* restore contents of the test addresses and restore interrupt mask */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TESTADDR
c_func
(paren
id|i
)paren
op_assign
id|saved_contents
(braket
id|i
)braket
suffix:semicolon
)brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;movew %0,sr&quot;
suffix:colon
suffix:colon
l_string|&quot;g&quot;
(paren
id|oldflags
)paren
)paren
suffix:semicolon
)brace
DECL|macro|TESTADDR
macro_line|#undef TESTADDR
DECL|macro|TESTPAT
macro_line|#undef TESTPAT
DECL|function|check_bootinfo_version
r_static
r_int
id|check_bootinfo_version
c_func
(paren
r_char
op_star
id|memptr
)paren
(brace
r_struct
id|bootversion
op_star
id|bv
op_assign
(paren
r_struct
id|bootversion
op_star
)paren
id|memptr
suffix:semicolon
r_int
r_int
id|version
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|kernel_major
comma
id|kernel_minor
comma
id|boots_major
comma
id|boots_minor
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bv-&gt;magic
op_eq
id|BOOTINFOV_MAGIC
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|bv-&gt;machversions
(braket
id|i
)braket
dot
id|machtype
op_ne
l_int|0
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|bv-&gt;machversions
(braket
id|i
)braket
dot
id|machtype
op_eq
id|MACH_ATARI
)paren
(brace
id|version
op_assign
id|bv-&gt;machversions
(braket
id|i
)braket
dot
id|version
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|version
)paren
id|printf
c_func
(paren
l_string|&quot;Kernel has no bootinfo version info, assuming 0.0&bslash;n&quot;
)paren
suffix:semicolon
id|kernel_major
op_assign
id|BI_VERSION_MAJOR
c_func
(paren
id|version
)paren
suffix:semicolon
id|kernel_minor
op_assign
id|BI_VERSION_MINOR
c_func
(paren
id|version
)paren
suffix:semicolon
id|boots_major
op_assign
id|BI_VERSION_MAJOR
c_func
(paren
id|ATARI_BOOTI_VERSION
)paren
suffix:semicolon
id|boots_minor
op_assign
id|BI_VERSION_MINOR
c_func
(paren
id|ATARI_BOOTI_VERSION
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Bootstrap&squot;s bootinfo version: %d.%d&bslash;n&quot;
comma
id|boots_major
comma
id|boots_minor
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Kernel&squot;s bootinfo version   : %d.%d&bslash;n&quot;
comma
id|kernel_major
comma
id|kernel_minor
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|kernel_major
)paren
(brace
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|ATARI_BOOTI_VERSION
)paren
suffix:colon
r_if
c_cond
(paren
id|kernel_minor
OG
id|boots_minor
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Warning: Bootinfo version of bootstrap and kernel &quot;
l_string|&quot;differ!&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;         Certain features may not work.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|COMPAT_ATARI_BOOTI_VERSION
)paren
suffix:colon
id|printf
c_func
(paren
l_string|&quot;(using backwards compatibility mode)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;nThis bootstrap is too %s for this kernel!&bslash;n&quot;
comma
id|boots_major
OL
id|kernel_major
ques
c_cond
l_string|&quot;old&quot;
suffix:colon
l_string|&quot;new&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|kernel_major
suffix:semicolon
)brace
macro_line|#ifdef USE_BOOTP
macro_line|# include &quot;bootp.h&quot;
macro_line|#else
DECL|macro|ll_read
macro_line|# define ll_read&t;read
DECL|macro|ll_lseek
macro_line|# define ll_lseek&t;lseek
DECL|macro|ll_close
macro_line|# define ll_close&t;close
macro_line|#endif
macro_line|#ifdef ZKERNEL
r_static
r_int
id|load_zkernel
c_func
(paren
r_int
id|fd
)paren
suffix:semicolon
r_static
r_int
id|kread
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|buf
comma
r_int
id|cnt
)paren
suffix:semicolon
r_static
r_int
id|klseek
c_func
(paren
r_int
id|fd
comma
r_int
id|where
comma
r_int
id|whence
)paren
suffix:semicolon
r_static
r_int
id|kclose
c_func
(paren
r_int
id|fd
)paren
suffix:semicolon
macro_line|#else
DECL|macro|kread
macro_line|# define kread&t;&t;read
DECL|macro|klseek
macro_line|# define klseek&t;&t;lseek
DECL|macro|kclose
macro_line|# define kclose&t;&t;close
macro_line|#endif
multiline_comment|/* ++andreas: this must be inline due to Super */
r_static
r_inline
r_void
id|boot_exit
(paren
r_int
)paren
id|__attribute__
(paren
(paren
id|noreturn
)paren
)paren
suffix:semicolon
DECL|function|boot_exit
r_static
r_inline
r_void
id|boot_exit
c_func
(paren
r_int
id|status
)paren
(brace
multiline_comment|/* first go back to user mode */
(paren
r_void
)paren
id|Super
c_func
(paren
id|userstk
)paren
suffix:semicolon
id|getchar
c_func
(paren
)paren
suffix:semicolon
m_exit
(paren
id|status
)paren
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|debugflag
op_assign
l_int|0
comma
id|ch
comma
id|kfd
comma
id|rfd
op_assign
op_minus
l_int|1
comma
id|i
comma
id|ignore_ttram
op_assign
l_int|0
suffix:semicolon
r_int
id|load_to_stram
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|ramdisk_name
comma
op_star
id|kernel_name
comma
op_star
id|memptr
suffix:semicolon
id|u_long
id|ST_ramsize
comma
id|TT_ramsize
comma
id|memreq
suffix:semicolon
id|u_long
id|cpu_type
comma
id|fpu_type
comma
id|mch_type
comma
id|mint
suffix:semicolon
r_struct
id|exec
id|kexec
suffix:semicolon
r_int
id|elf_kernel
op_assign
l_int|0
suffix:semicolon
id|Elf32_Ehdr
id|kexec_elf
suffix:semicolon
id|Elf32_Phdr
op_star
id|kernel_phdrs
op_assign
l_int|NULL
suffix:semicolon
id|u_long
id|start_mem
comma
id|mem_size
comma
id|rd_size
comma
id|text_offset
op_assign
l_int|0
comma
id|kernel_size
suffix:semicolon
r_int
id|prefer_bootp
op_assign
l_int|1
comma
id|kname_set
op_assign
l_int|0
comma
id|n_knames
suffix:semicolon
macro_line|#ifdef USE_BOOTP
r_int
id|err
suffix:semicolon
macro_line|#endif
r_char
id|kname_list
(braket
l_int|5
)braket
(braket
l_int|64
)braket
suffix:semicolon
r_void
op_star
id|bi_ptr
suffix:semicolon
id|ramdisk_name
op_assign
l_int|NULL
suffix:semicolon
id|kernel_name
op_assign
l_string|&quot;vmlinux&quot;
suffix:semicolon
multiline_comment|/* print the startup message */
id|puts
c_func
(paren
l_string|&quot;&bslash;fLinux/68k Atari Bootstrap version 2.2&quot;
macro_line|#ifdef USE_BOOTP
l_string|&quot; (with BOOTP)&quot;
macro_line|#endif
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;Copyright 1993,1994 by Arjan Knor, Robert de Vries, Roman Hodek, Andreas Schwab&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ++roman: If no arguments on the command line, read them from&n;&t; * file */
r_if
c_cond
(paren
id|argc
op_eq
l_int|1
)paren
id|get_default_args
c_func
(paren
op_amp
id|argc
comma
op_amp
id|argv
)paren
suffix:semicolon
multiline_comment|/* machine is Atari */
id|bi.machtype
op_assign
id|MACH_ATARI
suffix:semicolon
multiline_comment|/* check arguments */
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;bdtsk:r:&quot;
)paren
)paren
op_ne
id|EOF
)paren
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
id|debugflag
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|ignore_ttram
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|load_to_stram
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;k&squot;
suffix:colon
id|kernel_name
op_assign
id|optarg
suffix:semicolon
id|kname_set
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|ramdisk_name
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|prefer_bootp
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
r_default
suffix:colon
id|usage
c_func
(paren
)paren
suffix:semicolon
)brace
id|argc
op_sub_assign
id|optind
suffix:semicolon
id|argv
op_add_assign
id|optind
suffix:semicolon
multiline_comment|/* We have to access some system variables to get&n;     * the information we need, so we must switch to&n;     * supervisor mode first.&n;     */
id|userstk
op_assign
id|Super
c_func
(paren
l_int|0L
)paren
suffix:semicolon
multiline_comment|/* get the info we need from the cookie-jar */
id|cookiejar
op_assign
op_star
id|_p_cookies
suffix:semicolon
r_if
c_cond
(paren
id|cookiejar
op_eq
l_int|0L
)paren
(brace
multiline_comment|/* if we find no cookies, it&squot;s probably an ST */
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Error: No cookiejar found. Is this an ST?&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* Exit if MiNT/MultiTOS is running.  */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;MiNT&quot;
comma
op_amp
id|mint
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Warning: MiNT is running&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
id|puts
c_func
(paren
l_string|&quot;Linux cannot be started when MiNT is running. Aborting...&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* get _CPU, _FPU and _MCH */
id|getcookie
c_func
(paren
l_string|&quot;_CPU&quot;
comma
op_amp
id|cpu_type
)paren
suffix:semicolon
id|getcookie
c_func
(paren
l_string|&quot;_FPU&quot;
comma
op_amp
id|fpu_type
)paren
suffix:semicolon
id|getcookie
c_func
(paren
l_string|&quot;_MCH&quot;
comma
op_amp
id|mch_type
)paren
suffix:semicolon
multiline_comment|/* check if we are on a 68030/40 with FPU */
r_if
c_cond
(paren
(paren
id|cpu_type
op_ne
l_int|30
op_logical_and
id|cpu_type
op_ne
l_int|40
op_logical_and
id|cpu_type
op_ne
l_int|60
)paren
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Machine type currently not supported. Aborting...&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cpu_type
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|10
suffix:colon
r_break
suffix:semicolon
r_case
l_int|20
suffix:colon
id|bi.cputype
op_assign
id|CPU_68020
suffix:semicolon
id|bi.mmutype
op_assign
id|MMU_68851
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|30
suffix:colon
id|bi.cputype
op_assign
id|CPU_68030
suffix:semicolon
id|bi.mmutype
op_assign
id|MMU_68030
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|40
suffix:colon
id|bi.cputype
op_assign
id|CPU_68040
suffix:semicolon
id|bi.mmutype
op_assign
id|MMU_68040
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|60
suffix:colon
id|bi.cputype
op_assign
id|CPU_68060
suffix:semicolon
id|bi.mmutype
op_assign
id|MMU_68060
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Error: Unknown CPU type. Aborting...&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;CPU: %ld; &quot;
comma
id|cpu_type
op_plus
l_int|68000
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;FPU: &quot;
)paren
suffix:semicolon
multiline_comment|/* check for FPU; in case of a &squot;040 or &squot;060, don&squot;t look at _FPU itself,&n;     * some software may set it to wrong values (68882 or the like) */
r_if
c_cond
(paren
id|cpu_type
op_eq
l_int|40
)paren
(brace
id|bi.fputype
op_assign
id|FPU_68040
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68040&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cpu_type
op_eq
l_int|60
)paren
(brace
id|bi.fputype
op_assign
id|FPU_68060
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68060&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
(paren
id|fpu_type
op_rshift
l_int|16
)paren
op_amp
l_int|7
)paren
(brace
r_case
l_int|0
suffix:colon
id|puts
c_func
(paren
l_string|&quot;not present&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|puts
c_func
(paren
l_string|&quot;SFP004 not supported. Assuming no FPU.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* try to determine real type */
r_if
c_cond
(paren
id|fpu_idle_frame_size
(paren
)paren
op_ne
l_int|0x18
)paren
r_goto
id|m68882
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|4
suffix:colon
id|bi.fputype
op_assign
id|FPU_68881
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68881&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|m68882
suffix:colon
id|bi.fputype
op_assign
id|FPU_68882
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;68882&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Unknown FPU type. Assuming no FPU.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* ++roman: If an FPU was announced in the cookie, test&n;&t;   whether it is a real hardware FPU or a software emulator!  */
r_if
c_cond
(paren
id|bi.fputype
)paren
(brace
r_if
c_cond
(paren
id|test_software_fpu
c_func
(paren
)paren
)paren
(brace
id|bi.fputype
op_assign
l_int|0
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;FPU: software emulated. Assuming no FPU.&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the amounts of ST- and TT-RAM. */
multiline_comment|/* The size must be a multiple of 1MB. */
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_medusa
c_func
(paren
)paren
)paren
(brace
r_struct
(brace
r_int
r_int
id|version
suffix:semicolon
multiline_comment|/* version - currently 1 */
r_int
r_int
id|fr_start
suffix:semicolon
multiline_comment|/* start addr FastRAM */
r_int
r_int
id|fr_len
suffix:semicolon
multiline_comment|/* length FastRAM */
)brace
op_star
id|magn_cookie
suffix:semicolon
r_struct
(brace
r_int
r_int
id|version
suffix:semicolon
r_int
r_int
id|fr_start
suffix:semicolon
multiline_comment|/* start addr */
r_int
r_int
id|fr_len
suffix:semicolon
multiline_comment|/* length */
)brace
op_star
id|fx_cookie
suffix:semicolon
id|TT_ramsize
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ignore_ttram
)paren
(brace
multiline_comment|/* &quot;Original&quot; or properly emulated TT-Ram */
r_if
c_cond
(paren
op_star
id|ramtop
)paren
(brace
multiline_comment|/* the &squot;ramtop&squot; variable at 0x05a4 is not&n;&t;&t; * officially documented. We use it anyway&n;&t;&t; * because it is the only way to get the TTram size.&n;&t;&t; * (It is zero if there is no TTram.)&n;&t;&t; */
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|TT_RAM_BASE
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
(paren
op_star
id|ramtop
op_minus
id|TT_RAM_BASE
)paren
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|TT_ramsize
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;TT-RAM: %ld Mb; &quot;
comma
id|TT_ramsize
)paren
suffix:semicolon
)brace
multiline_comment|/* test for MAGNUM alternate RAM&n;&t;     * added 26.9.1995 M. Schwingen, rincewind@discworld.oche.de&n;&t;     */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;MAGN&quot;
comma
(paren
id|u_long
op_star
)paren
op_amp
id|magn_cookie
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|magn_cookie-&gt;fr_start
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|magn_cookie-&gt;fr_len
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|TT_ramsize
op_add_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;MAGNUM alternate RAM: %ld Mb; &quot;
comma
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* BlowUps FX */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;BPFX&quot;
comma
(paren
id|u_long
op_star
)paren
op_amp
id|fx_cookie
)paren
op_ne
op_minus
l_int|1
op_logical_and
id|fx_cookie
)paren
(brace
multiline_comment|/* if fx is set (cookie call above),&n;&t;&t; * we assume that BlowUps FX-card&n;&t;&t; * is installed. (Nat!)&n;&t;&t; */
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|fx_cookie-&gt;fr_start
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|fx_cookie-&gt;fr_len
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;FX alternate RAM: %ld Mb; &quot;
comma
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
op_star
id|phystop
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|ST_ramsize
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ST-RAM: %ld Mb&bslash;n&quot;
comma
id|ST_ramsize
)paren
suffix:semicolon
id|bi.num_memory
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|load_to_stram
op_logical_and
id|i
OG
l_int|1
)paren
(brace
multiline_comment|/* Put ST-RAM first in the list of mem blocks */
r_struct
id|mem_info
id|temp
op_assign
id|bi.memory
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|bi.memory
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|bi.memory
(braket
l_int|0
)braket
suffix:semicolon
id|bi.memory
(braket
l_int|0
)braket
op_assign
id|temp
suffix:semicolon
)brace
)brace
r_else
(brace
id|u_long
id|bank1
comma
id|bank2
comma
id|medusa_st_ram
suffix:semicolon
id|get_medusa_bank_sizes
c_func
(paren
op_amp
id|bank1
comma
op_amp
id|bank2
)paren
suffix:semicolon
id|medusa_st_ram
op_assign
op_star
id|phystop
op_amp
op_complement
(paren
id|MB
op_minus
l_int|1
)paren
suffix:semicolon
id|bank1
op_sub_assign
id|medusa_st_ram
suffix:semicolon
id|TT_ramsize
op_assign
l_int|0
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|medusa_st_ram
suffix:semicolon
id|ST_ramsize
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_div
id|MB
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Medusa pseudo ST-RAM from bank 1: %ld Mb; &quot;
comma
id|ST_ramsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ignore_ttram
op_logical_and
id|bank1
OG
l_int|0
)paren
(brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0x20000000
op_plus
id|medusa_st_ram
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|bank1
suffix:semicolon
id|TT_ramsize
op_add_assign
id|bank1
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;TT-RAM bank 1: %ld Mb; &quot;
comma
id|bank1
op_div
id|MB
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ignore_ttram
op_logical_and
id|bank2
OG
l_int|0
)paren
(brace
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_assign
l_int|0x24000000
suffix:semicolon
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|bank2
suffix:semicolon
id|TT_ramsize
op_add_assign
id|bank2
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;TT-RAM bank 2: %ld Mb; &quot;
comma
id|bank2
op_div
id|MB
)paren
suffix:semicolon
)brace
id|bi.num_memory
op_assign
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* verify that there is enough RAM; ST- and TT-RAM combined */
r_if
c_cond
(paren
id|ST_ramsize
op_plus
id|TT_ramsize
OL
id|MIN_RAMSIZE
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Not enough RAM. Aborting...&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
macro_line|#if 0&t;
multiline_comment|/* Get language/keyboard info */
multiline_comment|/* TODO: do we need this ? */
multiline_comment|/* Could be used to auto-select keyboard map later on. (rdv) */
r_if
c_cond
(paren
id|getcookie
c_func
(paren
l_string|&quot;_AKP&quot;
comma
op_amp
id|language
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Get the language info from the OS-header */
id|os_header
op_assign
op_star
id|_sysbase
suffix:semicolon
id|os_header
op_assign
id|os_header-&gt;os_beg
suffix:semicolon
id|lang
op_assign
(paren
id|os_header-&gt;os_conf
)paren
op_rshift
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Language: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lang
)paren
(brace
r_case
id|HOL
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Dutch&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Own country first :-) */
r_case
id|USA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;American&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWG
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Switzerland (German)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FRG
suffix:colon
id|puts
c_func
(paren
l_string|&quot;German&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FRA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;French&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWF
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Switzerland (French)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UK
suffix:colon
id|puts
c_func
(paren
l_string|&quot;English&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Spanish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ITA
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Italian&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWE
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Swedish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TUR
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Turkey&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIN
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Finnish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NOR
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Norwegian&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEN
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Danish&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAU
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Saudi-Arabian&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|puts
c_func
(paren
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Language: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|language
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|1
suffix:colon
id|printf
c_func
(paren
l_string|&quot;German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printf
c_func
(paren
l_string|&quot;French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Spanish &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Italian &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;English &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Keyboard type :&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|language
op_rshift
l_int|8
)paren
(brace
r_case
l_int|1
suffix:colon
id|printf
c_func
(paren
l_string|&quot;German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printf
c_func
(paren
l_string|&quot;French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Spanish &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Italian &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss French &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Swiss German &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;English &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Pass contents of the _MCH cookie to the kernel */
id|bi.mch_cookie
op_assign
id|mch_type
suffix:semicolon
multiline_comment|/*&n;     * Copy command line options into the kernel command line.&n;     */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_plus
id|strlen
c_func
(paren
op_star
id|argv
)paren
op_plus
l_int|1
)paren
OL
id|CL_SIZE
)paren
(brace
id|i
op_add_assign
id|strlen
c_func
(paren
op_star
id|argv
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bi.command_line
(braket
l_int|0
)braket
)paren
id|strcat
(paren
id|bi.command_line
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|strcat
(paren
id|bi.command_line
comma
op_star
id|argv
op_increment
)paren
suffix:semicolon
)brace
)brace
id|printf
(paren
l_string|&quot;Command line is &squot;%s&squot;&bslash;n&quot;
comma
id|bi.command_line
)paren
suffix:semicolon
id|start_mem
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|addr
suffix:semicolon
id|mem_size
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
multiline_comment|/* tell us where the kernel will go */
id|printf
c_func
(paren
l_string|&quot;&bslash;nThe kernel will be located at 0x%08lx&bslash;n&quot;
comma
id|start_mem
)paren
suffix:semicolon
macro_line|#ifdef TEST
multiline_comment|/*&n;    ** Temporary exit point for testing&n;    */
id|boot_exit
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* TEST */
id|i
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef USE_BOOTP
r_if
c_cond
(paren
op_logical_neg
id|kname_set
)paren
id|kname_list
(braket
id|i
op_increment
)braket
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* default kernel which BOOTP server says */
macro_line|#endif
macro_line|#ifdef ZKERNEL
id|strcpy
c_func
(paren
id|kname_list
(braket
id|i
)braket
comma
id|kernel_name
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|kname_list
(braket
id|i
)braket
comma
l_string|&quot;.gz&quot;
)paren
suffix:semicolon
op_increment
id|i
suffix:semicolon
macro_line|#endif
id|strcpy
c_func
(paren
id|kname_list
(braket
id|i
op_increment
)braket
comma
id|kernel_name
)paren
suffix:semicolon
macro_line|#ifdef ZKERNEL
r_if
c_cond
(paren
op_logical_neg
id|kname_set
)paren
id|strcpy
c_func
(paren
id|kname_list
(braket
id|i
op_increment
)braket
comma
l_string|&quot;vmlinuz&quot;
)paren
suffix:semicolon
macro_line|#endif
id|n_knames
op_assign
id|i
suffix:semicolon
id|kfd
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef USE_BOOTP
r_if
c_cond
(paren
id|prefer_bootp
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_knames
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_remote_kernel
c_func
(paren
id|kname_list
(braket
id|i
)braket
)paren
)paren
op_ge
l_int|0
)paren
r_goto
id|kernel_open
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
op_minus
l_int|1
)paren
multiline_comment|/* fatal error; retries don&squot;t help... */
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nremote boot failed; trying local kernel&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_knames
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|kfd
op_assign
id|open
c_func
(paren
id|kname_list
(braket
id|i
)braket
comma
id|O_RDONLY
)paren
)paren
op_ne
op_minus
l_int|1
)paren
r_goto
id|kernel_open
suffix:semicolon
)brace
macro_line|#ifdef USE_BOOTP
r_if
c_cond
(paren
op_logical_neg
id|prefer_bootp
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nlocal kernel failed; trying remote boot&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_knames
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_remote_kernel
c_func
(paren
id|kname_list
(braket
id|i
)braket
)paren
)paren
op_ge
l_int|0
)paren
r_goto
id|kernel_open
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
op_minus
l_int|1
)paren
multiline_comment|/* fatal error; retries don&squot;t help... */
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Unable to open any kernel file&bslash;n(Tried &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_knames
suffix:semicolon
op_increment
id|i
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s%s&quot;
comma
id|kname_list
(braket
id|i
)braket
comma
id|i
OL
id|n_knames
op_minus
l_int|2
ques
c_cond
l_string|&quot;, &quot;
suffix:colon
id|i
op_eq
id|n_knames
op_minus
l_int|2
ques
c_cond
l_string|&quot;, and &quot;
suffix:colon
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
id|kernel_open
suffix:colon
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
op_amp
id|kexec
comma
r_sizeof
(paren
id|kexec
)paren
)paren
op_ne
r_sizeof
(paren
id|kexec
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to read exec header from %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
macro_line|#ifdef ZKERNEL
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|kexec
)paren
(braket
l_int|0
)braket
op_eq
l_int|037
op_logical_and
(paren
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|kexec
)paren
(braket
l_int|1
)braket
op_eq
l_int|0213
op_logical_or
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|kexec
)paren
(braket
l_int|1
)braket
op_eq
l_int|0236
)paren
)paren
(brace
multiline_comment|/* That&squot;s a compressed kernel */
id|printf
c_func
(paren
l_string|&quot;Kernel is compressed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|load_zkernel
c_func
(paren
id|kfd
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Decompression error -- aborting&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
(brace
r_case
id|ZMAGIC
suffix:colon
id|text_offset
op_assign
id|N_TXTOFF
c_func
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QMAGIC
suffix:colon
id|text_offset
op_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
multiline_comment|/* the text size includes the exec header; remove this */
id|kexec.a_text
op_sub_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Try to parse it as an ELF header */
id|klseek
(paren
id|kfd
comma
l_int|0
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
op_amp
id|kexec_elf
comma
r_sizeof
(paren
id|kexec_elf
)paren
)paren
op_eq
r_sizeof
(paren
id|kexec_elf
)paren
op_logical_and
id|memcmp
(paren
op_amp
id|kexec_elf.e_ident
(braket
id|EI_MAG0
)braket
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_eq
l_int|0
)paren
(brace
id|elf_kernel
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* A few plausibility checks */
r_if
c_cond
(paren
id|kexec_elf.e_type
op_ne
id|ET_EXEC
op_logical_or
id|kexec_elf.e_machine
op_ne
id|EM_68K
op_logical_or
id|kexec_elf.e_version
op_ne
id|EV_CURRENT
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Invalid ELF header contents in kernel&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* Load the program headers */
id|kernel_phdrs
op_assign
(paren
id|Elf32_Phdr
op_star
)paren
id|Malloc
(paren
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
id|Elf32_Phdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kernel_phdrs
op_eq
l_int|NULL
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to allocate memory for program headers&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|klseek
(paren
id|kfd
comma
id|kexec_elf.e_phoff
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
id|kernel_phdrs
comma
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
op_star
id|kernel_phdrs
)paren
)paren
op_ne
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
op_star
id|kernel_phdrs
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to read program headers from %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Wrong magic number %lo in kernel header&bslash;n&quot;
comma
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* Load the kernel one page after start of mem */
id|start_mem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|mem_size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Align bss size to multiple of four */
r_if
c_cond
(paren
op_logical_neg
id|elf_kernel
)paren
id|kexec.a_bss
op_assign
(paren
id|kexec.a_bss
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* init ramdisk */
r_if
c_cond
(paren
id|ramdisk_name
)paren
(brace
r_if
c_cond
(paren
(paren
id|rfd
op_assign
id|open
c_func
(paren
id|ramdisk_name
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Unable to open ramdisk file %s&bslash;n&quot;
comma
id|ramdisk_name
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|bi.ramdisk.size
op_assign
id|lseek
c_func
(paren
id|rfd
comma
l_int|0
comma
id|SEEK_END
)paren
suffix:semicolon
)brace
r_else
id|bi.ramdisk.size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* calculate the total required amount of memory */
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
id|u_long
id|min_addr
op_assign
l_int|0xffffffff
comma
id|max_addr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|min_addr
OG
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
)paren
id|min_addr
op_assign
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|max_addr
OL
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
)paren
id|max_addr
op_assign
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
suffix:semicolon
)brace
multiline_comment|/* This is needed for newer linkers that include the header in&n;&t;   the first segment.  */
r_if
c_cond
(paren
id|min_addr
op_eq
l_int|0
)paren
(brace
id|min_addr
op_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_offset
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_filesz
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_memsz
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|kernel_size
op_assign
id|max_addr
op_minus
id|min_addr
suffix:semicolon
)brace
r_else
id|kernel_size
op_assign
id|kexec.a_text
op_plus
id|kexec.a_data
op_plus
id|kexec.a_bss
suffix:semicolon
id|rd_size
op_assign
id|bi.ramdisk.size
suffix:semicolon
r_if
c_cond
(paren
id|rd_size
op_plus
id|kernel_size
OG
id|mem_size
op_minus
id|MB
op_div
l_int|2
op_logical_and
id|bi.num_memory
OG
l_int|1
)paren
multiline_comment|/* If running low on ST ram load ramdisk into alternate ram.  */
id|bi.ramdisk.addr
op_assign
(paren
id|u_long
)paren
id|bi.memory
(braket
l_int|1
)braket
dot
id|addr
op_plus
id|bi.memory
(braket
l_int|1
)braket
dot
id|size
op_minus
id|rd_size
suffix:semicolon
r_else
multiline_comment|/* Else hopefully there is enough ST ram. */
id|bi.ramdisk.addr
op_assign
(paren
id|u_long
)paren
id|start_mem
op_plus
id|mem_size
op_minus
id|rd_size
suffix:semicolon
multiline_comment|/* create the bootinfo structure */
r_if
c_cond
(paren
op_logical_neg
id|create_bootinfo
c_func
(paren
)paren
)paren
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
id|memreq
op_assign
id|kernel_size
op_plus
id|bi_size
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_if
c_cond
(paren
r_sizeof
(paren
id|compat_bootinfo
)paren
OG
id|bi_size
)paren
id|memreq
op_assign
id|kernel_size
op_plus
r_sizeof
(paren
id|compat_bootinfo
)paren
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
multiline_comment|/* align load address of ramdisk image, read() is sloooow on odd addr. */
id|memreq
op_assign
(paren
(paren
id|memreq
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
op_plus
id|rd_size
suffix:semicolon
multiline_comment|/* allocate RAM for the kernel */
r_if
c_cond
(paren
op_logical_neg
(paren
id|memptr
op_assign
(paren
r_char
op_star
)paren
id|Malloc
(paren
id|memreq
)paren
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to allocate memory for kernel and ramdisk&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;kernel at address %lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|memptr
)paren
suffix:semicolon
(paren
r_void
)paren
id|memset
c_func
(paren
id|memptr
comma
l_int|0
comma
id|memreq
)paren
suffix:semicolon
multiline_comment|/* read the text and data segments from the kernel image */
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|klseek
(paren
id|kfd
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_offset
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to segment %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
id|memptr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_minus
id|PAGE_SIZE
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_filesz
)paren
op_ne
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_filesz
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read segment %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|klseek
(paren
id|kfd
comma
id|text_offset
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to text&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
id|memptr
comma
id|kexec.a_text
)paren
op_ne
id|kexec.a_text
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read text&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* data follows immediately after text */
r_if
c_cond
(paren
id|kread
(paren
id|kfd
comma
id|memptr
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
op_ne
id|kexec.a_data
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read data&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
id|kclose
(paren
id|kfd
)paren
suffix:semicolon
multiline_comment|/* Check kernel&squot;s bootinfo version */
r_switch
c_cond
(paren
id|check_bootinfo_version
c_func
(paren
id|memptr
)paren
)paren
(brace
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|ATARI_BOOTI_VERSION
)paren
suffix:colon
id|bi_ptr
op_assign
op_amp
id|bi_union.record
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|COMPAT_ATARI_BOOTI_VERSION
)paren
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|create_compat_bootinfo
c_func
(paren
)paren
)paren
(brace
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|bi_ptr
op_assign
op_amp
id|compat_bootinfo
suffix:semicolon
id|bi_size
op_assign
r_sizeof
(paren
id|compat_bootinfo
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
r_default
suffix:colon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* copy the boot_info struct to the end of the kernel image */
id|memcpy
(paren
(paren
r_void
op_star
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
comma
id|bi_ptr
comma
id|bi_size
)paren
suffix:semicolon
multiline_comment|/* read the ramdisk image */
r_if
c_cond
(paren
id|rfd
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|lseek
(paren
id|rfd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to beginning of ramdisk file&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read
(paren
id|rfd
comma
id|memptr
op_plus
id|memreq
op_minus
id|rd_size
comma
id|rd_size
)paren
op_ne
id|rd_size
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read ramdisk file&bslash;n&quot;
)paren
suffix:semicolon
id|Mfree
(paren
(paren
r_void
op_star
)paren
id|memptr
)paren
suffix:semicolon
id|boot_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|close
(paren
id|rfd
)paren
suffix:semicolon
)brace
multiline_comment|/* for those who want to debug */
r_if
c_cond
(paren
id|debugflag
)paren
(brace
r_if
c_cond
(paren
id|bi.ramdisk.size
)paren
id|printf
(paren
l_string|&quot;RAM disk at %#lx, size is %ld&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|memreq
op_minus
id|rd_size
)paren
comma
id|bi.ramdisk.size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
(paren
l_string|&quot;Kernel segment %d at %#lx, size %ld&bslash;n&quot;
comma
id|i
comma
id|start_mem
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_minus
id|PAGE_SIZE
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printf
(paren
l_string|&quot;&bslash;nKernel text at %#lx, code size %d&bslash;n&quot;
comma
id|start_mem
comma
id|kexec.a_text
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Kernel data at %#lx, data size %d&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Kernel bss  at %#lx, bss  size %d&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
comma
id|kexec.a_bss
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;&bslash;nboot_info is at %#lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|kernel_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;nKernel entry is %#lx&bslash;n&quot;
comma
id|elf_kernel
ques
c_cond
id|kexec_elf.e_entry
suffix:colon
id|kexec.a_entry
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk dest top is %#lx&bslash;n&quot;
comma
id|bi.ramdisk.addr
op_plus
id|rd_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk lower limit is %#lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|memreq
op_minus
id|rd_size
)paren
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk src top is %#lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|memreq
)paren
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Type a key to continue the Linux boot...&quot;
)paren
suffix:semicolon
id|fflush
(paren
id|stdout
)paren
suffix:semicolon
id|getchar
c_func
(paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Booting Linux...&bslash;n&quot;
)paren
suffix:semicolon
id|sync
(paren
)paren
suffix:semicolon
multiline_comment|/* turn off interrupts... */
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* turn off caches... */
id|disable_cache
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ..and any MMU translation */
id|disable_mmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ++guenther: allow reset if launched with MiNT */
op_star
(paren
r_int
op_star
)paren
l_int|0x426
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* copy mover code to a safe place if needed */
id|memcpy
(paren
(paren
r_void
op_star
)paren
l_int|0x400
comma
op_amp
id|copyall
comma
op_amp
id|copyallend
op_minus
op_amp
id|copyall
)paren
suffix:semicolon
multiline_comment|/* setup stack */
id|change_stack
(paren
(paren
r_void
op_star
)paren
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;     * On the Atari you can have two situations:&n;     * 1. One piece of contiguous RAM (Falcon)&n;     * 2. Two pieces of contiguous RAM (TT)&n;     * In case 2 you can load your program into ST-ram and load your data in&n;     * any old RAM you have left.&n;     * In case 1 you could overwrite your own program when copying the&n;     * kernel and ramdisk to their final positions.&n;     * To solve this the mover code is copied to a safe place first.&n;     * Then this program jumps to the mover code. After the mover code&n;     * has finished it jumps to the start of the kernel in its new position.&n;     * I thought the memory just after the interrupt vector table was a safe&n;     * place because it is used by TOS to store some system variables.&n;     * This range goes from 0x400 to approx. 0x5B0.&n;     * This is more than enough for the miniscule mover routine (16 bytes).&n;     */
id|jump_to_mover
c_func
(paren
(paren
r_char
op_star
)paren
id|start_mem
comma
id|memptr
comma
(paren
r_char
op_star
)paren
id|bi.ramdisk.addr
op_plus
id|rd_size
comma
id|memptr
op_plus
id|memreq
comma
id|kernel_size
op_plus
id|bi_size
comma
id|rd_size
comma
(paren
r_void
op_star
)paren
l_int|0x400
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
DECL|macro|MAXARGS
mdefine_line|#define&t;MAXARGS&t;&t;30
DECL|function|get_default_args
r_static
r_void
id|get_default_args
c_func
(paren
r_int
op_star
id|argc
comma
r_char
op_star
op_star
op_star
id|argv
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_static
r_char
op_star
id|nargv
(braket
id|MAXARGS
)braket
suffix:semicolon
r_char
id|arg
(braket
l_int|256
)braket
comma
op_star
id|p
suffix:semicolon
r_int
id|c
comma
id|quote
comma
id|state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen
c_func
(paren
l_string|&quot;bootargs&quot;
comma
l_string|&quot;r&quot;
)paren
)paren
)paren
r_return
suffix:semicolon
op_star
id|argc
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
op_star
op_star
id|argv
)paren
id|nargv
(braket
l_int|0
)braket
op_assign
op_star
op_star
id|argv
suffix:semicolon
r_else
id|nargv
(braket
l_int|0
)braket
op_assign
l_string|&quot;bootstrap&quot;
suffix:semicolon
op_star
id|argv
op_assign
id|nargv
suffix:semicolon
id|quote
op_assign
id|state
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|arg
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|fgetc
c_func
(paren
id|f
)paren
)paren
op_ne
id|EOF
)paren
(brace
r_if
c_cond
(paren
id|state
op_eq
l_int|0
)paren
(brace
multiline_comment|/* outside args, skip whitespace */
r_if
c_cond
(paren
op_logical_neg
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
id|state
op_assign
l_int|1
suffix:semicolon
id|p
op_assign
id|arg
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/* inside an arg: copy it into &squot;arg&squot;, obeying quoting */
r_if
c_cond
(paren
op_logical_neg
id|quote
op_logical_and
(paren
id|c
op_eq
l_char|&squot;&bslash;&squot;&squot;
op_logical_or
id|c
op_eq
l_char|&squot;&quot;&squot;
)paren
)paren
id|quote
op_assign
id|c
suffix:semicolon
r_else
r_if
c_cond
(paren
id|quote
op_logical_and
id|c
op_eq
id|quote
)paren
id|quote
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|quote
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
)paren
(brace
multiline_comment|/* end of this arg */
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|nargv
(braket
(paren
op_star
id|argc
)paren
op_increment
)braket
op_assign
id|strdup
c_func
(paren
id|arg
)paren
suffix:semicolon
id|state
op_assign
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|state
)paren
(brace
multiline_comment|/* last arg finished by EOF! */
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|nargv
(braket
(paren
op_star
id|argc
)paren
op_increment
)braket
op_assign
id|strdup
c_func
(paren
id|arg
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
id|nargv
(braket
op_star
id|argc
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Create the Bootinfo Structure&n;     */
DECL|function|create_bootinfo
r_static
r_int
id|create_bootinfo
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bi_record
op_star
id|record
suffix:semicolon
multiline_comment|/* Initialization */
id|bi_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Generic tags */
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_MACHTYPE
comma
r_sizeof
(paren
id|bi.machtype
)paren
comma
op_amp
id|bi.machtype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_CPUTYPE
comma
r_sizeof
(paren
id|bi.cputype
)paren
comma
op_amp
id|bi.cputype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_FPUTYPE
comma
r_sizeof
(paren
id|bi.fputype
)paren
comma
op_amp
id|bi.fputype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_MMUTYPE
comma
r_sizeof
(paren
id|bi.mmutype
)paren
comma
op_amp
id|bi.mmutype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_memory
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_MEMCHUNK
comma
r_sizeof
(paren
id|bi.memory
(braket
id|i
)braket
)paren
comma
op_amp
id|bi.memory
(braket
id|i
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bi.ramdisk.size
)paren
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_RAMDISK
comma
r_sizeof
(paren
id|bi.ramdisk
)paren
comma
op_amp
id|bi.ramdisk
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_string
c_func
(paren
id|BI_COMMAND_LINE
comma
id|bi.command_line
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Atari tags */
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_ATARI_MCH_COOKIE
comma
r_sizeof
(paren
id|bi.mch_cookie
)paren
comma
op_amp
id|bi.mch_cookie
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Trailer */
id|record
op_assign
(paren
r_struct
id|bi_record
op_star
)paren
(paren
(paren
id|u_long
)paren
op_amp
id|bi_union.record
op_plus
id|bi_size
)paren
suffix:semicolon
id|record-&gt;tag
op_assign
id|BI_LAST
suffix:semicolon
id|bi_size
op_add_assign
r_sizeof
(paren
id|bi_union.record.tag
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Add a Record to the Bootinfo Structure&n;     */
DECL|function|add_bi_record
r_static
r_int
id|add_bi_record
c_func
(paren
id|u_short
id|tag
comma
id|u_short
id|size
comma
r_const
r_void
op_star
id|data
)paren
(brace
r_struct
id|bi_record
op_star
id|record
suffix:semicolon
id|u_short
id|size2
suffix:semicolon
id|size2
op_assign
(paren
r_sizeof
(paren
r_struct
id|bi_record
)paren
op_plus
id|size
op_plus
l_int|3
)paren
op_amp
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|bi_size
op_plus
id|size2
op_plus
r_sizeof
(paren
id|bi_union.record.tag
)paren
OG
id|MAX_BI_SIZE
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Can&squot;t add bootinfo record. Ask a wizard to enlarge me.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|record
op_assign
(paren
r_struct
id|bi_record
op_star
)paren
(paren
(paren
id|u_long
)paren
op_amp
id|bi_union.record
op_plus
id|bi_size
)paren
suffix:semicolon
id|record-&gt;tag
op_assign
id|tag
suffix:semicolon
id|record-&gt;size
op_assign
id|size2
suffix:semicolon
id|memcpy
c_func
(paren
id|record-&gt;data
comma
id|data
comma
id|size
)paren
suffix:semicolon
id|bi_size
op_add_assign
id|size2
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Add a String Record to the Bootinfo Structure&n;     */
DECL|function|add_bi_string
r_static
r_int
id|add_bi_string
c_func
(paren
id|u_short
id|tag
comma
r_const
id|u_char
op_star
id|s
)paren
(brace
r_return
id|add_bi_record
c_func
(paren
id|tag
comma
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
comma
(paren
r_void
op_star
)paren
id|s
)paren
suffix:semicolon
)brace
macro_line|#ifdef BOOTINFO_COMPAT_1_0
multiline_comment|/*&n;     *  Create the Bootinfo structure for backwards compatibility mode&n;     */
DECL|function|create_compat_bootinfo
r_static
r_int
id|create_compat_bootinfo
c_func
(paren
r_void
)paren
(brace
id|u_int
id|i
suffix:semicolon
id|compat_bootinfo.machtype
op_assign
id|bi.machtype
suffix:semicolon
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68020
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68020
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68030
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68030
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68040
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68040
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68060
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68060
suffix:semicolon
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;CPU type 0x%08lx not supported by kernel&bslash;n&quot;
comma
id|bi.cputype
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68881
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68881
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68882
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68882
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68040
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68040
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68060
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68060
suffix:semicolon
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;FPU type 0x%08lx not supported by kernel&bslash;n&quot;
comma
id|bi.fputype
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|compat_bootinfo.num_memory
op_assign
id|bi.num_memory
suffix:semicolon
r_if
c_cond
(paren
id|compat_bootinfo.num_memory
OG
id|COMPAT_NUM_MEMINFO
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Warning: using only %d blocks of memory&bslash;n&quot;
comma
id|COMPAT_NUM_MEMINFO
)paren
suffix:semicolon
id|compat_bootinfo.num_memory
op_assign
id|COMPAT_NUM_MEMINFO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|compat_bootinfo.num_memory
suffix:semicolon
id|i
op_increment
)paren
(brace
id|compat_bootinfo.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|compat_bootinfo.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bi.ramdisk.size
)paren
(brace
id|compat_bootinfo.ramdisk_size
op_assign
(paren
id|bi.ramdisk.size
op_plus
l_int|1023
)paren
op_div
l_int|1024
suffix:semicolon
id|compat_bootinfo.ramdisk_addr
op_assign
id|bi.ramdisk.addr
suffix:semicolon
)brace
r_else
(brace
id|compat_bootinfo.ramdisk_size
op_assign
l_int|0
suffix:semicolon
id|compat_bootinfo.ramdisk_addr
op_assign
l_int|0
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|compat_bootinfo.command_line
comma
id|bi.command_line
comma
id|COMPAT_CL_SIZE
)paren
suffix:semicolon
id|compat_bootinfo.command_line
(braket
id|COMPAT_CL_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|compat_bootinfo.bi_atari.hw_present
op_assign
l_int|0
suffix:semicolon
id|compat_bootinfo.bi_atari.mch_cookie
op_assign
id|bi.mch_cookie
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
macro_line|#ifdef ZKERNEL
DECL|macro|ZFILE_CHUNK_BITS
mdefine_line|#define&t;ZFILE_CHUNK_BITS&t;16  /* chunk is 64 KB */
DECL|macro|ZFILE_CHUNK_SIZE
mdefine_line|#define&t;ZFILE_CHUNK_SIZE&t;(1 &lt;&lt; ZFILE_CHUNK_BITS)
DECL|macro|ZFILE_CHUNK_MASK
mdefine_line|#define&t;ZFILE_CHUNK_MASK&t;(ZFILE_CHUNK_SIZE-1)
DECL|macro|ZFILE_N_CHUNKS
mdefine_line|#define&t;ZFILE_N_CHUNKS&t;&t;(2*1024*1024/ZFILE_CHUNK_SIZE)
multiline_comment|/* variables for storing the uncompressed data */
DECL|variable|ZFile
r_static
r_char
op_star
id|ZFile
(braket
id|ZFILE_N_CHUNKS
)braket
suffix:semicolon
DECL|variable|ZFileSize
r_static
r_int
id|ZFileSize
op_assign
l_int|0
suffix:semicolon
DECL|variable|ZFpos
r_static
r_int
id|ZFpos
op_assign
l_int|0
suffix:semicolon
DECL|variable|Zwpos
r_static
r_int
id|Zwpos
op_assign
l_int|0
suffix:semicolon
DECL|variable|Zinfd
r_static
r_int
id|Zinfd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fd of compressed file */
multiline_comment|/*&n; * gzip declarations&n; */
DECL|macro|OF
mdefine_line|#define OF(args)  args
DECL|macro|memzero
mdefine_line|#define memzero(s, n)     memset ((s), 0, (n))
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
DECL|typedef|ulg
r_typedef
r_int
r_int
id|ulg
suffix:semicolon
DECL|macro|INBUFSIZ
mdefine_line|#define INBUFSIZ 4096
DECL|macro|WSIZE
mdefine_line|#define WSIZE 0x8000    /* window size--must be a power of two, and */
multiline_comment|/*  at least 32K for zip&squot;s deflate method */
DECL|variable|inbuf
r_static
id|uch
op_star
id|inbuf
suffix:semicolon
DECL|variable|window
r_static
id|uch
op_star
id|window
suffix:semicolon
DECL|variable|insize
r_static
r_int
id|insize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* valid bytes in inbuf */
DECL|variable|inptr
r_static
r_int
id|inptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index of next byte to be processed in inbuf */
DECL|variable|outcnt
r_static
r_int
id|outcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bytes in output buffer */
DECL|variable|exit_code
r_static
r_int
id|exit_code
op_assign
l_int|0
suffix:semicolon
DECL|variable|bytes_out
r_static
r_int
id|bytes_out
op_assign
l_int|0
suffix:semicolon
DECL|macro|get_byte
mdefine_line|#define get_byte()  (inptr &lt; insize ? inbuf[inptr++] : fill_inbuf())
multiline_comment|/* Diagnostic functions (stubbed out) */
DECL|macro|Assert
mdefine_line|#define Assert(cond,msg)
DECL|macro|Trace
mdefine_line|#define Trace(x)
DECL|macro|Tracev
mdefine_line|#define Tracev(x)
DECL|macro|Tracevv
mdefine_line|#define Tracevv(x)
DECL|macro|Tracec
mdefine_line|#define Tracec(c,x)
DECL|macro|Tracecv
mdefine_line|#define Tracecv(c,x)
DECL|macro|STATIC
mdefine_line|#define STATIC static
r_static
r_int
id|fill_inbuf
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|flush_window
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|m
)paren
suffix:semicolon
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
macro_line|#include &quot;../../../../lib/inflate.c&quot;
DECL|function|gzip_mark
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
DECL|function|gzip_release
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
multiline_comment|/*&n; * Fill the input buffer. This is called only when the buffer is empty&n; * and at least one byte is really needed.&n; */
DECL|function|fill_inbuf
r_static
r_int
id|fill_inbuf
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|exit_code
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|insize
op_assign
id|ll_read
c_func
(paren
id|Zinfd
comma
id|inbuf
comma
id|INBUFSIZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insize
op_le
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|inptr
op_assign
l_int|1
suffix:semicolon
r_return
id|inbuf
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the output window window[0..outcnt-1] and update crc and bytes_out.&n; * (Used for the decompressed data only.)&n; */
DECL|function|flush_window
r_static
r_void
id|flush_window
c_func
(paren
r_void
)paren
(brace
id|ulg
id|c
op_assign
id|crc
suffix:semicolon
multiline_comment|/* temporary variable */
r_int
id|n
suffix:semicolon
id|uch
op_star
id|in
comma
id|ch
suffix:semicolon
r_int
id|chunk
op_assign
id|Zwpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_if
c_cond
(paren
id|chunk
op_ge
id|ZFILE_N_CHUNKS
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;compressed image too large! Aborting.&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ZFile
(braket
id|chunk
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ZFile
(braket
id|chunk
)braket
op_assign
(paren
r_char
op_star
)paren
id|Malloc
c_func
(paren
id|ZFILE_CHUNK_SIZE
)paren
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Out of memory for decompresing kernel image&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
)brace
id|memcpy
c_func
(paren
id|ZFile
(braket
id|chunk
)braket
op_plus
(paren
id|Zwpos
op_amp
id|ZFILE_CHUNK_MASK
)paren
comma
id|window
comma
id|outcnt
)paren
suffix:semicolon
id|Zwpos
op_add_assign
id|outcnt
suffix:semicolon
DECL|macro|DISPLAY_BITS
mdefine_line|#define&t;DISPLAY_BITS 13
r_if
c_cond
(paren
(paren
id|Zwpos
op_amp
(paren
(paren
l_int|1
op_lshift
id|DISPLAY_BITS
)paren
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
id|in
op_assign
id|window
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|outcnt
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
id|c
op_assign
id|crc_32_tab
(braket
(paren
(paren
r_int
)paren
id|c
op_xor
id|ch
)paren
op_amp
l_int|0xff
)braket
op_xor
(paren
id|c
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|crc
op_assign
id|c
suffix:semicolon
id|bytes_out
op_add_assign
(paren
id|ulg
)paren
id|outcnt
suffix:semicolon
id|outcnt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|error
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|x
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;n%s&quot;
comma
id|x
)paren
suffix:semicolon
id|exit_code
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|load_zkernel
r_static
r_int
id|load_zkernel
c_func
(paren
r_int
id|fd
)paren
(brace
r_int
id|i
comma
id|err
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ZFILE_N_CHUNKS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ZFile
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|Zinfd
op_assign
id|fd
suffix:semicolon
id|ll_lseek
c_func
(paren
id|fd
comma
l_int|0
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inbuf
op_assign
(paren
id|uch
op_star
)paren
id|Malloc
c_func
(paren
id|INBUFSIZ
)paren
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Couldn&squot;t allocate gunzip buffer&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|window
op_assign
(paren
id|uch
op_star
)paren
id|Malloc
c_func
(paren
id|WSIZE
)paren
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Couldn&squot;t allocate gunzip window&bslash;n&quot;
)paren
suffix:semicolon
id|boot_exit
c_func
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Uncompressing kernel image &quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|makecrc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|gunzip
c_func
(paren
)paren
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
id|ZFileSize
op_assign
id|Zwpos
suffix:semicolon
id|ll_close
c_func
(paren
id|Zinfd
)paren
suffix:semicolon
multiline_comment|/* input file not needed anymore */
id|Mfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
id|Mfree
c_func
(paren
id|window
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Note about the read/lseek wrapper and its memory management: It assumes&n; * that all seeks are only forward, and thus data already read or skipped can&n; * be freed. This is true for current organization of bootstrap and kernels.&n; * Little exception: The struct kexec at the start of the file. After reading&n; * it, there may be a seek back to the end of the file. But this currently&n; * doesn&squot;t hurt. Same considerations apply to the TFTP file buffers. (Roman)&n; */
DECL|function|kread
r_static
r_int
id|kread
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|buf
comma
r_int
id|cnt
)paren
(brace
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ZFileSize
)paren
r_return
id|ll_read
c_func
(paren
id|fd
comma
id|buf
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ZFpos
op_plus
id|cnt
OG
id|ZFileSize
)paren
id|cnt
op_assign
id|ZFileSize
op_minus
id|ZFpos
suffix:semicolon
r_while
c_loop
(paren
id|cnt
OG
l_int|0
)paren
(brace
r_int
id|chunk
op_assign
id|ZFpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_int
id|endchunk
op_assign
(paren
id|chunk
op_plus
l_int|1
)paren
op_lshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_int
id|n
op_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|ZFpos
op_plus
id|n
OG
id|endchunk
)paren
id|n
op_assign
id|endchunk
op_minus
id|ZFpos
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|ZFile
(braket
id|chunk
)braket
op_plus
(paren
id|ZFpos
op_amp
id|ZFILE_CHUNK_MASK
)paren
comma
id|n
)paren
suffix:semicolon
id|cnt
op_sub_assign
id|n
suffix:semicolon
id|buf
op_add_assign
id|n
suffix:semicolon
id|done
op_add_assign
id|n
suffix:semicolon
id|ZFpos
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|ZFpos
op_eq
id|endchunk
)paren
(brace
id|Mfree
c_func
(paren
id|ZFile
(braket
id|chunk
)braket
)paren
suffix:semicolon
id|ZFile
(braket
id|chunk
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|done
suffix:semicolon
)brace
DECL|function|klseek
r_static
r_int
id|klseek
c_func
(paren
r_int
id|fd
comma
r_int
id|where
comma
r_int
id|whence
)paren
(brace
r_int
id|oldpos
comma
id|oldchunk
comma
id|newchunk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ZFileSize
)paren
r_return
id|ll_lseek
c_func
(paren
id|fd
comma
id|where
comma
id|whence
)paren
suffix:semicolon
id|oldpos
op_assign
id|ZFpos
suffix:semicolon
r_switch
c_cond
(paren
id|whence
)paren
(brace
r_case
id|SEEK_SET
suffix:colon
id|ZFpos
op_assign
id|where
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEEK_CUR
suffix:colon
id|ZFpos
op_add_assign
id|where
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEEK_END
suffix:colon
id|ZFpos
op_assign
id|ZFileSize
op_plus
id|where
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ZFpos
OL
l_int|0
)paren
(brace
id|ZFpos
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ZFpos
OG
id|ZFileSize
)paren
(brace
id|ZFpos
op_assign
id|ZFileSize
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* free memory of skipped-over data */
id|oldchunk
op_assign
id|oldpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
id|newchunk
op_assign
id|ZFpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_while
c_loop
(paren
id|oldchunk
OL
id|newchunk
)paren
(brace
r_if
c_cond
(paren
id|ZFile
(braket
id|oldchunk
)braket
)paren
(brace
id|Mfree
c_func
(paren
id|ZFile
(braket
id|oldchunk
)braket
)paren
suffix:semicolon
id|ZFile
(braket
id|oldchunk
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
op_increment
id|oldchunk
suffix:semicolon
)brace
r_return
id|ZFpos
suffix:semicolon
)brace
DECL|function|free_zfile
r_static
r_void
id|free_zfile
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ZFILE_N_CHUNKS
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|ZFile
(braket
id|i
)braket
)paren
id|Mfree
c_func
(paren
id|ZFile
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|kclose
r_static
r_int
id|kclose
c_func
(paren
r_int
id|fd
)paren
(brace
r_if
c_cond
(paren
id|ZFileSize
)paren
(brace
id|free_zfile
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|ll_close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
macro_line|#endif /* ZKERNEL */
eof
