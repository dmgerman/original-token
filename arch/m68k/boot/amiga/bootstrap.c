multiline_comment|/*&n;** bootstrap.c -- This program loads the Linux/68k kernel into an Amiga&n;**                and and launches it.&n;**&n;** Copyright 1993,1994 by Hamish Macdonald, Greg Harp&n;**&n;** Modified 11-May-94 by Geert Uytterhoeven&n;**                      (Geert.Uytterhoeven@cs.kuleuven.ac.be)&n;**     - A3640 MapROM check&n;** Modified 31-May-94 by Geert Uytterhoeven&n;**     - Memory thrash problem solved&n;** Modified 07-March-95 by Geert Uytterhoeven&n;**     - Memory block sizes are rounded to a multiple of 256K instead of 1M&n;**       This _requires_ &gt;0.9pl5 to work!&n;**       (unless all block sizes are multiples of 1M :-)&n;**&n;** This file is subject to the terms and conditions of the GNU General Public&n;** License.  See the file COPYING in the main directory of this archive&n;** for more details.&n;**&n;*/
macro_line|#include &lt;stddef.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sys/file.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;unistd.h&gt;
multiline_comment|/* Amiga bootstrap include file */
macro_line|#include &quot;bootstrap.h&quot;
multiline_comment|/* required Linux/68k include files */
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
multiline_comment|/* temporary stack size */
DECL|macro|TEMP_STACKSIZE
mdefine_line|#define TEMP_STACKSIZE&t;256
multiline_comment|/* Exec Base */
r_extern
r_struct
id|ExecBase
op_star
id|SysBase
suffix:semicolon
r_extern
r_char
op_star
id|optarg
suffix:semicolon
DECL|variable|kexec
r_struct
id|exec
id|kexec
suffix:semicolon
DECL|variable|memptr
r_char
op_star
id|memptr
suffix:semicolon
DECL|variable|start_mem
id|u_long
id|start_mem
suffix:semicolon
DECL|variable|mem_size
id|u_long
id|mem_size
suffix:semicolon
DECL|variable|rd_size
id|u_long
id|rd_size
suffix:semicolon
DECL|variable|ExpansionBase
r_struct
id|ExpansionBase
op_star
id|ExpansionBase
suffix:semicolon
DECL|variable|GfxBase
r_struct
id|GfxBase
op_star
id|GfxBase
suffix:semicolon
DECL|variable|bi
r_struct
id|bootinfo
id|bi
suffix:semicolon
DECL|variable|bi_size
id|u_long
id|bi_size
op_assign
r_sizeof
id|bi
suffix:semicolon
DECL|variable|CustomBase
id|caddr_t
id|CustomBase
op_assign
(paren
id|caddr_t
)paren
id|CUSTOM_PHYSADDR
suffix:semicolon
DECL|function|usage
r_void
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Usage:&bslash;n&quot;
l_string|&quot;&bslash;tbootstrap [-d] [-k kernel_executable] [-r ramdisk_file]&quot;
l_string|&quot; [option...]&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This assembler code is copied to chip ram, and&n; * then executed.&n; * It copies the kernel (and ramdisk) to their&n; * final resting place.&n; */
macro_line|#ifndef __GNUC__
macro_line|#error GNU CC is required to compile the bootstrap program
macro_line|#endif
id|asm
c_func
(paren
"&quot;"
dot
id|text
dot
id|globl
id|_copyall
comma
id|_copyallend
id|_copyall
suffix:colon
op_or
multiline_comment|/* put variables in registers because they may */
id|lea
id|_kexec
comma
id|a3
op_or
multiline_comment|/* be overwritten by kernel/ramdisk copy!! - G.U. */
id|movel
id|_memptr
comma
id|a4
id|movel
id|_start_mem
comma
id|a5
id|movel
id|_mem_size
comma
id|d0
id|movel
id|_rd_size
comma
id|d1
id|movel
id|_bi_size
comma
id|d5
id|movel
id|a3
"@"
(paren
l_int|4
)paren
comma
id|d2
op_or
id|kexec.a_text
id|movel
id|a3
"@"
(paren
l_int|8
)paren
comma
id|d3
op_or
id|kexec.a_data
id|movel
id|a3
"@"
(paren
l_int|12
)paren
comma
id|d4
op_or
id|kexec.a_bss
op_or
multiline_comment|/* copy kernel text and data */
id|movel
id|a4
comma
id|a0
op_or
id|src
op_assign
(paren
id|u_long
op_star
)paren
id|memptr
suffix:semicolon
id|movel
id|a0
comma
id|a2
op_or
id|limit
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
)paren
suffix:semicolon
id|addl
id|d2
comma
id|a2
id|addl
id|d3
comma
id|a2
id|movel
id|a5
comma
id|a1
op_or
id|dest
op_assign
(paren
id|u_long
op_star
)paren
id|start_mem
suffix:semicolon
l_int|1
suffix:colon
id|cmpl
id|a0
comma
id|a2
id|beqs
l_float|2f
op_or
r_while
(paren
id|src
OL
id|limit
)paren
id|moveb
id|a0
"@"
op_plus
comma
id|a1
"@"
op_plus
op_or
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
id|bras
l_int|1
id|b
l_int|2
suffix:colon
op_or
multiline_comment|/* clear kernel bss */
id|movel
id|a1
comma
id|a0
op_or
id|dest
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|start_mem
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
)paren
suffix:semicolon
id|movel
id|a1
comma
id|a2
op_or
id|limit
op_assign
id|dest
op_plus
id|kexec.a_bss
op_div
r_sizeof
(paren
id|u_long
)paren
suffix:semicolon
id|addl
id|d4
comma
id|a2
l_int|1
suffix:colon
id|cmpl
id|a0
comma
id|a2
id|beqs
l_float|2f
op_or
r_while
(paren
id|dest
OL
id|limit
)paren
id|clrb
id|a0
"@"
op_plus
op_or
op_star
id|dest
op_increment
op_assign
l_int|0
suffix:semicolon
id|bras
l_int|1
id|b
l_int|2
suffix:colon
op_or
multiline_comment|/* copy bootinfo to end of bss */
id|movel
id|a4
comma
id|a1
op_or
id|src
op_assign
(paren
id|u
r_int
op_star
)paren
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
)paren
suffix:semicolon
id|addl
id|d2
comma
id|a1
id|addl
id|d3
comma
id|a1
op_or
id|dest
op_assign
id|end
id|of
id|bss
(paren
id|already
id|in
id|a0
)paren
id|movel
id|d5
comma
id|d7
op_or
id|count
op_assign
r_sizeof
id|bi
id|subql
macro_line|#1,d7
l_int|1
suffix:colon
id|moveb
id|a1
"@"
op_plus
comma
id|a0
"@"
op_plus
op_or
r_while
c_loop
(paren
op_decrement
id|count
OG
op_minus
l_int|1
)paren
id|dbra
id|d7
comma
l_int|1
id|b
op_or
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
op_or
multiline_comment|/* copy the ramdisk to the top of memory (from back to front) */
id|movel
id|a5
comma
id|a1
op_or
id|dest
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|start_mem
op_plus
id|mem_size
)paren
suffix:semicolon
id|addl
id|d0
comma
id|a1
id|movel
id|a4
comma
id|a2
op_or
id|limit
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
op_plus
r_sizeof
id|bi
)paren
suffix:semicolon
id|addl
id|d2
comma
id|a2
id|addl
id|d3
comma
id|a2
id|addl
id|d5
comma
id|a2
id|movel
id|a2
comma
id|a0
op_or
id|src
op_assign
(paren
id|u_long
op_star
)paren
(paren
(paren
id|u_long
)paren
id|limit
op_plus
id|rd_size
)paren
suffix:semicolon
id|addl
id|d1
comma
id|a0
l_int|1
suffix:colon
id|cmpl
id|a0
comma
id|a2
id|beqs
l_float|2f
op_or
r_while
c_loop
(paren
id|src
OG
id|limit
)paren
id|moveb
id|a0
"@"
op_minus
comma
id|a1
"@"
op_minus
op_or
op_star
op_decrement
id|dest
op_assign
op_star
op_decrement
id|src
suffix:semicolon
id|bras
l_int|1
id|b
l_int|2
suffix:colon
op_or
multiline_comment|/* jump to start of kernel */
id|movel
id|a5
comma
id|a0
op_or
id|jump_to
(paren
id|START_MEM
)paren
suffix:semicolon
id|jsr
id|a0
"@"
id|_copyallend
suffix:colon
"&quot;"
)paren
suffix:semicolon
id|asm
c_func
(paren
"&quot;"
dot
id|text
dot
id|globl
id|_maprommed
id|_maprommed
suffix:colon
id|oriw
macro_line|#0x0700,sr
id|moveml
macro_line|#0x3f20,sp@-
multiline_comment|/* Save cache settings */
dot
r_int
l_int|0x4e7a1002
multiline_comment|/* movec cacr,d1 */
multiline_comment|/* Save MMU settings */
dot
r_int
l_int|0x4e7a2003
multiline_comment|/* movec tc,d2 */
dot
r_int
l_int|0x4e7a3004
multiline_comment|/* movec itt0,d3 */
dot
r_int
l_int|0x4e7a4005
multiline_comment|/* movec itt1,d4 */
dot
r_int
l_int|0x4e7a5006
multiline_comment|/* movec dtt0,d5 */
dot
r_int
l_int|0x4e7a6007
multiline_comment|/* movec dtt1,d6 */
id|moveq
macro_line|#0,d0
id|movel
id|d0
comma
id|a2
multiline_comment|/* Disable caches */
dot
r_int
l_int|0x4e7b0002
multiline_comment|/* movec d0,cacr */
multiline_comment|/* Disable MMU */
dot
r_int
l_int|0x4e7b0003
multiline_comment|/* movec d0,tc */
dot
r_int
l_int|0x4e7b0004
multiline_comment|/* movec d0,itt0 */
dot
r_int
l_int|0x4e7b0005
multiline_comment|/* movec d0,itt1 */
dot
r_int
l_int|0x4e7b0006
multiline_comment|/* movec d0,dtt0 */
dot
r_int
l_int|0x4e7b0007
multiline_comment|/* movec d0,dtt1 */
id|lea
l_int|0x07f80000
comma
id|a0
id|lea
l_int|0x00f80000
comma
id|a1
id|movel
id|a0
"@"
comma
id|d7
id|cmpl
id|a1
"@"
comma
id|d7
id|jnes
l_float|1f
id|movel
id|d7
comma
id|d0
id|notl
id|d0
id|movel
id|d0
comma
id|a0
"@"
id|nop
id|cmpl
id|a1
"@"
comma
id|d0
id|jnes
l_float|1f
multiline_comment|/* MapROMmed A3640 present */
id|moveq
macro_line|#-1,d0
id|movel
id|d0
comma
id|a2
l_int|1
suffix:colon
id|movel
id|d7
comma
id|a0
"@"
multiline_comment|/* Restore MMU settings */
dot
r_int
l_int|0x4e7b2003
multiline_comment|/* movec d2,tc */
dot
r_int
l_int|0x4e7b3004
multiline_comment|/* movec d3,itt0 */
dot
r_int
l_int|0x4e7b4005
multiline_comment|/* movec d4,itt1 */
dot
r_int
l_int|0x4e7b5006
multiline_comment|/* movec d5,dtt0 */
dot
r_int
l_int|0x4e7b6007
multiline_comment|/* movec d6,dtt1 */
multiline_comment|/* Restore cache settings */
dot
r_int
l_int|0x4e7b1002
multiline_comment|/* movec d1,cacr */
id|movel
id|a2
comma
id|d0
id|moveml
id|sp
"@"
op_plus
comma
macro_line|#0x04fc
id|rte
"&quot;"
)paren
suffix:semicolon
r_extern
r_int
r_int
id|maprommed
c_func
(paren
)paren
suffix:semicolon
r_extern
r_char
id|copyall
comma
id|copyallend
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|ch
comma
id|debugflag
op_assign
l_int|0
comma
id|kfd
comma
id|rfd
op_assign
op_minus
l_int|1
comma
id|i
suffix:semicolon
r_int
id|fast_total
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* total Fast RAM in system */
r_struct
id|MemHeader
op_star
id|mnp
suffix:semicolon
r_struct
id|ConfigDev
op_star
id|cdp
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|kernel_name
op_assign
l_string|&quot;vmlinux&quot;
suffix:semicolon
r_char
op_star
id|ramdisk_name
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|memfile
op_assign
l_int|NULL
suffix:semicolon
id|u_long
id|memreq
suffix:semicolon
r_void
(paren
op_star
id|startfunc
)paren
(paren
r_void
)paren
suffix:semicolon
r_int
id|startcodesize
suffix:semicolon
id|u_long
op_star
id|stack
comma
id|text_offset
suffix:semicolon
r_int
r_char
op_star
id|rb3_reg
op_assign
l_int|NULL
comma
op_star
id|piccolo_reg
op_assign
l_int|NULL
comma
op_star
id|sd64_reg
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* print the greet message */
id|puts
c_func
(paren
l_string|&quot;&f;Linux/68k Amiga Bootstrap version 1.11&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;Copyright 1993,1994 by Hamish Macdonald and Greg Harp&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* machine is Amiga */
id|bi.machtype
op_assign
id|MACH_AMIGA
suffix:semicolon
multiline_comment|/* check arguments */
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;dk:r:m:&quot;
)paren
)paren
op_ne
id|EOF
)paren
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
id|debugflag
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;k&squot;
suffix:colon
id|kernel_name
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|ramdisk_name
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|memfile
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
r_default
suffix:colon
id|usage
c_func
(paren
)paren
suffix:semicolon
)brace
id|argc
op_sub_assign
id|optind
suffix:semicolon
id|argv
op_add_assign
id|optind
suffix:semicolon
id|SysBase
op_assign
op_star
(paren
r_struct
id|ExecBase
op_star
op_star
)paren
l_int|4
suffix:semicolon
multiline_comment|/* Memory &amp; AutoConfig based on &squot;unix_boot.c&squot; by C= */
multiline_comment|/* open Expansion Library */
id|ExpansionBase
op_assign
(paren
r_struct
id|ExpansionBase
op_star
)paren
id|OpenLibrary
c_func
(paren
l_string|&quot;expansion.library&quot;
comma
l_int|36
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ExpansionBase
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Unable to open expansion.library V36 or greater!  Aborting...&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* find all of the autoconfig boards in the system */
id|cdp
op_assign
(paren
r_struct
id|ConfigDev
op_star
)paren
id|FindConfigDev
c_func
(paren
id|cdp
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|NUM_AUTO
)paren
op_logical_and
id|cdp
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* copy the contents of each structure into our boot info */
id|memcpy
c_func
(paren
op_amp
id|bi.bi_amiga.autocon
(braket
id|i
)braket
comma
id|cdp
comma
r_sizeof
(paren
r_struct
id|ConfigDev
)paren
)paren
suffix:semicolon
multiline_comment|/* count this device */
id|bi.bi_amiga.num_autocon
op_increment
suffix:semicolon
multiline_comment|/* get next device */
id|cdp
op_assign
(paren
r_struct
id|ConfigDev
op_star
)paren
id|FindConfigDev
c_func
(paren
id|cdp
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* find out the memory in the system */
r_for
c_loop
(paren
id|mnp
op_assign
(paren
r_struct
id|MemHeader
op_star
)paren
id|SysBase-&gt;MemList.l_head
suffix:semicolon
(paren
id|bi.num_memory
OL
id|NUM_MEMINFO
)paren
op_logical_and
id|mnp-&gt;mh_Node.ln_Succ
suffix:semicolon
id|mnp
op_assign
(paren
r_struct
id|MemHeader
op_star
)paren
id|mnp-&gt;mh_Node.ln_Succ
)paren
(brace
r_struct
id|MemHeader
id|mh
suffix:semicolon
multiline_comment|/* copy the information */
id|mh
op_assign
op_star
id|mnp
suffix:semicolon
multiline_comment|/* if we suspect that Kickstart is shadowed in an A3000,&n;&t;&t;   modify the entry to show 512K more at the top of RAM&n;&t;&t;   Check first for a MapROMmed A3640 board: overwriting the&n;&t;&t;   Kickstart image causes an infinite lock-up on reboot! */
r_if
c_cond
(paren
id|mh.mh_Upper
op_eq
(paren
r_void
op_star
)paren
l_int|0x07f80000
)paren
r_if
c_cond
(paren
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68040
)paren
op_logical_and
id|Supervisor
c_func
(paren
id|maprommed
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;A3640 MapROM detected.&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|mh.mh_Upper
op_assign
(paren
r_void
op_star
)paren
l_int|0x08000000
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;A3000 shadowed Kickstart detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* if we suspect that Kickstart is zkicked,&n;&t;&t;   modify the entry to show 512K more at the bottom of RAM */
r_if
c_cond
(paren
id|mh.mh_Lower
op_eq
(paren
r_void
op_star
)paren
l_int|0x00280020
)paren
(brace
id|mh.mh_Lower
op_assign
(paren
r_void
op_star
)paren
l_int|0x00200000
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ZKick detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If this machine has &quot;LOCAL&quot; memory between 0x07000000&n;&t;&t; * and 0x080000000, then we&squot;ll call it an A3000.&n;&t;&t; */
r_if
c_cond
(paren
id|mh.mh_Lower
op_ge
(paren
r_void
op_star
)paren
l_int|0x07000000
op_logical_and
id|mh.mh_Lower
OL
(paren
r_void
op_star
)paren
l_int|0x08000000
op_logical_and
(paren
id|mh.mh_Attributes
op_amp
id|MEMF_LOCAL
)paren
)paren
id|bi.bi_amiga.model
op_assign
id|AMI_3000
suffix:semicolon
multiline_comment|/* mask the memory limit values */
id|mh.mh_Upper
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
id|u_long
)paren
id|mh.mh_Upper
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
id|mh.mh_Lower
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
id|u_long
)paren
id|mh.mh_Lower
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
multiline_comment|/* if fast memory */
r_if
c_cond
(paren
id|mh.mh_Attributes
op_amp
id|MEMF_FAST
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* record the start */
id|bi.memory
(braket
id|bi.num_memory
)braket
dot
id|addr
op_assign
(paren
id|u_long
)paren
id|mh.mh_Lower
suffix:semicolon
multiline_comment|/* set the size value to the size of this block */
id|size
op_assign
(paren
id|u_long
)paren
id|mh.mh_Upper
op_minus
(paren
id|u_long
)paren
id|mh.mh_Lower
suffix:semicolon
multiline_comment|/* mask off to a 256K increment */
id|size
op_and_assign
l_int|0xfffc0000
suffix:semicolon
id|fast_total
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
multiline_comment|/* count this block */
id|bi.memory
(braket
id|bi.num_memory
op_increment
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mh.mh_Attributes
op_amp
id|MEMF_CHIP
)paren
(brace
multiline_comment|/* if CHIP memory, record the size */
id|bi.bi_amiga.chip_size
op_assign
(paren
id|u_long
)paren
id|mh.mh_Upper
suffix:semicolon
multiline_comment|/* - (u_long)mh.mh_Lower; */
)brace
)brace
id|CloseLibrary
c_func
(paren
(paren
r_struct
id|Library
op_star
)paren
id|ExpansionBase
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if we have a memory file, read the memory information from it&n;&t; */
r_if
c_cond
(paren
id|memfile
)paren
(brace
id|FILE
op_star
id|fp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fp
op_assign
id|fopen
(paren
id|memfile
comma
l_string|&quot;r&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|perror
(paren
l_string|&quot;open memory file&quot;
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Cannot open memory file %s&bslash;n&quot;
comma
id|memfile
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fscanf
(paren
id|fp
comma
l_string|&quot;%lu&quot;
comma
op_amp
id|bi.bi_amiga.chip_size
)paren
op_ne
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;memory file does not contain chip memory size&bslash;n&quot;
)paren
suffix:semicolon
id|fclose
(paren
id|fp
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_MEMINFO
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|fscanf
(paren
id|fp
comma
l_string|&quot;%lx %lu&quot;
comma
op_amp
id|bi.memory
(braket
id|i
)braket
dot
id|addr
comma
op_amp
id|bi.memory
(braket
id|i
)braket
dot
id|size
)paren
op_ne
l_int|2
)paren
r_break
suffix:semicolon
)brace
id|fclose
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|bi.num_memory
op_logical_and
id|i
OG
l_int|0
)paren
id|bi.num_memory
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* get info from ExecBase */
id|bi.bi_amiga.vblank
op_assign
id|SysBase-&gt;VBlankFrequency
suffix:semicolon
id|bi.bi_amiga.psfreq
op_assign
id|SysBase-&gt;PowerSupplyFrequency
suffix:semicolon
id|bi.bi_amiga.eclock
op_assign
id|SysBase-&gt;EClockFrequency
suffix:semicolon
multiline_comment|/* open graphics library */
id|GfxBase
op_assign
(paren
r_struct
id|GfxBase
op_star
)paren
id|OpenLibrary
(paren
l_string|&quot;graphics.library&quot;
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* determine chipset */
id|bi.bi_amiga.chipset
op_assign
id|CS_STONEAGE
suffix:semicolon
r_if
c_cond
(paren
id|GfxBase
)paren
(brace
r_if
c_cond
(paren
id|GfxBase-&gt;ChipRevBits0
op_amp
id|GFXG_AGA
)paren
(brace
id|bi.bi_amiga.chipset
op_assign
id|CS_AGA
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  we considered this machine to be an A3000 because of its&n;&t;&t; *  local memory just beneath $8000000; now if it has AGA, it&n;&t;&t; *  must be an A4000&n;&t;&t; *  except the case no RAM is installed on the motherboard but&n;&t;&t; *  on an additional card like FastLane Z3 or on the processor&n;&t;&t; *  board itself. Gotta check this out.&n;&t;&t; */
id|bi.bi_amiga.model
op_assign
(paren
id|bi.bi_amiga.model
op_eq
id|AMI_3000
)paren
ques
c_cond
id|AMI_4000
suffix:colon
id|AMI_1200
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|GfxBase-&gt;ChipRevBits0
op_amp
id|GFXG_ECS
)paren
(brace
id|bi.bi_amiga.chipset
op_assign
id|CS_ECS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|GfxBase-&gt;ChipRevBits0
op_amp
id|GFXG_OCS
)paren
(brace
id|bi.bi_amiga.chipset
op_assign
id|CS_OCS
suffix:semicolon
)brace
)brace
multiline_comment|/* Display amiga model */
r_switch
c_cond
(paren
id|bi.bi_amiga.model
)paren
(brace
r_case
id|AMI_UNKNOWN
suffix:colon
r_break
suffix:semicolon
r_case
id|AMI_500
suffix:colon
id|printf
(paren
l_string|&quot;Amiga 500 &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AMI_2000
suffix:colon
id|printf
(paren
l_string|&quot;Amiga 2000 &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AMI_3000
suffix:colon
id|printf
(paren
l_string|&quot;Amiga 3000 &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AMI_4000
suffix:colon
id|printf
(paren
l_string|&quot;Amiga 4000 &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AMI_1200
suffix:colon
multiline_comment|/* this implies an upgraded model   */
id|printf
(paren
l_string|&quot;Amiga 1200 &quot;
)paren
suffix:semicolon
multiline_comment|/* equipped with at least 68030 !!! */
r_break
suffix:semicolon
)brace
multiline_comment|/* display and set the CPU &lt;type */
id|printf
c_func
(paren
l_string|&quot;CPU: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68040
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;68040&quot;
)paren
suffix:semicolon
id|bi.cputype
op_assign
id|CPU_68040
suffix:semicolon
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_FPU40
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; with internal FPU&quot;
)paren
suffix:semicolon
id|bi.cputype
op_or_assign
id|FPU_68040
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot; without FPU&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68030
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;68030&quot;
)paren
suffix:semicolon
id|bi.cputype
op_assign
id|CPU_68030
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68020
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;68020 (Do you have an MMU?)&quot;
)paren
suffix:semicolon
id|bi.cputype
op_assign
id|CPU_68020
suffix:semicolon
)brace
r_else
(brace
id|puts
c_func
(paren
l_string|&quot;Insufficient for Linux.  Aborting...&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SysBase-&gt;AttnFlags = %#x&bslash;n&quot;
comma
id|SysBase-&gt;AttnFlags
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68882
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; with 68882 FPU&quot;
)paren
suffix:semicolon
id|bi.cputype
op_or_assign
id|FPU_68882
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68881
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; with 68881 FPU&quot;
)paren
suffix:semicolon
id|bi.cputype
op_or_assign
id|FPU_68881
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot; without FPU&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bi.bi_amiga.chipset
)paren
(brace
r_case
id|CS_STONEAGE
suffix:colon
id|printf
c_func
(paren
l_string|&quot;, old or unknown chipset&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_OCS
suffix:colon
id|printf
c_func
(paren
l_string|&quot;, OCS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_ECS
suffix:colon
id|printf
c_func
(paren
l_string|&quot;, ECS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_AGA
suffix:colon
id|printf
c_func
(paren
l_string|&quot;, AGA chipset&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|putchar
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|putchar
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy command line options into the kernel command line.&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_plus
id|strlen
c_func
(paren
op_star
id|argv
)paren
op_plus
l_int|1
)paren
OL
id|CL_SIZE
)paren
(brace
id|i
op_add_assign
id|strlen
c_func
(paren
op_star
id|argv
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bi.command_line
(braket
l_int|0
)braket
)paren
id|strcat
(paren
id|bi.command_line
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|strcat
(paren
id|bi.command_line
comma
op_star
id|argv
op_increment
)paren
suffix:semicolon
)brace
)brace
id|printf
(paren
l_string|&quot;Command line is &squot;%s&squot;&bslash;n&quot;
comma
id|bi.command_line
)paren
suffix:semicolon
multiline_comment|/* display the clock statistics */
id|printf
c_func
(paren
l_string|&quot;Vertical Blank Frequency: %dHz&bslash;nPower Supply Frequency: %dHz&bslash;n&quot;
comma
id|bi.bi_amiga.vblank
comma
id|bi.bi_amiga.psfreq
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;EClock Frequency: %7.5fKHz&bslash;n&bslash;n&quot;
comma
(paren
r_float
)paren
id|bi.bi_amiga.eclock
op_div
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* display autoconfig devices */
r_if
c_cond
(paren
id|bi.bi_amiga.num_autocon
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Found %d AutoConfig Device%s&quot;
comma
id|bi.bi_amiga.num_autocon
comma
(paren
id|bi.bi_amiga.num_autocon
OG
l_int|1
)paren
ques
c_cond
l_string|&quot;s&bslash;n&quot;
suffix:colon
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.bi_amiga.num_autocon
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Device %d: addr = %08lx&bslash;n&quot;
comma
id|i
comma
(paren
id|u_long
)paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_BoardAddr
)paren
suffix:semicolon
multiline_comment|/* check for a Rainbow 3 and prepare to reset it if there is one */
r_if
c_cond
(paren
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Manufacturer
op_eq
id|MANUF_HELFRICH1
)paren
op_logical_and
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Product
op_eq
id|PROD_RAINBOW3
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(Found a Rainbow 3 board - will reset it at kernel boot time)&bslash;n&quot;
)paren
suffix:semicolon
id|rb3_reg
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_BoardAddr
op_plus
l_int|0x01002000
)paren
suffix:semicolon
)brace
multiline_comment|/* check for a Piccolo and prepare to reset it if there is one */
r_if
c_cond
(paren
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Manufacturer
op_eq
id|MANUF_HELFRICH2
)paren
op_logical_and
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Product
op_eq
id|PROD_PICCOLO_REG
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(Found a Piccolo board - will reset it at kernel boot time)&bslash;n&quot;
)paren
suffix:semicolon
id|piccolo_reg
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_BoardAddr
op_plus
l_int|0x8000
)paren
suffix:semicolon
)brace
multiline_comment|/* check for a SD64 and prepare to reset it if there is one */
r_if
c_cond
(paren
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Manufacturer
op_eq
id|MANUF_HELFRICH2
)paren
op_logical_and
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Product
op_eq
id|PROD_SD64_REG
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(Found a SD64 board - will reset it at kernel boot time)&bslash;n&quot;
)paren
suffix:semicolon
id|sd64_reg
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|bi.bi_amiga.autocon
(braket
id|i
)braket
dot
id|cd_BoardAddr
op_plus
l_int|0x8000
)paren
suffix:semicolon
)brace
multiline_comment|/* what this code lacks - what if there are several boards of  */
multiline_comment|/* the same brand ? In that case I should reset them one after */
multiline_comment|/* the other, which is currently not done - a rare case...FN   */
multiline_comment|/* ok, MY amiga currently hosts all three of the above boards ;-) */
)brace
)brace
r_else
id|puts
c_func
(paren
l_string|&quot;No AutoConfig Devices Found&quot;
)paren
suffix:semicolon
multiline_comment|/* display memory */
r_if
c_cond
(paren
id|bi.num_memory
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n%d Block%sof Memory Found&bslash;n&quot;
comma
id|bi.num_memory
comma
(paren
id|bi.num_memory
OG
l_int|1
)paren
ques
c_cond
l_string|&quot;s &quot;
suffix:colon
l_string|&quot; &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_memory
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Block %d: %08lx to %08lx (%ldKB)&bslash;n&quot;
comma
id|i
comma
id|bi.memory
(braket
id|i
)braket
dot
id|addr
comma
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|bi.memory
(braket
id|i
)braket
dot
id|size
comma
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|puts
c_func
(paren
l_string|&quot;No memory found?!  Aborting...&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* display chip memory size */
id|printf
(paren
l_string|&quot;%ldK of CHIP memory&bslash;n&quot;
comma
id|bi.bi_amiga.chip_size
op_rshift
l_int|10
)paren
suffix:semicolon
id|start_mem
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|addr
suffix:semicolon
id|mem_size
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
multiline_comment|/* tell us where the kernel will go */
id|printf
c_func
(paren
l_string|&quot;&bslash;nThe kernel will be located at %08lx&bslash;n&quot;
comma
id|start_mem
)paren
suffix:semicolon
multiline_comment|/* verify that there is enough Chip RAM */
r_if
c_cond
(paren
id|bi.bi_amiga.chip_size
OL
l_int|512
op_star
l_int|1024
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;&bslash;nNot enough Chip RAM in this system.  Aborting...&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* verify that there is enough Fast RAM */
r_if
c_cond
(paren
id|fast_total
OL
l_int|2
op_star
l_int|1024
op_star
l_int|1024
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;&bslash;nNot enough Fast RAM in this system.  Aborting...&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* open kernel executable and read exec header */
r_if
c_cond
(paren
(paren
id|kfd
op_assign
id|open
(paren
id|kernel_name
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to open kernel file %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
op_amp
id|kexec
comma
r_sizeof
(paren
id|kexec
)paren
)paren
op_ne
r_sizeof
(paren
id|kexec
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to read exec header from %s&bslash;n&quot;
comma
id|kernel_name
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
(brace
r_case
id|ZMAGIC
suffix:colon
id|text_offset
op_assign
id|N_TXTOFF
c_func
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QMAGIC
suffix:colon
id|text_offset
op_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
multiline_comment|/* the text size includes the exec header; remove this */
id|kexec.a_text
op_sub_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Wrong magic number %lo in kernel header&bslash;n&quot;
comma
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* Load the kernel at one page after start of mem */
id|start_mem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|mem_size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Align bss size to multiple of four */
id|kexec.a_bss
op_assign
(paren
id|kexec.a_bss
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ramdisk_name
)paren
(brace
r_if
c_cond
(paren
(paren
id|rfd
op_assign
id|open
(paren
id|ramdisk_name
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to open ramdisk file %s&bslash;n&quot;
comma
id|ramdisk_name
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* record ramdisk size */
id|bi.ramdisk_size
op_assign
(paren
id|lseek
(paren
id|rfd
comma
l_int|0
comma
id|L_XTND
)paren
op_plus
l_int|1023
)paren
op_rshift
l_int|10
suffix:semicolon
)brace
r_else
id|bi.ramdisk_size
op_assign
l_int|0
suffix:semicolon
id|rd_size
op_assign
id|bi.ramdisk_size
op_lshift
l_int|10
suffix:semicolon
id|bi.ramdisk_addr
op_assign
(paren
id|u_long
)paren
id|start_mem
op_plus
id|mem_size
op_minus
id|rd_size
suffix:semicolon
id|memreq
op_assign
id|kexec.a_text
op_plus
id|kexec.a_data
op_plus
r_sizeof
(paren
id|bi
)paren
op_plus
id|rd_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|memptr
op_assign
(paren
r_char
op_star
)paren
id|AllocMem
(paren
id|memreq
comma
id|MEMF_FAST
op_or
id|MEMF_CLEAR
)paren
)paren
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to allocate memory&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lseek
(paren
id|kfd
comma
id|text_offset
comma
id|L_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to text&bslash;n&quot;
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read
(paren
id|kfd
comma
id|memptr
comma
id|kexec.a_text
)paren
op_ne
id|kexec.a_text
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read text&bslash;n&quot;
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* data follows immediately after text */
r_if
c_cond
(paren
id|read
(paren
id|kfd
comma
id|memptr
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
op_ne
id|kexec.a_data
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read data&bslash;n&quot;
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|close
(paren
id|kfd
)paren
suffix:semicolon
multiline_comment|/* copy the boot_info struct to the end of the kernel image */
id|memcpy
(paren
(paren
r_void
op_star
)paren
(paren
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
)paren
comma
op_amp
id|bi
comma
r_sizeof
(paren
id|bi
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rfd
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|lseek
(paren
id|rfd
comma
l_int|0
comma
id|L_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to seek to beginning of ramdisk file&bslash;n&quot;
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read
(paren
id|rfd
comma
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
op_plus
r_sizeof
(paren
id|bi
)paren
comma
id|rd_size
)paren
op_ne
id|rd_size
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Failed to read ramdisk file&bslash;n&quot;
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
id|close
(paren
id|rfd
)paren
suffix:semicolon
)brace
multiline_comment|/* allocate temporary chip ram stack */
id|stack
op_assign
(paren
id|u_long
op_star
)paren
id|AllocMem
c_func
(paren
id|TEMP_STACKSIZE
comma
id|MEMF_CHIP
op_or
id|MEMF_CLEAR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stack
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to allocate memory for stack&bslash;n&quot;
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* allocate chip ram for copy of startup code */
id|startcodesize
op_assign
op_amp
id|copyallend
op_minus
op_amp
id|copyall
suffix:semicolon
id|startfunc
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
)paren
)paren
id|AllocMem
c_func
(paren
id|startcodesize
comma
id|MEMF_CHIP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|startfunc
)paren
(brace
id|fprintf
(paren
id|stderr
comma
l_string|&quot;Unable to allocate memory for code&bslash;n&quot;
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
id|FreeMem
(paren
(paren
r_void
op_star
)paren
id|stack
comma
id|TEMP_STACKSIZE
)paren
suffix:semicolon
m_exit
(paren
id|EXIT_FAILURE
)paren
suffix:semicolon
)brace
multiline_comment|/* copy startup code to CHIP RAM */
id|memcpy
(paren
id|startfunc
comma
op_amp
id|copyall
comma
id|startcodesize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
(brace
r_if
c_cond
(paren
id|bi.ramdisk_size
)paren
id|printf
(paren
l_string|&quot;RAM disk at %#lx, size is %ldK&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
comma
id|bi.ramdisk_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;nKernel text at %#lx, code size %x&bslash;n&quot;
comma
id|start_mem
comma
id|kexec.a_text
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Kernel data at %#lx, data size %x&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Kernel bss  at %#lx, bss  size %x&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
comma
id|kexec.a_bss
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;boot info at %#lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
op_plus
id|kexec.a_bss
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;&bslash;nKernel entry is %#x&bslash;n&quot;
comma
id|kexec.a_entry
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk dest top is %#lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|mem_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk lower limit is %#lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
)paren
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ramdisk src top is %#lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
)paren
op_plus
id|rd_size
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;Type a key to continue the Linux boot...&quot;
)paren
suffix:semicolon
id|fflush
(paren
id|stdout
)paren
suffix:semicolon
id|getchar
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* wait for things to settle down */
id|sleep
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* FN: If a Rainbow III board is present, reset it to disable */
multiline_comment|/* its (possibly activated) vertical blank interrupts as the */
multiline_comment|/* kernel is not yet prepared to handle them (level 6). */
r_if
c_cond
(paren
id|rb3_reg
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* set RESET bit in special function register */
op_star
id|rb3_reg
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* actually, only a few cycles delay are required... */
id|sleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* clear reset bit */
op_star
id|rb3_reg
op_assign
l_int|0x00
suffix:semicolon
)brace
multiline_comment|/* the same stuff as above, for the Piccolo board. */
multiline_comment|/* this also has the side effect of resetting the board&squot;s */
multiline_comment|/* output selection logic to use the Amiga&squot;s display in single */
multiline_comment|/* monitor systems - which is currently what we want. */
r_if
c_cond
(paren
id|piccolo_reg
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* set RESET bit in special function register */
op_star
id|piccolo_reg
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* actually, only a few cycles delay are required... */
id|sleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* clear reset bit */
op_star
id|piccolo_reg
op_assign
l_int|0x51
suffix:semicolon
)brace
multiline_comment|/* the same stuff as above, for the SD64 board. */
multiline_comment|/* just as on the Piccolo, this also resets the monitor switch */
r_if
c_cond
(paren
id|sd64_reg
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* set RESET bit in special function register */
op_star
id|sd64_reg
op_assign
l_int|0x1f
suffix:semicolon
multiline_comment|/* actually, only a few cycles delay are required... */
id|sleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* clear reset bit AND switch monitor bit (0x20) */
op_star
id|sd64_reg
op_assign
l_int|0x4f
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GfxBase
)paren
(brace
multiline_comment|/* set graphics mode to a nice normal one */
id|LoadView
(paren
l_int|NULL
)paren
suffix:semicolon
id|CloseLibrary
(paren
(paren
r_struct
id|Library
op_star
)paren
id|GfxBase
)paren
suffix:semicolon
)brace
id|Disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Turn off all DMA */
id|custom.dmacon
op_assign
id|DMAF_ALL
op_or
id|DMAF_MASTER
suffix:semicolon
multiline_comment|/* turn off caches */
id|CacheControl
(paren
l_int|0L
comma
op_complement
l_int|0L
)paren
suffix:semicolon
multiline_comment|/* Go into supervisor state */
id|SuperState
(paren
)paren
suffix:semicolon
multiline_comment|/* setup stack */
id|change_stack
(paren
(paren
r_char
op_star
)paren
id|stack
op_plus
id|TEMP_STACKSIZE
)paren
suffix:semicolon
multiline_comment|/* turn off any mmu translation */
id|disable_mmu
(paren
)paren
suffix:semicolon
multiline_comment|/* execute the copy-and-go code (from CHIP RAM) */
id|startfunc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
eof
