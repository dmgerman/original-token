multiline_comment|/*&n; *  linux/arch/m68k/boot/amiga/linuxboot.c -- Generic routine to boot Linux/m68k&n; *&t;&t;&t;&t;&t;      on Amiga, used by both Amiboot and&n; *&t;&t;&t;&t;&t;      Amiga-Lilo.&n; *&n; *&t;Created 1996 by Geert Uytterhoeven&n; *&n; *&n; *  This file is based on the original bootstrap code (bootstrap.c):&n; *&n; *&t;Copyright (C) 1993, 1994 Hamish Macdonald&n; *&t;&t;&t;&t; Greg Harp&n; *&n; *&t;&t;    with work by Michael Rausch&n; *&t;&t;&t;&t; Geert Uytterhoeven&n; *&t;&t;&t;&t; Frank Neumann&n; *&t;&t;&t;&t; Andreas Schwab&n; *&n; *&n; *  This file is subject to the terms and conditions of the GNU General Public&n; *  License.  See the file COPYING in the main directory of this archive&n; *  for more details.&n; *&n; *  History:&n; *&t;03 Feb 1997 Implemented kernel decompression (Geert, based on Roman&squot;s&n; *&t;&t;    code for ataboot)&n; *&t;30 Dec 1996 Reverted the CPU detection to the old scheme&n; *&t;&t;    New boot parameter override scheme (Geert)&n; *      27 Nov 1996 Compatibility with bootinfo interface version 1.0 (Geert)&n; *       9 Sep 1996 Rewritten option parsing&n; *&t;&t;    New parameter passing to linuxboot() (linuxboot_args)&n; *&t;&t;    (Geert)&n; *&t;18 Aug 1996 Updated for the new boot information structure (Geert)&n; *&t;10 Jan 1996 The real Linux/m68k boot code moved to linuxboot.[ch]&n; *&t;&t;    (Geert)&n; *&t;11 Jul 1995 Support for ELF kernel (untested!) (Andreas)&n; *&t; 7 Mar 1995 Memory block sizes are rounded to a multiple of 256K&n; *&t;&t;    instead of 1M (Geert)&n; *&t;31 May 1994 Memory thrash problem solved (Geert)&n; *&t;11 May 1994 A3640 MapROM check (Geert)&n; */
macro_line|#ifndef __GNUC__
macro_line|#error GNU CC is required to compile this program
macro_line|#endif /* __GNUC__ */
DECL|macro|BOOTINFO_COMPAT_1_0
mdefine_line|#define BOOTINFO_COMPAT_1_0&t;/* bootinfo interface version 1.0 compatible */
multiline_comment|/* support compressed kernels? */
DECL|macro|ZKERNEL
mdefine_line|#define ZKERNEL
macro_line|#include &lt;stddef.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &quot;linuxboot.h&quot;
DECL|macro|custom
macro_line|#undef custom
DECL|macro|custom
mdefine_line|#define custom ((*(volatile struct CUSTOM *)(CUSTOM_PHYSADDR)))
multiline_comment|/* temporary stack size */
DECL|macro|TEMP_STACKSIZE
mdefine_line|#define TEMP_STACKSIZE&t;(256)
DECL|macro|DEFAULT_BAUD
mdefine_line|#define DEFAULT_BAUD&t;(9600)
r_extern
r_char
id|copyall
comma
id|copyallend
suffix:semicolon
DECL|variable|kexec
r_static
r_struct
id|exec
id|kexec
suffix:semicolon
DECL|variable|kexec_elf
r_static
id|Elf32_Ehdr
id|kexec_elf
suffix:semicolon
DECL|variable|linuxboot_args
r_static
r_const
r_struct
id|linuxboot_args
op_star
id|linuxboot_args
suffix:semicolon
multiline_comment|/* Bootinfo */
DECL|variable|bi
r_struct
id|amiga_bootinfo
id|bi
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
DECL|variable|compat_bootinfo
r_static
r_struct
id|compat_bootinfo
id|compat_bootinfo
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
DECL|macro|MAX_BI_SIZE
mdefine_line|#define MAX_BI_SIZE&t;(4096)
DECL|variable|bi_size
r_static
id|u_long
id|bi_size
suffix:semicolon
r_static
r_union
(brace
DECL|member|record
r_struct
id|bi_record
id|record
suffix:semicolon
DECL|member|fake
id|u_char
id|fake
(braket
id|MAX_BI_SIZE
)braket
suffix:semicolon
DECL|variable|bi_union
)brace
id|bi_union
suffix:semicolon
DECL|macro|kernelname
mdefine_line|#define kernelname&t;linuxboot_args-&gt;kernelname
DECL|macro|ramdiskname
mdefine_line|#define ramdiskname&t;linuxboot_args-&gt;ramdiskname
DECL|macro|debugflag
mdefine_line|#define debugflag&t;linuxboot_args-&gt;debugflag
DECL|macro|keep_video
mdefine_line|#define keep_video&t;linuxboot_args-&gt;keep_video
DECL|macro|reset_boards
mdefine_line|#define reset_boards&t;linuxboot_args-&gt;reset_boards
DECL|macro|baud
mdefine_line|#define baud&t;&t;linuxboot_args-&gt;baud
DECL|macro|Puts
mdefine_line|#define Puts&t;&t;linuxboot_args-&gt;puts
DECL|macro|GetChar
mdefine_line|#define GetChar&t;&t;linuxboot_args-&gt;getchar
DECL|macro|PutChar
mdefine_line|#define PutChar&t;&t;linuxboot_args-&gt;putchar
DECL|macro|Printf
mdefine_line|#define Printf&t;&t;linuxboot_args-&gt;printf
DECL|macro|Open
mdefine_line|#define Open&t;&t;linuxboot_args-&gt;open
DECL|macro|Seek
mdefine_line|#define Seek&t;&t;linuxboot_args-&gt;seek
DECL|macro|Read
mdefine_line|#define Read&t;&t;linuxboot_args-&gt;read
DECL|macro|Close
mdefine_line|#define Close&t;&t;linuxboot_args-&gt;close
DECL|macro|FileSize
mdefine_line|#define FileSize&t;linuxboot_args-&gt;filesize
DECL|macro|Sleep
mdefine_line|#define Sleep&t;&t;linuxboot_args-&gt;sleep
multiline_comment|/*&n;     *  Function Prototypes&n;     */
r_static
id|u_long
id|get_chipset
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|get_processor
c_func
(paren
id|u_long
op_star
id|cpu
comma
id|u_long
op_star
id|fpu
comma
id|u_long
op_star
id|mmu
)paren
suffix:semicolon
r_static
id|u_long
id|get_model
c_func
(paren
id|u_long
id|chipset
)paren
suffix:semicolon
r_static
r_int
id|probe_resident
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_int
id|probe_resource
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_int
id|create_bootinfo
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_static
r_int
id|create_compat_bootinfo
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
r_static
r_int
id|add_bi_record
c_func
(paren
id|u_short
id|tag
comma
id|u_short
id|size
comma
r_const
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|add_bi_string
c_func
(paren
id|u_short
id|tag
comma
r_const
id|u_char
op_star
id|s
)paren
suffix:semicolon
r_static
r_int
id|check_bootinfo_version
c_func
(paren
r_const
r_char
op_star
id|memptr
)paren
suffix:semicolon
r_static
r_void
id|start_kernel
c_func
(paren
r_void
(paren
op_star
id|startfunc
)paren
(paren
)paren
comma
r_char
op_star
id|stackp
comma
r_char
op_star
id|memptr
comma
id|u_long
id|start_mem
comma
id|u_long
id|mem_size
comma
id|u_long
id|rd_size
comma
id|u_long
id|kernel_size
)paren
id|__attribute__
(paren
(paren
id|noreturn
)paren
)paren
suffix:semicolon
id|asmlinkage
id|u_long
id|maprommed
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
id|u_long
id|check346
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef ZKERNEL
r_static
r_int
id|load_zkernel
c_func
(paren
r_int
id|fd
)paren
suffix:semicolon
r_static
r_int
id|KRead
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|buf
comma
r_int
id|cnt
)paren
suffix:semicolon
r_static
r_int
id|KSeek
c_func
(paren
r_int
id|fd
comma
r_int
id|offset
)paren
suffix:semicolon
r_static
r_int
id|KClose
c_func
(paren
r_int
id|fd
)paren
suffix:semicolon
macro_line|#else
DECL|macro|KRead
mdefine_line|#define KRead&t;&t;Read
DECL|macro|KSeek
mdefine_line|#define KSeek&t;&t;Seek
DECL|macro|KClose
mdefine_line|#define KClose&t;&t;Close
macro_line|#endif
multiline_comment|/*&n;     *&t;Reset functions for nasty Zorro boards&n;     */
r_static
r_void
id|reset_rb3
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
r_static
r_void
id|reset_piccolo
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
r_static
r_void
id|reset_sd64
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
r_static
r_void
id|reset_ariadne
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
r_static
r_void
id|reset_hydra
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
macro_line|#if 0
r_static
r_void
id|reset_a2060
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
macro_line|#endif
DECL|struct|boardreset
r_struct
id|boardreset
(brace
DECL|member|manuf
id|u_short
id|manuf
suffix:semicolon
DECL|member|prod
id|u_short
id|prod
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|reset
r_void
(paren
op_star
id|reset
)paren
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|boardresetdb
r_static
r_struct
id|boardreset
id|boardresetdb
(braket
)braket
op_assign
(brace
(brace
id|MANUF_HELFRICH1
comma
id|PROD_RAINBOW3
comma
l_string|&quot;Rainbow 3&quot;
comma
id|reset_rb3
)brace
comma
(brace
id|MANUF_HELFRICH2
comma
id|PROD_PICCOLO_REG
comma
l_string|&quot;Piccolo&quot;
comma
id|reset_piccolo
)brace
comma
(brace
id|MANUF_HELFRICH2
comma
id|PROD_SD64_REG
comma
l_string|&quot;SD64&quot;
comma
id|reset_sd64
)brace
comma
(brace
id|MANUF_VILLAGE_TRONIC
comma
id|PROD_ARIADNE
comma
l_string|&quot;Ariadne&quot;
comma
id|reset_ariadne
)brace
comma
(brace
id|MANUF_HYDRA_SYSTEMS
comma
id|PROD_AMIGANET
comma
l_string|&quot;Hydra&quot;
comma
id|reset_hydra
)brace
comma
macro_line|#if 0
(brace
id|MANUF_COMMODORE
comma
id|PROD_A2060
comma
l_string|&quot;A2060&quot;
comma
id|reset_a2060
)brace
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|NUM_BOARDRESET
mdefine_line|#define NUM_BOARDRESET&t;sizeof(boardresetdb)/sizeof(*boardresetdb)
DECL|variable|boardresetfuncs
r_static
r_void
(paren
op_star
id|boardresetfuncs
(braket
id|ZORRO_NUM_AUTO
)braket
)paren
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
suffix:semicolon
DECL|variable|amiga_models
r_const
r_char
op_star
id|amiga_models
(braket
)braket
op_assign
(brace
l_string|&quot;Amiga 500&quot;
comma
l_string|&quot;Amiga 500+&quot;
comma
l_string|&quot;Amiga 600&quot;
comma
l_string|&quot;Amiga 1000&quot;
comma
l_string|&quot;Amiga 1200&quot;
comma
l_string|&quot;Amiga 2000&quot;
comma
l_string|&quot;Amiga 2500&quot;
comma
l_string|&quot;Amiga 3000&quot;
comma
l_string|&quot;Amiga 3000T&quot;
comma
l_string|&quot;Amiga 3000+&quot;
comma
l_string|&quot;Amiga 4000&quot;
comma
l_string|&quot;Amiga 4000T&quot;
comma
l_string|&quot;CDTV&quot;
comma
l_string|&quot;CD32&quot;
comma
l_string|&quot;Draco&quot;
)brace
suffix:semicolon
DECL|variable|first_amiga_model
r_const
id|u_long
id|first_amiga_model
op_assign
id|AMI_500
suffix:semicolon
DECL|variable|last_amiga_model
r_const
id|u_long
id|last_amiga_model
op_assign
id|AMI_DRACO
suffix:semicolon
DECL|macro|MASK
mdefine_line|#define MASK(model)&t;(1&lt;&lt;AMI_##model)
DECL|macro|CLASS_A3000
mdefine_line|#define CLASS_A3000&t;(MASK(3000) | MASK(3000T))
DECL|macro|CLASS_A4000
mdefine_line|#define CLASS_A4000&t;(MASK(4000) | MASK(4000T))
DECL|macro|CLASS_ZKICK
mdefine_line|#define CLASS_ZKICK&t;(MASK(500) | MASK(1000) | MASK(2000) | MASK(2500))
multiline_comment|/*&n;     *&t;Boot the Linux/m68k Operating System&n;     */
DECL|function|linuxboot
id|u_long
id|linuxboot
c_func
(paren
r_const
r_struct
id|linuxboot_args
op_star
id|args
)paren
(brace
r_int
id|kfd
op_assign
op_minus
l_int|1
comma
id|rfd
op_assign
op_minus
l_int|1
comma
id|elf_kernel
op_assign
l_int|0
comma
id|do_fast
comma
id|do_chip
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_const
r_struct
id|MemHeader
op_star
id|mnp
suffix:semicolon
r_struct
id|ConfigDev
op_star
id|cdp
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|memptr
op_assign
l_int|NULL
suffix:semicolon
id|u_long
op_star
id|stack
op_assign
l_int|NULL
suffix:semicolon
id|u_long
id|fast_total
comma
id|model_mask
comma
id|startcodesize
comma
id|start_mem
comma
id|mem_size
comma
id|rd_size
suffix:semicolon
id|u_long
id|kernel_size
suffix:semicolon
id|u_int
id|realbaud
suffix:semicolon
id|u_long
id|memreq
op_assign
l_int|0
comma
id|text_offset
op_assign
l_int|0
suffix:semicolon
id|Elf32_Phdr
op_star
id|kernel_phdrs
op_assign
l_int|NULL
suffix:semicolon
r_void
(paren
op_star
id|startfunc
)paren
(paren
r_void
)paren
suffix:semicolon
id|u_short
id|manuf
suffix:semicolon
id|u_char
id|prod
suffix:semicolon
r_void
op_star
id|bi_ptr
suffix:semicolon
id|linuxboot_args
op_assign
id|args
suffix:semicolon
multiline_comment|/* print the greet message */
id|Puts
c_func
(paren
l_string|&quot;&bslash;nLinux/m68k Amiga Bootstrap version &quot;
id|AMIBOOT_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|Puts
c_func
(paren
l_string|&quot;Copyright 1993,1994 by Hamish Macdonald and Greg Harp&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Note: Initial values in bi override detected values */
id|bi
op_assign
id|args-&gt;bi
suffix:semicolon
multiline_comment|/* machine is Amiga */
id|bi.machtype
op_assign
id|MACH_AMIGA
suffix:semicolon
multiline_comment|/* determine chipset */
r_if
c_cond
(paren
op_logical_neg
id|bi.chipset
)paren
id|bi.chipset
op_assign
id|get_chipset
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* determine CPU, FPU and MMU type */
r_if
c_cond
(paren
op_logical_neg
id|bi.cputype
)paren
id|get_processor
c_func
(paren
op_amp
id|bi.cputype
comma
op_amp
id|bi.fputype
comma
op_amp
id|bi.mmutype
)paren
suffix:semicolon
multiline_comment|/* determine Amiga model */
r_if
c_cond
(paren
op_logical_neg
id|bi.model
)paren
id|bi.model
op_assign
id|get_model
c_func
(paren
id|bi.chipset
)paren
suffix:semicolon
id|model_mask
op_assign
(paren
id|bi.model
op_ne
id|AMI_UNKNOWN
)paren
ques
c_cond
l_int|1
op_lshift
id|bi.model
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Memory &amp; AutoConfig based on &squot;unix_boot.c&squot; by C= */
multiline_comment|/* find all of the autoconfig boards in the system */
r_if
c_cond
(paren
op_logical_neg
id|bi.num_autocon
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|cdp
op_assign
(paren
r_struct
id|ConfigDev
op_star
)paren
id|FindConfigDev
c_func
(paren
id|cdp
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|bi.num_autocon
OL
id|ZORRO_NUM_AUTO
)paren
multiline_comment|/* copy the contents of each structure into our boot info and&n;&t;&t;   count this device */
id|memcpy
c_func
(paren
op_amp
id|bi.autocon
(braket
id|bi.num_autocon
op_increment
)braket
comma
id|cdp
comma
r_sizeof
(paren
r_struct
id|ConfigDev
)paren
)paren
suffix:semicolon
r_else
id|Printf
c_func
(paren
l_string|&quot;Warning: too many AutoConfig devices. Ignoring device at &quot;
l_string|&quot;0x%08lx&bslash;n&quot;
comma
id|cdp-&gt;cd_BoardAddr
)paren
suffix:semicolon
id|do_fast
op_assign
id|bi.num_memory
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|do_chip
op_assign
id|bi.chip_size
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* find out the memory in the system */
r_for
c_loop
(paren
id|mnp
op_assign
(paren
r_struct
id|MemHeader
op_star
)paren
id|SysBase-&gt;MemList.lh_Head
suffix:semicolon
id|mnp-&gt;mh_Node.ln_Succ
suffix:semicolon
id|mnp
op_assign
(paren
r_struct
id|MemHeader
op_star
)paren
id|mnp-&gt;mh_Node.ln_Succ
)paren
(brace
r_struct
id|MemHeader
id|mh
suffix:semicolon
multiline_comment|/* copy the information */
id|mh
op_assign
op_star
id|mnp
suffix:semicolon
multiline_comment|/* skip virtual memory */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mh.mh_Attributes
op_amp
id|MEMF_PUBLIC
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* if we suspect that Kickstart is shadowed in an A3000,&n;&t;   modify the entry to show 512K more at the top of RAM&n;&t;   Check first for a MapROMmed A3640 board: overwriting the&n;&t;   Kickstart image causes an infinite lock-up on reboot! */
r_if
c_cond
(paren
(paren
id|mh.mh_Upper
op_eq
(paren
r_void
op_star
)paren
l_int|0x07f80000
)paren
op_logical_and
(paren
id|model_mask
op_amp
(paren
id|CLASS_A3000
op_or
id|CLASS_A4000
)paren
)paren
)paren
r_if
c_cond
(paren
(paren
id|bi.cputype
op_amp
id|CPU_68040
)paren
op_logical_and
id|Supervisor
c_func
(paren
id|maprommed
)paren
)paren
id|Puts
c_func
(paren
l_string|&quot;A3640 MapROM detected.&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|model_mask
op_amp
id|CLASS_A3000
)paren
(brace
id|mh.mh_Upper
op_assign
(paren
r_void
op_star
)paren
l_int|0x08000000
suffix:semicolon
id|Puts
c_func
(paren
l_string|&quot;A3000 shadowed Kickstart detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* if we suspect that Kickstart is zkicked,&n;&t;   modify the entry to show 512K more at the botton of RAM */
r_if
c_cond
(paren
(paren
id|mh.mh_Lower
op_eq
(paren
r_void
op_star
)paren
l_int|0x00280020
)paren
op_logical_and
(paren
id|model_mask
op_amp
id|CLASS_ZKICK
)paren
)paren
(brace
id|mh.mh_Lower
op_assign
(paren
r_void
op_star
)paren
l_int|0x00200000
suffix:semicolon
id|Puts
c_func
(paren
l_string|&quot;ZKick detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* mask the memory limit values */
id|mh.mh_Upper
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
id|u_long
)paren
id|mh.mh_Upper
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
id|mh.mh_Lower
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
id|u_long
)paren
id|mh.mh_Lower
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
multiline_comment|/* if fast memory */
r_if
c_cond
(paren
id|do_fast
op_logical_and
id|mh.mh_Attributes
op_amp
id|MEMF_FAST
)paren
(brace
multiline_comment|/* set the size value to the size of this block and mask off to a&n;&t;       256K increment */
id|u_long
id|size
op_assign
(paren
(paren
id|u_long
)paren
id|mh.mh_Upper
op_minus
(paren
id|u_long
)paren
id|mh.mh_Lower
)paren
op_amp
l_int|0xfffc0000
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
r_if
c_cond
(paren
id|bi.num_memory
OL
id|NUM_MEMINFO
)paren
(brace
multiline_comment|/* record the start and size */
id|bi.memory
(braket
id|bi.num_memory
)braket
dot
id|addr
op_assign
(paren
id|u_long
)paren
id|mh.mh_Lower
suffix:semicolon
id|bi.memory
(braket
id|bi.num_memory
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
multiline_comment|/* count this block */
id|bi.num_memory
op_increment
suffix:semicolon
)brace
r_else
id|Printf
c_func
(paren
l_string|&quot;Warning: too many memory blocks. Ignoring block &quot;
l_string|&quot;of %ldK at 0x%08x&bslash;n&quot;
comma
id|size
op_rshift
l_int|10
comma
(paren
id|u_long
)paren
id|mh.mh_Lower
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|do_chip
op_logical_and
id|mh.mh_Attributes
op_amp
id|MEMF_CHIP
)paren
multiline_comment|/* if CHIP memory, record the size */
id|bi.chip_size
op_assign
(paren
id|u_long
)paren
id|mh.mh_Upper
suffix:semicolon
)brace
multiline_comment|/* get info from ExecBase */
r_if
c_cond
(paren
op_logical_neg
id|bi.vblank
)paren
id|bi.vblank
op_assign
id|SysBase-&gt;VBlankFrequency
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bi.psfreq
)paren
id|bi.psfreq
op_assign
id|SysBase-&gt;PowerSupplyFrequency
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bi.eclock
)paren
id|bi.eclock
op_assign
id|SysBase-&gt;ex_EClockFrequency
suffix:semicolon
multiline_comment|/* serial port */
r_if
c_cond
(paren
op_logical_neg
id|bi.serper
)paren
(brace
id|realbaud
op_assign
id|baud
ques
c_cond
id|baud
suffix:colon
id|DEFAULT_BAUD
suffix:semicolon
id|bi.serper
op_assign
(paren
l_int|5
op_star
id|bi.eclock
op_plus
id|realbaud
op_div
l_int|2
)paren
op_div
id|realbaud
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* display Amiga model */
r_if
c_cond
(paren
id|bi.model
op_ge
id|first_amiga_model
op_logical_and
id|bi.model
op_le
id|last_amiga_model
)paren
id|Printf
c_func
(paren
l_string|&quot;%s &quot;
comma
id|amiga_models
(braket
id|bi.model
op_minus
id|first_amiga_model
)braket
)paren
suffix:semicolon
r_else
id|Puts
c_func
(paren
l_string|&quot;Amiga &quot;
)paren
suffix:semicolon
multiline_comment|/* display the CPU type */
id|Puts
c_func
(paren
l_string|&quot;CPU: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bi.cputype
)paren
(brace
r_case
id|CPU_68020
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;68020 (Do you have an MMU?)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_68030
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;68030&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_68040
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;68040&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_68060
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;68060&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;Insufficient for Linux.  Aborting...&bslash;n&quot;
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;SysBase-&gt;AttnFlags = 0x%08lx&bslash;n&quot;
comma
id|SysBase-&gt;AttnFlags
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bi.fputype
)paren
(brace
r_case
id|FPU_68881
suffix:colon
id|Puts
c_func
(paren
l_string|&quot; with 68881 FPU&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FPU_68882
suffix:colon
id|Puts
c_func
(paren
l_string|&quot; with 68882 FPU&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FPU_68040
suffix:colon
r_case
id|FPU_68060
suffix:colon
id|Puts
c_func
(paren
l_string|&quot; with internal FPU&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|Puts
c_func
(paren
l_string|&quot; without FPU&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* display the chipset */
r_switch
c_cond
(paren
id|bi.chipset
)paren
(brace
r_case
id|CS_STONEAGE
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;, old or unknown chipset&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_OCS
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;, OCS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_ECS
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;, ECS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_AGA
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;, AGA chipset&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|Puts
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* display the command line */
id|Printf
c_func
(paren
l_string|&quot;Command line is &squot;%s&squot;&bslash;n&quot;
comma
id|bi.command_line
)paren
suffix:semicolon
multiline_comment|/* display the clock statistics */
id|Printf
c_func
(paren
l_string|&quot;Vertical Blank Frequency: %ldHz&bslash;n&quot;
comma
id|bi.vblank
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;Power Supply Frequency: %ldHz&bslash;n&quot;
comma
id|bi.psfreq
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;EClock Frequency: %ldHz&bslash;n&bslash;n&quot;
comma
id|bi.eclock
)paren
suffix:semicolon
multiline_comment|/* display autoconfig devices */
r_if
c_cond
(paren
id|bi.num_autocon
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Found %ld AutoConfig Device%s&bslash;n&quot;
comma
id|bi.num_autocon
comma
id|bi.num_autocon
OG
l_int|1
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_autocon
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Device %ld: addr = 0x%08lx&quot;
comma
id|i
comma
(paren
id|u_long
)paren
id|bi.autocon
(braket
id|i
)braket
dot
id|cd_BoardAddr
)paren
suffix:semicolon
id|boardresetfuncs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|reset_boards
)paren
(brace
id|manuf
op_assign
id|bi.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Manufacturer
suffix:semicolon
id|prod
op_assign
id|bi.autocon
(braket
id|i
)braket
dot
id|cd_Rom.er_Product
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NUM_BOARDRESET
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
(paren
id|manuf
op_eq
id|boardresetdb
(braket
id|j
)braket
dot
id|manuf
)paren
op_logical_and
(paren
id|prod
op_eq
id|boardresetdb
(braket
id|j
)braket
dot
id|prod
)paren
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot; [%s - will be reset at kernel boot time]&quot;
comma
id|boardresetdb
(braket
id|j
)braket
dot
id|name
)paren
suffix:semicolon
id|boardresetfuncs
(braket
id|i
)braket
op_assign
id|boardresetdb
(braket
id|j
)braket
dot
id|reset
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|PutChar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
r_else
id|Puts
c_func
(paren
l_string|&quot;No AutoConfig Devices Found&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* display memory */
r_if
c_cond
(paren
id|bi.num_memory
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;&bslash;nFound %ld Block%sof Memory&bslash;n&quot;
comma
id|bi.num_memory
comma
id|bi.num_memory
OG
l_int|1
ques
c_cond
l_string|&quot;s &quot;
suffix:colon
l_string|&quot; &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_memory
suffix:semicolon
id|i
op_increment
)paren
id|Printf
c_func
(paren
l_string|&quot;Block %ld: 0x%08lx to 0x%08lx (%ldK)&bslash;n&quot;
comma
id|i
comma
id|bi.memory
(braket
id|i
)braket
dot
id|addr
comma
id|bi.memory
(braket
id|i
)braket
dot
id|addr
op_plus
id|bi.memory
(braket
id|i
)braket
dot
id|size
comma
id|bi.memory
(braket
id|i
)braket
dot
id|size
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
r_else
(brace
id|Puts
c_func
(paren
l_string|&quot;No memory found?!  Aborting...&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* display chip memory size */
id|Printf
c_func
(paren
l_string|&quot;%ldK of CHIP memory&bslash;n&quot;
comma
id|bi.chip_size
op_rshift
l_int|10
)paren
suffix:semicolon
id|start_mem
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|addr
suffix:semicolon
id|mem_size
op_assign
id|bi.memory
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
multiline_comment|/* tell us where the kernel will go */
id|Printf
c_func
(paren
l_string|&quot;&bslash;nThe kernel will be located at 0x%08lx&bslash;n&quot;
comma
id|start_mem
)paren
suffix:semicolon
multiline_comment|/* verify that there is enough Chip RAM */
r_if
c_cond
(paren
id|bi.chip_size
OL
l_int|512
op_star
l_int|1024
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Not enough Chip RAM in this system.  Aborting...&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* verify that there is enough Fast RAM */
r_for
c_loop
(paren
id|fast_total
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_memory
suffix:semicolon
id|i
op_increment
)paren
id|fast_total
op_add_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|fast_total
OL
l_int|2
op_star
l_int|1024
op_star
l_int|1024
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Not enough Fast RAM in this system.  Aborting...&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* support for ramdisk */
r_if
c_cond
(paren
id|ramdiskname
)paren
(brace
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_assign
id|FileSize
c_func
(paren
id|ramdiskname
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Unable to find size of ramdisk file `%s&squot;&bslash;n&quot;
comma
id|ramdiskname
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* record ramdisk size */
id|bi.ramdisk.size
op_assign
id|size
suffix:semicolon
)brace
r_else
id|bi.ramdisk.size
op_assign
l_int|0
suffix:semicolon
id|rd_size
op_assign
id|bi.ramdisk.size
suffix:semicolon
id|bi.ramdisk.addr
op_assign
(paren
id|u_long
)paren
id|start_mem
op_plus
id|mem_size
op_minus
id|rd_size
suffix:semicolon
multiline_comment|/* create the bootinfo structure */
r_if
c_cond
(paren
op_logical_neg
id|create_bootinfo
c_func
(paren
)paren
)paren
r_goto
id|Fail
suffix:semicolon
multiline_comment|/* open kernel executable and read exec header */
r_if
c_cond
(paren
(paren
id|kfd
op_assign
id|Open
c_func
(paren
id|kernelname
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Unable to open kernel file `%s&squot;&bslash;n&quot;
comma
id|kernelname
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|KRead
c_func
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
op_amp
id|kexec
comma
r_sizeof
(paren
id|kexec
)paren
)paren
op_ne
r_sizeof
(paren
id|kexec
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Unable to read exec header from kernel file&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
macro_line|#ifdef ZKERNEL
r_if
c_cond
(paren
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|kexec
)paren
(braket
l_int|0
)braket
op_eq
l_int|037
op_logical_and
(paren
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|kexec
)paren
(braket
l_int|1
)braket
op_eq
l_int|0213
op_logical_or
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|kexec
)paren
(braket
l_int|1
)braket
op_eq
l_int|0236
)paren
)paren
(brace
multiline_comment|/* That&squot;s a compressed kernel */
id|Puts
c_func
(paren
l_string|&quot;Kernel is compressed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|load_zkernel
c_func
(paren
id|kfd
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Decompression error -- aborting&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
(brace
r_case
id|ZMAGIC
suffix:colon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;&bslash;nLoading a.out (ZMAGIC) Linux/m68k kernel...&bslash;n&quot;
)paren
suffix:semicolon
id|text_offset
op_assign
id|N_TXTOFF
c_func
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QMAGIC
suffix:colon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;&bslash;nLoading a.out (QMAGIC) Linux/m68k kernel...&bslash;n&quot;
)paren
suffix:semicolon
id|text_offset
op_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
multiline_comment|/* the text size includes the exec header; remove this */
id|kexec.a_text
op_sub_assign
r_sizeof
(paren
id|kexec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Try to parse it as an ELF header */
id|KSeek
c_func
(paren
id|kfd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|KRead
c_func
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
op_amp
id|kexec_elf
comma
r_sizeof
(paren
id|kexec_elf
)paren
)paren
op_eq
r_sizeof
(paren
id|kexec_elf
)paren
)paren
op_logical_and
(paren
id|memcmp
c_func
(paren
op_amp
id|kexec_elf.e_ident
(braket
id|EI_MAG0
)braket
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|elf_kernel
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;&bslash;nLoading ELF Linux/m68k kernel...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* A few plausibility checks */
r_if
c_cond
(paren
(paren
id|kexec_elf.e_type
op_ne
id|ET_EXEC
)paren
op_logical_or
(paren
id|kexec_elf.e_machine
op_ne
id|EM_68K
)paren
op_logical_or
(paren
id|kexec_elf.e_version
op_ne
id|EV_CURRENT
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Invalid ELF header contents in kernel&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* Load the program headers */
r_if
c_cond
(paren
op_logical_neg
(paren
id|kernel_phdrs
op_assign
(paren
id|Elf32_Phdr
op_star
)paren
id|AllocMem
c_func
(paren
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
id|Elf32_Phdr
)paren
comma
id|MEMF_FAST
op_or
id|MEMF_PUBLIC
op_or
id|MEMF_CLEAR
)paren
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Unable to allocate memory for program headers&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
id|KSeek
c_func
(paren
id|kfd
comma
id|kexec_elf.e_phoff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|KRead
c_func
(paren
id|kfd
comma
(paren
r_void
op_star
)paren
id|kernel_phdrs
comma
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
op_star
id|kernel_phdrs
)paren
)paren
op_ne
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
op_star
id|kernel_phdrs
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Unable to read program headers from kernel file&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|Printf
c_func
(paren
l_string|&quot;Wrong magic number 0x%08lx in kernel header&bslash;n&quot;
comma
id|N_MAGIC
c_func
(paren
id|kexec
)paren
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* Load the kernel at one page after start of mem */
id|start_mem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|mem_size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Align bss size to multiple of four */
r_if
c_cond
(paren
op_logical_neg
id|elf_kernel
)paren
id|kexec.a_bss
op_assign
(paren
id|kexec.a_bss
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* calculate the total required amount of memory */
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
id|u_long
id|min_addr
op_assign
l_int|0xffffffff
comma
id|max_addr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|min_addr
OG
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
)paren
id|min_addr
op_assign
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|max_addr
OL
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
)paren
id|max_addr
op_assign
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
suffix:semicolon
)brace
multiline_comment|/* This is needed for newer linkers that include the header in&n;&t;   the first segment.  */
r_if
c_cond
(paren
id|min_addr
op_eq
l_int|0
)paren
(brace
id|min_addr
op_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_offset
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_filesz
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|kernel_phdrs
(braket
l_int|0
)braket
dot
id|p_memsz
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|kernel_size
op_assign
id|max_addr
op_minus
id|min_addr
suffix:semicolon
)brace
r_else
id|kernel_size
op_assign
id|kexec.a_text
op_plus
id|kexec.a_data
op_plus
id|kexec.a_bss
suffix:semicolon
id|memreq
op_assign
id|kernel_size
op_plus
id|bi_size
op_plus
id|rd_size
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_if
c_cond
(paren
r_sizeof
(paren
id|compat_bootinfo
)paren
OG
id|bi_size
)paren
id|memreq
op_assign
id|kernel_size
op_plus
r_sizeof
(paren
id|compat_bootinfo
)paren
op_plus
id|rd_size
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
r_if
c_cond
(paren
op_logical_neg
(paren
id|memptr
op_assign
(paren
r_char
op_star
)paren
id|AllocMem
c_func
(paren
id|memreq
comma
id|MEMF_FAST
op_or
id|MEMF_PUBLIC
op_or
id|MEMF_CLEAR
)paren
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Unable to allocate memory&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* read the text and data segments from the kernel image */
r_if
c_cond
(paren
id|elf_kernel
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|KSeek
c_func
(paren
id|kfd
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_offset
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Failed to seek to segment %ld&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|KRead
c_func
(paren
id|kfd
comma
id|memptr
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_minus
id|PAGE_SIZE
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_filesz
)paren
op_ne
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_filesz
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Failed to read segment %ld&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|KSeek
c_func
(paren
id|kfd
comma
id|text_offset
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Failed to seek to text&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|KRead
c_func
(paren
id|kfd
comma
id|memptr
comma
id|kexec.a_text
)paren
op_ne
id|kexec.a_text
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Failed to read text&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* data follows immediately after text */
r_if
c_cond
(paren
id|KRead
c_func
(paren
id|kfd
comma
id|memptr
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
op_ne
id|kexec.a_data
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Failed to read data&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
)brace
id|KClose
c_func
(paren
id|kfd
)paren
suffix:semicolon
id|kfd
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Check kernel&squot;s bootinfo version */
r_switch
c_cond
(paren
id|check_bootinfo_version
c_func
(paren
id|memptr
)paren
)paren
(brace
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|AMIGA_BOOTI_VERSION
)paren
suffix:colon
id|bi_ptr
op_assign
op_amp
id|bi_union.record
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|COMPAT_AMIGA_BOOTI_VERSION
)paren
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|create_compat_bootinfo
c_func
(paren
)paren
)paren
r_goto
id|Fail
suffix:semicolon
id|bi_ptr
op_assign
op_amp
id|compat_bootinfo
suffix:semicolon
id|bi_size
op_assign
r_sizeof
(paren
id|compat_bootinfo
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
r_default
suffix:colon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* copy the bootinfo to the end of the kernel image */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
comma
id|bi_ptr
comma
id|bi_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ramdiskname
)paren
(brace
r_if
c_cond
(paren
(paren
id|rfd
op_assign
id|Open
c_func
(paren
id|ramdiskname
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Unable to open ramdisk file `%s&squot;&bslash;n&quot;
comma
id|ramdiskname
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Read
c_func
(paren
id|rfd
comma
id|memptr
op_plus
id|kernel_size
op_plus
id|bi_size
comma
id|rd_size
)paren
op_ne
id|rd_size
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Failed to read ramdisk file&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
id|Close
c_func
(paren
id|rfd
)paren
suffix:semicolon
id|rfd
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* allocate temporary chip ram stack */
r_if
c_cond
(paren
op_logical_neg
(paren
id|stack
op_assign
(paren
id|u_long
op_star
)paren
id|AllocMem
c_func
(paren
id|TEMP_STACKSIZE
comma
id|MEMF_CHIP
op_or
id|MEMF_CLEAR
)paren
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Unable to allocate memory for stack&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* allocate chip ram for copy of startup code */
id|startcodesize
op_assign
op_amp
id|copyallend
op_minus
op_amp
id|copyall
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|startfunc
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
)paren
)paren
id|AllocMem
c_func
(paren
id|startcodesize
comma
id|MEMF_CHIP
op_or
id|MEMF_CLEAR
)paren
)paren
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Unable to allocate memory for startcode&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Fail
suffix:semicolon
)brace
multiline_comment|/* copy startup code to CHIP RAM */
id|memcpy
c_func
(paren
id|startfunc
comma
op_amp
id|copyall
comma
id|startcodesize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
(brace
r_if
c_cond
(paren
id|bi.ramdisk.size
)paren
id|Printf
c_func
(paren
l_string|&quot;RAM disk at 0x%08lx, size is %ldK&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|memptr
op_plus
id|kernel_size
comma
id|bi.ramdisk.size
op_rshift
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_kernel
)paren
(brace
id|PutChar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kexec_elf.e_phnum
suffix:semicolon
id|i
op_increment
)paren
id|Printf
c_func
(paren
l_string|&quot;Kernel segment %ld at 0x%08lx, size %ld&bslash;n&quot;
comma
id|i
comma
id|start_mem
op_plus
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_vaddr
op_minus
id|PAGE_SIZE
comma
id|kernel_phdrs
(braket
id|i
)braket
dot
id|p_memsz
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;Boot info        at 0x%08lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|kernel_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printf
c_func
(paren
l_string|&quot;&bslash;nKernel text at 0x%08lx, code size 0x%08lx&bslash;n&quot;
comma
id|start_mem
comma
id|kexec.a_text
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;Kernel data at 0x%08lx, data size 0x%08lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
comma
id|kexec.a_data
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;Kernel bss  at 0x%08lx, bss  size 0x%08lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|kexec.a_text
op_plus
id|kexec.a_data
comma
id|kexec.a_bss
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;Boot info   at 0x%08lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|kernel_size
)paren
suffix:semicolon
)brace
id|Printf
c_func
(paren
l_string|&quot;&bslash;nKernel entry is 0x%08lx&bslash;n&quot;
comma
id|elf_kernel
ques
c_cond
id|kexec_elf.e_entry
suffix:colon
id|kexec.a_entry
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;ramdisk dest top is 0x%08lx&bslash;n&quot;
comma
id|start_mem
op_plus
id|mem_size
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;ramdisk lower limit is 0x%08lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;ramdisk src top is 0x%08lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
op_plus
id|rd_size
)paren
suffix:semicolon
id|Puts
c_func
(paren
l_string|&quot;&bslash;nType a key to continue the Linux/m68k boot...&quot;
)paren
suffix:semicolon
id|GetChar
c_func
(paren
)paren
suffix:semicolon
id|PutChar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* wait for things to settle down */
id|Sleep
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keep_video
)paren
multiline_comment|/* set graphics mode to a nice normal one */
id|LoadView
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|Disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reset nasty Zorro boards */
r_if
c_cond
(paren
id|reset_boards
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_autocon
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|boardresetfuncs
(braket
id|i
)braket
)paren
id|boardresetfuncs
(braket
id|i
)braket
(paren
op_amp
id|bi.autocon
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Turn off all DMA */
id|custom.dmacon
op_assign
id|DMAF_ALL
op_or
id|DMAF_MASTER
suffix:semicolon
multiline_comment|/* turn off caches */
id|CacheControl
c_func
(paren
l_int|0
comma
op_complement
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Go into supervisor state */
id|SuperState
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* turn off any mmu translation */
id|disable_mmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* execute the copy-and-go code (from CHIP RAM) */
id|start_kernel
c_func
(paren
id|startfunc
comma
(paren
r_char
op_star
)paren
id|stack
op_plus
id|TEMP_STACKSIZE
comma
id|memptr
comma
id|start_mem
comma
id|mem_size
comma
id|rd_size
comma
id|kernel_size
)paren
suffix:semicolon
multiline_comment|/* Clean up and exit in case of a failure */
id|Fail
suffix:colon
r_if
c_cond
(paren
id|kfd
op_ne
op_minus
l_int|1
)paren
id|KClose
c_func
(paren
id|kfd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rfd
op_ne
op_minus
l_int|1
)paren
id|Close
c_func
(paren
id|rfd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memptr
)paren
id|FreeMem
c_func
(paren
(paren
r_void
op_star
)paren
id|memptr
comma
id|memreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stack
)paren
id|FreeMem
c_func
(paren
(paren
r_void
op_star
)paren
id|stack
comma
id|TEMP_STACKSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kernel_phdrs
)paren
id|FreeMem
c_func
(paren
(paren
r_void
op_star
)paren
id|kernel_phdrs
comma
id|kexec_elf.e_phnum
op_star
r_sizeof
(paren
id|Elf32_Phdr
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;Determine the Chipset&n;     */
DECL|function|get_chipset
r_static
id|u_long
id|get_chipset
c_func
(paren
r_void
)paren
(brace
id|u_char
id|cs
suffix:semicolon
id|u_long
id|chipset
suffix:semicolon
r_if
c_cond
(paren
id|GfxBase-&gt;Version
op_ge
l_int|39
)paren
id|cs
op_assign
id|SetChipRev
c_func
(paren
id|SETCHIPREV_BEST
)paren
suffix:semicolon
r_else
id|cs
op_assign
id|GfxBase-&gt;ChipRevBits0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cs
op_amp
id|GFXG_AGA
)paren
op_eq
id|GFXG_AGA
)paren
id|chipset
op_assign
id|CS_AGA
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cs
op_amp
id|GFXG_ECS
)paren
op_eq
id|GFXG_ECS
)paren
id|chipset
op_assign
id|CS_ECS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|cs
op_amp
id|GFXG_OCS
)paren
op_eq
id|GFXG_OCS
)paren
id|chipset
op_assign
id|CS_OCS
suffix:semicolon
r_else
id|chipset
op_assign
id|CS_STONEAGE
suffix:semicolon
r_return
id|chipset
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;Determine the CPU Type&n;     */
DECL|function|get_processor
r_static
r_void
id|get_processor
c_func
(paren
id|u_long
op_star
id|cpu
comma
id|u_long
op_star
id|fpu
comma
id|u_long
op_star
id|mmu
)paren
(brace
op_star
id|cpu
op_assign
op_star
id|fpu
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68060
)paren
op_star
id|cpu
op_assign
id|CPU_68060
suffix:semicolon
r_else
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68040
)paren
op_star
id|cpu
op_assign
id|CPU_68040
suffix:semicolon
r_else
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68030
)paren
op_star
id|cpu
op_assign
id|CPU_68030
suffix:semicolon
r_else
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68020
)paren
op_star
id|cpu
op_assign
id|CPU_68020
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cpu
op_eq
id|CPU_68040
op_logical_or
op_star
id|cpu
op_eq
id|CPU_68060
)paren
(brace
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_FPU40
)paren
op_star
id|fpu
op_assign
op_star
id|cpu
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68882
)paren
op_star
id|fpu
op_assign
id|FPU_68882
suffix:semicolon
r_else
r_if
c_cond
(paren
id|SysBase-&gt;AttnFlags
op_amp
id|AFF_68881
)paren
op_star
id|fpu
op_assign
id|FPU_68881
suffix:semicolon
)brace
op_star
id|mmu
op_assign
op_star
id|cpu
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;Determine the Amiga Model&n;     */
DECL|function|get_model
r_static
id|u_long
id|get_model
c_func
(paren
id|u_long
id|chipset
)paren
(brace
id|u_long
id|model
op_assign
id|AMI_UNKNOWN
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;Amiga model identification:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_resource
c_func
(paren
l_string|&quot;draco.resource&quot;
)paren
)paren
id|model
op_assign
id|AMI_DRACO
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;    Chipset: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|chipset
)paren
(brace
r_case
id|CS_STONEAGE
suffix:colon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;Old or unknown&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|OCS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_OCS
suffix:colon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;OCS&bslash;n&quot;
)paren
suffix:semicolon
id|OCS
suffix:colon
r_if
c_cond
(paren
id|probe_resident
c_func
(paren
l_string|&quot;cd.device&quot;
)paren
)paren
id|model
op_assign
id|AMI_CDTV
suffix:semicolon
r_else
multiline_comment|/* let&squot;s call it an A2000 (may be A500, A1000, A2500) */
id|model
op_assign
id|AMI_2000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_ECS
suffix:colon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;ECS&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_resident
c_func
(paren
l_string|&quot;Magic 36.7&quot;
)paren
op_logical_or
id|probe_resident
c_func
(paren
l_string|&quot;kickad 36.57&quot;
)paren
op_logical_or
id|probe_resident
c_func
(paren
l_string|&quot;A3000 Bonus&quot;
)paren
op_logical_or
id|probe_resident
c_func
(paren
l_string|&quot;A3000 bonus&quot;
)paren
)paren
multiline_comment|/* let&squot;s call it an A3000 (may be A3000T) */
id|model
op_assign
id|AMI_3000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|probe_resource
c_func
(paren
l_string|&quot;card.resource&quot;
)paren
)paren
id|model
op_assign
id|AMI_600
suffix:semicolon
r_else
multiline_comment|/* let&squot;s call it an A2000 (may be A500[+], A1000, A2500) */
id|model
op_assign
id|AMI_2000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS_AGA
suffix:colon
r_if
c_cond
(paren
id|debugflag
)paren
id|Puts
c_func
(paren
l_string|&quot;AGA&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_resident
c_func
(paren
l_string|&quot;A1000 Bonus&quot;
)paren
op_logical_or
id|probe_resident
c_func
(paren
l_string|&quot;A4000 bonus&quot;
)paren
)paren
id|model
op_assign
id|probe_resident
c_func
(paren
l_string|&quot;NCR scsi.device&quot;
)paren
ques
c_cond
id|AMI_4000T
suffix:colon
id|AMI_4000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|probe_resource
c_func
(paren
l_string|&quot;card.resource&quot;
)paren
)paren
id|model
op_assign
id|AMI_1200
suffix:semicolon
r_else
r_if
c_cond
(paren
id|probe_resident
c_func
(paren
l_string|&quot;cd.device&quot;
)paren
)paren
id|model
op_assign
id|AMI_CD32
suffix:semicolon
r_else
id|model
op_assign
id|AMI_3000PLUS
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|debugflag
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;&bslash;nType a key to continue...&quot;
)paren
suffix:semicolon
id|GetChar
c_func
(paren
)paren
suffix:semicolon
id|Puts
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|model
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;Probe for a Resident Modules&n;     */
DECL|function|probe_resident
r_static
r_int
id|probe_resident
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_const
r_struct
id|Resident
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
id|Printf
c_func
(paren
l_string|&quot;    Module `%s&squot;: &quot;
comma
id|name
)paren
suffix:semicolon
id|res
op_assign
id|FindResident
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
r_if
c_cond
(paren
id|res
)paren
id|Printf
c_func
(paren
l_string|&quot;0x%08lx&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_else
id|Puts
c_func
(paren
l_string|&quot;not present&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|res
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;Probe for an available Resource&n;     */
DECL|function|probe_resource
r_static
r_int
id|probe_resource
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_const
r_void
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
id|Printf
c_func
(paren
l_string|&quot;    Resource `%s&squot;: &quot;
comma
id|name
)paren
suffix:semicolon
id|res
op_assign
id|OpenResource
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debugflag
)paren
r_if
c_cond
(paren
id|res
)paren
id|Printf
c_func
(paren
l_string|&quot;0x%08lx&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_else
id|Puts
c_func
(paren
l_string|&quot;not present&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|res
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Create the Bootinfo structure&n;     */
DECL|function|create_bootinfo
r_static
r_int
id|create_bootinfo
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bi_record
op_star
id|record
suffix:semicolon
multiline_comment|/* Initialization */
id|bi_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Generic tags */
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_MACHTYPE
comma
r_sizeof
(paren
id|bi.machtype
)paren
comma
op_amp
id|bi.machtype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_CPUTYPE
comma
r_sizeof
(paren
id|bi.cputype
)paren
comma
op_amp
id|bi.cputype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_FPUTYPE
comma
r_sizeof
(paren
id|bi.fputype
)paren
comma
op_amp
id|bi.fputype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_MMUTYPE
comma
r_sizeof
(paren
id|bi.mmutype
)paren
comma
op_amp
id|bi.mmutype
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_memory
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_MEMCHUNK
comma
r_sizeof
(paren
id|bi.memory
(braket
id|i
)braket
)paren
comma
op_amp
id|bi.memory
(braket
id|i
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bi.ramdisk.size
)paren
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_RAMDISK
comma
r_sizeof
(paren
id|bi.ramdisk
)paren
comma
op_amp
id|bi.ramdisk
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_string
c_func
(paren
id|BI_COMMAND_LINE
comma
id|bi.command_line
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Amiga tags */
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_MODEL
comma
r_sizeof
(paren
id|bi.model
)paren
comma
op_amp
id|bi.model
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bi.num_autocon
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_AUTOCON
comma
r_sizeof
(paren
id|bi.autocon
(braket
id|i
)braket
)paren
comma
op_amp
id|bi.autocon
(braket
id|i
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_CHIP_SIZE
comma
r_sizeof
(paren
id|bi.chip_size
)paren
comma
op_amp
id|bi.chip_size
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_VBLANK
comma
r_sizeof
(paren
id|bi.vblank
)paren
comma
op_amp
id|bi.vblank
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_PSFREQ
comma
r_sizeof
(paren
id|bi.psfreq
)paren
comma
op_amp
id|bi.psfreq
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_ECLOCK
comma
r_sizeof
(paren
id|bi.eclock
)paren
comma
op_amp
id|bi.eclock
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_CHIPSET
comma
r_sizeof
(paren
id|bi.chipset
)paren
comma
op_amp
id|bi.chipset
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_bi_record
c_func
(paren
id|BI_AMIGA_SERPER
comma
r_sizeof
(paren
id|bi.serper
)paren
comma
op_amp
id|bi.serper
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Trailer */
id|record
op_assign
(paren
r_struct
id|bi_record
op_star
)paren
(paren
(paren
id|u_long
)paren
op_amp
id|bi_union.record
op_plus
id|bi_size
)paren
suffix:semicolon
id|record-&gt;tag
op_assign
id|BI_LAST
suffix:semicolon
id|bi_size
op_add_assign
r_sizeof
(paren
id|bi_union.record.tag
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Add a Record to the Bootinfo Structure&n;     */
DECL|function|add_bi_record
r_static
r_int
id|add_bi_record
c_func
(paren
id|u_short
id|tag
comma
id|u_short
id|size
comma
r_const
r_void
op_star
id|data
)paren
(brace
r_struct
id|bi_record
op_star
id|record
suffix:semicolon
id|u_int
id|size2
suffix:semicolon
id|size2
op_assign
(paren
r_sizeof
(paren
r_struct
id|bi_record
)paren
op_plus
id|size
op_plus
l_int|3
)paren
op_amp
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|bi_size
op_plus
id|size2
op_plus
r_sizeof
(paren
id|bi_union.record.tag
)paren
OG
id|MAX_BI_SIZE
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Can&squot;t add bootinfo record. Ask a wizard to enlarge me.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|record
op_assign
(paren
r_struct
id|bi_record
op_star
)paren
(paren
(paren
id|u_long
)paren
op_amp
id|bi_union.record
op_plus
id|bi_size
)paren
suffix:semicolon
id|record-&gt;tag
op_assign
id|tag
suffix:semicolon
id|record-&gt;size
op_assign
id|size2
suffix:semicolon
id|memcpy
c_func
(paren
id|record-&gt;data
comma
id|data
comma
id|size
)paren
suffix:semicolon
id|bi_size
op_add_assign
id|size2
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Add a String Record to the Bootinfo Structure&n;     */
DECL|function|add_bi_string
r_static
r_int
id|add_bi_string
c_func
(paren
id|u_short
id|tag
comma
r_const
id|u_char
op_star
id|s
)paren
(brace
r_return
id|add_bi_record
c_func
(paren
id|tag
comma
id|strlen
c_func
(paren
id|s
)paren
op_plus
l_int|1
comma
(paren
r_void
op_star
)paren
id|s
)paren
suffix:semicolon
)brace
macro_line|#ifdef BOOTINFO_COMPAT_1_0
multiline_comment|/*&n;     *  Create the Bootinfo structure for backwards compatibility mode&n;     */
DECL|function|create_compat_bootinfo
r_static
r_int
id|create_compat_bootinfo
c_func
(paren
r_void
)paren
(brace
id|u_int
id|i
suffix:semicolon
id|compat_bootinfo.machtype
op_assign
id|bi.machtype
suffix:semicolon
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68020
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68020
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68030
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68030
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68040
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68040
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.cputype
op_amp
id|CPU_68060
)paren
id|compat_bootinfo.cputype
op_assign
id|COMPAT_CPU_68060
suffix:semicolon
r_else
(brace
id|Printf
c_func
(paren
l_string|&quot;CPU type 0x%08lx not supported by kernel&bslash;n&quot;
comma
id|bi.cputype
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68881
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68881
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68882
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68882
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68040
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68040
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bi.fputype
op_amp
id|FPU_68060
)paren
id|compat_bootinfo.cputype
op_or_assign
id|COMPAT_FPU_68060
suffix:semicolon
r_else
(brace
id|Printf
c_func
(paren
l_string|&quot;FPU type 0x%08lx not supported by kernel&bslash;n&quot;
comma
id|bi.fputype
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|compat_bootinfo.num_memory
op_assign
id|bi.num_memory
suffix:semicolon
r_if
c_cond
(paren
id|compat_bootinfo.num_memory
OG
id|COMPAT_NUM_MEMINFO
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Warning: using only %ld blocks of memory&bslash;n&quot;
comma
id|COMPAT_NUM_MEMINFO
)paren
suffix:semicolon
id|compat_bootinfo.num_memory
op_assign
id|COMPAT_NUM_MEMINFO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|compat_bootinfo.num_memory
suffix:semicolon
id|i
op_increment
)paren
(brace
id|compat_bootinfo.memory
(braket
id|i
)braket
dot
id|addr
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|compat_bootinfo.memory
(braket
id|i
)braket
dot
id|size
op_assign
id|bi.memory
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bi.ramdisk.size
)paren
(brace
id|compat_bootinfo.ramdisk_size
op_assign
(paren
id|bi.ramdisk.size
op_plus
l_int|1023
)paren
op_div
l_int|1024
suffix:semicolon
id|compat_bootinfo.ramdisk_addr
op_assign
id|bi.ramdisk.addr
suffix:semicolon
)brace
r_else
(brace
id|compat_bootinfo.ramdisk_size
op_assign
l_int|0
suffix:semicolon
id|compat_bootinfo.ramdisk_addr
op_assign
l_int|0
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|compat_bootinfo.command_line
comma
id|bi.command_line
comma
id|COMPAT_CL_SIZE
)paren
suffix:semicolon
id|compat_bootinfo.command_line
(braket
id|COMPAT_CL_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|compat_bootinfo.bi_amiga.model
op_assign
id|bi.model
suffix:semicolon
id|compat_bootinfo.bi_amiga.num_autocon
op_assign
id|bi.num_autocon
suffix:semicolon
r_if
c_cond
(paren
id|compat_bootinfo.bi_amiga.num_autocon
OG
id|COMPAT_NUM_AUTO
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;Warning: using only %ld AutoConfig devices&bslash;n&quot;
comma
id|COMPAT_NUM_AUTO
)paren
suffix:semicolon
id|compat_bootinfo.bi_amiga.num_autocon
op_assign
id|COMPAT_NUM_AUTO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|compat_bootinfo.bi_amiga.num_autocon
suffix:semicolon
id|i
op_increment
)paren
id|compat_bootinfo.bi_amiga.autocon
(braket
id|i
)braket
op_assign
id|bi.autocon
(braket
id|i
)braket
suffix:semicolon
id|compat_bootinfo.bi_amiga.chip_size
op_assign
id|bi.chip_size
suffix:semicolon
id|compat_bootinfo.bi_amiga.vblank
op_assign
id|bi.vblank
suffix:semicolon
id|compat_bootinfo.bi_amiga.psfreq
op_assign
id|bi.psfreq
suffix:semicolon
id|compat_bootinfo.bi_amiga.eclock
op_assign
id|bi.eclock
suffix:semicolon
id|compat_bootinfo.bi_amiga.chipset
op_assign
id|bi.chipset
suffix:semicolon
id|compat_bootinfo.bi_amiga.hw_present
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
multiline_comment|/*&n;     *  Compare the Bootstrap and Kernel Versions&n;     */
DECL|function|check_bootinfo_version
r_static
r_int
id|check_bootinfo_version
c_func
(paren
r_const
r_char
op_star
id|memptr
)paren
(brace
r_const
r_struct
id|bootversion
op_star
id|bv
op_assign
(paren
r_struct
id|bootversion
op_star
)paren
id|memptr
suffix:semicolon
r_int
r_int
id|version
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|kernel_major
comma
id|kernel_minor
comma
id|boots_major
comma
id|boots_minor
suffix:semicolon
r_if
c_cond
(paren
id|bv-&gt;magic
op_eq
id|BOOTINFOV_MAGIC
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|bv-&gt;machversions
(braket
id|i
)braket
dot
id|machtype
op_ne
l_int|0
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|bv-&gt;machversions
(braket
id|i
)braket
dot
id|machtype
op_eq
id|MACH_AMIGA
)paren
(brace
id|version
op_assign
id|bv-&gt;machversions
(braket
id|i
)braket
dot
id|version
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|version
)paren
id|Puts
c_func
(paren
l_string|&quot;Kernel has no bootinfo version info, assuming 0.0&bslash;n&quot;
)paren
suffix:semicolon
id|kernel_major
op_assign
id|BI_VERSION_MAJOR
c_func
(paren
id|version
)paren
suffix:semicolon
id|kernel_minor
op_assign
id|BI_VERSION_MINOR
c_func
(paren
id|version
)paren
suffix:semicolon
id|boots_major
op_assign
id|BI_VERSION_MAJOR
c_func
(paren
id|AMIGA_BOOTI_VERSION
)paren
suffix:semicolon
id|boots_minor
op_assign
id|BI_VERSION_MINOR
c_func
(paren
id|AMIGA_BOOTI_VERSION
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;Bootstrap&squot;s bootinfo version: %ld.%ld&bslash;n&quot;
comma
id|boots_major
comma
id|boots_minor
)paren
suffix:semicolon
id|Printf
c_func
(paren
l_string|&quot;Kernel&squot;s bootinfo version   : %ld.%ld&bslash;n&quot;
comma
id|kernel_major
comma
id|kernel_minor
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|kernel_major
)paren
(brace
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|AMIGA_BOOTI_VERSION
)paren
suffix:colon
r_if
c_cond
(paren
id|kernel_minor
OG
id|boots_minor
)paren
(brace
id|Puts
c_func
(paren
l_string|&quot;Warning: Bootinfo version of bootstrap and kernel &quot;
l_string|&quot;differ!&bslash;n&quot;
)paren
suffix:semicolon
id|Puts
c_func
(paren
l_string|&quot;         Certain features may not work.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#ifdef BOOTINFO_COMPAT_1_0
r_case
id|BI_VERSION_MAJOR
c_func
(paren
id|COMPAT_AMIGA_BOOTI_VERSION
)paren
suffix:colon
id|Puts
c_func
(paren
l_string|&quot;(using backwards compatibility mode)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* BOOTINFO_COMPAT_1_0 */
r_default
suffix:colon
id|Printf
c_func
(paren
l_string|&quot;&bslash;nThis bootstrap is too %s for this kernel!&bslash;n&quot;
comma
id|boots_major
OL
id|kernel_major
ques
c_cond
l_string|&quot;old&quot;
suffix:colon
l_string|&quot;new&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|kernel_major
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;Call the copy-and-go-code&n;     */
DECL|function|start_kernel
r_static
r_void
id|start_kernel
c_func
(paren
r_void
(paren
op_star
id|startfunc
)paren
(paren
)paren
comma
r_char
op_star
id|stackp
comma
r_char
op_star
id|memptr
comma
id|u_long
id|start_mem
comma
id|u_long
id|mem_size
comma
id|u_long
id|rd_size
comma
id|u_long
id|kernel_size
)paren
(brace
r_register
r_void
(paren
op_star
id|a0
)paren
(paren
)paren
id|__asm
c_func
(paren
l_string|&quot;a0&quot;
)paren
op_assign
id|startfunc
suffix:semicolon
r_register
r_char
op_star
id|a2
id|__asm
c_func
(paren
l_string|&quot;a2&quot;
)paren
op_assign
id|stackp
suffix:semicolon
r_register
r_char
op_star
id|a3
id|__asm
c_func
(paren
l_string|&quot;a3&quot;
)paren
op_assign
id|memptr
suffix:semicolon
r_register
id|u_long
id|a4
id|__asm
c_func
(paren
l_string|&quot;a4&quot;
)paren
op_assign
id|start_mem
suffix:semicolon
r_register
id|u_long
id|d0
id|__asm
c_func
(paren
l_string|&quot;d0&quot;
)paren
op_assign
id|mem_size
suffix:semicolon
r_register
id|u_long
id|d1
id|__asm
c_func
(paren
l_string|&quot;d1&quot;
)paren
op_assign
id|rd_size
suffix:semicolon
r_register
id|u_long
id|d2
id|__asm
c_func
(paren
l_string|&quot;d2&quot;
)paren
op_assign
id|kernel_size
suffix:semicolon
r_register
id|u_long
id|d3
id|__asm
c_func
(paren
l_string|&quot;d3&quot;
)paren
op_assign
id|bi_size
suffix:semicolon
id|__asm
id|__volatile
(paren
l_string|&quot;movel a2,sp;&quot;
l_string|&quot;jmp a0@&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|a0
)paren
comma
l_string|&quot;r&quot;
(paren
id|a2
)paren
comma
l_string|&quot;r&quot;
(paren
id|a3
)paren
comma
l_string|&quot;r&quot;
(paren
id|a4
)paren
comma
l_string|&quot;r&quot;
(paren
id|d0
)paren
comma
l_string|&quot;r&quot;
(paren
id|d1
)paren
comma
l_string|&quot;r&quot;
(paren
id|d2
)paren
comma
l_string|&quot;r&quot;
(paren
id|d3
)paren
multiline_comment|/* no return */
)paren
suffix:semicolon
multiline_comment|/* fake a noreturn */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;This assembler code is copied to chip ram, and then executed.&n;     *&t;It copies the kernel to it&squot;s final resting place.&n;     *&n;     *&t;It is called with:&n;     *&n;     *&t;    a3 = memptr&n;     *&t;    a4 = start_mem&n;     *&t;    d0 = mem_size&n;     *&t;    d1 = rd_size&n;     *&t;    d2 = kernel_size&n;     *&t;    d3 = bi_size&n;     */
id|asm
c_func
(paren
l_string|&quot;.text&bslash;n&quot;
id|ALIGN_STR
l_string|&quot;&bslash;n&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|copyall
)paren
"&quot;"
suffix:colon
op_or
multiline_comment|/* copy kernel text and data */
id|movel
id|a3
comma
id|a0
op_or
id|src
op_assign
(paren
id|u_long
op_star
)paren
id|memptr
suffix:semicolon
id|movel
id|a0
comma
id|a2
op_or
id|limit
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
suffix:semicolon
id|addl
id|d2
comma
id|a2
id|movel
id|a4
comma
id|a1
op_or
id|dest
op_assign
(paren
id|u_long
op_star
)paren
id|start_mem
suffix:semicolon
l_int|1
suffix:colon
id|cmpl
id|a0
comma
id|a2
id|jeq
l_float|2f
op_or
r_while
(paren
id|src
OL
id|limit
)paren
id|moveb
id|a0
"@"
op_plus
comma
id|a1
"@"
op_plus
op_or
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
id|jra
l_int|1
id|b
l_int|2
suffix:colon
op_or
multiline_comment|/* copy bootinfo to end of bss */
id|movel
id|a3
comma
id|a0
op_or
id|src
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|memptr
op_plus
id|kernel_size
)paren
suffix:semicolon
id|addl
id|d2
comma
id|a0
op_or
id|dest
op_assign
id|end
id|of
id|bss
(paren
id|already
id|in
id|a1
)paren
id|movel
id|d3
comma
id|d7
op_or
id|count
op_assign
id|bi_size
id|subql
macro_line|#1,d7
l_int|1
suffix:colon
id|moveb
id|a0
"@"
op_plus
comma
id|a1
"@"
op_plus
op_or
r_while
(paren
op_decrement
id|count
OG
op_minus
l_int|1
)paren
id|dbra
id|d7
comma
l_int|1
id|b
op_or
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
op_or
multiline_comment|/* copy the ramdisk to the top of memory */
op_or
multiline_comment|/* (from back to front) */
id|movel
id|a4
comma
id|a1
op_or
id|dest
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|start_mem
op_plus
id|mem_size
)paren
suffix:semicolon
id|addl
id|d0
comma
id|a1
id|movel
id|a3
comma
id|a2
op_or
id|limit
op_assign
(paren
id|u_long
op_star
)paren
(paren
id|memptr
op_plus
id|kernel_size
op_plus
id|addl
id|d2
comma
id|a2
op_or
id|bi_size
)paren
suffix:semicolon
id|addl
id|d3
comma
id|a2
id|movel
id|a2
comma
id|a0
op_or
id|src
op_assign
(paren
id|u_long
op_star
)paren
(paren
(paren
id|u_long
)paren
id|limit
op_plus
id|rd_size
)paren
suffix:semicolon
id|addl
id|d1
comma
id|a0
l_int|1
suffix:colon
id|cmpl
id|a0
comma
id|a2
id|beqs
l_float|2f
op_or
r_while
(paren
id|src
OG
id|limit
)paren
id|moveb
id|a0
"@"
op_minus
comma
id|a1
"@"
op_minus
op_or
op_star
op_decrement
id|dest
op_assign
op_star
op_decrement
id|src
suffix:semicolon
id|bras
l_int|1
id|b
l_int|2
suffix:colon
op_or
multiline_comment|/* jump to start of kernel */
id|movel
id|a4
comma
id|a0
op_or
id|jump_to
(paren
id|start_mem
)paren
suffix:semicolon
id|jmp
id|a0
"@"
"&quot;"
id|SYMBOL_NAME_STR
c_func
(paren
id|copyallend
)paren
"&quot;"
suffix:colon
"&quot;"
)paren
suffix:semicolon
multiline_comment|/*&n;     *&t;Test for a MapROMmed A3640 Board&n;     */
id|asm
c_func
(paren
l_string|&quot;.text&bslash;n&quot;
id|ALIGN_STR
l_string|&quot;&bslash;n&quot;
id|SYMBOL_NAME_STR
c_func
(paren
id|maprommed
)paren
"&quot;"
suffix:colon
id|oriw
macro_line|#0x0700,sr
id|moveml
macro_line|#0x3f20,sp@-
op_or
multiline_comment|/* Save cache settings */
dot
r_int
l_int|0x4e7a1002
op_or
id|movec
id|cacr
comma
id|d1
op_star
op_div
op_or
multiline_comment|/* Save MMU settings */
dot
r_int
l_int|0x4e7a2003
op_or
id|movec
id|tc
comma
id|d2
dot
r_int
l_int|0x4e7a3004
op_or
id|movec
id|itt0
comma
id|d3
dot
r_int
l_int|0x4e7a4005
op_or
id|movec
id|itt1
comma
id|d4
dot
r_int
l_int|0x4e7a5006
op_or
id|movec
id|dtt0
comma
id|d5
dot
r_int
l_int|0x4e7a6007
op_or
id|movec
id|dtt1
comma
id|d6
id|moveq
macro_line|#0,d0
id|movel
id|d0
comma
id|a2
op_or
multiline_comment|/* Disable caches */
dot
r_int
l_int|0x4e7b0002
op_or
id|movec
id|d0
comma
id|cacr
op_or
multiline_comment|/* Disable MMU */
dot
r_int
l_int|0x4e7b0003
op_or
id|movec
id|d0
comma
id|tc
dot
r_int
l_int|0x4e7b0004
op_or
id|movec
id|d0
comma
id|itt0
dot
r_int
l_int|0x4e7b0005
op_or
id|movec
id|d0
comma
id|itt1
dot
r_int
l_int|0x4e7b0006
op_or
id|movec
id|d0
comma
id|dtt0
dot
r_int
l_int|0x4e7b0007
op_or
id|movec
id|d0
comma
id|dtt1
id|lea
l_int|0x07f80000
comma
id|a0
id|lea
l_int|0x00f80000
comma
id|a1
id|movel
id|a0
"@"
comma
id|d7
id|cmpl
id|a1
"@"
comma
id|d7
id|jne
l_float|1f
id|movel
id|d7
comma
id|d0
id|notl
id|d0
id|movel
id|d0
comma
id|a0
"@"
id|nop
op_or
multiline_comment|/* Thanks to J&#xfffd;rg Mayer! */
id|cmpl
id|a1
"@"
comma
id|d0
id|jne
l_float|1f
id|moveq
macro_line|#-1,d0&t;&t;| /* MapROMmed A3640 present */
id|movel
id|d0
comma
id|a2
l_int|1
suffix:colon
id|movel
id|d7
comma
id|a0
"@"
op_or
multiline_comment|/* Restore MMU settings */
dot
r_int
l_int|0x4e7b2003
op_or
id|movec
id|d2
comma
id|tc
dot
r_int
l_int|0x4e7b3004
op_or
id|movec
id|d3
comma
id|itt0
dot
r_int
l_int|0x4e7b4005
op_or
id|movec
id|d4
comma
id|itt1
dot
r_int
l_int|0x4e7b5006
op_or
id|movec
id|d5
comma
id|dtt0
dot
r_int
l_int|0x4e7b6007
op_or
id|movec
id|d6
comma
id|dtt1
op_or
multiline_comment|/* Restore cache settings */
dot
r_int
l_int|0x4e7b1002
op_or
id|movec
id|d1
comma
id|cacr
id|movel
id|a2
comma
id|d0
id|moveml
id|sp
"@"
op_plus
comma
macro_line|#0x04fc
id|rte
"&quot;"
)paren
suffix:semicolon
multiline_comment|/*&n;     *&t;Reset functions for nasty Zorro boards&n;     */
DECL|function|reset_rb3
r_static
r_void
id|reset_rb3
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
(brace
r_volatile
id|u_char
op_star
id|rb3_reg
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x01002000
)paren
suffix:semicolon
multiline_comment|/* FN: If a Rainbow III board is present, reset it to disable */
multiline_comment|/* its (possibly activated) vertical blank interrupts as the */
multiline_comment|/* kernel is not yet prepared to handle them (level 6). */
multiline_comment|/* set RESET bit in special function register */
op_star
id|rb3_reg
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* actually, only a few cycles delay are required... */
id|Sleep
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/* clear reset bit */
op_star
id|rb3_reg
op_assign
l_int|0x00
suffix:semicolon
)brace
DECL|function|reset_piccolo
r_static
r_void
id|reset_piccolo
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
(brace
r_volatile
id|u_char
op_star
id|piccolo_reg
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/* FN: the same stuff as above, for the Piccolo board. */
multiline_comment|/* this also has the side effect of resetting the board&squot;s */
multiline_comment|/* output selection logic to use the Amiga&squot;s display in single */
multiline_comment|/* monitor systems - which is currently what we want. */
multiline_comment|/* set RESET bit in special function register */
op_star
id|piccolo_reg
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* actually, only a few cycles delay are required... */
id|Sleep
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/* clear reset bit */
op_star
id|piccolo_reg
op_assign
l_int|0x51
suffix:semicolon
)brace
DECL|function|reset_sd64
r_static
r_void
id|reset_sd64
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
(brace
r_volatile
id|u_char
op_star
id|sd64_reg
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/* FN: the same stuff as above, for the SD64 board. */
multiline_comment|/* just as on the Piccolo, this also resets the monitor switch */
multiline_comment|/* set RESET bit in special function register */
op_star
id|sd64_reg
op_assign
l_int|0x1f
suffix:semicolon
multiline_comment|/* actually, only a few cycles delay are required... */
id|Sleep
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/* clear reset bit AND switch monitor bit (0x20) */
op_star
id|sd64_reg
op_assign
l_int|0x4f
suffix:semicolon
)brace
DECL|function|reset_ariadne
r_static
r_void
id|reset_ariadne
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
(brace
r_volatile
id|u_short
op_star
id|lance_rdp
op_assign
(paren
id|u_short
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x0370
)paren
suffix:semicolon
r_volatile
id|u_short
op_star
id|lance_rap
op_assign
(paren
id|u_short
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x0372
)paren
suffix:semicolon
r_volatile
id|u_short
op_star
id|lance_reset
op_assign
(paren
id|u_short
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x0374
)paren
suffix:semicolon
r_volatile
id|u_char
op_star
id|pit_paddr
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x1004
)paren
suffix:semicolon
r_volatile
id|u_char
op_star
id|pit_pbddr
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x1006
)paren
suffix:semicolon
r_volatile
id|u_char
op_star
id|pit_pacr
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x100b
)paren
suffix:semicolon
r_volatile
id|u_char
op_star
id|pit_pbcr
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x100e
)paren
suffix:semicolon
r_volatile
id|u_char
op_star
id|pit_psr
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0x101a
)paren
suffix:semicolon
id|u_short
id|in
suffix:semicolon
id|Disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     *&t;Reset the Ethernet part (Am79C960 PCnet-ISA)&n;     */
id|in
op_assign
op_star
id|lance_reset
suffix:semicolon
multiline_comment|/* Reset Chip on Read Access */
op_star
id|lance_rap
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* PCnet-ISA Controller Status (CSR0) */
op_star
id|lance_rdp
op_assign
l_int|0x0400
suffix:semicolon
multiline_comment|/* STOP */
multiline_comment|/*&n;     *&t;Reset the Parallel part (MC68230 PI/T)&n;     */
op_star
id|pit_pacr
op_and_assign
l_int|0xfd
suffix:semicolon
multiline_comment|/* Port A Control Register */
op_star
id|pit_pbcr
op_and_assign
l_int|0xfd
suffix:semicolon
multiline_comment|/* Port B Control Register */
op_star
id|pit_psr
op_assign
l_int|0x05
suffix:semicolon
multiline_comment|/* Port Status Register */
op_star
id|pit_paddr
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Port A Data Direction Register */
op_star
id|pit_pbddr
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Port B Data Direction Register */
id|Enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|reset_hydra
r_static
r_void
id|reset_hydra
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
(brace
r_volatile
id|u_char
op_star
id|nic_cr
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0xffe1
)paren
suffix:semicolon
r_volatile
id|u_char
op_star
id|nic_isr
op_assign
(paren
id|u_char
op_star
)paren
(paren
id|cd-&gt;cd_BoardAddr
op_plus
l_int|0xffe1
op_plus
l_int|14
)paren
suffix:semicolon
r_int
id|n
op_assign
l_int|5000
suffix:semicolon
id|Disable
c_func
(paren
)paren
suffix:semicolon
op_star
id|nic_cr
op_assign
l_int|0x21
suffix:semicolon
multiline_comment|/* nic command register: software reset etc. */
r_while
c_loop
(paren
(paren
(paren
op_star
id|nic_isr
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
op_logical_and
op_decrement
id|n
)paren
multiline_comment|/* wait for reset to complete */
suffix:semicolon
id|Enable
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|reset_a2060
c_func
(paren
r_const
r_struct
id|ConfigDev
op_star
id|cd
)paren
(brace
macro_line|#error reset_a2060: not yet implemented
)brace
macro_line|#endif
macro_line|#ifdef ZKERNEL
DECL|macro|ZFILE_CHUNK_BITS
mdefine_line|#define&t;ZFILE_CHUNK_BITS&t;16  /* chunk is 64 KB */
DECL|macro|ZFILE_CHUNK_SIZE
mdefine_line|#define&t;ZFILE_CHUNK_SIZE&t;(1 &lt;&lt; ZFILE_CHUNK_BITS)
DECL|macro|ZFILE_CHUNK_MASK
mdefine_line|#define&t;ZFILE_CHUNK_MASK&t;(ZFILE_CHUNK_SIZE-1)
DECL|macro|ZFILE_N_CHUNKS
mdefine_line|#define&t;ZFILE_N_CHUNKS&t;&t;(2*1024*1024/ZFILE_CHUNK_SIZE)
multiline_comment|/* variables for storing the uncompressed data */
DECL|variable|ZFile
r_static
r_char
op_star
id|ZFile
(braket
id|ZFILE_N_CHUNKS
)braket
suffix:semicolon
DECL|variable|ZFileSize
r_static
r_int
id|ZFileSize
op_assign
l_int|0
suffix:semicolon
DECL|variable|ZFpos
r_static
r_int
id|ZFpos
op_assign
l_int|0
suffix:semicolon
DECL|variable|Zwpos
r_static
r_int
id|Zwpos
op_assign
l_int|0
suffix:semicolon
DECL|variable|Zinfd
r_static
r_int
id|Zinfd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fd of compressed file */
multiline_comment|/*&n; * gzip declarations&n; */
DECL|macro|OF
mdefine_line|#define OF(args)  args
DECL|macro|memzero
mdefine_line|#define memzero(s, n)     memset ((s), 0, (n))
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
DECL|typedef|ulg
r_typedef
r_int
r_int
id|ulg
suffix:semicolon
DECL|macro|INBUFSIZ
mdefine_line|#define INBUFSIZ 4096
DECL|macro|WSIZE
mdefine_line|#define WSIZE 0x8000    /* window size--must be a power of two, and */
multiline_comment|/*  at least 32K for zip&squot;s deflate method */
DECL|variable|inbuf
r_static
id|uch
op_star
id|inbuf
suffix:semicolon
DECL|variable|window
r_static
id|uch
op_star
id|window
suffix:semicolon
DECL|variable|insize
r_static
r_int
id|insize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* valid bytes in inbuf */
DECL|variable|inptr
r_static
r_int
id|inptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index of next byte to be processed in inbuf */
DECL|variable|outcnt
r_static
r_int
id|outcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bytes in output buffer */
DECL|variable|exit_code
r_static
r_int
id|exit_code
op_assign
l_int|0
suffix:semicolon
DECL|variable|bytes_out
r_static
r_int
id|bytes_out
op_assign
l_int|0
suffix:semicolon
DECL|macro|get_byte
mdefine_line|#define get_byte()  (inptr &lt; insize ? inbuf[inptr++] : fill_inbuf())
multiline_comment|/* Diagnostic functions (stubbed out) */
DECL|macro|Assert
mdefine_line|#define Assert(cond,msg)
DECL|macro|Trace
mdefine_line|#define Trace(x)
DECL|macro|Tracev
mdefine_line|#define Tracev(x)
DECL|macro|Tracevv
mdefine_line|#define Tracevv(x)
DECL|macro|Tracec
mdefine_line|#define Tracec(c,x)
DECL|macro|Tracecv
mdefine_line|#define Tracecv(c,x)
DECL|macro|STATIC
mdefine_line|#define STATIC static
r_static
r_int
id|fill_inbuf
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|flush_window
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|m
)paren
suffix:semicolon
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
DECL|macro|malloc
mdefine_line|#define malloc(x)&t;AllocVec(x, MEMF_FAST | MEMF_PUBLIC)
DECL|macro|free
mdefine_line|#define free(x)&t;&t;FreeVec(x)
macro_line|#ifdef LILO
macro_line|#include &quot;inflate.c&quot;
macro_line|#else
macro_line|#include &quot;../../../../lib/inflate.c&quot;
macro_line|#endif
DECL|function|gzip_mark
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
DECL|function|gzip_release
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
multiline_comment|/*&n; * Fill the input buffer. This is called only when the buffer is empty&n; * and at least one byte is really needed.&n; */
DECL|function|fill_inbuf
r_static
r_int
id|fill_inbuf
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|exit_code
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|insize
op_assign
id|Read
c_func
(paren
id|Zinfd
comma
id|inbuf
comma
id|INBUFSIZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insize
op_le
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|inptr
op_assign
l_int|1
suffix:semicolon
r_return
id|inbuf
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the output window window[0..outcnt-1] and update crc and bytes_out.&n; * (Used for the decompressed data only.)&n; */
DECL|function|flush_window
r_static
r_void
id|flush_window
c_func
(paren
r_void
)paren
(brace
id|ulg
id|c
op_assign
id|crc
suffix:semicolon
multiline_comment|/* temporary variable */
r_int
id|n
suffix:semicolon
id|uch
op_star
id|in
comma
id|ch
suffix:semicolon
r_int
id|chunk
op_assign
id|Zwpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_if
c_cond
(paren
id|exit_code
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|chunk
op_ge
id|ZFILE_N_CHUNKS
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Compressed image too large! Aborting.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ZFile
(braket
id|chunk
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ZFile
(braket
id|chunk
)braket
op_assign
(paren
r_char
op_star
)paren
id|AllocMem
c_func
(paren
id|ZFILE_CHUNK_SIZE
comma
id|MEMF_FAST
op_or
id|MEMF_PUBLIC
)paren
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;Out of memory for decompresing kernel image&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|memcpy
c_func
(paren
id|ZFile
(braket
id|chunk
)braket
op_plus
(paren
id|Zwpos
op_amp
id|ZFILE_CHUNK_MASK
)paren
comma
id|window
comma
id|outcnt
)paren
suffix:semicolon
id|Zwpos
op_add_assign
id|outcnt
suffix:semicolon
DECL|macro|DISPLAY_BITS
mdefine_line|#define&t;DISPLAY_BITS 10
r_if
c_cond
(paren
(paren
id|Zwpos
op_amp
(paren
(paren
l_int|1
op_lshift
id|DISPLAY_BITS
)paren
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
id|PutChar
c_func
(paren
l_char|&squot;.&squot;
)paren
suffix:semicolon
id|in
op_assign
id|window
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|outcnt
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
id|c
op_assign
id|crc_32_tab
(braket
(paren
(paren
r_int
)paren
id|c
op_xor
id|ch
)paren
op_amp
l_int|0xff
)braket
op_xor
(paren
id|c
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|crc
op_assign
id|c
suffix:semicolon
id|bytes_out
op_add_assign
(paren
id|ulg
)paren
id|outcnt
suffix:semicolon
id|outcnt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|error
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|x
)paren
(brace
id|Printf
c_func
(paren
l_string|&quot;&bslash;n%s&quot;
comma
id|x
)paren
suffix:semicolon
id|exit_code
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|call_sub
r_static
r_inline
r_int
id|call_sub
c_func
(paren
r_int
(paren
op_star
id|func
)paren
(paren
r_void
)paren
comma
r_void
op_star
id|stackp
)paren
(brace
r_register
r_int
id|_res
id|__asm
c_func
(paren
l_string|&quot;d0&quot;
)paren
suffix:semicolon
r_register
r_int
(paren
op_star
id|a0
)paren
(paren
r_void
)paren
id|__asm
c_func
(paren
l_string|&quot;a0&quot;
)paren
op_assign
id|func
suffix:semicolon
r_register
r_int
(paren
op_star
id|a1
)paren
(paren
r_void
)paren
id|__asm
c_func
(paren
l_string|&quot;a1&quot;
)paren
op_assign
id|stackp
suffix:semicolon
id|__asm
id|__volatile
(paren
l_string|&quot;movel sp,a2;&quot;
l_string|&quot;movel a1,sp;&quot;
l_string|&quot;jsr a0@;&quot;
l_string|&quot;movel a2,sp&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|_res
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|a0
)paren
comma
l_string|&quot;r&quot;
(paren
id|a1
)paren
suffix:colon
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
comma
l_string|&quot;a2&quot;
comma
l_string|&quot;d0&quot;
comma
l_string|&quot;d1&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|_res
suffix:semicolon
)brace
DECL|function|load_zkernel
r_static
r_int
id|load_zkernel
c_func
(paren
r_int
id|fd
)paren
(brace
r_int
id|i
comma
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|macro|ZSTACKSIZE
mdefine_line|#define ZSTACKSIZE&t;(16384)
id|u_long
op_star
id|zstack
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ZFILE_N_CHUNKS
suffix:semicolon
op_increment
id|i
)paren
id|ZFile
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|Zinfd
op_assign
id|fd
suffix:semicolon
id|Seek
c_func
(paren
id|fd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inbuf
op_assign
(paren
id|uch
op_star
)paren
id|AllocMem
c_func
(paren
id|INBUFSIZ
comma
id|MEMF_FAST
op_or
id|MEMF_PUBLIC
)paren
)paren
)paren
id|Puts
c_func
(paren
l_string|&quot;Couldn&squot;t allocate gunzip buffer&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|window
op_assign
(paren
id|uch
op_star
)paren
id|AllocMem
c_func
(paren
id|WSIZE
comma
id|MEMF_FAST
op_or
id|MEMF_PUBLIC
)paren
)paren
)paren
id|Puts
c_func
(paren
l_string|&quot;Couldn&squot;t allocate gunzip window&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|zstack
op_assign
(paren
id|u_long
op_star
)paren
id|AllocMem
c_func
(paren
id|ZSTACKSIZE
comma
id|MEMF_FAST
op_or
id|MEMF_PUBLIC
)paren
)paren
)paren
id|Puts
c_func
(paren
l_string|&quot;Couldn&squot;t allocate gunzip stack&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|Puts
c_func
(paren
l_string|&quot;Uncompressing kernel image &quot;
)paren
suffix:semicolon
id|makecrc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|call_sub
c_func
(paren
id|gunzip
comma
(paren
r_char
op_star
)paren
id|zstack
op_plus
id|ZSTACKSIZE
)paren
)paren
)paren
id|Puts
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
id|ZFileSize
op_assign
id|Zwpos
suffix:semicolon
id|FreeMem
c_func
(paren
id|zstack
comma
id|ZSTACKSIZE
)paren
suffix:semicolon
)brace
id|FreeMem
c_func
(paren
id|window
comma
id|WSIZE
)paren
suffix:semicolon
id|window
op_assign
l_int|NULL
suffix:semicolon
)brace
id|FreeMem
c_func
(paren
id|inbuf
comma
id|INBUFSIZ
)paren
suffix:semicolon
id|inbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|Close
c_func
(paren
id|Zinfd
)paren
suffix:semicolon
multiline_comment|/* input file not needed anymore */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Note about the read/lseek wrapper and its memory management: It assumes&n; * that all seeks are only forward, and thus data already read or skipped can&n; * be freed. This is true for current organization of bootstrap and kernels.&n; * Little exception: The struct kexec at the start of the file. After reading&n; * it, there may be a seek back to the end of the file. But this currently&n; * doesn&squot;t hurt. (Roman)&n; */
DECL|function|KRead
r_static
r_int
id|KRead
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|buf
comma
r_int
id|cnt
)paren
(brace
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ZFileSize
)paren
r_return
id|Read
c_func
(paren
id|fd
comma
id|buf
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ZFpos
op_plus
id|cnt
OG
id|ZFileSize
)paren
id|cnt
op_assign
id|ZFileSize
op_minus
id|ZFpos
suffix:semicolon
r_while
c_loop
(paren
id|cnt
OG
l_int|0
)paren
(brace
r_int
id|chunk
op_assign
id|ZFpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_int
id|endchunk
op_assign
(paren
id|chunk
op_plus
l_int|1
)paren
op_lshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_int
id|n
op_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|ZFpos
op_plus
id|n
OG
id|endchunk
)paren
id|n
op_assign
id|endchunk
op_minus
id|ZFpos
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|ZFile
(braket
id|chunk
)braket
op_plus
(paren
id|ZFpos
op_amp
id|ZFILE_CHUNK_MASK
)paren
comma
id|n
)paren
suffix:semicolon
id|cnt
op_sub_assign
id|n
suffix:semicolon
id|buf
op_add_assign
id|n
suffix:semicolon
id|done
op_add_assign
id|n
suffix:semicolon
id|ZFpos
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|ZFpos
op_eq
id|endchunk
)paren
(brace
id|FreeMem
c_func
(paren
id|ZFile
(braket
id|chunk
)braket
comma
id|ZFILE_CHUNK_SIZE
)paren
suffix:semicolon
id|ZFile
(braket
id|chunk
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|done
suffix:semicolon
)brace
DECL|function|KSeek
r_static
r_int
id|KSeek
c_func
(paren
r_int
id|fd
comma
r_int
id|offset
)paren
(brace
r_int
id|oldpos
comma
id|oldchunk
comma
id|newchunk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ZFileSize
)paren
r_return
id|Seek
c_func
(paren
id|fd
comma
id|offset
)paren
suffix:semicolon
id|oldpos
op_assign
id|ZFpos
suffix:semicolon
id|ZFpos
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|ZFpos
OL
l_int|0
)paren
(brace
id|ZFpos
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ZFpos
OG
id|ZFileSize
)paren
(brace
id|ZFpos
op_assign
id|ZFileSize
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* free memory of skipped-over data */
id|oldchunk
op_assign
id|oldpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
id|newchunk
op_assign
id|ZFpos
op_rshift
id|ZFILE_CHUNK_BITS
suffix:semicolon
r_while
c_loop
(paren
id|oldchunk
OL
id|newchunk
)paren
(brace
r_if
c_cond
(paren
id|ZFile
(braket
id|oldchunk
)braket
)paren
(brace
id|FreeMem
c_func
(paren
id|ZFile
(braket
id|oldchunk
)braket
comma
id|ZFILE_CHUNK_SIZE
)paren
suffix:semicolon
id|ZFile
(braket
id|oldchunk
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
op_increment
id|oldchunk
suffix:semicolon
)brace
r_return
id|ZFpos
suffix:semicolon
)brace
DECL|function|free_zfile
r_static
r_void
id|free_zfile
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ZFILE_N_CHUNKS
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|ZFile
(braket
id|i
)braket
)paren
(brace
id|FreeMem
c_func
(paren
id|ZFile
(braket
id|i
)braket
comma
id|ZFILE_CHUNK_SIZE
)paren
suffix:semicolon
id|ZFile
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|KClose
r_static
r_int
id|KClose
c_func
(paren
r_int
id|fd
)paren
(brace
r_if
c_cond
(paren
id|ZFileSize
)paren
(brace
id|free_zfile
c_func
(paren
)paren
suffix:semicolon
id|ZFileSize
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|Close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* ZKERNEL */
eof
