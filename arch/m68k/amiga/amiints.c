multiline_comment|/*&n; * amiints.c -- Amiga Linux interrupt handling code&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file README.legal in the main directory of this archive&n; * for more details.&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#include &lt;asm/amigaints.h&gt;
multiline_comment|/* isr node variables for amiga interrupt sources */
DECL|variable|ami_lists
r_static
id|isr_node_t
op_star
id|ami_lists
(braket
id|NUM_AMIGA_SOURCES
)braket
suffix:semicolon
DECL|variable|ami_intena_vals
r_static
r_const
id|ushort
id|ami_intena_vals
(braket
id|NUM_AMIGA_SOURCES
)braket
op_assign
(brace
id|IF_VERTB
comma
id|IF_COPER
comma
id|IF_AUD0
comma
id|IF_AUD1
comma
id|IF_AUD2
comma
id|IF_AUD3
comma
id|IF_BLIT
comma
id|IF_DSKSYN
comma
id|IF_DSKBLK
comma
id|IF_RBF
comma
id|IF_TBE
comma
id|IF_PORTS
comma
id|IF_PORTS
comma
id|IF_PORTS
comma
id|IF_PORTS
comma
id|IF_PORTS
comma
id|IF_EXTER
comma
id|IF_EXTER
comma
id|IF_EXTER
comma
id|IF_EXTER
comma
id|IF_EXTER
comma
id|IF_SOFT
comma
id|IF_PORTS
comma
id|IF_EXTER
)brace
suffix:semicolon
DECL|struct|ciadata
r_struct
id|ciadata
(brace
DECL|member|ciaptr
r_volatile
r_struct
id|CIA
op_star
id|ciaptr
suffix:semicolon
DECL|member|baseirq
r_int
r_int
id|baseirq
suffix:semicolon
DECL|variable|ciadata
)brace
id|ciadata
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n; * index into ami_lists for IRQs.  CIA IRQs are special, because&n; * the same cia interrupt handler is used for both CIAs.&n; */
DECL|macro|IRQ_IDX
mdefine_line|#define IRQ_IDX(source) (source &amp; ~IRQ_MACHSPEC)
DECL|macro|CIA_IRQ_IDX
mdefine_line|#define CIA_IRQ_IDX(source) (IRQ_IDX(datap-&gt;baseirq) &bslash;&n;&t;&t;&t;     +(source-IRQ_AMIGA_CIAA_TA))
multiline_comment|/*&n; * void amiga_init_INTS (void)&n; *&n; * Parameters:&t;None&n; *&n; * Returns:&t;Nothing&n; *&n; * This function should be called during kernel startup to initialize&n; * the amiga IRQ handling routines.&n; */
r_static
r_void
id|ami_int1
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
comma
id|ami_int2
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
comma
id|ami_int3
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
comma
id|ami_int4
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
comma
id|ami_int5
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
comma
id|ami_int6
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
comma
id|ami_int7
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
comma
id|ami_intcia
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
suffix:semicolon
DECL|function|amiga_init_INTS
r_void
id|amiga_init_INTS
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* initialize handlers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_AMIGA_SOURCES
suffix:semicolon
id|i
op_increment
)paren
id|ami_lists
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|add_isr
(paren
id|IRQ1
comma
id|ami_int1
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;int1 handler&quot;
)paren
suffix:semicolon
id|add_isr
(paren
id|IRQ2
comma
id|ami_int2
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;int2 handler&quot;
)paren
suffix:semicolon
id|add_isr
(paren
id|IRQ3
comma
id|ami_int3
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;int3 handler&quot;
)paren
suffix:semicolon
id|add_isr
(paren
id|IRQ4
comma
id|ami_int4
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;int4 handler&quot;
)paren
suffix:semicolon
id|add_isr
(paren
id|IRQ5
comma
id|ami_int5
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;int5 handler&quot;
)paren
suffix:semicolon
id|add_isr
(paren
id|IRQ6
comma
id|ami_int6
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;int6 handler&quot;
)paren
suffix:semicolon
id|add_isr
(paren
id|IRQ7
comma
id|ami_int7
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;int7 handler&quot;
)paren
suffix:semicolon
multiline_comment|/* hook in the CIA interrupts */
id|ciadata
(braket
l_int|0
)braket
dot
id|ciaptr
op_assign
op_amp
id|ciaa
suffix:semicolon
id|ciadata
(braket
l_int|0
)braket
dot
id|baseirq
op_assign
id|IRQ_AMIGA_CIAA_TA
suffix:semicolon
id|add_isr
(paren
id|IRQ_AMIGA_PORTS
comma
id|ami_intcia
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;Amiga CIAA&quot;
)paren
suffix:semicolon
id|ciadata
(braket
l_int|1
)braket
dot
id|ciaptr
op_assign
op_amp
id|ciab
suffix:semicolon
id|ciadata
(braket
l_int|1
)braket
dot
id|baseirq
op_assign
id|IRQ_AMIGA_CIAB_TA
suffix:semicolon
id|add_isr
(paren
id|IRQ_AMIGA_EXTER
comma
id|ami_intcia
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;Amiga CIAB&quot;
)paren
suffix:semicolon
multiline_comment|/* turn off all interrupts and enable the master interrupt bit */
id|custom.intena
op_assign
l_int|0x7fff
suffix:semicolon
id|custom.intreq
op_assign
l_int|0x7fff
suffix:semicolon
id|custom.intena
op_assign
l_int|0xc000
suffix:semicolon
multiline_comment|/* turn off all CIA interrupts */
id|ciaa.icr
op_assign
l_int|0x7f
suffix:semicolon
id|ciab.icr
op_assign
l_int|0x7f
suffix:semicolon
multiline_comment|/* clear any pending CIA interrupts */
id|i
op_assign
id|ciaa.icr
suffix:semicolon
id|i
op_assign
id|ciab.icr
suffix:semicolon
)brace
multiline_comment|/*&n; * The builtin Amiga hardware interrupt handlers.&n; */
DECL|function|ami_int1
r_static
r_void
id|ami_int1
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
id|ushort
id|ints
op_assign
id|custom.intreqr
op_amp
id|custom.intenar
suffix:semicolon
multiline_comment|/* if serial transmit buffer empty, interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_TBE
)paren
(brace
r_if
c_cond
(paren
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_TBE
)paren
)braket
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_TBE
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_TBE
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* &n;&t;     * don&squot;t acknowledge.... &n;&t;     * allow serial code to turn off interrupts, but&n;&t;     * leave it pending so that when interrupts are&n;&t;     * turned on, transmission will resume&n;&t;     */
)brace
r_else
multiline_comment|/* acknowledge the interrupt */
id|custom.intreq
op_assign
id|IF_TBE
suffix:semicolon
)brace
multiline_comment|/* if floppy disk transfer complete, interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_DSKBLK
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_DSKBLK
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_DSKBLK
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_DSKBLK
suffix:semicolon
)brace
multiline_comment|/* if software interrupt set, interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_SOFT
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_SOFT
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_SOFT
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_SOFT
suffix:semicolon
)brace
)brace
DECL|function|ami_int2
r_static
r_void
id|ami_int2
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
id|ushort
id|ints
op_assign
id|custom.intreqr
op_amp
id|custom.intenar
suffix:semicolon
r_if
c_cond
(paren
id|ints
op_amp
id|IF_PORTS
)paren
(brace
multiline_comment|/* call routines which have hooked into the PORTS interrupt */
id|call_isr_list
(paren
id|IRQ_AMIGA_PORTS
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_PORTS
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_PORTS
suffix:semicolon
)brace
)brace
DECL|function|ami_int3
r_static
r_void
id|ami_int3
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
id|ushort
id|ints
op_assign
id|custom.intreqr
op_amp
id|custom.intenar
suffix:semicolon
multiline_comment|/* if a copper interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_COPER
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_COPPER
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_COPPER
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_COPER
suffix:semicolon
)brace
multiline_comment|/* if a vertical blank interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_VERTB
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_VERTB
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_VERTB
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_VERTB
suffix:semicolon
)brace
multiline_comment|/* if a blitter interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_BLIT
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_BLIT
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_BLIT
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_BLIT
suffix:semicolon
)brace
)brace
DECL|function|ami_int4
r_static
r_void
id|ami_int4
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
id|ushort
id|ints
op_assign
id|custom.intreqr
op_amp
id|custom.intenar
suffix:semicolon
multiline_comment|/* if audio 0 interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_AUD0
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_AUD0
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_AUD0
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_AUD0
suffix:semicolon
)brace
multiline_comment|/* if audio 1 interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_AUD1
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_AUD1
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_AUD1
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_AUD1
suffix:semicolon
)brace
multiline_comment|/* if audio 2 interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_AUD2
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_AUD2
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_AUD2
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_AUD2
suffix:semicolon
)brace
multiline_comment|/* if audio 3 interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_AUD3
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_AUD3
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_AUD3
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_AUD3
suffix:semicolon
)brace
)brace
DECL|function|ami_int5
r_static
r_void
id|ami_int5
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
id|ushort
id|ints
op_assign
id|custom.intreqr
op_amp
id|custom.intenar
suffix:semicolon
multiline_comment|/* if serial receive buffer full interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_RBF
)paren
(brace
r_if
c_cond
(paren
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_RBF
)paren
)braket
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_RBF
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_RBF
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* don&squot;t acknowledge ; leave that for the handler */
)brace
r_else
multiline_comment|/* acknowledge the interrupt */
id|custom.intreq
op_assign
id|IF_RBF
suffix:semicolon
)brace
multiline_comment|/* if a disk sync interrupt */
r_if
c_cond
(paren
id|ints
op_amp
id|IF_DSKSYN
)paren
(brace
id|call_isr_list
(paren
id|IRQ_AMIGA_DSKSYN
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_DSKSYN
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_DSKSYN
suffix:semicolon
)brace
)brace
DECL|function|ami_int6
r_static
r_void
id|ami_int6
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
id|ushort
id|ints
op_assign
id|custom.intreqr
op_amp
id|custom.intenar
suffix:semicolon
r_if
c_cond
(paren
id|ints
op_amp
id|IF_EXTER
)paren
(brace
multiline_comment|/* call routines which have hooked into the EXTER interrupt */
id|call_isr_list
(paren
id|IRQ_AMIGA_EXTER
comma
id|ami_lists
(braket
id|IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_EXTER
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* acknowledge */
id|custom.intreq
op_assign
id|IF_EXTER
suffix:semicolon
)brace
)brace
DECL|function|ami_int7
r_static
r_void
id|ami_int7
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
id|panic
(paren
l_string|&quot;level 7 interrupt received&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|ami_intcia
r_static
r_void
id|ami_intcia
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|fp
comma
r_void
op_star
id|data
)paren
(brace
multiline_comment|/* check CIA interrupts */
r_struct
id|ciadata
op_star
id|datap
suffix:semicolon
id|u_char
id|cia_ints
suffix:semicolon
multiline_comment|/* setup data correctly */
r_if
c_cond
(paren
id|irq
op_eq
id|IRQ_AMIGA_PORTS
)paren
id|datap
op_assign
op_amp
id|ciadata
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|datap
op_assign
op_amp
id|ciadata
(braket
l_int|1
)braket
suffix:semicolon
id|cia_ints
op_assign
id|datap-&gt;ciaptr-&gt;icr
suffix:semicolon
multiline_comment|/* if timer A interrupt */
r_if
c_cond
(paren
id|cia_ints
op_amp
id|CIA_ICR_TA
)paren
id|call_isr_list
(paren
id|IRQ_AMIGA_CIAA_TA
comma
id|ami_lists
(braket
id|CIA_IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_CIAA_TA
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* if timer B interrupt */
r_if
c_cond
(paren
id|cia_ints
op_amp
id|CIA_ICR_TB
)paren
id|call_isr_list
(paren
id|IRQ_AMIGA_CIAA_TB
comma
id|ami_lists
(braket
id|CIA_IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_CIAA_TB
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* if the alarm interrupt */
r_if
c_cond
(paren
id|cia_ints
op_amp
id|CIA_ICR_ALRM
)paren
id|call_isr_list
(paren
id|IRQ_AMIGA_CIAA_ALRM
comma
id|ami_lists
(braket
id|CIA_IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_CIAA_ALRM
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* if serial port interrupt (keyboard) */
r_if
c_cond
(paren
id|cia_ints
op_amp
id|CIA_ICR_SP
)paren
id|call_isr_list
(paren
id|IRQ_AMIGA_CIAA_SP
comma
id|ami_lists
(braket
id|CIA_IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_CIAA_SP
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
multiline_comment|/* if flag interrupt (parallel port) */
r_if
c_cond
(paren
id|cia_ints
op_amp
id|CIA_ICR_FLG
)paren
id|call_isr_list
(paren
id|IRQ_AMIGA_CIAA_FLG
comma
id|ami_lists
(braket
id|CIA_IRQ_IDX
c_func
(paren
id|IRQ_AMIGA_CIAA_FLG
)paren
)braket
comma
id|fp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * amiga_add_isr : add an interrupt service routine for a particular&n; *&t;&t;   machine specific interrupt source.&n; *&t;&t;   If the addition was successful, it returns 1, otherwise&n; *&t;&t;   it returns 0.  It will fail if another routine is already&n; *&t;&t;   bound into the specified source.&n; *   Note that the &quot;pri&quot; argument is currently unused.&n; */
DECL|function|amiga_add_isr
r_int
id|amiga_add_isr
(paren
r_int
r_int
id|source
comma
id|isrfunc
id|isr
comma
r_int
id|pri
comma
r_void
op_star
id|data
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|amiga_source
op_assign
id|source
op_amp
op_complement
id|IRQ_MACHSPEC
suffix:semicolon
id|isr_node_t
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|amiga_source
OG
id|NUM_AMIGA_SOURCES
)paren
(brace
id|printk
(paren
l_string|&quot;amiga_add_isr: Unknown interrupt source %ld&bslash;n&quot;
comma
id|source
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
id|new_isr_node
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;isr
op_assign
id|isr
suffix:semicolon
id|p-&gt;pri
op_assign
id|pri
suffix:semicolon
id|p-&gt;data
op_assign
id|data
suffix:semicolon
id|p-&gt;name
op_assign
id|name
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|insert_isr
(paren
op_amp
id|ami_lists
(braket
id|amiga_source
)braket
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* enable the interrupt */
id|custom.intena
op_assign
id|IF_SETCLR
op_or
id|ami_intena_vals
(braket
id|amiga_source
)braket
suffix:semicolon
multiline_comment|/* if a CIAA interrupt, enable the appropriate CIA ICR bit */
r_if
c_cond
(paren
id|source
op_ge
id|IRQ_AMIGA_CIAA_TA
op_logical_and
id|source
op_le
id|IRQ_AMIGA_CIAA_FLG
)paren
id|ciaa.icr
op_assign
l_int|0x80
op_or
(paren
l_int|1
op_lshift
(paren
id|source
op_minus
id|IRQ_AMIGA_CIAA_TA
)paren
)paren
suffix:semicolon
multiline_comment|/* if a CIAB interrupt, enable the appropriate CIA ICR bit */
r_if
c_cond
(paren
id|source
op_ge
id|IRQ_AMIGA_CIAB_TA
op_logical_and
id|source
op_le
id|IRQ_AMIGA_CIAB_FLG
)paren
id|ciab.icr
op_assign
l_int|0x80
op_or
(paren
l_int|1
op_lshift
(paren
id|source
op_minus
id|IRQ_AMIGA_CIAB_TA
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|amiga_get_irq_list
r_int
id|amiga_get_irq_list
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
id|isr_node_t
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_AMIGA_SOURCES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ami_lists
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;ami  %2d: ???????? &quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|ami_lists
(braket
id|i
)braket
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|p-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;next
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;                  &quot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
eof
