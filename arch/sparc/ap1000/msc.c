multiline_comment|/*&n;   * Copyright 1996 The Australian National University.&n;   * Copyright 1996 Fujitsu Laboratories Limited&n;   * &n;   * This software may be distributed under the terms of the Gnu&n;   * Public License version 2 or later&n;  */
multiline_comment|/*&n; * Routines to control the AP1000+ Message Controller (MSC+)&n; * and Memory Controller (MC+).&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|_APLIB_
mdefine_line|#define _APLIB_
macro_line|#include &lt;asm/ap1000/apreg.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/ap1000/pgtapmmu.h&gt;
macro_line|#include &lt;linux/tasks.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
r_static
r_void
id|msc_interrupt_9
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|msc_interrupt_11
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|msc_set_ringbuf
c_func
(paren
r_int
id|context
)paren
suffix:semicolon
r_static
r_void
id|msc_update_read_ptr
c_func
(paren
r_int
id|context
comma
r_int
id|overflow
)paren
suffix:semicolon
r_static
r_void
id|fail_write
c_func
(paren
r_int
id|context
comma
r_int
id|intr
comma
r_int
id|vaddr
)paren
suffix:semicolon
r_static
r_void
id|fail_read
c_func
(paren
r_int
id|context
comma
r_int
id|intr
comma
r_int
id|vaddr
)paren
suffix:semicolon
r_static
r_void
id|msc_switch_from_check
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
r_static
r_void
id|msc_status
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
multiline_comment|/*&n; * This describes how the 5 queues for outgoing requests&n; * are mapped into the 256 words of send queue RAM in the MSC+.&n; */
DECL|macro|NSENDQUEUES
mdefine_line|#define NSENDQUEUES&t;&t;5
DECL|struct|send_queues
r_static
r_struct
id|send_queues
(brace
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* must be a multiple of size */
DECL|member|size
r_int
id|size
suffix:semicolon
multiline_comment|/* must be 32 or 64 */
DECL|variable|send_queues
)brace
id|send_queues
(braket
id|NSENDQUEUES
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|64
)brace
comma
multiline_comment|/* System put/send requests */
(brace
l_int|192
comma
l_int|32
)brace
comma
multiline_comment|/* Remote read/write requests */
(brace
l_int|64
comma
l_int|64
)brace
comma
multiline_comment|/* User put/send requests */
(brace
l_int|224
comma
l_int|32
)brace
comma
multiline_comment|/* Remote read replies */
(brace
l_int|128
comma
l_int|64
)brace
comma
multiline_comment|/* Get replies */
)brace
suffix:semicolon
DECL|macro|NR_RBUFS
mdefine_line|#define NR_RBUFS MSC_NR_RBUFS
r_static
r_struct
(brace
DECL|member|rbmbwp
r_int
id|rbmbwp
suffix:semicolon
DECL|member|rbmmode
r_int
id|rbmmode
suffix:semicolon
DECL|member|rbmrp
r_int
id|rbmrp
suffix:semicolon
DECL|variable|ringbufs
)brace
id|ringbufs
(braket
id|MSC_NR_RBUFS
)braket
op_assign
(brace
(brace
id|MSC_RBMBWP0
comma
id|MSC_RBMMODE0
comma
id|MSC_RBMRP0
)brace
comma
(brace
id|MSC_RBMBWP1
comma
id|MSC_RBMMODE1
comma
id|MSC_RBMRP1
)brace
comma
(brace
id|MSC_RBMBWP2
comma
id|MSC_RBMMODE2
comma
id|MSC_RBMRP2
)brace
comma
)brace
suffix:semicolon
DECL|macro|CTX_MASK
mdefine_line|#define CTX_MASK&t;0xfff
DECL|macro|NULL_CONTEXT
mdefine_line|#define NULL_CONTEXT&t;CTX_MASK
DECL|macro|QOF_ORDER
mdefine_line|#define QOF_ORDER       3&t;/* 32kB queue overflow buffer */
DECL|macro|QOF_SIZE
mdefine_line|#define QOF_SIZE&t;((1&lt;&lt;QOF_ORDER)*PAGE_SIZE)
DECL|macro|QOF_ELT_SIZE
mdefine_line|#define QOF_ELT_SIZE&t;8&t;/* size of each queue element */
DECL|macro|QOF_REDZONE_SZ
mdefine_line|#define QOF_REDZONE_SZ&t;8192&t;/* 8kB redzone, imposed by hardware */
DECL|macro|QOF_NELT
mdefine_line|#define QOF_NELT&t;(QOF_SIZE / QOF_ELT_SIZE)
DECL|macro|QOF_RED_NELT
mdefine_line|#define QOF_RED_NELT&t;(QOF_REDZONE_SZ / QOF_ELT_SIZE)
DECL|macro|QOF_GREEN_NELT
mdefine_line|#define QOF_GREEN_NELT&t;((QOF_SIZE - QOF_REDZONE_SZ) / QOF_ELT_SIZE)
DECL|macro|MAKE_QBMPTR
mdefine_line|#define MAKE_QBMPTR(qof, size) &bslash;&n;&t;(MKFIELD((qof) &gt;&gt; 19, MSC_QBMP_BP) &bslash;&n;&t; + MKFIELD((qof) &gt;&gt; 3, MSC_QBMP_WP) &bslash;&n;&t; + MKFIELD(((qof) + (size) - 1) &gt;&gt; 13, MSC_QBMP_LIM))
DECL|macro|QBM_UPDATE_WP
mdefine_line|#define QBM_UPDATE_WP(wp)&t;&bslash;&n;&t;MSC_OUT(MSC_QBMPTR, INSFIELD(MSC_IN(MSC_QBMPTR), (unsigned)(wp) &gt;&gt; 3, &bslash;&n;&t;&t;&t;&t;     MSC_QBMP_WP))
multiline_comment|/* Send queue overflow buffer structure */
DECL|struct|qof_elt
r_struct
id|qof_elt
(brace
DECL|member|info
r_int
id|info
suffix:semicolon
DECL|member|data
r_int
id|data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Fields in qof_elt.info */
DECL|macro|QOF_QUEUE_SH
mdefine_line|#define QOF_QUEUE_SH&t;24&t;&t;/* queue bits start at bit 24 */
DECL|macro|QOF_QUEUE_M
mdefine_line|#define QOF_QUEUE_M&t;0x1f&t;&t;/* 5 bits wide */
DECL|macro|QOF_ENDBIT
mdefine_line|#define QOF_ENDBIT&t;1&t;&t;/* end bit in bit 0 */
DECL|variable|qof_base
r_static
r_struct
id|qof_elt
op_star
id|qof_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* start of overflow buffer */
DECL|variable|qof_phys
r_static
r_int
r_int
id|qof_phys
suffix:semicolon
multiline_comment|/* physical start adrs of overflow buffer */
DECL|variable|qof_rp
r_static
r_struct
id|qof_elt
op_star
id|qof_rp
suffix:semicolon
multiline_comment|/* read pointer for refills */
DECL|variable|qof_new
r_static
r_struct
id|qof_elt
op_star
id|qof_new
suffix:semicolon
multiline_comment|/* first element we haven&squot;t yet looked at */
DECL|variable|qof_present
r_static
r_int
id|qof_present
(braket
id|NSENDQUEUES
)braket
suffix:semicolon
multiline_comment|/* # elts for each q in [qof_rp,qof_new) */
multiline_comment|/* this is used to flag when the msc is blocked, so we can&squot;t send &n;   messages on it without the possability of deadlock */
DECL|variable|msc_blocked
r_int
id|msc_blocked
op_assign
l_int|0
suffix:semicolon
DECL|variable|block_parallel_tasks
r_int
id|block_parallel_tasks
op_assign
l_int|0
suffix:semicolon
DECL|variable|qbm_full_counter
r_static
r_int
id|qbm_full_counter
op_assign
l_int|0
suffix:semicolon
DECL|macro|INTR_LIMIT
mdefine_line|#define INTR_LIMIT 10000
DECL|variable|intr_counter
r_static
r_int
id|intr_counter
op_assign
l_int|0
suffix:semicolon
DECL|variable|intr_mask
r_static
r_int
id|intr_mask
suffix:semicolon
DECL|macro|DUMMY_RINGBUF_ORDER
mdefine_line|#define DUMMY_RINGBUF_ORDER 5
DECL|macro|DUMMY_RINGBUF_SIZE
mdefine_line|#define DUMMY_RINGBUF_SIZE ((1&lt;&lt;DUMMY_RINGBUF_ORDER)*PAGE_SIZE)
multiline_comment|/* &n; * The system ring buffer, used for inter-kernel comms &n; */
DECL|variable|system_ringbuf
r_struct
id|ringbuf_struct
id|system_ringbuf
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|SYSTEM_RINGBUF_ORDER
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|dummy_ringbuf
r_struct
id|ringbuf_struct
id|dummy_ringbuf
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|DUMMY_RINGBUF_ORDER
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|system_read_ptr
r_int
id|system_read_ptr
op_assign
(paren
id|SYSTEM_RINGBUF_SIZE
op_rshift
l_int|5
)paren
op_minus
l_int|1
suffix:semicolon
DECL|variable|dummy_read_ptr
r_int
id|dummy_read_ptr
op_assign
(paren
id|DUMMY_RINGBUF_SIZE
op_rshift
l_int|5
)paren
op_minus
l_int|1
suffix:semicolon
DECL|macro|SQ_NEW_MODE
mdefine_line|#define SQ_NEW_MODE(mode) do { &bslash;&n;    MSC_OUT(MSC_SQCTRL, ((MSC_IN(MSC_SQCTRL) &amp; ~MSC_SQC_RMODE) &bslash;&n;&t;&t;&t; | MSC_SQC_RMODE_ ## mode)); &bslash;&n;    while ((MSC_IN(MSC_SQCTRL) &amp; MSC_SQC_MODE) != MSC_SQC_MODE_ ## mode) &bslash;&n;&t;/* hang */ ; &bslash;&n;} while (0)
multiline_comment|/* Repack the queue overflow buffer if &gt;= this many already-used entries */
DECL|macro|REPACK_THRESH
mdefine_line|#define REPACK_THRESH&t;64
r_static
r_void
id|refill_sq
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|repack_qof
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|shuffle_qof
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|async_callback
c_func
(paren
r_int
comma
r_int
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
DECL|function|mask_all_interrupts
r_static
r_void
id|mask_all_interrupts
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* disable all MSC+ interrupts */
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
op_or
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_SQFILL_SH
)paren
op_or
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_RBMISS_SH
)paren
op_or
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_RBFULL_SH
)paren
op_or
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_RMASF_SH
)paren
op_or
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_RMASE_SH
)paren
op_or
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_SMASF_SH
)paren
op_or
(paren
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_SMASE_SH
)paren
)paren
suffix:semicolon
)brace
DECL|function|valid_task
r_static
r_inline
r_int
id|valid_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
id|tsk
op_logical_and
op_logical_neg
(paren
(paren
id|tsk
)paren
op_member_access_from_pointer
id|flags
op_amp
id|PF_EXITING
)paren
op_logical_and
id|tsk-&gt;mm
op_logical_and
id|tsk-&gt;mm-&gt;context
op_ne
id|NO_CONTEXT
suffix:semicolon
)brace
DECL|function|apmmu_get_raw_ctable_ptr
r_static
r_inline
r_int
r_int
id|apmmu_get_raw_ctable_ptr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|retval
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lda [%1] %2, %0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|retval
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|APMMU_CTXTBL_PTR
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_M_MMUREGS
)paren
)paren
suffix:semicolon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
DECL|function|mc_tlb_map
r_static
r_void
id|mc_tlb_map
c_func
(paren
r_int
id|phys_page
comma
r_int
id|vpage
comma
r_int
id|context
)paren
(brace
r_int
r_int
r_int
op_star
id|tlb4k
suffix:semicolon
r_int
r_int
r_int
id|new_entry
suffix:semicolon
r_int
r_int
op_star
id|new_entryp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|new_entry
suffix:semicolon
id|tlb4k
op_assign
(paren
(paren
r_int
r_int
r_int
op_star
)paren
id|MC_MMU_TLB4K
)paren
op_plus
(paren
id|vpage
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|new_entryp
(braket
l_int|0
)braket
op_assign
(paren
id|phys_page
op_amp
op_complement
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
id|new_entryp
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|phys_page
op_amp
l_int|7
)paren
op_lshift
l_int|29
)paren
op_or
(paren
(paren
(paren
id|vpage
op_rshift
l_int|8
)paren
op_amp
l_int|0xFFF
)paren
op_lshift
l_int|17
)paren
op_or
(paren
id|context
op_lshift
l_int|5
)paren
op_or
l_int|0x13
suffix:semicolon
id|tlb4k
(braket
l_int|0
)braket
op_assign
id|new_entry
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;mc_tlb_map(%x,%x,%x) %x %x at %x&bslash;n&quot;
comma
id|phys_page
comma
id|vpage
comma
id|context
comma
id|new_entryp
(braket
l_int|0
)braket
comma
id|new_entryp
(braket
l_int|1
)braket
comma
id|tlb4k
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|mc_tlb_unmap
r_static
r_void
id|mc_tlb_unmap
c_func
(paren
r_int
id|vpage
)paren
(brace
r_int
r_int
r_int
op_star
id|tlb4k
op_assign
(paren
r_int
r_int
r_int
op_star
)paren
id|MC_MMU_TLB4K
suffix:semicolon
id|tlb4k
op_assign
(paren
(paren
r_int
r_int
r_int
op_star
)paren
id|MC_MMU_TLB4K
)paren
op_plus
(paren
id|vpage
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|tlb4k
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|mc_tlb_init
r_void
id|mc_tlb_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
r_int
op_star
id|tlb256k
comma
op_star
id|tlb4k
suffix:semicolon
r_int
id|i
suffix:semicolon
id|tlb4k
op_assign
(paren
r_int
r_int
r_int
op_star
)paren
id|MC_MMU_TLB4K
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MC_MMU_TLB4K_SIZE
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
op_star
id|tlb4k
op_increment
op_assign
l_int|0
suffix:semicolon
id|tlb256k
op_assign
(paren
r_int
r_int
r_int
op_star
)paren
id|MC_MMU_TLB256K
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MC_MMU_TLB256K_SIZE
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
op_star
id|tlb256k
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ap_msc_init
r_void
id|ap_msc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|flags
comma
id|res
suffix:semicolon
r_int
r_int
id|qp
suffix:semicolon
id|bif_add_debug_key
c_func
(paren
l_char|&squot;M&squot;
comma
id|msc_status
comma
l_string|&quot;MSC+ status&quot;
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;MSC+ version %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_VERSION
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MC+  version %x&bslash;n&quot;
comma
id|MC_IN
c_func
(paren
id|MC_VERSION
)paren
)paren
suffix:semicolon
macro_line|#endif
id|mc_tlb_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set the MC&squot;s copy of the context table pointer */
id|MC_OUT
c_func
(paren
id|MC_CTP
comma
id|apmmu_get_raw_ctable_ptr
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the send queue pointers */
id|qp
op_assign
id|MSC_SQPTR0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
id|MSC_OUT
c_func
(paren
id|qp
comma
(paren
(paren
id|send_queues
(braket
id|i
)braket
dot
id|size
op_eq
l_int|64
ques
c_cond
id|MSC_SQP_MODE
suffix:colon
l_int|0
)paren
op_plus
(paren
(paren
id|send_queues
(braket
id|i
)braket
dot
id|base
op_rshift
l_int|5
)paren
op_lshift
id|MSC_SQP_BP_SH
)paren
)paren
)paren
suffix:semicolon
id|qp
op_add_assign
(paren
id|MSC_SQPTR1
op_minus
id|MSC_SQPTR0
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the send queue RAM */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
op_increment
id|i
)paren
id|MSC_OUT
c_func
(paren
id|MSC_SQRAM
op_plus
id|i
op_star
l_int|8
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qof_base
)paren
(brace
id|qof_base
op_assign
(paren
r_struct
id|qof_elt
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|QOF_ORDER
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MAP_NR
c_func
(paren
id|qof_base
)paren
suffix:semicolon
id|i
op_le
id|MAP_NR
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|qof_base
)paren
op_plus
id|QOF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
op_increment
id|i
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|qof_phys
op_assign
id|mmu_v2p
c_func
(paren
(paren
r_int
r_int
)paren
id|qof_base
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_QBMPTR
comma
id|MAKE_QBMPTR
c_func
(paren
(paren
r_int
r_int
)paren
id|qof_base
comma
id|QOF_SIZE
)paren
)paren
suffix:semicolon
id|qof_rp
op_assign
id|qof_base
suffix:semicolon
id|qof_new
op_assign
id|qof_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSENDQUEUES
suffix:semicolon
op_increment
id|i
)paren
id|qof_present
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|SQ_NEW_MODE
c_func
(paren
id|NORMAL
)paren
suffix:semicolon
multiline_comment|/* Set the send queue to normal mode */
multiline_comment|/* Register interrupt handler for MSC+ */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|request_irq
c_func
(paren
id|APMSC_IRQ
comma
id|msc_interrupt_11
comma
id|SA_INTERRUPT
comma
l_string|&quot;apmsc&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;couldn&squot;t register MSC interrupt 11: error=%d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
id|res
op_assign
id|request_irq
c_func
(paren
id|APMAS_IRQ
comma
id|msc_interrupt_9
comma
id|SA_INTERRUPT
comma
l_string|&quot;apmas&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;couldn&squot;t register MSC interrupt 9: error=%d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_MASCTRL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Enable all MSC+ interrupts (for now) */
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
op_or
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_SQFILL_SH
)paren
op_or
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_RBMISS_SH
)paren
op_or
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_RBFULL_SH
)paren
op_or
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_RMASF_SH
)paren
op_or
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_RMASE_SH
)paren
op_or
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_SMASF_SH
)paren
op_or
(paren
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_SMASE_SH
)paren
)paren
suffix:semicolon
multiline_comment|/* setup invalid contexts */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MSC_NR_RBUFS
suffix:semicolon
id|i
op_increment
)paren
id|MSC_OUT
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
comma
id|NULL_CONTEXT
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_SMASREG
comma
l_int|0
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_RMASREG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|system_ringbuf.ringbuf
)paren
(brace
id|system_ringbuf.ringbuf
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|SYSTEM_RINGBUF_ORDER
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MAP_NR
c_func
(paren
id|system_ringbuf.ringbuf
)paren
suffix:semicolon
id|i
op_le
id|MAP_NR
c_func
(paren
id|system_ringbuf.ringbuf
op_plus
id|SYSTEM_RINGBUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|flags
)paren
suffix:semicolon
id|system_ringbuf.write_ptr
op_assign
id|mmu_v2p
c_func
(paren
(paren
r_int
)paren
id|system_ringbuf.ringbuf
)paren
op_lshift
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dummy_ringbuf.ringbuf
)paren
(brace
id|dummy_ringbuf.ringbuf
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|DUMMY_RINGBUF_ORDER
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MAP_NR
c_func
(paren
id|dummy_ringbuf.ringbuf
)paren
suffix:semicolon
id|i
op_le
id|MAP_NR
c_func
(paren
id|dummy_ringbuf.ringbuf
op_plus
id|DUMMY_RINGBUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|flags
)paren
suffix:semicolon
id|dummy_ringbuf.write_ptr
op_assign
id|mmu_v2p
c_func
(paren
(paren
r_int
)paren
id|dummy_ringbuf.ringbuf
)paren
op_lshift
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|qbmfill_interrupt
r_static
r_inline
r_void
id|qbmfill_interrupt
c_func
(paren
r_void
)paren
(brace
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
suffix:semicolon
id|intr_mask
op_and_assign
op_complement
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
suffix:semicolon
id|SQ_NEW_MODE
c_func
(paren
id|THRU
)paren
suffix:semicolon
multiline_comment|/* set send queue ctrlr to through mode */
id|refill_sq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* refill the send queues */
id|SQ_NEW_MODE
c_func
(paren
id|NORMAL
)paren
suffix:semicolon
multiline_comment|/* set send queue ctrlr back to normal mode */
multiline_comment|/* dismiss the interrupt */
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_SQFILL_SH
)paren
suffix:semicolon
)brace
DECL|function|qbmful_interrupt
r_static
r_inline
r_void
id|qbmful_interrupt
c_func
(paren
r_void
)paren
(brace
r_int
id|nvalid
comma
id|ntot
comma
id|q
suffix:semicolon
id|qbm_full_counter
op_increment
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;qbm full interrupt&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SQ_NEW_MODE
c_func
(paren
id|THRU
)paren
suffix:semicolon
multiline_comment|/* set send queue ctrlr to through mode */
multiline_comment|/* stuff as much as we can into the send queue RAM */
id|refill_sq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* count how many valid words are left in the qof buffer */
id|nvalid
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
l_int|0
suffix:semicolon
id|q
OL
id|NSENDQUEUES
suffix:semicolon
op_increment
id|q
)paren
id|nvalid
op_add_assign
id|qof_present
(braket
id|q
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nvalid
op_ge
id|QOF_GREEN_NELT
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;send queue overflow buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
suffix:semicolon
id|intr_mask
op_or_assign
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
suffix:semicolon
id|resched_force
c_func
(paren
)paren
suffix:semicolon
id|block_parallel_tasks
op_assign
l_int|1
suffix:semicolon
id|mark_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
)brace
id|ntot
op_assign
id|qof_new
op_minus
id|qof_rp
suffix:semicolon
multiline_comment|/* total # words of qof buf used */
r_if
c_cond
(paren
id|ntot
op_minus
id|nvalid
op_ge
id|REPACK_THRESH
op_logical_or
id|ntot
op_ge
id|QOF_GREEN_NELT
op_logical_or
(paren
id|ntot
OG
id|nvalid
op_logical_and
id|nvalid
op_ge
id|QOF_GREEN_NELT
op_minus
id|REPACK_THRESH
)paren
)paren
(brace
id|repack_qof
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qof_new
op_minus
id|qof_rp
op_ne
id|nvalid
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MSC: qof_present wrong&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|nvalid
OG
l_int|0
)paren
(brace
id|shuffle_qof
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* N.B. if nvalid == 0, msc_refill_sq has already reset the QBM&squot;s WP */
id|SQ_NEW_MODE
c_func
(paren
id|NORMAL
)paren
suffix:semicolon
multiline_comment|/* dismiss the interrupt */
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
suffix:semicolon
)brace
DECL|function|msc_interrupt_11
r_static
r_void
id|msc_interrupt_11
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|intr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_counter
op_increment
op_eq
id|INTR_LIMIT
)paren
(brace
id|mask_all_interrupts
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;too many MSC interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|intr
op_assign
id|MSC_IN
c_func
(paren
id|MSC_INTR
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CID(%d) msc_interrupt_11: intr = %x&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
comma
id|intr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_RBMISS_SH
)paren
)paren
(brace
r_int
id|context
suffix:semicolon
id|context
op_assign
id|MSC_IN
c_func
(paren
id|MSC_RMASREG
)paren
op_rshift
l_int|20
suffix:semicolon
id|msc_set_ringbuf
c_func
(paren
id|context
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_RBMISS_SH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_RBFULL_SH
)paren
)paren
(brace
r_int
id|context
op_assign
id|MSC_IN
c_func
(paren
id|MSC_RMASREG
)paren
op_rshift
l_int|20
suffix:semicolon
id|msc_update_read_ptr
c_func
(paren
id|context
comma
l_int|1
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_RBFULL_SH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_SQFILL_SH
)paren
)paren
(brace
id|qbmfill_interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_QBMFUL_SH
)paren
)paren
(brace
id|qbmful_interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|msc_timer
r_void
id|msc_timer
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* unmask all the interrupts that are supposed to be unmasked */
id|intr_counter
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* assumes NSENDQUEUES == 5 */
DECL|variable|log2tbl
r_static
r_int
id|log2tbl
(braket
l_int|32
)braket
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
comma
op_minus
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|3
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|4
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|direct_queues
r_static
r_int
r_int
id|direct_queues
(braket
id|NSENDQUEUES
)braket
(braket
l_int|2
)braket
op_assign
(brace
(brace
id|MSC_SYSTEM_DIRECT
comma
id|MSC_SYSTEM_DIRECT_END
)brace
comma
(brace
id|MSC_REMOTE_DIRECT
comma
id|MSC_REMOTE_DIRECT_END
)brace
comma
(brace
id|MSC_USER_DIRECT
comma
id|MSC_USER_DIRECT_END
)brace
comma
(brace
id|MSC_REMREPLY_DIRECT
comma
id|MSC_REMREPLY_DIRECT_END
)brace
comma
(brace
id|MSC_REPLY_DIRECT
comma
id|MSC_REPLY_DIRECT_END
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Copy entries from the queue overflow buffer back to the send queue.&n; * This must be called with the send queue controller in THRU mode.&n; */
DECL|function|refill_sq
r_static
r_void
id|refill_sq
c_func
(paren
r_void
)paren
(brace
r_int
id|notfull
comma
id|use_old
suffix:semicolon
r_int
id|q
comma
id|kept_some
suffix:semicolon
r_int
id|sqp
comma
id|sqc
suffix:semicolon
r_struct
id|qof_elt
op_star
id|rp
comma
op_star
id|qof_wp
suffix:semicolon
r_int
id|freew
(braket
id|NSENDQUEUES
)braket
suffix:semicolon
multiline_comment|/* # free words in each queue */
multiline_comment|/* give parallel tasks another chance */
id|block_parallel_tasks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get the qbm&squot;s write pointer */
id|qof_wp
op_assign
id|qof_base
op_plus
(paren
id|EXTFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QBMPTR
)paren
comma
id|MSC_QBMP_WP
)paren
op_amp
(paren
(paren
id|QOF_SIZE
op_minus
l_int|1
)paren
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;refill_sq: rp=%p new=%p wp=%p pres=[&quot;
comma
id|qof_rp
comma
id|qof_new
comma
id|qof_wp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
l_int|0
suffix:semicolon
id|q
OL
id|NSENDQUEUES
suffix:semicolon
op_increment
id|q
)paren
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|qof_present
(braket
id|q
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* work out which send queues and aren&squot;t full */
id|notfull
op_assign
l_int|0
suffix:semicolon
id|use_old
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
l_int|0
suffix:semicolon
id|q
OL
id|NSENDQUEUES
suffix:semicolon
op_increment
id|q
)paren
(brace
id|sqp
op_assign
id|MSC_IN
c_func
(paren
id|MSC_SQPTR0
op_plus
id|q
op_star
l_int|8
)paren
suffix:semicolon
id|freew
(braket
id|q
)braket
op_assign
(paren
id|EXTFIELD
c_func
(paren
id|sqp
comma
id|MSC_SQP_RP
)paren
op_minus
id|EXTFIELD
c_func
(paren
id|sqp
comma
id|MSC_SQP_WP
)paren
op_minus
l_int|1
)paren
op_amp
(paren
(paren
id|sqp
op_amp
id|MSC_SQP_MODE
)paren
ques
c_cond
l_int|0x3f
suffix:colon
l_int|0x1f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|freew
(braket
id|q
)braket
OG
l_int|0
)paren
id|notfull
op_or_assign
l_int|1
op_lshift
(paren
id|q
op_plus
id|QOF_QUEUE_SH
)paren
suffix:semicolon
id|use_old
op_add_assign
(paren
id|freew
(braket
id|q
)braket
OL
id|qof_present
(braket
id|q
)braket
)paren
ques
c_cond
id|freew
(braket
id|q
)braket
suffix:colon
id|qof_present
(braket
id|q
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;     * If there are useful entries in the old part of the overflow&n;     * queue, process them.&n;     */
id|kept_some
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|rp
op_assign
id|qof_rp
suffix:semicolon
id|rp
template_param
l_int|0
suffix:semicolon
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|rp-&gt;info
op_amp
id|notfull
)paren
(brace
multiline_comment|/* Here&squot;s one we can stuff back into the send queue */
id|q
op_assign
id|log2tbl
(braket
id|EXTFIELD
c_func
(paren
id|rp-&gt;info
comma
id|QOF_QUEUE
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|q
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad queue bits in qof info (%x) at %p&bslash;n&quot;
comma
id|rp-&gt;info
comma
id|rp
)paren
suffix:semicolon
multiline_comment|/* XXX just ignore this entry - should never happen */
id|rp-&gt;info
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|MSC_OUT
c_func
(paren
id|direct_queues
(braket
id|q
)braket
(braket
id|rp-&gt;info
op_amp
id|QOF_ENDBIT
)braket
comma
id|rp-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|freew
(braket
id|q
)braket
op_eq
l_int|0
)paren
id|notfull
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|q
op_plus
id|QOF_QUEUE_SH
)paren
)paren
suffix:semicolon
op_decrement
id|qof_present
(braket
id|q
)braket
suffix:semicolon
op_decrement
id|use_old
suffix:semicolon
id|rp-&gt;info
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|kept_some
op_logical_and
id|rp-&gt;info
op_ne
l_int|0
)paren
(brace
id|qof_rp
op_assign
id|rp
suffix:semicolon
id|kept_some
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Trim off any further already-used items. */
r_if
c_cond
(paren
op_logical_neg
id|kept_some
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|rp
OL
id|qof_new
suffix:semicolon
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|rp-&gt;info
)paren
(brace
id|qof_rp
op_assign
id|rp
suffix:semicolon
id|kept_some
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * Now process everything that&squot;s arrived since we last updated qof_new.&n;     */
r_for
c_loop
(paren
id|rp
op_assign
id|qof_new
suffix:semicolon
id|rp
OL
id|qof_wp
suffix:semicolon
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|rp-&gt;info
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|q
op_assign
id|log2tbl
(braket
id|EXTFIELD
c_func
(paren
id|rp-&gt;info
comma
id|QOF_QUEUE
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|q
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad queue bits in qof info (%x) at %p&bslash;n&quot;
comma
id|rp-&gt;info
comma
id|rp
)paren
suffix:semicolon
multiline_comment|/* XXX just ignore this entry - should never happen */
id|rp-&gt;info
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rp-&gt;info
op_amp
id|notfull
)paren
(brace
multiline_comment|/* Another one to stuff back into the send queue. */
id|MSC_OUT
c_func
(paren
id|direct_queues
(braket
id|q
)braket
(braket
id|rp-&gt;info
op_amp
id|QOF_ENDBIT
)braket
comma
id|rp-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|freew
(braket
id|q
)braket
op_eq
l_int|0
)paren
id|notfull
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|q
op_plus
id|QOF_QUEUE_SH
)paren
)paren
suffix:semicolon
id|rp-&gt;info
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_increment
id|qof_present
(braket
id|q
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kept_some
)paren
(brace
id|qof_rp
op_assign
id|rp
suffix:semicolon
id|kept_some
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Update state and the MSC queue-spill flags. */
r_if
c_cond
(paren
op_logical_neg
id|kept_some
)paren
(brace
multiline_comment|/* queue is empty; avoid unnecessary overflow interrupt later */
id|qof_rp
op_assign
id|qof_new
op_assign
id|qof_base
suffix:semicolon
id|QBM_UPDATE_WP
c_func
(paren
id|mmu_v2p
c_func
(paren
(paren
r_int
r_int
)paren
id|qof_base
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|qof_new
op_assign
id|qof_wp
suffix:semicolon
)brace
id|sqc
op_assign
id|MSC_IN
c_func
(paren
id|MSC_SQCTRL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
l_int|0
suffix:semicolon
id|q
OL
id|NSENDQUEUES
suffix:semicolon
op_increment
id|q
)paren
r_if
c_cond
(paren
id|qof_present
(braket
id|q
)braket
op_eq
l_int|0
op_logical_and
id|freew
(braket
id|q
)braket
OG
l_int|0
)paren
id|sqc
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|q
op_plus
id|MSC_SQC_SPLF_SH
)paren
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_SQCTRL
comma
id|sqc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the valid entries from their current position&n; * in the queue overflow buffer to the beginning.&n; * This must be called with the send queue controller in THRU or BLOCKING mode.&n; */
DECL|function|repack_qof
r_static
r_void
id|repack_qof
c_func
(paren
r_void
)paren
(brace
r_struct
id|qof_elt
op_star
id|rp
comma
op_star
id|wp
suffix:semicolon
id|wp
op_assign
id|qof_base
suffix:semicolon
r_for
c_loop
(paren
id|rp
op_assign
id|qof_rp
suffix:semicolon
id|rp
OL
id|qof_new
suffix:semicolon
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|rp-&gt;info
)paren
(brace
r_if
c_cond
(paren
id|rp
OG
id|wp
)paren
op_star
id|wp
op_assign
op_star
id|rp
suffix:semicolon
op_increment
id|wp
suffix:semicolon
)brace
)brace
id|qof_rp
op_assign
id|qof_base
suffix:semicolon
id|qof_new
op_assign
id|wp
suffix:semicolon
id|QBM_UPDATE_WP
c_func
(paren
id|wp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy all entries from their current position&n; * in the queue overflow buffer to the beginning.&n; * This must be called with the send queue controller in THRU or BLOCKING mode.&n; */
DECL|function|shuffle_qof
r_static
r_void
id|shuffle_qof
c_func
(paren
r_void
)paren
(brace
r_int
id|n
suffix:semicolon
id|n
op_assign
id|qof_new
op_minus
id|qof_rp
suffix:semicolon
id|memmove
c_func
(paren
id|qof_base
comma
id|qof_rp
comma
id|n
op_star
r_sizeof
(paren
r_struct
id|qof_elt
)paren
)paren
suffix:semicolon
id|qof_rp
op_assign
id|qof_base
suffix:semicolon
id|qof_new
op_assign
id|qof_base
op_plus
id|n
suffix:semicolon
id|QBM_UPDATE_WP
c_func
(paren
id|qof_new
)paren
suffix:semicolon
)brace
DECL|function|handle_signal
r_static
r_inline
r_void
id|handle_signal
c_func
(paren
r_int
id|context
comma
r_int
id|vaddr
)paren
(brace
r_int
id|signum
op_assign
(paren
id|vaddr
op_minus
id|MSC_REM_SIGNAL
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_int
id|taskid
op_assign
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MPP_IS_PAR_TASK
c_func
(paren
id|taskid
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|taskid
)braket
)paren
)paren
(brace
id|send_sig
c_func
(paren
id|signum
comma
id|task
(braket
id|taskid
)braket
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CID(%d) sent signal %d to task %d&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
comma
id|signum
comma
id|taskid
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * fail a msc write operation. We use Pauls dirty tlb trick to avoide&n; * the msc hardware bugs &n; */
DECL|function|fail_write
r_static
r_void
id|fail_write
c_func
(paren
r_int
id|context
comma
r_int
id|intr
comma
r_int
id|vaddr
)paren
(brace
r_int
id|tsk
op_assign
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
suffix:semicolon
r_int
id|vpage
op_assign
id|vaddr
op_rshift
l_int|12
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;fail write tsk=%d intr=%x vaddr=%x RMASREG=%x errproc=%x&bslash;n&quot;
comma
id|tsk
comma
id|intr
comma
id|vaddr
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASREG
)paren
comma
id|MSC_IN
c_func
(paren
id|MSC_RHDERRPROC
)paren
)paren
suffix:semicolon
macro_line|#endif
id|mc_tlb_map
c_func
(paren
l_int|0x800000
op_or
(paren
id|mmu_v2p
c_func
(paren
(paren
r_int
)paren
id|dummy_ringbuf.ringbuf
)paren
op_rshift
l_int|12
)paren
comma
id|vpage
comma
id|context
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_MASCTRL
comma
id|MSC_IN
c_func
(paren
id|MSC_MASCTRL
)paren
op_amp
op_complement
id|MSC_MASC_RFEXIT
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|intr
)paren
suffix:semicolon
id|mc_tlb_unmap
c_func
(paren
id|vpage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|tsk
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
id|vaddr
op_minus
id|MSC_REM_SIGNAL
OL
id|_NSIG
op_star
id|PAGE_SIZE
)paren
(brace
id|handle_signal
c_func
(paren
id|context
comma
id|vaddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|tss.sig_address
op_assign
id|vaddr
suffix:semicolon
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|tss.sig_desc
op_assign
id|SUBSIG_NOMAPPING
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|task
(braket
id|tsk
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * fail a msc read operation using the tlb trick */
DECL|function|fail_read
r_static
r_void
id|fail_read
c_func
(paren
r_int
id|context
comma
r_int
id|intr
comma
r_int
id|vaddr
)paren
(brace
r_int
id|tsk
op_assign
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;fail read tsk=%d intr=%x&bslash;n&quot;
comma
id|tsk
comma
id|intr
)paren
suffix:semicolon
macro_line|#endif
id|mc_tlb_map
c_func
(paren
l_int|0x800000
op_or
(paren
id|mmu_v2p
c_func
(paren
(paren
r_int
)paren
id|dummy_ringbuf.ringbuf
)paren
op_rshift
l_int|12
)paren
comma
id|vaddr
op_rshift
l_int|12
comma
id|context
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_MASCTRL
comma
id|MSC_IN
c_func
(paren
id|MSC_MASCTRL
)paren
op_amp
op_complement
id|MSC_MASC_SFEXIT
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|intr
)paren
suffix:semicolon
id|mc_tlb_unmap
c_func
(paren
id|vaddr
op_rshift
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|tsk
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
id|vaddr
op_minus
id|MSC_REM_SIGNAL
OL
id|_NSIG
op_star
id|PAGE_SIZE
)paren
(brace
id|handle_signal
c_func
(paren
id|context
comma
id|vaddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|tss.sig_address
op_assign
id|vaddr
suffix:semicolon
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|tss.sig_desc
op_assign
id|SUBSIG_NOMAPPING
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|task
(braket
id|tsk
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|async_callback
r_static
r_void
id|async_callback
c_func
(paren
r_int
id|tsk
comma
r_int
r_int
id|vaddr
comma
r_int
id|write
comma
r_int
id|ret
)paren
(brace
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|msc_blocked
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
(brace
id|intr_mask
op_and_assign
op_complement
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_RMASF_SH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|fail_write
c_func
(paren
id|MPP_TASK_TO_CTX
c_func
(paren
id|tsk
)paren
comma
id|MSC_INTR_RMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_RMASF_SH
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|MSC_OUT
c_func
(paren
id|MSC_MASCTRL
comma
id|MSC_IN
c_func
(paren
id|MSC_MASCTRL
)paren
op_amp
op_complement
id|MSC_MASC_RFEXIT
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_RMASF_SH
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_RMASF_SH
)paren
suffix:semicolon
)brace
r_else
(brace
id|intr_mask
op_and_assign
op_complement
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_SMASF_SH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|fail_read
c_func
(paren
id|MPP_TASK_TO_CTX
c_func
(paren
id|tsk
)paren
comma
id|MSC_INTR_SMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_SMASF_SH
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|MSC_OUT
c_func
(paren
id|MSC_MASCTRL
comma
id|MSC_IN
c_func
(paren
id|MSC_MASCTRL
)paren
op_amp
op_complement
id|MSC_MASC_SFEXIT
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_SMASF_SH
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_MASK
op_lshift
id|MSC_INTR_SMASF_SH
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|msc_write_fault
r_static
r_inline
r_void
id|msc_write_fault
c_func
(paren
r_void
)paren
(brace
r_int
id|context
op_assign
id|MSC_IN
c_func
(paren
id|MSC_RMASREG
)paren
op_rshift
l_int|20
suffix:semicolon
r_int
id|vaddr
op_assign
id|MSC_IN
c_func
(paren
id|MSC_RMASTWP
)paren
op_lshift
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|context
op_eq
id|SYSTEM_CONTEXT
)paren
(brace
id|fail_write
c_func
(paren
id|context
comma
id|MSC_INTR_RMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
id|show_mapping_ctx
c_func
(paren
l_int|0
comma
id|context
comma
id|vaddr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ERROR: system write fault at %x&bslash;n&quot;
comma
id|vaddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vaddr
op_minus
id|MSC_REM_SIGNAL
OL
id|_NSIG
op_star
id|PAGE_SIZE
)paren
(brace
id|fail_write
c_func
(paren
id|context
comma
id|MSC_INTR_RMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
)paren
(brace
r_int
id|tsk
op_assign
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|valid_task
c_func
(paren
id|task
(braket
id|tsk
)braket
)paren
op_logical_and
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|ringbuf
)paren
(brace
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_RMASF_SH
)paren
suffix:semicolon
id|intr_mask
op_or_assign
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_RMASF_SH
)paren
suffix:semicolon
macro_line|#if DEBUG
id|show_mapping_ctx
c_func
(paren
l_int|0
comma
id|context
comma
id|vaddr
)paren
suffix:semicolon
macro_line|#endif
id|msc_blocked
op_increment
suffix:semicolon
id|async_fault
c_func
(paren
id|vaddr
comma
l_int|1
comma
id|tsk
comma
id|async_callback
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CID(%d) mas write fault context=%x vaddr=%x&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
comma
id|context
comma
id|vaddr
)paren
suffix:semicolon
macro_line|#endif
id|fail_write
c_func
(paren
id|context
comma
id|MSC_INTR_RMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
)brace
DECL|function|msc_read_fault
r_static
r_inline
r_void
id|msc_read_fault
c_func
(paren
r_void
)paren
(brace
r_int
id|context
op_assign
id|MSC_IN
c_func
(paren
id|MSC_SMASREG
)paren
op_rshift
l_int|20
suffix:semicolon
r_int
id|vaddr
op_assign
id|MSC_IN
c_func
(paren
id|MSC_SMASTWP
)paren
op_lshift
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|context
op_eq
id|SYSTEM_CONTEXT
)paren
(brace
id|fail_read
c_func
(paren
id|context
comma
id|MSC_INTR_SMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
id|show_mapping_ctx
c_func
(paren
l_int|0
comma
id|context
comma
id|vaddr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ERROR: system read fault at %x&bslash;n&quot;
comma
id|vaddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
)paren
(brace
r_int
id|tsk
op_assign
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vaddr
op_minus
id|MSC_REM_SIGNAL
OL
id|_NSIG
op_star
id|PAGE_SIZE
)paren
(brace
id|fail_read
c_func
(paren
id|context
comma
id|MSC_INTR_SMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|valid_task
c_func
(paren
id|task
(braket
id|tsk
)braket
)paren
op_logical_and
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|ringbuf
)paren
(brace
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_SET_INTR_MASK
op_lshift
id|MSC_INTR_SMASF_SH
)paren
suffix:semicolon
id|intr_mask
op_or_assign
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_SMASF_SH
)paren
suffix:semicolon
id|msc_blocked
op_increment
suffix:semicolon
id|async_fault
c_func
(paren
id|vaddr
comma
l_int|0
comma
id|tsk
comma
id|async_callback
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CID(%d) mas read fault context=%x vaddr=%x&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
comma
id|context
comma
id|vaddr
)paren
suffix:semicolon
macro_line|#endif
id|fail_read
c_func
(paren
id|context
comma
id|MSC_INTR_SMASF_SH
comma
id|vaddr
)paren
suffix:semicolon
)brace
DECL|function|msc_interrupt_9
r_static
r_void
id|msc_interrupt_9
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|intr
comma
id|cnt
comma
id|r
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_counter
op_increment
op_eq
id|INTR_LIMIT
)paren
(brace
id|mask_all_interrupts
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;too many MSC interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|intr
op_assign
id|MSC_IN
c_func
(paren
id|MSC_INTR
)paren
op_amp
op_complement
id|intr_mask
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CID(%d) msc_interrupt_9: intr = %x&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
comma
id|intr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_RMASF_SH
)paren
)paren
(brace
id|msc_write_fault
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_SMASF_SH
)paren
)paren
(brace
id|msc_read_fault
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_RMASE_SH
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;recv mas error interrupt (write)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;masctrl = %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_MASCTRL
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rmasadr = %x %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASADR
)paren
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASADR
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rmastwp = %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASTWP
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rmasreg = %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASREG
)paren
)paren
suffix:semicolon
id|r
op_assign
id|MSC_IN
c_func
(paren
id|MSC_RMASREG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
id|MSC_MASR_AVIO
)paren
op_logical_or
(paren
id|r
op_amp
id|MSC_MASR_CMD
)paren
op_ne
id|MSC_MASR_CMD_XFER
)paren
multiline_comment|/* throw away the rest of the incoming data */
id|MSC_OUT
c_func
(paren
id|MSC_RHDERRPROC
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear the interrupt */
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_RMASE_SH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr
op_amp
(paren
id|AP_INTR_REQ
op_lshift
id|MSC_INTR_SMASE_SH
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;send mas error interrupt (read)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;masctrl = %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_MASCTRL
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;smasadr = %x %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASADR
)paren
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASADR
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;smascnt = %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASCNT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;smastwp = %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASTWP
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;smasreg = %x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASREG
)paren
)paren
suffix:semicolon
multiline_comment|/* supply dummy data */
id|cnt
op_assign
id|MSC_IN
c_func
(paren
id|MSC_SMASCNT
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|MSC_IN
c_func
(paren
id|MSC_SMASREG
)paren
op_amp
id|MSC_MASR_CMD
)paren
(brace
r_case
id|MSC_MASR_CMD_XFER
suffix:colon
id|MSC_OUT
c_func
(paren
id|MSC_HDGERRPROC
comma
(paren
id|EXTFIELD
c_func
(paren
id|cnt
comma
id|MSC_SMCT_MCNT
)paren
op_plus
id|EXTFIELD
c_func
(paren
id|cnt
comma
id|MSC_SMCT_ICNT
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* case remote read: */
r_case
id|MSC_MASR_CMD_FOP
suffix:colon
r_case
id|MSC_MASR_CMD_CSI
suffix:colon
id|MSC_OUT
c_func
(paren
id|MSC_HDGERRPROC
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* clear interrupt */
id|MSC_OUT
c_func
(paren
id|MSC_INTR
comma
id|AP_CLR_INTR_REQ
op_lshift
id|MSC_INTR_SMASF_SH
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * remove access to a tasks ring buffer&n; */
DECL|function|msc_unset_ringbuf
r_void
id|msc_unset_ringbuf
c_func
(paren
r_int
id|i
)paren
(brace
r_int
id|ctx
op_assign
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
)paren
op_amp
id|CTX_MASK
suffix:semicolon
r_int
id|tsk
op_assign
id|MPP_CTX_TO_TASK
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_struct
id|ringbuf_struct
op_star
id|rbuf
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;msc_unset_ringbuf(%d) %x&bslash;n&quot;
comma
id|i
comma
id|ctx
)paren
suffix:semicolon
macro_line|#endif
id|MSC_OUT
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
comma
id|NULL_CONTEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
id|SYSTEM_CONTEXT
)paren
(brace
id|rbuf
op_assign
op_amp
id|system_ringbuf
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ctx
op_ne
id|NULL_CONTEXT
op_logical_and
id|MPP_IS_PAR_CTX
c_func
(paren
id|ctx
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|tsk
)braket
)paren
op_logical_and
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|ringbuf
)paren
(brace
id|rbuf
op_assign
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|ringbuf
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ctx
op_ne
id|NULL_CONTEXT
op_logical_and
id|MPP_IS_PAR_CTX
c_func
(paren
id|ctx
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|tsk
)braket
)paren
op_logical_and
id|task
(braket
id|tsk
)braket
op_member_access_from_pointer
id|aplib
)paren
(brace
id|rbuf
op_assign
op_amp
id|system_ringbuf
suffix:semicolon
)brace
r_else
(brace
id|rbuf
op_assign
op_amp
id|dummy_ringbuf
suffix:semicolon
)brace
id|rbuf-&gt;write_ptr
op_assign
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmbwp
)paren
suffix:semicolon
)brace
DECL|function|msc_update_read_ptr
r_static
r_void
id|msc_update_read_ptr
c_func
(paren
r_int
id|context
comma
r_int
id|overflow
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|new_read_ptr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_RBUFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
)paren
op_amp
id|CTX_MASK
)paren
op_eq
id|context
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NR_RBUFS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;didn&squot;t find context %d in msc_update_read_ptr()&bslash;n&quot;
comma
id|context
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|context
op_eq
id|SYSTEM_CONTEXT
)paren
(brace
id|tnet_check_completion
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|overflow
op_logical_and
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmrp
)paren
op_eq
id|system_read_ptr
)paren
id|printk
c_func
(paren
l_string|&quot;system ringbuffer overflow&bslash;n&quot;
)paren
suffix:semicolon
id|new_read_ptr
op_assign
id|system_read_ptr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
)paren
op_logical_and
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
op_member_access_from_pointer
id|ringbuf
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
suffix:semicolon
r_struct
id|_kernel_cap_shared
op_star
id|_kernel
suffix:semicolon
r_int
id|soft_read_ptr
suffix:semicolon
r_int
id|octx
suffix:semicolon
id|octx
op_assign
id|apmmu_get_context
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|octx
op_ne
id|context
)paren
id|apmmu_set_context
c_func
(paren
id|context
)paren
suffix:semicolon
id|_kernel
op_assign
(paren
r_struct
id|_kernel_cap_shared
op_star
)paren
(paren
id|RBUF_VBASE
op_plus
id|RBUF_SHARED_PAGE_OFF
)paren
suffix:semicolon
id|soft_read_ptr
op_assign
id|_kernel-&gt;rbuf_read_ptr
suffix:semicolon
r_if
c_cond
(paren
id|octx
op_ne
id|context
)paren
id|apmmu_set_context
c_func
(paren
id|octx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|overflow
op_logical_and
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmrp
)paren
op_eq
id|soft_read_ptr
)paren
(brace
multiline_comment|/* send them a SIGLOST and wipe their ring buffer */
id|printk
c_func
(paren
l_string|&quot;ring buffer overflow for %s ctx=%x&bslash;n&quot;
comma
id|tsk-&gt;comm
comma
id|context
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGLOST
comma
id|tsk
comma
l_int|1
)paren
suffix:semicolon
id|soft_read_ptr
op_decrement
suffix:semicolon
)brace
id|new_read_ptr
op_assign
id|soft_read_ptr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
)paren
op_logical_and
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
op_member_access_from_pointer
id|aplib
)paren
(brace
id|tnet_check_completion
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|overflow
op_logical_and
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmrp
)paren
op_eq
id|system_read_ptr
)paren
id|printk
c_func
(paren
l_string|&quot;system ringbuffer overflow&bslash;n&quot;
)paren
suffix:semicolon
id|new_read_ptr
op_assign
id|system_read_ptr
suffix:semicolon
)brace
r_else
(brace
id|dummy_read_ptr
op_assign
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmrp
)paren
op_minus
l_int|1
suffix:semicolon
id|new_read_ptr
op_assign
id|dummy_read_ptr
op_minus
l_int|1
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|overflow
)paren
id|printk
c_func
(paren
l_string|&quot;reset dummy ring buffer for context %x&bslash;n&quot;
comma
id|context
)paren
suffix:semicolon
macro_line|#endif
)brace
id|MSC_OUT
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmrp
comma
id|new_read_ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * give a task one of the system ring buffers &n; * this is called on a context miss interrupt, so we can assume that&n; * the tasks context is not currently set in one of the ringbufs&n; */
DECL|function|msc_set_ringbuf
r_static
r_void
id|msc_set_ringbuf
c_func
(paren
r_int
id|context
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ctx
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_int
id|write_ptr
suffix:semicolon
r_static
r_int
id|next_ctx
op_assign
l_int|0
suffix:semicolon
r_struct
id|ringbuf_struct
op_star
id|rbuf
suffix:semicolon
r_if
c_cond
(paren
id|context
op_eq
id|SYSTEM_CONTEXT
)paren
(brace
id|rbuf
op_assign
op_amp
id|system_ringbuf
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
)paren
op_logical_and
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
op_member_access_from_pointer
id|ringbuf
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
suffix:semicolon
id|rbuf
op_assign
id|tsk-&gt;ringbuf
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MPP_IS_PAR_CTX
c_func
(paren
id|context
)paren
op_logical_and
id|valid_task
c_func
(paren
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
)paren
op_logical_and
id|task
(braket
id|MPP_CTX_TO_TASK
c_func
(paren
id|context
)paren
)braket
op_member_access_from_pointer
id|aplib
)paren
(brace
id|rbuf
op_assign
op_amp
id|system_ringbuf
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* use the dummy ring buffer */
id|rbuf
op_assign
op_amp
id|dummy_ringbuf
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_RBUFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ctx
op_assign
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
)paren
op_amp
id|CTX_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
id|NULL_CONTEXT
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NR_RBUFS
)paren
(brace
id|i
op_assign
id|next_ctx
suffix:semicolon
id|next_ctx
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|NR_RBUFS
suffix:semicolon
)brace
id|ctx
op_assign
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
)paren
op_amp
id|CTX_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_ne
id|NULL_CONTEXT
)paren
id|msc_unset_ringbuf
c_func
(paren
id|i
)paren
suffix:semicolon
id|write_ptr
op_assign
id|rbuf-&gt;write_ptr
suffix:semicolon
id|mode
op_assign
(paren
id|rbuf-&gt;order
op_minus
l_int|5
)paren
op_rshift
l_int|1
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
comma
id|context
op_or
(paren
id|mode
op_lshift
l_int|12
)paren
)paren
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmbwp
comma
id|write_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbuf
op_eq
op_amp
id|system_ringbuf
)paren
(brace
id|MSC_OUT
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmrp
comma
id|system_read_ptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|msc_update_read_ptr
c_func
(paren
id|context
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;CID(%d) mapped ringbuf for context %d in slot %d&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
comma
id|context
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * this is called when a task exits&n;*/
DECL|function|exit_msc
r_void
id|exit_msc
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MPP_IS_PAR_TASK
c_func
(paren
id|tsk-&gt;taskid
)paren
)paren
r_return
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;exit_msc(%d) ctx=%d&bslash;n&quot;
comma
id|tsk-&gt;taskid
comma
id|tsk-&gt;mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_RBUFS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ctx
op_assign
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
)paren
op_amp
id|CTX_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ctx
op_eq
id|MPP_TASK_TO_CTX
c_func
(paren
id|tsk-&gt;taskid
)paren
)paren
id|msc_unset_ringbuf
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|msc_switch_from_check
c_func
(paren
id|tsk
)paren
suffix:semicolon
multiline_comment|/* stop it receiving new-style messages */
id|tsk-&gt;aplib
op_assign
l_int|NULL
suffix:semicolon
id|exit_ringbuf
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
DECL|function|msc_sq_pause
r_static
r_void
id|msc_sq_pause
c_func
(paren
r_void
)paren
(brace
id|MSC_OUT
c_func
(paren
id|MSC_SQCTRL
comma
id|MSC_IN
c_func
(paren
id|MSC_SQCTRL
)paren
op_or
id|MSC_SQC_PAUSE
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|MSC_IN
c_func
(paren
id|MSC_SQCTRL
)paren
op_amp
id|MSC_SQC_STABLE
)paren
)paren
multiline_comment|/* wait for stable bit */
suffix:semicolon
)brace
DECL|function|msc_sq_resume
r_static
r_void
id|msc_sq_resume
c_func
(paren
r_void
)paren
(brace
id|MSC_OUT
c_func
(paren
id|MSC_SQCTRL
comma
id|MSC_IN
c_func
(paren
id|MSC_SQCTRL
)paren
op_amp
op_complement
id|MSC_SQC_PAUSE
)paren
suffix:semicolon
)brace
DECL|function|msc_switch_from_check
r_static
r_void
id|msc_switch_from_check
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|user_count
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_struct
id|ringbuf_struct
op_star
id|rbuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|octx
comma
id|ctx
suffix:semicolon
r_if
c_cond
(paren
id|valid_task
c_func
(paren
id|tsk
)paren
op_logical_and
id|tsk-&gt;ringbuf
)paren
id|rbuf
op_assign
id|tsk-&gt;ringbuf
suffix:semicolon
multiline_comment|/* it doesn&squot;t seem obvious why this field should contain count+1,&n;&t;   but it does */
id|user_count
op_assign
id|EXTFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
comma
id|MSC_QWDC_USRCNT
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* check if the user queue count is != 0 */
r_if
c_cond
(paren
id|user_count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rbuf
)paren
id|printk
c_func
(paren
l_string|&quot;switching from dead task&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;saving %d words MSC_QWORDCNT=%x&bslash;n&quot;
comma
id|user_count
comma
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* bugger - we have to do some messy work */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|MPP_TASK_TO_CTX
c_func
(paren
id|tsk-&gt;taskid
)paren
suffix:semicolon
id|octx
op_assign
id|apmmu_get_context
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|octx
op_ne
id|ctx
)paren
id|apmmu_set_context
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|msc_sq_pause
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* remember the expected length of the command - usually (always?) 8 */
r_if
c_cond
(paren
id|rbuf
)paren
id|rbuf-&gt;frag_len
op_assign
id|EXTFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
comma
id|MSC_QWDC_USRLEN
)paren
suffix:semicolon
multiline_comment|/* pull words from the overflow first */
r_if
c_cond
(paren
id|MSC_IN
c_func
(paren
id|MSC_SQCTRL
)paren
op_amp
id|MSC_SQC_USERF
)paren
(brace
multiline_comment|/* we have overflowed */
r_struct
id|qof_elt
op_star
id|qof_wp
op_assign
id|qof_base
op_plus
(paren
id|EXTFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QBMPTR
)paren
comma
id|MSC_QBMP_WP
)paren
op_amp
(paren
(paren
id|QOF_SIZE
op_minus
l_int|1
)paren
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|qof_wp
op_ne
id|qof_rp
op_logical_and
id|user_count
)paren
(brace
id|qof_wp
op_decrement
suffix:semicolon
multiline_comment|/* only grab elements in the user queue */
r_if
c_cond
(paren
id|qof_wp-&gt;info
op_logical_and
id|log2tbl
(braket
id|EXTFIELD
c_func
(paren
id|qof_wp-&gt;info
comma
id|QOF_QUEUE
)paren
)braket
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|qof_wp-&gt;info
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MSC: end bit set - yikes!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|qof_wp-&gt;info
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rbuf
)paren
(brace
id|rbuf-&gt;sq_fragment
(braket
op_decrement
id|user_count
)braket
op_assign
id|qof_wp-&gt;data
suffix:semicolon
id|rbuf-&gt;frag_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qof_wp
OL
id|qof_new
)paren
id|qof_present
(braket
l_int|2
)braket
op_decrement
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG
r_if
c_cond
(paren
id|rbuf
)paren
id|printk
c_func
(paren
l_string|&quot;pulled %d elements from overflow (%d left)&bslash;n&quot;
comma
id|rbuf-&gt;frag_count
comma
id|user_count
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* then pull words direct from the msc ram */
r_if
c_cond
(paren
id|user_count
)paren
(brace
r_int
id|wp
op_assign
id|EXTFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_SQPTR2
)paren
comma
id|MSC_SQP_WP
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|wp
op_sub_assign
id|user_count
suffix:semicolon
r_if
c_cond
(paren
id|wp
OL
l_int|0
)paren
id|wp
op_add_assign
id|send_queues
(braket
l_int|2
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|user_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|wp2
op_assign
(paren
id|wp
op_plus
id|i
)paren
op_mod
id|send_queues
(braket
l_int|2
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|rbuf
)paren
id|rbuf-&gt;sq_fragment
(braket
id|i
op_plus
id|rbuf-&gt;frag_count
)braket
op_assign
id|MSC_IN
c_func
(paren
id|MSC_SQRAM
op_plus
(paren
id|send_queues
(braket
l_int|2
)braket
dot
id|base
op_plus
id|wp2
)paren
op_star
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rbuf
)paren
id|rbuf-&gt;frag_count
op_add_assign
id|user_count
suffix:semicolon
id|MSC_OUT
c_func
(paren
id|MSC_SQPTR2
comma
id|INSFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_SQPTR2
)paren
comma
id|wp
comma
id|MSC_SQP_WP
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;saved %d words from msc ram&bslash;n&quot;
comma
id|rbuf-&gt;frag_count
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* reset the user count to 1 */
id|MSC_OUT
c_func
(paren
id|MSC_QWORDCNT
comma
id|INSFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
comma
l_int|1
comma
id|MSC_QWDC_USRCNT
)paren
)paren
suffix:semicolon
id|msc_sq_resume
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|octx
op_ne
id|ctx
)paren
id|apmmu_set_context
c_func
(paren
id|octx
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|msc_switch_to_check
r_static
r_void
id|msc_switch_to_check
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|octx
comma
id|ctx
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valid_task
c_func
(paren
id|tsk
)paren
op_logical_or
op_logical_neg
id|tsk-&gt;ringbuf
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ctx
op_assign
id|MPP_TASK_TO_CTX
c_func
(paren
id|tsk-&gt;taskid
)paren
suffix:semicolon
id|octx
op_assign
id|apmmu_get_context
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|octx
op_ne
id|ctx
)paren
id|apmmu_set_context
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* if the task we are switching to has no saved words then &n;&t;   we&squot;re finished */
r_if
c_cond
(paren
id|tsk-&gt;ringbuf-&gt;frag_count
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|octx
op_ne
id|ctx
)paren
id|apmmu_set_context
c_func
(paren
id|octx
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;frag fill MSC_QWORDCNT=%x frag_count=%d&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
comma
id|tsk-&gt;ringbuf-&gt;frag_count
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/* reset the user length */
id|MSC_OUT
c_func
(paren
id|MSC_QWORDCNT
comma
id|INSFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
comma
id|tsk-&gt;ringbuf-&gt;frag_len
comma
id|MSC_QWDC_USRLEN
)paren
)paren
suffix:semicolon
multiline_comment|/* push the words into the direct queue */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tsk-&gt;ringbuf-&gt;frag_count
suffix:semicolon
id|i
op_increment
)paren
id|MSC_OUT
c_func
(paren
id|MSC_USER_DIRECT
comma
id|tsk-&gt;ringbuf-&gt;sq_fragment
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* reset the user count */
id|MSC_OUT
c_func
(paren
id|MSC_QWORDCNT
comma
id|INSFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
comma
l_int|1
op_plus
id|tsk-&gt;ringbuf-&gt;frag_count
comma
id|MSC_QWDC_USRCNT
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;frag fill done MSC_QWORDCNT=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
)paren
suffix:semicolon
macro_line|#endif
id|tsk-&gt;ringbuf-&gt;frag_count
op_assign
l_int|0
suffix:semicolon
id|tsk-&gt;ringbuf-&gt;frag_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|octx
op_ne
id|ctx
)paren
id|apmmu_set_context
c_func
(paren
id|octx
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|msc_switch_check
r_void
id|msc_switch_check
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_static
r_int
id|last_task
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|last_task
op_eq
id|tsk-&gt;taskid
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|MPP_IS_PAR_TASK
c_func
(paren
id|last_task
)paren
)paren
id|msc_switch_from_check
c_func
(paren
id|task
(braket
id|last_task
)braket
)paren
suffix:semicolon
id|msc_switch_to_check
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|last_task
op_assign
id|tsk-&gt;taskid
suffix:semicolon
)brace
multiline_comment|/* we want to try to avoid task switching while there are partial commands&n;   in the send queues */
DECL|function|msc_switch_ok
r_int
id|msc_switch_ok
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|EXTFIELD
c_func
(paren
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
comma
id|MSC_QWDC_USRCNT
)paren
op_minus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * print out the state of the msc&n;*/
DECL|function|msc_status
r_static
r_void
id|msc_status
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_SQCTRL=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SQCTRL
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;MSC_SQPTR%d=%x&bslash;n&quot;
comma
id|i
comma
id|MSC_IN
c_func
(paren
id|MSC_SQPTR0
op_plus
l_int|8
op_star
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_OPTADR=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_OPTADR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_MASCTRL=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_MASCTRL
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_SMASADR=%x_%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASADR
)paren
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASADR
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_RMASADR=%x_%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASADR
)paren
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASADR
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_PID=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_PID
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_QWORDCNT=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_QWORDCNT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_INTR=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_INTR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_CIDRANGE=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_CIDRANGE
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_QBMPTR=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_QBMPTR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_SMASTWP=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASTWP
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_RMASTWP=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASTWP
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_SMASREG=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASREG
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_RMASREG=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_RMASREG
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_SMASCNT=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SMASCNT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_IRL=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_IRL
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSC_SIMMCHK=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|MSC_SIMMCHK
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RBMBWP%d=%x&bslash;n&quot;
comma
id|i
comma
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmbwp
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RBMMODE%d=%x&bslash;n&quot;
comma
id|i
comma
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmmode
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RBMRP%d=%x&bslash;n&quot;
comma
id|i
comma
id|MSC_IN
c_func
(paren
id|ringbufs
(braket
id|i
)braket
dot
id|rbmrp
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;DMA_GEN=%x&bslash;n&quot;
comma
id|MSC_IN
c_func
(paren
id|DMA_GEN
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;qbm_full_counter=%d&bslash;n&quot;
comma
id|qbm_full_counter
)paren
suffix:semicolon
)brace
eof
