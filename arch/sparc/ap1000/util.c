multiline_comment|/*&n;   * Copyright 1996 The Australian National University.&n;   * Copyright 1996 Fujitsu Laboratories Limited&n;   * &n;   * This software may be distributed under the terms of the Gnu&n;   * Public License version 2 or later&n;  */
multiline_comment|/* general utility functions for the AP1000 */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/ap1000/apservice.h&gt;
macro_line|#include &lt;asm/ap1000/apreg.h&gt;
macro_line|#include &lt;asm/asi.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mpp.h&gt;
DECL|macro|APLOG
mdefine_line|#define APLOG 0
DECL|variable|cap_init
r_struct
id|cap_init
id|cap_init
suffix:semicolon
multiline_comment|/* find what cell id we are running on */
DECL|function|mpp_cid
r_int
id|mpp_cid
c_func
(paren
r_void
)paren
(brace
r_return
id|BIF_IN
c_func
(paren
id|BIF_CIDR1
)paren
suffix:semicolon
)brace
multiline_comment|/* find how many cells there are */
DECL|function|mpp_num_cells
r_int
id|mpp_num_cells
c_func
(paren
r_void
)paren
(brace
r_return
id|cap_init.numcells
suffix:semicolon
)brace
multiline_comment|/* this can be used to ensure some data is readable before DMAing&n;   it. */
DECL|function|ap_verify_data
r_int
id|ap_verify_data
c_func
(paren
r_char
op_star
id|d
comma
r_int
id|len
)paren
(brace
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
id|res
op_add_assign
op_star
id|d
op_increment
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* How many BogoMIPS in the entire machine&n;Don&squot;t worry about float because when it gets this big, it&squot;s irrelevant */
DECL|function|mpp_agg_bogomips
r_int
id|mpp_agg_bogomips
c_func
(paren
r_void
)paren
(brace
r_return
id|mpp_num_cells
c_func
(paren
)paren
op_star
id|loops_per_sec
op_div
l_int|500000
suffix:semicolon
multiline_comment|/* cheat in working it out */
)brace
multiline_comment|/* Puts multiprocessor configuration info into a buffer */
DECL|function|get_mppinfo
r_int
id|get_mppinfo
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Machine Type:&bslash;t&bslash;t: %s&bslash;nNumber of Cells&bslash;t&bslash;t: %d&bslash;nAggregate BogoMIPS&bslash;t: %d&bslash;n&quot;
comma
l_string|&quot;Fujitsu AP1000+&quot;
comma
id|mpp_num_cells
c_func
(paren
)paren
comma
id|mpp_agg_bogomips
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#if APLOG
DECL|variable|do_logging
r_static
r_int
id|do_logging
op_assign
l_int|0
suffix:semicolon
DECL|function|ap_log
r_void
id|ap_log
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
DECL|macro|LOG_MAGIC
mdefine_line|#define LOG_MAGIC 0x8736526
r_static
r_char
op_star
id|logbase
suffix:semicolon
r_static
r_char
op_star
id|logptr
suffix:semicolon
r_static
r_int
id|logsize
op_assign
l_int|1024
suffix:semicolon
r_int
id|l
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
op_logical_and
id|len
op_eq
op_minus
l_int|1
)paren
(brace
id|logbase
op_assign
id|kmalloc
c_func
(paren
id|logsize
op_plus
l_int|8
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|logbase
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;log init failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|logsize
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|logbase
(braket
l_int|8
op_plus
id|i
)braket
op_eq
l_char|&squot;|&squot;
)paren
id|logbase
(braket
l_int|8
op_plus
id|i
)braket
op_assign
l_char|&squot;_&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
(paren
r_int
op_star
)paren
id|logbase
)paren
op_eq
id|LOG_MAGIC
)paren
(brace
r_int
id|oldoffset
op_assign
op_star
(paren
r_int
op_star
)paren
(paren
id|logbase
op_plus
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;==%3d== START OLD LOG ==&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
)paren
suffix:semicolon
id|ap_write
c_func
(paren
l_int|1
comma
id|logbase
op_plus
l_int|8
op_plus
id|oldoffset
comma
id|logsize
op_minus
id|oldoffset
)paren
suffix:semicolon
id|ap_write
c_func
(paren
l_int|1
comma
id|logbase
op_plus
l_int|8
comma
id|oldoffset
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;==%3d== END OLD LOG ==&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
op_star
(paren
r_int
op_star
)paren
id|logbase
op_assign
id|LOG_MAGIC
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
id|logbase
op_plus
l_int|4
)paren
op_assign
l_int|0
suffix:semicolon
id|logbase
op_add_assign
l_int|8
suffix:semicolon
id|logptr
op_assign
id|logbase
suffix:semicolon
id|memset
c_func
(paren
id|logbase
comma
l_int|0
comma
id|logsize
)paren
suffix:semicolon
id|do_logging
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|do_logging
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
id|l
op_assign
id|logsize
op_minus
(paren
id|logptr
op_minus
id|logbase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
id|len
)paren
id|l
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|logptr
comma
id|buf
comma
id|l
)paren
suffix:semicolon
id|len
op_sub_assign
id|l
suffix:semicolon
id|logptr
op_add_assign
id|l
suffix:semicolon
r_if
c_cond
(paren
id|logptr
op_eq
id|logbase
op_plus
id|logsize
)paren
id|logptr
op_assign
id|logbase
suffix:semicolon
)brace
op_star
(paren
r_int
op_star
)paren
(paren
id|logbase
op_minus
l_int|4
)paren
op_assign
(paren
id|logptr
op_minus
id|logbase
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|ap_current_uid
r_int
id|ap_current_uid
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* set output only to a particular uid */
DECL|function|ap_set_user
r_void
id|ap_set_user
c_func
(paren
r_int
id|uid
)paren
(brace
id|ap_current_uid
op_assign
id|uid
suffix:semicolon
)brace
multiline_comment|/* write some data to a filedescriptor on the front end */
DECL|function|ap_write
r_int
id|ap_write
c_func
(paren
r_int
id|fd
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
r_struct
id|cap_request
id|req
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if APLOG
id|ap_log
c_func
(paren
id|buf
comma
id|nbytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
l_char|&squot;|&squot;
)paren
r_return
id|nbytes
suffix:semicolon
macro_line|#endif
id|req.cid
op_assign
id|mpp_cid
c_func
(paren
)paren
suffix:semicolon
id|req.type
op_assign
id|REQ_WRITE
suffix:semicolon
id|req.size
op_assign
id|nbytes
op_plus
r_sizeof
(paren
id|req
)paren
suffix:semicolon
id|req.data
(braket
l_int|0
)braket
op_assign
id|fd
suffix:semicolon
r_if
c_cond
(paren
id|ap_current_uid
op_eq
op_minus
l_int|1
op_logical_and
id|current
op_logical_and
id|current-&gt;pid
)paren
(brace
id|req.data
(braket
l_int|1
)braket
op_assign
id|current-&gt;uid
suffix:semicolon
)brace
r_else
(brace
id|req.data
(braket
l_int|1
)braket
op_assign
id|ap_current_uid
suffix:semicolon
)brace
id|req.header
op_assign
id|MAKE_HEADER
c_func
(paren
id|HOST_CID
)paren
suffix:semicolon
id|bif_queue
c_func
(paren
op_amp
id|req
comma
id|buf
comma
id|nbytes
)paren
suffix:semicolon
r_return
id|nbytes
suffix:semicolon
)brace
multiline_comment|/* write one character to stdout on the front end */
DECL|function|ap_putchar
r_int
id|ap_putchar
c_func
(paren
r_char
id|c
)paren
(brace
r_struct
id|cap_request
id|req
suffix:semicolon
macro_line|#if APLOG
id|ap_log
c_func
(paren
op_amp
id|c
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|req.cid
op_assign
id|mpp_cid
c_func
(paren
)paren
suffix:semicolon
id|req.type
op_assign
id|REQ_PUTCHAR
suffix:semicolon
id|req.size
op_assign
r_sizeof
(paren
id|req
)paren
suffix:semicolon
id|req.data
(braket
l_int|0
)braket
op_assign
id|c
suffix:semicolon
id|req.header
op_assign
id|MAKE_HEADER
c_func
(paren
id|HOST_CID
)paren
suffix:semicolon
id|bif_queue
c_func
(paren
op_amp
id|req
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* start the debugger (kgdb) on this cell */
DECL|function|ap_start_debugger
r_void
id|ap_start_debugger
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|set_debug_traps
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
id|set_debug_traps
c_func
(paren
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
id|breakpoint
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|ap_panic
r_void
id|ap_panic
c_func
(paren
r_char
op_star
id|msg
comma
r_int
id|a1
comma
r_int
id|a2
comma
r_int
id|a3
comma
r_int
id|a4
comma
r_int
id|a5
)paren
(brace
id|ap_led
c_func
(paren
l_int|0xAA
)paren
suffix:semicolon
id|printk
c_func
(paren
id|msg
comma
id|a1
comma
id|a2
comma
id|a3
comma
id|a4
comma
id|a5
)paren
suffix:semicolon
id|ap_start_debugger
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|ap_printk
r_void
id|ap_printk
c_func
(paren
r_char
op_star
id|msg
comma
r_int
id|a1
comma
r_int
id|a2
comma
r_int
id|a3
comma
r_int
id|a4
comma
r_int
id|a5
)paren
(brace
id|printk
c_func
(paren
id|msg
comma
id|a1
comma
id|a2
comma
id|a3
comma
id|a4
comma
id|a5
)paren
suffix:semicolon
multiline_comment|/* bif_queue_flush(); */
)brace
multiline_comment|/* get the command line arguments from the front end */
DECL|function|ap_getbootargs
r_void
id|ap_getbootargs
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_struct
id|cap_request
id|req
suffix:semicolon
r_int
id|size
suffix:semicolon
id|req.cid
op_assign
id|mpp_cid
c_func
(paren
)paren
suffix:semicolon
id|req.type
op_assign
id|REQ_GETBOOTARGS
suffix:semicolon
id|req.size
op_assign
r_sizeof
(paren
id|req
)paren
suffix:semicolon
id|req.header
op_assign
id|MAKE_HEADER
c_func
(paren
id|HOST_CID
)paren
suffix:semicolon
id|write_bif_polled
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|req
comma
r_sizeof
(paren
id|req
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ap_wait_request
c_func
(paren
op_amp
id|req
comma
id|REQ_GETBOOTARGS
)paren
suffix:semicolon
id|size
op_assign
id|req.size
op_minus
r_sizeof
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|buf
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
(brace
id|read_bif
c_func
(paren
id|buf
comma
id|size
)paren
suffix:semicolon
)brace
id|req.cid
op_assign
id|mpp_cid
c_func
(paren
)paren
suffix:semicolon
id|req.type
op_assign
id|REQ_INIT
suffix:semicolon
id|req.size
op_assign
r_sizeof
(paren
id|req
)paren
suffix:semicolon
id|req.header
op_assign
id|MAKE_HEADER
c_func
(paren
id|HOST_CID
)paren
suffix:semicolon
id|write_bif_polled
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|req
comma
r_sizeof
(paren
id|req
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ap_wait_request
c_func
(paren
op_amp
id|req
comma
id|REQ_INIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req.size
op_ne
r_sizeof
(paren
id|req
)paren
)paren
id|read_bif
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cap_init
comma
id|req.size
op_minus
r_sizeof
(paren
id|req
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req.size
op_minus
r_sizeof
(paren
id|req
)paren
)paren
op_ne
r_sizeof
(paren
id|cap_init
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;WARNING: Init structure is wrong size, recompile util.c&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cap_init.gdbcell
op_eq
id|mpp_cid
c_func
(paren
)paren
)paren
id|ap_start_debugger
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Got command line arguments from server&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* a useful utility for debugging pagetable setups */
DECL|function|show_mapping_ctx
r_void
id|show_mapping_ctx
c_func
(paren
r_int
op_star
id|ctp
comma
r_int
id|context
comma
r_int
id|Vm
)paren
(brace
r_int
op_star
id|pgtable
suffix:semicolon
r_int
id|entry
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|level
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctp
)paren
id|ctp
op_assign
(paren
r_int
op_star
)paren
id|mmu_p2v
c_func
(paren
id|srmmu_get_ctable_ptr
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ctp=0x%x &quot;
comma
(paren
r_int
)paren
id|ctp
)paren
suffix:semicolon
id|pgtable
op_assign
id|ctp
op_plus
id|context
suffix:semicolon
multiline_comment|/* get the virtual page */
id|Vm
op_assign
id|Vm
op_rshift
l_int|12
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Vm page 0x%x is &quot;
comma
id|Vm
)paren
suffix:semicolon
id|entry
(braket
l_int|0
)braket
op_assign
id|Vm
op_rshift
l_int|12
suffix:semicolon
id|entry
(braket
l_int|1
)braket
op_assign
(paren
id|Vm
op_rshift
l_int|6
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|entry
(braket
l_int|2
)braket
op_assign
id|Vm
op_amp
l_int|0x3f
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#if 1
id|printk
c_func
(paren
l_string|&quot;(%08x) &quot;
comma
id|pgtable
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|pgtable
(braket
l_int|0
)braket
op_amp
l_int|3
)paren
op_eq
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mapped at level %d to 0x%x&bslash;n&quot;
comma
id|level
comma
id|pgtable
(braket
l_int|0
)braket
op_rshift
l_int|8
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pgtable
(braket
l_int|0
)braket
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unmapped at level %d&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pgtable
(braket
l_int|0
)braket
op_amp
l_int|3
)paren
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;invalid at level %d&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pgtable
(braket
l_int|0
)braket
op_amp
l_int|3
)paren
op_eq
l_int|1
)paren
(brace
id|pgtable
op_assign
(paren
r_int
op_star
)paren
(paren
(paren
(paren
id|pgtable
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_lshift
l_int|6
)paren
op_or
l_int|0xf0000000
)paren
suffix:semicolon
id|pgtable
op_add_assign
id|entry
(braket
id|level
)braket
suffix:semicolon
id|level
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|variable|current_led
r_static
r_int
r_char
id|current_led
op_assign
l_int|0
suffix:semicolon
DECL|function|ap_led
r_void
id|ap_led
c_func
(paren
r_int
r_char
id|d
)paren
(brace
r_int
id|paddr
op_assign
l_int|0x1000
suffix:semicolon
r_int
id|word
op_assign
l_int|0xff
op_amp
op_complement
id|d
suffix:semicolon
id|current_led
op_assign
id|d
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;sta %0, [%1] %2&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|word
)paren
comma
l_string|&quot;r&quot;
(paren
id|paddr
)paren
comma
l_string|&quot;i&quot;
(paren
l_int|0x2c
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|ap_xor_led
r_void
id|ap_xor_led
c_func
(paren
r_int
r_char
id|d
)paren
(brace
id|ap_led
c_func
(paren
id|current_led
op_xor
id|d
)paren
suffix:semicolon
)brace
DECL|function|ap_set_led
r_void
id|ap_set_led
c_func
(paren
r_int
r_char
id|d
)paren
(brace
id|ap_led
c_func
(paren
id|current_led
op_or
id|d
)paren
suffix:semicolon
)brace
DECL|function|ap_unset_led
r_void
id|ap_unset_led
c_func
(paren
r_int
r_char
id|d
)paren
(brace
id|ap_led
c_func
(paren
id|current_led
op_amp
op_complement
id|d
)paren
suffix:semicolon
)brace
DECL|function|kbd_put_char
r_void
id|kbd_put_char
c_func
(paren
r_char
id|c
)paren
(brace
id|ap_putchar
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|ap_enter_irq
r_void
id|ap_enter_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
r_char
id|v
op_assign
id|current_led
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|2
suffix:colon
id|v
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|v
op_or_assign
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|v
op_or_assign
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|v
op_or_assign
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|v
op_or_assign
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|v
op_or_assign
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|v
op_or_assign
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ap_led
c_func
(paren
id|v
)paren
suffix:semicolon
)brace
DECL|function|ap_exit_irq
r_void
id|ap_exit_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
r_char
id|v
op_assign
id|current_led
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|2
suffix:colon
id|v
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|v
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|v
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|v
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|v
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|v
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|v
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ap_led
c_func
(paren
id|v
)paren
suffix:semicolon
)brace
DECL|variable|timer_wait
r_static
r_struct
id|wait_queue
op_star
id|timer_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|function|wait_callback
r_static
r_void
id|wait_callback
c_func
(paren
r_int
r_int
id|_ignored
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|timer_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* wait till x == *p */
DECL|function|wait_on_int
r_int
id|wait_on_int
c_func
(paren
r_volatile
r_int
op_star
id|p
comma
r_int
id|x
comma
r_int
id|interval
)paren
(brace
r_struct
id|timer_list
op_star
id|timer
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|timer
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer
)paren
id|panic
c_func
(paren
l_string|&quot;out of memory in wait_on_int()&bslash;n&quot;
)paren
suffix:semicolon
id|timer-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|timer-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|timer-&gt;data
op_assign
l_int|0
suffix:semicolon
id|timer-&gt;function
op_assign
id|wait_callback
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_ne
id|x
)paren
(brace
id|timer-&gt;expires
op_assign
id|jiffies
op_plus
id|interval
suffix:semicolon
id|add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|timer_wait
)paren
suffix:semicolon
id|del_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|kfree_s
c_func
(paren
id|timer
comma
r_sizeof
(paren
op_star
id|timer
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* an ugly hack to get nfs booting from a central cell to work */
DECL|function|ap_nfs_hook
r_void
id|ap_nfs_hook
c_func
(paren
r_int
r_int
id|server
)paren
(brace
r_int
id|cid
op_assign
id|server
op_minus
id|cap_init.baseIP
suffix:semicolon
r_if
c_cond
(paren
id|cid
OL
id|cap_init.bootcid
op_plus
id|cap_init.numcells
op_logical_and
id|cid
op_ne
id|mpp_cid
c_func
(paren
)paren
)paren
(brace
r_int
id|end
op_assign
id|jiffies
op_plus
l_int|20
op_star
id|HZ
suffix:semicolon
multiline_comment|/* we are booting from another cell */
id|printk
c_func
(paren
l_string|&quot;waiting for the master cell&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|end
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;continuing&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* convert a IP address to a cell id */
DECL|function|ap_ip_to_cid
r_int
id|ap_ip_to_cid
c_func
(paren
id|u_long
id|ip
)paren
(brace
r_int
id|cid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip
op_amp
id|cap_init.netmask
)paren
op_ne
(paren
id|cap_init.baseIP
op_amp
id|cap_init.netmask
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip
op_amp
op_complement
id|cap_init.netmask
)paren
op_eq
id|AP_ALIAS_IP
)paren
id|cid
op_assign
id|cap_init.bootcid
suffix:semicolon
r_else
id|cid
op_assign
id|ip
op_minus
id|cap_init.baseIP
suffix:semicolon
r_if
c_cond
(paren
id|cid
op_ge
id|cap_init.bootcid
op_plus
id|cap_init.numcells
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|cid
suffix:semicolon
)brace
DECL|function|ap_reboot
r_void
id|ap_reboot
c_func
(paren
r_char
op_star
id|bootstr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cell(%d) - don&squot;t know how to reboot&bslash;n&quot;
comma
id|mpp_cid
c_func
(paren
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|dumb_memset
r_void
id|dumb_memset
c_func
(paren
r_char
op_star
id|buf
comma
r_char
id|val
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
op_star
id|buf
op_increment
op_assign
id|val
suffix:semicolon
)brace
DECL|function|ap_init_time
r_void
id|ap_init_time
c_func
(paren
r_struct
id|timeval
op_star
id|xtime
)paren
(brace
id|xtime-&gt;tv_sec
op_assign
id|cap_init.init_time
suffix:semicolon
id|xtime-&gt;tv_usec
op_assign
l_int|0
suffix:semicolon
)brace
eof
