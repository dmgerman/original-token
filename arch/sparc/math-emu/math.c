multiline_comment|/*&n; * arch/sparc/math-emu/math.c&n; *&n; * Copyright (C) 1998 Peter Maydell (pmaydell@chiark.greenend.org.uk)&n; * Copyright (C) 1997, 1999 Jakub Jelinek (jj@ultra.linux.cz)&n; * Copyright (C) 1999 David S. Miller (davem@redhat.com)&n; *&n; * This is a good place to start if you&squot;re trying to understand the&n; * emulation code, because it&squot;s pretty simple. What we do is&n; * essentially analyse the instruction to work out what the operation&n; * is and which registers are involved. We then execute the appropriate&n; * FXXXX function. [The floating point queue introduces a minor wrinkle;&n; * see below...]&n; * The fxxxxx.c files each emulate a single insn. They look relatively&n; * simple because the complexity is hidden away in an unholy tangle&n; * of preprocessor macros.&n; *&n; * The first layer of macros is single.h, double.h, quad.h. Generally&n; * these files define macros for working with floating point numbers&n; * of the three IEEE formats. FP_ADD_D(R,A,B) is for adding doubles,&n; * for instance. These macros are usually defined as calls to more&n; * generic macros (in this case _FP_ADD(D,2,R,X,Y) where the number&n; * of machine words required to store the given IEEE format is passed&n; * as a parameter. [double.h and co check the number of bits in a word&n; * and define FP_ADD_D &amp; co appropriately].&n; * The generic macros are defined in op-common.h. This is where all&n; * the grotty stuff like handling NaNs is coded. To handle the possible&n; * word sizes macros in op-common.h use macros like _FP_FRAC_SLL_##wc()&n; * where wc is the &squot;number of machine words&squot; parameter (here 2).&n; * These are defined in the third layer of macros: op-1.h, op-2.h&n; * and op-4.h. These handle operations on floating point numbers composed&n; * of 1,2 and 4 machine words respectively. [For example, on sparc64&n; * doubles are one machine word so macros in double.h eventually use&n; * constructs in op-1.h, but on sparc32 they use op-2.h definitions.]&n; * soft-fp.h is on the same level as op-common.h, and defines some&n; * macros which are independent of both word size and FP format.&n; * Finally, sfp-machine.h is the machine dependent part of the&n; * code: it defines the word size and what type a word is. It also&n; * defines how _FP_MUL_MEAT_t() maps to _FP_MUL_MEAT_n_* : op-n.h&n; * provide several possible flavours of multiply algorithm, most&n; * of which require that you supply some form of asm or C primitive to&n; * do the actual multiply. (such asm primitives should be defined&n; * in sfp-machine.h too). udivmodti4.c is the same sort of thing.&n; *&n; * There may be some errors here because I&squot;m working from a&n; * SPARC architecture manual V9, and what I really want is V8...&n; * Also, the insns which can generate exceptions seem to be a&n; * greater subset of the FPops than for V9 (for example, FCMPED&n; * has to be emulated on V8). So I think I&squot;m going to have&n; * to emulate them all just to be on the safe side...&n; *&n; * Emulation routines originate from soft-fp package, which is&n; * part of glibc and has appropriate copyrights in it (allegedly).&n; *&n; * NB: on sparc int == long == 4 bytes, long long == 8 bytes.&n; * Most bits of the kernel seem to go for long rather than int,&n; * so we follow that practice...&n; */
multiline_comment|/* TODO:&n; * fpsave() saves the FP queue but fpload() doesn&squot;t reload it.&n; * Therefore when we context switch or change FPU ownership&n; * we have to check to see if the queue had anything in it and&n; * emulate it if it did. This is going to be a pain.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;sfp-util.h&quot;
macro_line|#include &lt;math-emu/soft-fp.h&gt;
macro_line|#include &lt;math-emu/single.h&gt;
macro_line|#include &lt;math-emu/double.h&gt;
macro_line|#include &lt;math-emu/quad.h&gt;
DECL|macro|FLOATFUNC
mdefine_line|#define FLOATFUNC(x) extern int x(void *,void *,void *)
multiline_comment|/* The Vn labels indicate what version of the SPARC architecture gas thinks&n; * each insn is. This is from the binutils source :-&gt;&n; */
multiline_comment|/* quadword instructions */
DECL|macro|FSQRTQ
mdefine_line|#define FSQRTQ&t;0x02b&t;&t;/* v8 */
DECL|macro|FADDQ
mdefine_line|#define FADDQ&t;0x043&t;&t;/* v8 */
DECL|macro|FSUBQ
mdefine_line|#define FSUBQ&t;0x047&t;&t;/* v8 */
DECL|macro|FMULQ
mdefine_line|#define FMULQ&t;0x04b&t;&t;/* v8 */
DECL|macro|FDIVQ
mdefine_line|#define FDIVQ&t;0x04f&t;&t;/* v8 */
DECL|macro|FDMULQ
mdefine_line|#define FDMULQ&t;0x06e&t;&t;/* v8 */
DECL|macro|FQTOS
mdefine_line|#define FQTOS&t;0x0c7&t;&t;/* v8 */
DECL|macro|FQTOD
mdefine_line|#define FQTOD&t;0x0cb&t;&t;/* v8 */
DECL|macro|FITOQ
mdefine_line|#define FITOQ&t;0x0cc&t;&t;/* v8 */
DECL|macro|FSTOQ
mdefine_line|#define FSTOQ&t;0x0cd&t;&t;/* v8 */
DECL|macro|FDTOQ
mdefine_line|#define FDTOQ&t;0x0ce&t;&t;/* v8 */
DECL|macro|FQTOI
mdefine_line|#define FQTOI&t;0x0d3&t;&t;/* v8 */
DECL|macro|FCMPQ
mdefine_line|#define FCMPQ&t;0x053&t;&t;/* v8 */
DECL|macro|FCMPEQ
mdefine_line|#define FCMPEQ&t;0x057&t;&t;/* v8 */
multiline_comment|/* single/double instructions (subnormal): should all work */
DECL|macro|FSQRTS
mdefine_line|#define FSQRTS&t;0x029&t;&t;/* v7 */
DECL|macro|FSQRTD
mdefine_line|#define FSQRTD&t;0x02a&t;&t;/* v7 */
DECL|macro|FADDS
mdefine_line|#define FADDS&t;0x041&t;&t;/* v6 */
DECL|macro|FADDD
mdefine_line|#define FADDD&t;0x042&t;&t;/* v6 */
DECL|macro|FSUBS
mdefine_line|#define FSUBS&t;0x045&t;&t;/* v6 */
DECL|macro|FSUBD
mdefine_line|#define FSUBD&t;0x046&t;&t;/* v6 */
DECL|macro|FMULS
mdefine_line|#define FMULS&t;0x049&t;&t;/* v6 */
DECL|macro|FMULD
mdefine_line|#define FMULD&t;0x04a&t;&t;/* v6 */
DECL|macro|FDIVS
mdefine_line|#define FDIVS&t;0x04d&t;&t;/* v6 */
DECL|macro|FDIVD
mdefine_line|#define FDIVD&t;0x04e&t;&t;/* v6 */
DECL|macro|FSMULD
mdefine_line|#define FSMULD&t;0x069&t;&t;/* v6 */
DECL|macro|FDTOS
mdefine_line|#define FDTOS&t;0x0c6&t;&t;/* v6 */
DECL|macro|FSTOD
mdefine_line|#define FSTOD&t;0x0c9&t;&t;/* v6 */
DECL|macro|FSTOI
mdefine_line|#define FSTOI&t;0x0d1&t;&t;/* v6 */
DECL|macro|FDTOI
mdefine_line|#define FDTOI&t;0x0d2&t;&t;/* v6 */
DECL|macro|FABSS
mdefine_line|#define FABSS&t;0x009&t;&t;/* v6 */
DECL|macro|FCMPS
mdefine_line|#define FCMPS&t;0x051&t;&t;/* v6 */
DECL|macro|FCMPES
mdefine_line|#define FCMPES&t;0x055&t;&t;/* v6 */
DECL|macro|FCMPD
mdefine_line|#define FCMPD&t;0x052&t;&t;/* v6 */
DECL|macro|FCMPED
mdefine_line|#define FCMPED&t;0x056&t;&t;/* v6 */
DECL|macro|FMOVS
mdefine_line|#define FMOVS&t;0x001&t;&t;/* v6 */
DECL|macro|FNEGS
mdefine_line|#define FNEGS&t;0x005&t;&t;/* v6 */
DECL|macro|FITOS
mdefine_line|#define FITOS&t;0x0c4&t;&t;/* v6 */
DECL|macro|FITOD
mdefine_line|#define FITOD&t;0x0c8&t;&t;/* v6 */
DECL|macro|FSR_TEM_SHIFT
mdefine_line|#define FSR_TEM_SHIFT&t;23UL
DECL|macro|FSR_TEM_MASK
mdefine_line|#define FSR_TEM_MASK&t;(0x1fUL &lt;&lt; FSR_TEM_SHIFT)
DECL|macro|FSR_AEXC_SHIFT
mdefine_line|#define FSR_AEXC_SHIFT&t;5UL
DECL|macro|FSR_AEXC_MASK
mdefine_line|#define FSR_AEXC_MASK&t;(0x1fUL &lt;&lt; FSR_AEXC_SHIFT)
DECL|macro|FSR_CEXC_SHIFT
mdefine_line|#define FSR_CEXC_SHIFT&t;0UL
DECL|macro|FSR_CEXC_MASK
mdefine_line|#define FSR_CEXC_MASK&t;(0x1fUL &lt;&lt; FSR_CEXC_SHIFT)
r_static
r_int
id|do_one_mathemu
c_func
(paren
id|u32
id|insn
comma
r_int
r_int
op_star
id|fsr
comma
r_int
r_int
op_star
id|fregs
)paren
suffix:semicolon
multiline_comment|/* Unlike the Sparc64 version (which has a struct fpustate), we&n; * pass the taskstruct corresponding to the task which currently owns the&n; * FPU. This is partly because we don&squot;t have the fpustate struct and&n; * partly because the task owning the FPU isn&squot;t always current (as is&n; * the case for the Sparc64 port). This is probably SMP-related...&n; * This function returns 1 if all queued insns were emulated successfully.&n; * The test for unimplemented FPop in kernel mode has been moved into&n; * kernel/traps.c for simplicity.&n; */
DECL|function|do_mathemu
r_int
id|do_mathemu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|task_struct
op_star
id|fpt
)paren
(brace
multiline_comment|/* regs-&gt;pc isn&squot;t necessarily the PC at which the offending insn is sitting.&n;&t; * The FPU maintains a queue of FPops which cause traps.&n;&t; * When it hits an instruction that requires that the trapped op succeeded&n;&t; * (usually because it reads a reg. that the trapped op wrote) then it&n;&t; * causes this exception. We need to emulate all the insns on the queue&n;&t; * and then allow the op to proceed.&n;&t; * This code should also handle the case where the trap was precise,&n;&t; * in which case the queue length is zero and regs-&gt;pc points at the&n;&t; * single FPop to be emulated. (this case is untested, though :-&gt;)&n;&t; * You&squot;ll need this case if you want to be able to emulate all FPops&n;&t; * because the FPU either doesn&squot;t exist or has been software-disabled.&n;&t; * [The UltraSPARC makes FP a precise trap; this isn&squot;t as stupid as it&n;&t; * might sound because the Ultra does funky things with a superscalar&n;&t; * architecture.]&n;&t; */
multiline_comment|/* You wouldn&squot;t believe how often I typed &squot;ftp&squot; when I meant &squot;fpt&squot; :-&gt; */
r_int
id|i
suffix:semicolon
r_int
id|retcode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assume all succeed */
r_int
r_int
id|insn
suffix:semicolon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;In do_mathemu()... pc is %08lx&bslash;n&quot;
comma
id|regs-&gt;pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpqdepth is %ld&bslash;n&quot;
comma
id|fpt-&gt;thread.fpqdepth
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fpt-&gt;thread.fpqdepth
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%d: %08lx at %08lx&bslash;n&quot;
comma
id|i
comma
id|fpt-&gt;thread.fpqueue
(braket
id|i
)braket
dot
id|insn
comma
(paren
r_int
r_int
)paren
id|fpt-&gt;thread.fpqueue
(braket
id|i
)braket
dot
id|insn_addr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fpt-&gt;thread.fpqdepth
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no queue, guilty insn is at regs-&gt;pc */
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;precise trap at %08lx&bslash;n&quot;
comma
id|regs-&gt;pc
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|get_user
c_func
(paren
id|insn
comma
(paren
id|u32
op_star
)paren
id|regs-&gt;pc
)paren
)paren
(brace
id|retcode
op_assign
id|do_one_mathemu
c_func
(paren
id|insn
comma
op_amp
id|fpt-&gt;thread.fsr
comma
id|fpt-&gt;thread.float_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retcode
)paren
(brace
multiline_comment|/* in this case we need to fix up PC &amp; nPC */
id|regs-&gt;pc
op_assign
id|regs-&gt;npc
suffix:semicolon
id|regs-&gt;npc
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
r_return
id|retcode
suffix:semicolon
)brace
multiline_comment|/* Normal case: need to empty the queue... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fpt-&gt;thread.fpqdepth
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retcode
op_assign
id|do_one_mathemu
c_func
(paren
id|fpt-&gt;thread.fpqueue
(braket
id|i
)braket
dot
id|insn
comma
op_amp
(paren
id|fpt-&gt;thread.fsr
)paren
comma
id|fpt-&gt;thread.float_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
multiline_comment|/* insn failed, no point doing any more */
r_break
suffix:semicolon
)brace
multiline_comment|/* Now empty the queue and clear the queue_not_empty flag */
r_if
c_cond
(paren
id|retcode
)paren
(brace
id|fpt-&gt;thread.fsr
op_and_assign
op_complement
(paren
l_int|0x3000
op_or
id|FSR_CEXC_MASK
)paren
suffix:semicolon
)brace
r_else
id|fpt-&gt;thread.fsr
op_and_assign
op_complement
l_int|0x3000
suffix:semicolon
id|fpt-&gt;thread.fpqdepth
op_assign
l_int|0
suffix:semicolon
r_return
id|retcode
suffix:semicolon
)brace
multiline_comment|/* All routines returning an exception to raise should detect&n; * such exceptions _before_ rounding to be consistant with&n; * the behavior of the hardware in the implemented cases&n; * (and thus with the recommendations in the V9 architecture&n; * manual).&n; *&n; * We return 0 if a SIGFPE should be sent, 1 otherwise.&n; */
DECL|function|record_exception
r_static
r_inline
r_int
id|record_exception
c_func
(paren
r_int
r_int
op_star
id|pfsr
comma
r_int
id|eflag
)paren
(brace
r_int
r_int
id|fsr
op_assign
op_star
id|pfsr
suffix:semicolon
r_int
id|would_trap
suffix:semicolon
multiline_comment|/* Determine if this exception would have generated a trap. */
id|would_trap
op_assign
(paren
id|fsr
op_amp
(paren
(paren
r_int
)paren
id|eflag
op_lshift
id|FSR_TEM_SHIFT
)paren
)paren
op_ne
l_int|0UL
suffix:semicolon
multiline_comment|/* If trapping, we only want to signal one bit. */
r_if
c_cond
(paren
id|would_trap
op_ne
l_int|0
)paren
(brace
id|eflag
op_and_assign
(paren
(paren
id|fsr
op_amp
id|FSR_TEM_MASK
)paren
op_rshift
id|FSR_TEM_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|eflag
op_amp
(paren
id|eflag
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_INVALID
)paren
(brace
id|eflag
op_assign
id|FP_EX_INVALID
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_OVERFLOW
)paren
(brace
id|eflag
op_assign
id|FP_EX_OVERFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_UNDERFLOW
)paren
(brace
id|eflag
op_assign
id|FP_EX_UNDERFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_DIVZERO
)paren
(brace
id|eflag
op_assign
id|FP_EX_DIVZERO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_INEXACT
)paren
(brace
id|eflag
op_assign
id|FP_EX_INEXACT
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Set CEXC, here is the rule:&n;&t; *&n;&t; *    In general all FPU ops will set one and only one&n;&t; *    bit in the CEXC field, this is always the case&n;&t; *    when the IEEE exception trap is enabled in TEM.&n;&t; */
id|fsr
op_and_assign
op_complement
(paren
id|FSR_CEXC_MASK
)paren
suffix:semicolon
id|fsr
op_or_assign
(paren
(paren
r_int
)paren
id|eflag
op_lshift
id|FSR_CEXC_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Set the AEXC field, rule is:&n;&t; *&n;&t; *    If a trap would not be generated, the&n;&t; *    CEXC just generated is OR&squot;d into the&n;&t; *    existing value of AEXC.&n;&t; */
r_if
c_cond
(paren
id|would_trap
op_eq
l_int|0
)paren
(brace
id|fsr
op_or_assign
(paren
(paren
r_int
)paren
id|eflag
op_lshift
id|FSR_AEXC_SHIFT
)paren
suffix:semicolon
)brace
multiline_comment|/* If trapping, indicate fault trap type IEEE. */
r_if
c_cond
(paren
id|would_trap
op_ne
l_int|0
)paren
(brace
id|fsr
op_or_assign
(paren
l_int|1UL
op_lshift
l_int|14
)paren
suffix:semicolon
)brace
op_star
id|pfsr
op_assign
id|fsr
suffix:semicolon
r_return
(paren
id|would_trap
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
)brace
r_typedef
r_union
(brace
DECL|member|s
id|u32
id|s
suffix:semicolon
DECL|member|d
id|u64
id|d
suffix:semicolon
DECL|member|q
id|u64
id|q
(braket
l_int|2
)braket
suffix:semicolon
DECL|typedef|argp
)brace
op_star
id|argp
suffix:semicolon
DECL|function|do_one_mathemu
r_static
r_int
id|do_one_mathemu
c_func
(paren
id|u32
id|insn
comma
r_int
r_int
op_star
id|pfsr
comma
r_int
r_int
op_star
id|fregs
)paren
(brace
multiline_comment|/* Emulate the given insn, updating fsr and fregs appropriately. */
r_int
id|type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* r is rd, b is rs2 and a is rs1. The *u arg tells&n;&t;   whether the argument should be packed/unpacked (0 - do not unpack/pack, 1 - unpack/pack)&n;&t;   non-u args tells the size of the argument (0 - no argument, 1 - single, 2 - double, 3 - quad */
DECL|macro|TYPE
mdefine_line|#define TYPE(dummy, r, ru, b, bu, a, au) type = (au &lt;&lt; 2) | (a &lt;&lt; 0) | (bu &lt;&lt; 5) | (b &lt;&lt; 3) | (ru &lt;&lt; 8) | (r &lt;&lt; 6)
r_int
id|freg
suffix:semicolon
id|argp
id|rs1
op_assign
l_int|NULL
comma
id|rs2
op_assign
l_int|NULL
comma
id|rd
op_assign
l_int|NULL
suffix:semicolon
id|FP_DECL_EX
suffix:semicolon
id|FP_DECL_S
c_func
(paren
id|SA
)paren
suffix:semicolon
id|FP_DECL_S
c_func
(paren
id|SB
)paren
suffix:semicolon
id|FP_DECL_S
c_func
(paren
id|SR
)paren
suffix:semicolon
id|FP_DECL_D
c_func
(paren
id|DA
)paren
suffix:semicolon
id|FP_DECL_D
c_func
(paren
id|DB
)paren
suffix:semicolon
id|FP_DECL_D
c_func
(paren
id|DR
)paren
suffix:semicolon
id|FP_DECL_Q
c_func
(paren
id|QA
)paren
suffix:semicolon
id|FP_DECL_Q
c_func
(paren
id|QB
)paren
suffix:semicolon
id|FP_DECL_Q
c_func
(paren
id|QR
)paren
suffix:semicolon
r_int
id|IR
suffix:semicolon
r_int
id|fsr
suffix:semicolon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;In do_mathemu(), emulating %08lx&bslash;n&quot;
comma
id|insn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|insn
op_amp
l_int|0xc1f80000
)paren
op_eq
l_int|0x81a00000
)paren
multiline_comment|/* FPOP1 */
(brace
r_switch
c_cond
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
(brace
r_case
id|FSQRTQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|3
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FADDQ
suffix:colon
r_case
id|FSUBQ
suffix:colon
r_case
id|FMULQ
suffix:colon
r_case
id|FDIVQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|3
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDMULQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FQTOS
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|1
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FQTOD
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|2
comma
l_int|1
comma
l_int|3
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FITOQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|3
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSTOQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|3
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDTOQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FQTOI
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|1
comma
l_int|0
comma
l_int|3
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSQRTS
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSQRTD
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FADDD
suffix:colon
r_case
id|FSUBD
suffix:colon
r_case
id|FMULD
suffix:colon
r_case
id|FDIVD
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FADDS
suffix:colon
r_case
id|FSUBS
suffix:colon
r_case
id|FMULS
suffix:colon
r_case
id|FDIVS
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSMULD
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDTOS
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSTOD
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSTOI
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDTOI
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FITOS
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FITOD
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FMOVS
suffix:colon
r_case
id|FABSS
suffix:colon
r_case
id|FNEGS
suffix:colon
id|TYPE
c_func
(paren
l_int|2
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;unknown FPop1: %03lx&bslash;n&quot;
comma
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|insn
op_amp
l_int|0xc1f80000
)paren
op_eq
l_int|0x81a80000
)paren
multiline_comment|/* FPOP2 */
(brace
r_switch
c_cond
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
(brace
r_case
id|FCMPS
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FCMPES
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FCMPD
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FCMPED
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|2
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FCMPQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|3
comma
l_int|1
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FCMPEQ
suffix:colon
id|TYPE
c_func
(paren
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|3
comma
l_int|1
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;unknown FPop2: %03lx&bslash;n&quot;
comma
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|type
)paren
(brace
multiline_comment|/* oops, didn&squot;t recognise that FPop */
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;attempt to emulate unrecognised FPop!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Decode the registers to be used */
id|freg
op_assign
(paren
op_star
id|pfsr
op_rshift
l_int|14
)paren
op_amp
l_int|0xf
suffix:semicolon
op_star
id|pfsr
op_and_assign
op_complement
l_int|0x1c000
suffix:semicolon
multiline_comment|/* clear the traptype bits */
id|freg
op_assign
(paren
(paren
id|insn
op_rshift
l_int|14
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0x3
)paren
(brace
multiline_comment|/* is rs1 single, double or quad? */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
(brace
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|pfsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
(brace
multiline_comment|/* doublewords must have bit 5 zeroed */
op_star
id|pfsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|rs1
op_assign
(paren
id|argp
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0x7
)paren
(brace
r_case
l_int|7
suffix:colon
id|FP_UNPACK_QP
(paren
id|QA
comma
id|rs1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|FP_UNPACK_DP
(paren
id|DA
comma
id|rs1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|FP_UNPACK_SP
(paren
id|SA
comma
id|rs1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|freg
op_assign
(paren
id|insn
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|3
)paren
op_amp
l_int|0x3
)paren
(brace
multiline_comment|/* same again for rs2 */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
(brace
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|pfsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
(brace
multiline_comment|/* doublewords must have bit 5 zeroed */
op_star
id|pfsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|rs2
op_assign
(paren
id|argp
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
)paren
(brace
r_case
l_int|7
suffix:colon
id|FP_UNPACK_QP
(paren
id|QB
comma
id|rs2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|FP_UNPACK_DP
(paren
id|DB
comma
id|rs2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|FP_UNPACK_SP
(paren
id|SB
comma
id|rs2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|freg
op_assign
(paren
(paren
id|insn
op_rshift
l_int|25
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|6
)paren
op_amp
l_int|0x3
)paren
(brace
multiline_comment|/* and finally rd. This one&squot;s a bit different */
r_case
l_int|0
suffix:colon
multiline_comment|/* dest is fcc. (this must be FCMPQ or FCMPEQ) */
r_if
c_cond
(paren
id|freg
)paren
(brace
multiline_comment|/* V8 has only one set of condition codes, so */
multiline_comment|/* anything but 0 in the rd field is an error */
op_star
id|pfsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
multiline_comment|/* (should probably flag as invalid opcode */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* but SIGFPE will do :-&gt; ) */
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
(brace
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|pfsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
(brace
multiline_comment|/* doublewords must have bit 5 zeroed */
op_star
id|pfsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
l_int|1
suffix:colon
id|rd
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;executing insn...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* do the Right Thing */
r_switch
c_cond
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
(brace
multiline_comment|/* + */
r_case
id|FADDS
suffix:colon
id|FP_ADD_S
(paren
id|SR
comma
id|SA
comma
id|SB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FADDD
suffix:colon
id|FP_ADD_D
(paren
id|DR
comma
id|DA
comma
id|DB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FADDQ
suffix:colon
id|FP_ADD_Q
(paren
id|QR
comma
id|QA
comma
id|QB
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* - */
r_case
id|FSUBS
suffix:colon
id|FP_SUB_S
(paren
id|SR
comma
id|SA
comma
id|SB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSUBD
suffix:colon
id|FP_SUB_D
(paren
id|DR
comma
id|DA
comma
id|DB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSUBQ
suffix:colon
id|FP_SUB_Q
(paren
id|QR
comma
id|QA
comma
id|QB
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* * */
r_case
id|FMULS
suffix:colon
id|FP_MUL_S
(paren
id|SR
comma
id|SA
comma
id|SB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSMULD
suffix:colon
id|FP_CONV
(paren
id|D
comma
id|S
comma
l_int|2
comma
l_int|1
comma
id|DA
comma
id|SA
)paren
suffix:semicolon
id|FP_CONV
(paren
id|D
comma
id|S
comma
l_int|2
comma
l_int|1
comma
id|DB
comma
id|SB
)paren
suffix:semicolon
r_case
id|FMULD
suffix:colon
id|FP_MUL_D
(paren
id|DR
comma
id|DA
comma
id|DB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDMULQ
suffix:colon
id|FP_CONV
(paren
id|Q
comma
id|D
comma
l_int|4
comma
l_int|2
comma
id|QA
comma
id|DA
)paren
suffix:semicolon
id|FP_CONV
(paren
id|Q
comma
id|D
comma
l_int|4
comma
l_int|2
comma
id|QB
comma
id|DB
)paren
suffix:semicolon
r_case
id|FMULQ
suffix:colon
id|FP_MUL_Q
(paren
id|QR
comma
id|QA
comma
id|QB
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* / */
r_case
id|FDIVS
suffix:colon
id|FP_DIV_S
(paren
id|SR
comma
id|SA
comma
id|SB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDIVD
suffix:colon
id|FP_DIV_D
(paren
id|DR
comma
id|DA
comma
id|DB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDIVQ
suffix:colon
id|FP_DIV_Q
(paren
id|QR
comma
id|QA
comma
id|QB
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* sqrt */
r_case
id|FSQRTS
suffix:colon
id|FP_SQRT_S
(paren
id|SR
comma
id|SB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSQRTD
suffix:colon
id|FP_SQRT_D
(paren
id|DR
comma
id|DB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSQRTQ
suffix:colon
id|FP_SQRT_Q
(paren
id|QR
comma
id|QB
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* mov */
r_case
id|FMOVS
suffix:colon
id|rd-&gt;s
op_assign
id|rs2-&gt;s
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FABSS
suffix:colon
id|rd-&gt;s
op_assign
id|rs2-&gt;s
op_amp
l_int|0x7fffffff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FNEGS
suffix:colon
id|rd-&gt;s
op_assign
id|rs2-&gt;s
op_xor
l_int|0x80000000
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* float to int */
r_case
id|FSTOI
suffix:colon
id|FP_TO_INT_S
(paren
id|IR
comma
id|SB
comma
l_int|32
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDTOI
suffix:colon
id|FP_TO_INT_D
(paren
id|IR
comma
id|DB
comma
l_int|32
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FQTOI
suffix:colon
id|FP_TO_INT_Q
(paren
id|IR
comma
id|QB
comma
l_int|32
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* int to float */
r_case
id|FITOS
suffix:colon
id|IR
op_assign
id|rs2-&gt;s
suffix:semicolon
id|FP_FROM_INT_S
(paren
id|SR
comma
id|IR
comma
l_int|32
comma
r_int
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FITOD
suffix:colon
id|IR
op_assign
id|rs2-&gt;s
suffix:semicolon
id|FP_FROM_INT_D
(paren
id|DR
comma
id|IR
comma
l_int|32
comma
r_int
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FITOQ
suffix:colon
id|IR
op_assign
id|rs2-&gt;s
suffix:semicolon
id|FP_FROM_INT_Q
(paren
id|QR
comma
id|IR
comma
l_int|32
comma
r_int
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* float to float */
r_case
id|FSTOD
suffix:colon
id|FP_CONV
(paren
id|D
comma
id|S
comma
l_int|2
comma
l_int|1
comma
id|DR
comma
id|SB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSTOQ
suffix:colon
id|FP_CONV
(paren
id|Q
comma
id|S
comma
l_int|4
comma
l_int|1
comma
id|QR
comma
id|SB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDTOQ
suffix:colon
id|FP_CONV
(paren
id|Q
comma
id|D
comma
l_int|4
comma
l_int|2
comma
id|QR
comma
id|DB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDTOS
suffix:colon
id|FP_CONV
(paren
id|S
comma
id|D
comma
l_int|1
comma
l_int|2
comma
id|SR
comma
id|DB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FQTOS
suffix:colon
id|FP_CONV
(paren
id|S
comma
id|Q
comma
l_int|1
comma
l_int|4
comma
id|SR
comma
id|QB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FQTOD
suffix:colon
id|FP_CONV
(paren
id|D
comma
id|Q
comma
l_int|2
comma
l_int|4
comma
id|DR
comma
id|QB
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* comparison */
r_case
id|FCMPS
suffix:colon
r_case
id|FCMPES
suffix:colon
id|FP_CMP_S
c_func
(paren
id|IR
comma
id|SB
comma
id|SA
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IR
op_eq
l_int|3
op_logical_and
(paren
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
op_eq
id|FCMPES
op_logical_or
id|FP_ISSIGNAN_S
c_func
(paren
id|SA
)paren
op_logical_or
id|FP_ISSIGNAN_S
c_func
(paren
id|SB
)paren
)paren
)paren
id|FP_SET_EXCEPTION
(paren
id|FP_EX_INVALID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FCMPD
suffix:colon
r_case
id|FCMPED
suffix:colon
id|FP_CMP_D
c_func
(paren
id|IR
comma
id|DB
comma
id|DA
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IR
op_eq
l_int|3
op_logical_and
(paren
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
op_eq
id|FCMPED
op_logical_or
id|FP_ISSIGNAN_D
c_func
(paren
id|DA
)paren
op_logical_or
id|FP_ISSIGNAN_D
c_func
(paren
id|DB
)paren
)paren
)paren
id|FP_SET_EXCEPTION
(paren
id|FP_EX_INVALID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FCMPQ
suffix:colon
r_case
id|FCMPEQ
suffix:colon
id|FP_CMP_Q
c_func
(paren
id|IR
comma
id|QB
comma
id|QA
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IR
op_eq
l_int|3
op_logical_and
(paren
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
op_eq
id|FCMPEQ
op_logical_or
id|FP_ISSIGNAN_Q
c_func
(paren
id|QA
)paren
op_logical_or
id|FP_ISSIGNAN_Q
c_func
(paren
id|QB
)paren
)paren
)paren
id|FP_SET_EXCEPTION
(paren
id|FP_EX_INVALID
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|FP_INHIBIT_RESULTS
)paren
(brace
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|6
)paren
op_amp
l_int|0x7
)paren
(brace
r_case
l_int|0
suffix:colon
id|fsr
op_assign
op_star
id|pfsr
suffix:semicolon
r_if
c_cond
(paren
id|IR
op_eq
op_minus
l_int|1
)paren
id|IR
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* fcc is always fcc0 */
id|fsr
op_and_assign
op_complement
l_int|0xc00
suffix:semicolon
id|fsr
op_or_assign
(paren
id|IR
op_lshift
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
op_star
id|pfsr
op_assign
id|fsr
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|rd-&gt;s
op_assign
id|IR
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|FP_PACK_SP
(paren
id|rd
comma
id|SR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|FP_PACK_DP
(paren
id|rd
comma
id|DR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|FP_PACK_QP
(paren
id|rd
comma
id|QR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|_fex
op_eq
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* success! */
r_return
id|record_exception
c_func
(paren
id|pfsr
comma
id|_fex
)paren
suffix:semicolon
)brace
eof
