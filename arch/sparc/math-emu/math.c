multiline_comment|/*&n; * arch/sparc/math-emu/math.c&n; *&n; * Copyright (C) 1998 Peter Maydell (pmaydell@chiark.greenend.org.uk)&n; * Copyright (C) 1997, 1999 Jakub Jelinek (jj@ultra.linux.cz)&n; * Copyright (C) 1999 David S. Miller (davem@redhat.com)&n; *&n; * This is a good place to start if you&squot;re trying to understand the&n; * emulation code, because it&squot;s pretty simple. What we do is&n; * essentially analyse the instruction to work out what the operation&n; * is and which registers are involved. We then execute the appropriate&n; * FXXXX function. [The floating point queue introduces a minor wrinkle;&n; * see below...]&n; * The fxxxxx.c files each emulate a single insn. They look relatively&n; * simple because the complexity is hidden away in an unholy tangle&n; * of preprocessor macros.&n; *&n; * The first layer of macros is single.h, double.h, quad.h. Generally&n; * these files define macros for working with floating point numbers&n; * of the three IEEE formats. FP_ADD_D(R,A,B) is for adding doubles,&n; * for instance. These macros are usually defined as calls to more&n; * generic macros (in this case _FP_ADD(D,2,R,X,Y) where the number&n; * of machine words required to store the given IEEE format is passed&n; * as a parameter. [double.h and co check the number of bits in a word&n; * and define FP_ADD_D &amp; co appropriately].&n; * The generic macros are defined in op-common.h. This is where all&n; * the grotty stuff like handling NaNs is coded. To handle the possible&n; * word sizes macros in op-common.h use macros like _FP_FRAC_SLL_##wc()&n; * where wc is the &squot;number of machine words&squot; parameter (here 2).&n; * These are defined in the third layer of macros: op-1.h, op-2.h&n; * and op-4.h. These handle operations on floating point numbers composed&n; * of 1,2 and 4 machine words respectively. [For example, on sparc64&n; * doubles are one machine word so macros in double.h eventually use&n; * constructs in op-1.h, but on sparc32 they use op-2.h definitions.]&n; * soft-fp.h is on the same level as op-common.h, and defines some&n; * macros which are independent of both word size and FP format.&n; * Finally, sfp-machine.h is the machine dependent part of the&n; * code: it defines the word size and what type a word is. It also&n; * defines how _FP_MUL_MEAT_t() maps to _FP_MUL_MEAT_n_* : op-n.h&n; * provide several possible flavours of multiply algorithm, most&n; * of which require that you supply some form of asm or C primitive to&n; * do the actual multiply. (such asm primitives should be defined&n; * in sfp-machine.h too). udivmodti4.c is the same sort of thing.&n; *&n; * There may be some errors here because I&squot;m working from a&n; * SPARC architecture manual V9, and what I really want is V8...&n; * Also, the insns which can generate exceptions seem to be a&n; * greater subset of the FPops than for V9 (for example, FCMPED&n; * has to be emulated on V8). So I think I&squot;m going to have&n; * to emulate them all just to be on the safe side...&n; *&n; * Emulation routines originate from soft-fp package, which is&n; * part of glibc and has appropriate copyrights in it (allegedly).&n; *&n; * NB: on sparc int == long == 4 bytes, long long == 8 bytes.&n; * Most bits of the kernel seem to go for long rather than int,&n; * so we follow that practice...&n; */
multiline_comment|/* TODO:&n; * fpsave() saves the FP queue but fpload() doesn&squot;t reload it.&n; * Therefore when we context switch or change FPU ownership&n; * we have to check to see if the queue had anything in it and&n; * emulate it if it did. This is going to be a pain.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;sfp-util.h&quot;
macro_line|#include &quot;soft-fp.h&quot;
DECL|macro|FLOATFUNC
mdefine_line|#define FLOATFUNC(x) extern int x(void *,void *,void *)
multiline_comment|/* The Vn labels indicate what version of the SPARC architecture gas thinks&n; * each insn is. This is from the binutils source :-&gt;&n; */
multiline_comment|/* quadword instructions */
DECL|variable|FSQRTQ
id|FLOATFUNC
c_func
(paren
id|FSQRTQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FADDQ
id|FLOATFUNC
c_func
(paren
id|FADDQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FSUBQ
id|FLOATFUNC
c_func
(paren
id|FSUBQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FMULQ
id|FLOATFUNC
c_func
(paren
id|FMULQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FDIVQ
id|FLOATFUNC
c_func
(paren
id|FDIVQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FDMULQ
id|FLOATFUNC
c_func
(paren
id|FDMULQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FQTOS
id|FLOATFUNC
c_func
(paren
id|FQTOS
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FQTOD
id|FLOATFUNC
c_func
(paren
id|FQTOD
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FITOQ
id|FLOATFUNC
c_func
(paren
id|FITOQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FSTOQ
id|FLOATFUNC
c_func
(paren
id|FSTOQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FDTOQ
id|FLOATFUNC
c_func
(paren
id|FDTOQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FQTOI
id|FLOATFUNC
c_func
(paren
id|FQTOI
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FCMPQ
id|FLOATFUNC
c_func
(paren
id|FCMPQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FCMPEQ
id|FLOATFUNC
c_func
(paren
id|FCMPEQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
multiline_comment|/* single/double instructions (subnormal): should all work */
DECL|variable|FSQRTS
id|FLOATFUNC
c_func
(paren
id|FSQRTS
)paren
suffix:semicolon
multiline_comment|/* v7 */
DECL|variable|FSQRTD
id|FLOATFUNC
c_func
(paren
id|FSQRTD
)paren
suffix:semicolon
multiline_comment|/* v7 */
DECL|variable|FADDS
id|FLOATFUNC
c_func
(paren
id|FADDS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FADDD
id|FLOATFUNC
c_func
(paren
id|FADDD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSUBS
id|FLOATFUNC
c_func
(paren
id|FSUBS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSUBD
id|FLOATFUNC
c_func
(paren
id|FSUBD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FMULS
id|FLOATFUNC
c_func
(paren
id|FMULS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FMULD
id|FLOATFUNC
c_func
(paren
id|FMULD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FDIVS
id|FLOATFUNC
c_func
(paren
id|FDIVS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FDIVD
id|FLOATFUNC
c_func
(paren
id|FDIVD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSMULD
id|FLOATFUNC
c_func
(paren
id|FSMULD
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FDTOS
id|FLOATFUNC
c_func
(paren
id|FDTOS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSTOD
id|FLOATFUNC
c_func
(paren
id|FSTOD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSTOI
id|FLOATFUNC
c_func
(paren
id|FSTOI
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FDTOI
id|FLOATFUNC
c_func
(paren
id|FDTOI
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FABSS
id|FLOATFUNC
c_func
(paren
id|FABSS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPS
id|FLOATFUNC
c_func
(paren
id|FCMPS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPES
id|FLOATFUNC
c_func
(paren
id|FCMPES
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPD
id|FLOATFUNC
c_func
(paren
id|FCMPD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPED
id|FLOATFUNC
c_func
(paren
id|FCMPED
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FMOVS
id|FLOATFUNC
c_func
(paren
id|FMOVS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FNEGS
id|FLOATFUNC
c_func
(paren
id|FNEGS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FITOS
id|FLOATFUNC
c_func
(paren
id|FITOS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FITOD
id|FLOATFUNC
c_func
(paren
id|FITOD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|macro|FSR_TEM_SHIFT
mdefine_line|#define FSR_TEM_SHIFT&t;23UL
DECL|macro|FSR_TEM_MASK
mdefine_line|#define FSR_TEM_MASK&t;(0x1fUL &lt;&lt; FSR_TEM_SHIFT)
DECL|macro|FSR_AEXC_SHIFT
mdefine_line|#define FSR_AEXC_SHIFT&t;5UL
DECL|macro|FSR_AEXC_MASK
mdefine_line|#define FSR_AEXC_MASK&t;(0x1fUL &lt;&lt; FSR_AEXC_SHIFT)
DECL|macro|FSR_CEXC_SHIFT
mdefine_line|#define FSR_CEXC_SHIFT&t;0UL
DECL|macro|FSR_CEXC_MASK
mdefine_line|#define FSR_CEXC_MASK&t;(0x1fUL &lt;&lt; FSR_CEXC_SHIFT)
r_static
r_int
id|do_one_mathemu
c_func
(paren
id|u32
id|insn
comma
r_int
r_int
op_star
id|fsr
comma
r_int
r_int
op_star
id|fregs
)paren
suffix:semicolon
multiline_comment|/* Unlike the Sparc64 version (which has a struct fpustate), we&n; * pass the taskstruct corresponding to the task which currently owns the&n; * FPU. This is partly because we don&squot;t have the fpustate struct and&n; * partly because the task owning the FPU isn&squot;t always current (as is&n; * the case for the Sparc64 port). This is probably SMP-related...&n; * This function returns 1 if all queued insns were emulated successfully.&n; * The test for unimplemented FPop in kernel mode has been moved into&n; * kernel/traps.c for simplicity.&n; */
DECL|function|do_mathemu
r_int
id|do_mathemu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|task_struct
op_star
id|fpt
)paren
(brace
multiline_comment|/* regs-&gt;pc isn&squot;t necessarily the PC at which the offending insn is sitting.&n;&t; * The FPU maintains a queue of FPops which cause traps.&n;&t; * When it hits an instruction that requires that the trapped op succeeded&n;&t; * (usually because it reads a reg. that the trapped op wrote) then it&n;&t; * causes this exception. We need to emulate all the insns on the queue&n;&t; * and then allow the op to proceed.&n;&t; * This code should also handle the case where the trap was precise,&n;&t; * in which case the queue length is zero and regs-&gt;pc points at the&n;&t; * single FPop to be emulated. (this case is untested, though :-&gt;)&n;&t; * You&squot;ll need this case if you want to be able to emulate all FPops&n;&t; * because the FPU either doesn&squot;t exist or has been software-disabled.&n;&t; * [The UltraSPARC makes FP a precise trap; this isn&squot;t as stupid as it&n;&t; * might sound because the Ultra does funky things with a superscalar&n;&t; * architecture.]&n;&t; */
multiline_comment|/* You wouldn&squot;t believe how often I typed &squot;ftp&squot; when I meant &squot;fpt&squot; :-&gt; */
r_int
id|i
suffix:semicolon
r_int
id|retcode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assume all succeed */
r_int
r_int
id|insn
suffix:semicolon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;In do_mathemu()... pc is %08lx&bslash;n&quot;
comma
id|regs-&gt;pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpqdepth is %ld&bslash;n&quot;
comma
id|fpt-&gt;tss.fpqdepth
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fpt-&gt;tss.fpqdepth
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%d: %08lx at %08lx&bslash;n&quot;
comma
id|i
comma
id|fpt-&gt;tss.fpqueue
(braket
id|i
)braket
dot
id|insn
comma
(paren
r_int
r_int
)paren
id|fpt-&gt;tss.fpqueue
(braket
id|i
)braket
dot
id|insn_addr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fpt-&gt;tss.fpqdepth
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no queue, guilty insn is at regs-&gt;pc */
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;precise trap at %08lx&bslash;n&quot;
comma
id|regs-&gt;pc
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|get_user
c_func
(paren
id|insn
comma
(paren
id|u32
op_star
)paren
id|regs-&gt;pc
)paren
)paren
(brace
id|retcode
op_assign
id|do_one_mathemu
c_func
(paren
id|insn
comma
op_amp
id|fpt-&gt;tss.fsr
comma
id|fpt-&gt;tss.float_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retcode
)paren
(brace
multiline_comment|/* in this case we need to fix up PC &amp; nPC */
id|regs-&gt;pc
op_assign
id|regs-&gt;npc
suffix:semicolon
id|regs-&gt;npc
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
r_return
id|retcode
suffix:semicolon
)brace
multiline_comment|/* Normal case: need to empty the queue... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fpt-&gt;tss.fpqdepth
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retcode
op_assign
id|do_one_mathemu
c_func
(paren
id|fpt-&gt;tss.fpqueue
(braket
id|i
)braket
dot
id|insn
comma
op_amp
(paren
id|fpt-&gt;tss.fsr
)paren
comma
id|fpt-&gt;tss.float_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
multiline_comment|/* insn failed, no point doing any more */
r_break
suffix:semicolon
)brace
multiline_comment|/* Now empty the queue and clear the queue_not_empty flag */
r_if
c_cond
(paren
id|retcode
)paren
(brace
id|fpt-&gt;tss.fsr
op_and_assign
op_complement
(paren
l_int|0x3000
op_or
id|FSR_CEXC_MASK
)paren
suffix:semicolon
)brace
r_else
id|fpt-&gt;tss.fsr
op_and_assign
op_complement
l_int|0x3000
suffix:semicolon
id|fpt-&gt;tss.fpqdepth
op_assign
l_int|0
suffix:semicolon
r_return
id|retcode
suffix:semicolon
)brace
multiline_comment|/* All routines returning an exception to raise should detect&n; * such exceptions _before_ rounding to be consistant with&n; * the behavior of the hardware in the implemented cases&n; * (and thus with the recommendations in the V9 architecture&n; * manual).&n; *&n; * We return 0 if a SIGFPE should be sent, 1 otherwise.&n; */
DECL|function|record_exception
r_static
r_int
id|record_exception
c_func
(paren
r_int
r_int
op_star
id|pfsr
comma
r_int
id|eflag
)paren
(brace
r_int
r_int
id|fsr
op_assign
op_star
id|pfsr
suffix:semicolon
r_int
id|would_trap
suffix:semicolon
multiline_comment|/* Determine if this exception would have generated a trap. */
id|would_trap
op_assign
(paren
id|fsr
op_amp
(paren
(paren
r_int
)paren
id|eflag
op_lshift
id|FSR_TEM_SHIFT
)paren
)paren
op_ne
l_int|0UL
suffix:semicolon
multiline_comment|/* If trapping, we only want to signal one bit. */
r_if
c_cond
(paren
id|would_trap
op_ne
l_int|0
)paren
(brace
id|eflag
op_and_assign
(paren
(paren
id|fsr
op_amp
id|FSR_TEM_MASK
)paren
op_rshift
id|FSR_TEM_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|eflag
op_amp
(paren
id|eflag
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_INVALID
)paren
(brace
id|eflag
op_assign
id|FP_EX_INVALID
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_OVERFLOW
)paren
(brace
id|eflag
op_assign
id|FP_EX_OVERFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_UNDERFLOW
)paren
(brace
id|eflag
op_assign
id|FP_EX_UNDERFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_DIVZERO
)paren
(brace
id|eflag
op_assign
id|FP_EX_DIVZERO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eflag
op_amp
id|FP_EX_INEXACT
)paren
(brace
id|eflag
op_assign
id|FP_EX_INEXACT
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Set CEXC, here is the rule:&n;&t; *&n;&t; *    In general all FPU ops will set one and only one&n;&t; *    bit in the CEXC field, this is always the case&n;&t; *    when the IEEE exception trap is enabled in TEM.&n;&t; */
id|fsr
op_and_assign
op_complement
(paren
id|FSR_CEXC_MASK
)paren
suffix:semicolon
id|fsr
op_or_assign
(paren
(paren
r_int
)paren
id|eflag
op_lshift
id|FSR_CEXC_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Set the AEXC field, rule is:&n;&t; *&n;&t; *    If a trap would not be generated, the&n;&t; *    CEXC just generated is OR&squot;d into the&n;&t; *    existing value of AEXC.&n;&t; */
r_if
c_cond
(paren
id|would_trap
op_eq
l_int|0
)paren
(brace
id|fsr
op_or_assign
(paren
(paren
r_int
)paren
id|eflag
op_lshift
id|FSR_AEXC_SHIFT
)paren
suffix:semicolon
)brace
multiline_comment|/* If trapping, indicate fault trap type IEEE. */
r_if
c_cond
(paren
id|would_trap
op_ne
l_int|0
)paren
(brace
id|fsr
op_or_assign
(paren
l_int|1UL
op_lshift
l_int|14
)paren
suffix:semicolon
)brace
op_star
id|pfsr
op_assign
id|fsr
suffix:semicolon
r_return
(paren
id|would_trap
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|do_one_mathemu
r_static
r_int
id|do_one_mathemu
c_func
(paren
id|u32
id|insn
comma
r_int
r_int
op_star
id|fsr
comma
r_int
r_int
op_star
id|fregs
)paren
(brace
multiline_comment|/* Emulate the given insn, updating fsr and fregs appropriately. */
r_int
id|type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 01 is single, 10 is double, 11 is quad,&n;&t; * 000011 is rs1, 001100 is rs2, 110000 is rd (00 in rd is fcc)&n;&t; * 111100000000 tells which ftt that may happen in&n;&t; * (this field not used on sparc32 code, as we can&squot;t&n;&t; * extract trap type info for ops on the FP queue)&n;&t; */
r_int
id|freg
comma
id|eflag
suffix:semicolon
r_int
(paren
op_star
id|func
)paren
(paren
r_void
op_star
comma
r_void
op_star
comma
r_void
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|rs1
op_assign
l_int|NULL
comma
op_star
id|rs2
op_assign
l_int|NULL
comma
op_star
id|rd
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;In do_mathemu(), emulating %08lx&bslash;n&quot;
comma
id|insn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|insn
op_amp
l_int|0xc1f80000
)paren
op_eq
l_int|0x81a00000
)paren
multiline_comment|/* FPOP1 */
(brace
r_switch
c_cond
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
(brace
multiline_comment|/* QUAD - ftt == 3 */
r_case
l_int|0x001
suffix:colon
id|type
op_assign
l_int|0x314
suffix:semicolon
id|func
op_assign
id|FMOVS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x005
suffix:colon
id|type
op_assign
l_int|0x314
suffix:semicolon
id|func
op_assign
id|FNEGS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x009
suffix:colon
id|type
op_assign
l_int|0x314
suffix:semicolon
id|func
op_assign
id|FABSS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02b
suffix:colon
id|type
op_assign
l_int|0x33c
suffix:semicolon
id|func
op_assign
id|FSQRTQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x043
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FADDQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x047
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FSUBQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04b
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FMULQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04f
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FDIVQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x06e
suffix:colon
id|type
op_assign
l_int|0x33a
suffix:semicolon
id|func
op_assign
id|FDMULQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0c7
suffix:colon
id|type
op_assign
l_int|0x31c
suffix:semicolon
id|func
op_assign
id|FQTOS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0cb
suffix:colon
id|type
op_assign
l_int|0x32c
suffix:semicolon
id|func
op_assign
id|FQTOD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0cc
suffix:colon
id|type
op_assign
l_int|0x334
suffix:semicolon
id|func
op_assign
id|FITOQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0cd
suffix:colon
id|type
op_assign
l_int|0x334
suffix:semicolon
id|func
op_assign
id|FSTOQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0ce
suffix:colon
id|type
op_assign
l_int|0x338
suffix:semicolon
id|func
op_assign
id|FDTOQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0d3
suffix:colon
id|type
op_assign
l_int|0x31c
suffix:semicolon
id|func
op_assign
id|FQTOI
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* SUBNORMAL - ftt == 2 */
r_case
l_int|0x029
suffix:colon
id|type
op_assign
l_int|0x214
suffix:semicolon
id|func
op_assign
id|FSQRTS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02a
suffix:colon
id|type
op_assign
l_int|0x228
suffix:semicolon
id|func
op_assign
id|FSQRTD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x041
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FADDS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x042
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FADDD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x045
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FSUBS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x046
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FSUBD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x049
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FMULS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04a
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FMULD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04d
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FDIVS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04e
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FDIVD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x069
suffix:colon
id|type
op_assign
l_int|0x225
suffix:semicolon
id|func
op_assign
id|FSMULD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0c6
suffix:colon
id|type
op_assign
l_int|0x218
suffix:semicolon
id|func
op_assign
id|FDTOS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0c9
suffix:colon
id|type
op_assign
l_int|0x224
suffix:semicolon
id|func
op_assign
id|FSTOD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0d1
suffix:colon
id|type
op_assign
l_int|0x214
suffix:semicolon
id|func
op_assign
id|FSTOI
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0d2
suffix:colon
id|type
op_assign
l_int|0x218
suffix:semicolon
id|func
op_assign
id|FDTOI
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;unknown FPop1: %03lx&bslash;n&quot;
comma
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|insn
op_amp
l_int|0xc1f80000
)paren
op_eq
l_int|0x81a80000
)paren
multiline_comment|/* FPOP2 */
(brace
r_switch
c_cond
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
(brace
r_case
l_int|0x051
suffix:colon
id|type
op_assign
l_int|0x305
suffix:semicolon
id|func
op_assign
id|FCMPS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x052
suffix:colon
id|type
op_assign
l_int|0x30a
suffix:semicolon
id|func
op_assign
id|FCMPD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x053
suffix:colon
id|type
op_assign
l_int|0x30f
suffix:semicolon
id|func
op_assign
id|FCMPQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x055
suffix:colon
id|type
op_assign
l_int|0x305
suffix:semicolon
id|func
op_assign
id|FCMPES
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x056
suffix:colon
id|type
op_assign
l_int|0x30a
suffix:semicolon
id|func
op_assign
id|FCMPED
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x057
suffix:colon
id|type
op_assign
l_int|0x30f
suffix:semicolon
id|func
op_assign
id|FCMPEQ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;unknown FPop2: %03lx&bslash;n&quot;
comma
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|type
)paren
(brace
multiline_comment|/* oops, didn&squot;t recognise that FPop */
id|printk
c_func
(paren
l_string|&quot;attempt to emulate unrecognised FPop!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Decode the registers to be used */
id|freg
op_assign
(paren
op_star
id|fsr
op_rshift
l_int|14
)paren
op_amp
l_int|0xf
suffix:semicolon
op_star
id|fsr
op_and_assign
op_complement
l_int|0x1c000
suffix:semicolon
multiline_comment|/* clear the traptype bits */
id|freg
op_assign
(paren
(paren
id|insn
op_rshift
l_int|14
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0x3
)paren
(brace
multiline_comment|/* is rs1 single, double or quad? */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
(brace
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
(brace
multiline_comment|/* doublewords must have bit 5 zeroed */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|rs1
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
id|freg
op_assign
(paren
id|insn
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|2
)paren
op_amp
l_int|0x3
)paren
(brace
multiline_comment|/* same again for rs2 */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
(brace
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
(brace
multiline_comment|/* doublewords must have bit 5 zeroed */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|rs2
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
id|freg
op_assign
(paren
(paren
id|insn
op_rshift
l_int|25
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|4
)paren
op_amp
l_int|0x3
)paren
(brace
multiline_comment|/* and finally rd. This one&squot;s a bit different */
r_case
l_int|0
suffix:colon
multiline_comment|/* dest is fcc. (this must be FCMPQ or FCMPEQ) */
r_if
c_cond
(paren
id|freg
)paren
(brace
multiline_comment|/* V8 has only one set of condition codes, so */
multiline_comment|/* anything but 0 in the rd field is an error */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
multiline_comment|/* (should probably flag as invalid opcode */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* but SIGFPE will do :-&gt; ) */
)brace
id|rd
op_assign
(paren
r_void
op_star
)paren
(paren
id|fsr
)paren
suffix:semicolon
multiline_comment|/* FCMPQ and FCMPEQ are special and only  */
r_break
suffix:semicolon
multiline_comment|/* set bits they&squot;re supposed to :-&gt; */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
(brace
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
(brace
multiline_comment|/* doublewords must have bit 5 zeroed */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
l_int|1
suffix:colon
id|rd
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;executing insn...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|eflag
op_assign
id|func
c_func
(paren
id|rd
comma
id|rs2
comma
id|rs1
)paren
suffix:semicolon
multiline_comment|/* do the Right Thing */
r_if
c_cond
(paren
id|eflag
op_eq
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* success! */
r_return
id|record_exception
c_func
(paren
id|fsr
comma
id|eflag
)paren
suffix:semicolon
)brace
eof
