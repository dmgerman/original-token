multiline_comment|/* &n; * arch/sparc/math-emu/math.c&n; *&n; * Copyright (C) 1998 Peter Maydell (pmaydell@chiark.greenend.org.uk)&n; * Based on the sparc64 code by Jakub Jelinek.&n; *&n; * This is a good place to start if you&squot;re trying to understand the&n; * emulation code, because it&squot;s pretty simple. What we do is &n; * essentially analyse the instruction to work out what the operation&n; * is and which registers are involved. We then execute the appropriate&n; * FXXXX function. [The floating point queue introduces a minor wrinkle;&n; * see below...]&n; * The fxxxxx.c files each emulate a single insn. They look relatively&n; * simple because the complexity is hidden away in an unholy tangle&n; * of preprocessor macros. &n; *&n; * WARNING : don&squot;t look at the macro definitions unless you &n; * absolutely have to! They&squot;re extremely ugly, rather complicated&n; * and a single line in an fxxxx.c file can expand to the equivalent &n; * of  30 lines or more of C. Of course, any error in those 30 lines &n; * is reported by the compiler as an error in the single line with the&n; * macro usage...&n; * Question: should we replace them with inline functions?&n; *&n; * The first layer of macros is single.h, double.h, quad.h. Generally&n; * these files define macros for working with floating point numbers&n; * of the three IEEE formats. FP_ADD_D(R,A,B) is for adding doubles,&n; * for instance. These macros are usually defined as calls to more&n; * generic macros (in this case _FP_ADD(D,2,R,X,Y) where the number&n; * of machine words required to store the given IEEE format is passed&n; * as a parameter. [double.h and co check the number of bits in a word&n; * and define FP_ADD_D &amp; co appropriately]. &n; * The generic macros are defined in op-common.h. This is where all&n; * the grotty stuff like handling NaNs is coded. To handle the possible&n; * word sizes macros in op-common.h use macros like _FP_FRAC_SLL_##wc()&n; * where wc is the &squot;number of machine words&squot; parameter (here 2). &n; * These are defined in the third layer of macros: op-1.h, op-2.h&n; * and op-4.h. These handle operations on floating point numbers composed&n; * of 1,2 and 4 machine words respectively. [For example, on sparc64&n; * doubles are one machine word so macros in double.h eventually use&n; * constructs in op-1.h, but on sparc32 they use op-2.h definitions.]&n; * soft-fp.h is on the same level as op-common.h, and defines some&n; * macros which are independent of both word size and FP format.&n; * Finally, sfp-machine.h is the machine dependent part of the &n; * code: it defines the word size and what type a word is. It also&n; * defines how _FP_MUL_MEAT_t() maps to _FP_MUL_MEAT_n_* : op-n.h&n; * provide several possible flavours of multiply algorithm, most&n; * of which require that you supply some form of asm or C primitive to&n; * do the actual multiply. (such asm primitives should be defined&n; * in sfp-machine.h too). udivmodti4.c is the same sort of thing.&n; *&n; * There may be some errors here because I&squot;m working from a&n; * SPARC architecture manual V9, and what I really want is V8...&n; * Also, the insns which can generate exceptions seem to be a&n; * greater subset of the FPops than for V9 (for example, FCMPED&n; * has to be emulated on V8). So I think I&squot;m going to have&n; * to emulate them all just to be on the safe side...&n; *&n; * Emulation routines originate from soft-fp package, which is&n; * part of glibc and has appropriate copyrights in it (allegedly).&n; *&n; * NB: on sparc int == long == 4 bytes, long long == 8 bytes.&n; * Most bits of the kernel seem to go for long rather than int,&n; * so we follow that practice...&n; */
multiline_comment|/* WISHLIST:&n; *&n; * + Replace all the macros with inline functions. These should&n; * have the same effect but be much easier to work with.&n; *&n; * + Emulate the IEEE exception flags. We don&squot;t currently do this&n; * because a) it would require significant alterations to&n; * the emulation macros [see the comments about _FP_NEG()&n; * in op-common.c and note that we&squot;d need to invent a convention&n; * for passing in the flags to FXXXX fns and returning them] and &n; * b) SPARClinux doesn&squot;t let users access the flags anyway &n; * [contrast Solaris, which allows you to examine, clear or set&n; * the flags, and request that exceptions cause SIGFPE &n; * [which you then set up a signal handler for, obviously...]].&n; * Erm, (b) may quite possibly be garbage. %fsr is user-writable&n; * so you don&squot;t need a syscall. There may or may not be library&n; * support.&n; *&n; * + Emulation of FMULQ, FDIVQ, FSQRTQ, FDMULQ needs to be &n; * written!&n; * &n; * + reindent code to conform to Linux kernel standard :-&gt;&n; *&n; * + work out whether all the compile-time warnings are bogus&n; *&n; * + check that conversion to/from integers works&n; * &n; * + check with the SPARC architecture manual to see if we resolve&n; * the implementation-dependent bits of the IEEE spec in the&n; * same manner as the hardware.&n; *&n; * + more test cases for the test script always welcome!&n; *&n; * + illegal opcodes currently cause SIGFPEs. We should arrange&n; * to tell the traps.c code to SIGILL instead. Currently,&n; * everywhere that we return 0 should cause SIGILL, I think.&n; * SIGFPE should only be caused if we set an IEEE exception bit&n; * and the relevant trap bit is also set. (this means that &n; * traps.c should do this; also it should handle the case of&n; * IEEE exception generated directly by the hardware.)&n; * Should illegal_fp_register (which is a flavour of fp exception)&n; * cause SIGFPE or  SIGILL?&n; *&n; * + the test script needs to be extended to handle the quadword&n; * and comparison insns.&n; *&n; * + _FP_DIV_MEAT_2_udiv_64() appears to work but it should be&n; * checked by somebody who understands the algorithm :-&gt;&n; * &n; * + fpsave() saves the FP queue but fpload() doesn&squot;t reload it.&n; * Therefore when we context switch or change FPU ownership&n; * we have to check to see if the queue had anything in it and&n; * emulate it if it did. This is going to be a pain. &n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|FLOATFUNC
mdefine_line|#define FLOATFUNC(x) extern int x(void *,void *,void *)
multiline_comment|/* Current status: we don&squot;t properly emulate the difficult quadword&n; * insns (MUL, DIV, SQRT).&n; * There are also some ops involving the FP registers which we don&squot;t&n; * emulate: the branch on FP condition flags and the load/store to&n; * FP regs or FSR. I&squot;m assuming that these will never generate traps&n; * (not unreasonable if there&squot;s an FPU at all; comments in the NetBSD&n; * kernel source agree on this point). If we wanted to allow&n; * purely software-emulation of the FPU with FPU totally disabled&n; * or non-existent, we&squot;d have to emulate these as well. We&squot;d also&n; * need to alter the fp_disabled trap handler to call the math-emu&n; * code appropriately. The structure of do_one_mathemu() is also&n; * inappropriate for these ops (as it has no way to alter the pc, &n; * for a start) and it might be better to special-case them in do_mathemu().&n; * Oh, and you&squot;d need to alter the traps.c code so it didn&squot;t try to&n; * fpsave() and fpload(). If there&squot;s genuinely no FPU then there&squot;s &n; * probably bits of kernel stuff that just won&squot;t work anyway...&n; */
multiline_comment|/* The Vn labels indicate what version of the SPARC architecture gas thinks&n; * each insn is. This is from the binutils source :-&gt; &n; */
multiline_comment|/* quadword instructions */
DECL|variable|FSQRTQ
id|FLOATFUNC
c_func
(paren
id|FSQRTQ
)paren
suffix:semicolon
multiline_comment|/* v8 NYI */
DECL|variable|FADDQ
id|FLOATFUNC
c_func
(paren
id|FADDQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FSUBQ
id|FLOATFUNC
c_func
(paren
id|FSUBQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FMULQ
id|FLOATFUNC
c_func
(paren
id|FMULQ
)paren
suffix:semicolon
multiline_comment|/* v8 NYI */
DECL|variable|FDIVQ
id|FLOATFUNC
c_func
(paren
id|FDIVQ
)paren
suffix:semicolon
multiline_comment|/* v8 NYI */
DECL|variable|FDMULQ
id|FLOATFUNC
c_func
(paren
id|FDMULQ
)paren
suffix:semicolon
multiline_comment|/* v8 NYI */
DECL|variable|FQTOS
id|FLOATFUNC
c_func
(paren
id|FQTOS
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FQTOD
id|FLOATFUNC
c_func
(paren
id|FQTOD
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FITOQ
id|FLOATFUNC
c_func
(paren
id|FITOQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FSTOQ
id|FLOATFUNC
c_func
(paren
id|FSTOQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FDTOQ
id|FLOATFUNC
c_func
(paren
id|FDTOQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FQTOI
id|FLOATFUNC
c_func
(paren
id|FQTOI
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FCMPQ
id|FLOATFUNC
c_func
(paren
id|FCMPQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FCMPEQ
id|FLOATFUNC
c_func
(paren
id|FCMPEQ
)paren
suffix:semicolon
multiline_comment|/* v8 */
multiline_comment|/* single/double instructions (subnormal): should all work */
DECL|variable|FSQRTS
id|FLOATFUNC
c_func
(paren
id|FSQRTS
)paren
suffix:semicolon
multiline_comment|/* v7 */
DECL|variable|FSQRTD
id|FLOATFUNC
c_func
(paren
id|FSQRTD
)paren
suffix:semicolon
multiline_comment|/* v7 */
DECL|variable|FADDS
id|FLOATFUNC
c_func
(paren
id|FADDS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FADDD
id|FLOATFUNC
c_func
(paren
id|FADDD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSUBS
id|FLOATFUNC
c_func
(paren
id|FSUBS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSUBD
id|FLOATFUNC
c_func
(paren
id|FSUBD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FMULS
id|FLOATFUNC
c_func
(paren
id|FMULS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FMULD
id|FLOATFUNC
c_func
(paren
id|FMULD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FDIVS
id|FLOATFUNC
c_func
(paren
id|FDIVS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FDIVD
id|FLOATFUNC
c_func
(paren
id|FDIVD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSMULD
id|FLOATFUNC
c_func
(paren
id|FSMULD
)paren
suffix:semicolon
multiline_comment|/* v8 */
DECL|variable|FDTOS
id|FLOATFUNC
c_func
(paren
id|FDTOS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSTOD
id|FLOATFUNC
c_func
(paren
id|FSTOD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FSTOI
id|FLOATFUNC
c_func
(paren
id|FSTOI
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FDTOI
id|FLOATFUNC
c_func
(paren
id|FDTOI
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FABSS
id|FLOATFUNC
c_func
(paren
id|FABSS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPS
id|FLOATFUNC
c_func
(paren
id|FCMPS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPES
id|FLOATFUNC
c_func
(paren
id|FCMPES
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPD
id|FLOATFUNC
c_func
(paren
id|FCMPD
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FCMPED
id|FLOATFUNC
c_func
(paren
id|FCMPED
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FMOVS
id|FLOATFUNC
c_func
(paren
id|FMOVS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FNEGS
id|FLOATFUNC
c_func
(paren
id|FNEGS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FITOS
id|FLOATFUNC
c_func
(paren
id|FITOS
)paren
suffix:semicolon
multiline_comment|/* v6 */
DECL|variable|FITOD
id|FLOATFUNC
c_func
(paren
id|FITOD
)paren
suffix:semicolon
multiline_comment|/* v6 */
r_static
r_int
id|do_one_mathemu
c_func
(paren
id|u32
id|insn
comma
r_int
r_int
op_star
id|fsr
comma
r_int
r_int
op_star
id|fregs
)paren
suffix:semicolon
multiline_comment|/* Unlike the Sparc64 version (which has a struct fpustate), we&n; * pass the taskstruct corresponding to the task which currently owns the&n; * FPU. This is partly because we don&squot;t have the fpustate struct and&n; * partly because the task owning the FPU isn&squot;t always current (as is&n; * the case for the Sparc64 port). This is probably SMP-related...&n; * This function returns 1 if all queued insns were emulated successfully.&n; * The test for unimplemented FPop in kernel mode has been moved into&n; * kernel/traps.c for simplicity.&n; */
DECL|function|do_mathemu
r_int
id|do_mathemu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|task_struct
op_star
id|fpt
)paren
(brace
multiline_comment|/* regs-&gt;pc isn&squot;t necessarily the PC at which the offending insn is sitting.&n;    * The FPU maintains a queue of FPops which cause traps. &n;    * When it hits an instruction that requires that the trapped op succeeded&n;    * (usually because it reads a reg. that the trapped op wrote) then it&n;    * causes this exception. We need to emulate all the insns on the queue&n;    * and then allow the op to proceed.&n;    * This code should also handle the case where the trap was precise,&n;    * in which case the queue length is zero and regs-&gt;pc points at the &n;    * single FPop to be emulated. (this case is untested, though :-&gt;) &n;    * You&squot;ll need this case if you want to be able to emulate all FPops&n;    * because the FPU either doesn&squot;t exist or has been software-disabled.&n;    * [The UltraSPARC makes FP a precise trap; this isn&squot;t as stupid as it &n;    * might sound because the Ultra does funky things with a superscalar&n;    * architecture.]&n;    */
multiline_comment|/* You wouldn&squot;t believe how often I typed &squot;ftp&squot; when I meant &squot;fpt&squot; :-&gt; */
r_int
id|i
suffix:semicolon
r_int
id|retcode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assume all succeed */
r_int
r_int
id|insn
suffix:semicolon
macro_line|#ifdef DEBUG_MATHEMU   
id|printk
c_func
(paren
l_string|&quot;In do_mathemu()... pc is %08lx&bslash;n&quot;
comma
id|regs-&gt;pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fpqdepth is %ld&bslash;n&quot;
comma
id|fpt-&gt;tss.fpqdepth
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fpt-&gt;tss.fpqdepth
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%d: %08lx at %08lx&bslash;n&quot;
comma
id|i
comma
id|fpt-&gt;tss.fpqueue
(braket
id|i
)braket
dot
id|insn
comma
(paren
r_int
r_int
)paren
id|fpt-&gt;tss.fpqueue
(braket
id|i
)braket
dot
id|insn_addr
)paren
suffix:semicolon
macro_line|#endif      
r_if
c_cond
(paren
id|fpt-&gt;tss.fpqdepth
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no queue, guilty insn is at regs-&gt;pc */
macro_line|#ifdef DEBUG_MATHEMU   
id|printk
c_func
(paren
l_string|&quot;precise trap at %08lx&bslash;n&quot;
comma
id|regs-&gt;pc
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|get_user
c_func
(paren
id|insn
comma
(paren
id|u32
op_star
)paren
id|regs-&gt;pc
)paren
)paren
(brace
id|retcode
op_assign
id|do_one_mathemu
c_func
(paren
id|insn
comma
op_amp
id|fpt-&gt;tss.fsr
comma
id|fpt-&gt;tss.float_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retcode
)paren
(brace
multiline_comment|/* in this case we need to fix up PC &amp; nPC */
id|regs-&gt;pc
op_assign
id|regs-&gt;npc
suffix:semicolon
id|regs-&gt;npc
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
r_return
id|retcode
suffix:semicolon
)brace
multiline_comment|/* Normal case: need to empty the queue... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fpt-&gt;tss.fpqdepth
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retcode
op_assign
id|do_one_mathemu
c_func
(paren
id|fpt-&gt;tss.fpqueue
(braket
id|i
)braket
dot
id|insn
comma
op_amp
(paren
id|fpt-&gt;tss.fsr
)paren
comma
id|fpt-&gt;tss.float_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
multiline_comment|/* insn failed, no point doing any more */
r_break
suffix:semicolon
)brace
multiline_comment|/* Now empty the queue and clear the queue_not_empty flag */
id|fpt-&gt;tss.fsr
op_and_assign
op_complement
l_int|0x3000
suffix:semicolon
id|fpt-&gt;tss.fpqdepth
op_assign
l_int|0
suffix:semicolon
r_return
id|retcode
suffix:semicolon
)brace
DECL|function|do_one_mathemu
r_static
r_int
id|do_one_mathemu
c_func
(paren
id|u32
id|insn
comma
r_int
r_int
op_star
id|fsr
comma
r_int
r_int
op_star
id|fregs
)paren
(brace
multiline_comment|/* Emulate the given insn, updating fsr and fregs appropriately. */
r_int
id|type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 01 is single, 10 is double, 11 is quad, &n;    * 000011 is rs1, 001100 is rs2, 110000 is rd (00 in rd is fcc)&n;    * 111100000000 tells which ftt that may happen in &n;    * (this field not used on sparc32 code, as we can&squot;t &n;    * extract trap type info for ops on the FP queue) &n;    */
r_int
id|freg
suffix:semicolon
r_int
(paren
op_star
id|func
)paren
(paren
r_void
op_star
comma
r_void
op_star
comma
r_void
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|rs1
op_assign
l_int|NULL
comma
op_star
id|rs2
op_assign
l_int|NULL
comma
op_star
id|rd
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef DEBUG_MATHEMU
id|printk
c_func
(paren
l_string|&quot;In do_mathemu(), emulating %08lx&bslash;n&quot;
comma
id|insn
)paren
suffix:semicolon
macro_line|#endif   
r_if
c_cond
(paren
(paren
id|insn
op_amp
l_int|0xc1f80000
)paren
op_eq
l_int|0x81a00000
)paren
multiline_comment|/* FPOP1 */
(brace
r_switch
c_cond
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
(brace
multiline_comment|/* QUAD - ftt == 3 */
r_case
l_int|0x001
suffix:colon
id|type
op_assign
l_int|0x314
suffix:semicolon
id|func
op_assign
id|FMOVS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x005
suffix:colon
id|type
op_assign
l_int|0x314
suffix:semicolon
id|func
op_assign
id|FNEGS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x009
suffix:colon
id|type
op_assign
l_int|0x314
suffix:semicolon
id|func
op_assign
id|FABSS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02b
suffix:colon
id|type
op_assign
l_int|0x33c
suffix:semicolon
id|func
op_assign
id|FSQRTQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x043
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FADDQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x047
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FSUBQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04b
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FMULQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04f
suffix:colon
id|type
op_assign
l_int|0x33f
suffix:semicolon
id|func
op_assign
id|FDIVQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x06e
suffix:colon
id|type
op_assign
l_int|0x33a
suffix:semicolon
id|func
op_assign
id|FDMULQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0c7
suffix:colon
id|type
op_assign
l_int|0x31c
suffix:semicolon
id|func
op_assign
id|FQTOS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0cb
suffix:colon
id|type
op_assign
l_int|0x32c
suffix:semicolon
id|func
op_assign
id|FQTOD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0cc
suffix:colon
id|type
op_assign
l_int|0x334
suffix:semicolon
id|func
op_assign
id|FITOQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0cd
suffix:colon
id|type
op_assign
l_int|0x334
suffix:semicolon
id|func
op_assign
id|FSTOQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0ce
suffix:colon
id|type
op_assign
l_int|0x338
suffix:semicolon
id|func
op_assign
id|FDTOQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0d3
suffix:colon
id|type
op_assign
l_int|0x31c
suffix:semicolon
id|func
op_assign
id|FQTOI
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* SUBNORMAL - ftt == 2 */
r_case
l_int|0x029
suffix:colon
id|type
op_assign
l_int|0x214
suffix:semicolon
id|func
op_assign
id|FSQRTS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02a
suffix:colon
id|type
op_assign
l_int|0x228
suffix:semicolon
id|func
op_assign
id|FSQRTD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x041
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FADDS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x042
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FADDD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x045
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FSUBS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x046
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FSUBD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x049
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FMULS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04a
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FMULD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04d
suffix:colon
id|type
op_assign
l_int|0x215
suffix:semicolon
id|func
op_assign
id|FDIVS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04e
suffix:colon
id|type
op_assign
l_int|0x22a
suffix:semicolon
id|func
op_assign
id|FDIVD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x069
suffix:colon
id|type
op_assign
l_int|0x225
suffix:semicolon
id|func
op_assign
id|FSMULD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0c6
suffix:colon
id|type
op_assign
l_int|0x218
suffix:semicolon
id|func
op_assign
id|FDTOS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0c9
suffix:colon
id|type
op_assign
l_int|0x224
suffix:semicolon
id|func
op_assign
id|FSTOD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0d1
suffix:colon
id|type
op_assign
l_int|0x214
suffix:semicolon
id|func
op_assign
id|FSTOI
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0d2
suffix:colon
id|type
op_assign
l_int|0x218
suffix:semicolon
id|func
op_assign
id|FDTOI
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG_MATHEMU         
id|printk
c_func
(paren
l_string|&quot;unknown FPop1: %03lx&bslash;n&quot;
comma
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
suffix:semicolon
macro_line|#endif         
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|insn
op_amp
l_int|0xc1f80000
)paren
op_eq
l_int|0x81a80000
)paren
multiline_comment|/* FPOP2 */
(brace
r_switch
c_cond
(paren
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
(brace
r_case
l_int|0x051
suffix:colon
id|type
op_assign
l_int|0x305
suffix:semicolon
id|func
op_assign
id|FCMPS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x052
suffix:colon
id|type
op_assign
l_int|0x30a
suffix:semicolon
id|func
op_assign
id|FCMPD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x053
suffix:colon
id|type
op_assign
l_int|0x30f
suffix:semicolon
id|func
op_assign
id|FCMPQ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x055
suffix:colon
id|type
op_assign
l_int|0x305
suffix:semicolon
id|func
op_assign
id|FCMPES
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x056
suffix:colon
id|type
op_assign
l_int|0x30a
suffix:semicolon
id|func
op_assign
id|FCMPED
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x057
suffix:colon
id|type
op_assign
l_int|0x30f
suffix:semicolon
id|func
op_assign
id|FCMPEQ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG_MATHEMU         
id|printk
c_func
(paren
l_string|&quot;unknown FPop2: %03lx&bslash;n&quot;
comma
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x1ff
)paren
suffix:semicolon
macro_line|#endif         &t;
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|type
)paren
(brace
multiline_comment|/* oops, didn&squot;t recognise that FPop */
id|printk
c_func
(paren
l_string|&quot;attempt to emulate unrecognised FPop!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Decode the registers to be used */
id|freg
op_assign
(paren
op_star
id|fsr
op_rshift
l_int|14
)paren
op_amp
l_int|0xf
suffix:semicolon
op_star
id|fsr
op_and_assign
op_complement
l_int|0x1c000
suffix:semicolon
multiline_comment|/* clear the traptype bits */
id|freg
op_assign
(paren
(paren
id|insn
op_rshift
l_int|14
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
l_int|0x3
)paren
multiline_comment|/* is rs1 single, double or quad? */
(brace
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
(brace
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
multiline_comment|/* doublewords must have bit 5 zeroed */
(brace
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|rs1
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
id|freg
op_assign
(paren
id|insn
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|2
)paren
op_amp
l_int|0x3
)paren
(brace
multiline_comment|/* same again for rs2 */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
(brace
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
multiline_comment|/* doublewords must have bit 5 zeroed */
(brace
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|rs2
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
id|freg
op_assign
(paren
(paren
id|insn
op_rshift
l_int|25
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|type
op_rshift
l_int|4
)paren
op_amp
l_int|0x3
)paren
multiline_comment|/* and finally rd. This one&squot;s a bit different */
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* dest is fcc. (this must be FCMPQ or FCMPEQ) */
r_if
c_cond
(paren
id|freg
)paren
multiline_comment|/* V8 has only one set of condition codes, so */
(brace
multiline_comment|/* anything but 0 in the rd field is an error */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
multiline_comment|/* (should probably flag as invalid opcode */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* but SIGFPE will do :-&gt; ) */
)brace
id|rd
op_assign
(paren
r_void
op_star
)paren
(paren
id|fsr
)paren
suffix:semicolon
multiline_comment|/* FCMPQ and FCMPEQ are special and only  */
r_break
suffix:semicolon
multiline_comment|/* set bits they&squot;re supposed to :-&gt; */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|3
)paren
multiline_comment|/* quadwords must have bits 4&amp;5 of the */
(brace
multiline_comment|/* encoded reg. number set to zero. */
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* simulate invalid_fp_register exception */
)brace
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|freg
op_amp
l_int|1
)paren
multiline_comment|/* doublewords must have bit 5 zeroed */
(brace
op_star
id|fsr
op_or_assign
(paren
l_int|6
op_lshift
l_int|14
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
l_int|1
suffix:colon
id|rd
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fregs
(braket
id|freg
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MATHEMU   
id|printk
c_func
(paren
l_string|&quot;executing insn...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif   
id|func
c_func
(paren
id|rd
comma
id|rs2
comma
id|rs1
)paren
suffix:semicolon
multiline_comment|/* do the Right Thing */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* success! */
)brace
eof
