multiline_comment|/* Machine-dependent software floating-point definitions.  Sparc version.&n;   Copyright (C) 1997 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Library General Public License as&n;   published by the Free Software Foundation; either version 2 of the&n;   License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;   Library General Public License for more details.&n;&n;   You should have received a copy of the GNU Library General Public&n;   License along with the GNU C Library; see the file COPYING.LIB.  If&n;   not, write to the Free Software Foundation, Inc.,&n;   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  &n;&n;   Actually, this is a sparc (32bit) version, written based on the&n;   i386 and sparc64 versions, by me, &n;   Peter Maydell (pmaydell@chiark.greenend.org.uk).&n;   Comments are by and large also mine, although they may be inaccurate.&n;&n;   In picking out asm fragments I&squot;ve gone with the lowest common&n;   denominator, which also happens to be the hardware I have :-&gt;&n;   That is, a SPARC without hardware multiply and divide.&n; */
multiline_comment|/* basic word size definitions */
DECL|macro|_FP_W_TYPE_SIZE
mdefine_line|#define _FP_W_TYPE_SIZE&t;&t;32
DECL|macro|_FP_W_TYPE
mdefine_line|#define _FP_W_TYPE&t;&t;unsigned long
DECL|macro|_FP_WS_TYPE
mdefine_line|#define _FP_WS_TYPE&t;&t;signed long
DECL|macro|_FP_I_TYPE
mdefine_line|#define _FP_I_TYPE&t;&t;long
multiline_comment|/* You can optionally code some things like addition in asm. For&n; * example, i386 defines __FP_FRAC_ADD_2 as asm. If you don&squot;t&n; * then you get a fragment of C code [if you change an #ifdef 0&n; * in op-2.h] or a call to add_ssaaaa (see below).&n; * Good places to look for asm fragments to use are gcc and glibc.&n; * gcc&squot;s longlong.h is useful.&n; */
multiline_comment|/* We need to know how to multiply and divide. If the host word size&n; * is &gt;= 2*fracbits you can use FP_MUL_MEAT_n_imm(t,R,X,Y) which&n; * codes the multiply with whatever gcc does to &squot;a * b&squot;.&n; * _FP_MUL_MEAT_n_wide(t,R,X,Y,f) is used when you have an asm &n; * function that can multiply two 1W values and get a 2W result. &n; * Otherwise you&squot;re stuck with _FP_MUL_MEAT_n_hard(t,R,X,Y) which&n; * does bitshifting to avoid overflow.&n; * For division there is FP_DIV_MEAT_n_imm(t,R,X,Y,f) for word size&n; * &gt;= 2*fracbits, where f is either _FP_DIV_HELP_imm or &n; * _FP_DIV_HELP_ldiv (see op-1.h).&n; * _FP_DIV_MEAT_udiv() is if you have asm to do 2W/1W =&gt; (1W, 1W).&n; * [GCC and glibc have longlong.h which has the asm macro udiv_qrnnd&n; * to do this.]&n; * In general, &squot;n&squot; is the number of words required to hold the type,&n; * and &squot;t&squot; is either S, D or Q for single/double/quad.&n; *           -- PMM&n; */
multiline_comment|/* Example: SPARC64:&n; * #define _FP_MUL_MEAT_S(R,X,Y)&t;_FP_MUL_MEAT_1_imm(S,R,X,Y)&n; * #define _FP_MUL_MEAT_D(R,X,Y)&t;_FP_MUL_MEAT_1_wide(D,R,X,Y,umul_ppmm)&n; * #define _FP_MUL_MEAT_Q(R,X,Y)&t;_FP_MUL_MEAT_2_wide(Q,R,X,Y,umul_ppmm)&n; *&n; * #define _FP_DIV_MEAT_S(R,X,Y)&t;_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)&n; * #define _FP_DIV_MEAT_D(R,X,Y)&t;_FP_DIV_MEAT_1_udiv(D,R,X,Y)&n; * #define _FP_DIV_MEAT_Q(R,X,Y)&t;_FP_DIV_MEAT_2_udiv_64(Q,R,X,Y)&n; *&n; * Example: i386:&n; * #define _FP_MUL_MEAT_S(R,X,Y)   _FP_MUL_MEAT_1_wide(S,R,X,Y,_i386_mul_32_64)&n; * #define _FP_MUL_MEAT_D(R,X,Y)   _FP_MUL_MEAT_2_wide(D,R,X,Y,_i386_mul_32_64)&n; *&n; * #define _FP_DIV_MEAT_S(R,X,Y)   _FP_DIV_MEAT_1_udiv(S,R,X,Y,_i386_div_64_32)&n; * #define _FP_DIV_MEAT_D(R,X,Y)   _FP_DIV_MEAT_2_udiv_64(D,R,X,Y)&n; */
DECL|macro|_FP_MUL_MEAT_S
mdefine_line|#define _FP_MUL_MEAT_S(R,X,Y)   _FP_MUL_MEAT_1_wide(S,R,X,Y,umul_ppmm)
DECL|macro|_FP_MUL_MEAT_D
mdefine_line|#define _FP_MUL_MEAT_D(R,X,Y)   _FP_MUL_MEAT_2_wide(D,R,X,Y,umul_ppmm)
multiline_comment|/* FIXME: This is not implemented, but should be soon */
DECL|macro|_FP_MUL_MEAT_Q
mdefine_line|#define _FP_MUL_MEAT_Q(R,X,Y)   _FP_FRAC_SET_4(R, _FP_ZEROFRAC_4)
DECL|macro|_FP_DIV_MEAT_S
mdefine_line|#define _FP_DIV_MEAT_S(R,X,Y)   _FP_DIV_MEAT_1_udiv(S,R,X,Y)
DECL|macro|_FP_DIV_MEAT_D
mdefine_line|#define _FP_DIV_MEAT_D(R,X,Y)   _FP_DIV_MEAT_2_udiv_64(D,R,X,Y)
multiline_comment|/* FIXME: This is not implemented, but should be soon */
DECL|macro|_FP_DIV_MEAT_Q
mdefine_line|#define _FP_DIV_MEAT_Q(R,X,Y)   _FP_FRAC_SET_4(R, _FP_ZEROFRAC_4)
multiline_comment|/* These macros define what NaN looks like. They&squot;re supposed to expand to &n; * a comma-separated set of 32bit unsigned ints that encode NaN.&n; */
DECL|macro|_FP_NANFRAC_S
mdefine_line|#define _FP_NANFRAC_S&t;&t;_FP_QNANBIT_S
DECL|macro|_FP_NANFRAC_D
mdefine_line|#define _FP_NANFRAC_D&t;&t;_FP_QNANBIT_D, 0
DECL|macro|_FP_NANFRAC_Q
mdefine_line|#define _FP_NANFRAC_Q           _FP_QNANBIT_Q, 0, 0, 0
DECL|macro|_FP_KEEPNANFRACP
mdefine_line|#define _FP_KEEPNANFRACP 1
multiline_comment|/* This macro appears to be called when both X and Y are NaNs, and &n; * has to choose one and copy it to R. i386 goes for the larger of the&n; * two, sparc64 just picks Y. I don&squot;t understand this at all so I&squot;ll&n; * go with sparc64 because it&squot;s shorter :-&gt;   -- PMM &n; */
DECL|macro|_FP_CHOOSENAN
mdefine_line|#define _FP_CHOOSENAN(fs, wc, R, X, Y)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R,Y);&t;&t;&t;&t;&t;&bslash;&n;    R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_UNPACK_RAW_1
mdefine_line|#define __FP_UNPACK_RAW_1(fs, X, val)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    union _FP_UNION_##fs *_flo =&t;&t;&t;&t;&bslash;&n;    &t;(union _FP_UNION_##fs *)val;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_f = _flo-&gt;bits.frac;&t;&t;&t;&t;&t;&bslash;&n;    X##_e = _flo-&gt;bits.exp;&t;&t;&t;&t;&t;&bslash;&n;    X##_s = _flo-&gt;bits.sign;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_PACK_RAW_1
mdefine_line|#define __FP_PACK_RAW_1(fs, val, X)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    union _FP_UNION_##fs *_flo =&t;&t;&t;&t;&bslash;&n;    &t;(union _FP_UNION_##fs *)val;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.frac = X##_f;&t;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.exp  = X##_e;&t;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.sign = X##_s;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_UNPACK_RAW_2
mdefine_line|#define __FP_UNPACK_RAW_2(fs, X, val)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    union _FP_UNION_##fs *_flo =&t;&t;&t;&bslash;&n;    &t;(union _FP_UNION_##fs *)val;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_f0 = _flo-&gt;bits.frac0;&t;&t;&t;&t;&bslash;&n;    X##_f1 = _flo-&gt;bits.frac1;&t;&t;&t;&t;&bslash;&n;    X##_e  = _flo-&gt;bits.exp;&t;&t;&t;&t;&bslash;&n;    X##_s  = _flo-&gt;bits.sign;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_PACK_RAW_2
mdefine_line|#define __FP_PACK_RAW_2(fs, val, X)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    union _FP_UNION_##fs *_flo =&t;&t;&t;&bslash;&n;    &t;(union _FP_UNION_##fs *)val;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.frac0 = X##_f0;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.frac1 = X##_f1;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.exp   = X##_e;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.sign  = X##_s;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_UNPACK_RAW_4
mdefine_line|#define __FP_UNPACK_RAW_4(fs, X, val)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    union _FP_UNION_##fs *_flo =&t;&t;&t;&bslash;&n;    &t;(union _FP_UNION_##fs *)val;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_f[0] = _flo-&gt;bits.frac0;&t;&t;&t;&bslash;&n;    X##_f[1] = _flo-&gt;bits.frac1;&t;&t;&t;&bslash;&n;    X##_f[2] = _flo-&gt;bits.frac2;&t;&t;&t;&bslash;&n;    X##_f[3] = _flo-&gt;bits.frac3;&t;&t;&t;&bslash;&n;    X##_e  = _flo-&gt;bits.exp;&t;&t;&t;&t;&bslash;&n;    X##_s  = _flo-&gt;bits.sign;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_PACK_RAW_4
mdefine_line|#define __FP_PACK_RAW_4(fs, val, X)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    union _FP_UNION_##fs *_flo =&t;&t;&t;&bslash;&n;    &t;(union _FP_UNION_##fs *)val;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.frac0 = X##_f[0];&t;&t;&t;&bslash;&n;    _flo-&gt;bits.frac1 = X##_f[1];&t;&t;&t;&bslash;&n;    _flo-&gt;bits.frac2 = X##_f[2];&t;&t;&t;&bslash;&n;    _flo-&gt;bits.frac3 = X##_f[3];&t;&t;&t;&bslash;&n;    _flo-&gt;bits.exp   = X##_e;&t;&t;&t;&t;&bslash;&n;    _flo-&gt;bits.sign  = X##_s;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_UNPACK_S
mdefine_line|#define __FP_UNPACK_S(X,val)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    __FP_UNPACK_RAW_1(S,X,val);&t;&t;&bslash;&n;    _FP_UNPACK_CANONICAL(S,1,X);&t;&bslash;&n;  } while (0)
DECL|macro|__FP_PACK_S
mdefine_line|#define __FP_PACK_S(val,X)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    _FP_PACK_CANONICAL(S,1,X);&t;&t;&bslash;&n;    __FP_PACK_RAW_1(S,val,X);&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_UNPACK_D
mdefine_line|#define __FP_UNPACK_D(X,val)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    __FP_UNPACK_RAW_2(D,X,val);&t;&t;&bslash;&n;    _FP_UNPACK_CANONICAL(D,2,X);&t;&bslash;&n;  } while (0)
DECL|macro|__FP_PACK_D
mdefine_line|#define __FP_PACK_D(val,X)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    _FP_PACK_CANONICAL(D,2,X);&t;&t;&bslash;&n;    __FP_PACK_RAW_2(D,val,X);&t;&t;&bslash;&n;  } while (0)
DECL|macro|__FP_UNPACK_Q
mdefine_line|#define __FP_UNPACK_Q(X,val)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    __FP_UNPACK_RAW_4(Q,X,val);&t;&t;&bslash;&n;    _FP_UNPACK_CANONICAL(Q,4,X);&t;&bslash;&n;  } while (0)
DECL|macro|__FP_PACK_Q
mdefine_line|#define __FP_PACK_Q(val,X)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    _FP_PACK_CANONICAL(Q,4,X);&t;&t;&bslash;&n;    __FP_PACK_RAW_4(Q,val,X);&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* the asm fragments go here: all these are taken from glibc-2.0.5&squot;s stdlib/longlong.h */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
multiline_comment|/* add_ssaaaa is used in op-2.h and should be equivalent to&n; * #define add_ssaaaa(sh,sl,ah,al,bh,bl) (sh = ah+bh+ (( sl = al+bl) &lt; al))&n; * add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,&n; * high_addend_2, low_addend_2) adds two UWtype integers, composed by&n; * HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2&n; * respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow&n; * (i.e. carry out) is not stored anywhere, and is lost.&n; */
DECL|macro|add_ssaaaa
mdefine_line|#define add_ssaaaa(sh, sl, ah, al, bh, bl) &bslash;&n;  __asm__ (&quot;addcc %r4,%5,%1
id|addx
op_mod
id|r2
comma
op_mod
l_int|3
comma
op_mod
l_int|0
l_string|&quot;                                                 &bslash;&n;           : &quot;
op_assign
id|r
l_string|&quot; ((USItype)(sh)),                                      &bslash;&n;             &quot;
op_assign
op_amp
id|r
l_string|&quot; ((USItype)(sl))                                      &bslash;&n;           : &quot;
op_mod
id|rJ
l_string|&quot; ((USItype)(ah)),                                     &bslash;&n;             &quot;
id|rI
l_string|&quot; ((USItype)(bh)),                                      &bslash;&n;             &quot;
op_mod
id|rJ
l_string|&quot; ((USItype)(al)),                                     &bslash;&n;             &quot;
id|rI
l_string|&quot; ((USItype)(bl))                                       &bslash;&n;           : &quot;
id|cc
"&quot;"
)paren
multiline_comment|/* sub_ddmmss is used in op-2.h and udivmodti4.c and should be equivalent to&n; * #define sub_ddmmss(sh, sl, ah, al, bh, bl) (sh = ah-bh - ((sl = al-bl) &gt; al))&n; * sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,&n; * high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,&n; * composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and&n; * LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE&n; * and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,&n; * and is lost.&n; */
DECL|macro|sub_ddmmss
mdefine_line|#define sub_ddmmss(sh, sl, ah, al, bh, bl) &bslash;&n;  __asm__ (&quot;subcc %r4,%5,%1
id|subx
op_mod
id|r2
comma
op_mod
l_int|3
comma
op_mod
l_int|0
l_string|&quot;                                                 &bslash;&n;           : &quot;
op_assign
id|r
l_string|&quot; ((USItype)(sh)),                                      &bslash;&n;             &quot;
op_assign
op_amp
id|r
l_string|&quot; ((USItype)(sl))                                      &bslash;&n;           : &quot;
id|rJ
l_string|&quot; ((USItype)(ah)),                                      &bslash;&n;             &quot;
id|rI
l_string|&quot; ((USItype)(bh)),                                      &bslash;&n;             &quot;
id|rJ
l_string|&quot; ((USItype)(al)),                                      &bslash;&n;             &quot;
id|rI
l_string|&quot; ((USItype)(bl))                                       &bslash;&n;           : &quot;
id|cc
"&quot;"
)paren
multiline_comment|/* asm fragments for mul and div */
multiline_comment|/* umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two&n; * UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype&n; * word product in HIGH_PROD and LOW_PROD.&n; * These look ugly because the sun4/4c don&squot;t have umul/udiv/smul/sdiv in&n; * hardware. &n; */
DECL|macro|umul_ppmm
mdefine_line|#define umul_ppmm(w1, w0, u, v) &bslash;&n;  __asm__ (&quot;! Inlined umul_ppmm
id|wr
op_mod
op_mod
id|g0
comma
op_mod
l_int|2
comma
op_mod
op_mod
id|y
op_logical_neg
id|SPARC
id|has
l_int|0
op_minus
l_int|3
id|delay
id|insn
id|after
id|a
id|wr
id|sra
op_mod
l_int|3
comma
l_int|31
comma
op_mod
op_mod
id|g2
op_logical_neg
id|Don
"&squot;"
id|t
id|move
id|this
id|insn
op_logical_and
op_mod
l_int|2
comma
op_mod
op_mod
id|g2
comma
op_mod
op_mod
id|g2
op_logical_neg
id|Don
"&squot;"
id|t
id|move
id|this
id|insn
id|andcc
op_mod
op_mod
id|g0
comma
l_int|0
comma
op_mod
op_mod
id|g1
op_logical_neg
id|Don
"&squot;"
id|t
id|move
id|this
id|insn
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
op_mod
l_int|3
comma
op_mod
op_mod
id|g1
id|mulscc
op_mod
op_mod
id|g1
comma
l_int|0
comma
op_mod
op_mod
id|g1
id|add
op_mod
op_mod
id|g1
comma
op_mod
op_mod
id|g2
comma
op_mod
l_int|0
id|rd
op_mod
op_mod
id|y
comma
op_mod
l_int|1
l_string|&quot;                                                 &bslash;&n;           : &quot;
op_assign
id|r
l_string|&quot; ((USItype)(w1)),                                      &bslash;&n;             &quot;
op_assign
id|r
l_string|&quot; ((USItype)(w0))                                       &bslash;&n;           : &quot;
op_mod
id|rI
l_string|&quot; ((USItype)(u)),                                      &bslash;&n;             &quot;
id|r
l_string|&quot; ((USItype)(v))                                         &bslash;&n;           : &quot;
op_mod
id|g1
l_string|&quot;, &quot;
op_mod
id|g2
l_string|&quot;, &quot;
id|cc
"&quot;"
)paren
multiline_comment|/* udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,&n; * denominator) divides a UDWtype, composed by the UWtype integers&n; * HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient&n; * in QUOTIENT and the remainder in REMAINDER.  HIGH_NUMERATOR must be less&n; * than DENOMINATOR for correct operation.  If, in addition, the most&n; * significant bit of DENOMINATOR must be 1, then the pre-processor symbol&n; * UDIV_NEEDS_NORMALIZATION is defined to 1.&n; */
DECL|macro|udiv_qrnnd
mdefine_line|#define udiv_qrnnd(q, r, n1, n0, d) &bslash;&n;  __asm__ (&quot;! Inlined udiv_qrnnd
id|mov
l_int|32
comma
op_mod
op_mod
id|g1
id|subcc
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
op_mod
id|g0
l_int|1
suffix:colon
id|bcs
l_float|5f
id|addxcc
op_mod
l_int|0
comma
op_mod
l_int|0
comma
op_mod
l_int|0
op_logical_neg
id|shift
id|n1n0
op_logical_and
id|a
id|q
op_minus
id|bit
id|in
id|lsb
id|sub
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
l_int|1
op_logical_neg
id|this
id|kills
id|msb
id|of
id|n
id|addx
op_mod
l_int|1
comma
op_mod
l_int|1
comma
op_mod
l_int|1
op_logical_neg
id|so
id|this
id|can
"&squot;"
id|t
id|give
id|carry
id|subcc
op_mod
op_mod
id|g1
comma
l_int|1
comma
op_mod
op_mod
id|g1
l_int|2
suffix:colon
id|bne
l_int|1
id|b
id|subcc
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
op_mod
id|g0
id|bcs
l_float|3f
id|addxcc
op_mod
l_int|0
comma
op_mod
l_int|0
comma
op_mod
l_int|0
op_logical_neg
id|shift
id|n1n0
op_logical_and
id|a
id|q
op_minus
id|bit
id|in
id|lsb
id|b
l_float|3f
id|sub
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
l_int|1
op_logical_neg
id|this
id|kills
id|msb
id|of
id|n
l_int|4
suffix:colon
id|sub
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
l_int|1
l_int|5
suffix:colon
id|addxcc
op_mod
l_int|1
comma
op_mod
l_int|1
comma
op_mod
l_int|1
id|bcc
l_int|2
id|b
id|subcc
op_mod
op_mod
id|g1
comma
l_int|1
comma
op_mod
op_mod
id|g1
op_logical_neg
id|Got
id|carry
id|from
id|n
dot
id|Subtract
id|next
id|step
id|to
id|cancel
id|this
id|carry
dot
id|bne
l_int|4
id|b
id|addcc
op_mod
l_int|0
comma
op_mod
l_int|0
comma
op_mod
l_int|0
op_logical_neg
id|shift
id|n1n0
op_logical_and
id|a
l_int|0
op_minus
id|bit
id|in
id|lsb
id|sub
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
l_int|1
l_int|3
suffix:colon
id|xnor
op_mod
l_int|0
comma
l_int|0
comma
op_mod
l_int|0
op_logical_neg
id|End
id|of
r_inline
id|udiv_qrnnd
l_string|&quot;                                     &bslash;&n;           : &quot;
op_assign
op_amp
id|r
l_string|&quot; ((USItype) (q)),                                     &bslash;&n;             &quot;
op_assign
op_amp
id|r
l_string|&quot; ((USItype) (r))                                      &bslash;&n;           : &quot;
id|r
l_string|&quot; ((USItype) (d)),                                       &bslash;&n;             &quot;
l_int|1
l_string|&quot; ((USItype) (n1)),                                      &bslash;&n;             &quot;
l_int|0
l_string|&quot; ((USItype) (n0)) : &quot;
op_mod
id|g1
l_string|&quot;, &quot;
id|cc
"&quot;"
)paren
DECL|macro|UDIV_NEEDS_NORMALIZATION
mdefine_line|#define UDIV_NEEDS_NORMALIZATION 0
DECL|macro|abort
mdefine_line|#define abort()&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return 0
macro_line|#ifdef __BIG_ENDIAN
DECL|macro|__BYTE_ORDER
mdefine_line|#define __BYTE_ORDER __BIG_ENDIAN
macro_line|#else
DECL|macro|__BYTE_ORDER
mdefine_line|#define __BYTE_ORDER __LITTLE_ENDIAN
macro_line|#endif
eof
