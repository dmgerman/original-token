multiline_comment|/* $Id: pcic.c,v 1.20 2000/12/05 00:56:36 anton Exp $&n; * pcic.c: Sparc/PCI controller support&n; *&n; * Copyright (C) 1998 V. Roganov and G. Raiko&n; *&n; * Code is derived from Ultra/PCI PSYCHO controller support, see that&n; * for author info.&n; *&n; * Support for diverse IIep based platforms by Pete Zaitcev.&n; * CP-1200 by Eric Brower.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/ebus.h&gt;
macro_line|#include &lt;asm/sbus.h&gt; /* for sanity check... */
macro_line|#include &lt;asm/swift.h&gt; /* for cache flushing. */
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/pcic.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifndef CONFIG_PCI
DECL|function|sys_pciconfig_read
id|asmlinkage
r_int
id|sys_pciconfig_read
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|sys_pciconfig_write
id|asmlinkage
r_int
id|sys_pciconfig_write
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#else
macro_line|#ifdef CONFIG_SUN_JSFLASH
r_extern
r_int
id|jsflash_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|pcibios_fixups
r_struct
id|pci_fixup
id|pcibios_fixups
(braket
)braket
op_assign
(brace
(brace
l_int|0
)brace
)brace
suffix:semicolon
r_int
r_int
id|pcic_pin_to_irq
c_func
(paren
r_int
r_int
id|pin
comma
r_char
op_star
id|name
)paren
suffix:semicolon
multiline_comment|/*&n; * I studied different documents and many live PROMs both from 2.30&n; * family and 3.xx versions. I came to the amazing conclusion: there is&n; * absolutely no way to route interrupts in IIep systems relying on&n; * information which PROM presents. We must hardcode interrupt routing&n; * schematics. And this actually sucks.   -- zaitcev 1999/05/12&n; *&n; * To find irq for a device we determine which routing map&n; * is in effect or, in other words, on which machine we are running.&n; * We use PROM name for this although other techniques may be used&n; * in special cases (Gleb reports a PROMless IIep based system).&n; * Once we know the map we take device configuration address and&n; * find PCIC pin number where INT line goes. Then we may either program&n; * preferred irq into the PCIC or supply the preexisting irq to the device.&n; */
DECL|struct|pcic_ca2irq
r_struct
id|pcic_ca2irq
(brace
DECL|member|busno
r_int
r_char
id|busno
suffix:semicolon
multiline_comment|/* PCI bus number */
DECL|member|devfn
r_int
r_char
id|devfn
suffix:semicolon
multiline_comment|/* Configuration address */
DECL|member|pin
r_int
r_char
id|pin
suffix:semicolon
multiline_comment|/* PCIC external interrupt pin */
DECL|member|irq
r_int
r_char
id|irq
suffix:semicolon
multiline_comment|/* Preferred IRQ (mappable in PCIC) */
DECL|member|force
r_int
r_int
id|force
suffix:semicolon
multiline_comment|/* Enforce preferred IRQ */
)brace
suffix:semicolon
DECL|struct|pcic_sn2list
r_struct
id|pcic_sn2list
(brace
DECL|member|sysname
r_char
op_star
id|sysname
suffix:semicolon
DECL|member|intmap
r_struct
id|pcic_ca2irq
op_star
id|intmap
suffix:semicolon
DECL|member|mapdim
r_int
id|mapdim
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * JavaEngine-1 apparently has different versions.&n; *&n; * According to communications with Sun folks, for P2 build 501-4628-03:&n; * pin 0 - parallel, audio;&n; * pin 1 - Ethernet;&n; * pin 2 - su;&n; * pin 3 - PS/2 kbd and mouse.&n; *&n; * OEM manual (805-1486):&n; * pin 0: Ethernet&n; * pin 1: All EBus&n; * pin 2: IGA (unused)&n; * pin 3: Not connected&n; * OEM manual says that 501-4628 &amp; 501-4811 are the same thing,&n; * only the latter has NAND flash in place.&n; *&n; * So far unofficial Sun wins over the OEM manual. Poor OEMs...&n; */
DECL|variable|pcic_i_je1a
r_static
r_struct
id|pcic_ca2irq
id|pcic_i_je1a
(braket
)braket
op_assign
(brace
multiline_comment|/* 501-4811-03 */
(brace
l_int|0
comma
l_int|0x00
comma
l_int|2
comma
l_int|12
comma
l_int|0
)brace
comma
multiline_comment|/* EBus: hogs all */
(brace
l_int|0
comma
l_int|0x01
comma
l_int|1
comma
l_int|6
comma
l_int|1
)brace
comma
multiline_comment|/* Happy Meal */
(brace
l_int|0
comma
l_int|0x80
comma
l_int|0
comma
l_int|7
comma
l_int|0
)brace
comma
multiline_comment|/* IGA (unused) */
)brace
suffix:semicolon
multiline_comment|/* XXX JS-E entry is incomplete - PCI Slot 2 address (pin 7)? */
DECL|variable|pcic_i_jse
r_static
r_struct
id|pcic_ca2irq
id|pcic_i_jse
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|13
comma
l_int|0
)brace
comma
multiline_comment|/* Ebus - serial and keyboard */
(brace
l_int|0
comma
l_int|0x01
comma
l_int|1
comma
l_int|6
comma
l_int|0
)brace
comma
multiline_comment|/* hme */
(brace
l_int|0
comma
l_int|0x08
comma
l_int|2
comma
l_int|9
comma
l_int|0
)brace
comma
multiline_comment|/* VGA - we hope not used :) */
(brace
l_int|0
comma
l_int|0x10
comma
l_int|6
comma
l_int|8
comma
l_int|0
)brace
comma
multiline_comment|/* PCI INTA# in Slot 1 */
(brace
l_int|0
comma
l_int|0x18
comma
l_int|7
comma
l_int|12
comma
l_int|0
)brace
comma
multiline_comment|/* PCI INTA# in Slot 2, shared w. RTC */
(brace
l_int|0
comma
l_int|0x38
comma
l_int|4
comma
l_int|9
comma
l_int|0
)brace
comma
multiline_comment|/* All ISA devices. Read 8259. */
(brace
l_int|0
comma
l_int|0x80
comma
l_int|5
comma
l_int|11
comma
l_int|0
)brace
comma
multiline_comment|/* EIDE */
multiline_comment|/* {0,0x88, 0,0,0} - unknown device... PMU? Probably no interrupt. */
(brace
l_int|0
comma
l_int|0xA0
comma
l_int|4
comma
l_int|9
comma
l_int|0
)brace
comma
multiline_comment|/* USB */
multiline_comment|/*&n;&t; * Some pins belong to non-PCI devices, we hardcode them in drivers.&n;&t; * sun4m timers - irq 10, 14&n;&t; * PC style RTC - pin 7, irq 4 ?&n;&t; * Smart card, Parallel - pin 4 shared with USB, ISA&n;&t; * audio - pin 3, irq 5 ?&n;&t; */
)brace
suffix:semicolon
multiline_comment|/* SPARCengine-6 was the original release name of CP1200.&n; * The documentation differs between the two versions&n; */
DECL|variable|pcic_i_se6
r_static
r_struct
id|pcic_ca2irq
id|pcic_i_se6
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0x08
comma
l_int|0
comma
l_int|2
comma
l_int|0
)brace
comma
multiline_comment|/* SCSI&t;*/
(brace
l_int|0
comma
l_int|0x01
comma
l_int|1
comma
l_int|6
comma
l_int|0
)brace
comma
multiline_comment|/* HME&t;*/
(brace
l_int|0
comma
l_int|0x00
comma
l_int|3
comma
l_int|13
comma
l_int|0
)brace
comma
multiline_comment|/* EBus&t;*/
)brace
suffix:semicolon
multiline_comment|/*&n; * Krups (courtesy of Varol Kaptan)&n; * No documentation available, but it was easy to guess&n; * because it was very similar to Espresso.&n; *  &n; * pin 0 - kbd, mouse, serial;&n; * pin 1 - Ethernet;&n; * pin 2 - igs (we do not use it);&n; * pin 3 - audio;&n; * pin 4,5,6 - unused;&n; * pin 7 - RTC (from P2 onwards as David B. says).&n; */
DECL|variable|pcic_i_jk
r_static
r_struct
id|pcic_ca2irq
id|pcic_i_jk
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0x00
comma
l_int|0
comma
l_int|13
comma
l_int|0
)brace
comma
multiline_comment|/* Ebus - serial and keyboard */
(brace
l_int|0
comma
l_int|0x01
comma
l_int|1
comma
l_int|6
comma
l_int|0
)brace
comma
multiline_comment|/* hme */
)brace
suffix:semicolon
multiline_comment|/*&n; * Several entries in this list may point to the same routing map&n; * as several PROMs may be installed on the same physical board.&n; */
DECL|macro|SN2L_INIT
mdefine_line|#define SN2L_INIT(name, map)&t;&bslash;&n;  { name, map, sizeof(map)/sizeof(struct pcic_ca2irq) }
DECL|variable|pcic_known_sysnames
r_static
r_struct
id|pcic_sn2list
id|pcic_known_sysnames
(braket
)braket
op_assign
(brace
id|SN2L_INIT
c_func
(paren
l_string|&quot;SUNW,JavaEngine1&quot;
comma
id|pcic_i_je1a
)paren
comma
multiline_comment|/* JE1, PROM 2.32 */
id|SN2L_INIT
c_func
(paren
l_string|&quot;SUNW,JS-E&quot;
comma
id|pcic_i_jse
)paren
comma
multiline_comment|/* PROLL JavaStation-E */
id|SN2L_INIT
c_func
(paren
l_string|&quot;SUNW,SPARCengine-6&quot;
comma
id|pcic_i_se6
)paren
comma
multiline_comment|/* SPARCengine-6/CP-1200 */
id|SN2L_INIT
c_func
(paren
l_string|&quot;SUNW,JS-NC&quot;
comma
id|pcic_i_jk
)paren
comma
multiline_comment|/* PROLL JavaStation-NC */
id|SN2L_INIT
c_func
(paren
l_string|&quot;SUNW,JSIIep&quot;
comma
id|pcic_i_jk
)paren
comma
multiline_comment|/* OBP JavaStation-NC */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Only one PCIC per IIep,&n; * and since we have no SMP IIep, only one per system.&n; */
DECL|variable|pcic0_up
r_static
r_int
id|pcic0_up
op_assign
l_int|0
suffix:semicolon
DECL|variable|pcic0
r_static
r_struct
id|linux_pcic
id|pcic0
suffix:semicolon
DECL|variable|pcic_regs
r_int
r_int
id|pcic_regs
suffix:semicolon
DECL|variable|pcic_speculative
r_volatile
r_int
id|pcic_speculative
suffix:semicolon
DECL|variable|pcic_trapped
r_volatile
r_int
id|pcic_trapped
suffix:semicolon
r_static
r_void
id|pci_do_gettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
suffix:semicolon
r_static
r_void
id|pci_do_settimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
suffix:semicolon
DECL|macro|CONFIG_CMD
mdefine_line|#define CONFIG_CMD(bus, device_fn, where) (0x80000000 | (((unsigned int)bus) &lt;&lt; 16) | (((unsigned int)device_fn) &lt;&lt; 8) | (where &amp; ~3))
r_static
r_int
id|pcic_read_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u32
op_star
id|value
)paren
suffix:semicolon
r_static
r_int
id|pcic_write_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u32
id|value
)paren
suffix:semicolon
DECL|function|pcic_read_config_byte
r_static
r_int
id|pcic_read_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u8
op_star
id|value
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
id|pcic_read_config_dword
c_func
(paren
id|dev
comma
id|where
op_amp
op_complement
l_int|3
comma
op_amp
id|v
)paren
suffix:semicolon
op_star
id|value
op_assign
l_int|0xff
op_amp
(paren
id|v
op_rshift
(paren
l_int|8
op_star
(paren
id|where
op_amp
l_int|3
)paren
)paren
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcic_read_config_word
r_static
r_int
id|pcic_read_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u16
op_star
id|value
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|where
op_amp
l_int|1
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
id|pcic_read_config_dword
c_func
(paren
id|dev
comma
id|where
op_amp
op_complement
l_int|3
comma
op_amp
id|v
)paren
suffix:semicolon
op_star
id|value
op_assign
l_int|0xffff
op_amp
(paren
id|v
op_rshift
(paren
l_int|8
op_star
(paren
id|where
op_amp
l_int|3
)paren
)paren
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcic_read_config_dword
r_static
r_int
id|pcic_read_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u32
op_star
id|value
)paren
(brace
r_int
r_char
id|bus
op_assign
id|dev-&gt;bus-&gt;number
suffix:semicolon
r_int
r_char
id|device_fn
op_assign
id|dev-&gt;devfn
suffix:semicolon
multiline_comment|/* unsigned char where; */
r_struct
id|linux_pcic
op_star
id|pcic
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|where
op_amp
l_int|3
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_ne
l_int|0
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
id|pcic
op_assign
op_amp
id|pcic0
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if 0 /* does not fail here */
id|pcic_speculative
op_assign
l_int|1
suffix:semicolon
id|pcic_trapped
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|writel
c_func
(paren
id|CONFIG_CMD
c_func
(paren
id|bus
comma
id|device_fn
comma
id|where
)paren
comma
id|pcic-&gt;pcic_config_space_addr
)paren
suffix:semicolon
macro_line|#if 0 /* does not fail here */
id|nop
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcic_trapped
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|value
op_assign
op_complement
l_int|0
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
macro_line|#endif
id|pcic_speculative
op_assign
l_int|2
suffix:semicolon
id|pcic_trapped
op_assign
l_int|0
suffix:semicolon
op_star
id|value
op_assign
id|readl
c_func
(paren
id|pcic-&gt;pcic_config_space_data
op_plus
(paren
id|where
op_amp
l_int|4
)paren
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcic_trapped
)paren
(brace
id|pcic_speculative
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|value
op_assign
op_complement
l_int|0
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
id|pcic_speculative
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|pcic_write_config_byte
r_static
r_int
id|pcic_write_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u8
id|value
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
id|pcic_read_config_dword
c_func
(paren
id|dev
comma
id|where
op_amp
op_complement
l_int|3
comma
op_amp
id|v
)paren
suffix:semicolon
id|v
op_assign
(paren
id|v
op_amp
op_complement
(paren
l_int|0xff
op_lshift
(paren
l_int|8
op_star
(paren
id|where
op_amp
l_int|3
)paren
)paren
)paren
)paren
op_or
(paren
(paren
l_int|0xff
op_amp
(paren
r_int
)paren
id|value
)paren
op_lshift
(paren
l_int|8
op_star
(paren
id|where
op_amp
l_int|3
)paren
)paren
)paren
suffix:semicolon
r_return
id|pcic_write_config_dword
c_func
(paren
id|dev
comma
id|where
op_amp
op_complement
l_int|3
comma
id|v
)paren
suffix:semicolon
)brace
DECL|function|pcic_write_config_word
r_static
r_int
id|pcic_write_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u16
id|value
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|where
op_amp
l_int|1
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
id|pcic_read_config_dword
c_func
(paren
id|dev
comma
id|where
op_amp
op_complement
l_int|3
comma
op_amp
id|v
)paren
suffix:semicolon
id|v
op_assign
(paren
id|v
op_amp
op_complement
(paren
l_int|0xffff
op_lshift
(paren
l_int|8
op_star
(paren
id|where
op_amp
l_int|3
)paren
)paren
)paren
)paren
op_or
(paren
(paren
l_int|0xffff
op_amp
(paren
r_int
)paren
id|value
)paren
op_lshift
(paren
l_int|8
op_star
(paren
id|where
op_amp
l_int|3
)paren
)paren
)paren
suffix:semicolon
r_return
id|pcic_write_config_dword
c_func
(paren
id|dev
comma
id|where
op_amp
op_complement
l_int|3
comma
id|v
)paren
suffix:semicolon
)brace
DECL|function|pcic_write_config_dword
r_static
r_int
id|pcic_write_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|where
comma
id|u32
id|value
)paren
(brace
r_int
r_char
id|bus
op_assign
id|dev-&gt;bus-&gt;number
suffix:semicolon
r_int
r_char
id|devfn
op_assign
id|dev-&gt;devfn
suffix:semicolon
r_struct
id|linux_pcic
op_star
id|pcic
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|where
op_amp
l_int|3
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_ne
l_int|0
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
id|pcic
op_assign
op_amp
id|pcic0
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|writel
c_func
(paren
id|CONFIG_CMD
c_func
(paren
id|bus
comma
id|devfn
comma
id|where
)paren
comma
id|pcic-&gt;pcic_config_space_addr
)paren
suffix:semicolon
id|writel
c_func
(paren
id|value
comma
id|pcic-&gt;pcic_config_space_data
op_plus
(paren
id|where
op_amp
l_int|4
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|variable|pcic_ops
r_static
r_struct
id|pci_ops
id|pcic_ops
op_assign
(brace
id|pcic_read_config_byte
comma
id|pcic_read_config_word
comma
id|pcic_read_config_dword
comma
id|pcic_write_config_byte
comma
id|pcic_write_config_word
comma
id|pcic_write_config_dword
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * On sparc64 pcibios_init() calls pci_controller_probe().&n; * We want PCIC probed little ahead so that interrupt controller&n; * would be operational.&n; */
DECL|function|pcic_probe
r_int
id|__init
id|pcic_probe
c_func
(paren
r_void
)paren
(brace
r_struct
id|linux_pcic
op_star
id|pcic
suffix:semicolon
r_struct
id|linux_prom_registers
id|regs
(braket
id|PROMREG_MAX
)braket
suffix:semicolon
r_struct
id|linux_pbm_info
op_star
id|pbm
suffix:semicolon
r_char
id|namebuf
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|node
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|pcic0_up
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PCIC: called twice!&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|pcic
op_assign
op_amp
id|pcic0
suffix:semicolon
id|node
op_assign
id|prom_getchild
(paren
id|prom_root_node
)paren
suffix:semicolon
id|node
op_assign
id|prom_searchsiblings
(paren
id|node
comma
l_string|&quot;pci&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Map in PCIC register set, config space, and IO base&n;&t; */
id|err
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
id|regs
comma
r_sizeof
(paren
id|regs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
op_logical_or
id|err
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PCIC: Error, cannot get PCIC registers &quot;
l_string|&quot;from PROM.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|pcic0_up
op_assign
l_int|1
suffix:semicolon
id|pcic-&gt;pcic_res_regs.name
op_assign
l_string|&quot;pcic_registers&quot;
suffix:semicolon
id|pcic-&gt;pcic_regs
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|regs
(braket
l_int|0
)braket
dot
id|phys_addr
comma
id|regs
(braket
l_int|0
)braket
dot
id|reg_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcic-&gt;pcic_regs
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PCIC: Error, cannot map PCIC registers.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|pcic-&gt;pcic_res_io.name
op_assign
l_string|&quot;pcic_io&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcic-&gt;pcic_io
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|regs
(braket
l_int|1
)braket
dot
id|phys_addr
comma
l_int|0x10000
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PCIC: Error, cannot map PCIC IO Base.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|pcic-&gt;pcic_res_cfg_addr.name
op_assign
l_string|&quot;pcic_cfg_addr&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcic-&gt;pcic_config_space_addr
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|regs
(braket
l_int|2
)braket
dot
id|phys_addr
comma
id|regs
(braket
l_int|2
)braket
dot
id|reg_size
op_star
l_int|2
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PCIC: Error, cannot map&quot;
l_string|&quot;PCI Configuration Space Address.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Docs say three least significant bits in address and data&n;&t; * must be the same. Thus, we need adjust size of data.&n;&t; */
id|pcic-&gt;pcic_res_cfg_data.name
op_assign
l_string|&quot;pcic_cfg_data&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcic-&gt;pcic_config_space_data
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|regs
(braket
l_int|3
)braket
dot
id|phys_addr
comma
id|regs
(braket
l_int|3
)braket
dot
id|reg_size
op_star
l_int|2
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PCIC: Error, cannot map&quot;
l_string|&quot;PCI Configuration Space Data.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|pbm
op_assign
op_amp
id|pcic-&gt;pbm
suffix:semicolon
id|pbm-&gt;prom_node
op_assign
id|node
suffix:semicolon
id|prom_getstring
c_func
(paren
id|node
comma
l_string|&quot;name&quot;
comma
id|namebuf
comma
l_int|63
)paren
suffix:semicolon
id|namebuf
(braket
l_int|63
)braket
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|pbm-&gt;prom_name
comma
id|namebuf
)paren
suffix:semicolon
(brace
r_extern
r_volatile
r_int
id|t_nmi
(braket
l_int|1
)braket
suffix:semicolon
r_extern
r_int
id|pcic_nmi_trap_patch
(braket
l_int|1
)braket
suffix:semicolon
id|t_nmi
(braket
l_int|0
)braket
op_assign
id|pcic_nmi_trap_patch
(braket
l_int|0
)braket
suffix:semicolon
id|t_nmi
(braket
l_int|1
)braket
op_assign
id|pcic_nmi_trap_patch
(braket
l_int|1
)braket
suffix:semicolon
id|t_nmi
(braket
l_int|2
)braket
op_assign
id|pcic_nmi_trap_patch
(braket
l_int|2
)braket
suffix:semicolon
id|t_nmi
(braket
l_int|3
)braket
op_assign
id|pcic_nmi_trap_patch
(braket
l_int|3
)braket
suffix:semicolon
id|swift_flush_dcache
c_func
(paren
)paren
suffix:semicolon
id|pcic_regs
op_assign
id|pcic-&gt;pcic_regs
suffix:semicolon
)brace
id|prom_getstring
c_func
(paren
id|prom_root_node
comma
l_string|&quot;name&quot;
comma
id|namebuf
comma
l_int|63
)paren
suffix:semicolon
id|namebuf
(braket
l_int|63
)braket
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|pcic_sn2list
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|pcic_known_sysnames
suffix:semicolon
id|p-&gt;sysname
op_ne
l_int|NULL
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|namebuf
comma
id|p-&gt;sysname
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|pcic-&gt;pcic_imap
op_assign
id|p-&gt;intmap
suffix:semicolon
id|pcic-&gt;pcic_imdim
op_assign
id|p-&gt;mapdim
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcic-&gt;pcic_imap
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We do not panic here for the sake of embedded systems.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;PCIC: System %s is unknown, cannot route interrupts&bslash;n&quot;
comma
id|namebuf
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pcic_pbm_scan_bus
r_static
r_void
id|__init
id|pcic_pbm_scan_bus
c_func
(paren
r_struct
id|linux_pcic
op_star
id|pcic
)paren
(brace
r_struct
id|linux_pbm_info
op_star
id|pbm
op_assign
op_amp
id|pcic-&gt;pbm
suffix:semicolon
id|pbm-&gt;pci_bus
op_assign
id|pci_scan_bus
c_func
(paren
id|pbm-&gt;pci_first_busno
comma
op_amp
id|pcic_ops
comma
id|pbm
)paren
suffix:semicolon
macro_line|#if 0 /* deadwood transplanted from sparc64 */
id|pci_fill_in_pbm_cookies
c_func
(paren
id|pbm-&gt;pci_bus
comma
id|pbm
comma
id|pbm-&gt;prom_node
)paren
suffix:semicolon
id|pci_record_assignments
c_func
(paren
id|pbm
comma
id|pbm-&gt;pci_bus
)paren
suffix:semicolon
id|pci_assign_unassigned
c_func
(paren
id|pbm
comma
id|pbm-&gt;pci_bus
)paren
suffix:semicolon
id|pci_fixup_irq
c_func
(paren
id|pbm
comma
id|pbm-&gt;pci_bus
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Main entry point from the PCI subsystem.&n; */
DECL|function|pcibios_init
r_void
id|__init
id|pcibios_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|linux_pcic
op_star
id|pcic
suffix:semicolon
multiline_comment|/*&n;&t; * PCIC should be initialized at start of the timer.&n;&t; * So, here we report the presence of PCIC and do some magic passes.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pcic0_up
)paren
(brace
r_return
suffix:semicolon
)brace
id|pcic
op_assign
op_amp
id|pcic0
suffix:semicolon
multiline_comment|/*&n;&t; *      Switch off IOTLB translation.&n;&t; */
id|writeb
c_func
(paren
id|PCI_DVMA_CONTROL_IOTLB_DISABLE
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_DVMA_CONTROL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      Increase mapped size for PCI memory space (DMA access).&n;&t; *      Should be done in that order (size first, address second).&n;&t; *      Why we couldn&squot;t set up 4GB and forget about it? XXX&n;&t; */
id|writel
c_func
(paren
l_int|0xF0000000UL
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_SIZE_0
)paren
suffix:semicolon
id|writel
c_func
(paren
l_int|0
op_plus
id|PCI_BASE_ADDRESS_SPACE_MEMORY
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_BASE_ADDRESS_0
)paren
suffix:semicolon
id|pcic_pbm_scan_bus
c_func
(paren
id|pcic
)paren
suffix:semicolon
id|ebus_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SUN_JSFLASH
id|jsflash_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|pcic_present
r_int
id|pcic_present
c_func
(paren
r_void
)paren
(brace
r_return
id|pcic0_up
suffix:semicolon
)brace
DECL|function|pdev_to_pnode
r_static
r_int
id|__init
id|pdev_to_pnode
c_func
(paren
r_struct
id|linux_pbm_info
op_star
id|pbm
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|linux_prom_pci_registers
id|regs
(braket
id|PROMREG_MAX
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|node
op_assign
id|prom_getchild
c_func
(paren
id|pbm-&gt;prom_node
)paren
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
id|err
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|regs
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|regs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
op_logical_and
id|err
op_ne
op_minus
l_int|1
)paren
(brace
r_int
r_int
id|devfn
op_assign
(paren
id|regs
(braket
l_int|0
)braket
dot
id|which_io
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|devfn
op_eq
id|pdev-&gt;devfn
)paren
(brace
r_return
id|node
suffix:semicolon
)brace
)brace
id|node
op_assign
id|prom_getsibling
c_func
(paren
id|node
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pci_devcookie_alloc
r_static
r_inline
r_struct
id|pcidev_cookie
op_star
id|pci_devcookie_alloc
c_func
(paren
r_void
)paren
(brace
r_return
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pcidev_cookie
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
DECL|function|pcic_map_pci_device
r_static
r_void
id|pcic_map_pci_device
c_func
(paren
r_struct
id|linux_pcic
op_star
id|pcic
comma
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|node
)paren
(brace
r_char
id|namebuf
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
l_int|0
op_logical_or
id|node
op_eq
op_minus
l_int|1
)paren
(brace
id|strcpy
c_func
(paren
id|namebuf
comma
l_string|&quot;???&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|prom_getstring
c_func
(paren
id|node
comma
l_string|&quot;name&quot;
comma
id|namebuf
comma
l_int|63
)paren
suffix:semicolon
id|namebuf
(braket
l_int|63
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
(brace
id|address
op_assign
id|dev-&gt;resource
(braket
id|j
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
id|address
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* are sequential */
id|flags
op_assign
id|dev-&gt;resource
(braket
id|j
)braket
dot
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IORESOURCE_IO
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|address
OL
l_int|0x10000
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * A device responds to I/O cycles on PCI.&n;&t;&t;&t;&t; * We generate these cycles with memory&n;&t;&t;&t;&t; * access into the fixed map (phys 0x30000000).&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Since a device driver does not want to&n;&t;&t;&t;&t; * do ioremap() before accessing PC-style I/O,&n;&t;&t;&t;&t; * we supply virtual, ready to access address.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Ebus devices do not come here even if&n;&t;&t;&t;&t; * CheerIO makes a similar conversion.&n;&t;&t;&t;&t; * See ebus.c for details.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Note that check_region()/request_region()&n;&t;&t;&t;&t; * work for these devices.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * XXX Neat trick, but it&squot;s a *bad* idea&n;&t;&t;&t;&t; * to shit into regions like that.&n;&t;&t;&t;&t; * What if we want to allocate one more&n;&t;&t;&t;&t; * PCI base address...&n;&t;&t;&t;&t; */
id|dev-&gt;resource
(braket
id|j
)braket
dot
id|start
op_assign
id|pcic-&gt;pcic_io
op_plus
id|address
suffix:semicolon
id|dev-&gt;resource
(braket
id|j
)braket
dot
id|end
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* XXX */
id|dev-&gt;resource
(braket
id|j
)braket
dot
id|flags
op_assign
(paren
id|flags
op_amp
op_complement
id|IORESOURCE_IO
)paren
op_or
id|IORESOURCE_MEM
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * OOPS... PCI Spec allows this. Sun does&n;&t;&t;&t;&t; * not have any devices getting above 64K&n;&t;&t;&t;&t; * so it must be user with a weird I/O&n;&t;&t;&t;&t; * board in a PCI slot. We must remap it&n;&t;&t;&t;&t; * under 64K but it is not done yet. XXX&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;PCIC: Skipping I/O space at 0x%lx,&quot;
l_string|&quot;this will Oops if a driver attaches;&quot;
l_string|&quot;device &squot;%s&squot; at %02x:%02x)&bslash;n&quot;
comma
id|address
comma
id|namebuf
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
DECL|function|pcic_fill_irq
id|pcic_fill_irq
c_func
(paren
r_struct
id|linux_pcic
op_star
id|pcic
comma
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|node
)paren
(brace
r_struct
id|pcic_ca2irq
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|ivec
suffix:semicolon
r_char
id|namebuf
(braket
l_int|64
)braket
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
l_int|0
op_logical_or
id|node
op_eq
op_minus
l_int|1
)paren
(brace
id|strcpy
c_func
(paren
id|namebuf
comma
l_string|&quot;???&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|prom_getstring
c_func
(paren
id|node
comma
l_string|&quot;name&quot;
comma
id|namebuf
comma
r_sizeof
(paren
id|namebuf
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|pcic-&gt;pcic_imap
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pcic-&gt;pcic_imdim
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;busno
op_eq
id|dev-&gt;bus-&gt;number
op_logical_and
id|p-&gt;devfn
op_eq
id|dev-&gt;devfn
)paren
r_break
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|pcic-&gt;pcic_imdim
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCIC: device %s devfn %02x:%02x not found in %d&bslash;n&quot;
comma
id|namebuf
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
comma
id|pcic-&gt;pcic_imdim
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|i
op_assign
id|p-&gt;pin
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|0
op_logical_and
id|i
OL
l_int|4
)paren
(brace
id|ivec
op_assign
id|readw
c_func
(paren
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_LO
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|ivec
op_rshift
(paren
id|i
op_lshift
l_int|2
)paren
op_amp
l_int|0xF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_ge
l_int|4
op_logical_and
id|i
OL
l_int|8
)paren
(brace
id|ivec
op_assign
id|readw
c_func
(paren
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_HI
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|ivec
op_rshift
(paren
(paren
id|i
op_minus
l_int|4
)paren
op_lshift
l_int|2
)paren
op_amp
l_int|0xF
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Corrupted map */
id|printk
c_func
(paren
l_string|&quot;PCIC: BAD PIN %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
)brace
)brace
multiline_comment|/* P3 */
multiline_comment|/* printk(&quot;PCIC: device %s pin %d ivec 0x%x irq %x&bslash;n&quot;, namebuf, i, ivec, dev-&gt;irq); */
multiline_comment|/*&n;&t; * dev-&gt;irq=0 means PROM did not bother to program the upper&n;&t; * half of PCIC. This happens on JS-E with PROM 3.11, for instance.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;irq
op_eq
l_int|0
op_logical_or
id|p-&gt;force
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;irq
op_eq
l_int|0
op_logical_or
id|p-&gt;irq
op_ge
l_int|15
)paren
(brace
multiline_comment|/* Corrupted map */
id|printk
c_func
(paren
l_string|&quot;PCIC: BAD IRQ %d&bslash;n&quot;
comma
id|p-&gt;irq
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;PCIC: setting irq %d at pin %d for device %02x:%02x&bslash;n&quot;
comma
id|p-&gt;irq
comma
id|p-&gt;pin
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|p-&gt;irq
suffix:semicolon
id|i
op_assign
id|p-&gt;pin
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|4
)paren
(brace
id|ivec
op_assign
id|readw
c_func
(paren
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_HI
)paren
suffix:semicolon
id|ivec
op_and_assign
op_complement
(paren
l_int|0xF
op_lshift
(paren
(paren
id|i
op_minus
l_int|4
)paren
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|ivec
op_or_assign
id|p-&gt;irq
op_lshift
(paren
(paren
id|i
op_minus
l_int|4
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|writew
c_func
(paren
id|ivec
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_HI
)paren
suffix:semicolon
)brace
r_else
(brace
id|ivec
op_assign
id|readw
c_func
(paren
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_LO
)paren
suffix:semicolon
id|ivec
op_and_assign
op_complement
(paren
l_int|0xF
op_lshift
(paren
id|i
op_lshift
l_int|2
)paren
)paren
suffix:semicolon
id|ivec
op_or_assign
id|p-&gt;irq
op_lshift
(paren
id|i
op_lshift
l_int|2
)paren
suffix:semicolon
id|writew
c_func
(paren
id|ivec
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_LO
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Normally called from {do_}pci_scan_bus...&n; */
DECL|function|pcibios_fixup_bus
r_void
id|__init
id|pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_struct
id|list_head
op_star
id|walk
suffix:semicolon
r_int
id|i
comma
id|has_io
comma
id|has_mem
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
r_struct
id|linux_pcic
op_star
id|pcic
suffix:semicolon
multiline_comment|/* struct linux_pbm_info* pbm = &amp;pcic-&gt;pbm; */
r_int
id|node
suffix:semicolon
r_struct
id|pcidev_cookie
op_star
id|pcp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcic0_up
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pcibios_fixup_bus: no PCIC&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pcic
op_assign
op_amp
id|pcic0
suffix:semicolon
multiline_comment|/*&n;&t; * Next crud is an equivalent of pbm = pcic_bus_to_pbm(bus);&n;&t; */
r_if
c_cond
(paren
id|bus-&gt;number
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pcibios_fixup_bus: nonzero bus 0x%x&bslash;n&quot;
comma
id|bus-&gt;number
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|walk
op_assign
op_amp
id|bus-&gt;devices
suffix:semicolon
r_for
c_loop
(paren
id|walk
op_assign
id|walk-&gt;next
suffix:semicolon
id|walk
op_ne
op_amp
id|bus-&gt;devices
suffix:semicolon
id|walk
op_assign
id|walk-&gt;next
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|pci_dev_b
c_func
(paren
id|walk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Comment from i386 branch:&n;&t;&t; *     There are buggy BIOSes that forget to enable I/O and memory&n;&t;&t; *     access to PCI devices. We try to fix this, but we need to&n;&t;&t; *     be sure that the BIOS didn&squot;t forget to assign an address&n;&t;&t; *     to the device. [mj]&n;&t;&t; * OBP is a case of such BIOS :-)&n;&t;&t; */
id|has_io
op_assign
id|has_mem
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|f
op_assign
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|IORESOURCE_IO
)paren
(brace
id|has_io
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|f
op_amp
id|IORESOURCE_MEM
)paren
id|has_mem
op_assign
l_int|1
suffix:semicolon
)brace
id|pcic_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_io
op_logical_and
op_logical_neg
(paren
id|cmd
op_amp
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCIC: Enabling I/O for device %02x:%02x&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
id|pcic_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|has_mem
op_logical_and
op_logical_neg
(paren
id|cmd
op_amp
id|PCI_COMMAND_MEMORY
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCIC: Enabling memory for device %02x:%02x&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
id|pcic_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
id|node
op_assign
id|pdev_to_pnode
c_func
(paren
op_amp
id|pcic-&gt;pbm
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
l_int|0
)paren
(brace
id|node
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* cookies */
id|pcp
op_assign
id|pci_devcookie_alloc
c_func
(paren
)paren
suffix:semicolon
id|pcp-&gt;pbm
op_assign
op_amp
id|pcic-&gt;pbm
suffix:semicolon
id|pcp-&gt;prom_node
op_assign
id|node
suffix:semicolon
id|dev-&gt;sysdata
op_assign
id|pcp
suffix:semicolon
multiline_comment|/* fixing I/O to look like memory */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|16
)paren
op_ne
id|PCI_BASE_CLASS_BRIDGE
)paren
id|pcic_map_pci_device
c_func
(paren
id|pcic
comma
id|dev
comma
id|node
)paren
suffix:semicolon
id|pcic_fill_irq
c_func
(paren
id|pcic
comma
id|dev
comma
id|node
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pcic_pin_to_irq() is exported to ebus.c.&n; */
r_int
r_int
DECL|function|pcic_pin_to_irq
id|pcic_pin_to_irq
c_func
(paren
r_int
r_int
id|pin
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|linux_pcic
op_star
id|pcic
op_assign
op_amp
id|pcic0
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
r_int
r_int
id|ivec
suffix:semicolon
r_if
c_cond
(paren
id|pin
OL
l_int|4
)paren
(brace
id|ivec
op_assign
id|readw
c_func
(paren
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_LO
)paren
suffix:semicolon
id|irq
op_assign
id|ivec
op_rshift
(paren
id|pin
op_lshift
l_int|2
)paren
op_amp
l_int|0xF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pin
OL
l_int|8
)paren
(brace
id|ivec
op_assign
id|readw
c_func
(paren
id|pcic-&gt;pcic_regs
op_plus
id|PCI_INT_SELECT_HI
)paren
suffix:semicolon
id|irq
op_assign
id|ivec
op_rshift
(paren
(paren
id|pin
op_minus
l_int|4
)paren
op_lshift
l_int|2
)paren
op_amp
l_int|0xF
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Corrupted map */
id|printk
c_func
(paren
l_string|&quot;PCIC: BAD PIN %d FOR %s&bslash;n&quot;
comma
id|pin
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
)brace
multiline_comment|/* XXX Cannot panic properly in case of PROLL */
)brace
multiline_comment|/* P3 */
multiline_comment|/* printk(&quot;PCIC: dev %s pin %d ivec 0x%x irq %x&bslash;n&quot;, name, pin, ivec, irq); */
r_return
id|irq
suffix:semicolon
)brace
multiline_comment|/* Makes compiler happy */
DECL|variable|pcic_timer_dummy
r_static
r_volatile
r_int
id|pcic_timer_dummy
suffix:semicolon
DECL|function|pcic_clear_clock_irq
r_static
r_void
id|pcic_clear_clock_irq
c_func
(paren
r_void
)paren
(brace
id|pcic_timer_dummy
op_assign
id|readl
c_func
(paren
id|pcic0.pcic_regs
op_plus
id|PCI_SYS_LIMIT
)paren
suffix:semicolon
)brace
DECL|function|pcic_timer_handler
r_static
r_void
id|pcic_timer_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|h
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pcic_clear_clock_irq
c_func
(paren
)paren
suffix:semicolon
id|do_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
DECL|macro|USECS_PER_JIFFY
mdefine_line|#define USECS_PER_JIFFY  10000  /* We have 100HZ &quot;standard&quot; timer for sparc */
DECL|macro|TICK_TIMER_LIMIT
mdefine_line|#define TICK_TIMER_LIMIT ((100*1000000/4)/100)
DECL|function|pci_time_init
r_void
id|__init
id|pci_time_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|linux_pcic
op_star
id|pcic
op_assign
op_amp
id|pcic0
suffix:semicolon
r_int
r_int
id|v
suffix:semicolon
r_int
id|timer_irq
comma
id|irq
suffix:semicolon
id|do_get_fast_time
op_assign
id|pci_do_gettimeofday
suffix:semicolon
multiline_comment|/* A hack until do_gettimeofday prototype is moved to arch specific headers&n;&t;   and btfixupped. Patch do_gettimeofday with ba pci_do_gettimeofday; nop */
(paren
(paren
r_int
r_int
op_star
)paren
id|do_gettimeofday
)paren
(braket
l_int|0
)braket
op_assign
l_int|0x10800000
op_or
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|pci_do_gettimeofday
op_minus
(paren
r_int
r_int
)paren
id|do_gettimeofday
)paren
op_rshift
l_int|2
)paren
op_amp
l_int|0x003fffff
)paren
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|do_gettimeofday
)paren
(braket
l_int|1
)braket
op_assign
l_int|0x01000000
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|bus_do_settimeofday
comma
id|pci_do_settimeofday
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|btfixup
c_func
(paren
)paren
suffix:semicolon
id|writel
(paren
id|TICK_TIMER_LIMIT
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_SYS_LIMIT
)paren
suffix:semicolon
multiline_comment|/* PROM should set appropriate irq */
id|v
op_assign
id|readb
c_func
(paren
id|pcic-&gt;pcic_regs
op_plus
id|PCI_COUNTER_IRQ
)paren
suffix:semicolon
id|timer_irq
op_assign
id|PCI_COUNTER_IRQ_SYS
c_func
(paren
id|v
)paren
suffix:semicolon
id|writel
(paren
id|PCI_COUNTER_IRQ_SET
c_func
(paren
id|timer_irq
comma
l_int|0
)paren
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_COUNTER_IRQ
)paren
suffix:semicolon
id|irq
op_assign
id|request_irq
c_func
(paren
id|timer_irq
comma
id|pcic_timer_handler
comma
(paren
id|SA_INTERRUPT
op_or
id|SA_STATIC_ALLOC
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;time_init: unable to attach IRQ%d&bslash;n&quot;
comma
id|timer_irq
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_gettimeoffset
r_static
id|__inline__
r_int
r_int
id|do_gettimeoffset
c_func
(paren
r_void
)paren
(brace
r_struct
id|tasklet_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * We devide all to 100&n;&t; * to have microsecond resolution and to avoid overflow&n;&t; */
r_int
r_int
id|count
op_assign
id|readl
c_func
(paren
id|pcic0.pcic_regs
op_plus
id|PCI_SYS_COUNTER
)paren
op_amp
op_complement
id|PCI_SYS_COUNTER_OVERFLOW
suffix:semicolon
id|count
op_assign
(paren
(paren
id|count
op_div
l_int|100
)paren
op_star
id|USECS_PER_JIFFY
)paren
op_div
(paren
id|TICK_TIMER_LIMIT
op_div
l_int|100
)paren
suffix:semicolon
id|t
op_assign
op_amp
id|bh_task_vec
(braket
id|TIMER_BH
)braket
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TASKLET_STATE_SCHED
comma
op_amp
id|t-&gt;state
)paren
)paren
id|offset
op_assign
l_int|1000000
suffix:semicolon
r_return
id|offset
op_plus
id|count
suffix:semicolon
)brace
r_extern
r_volatile
r_int
r_int
id|wall_jiffies
suffix:semicolon
DECL|function|pci_do_gettimeofday
r_static
r_void
id|pci_do_gettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
op_star
id|tv
op_assign
id|xtime
suffix:semicolon
id|tv-&gt;tv_usec
op_add_assign
id|do_gettimeoffset
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * xtime is atomically updated in timer_bh. The difference&n;&t; * between jiffies and wall_jiffies is nonzero if the timer&n;&t; * bottom half hasnt executed yet.&n;&t; */
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|wall_jiffies
)paren
op_ne
l_int|0
)paren
id|tv-&gt;tv_usec
op_add_assign
id|USECS_PER_JIFFY
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tv-&gt;tv_usec
op_ge
l_int|1000000
)paren
(brace
id|tv-&gt;tv_usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|tv-&gt;tv_sec
op_increment
suffix:semicolon
)brace
)brace
DECL|function|pci_do_settimeofday
r_static
r_void
id|pci_do_settimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tv-&gt;tv_usec
op_sub_assign
id|do_gettimeoffset
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tv-&gt;tv_usec
OL
l_int|0
)paren
(brace
id|tv-&gt;tv_usec
op_add_assign
l_int|1000000
suffix:semicolon
id|tv-&gt;tv_sec
op_decrement
suffix:semicolon
)brace
id|xtime
op_assign
op_star
id|tv
suffix:semicolon
id|time_adjust
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* stop active adjtime() */
id|time_status
op_or_assign
id|STA_UNSYNC
suffix:semicolon
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
id|time_esterror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|watchdog_reset
c_func
(paren
)paren
(brace
id|writeb
c_func
(paren
l_int|0
comma
id|pcic-&gt;pcic_regs
op_plus
id|PCI_SYS_STATUS
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Other archs parse arguments here.&n; */
DECL|function|pcibios_setup
r_char
op_star
id|__init
id|pcibios_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|str
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|pcibios_update_resource
r_void
id|pcibios_update_resource
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|resource
op_star
id|res1
comma
r_struct
id|resource
op_star
id|res2
comma
r_int
id|index
)paren
(brace
)brace
DECL|function|pcibios_align_resource
r_void
id|pcibios_align_resource
c_func
(paren
r_void
op_star
id|data
comma
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
)paren
(brace
)brace
DECL|function|pcibios_enable_device
r_int
id|pcibios_enable_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NMI&n; */
DECL|function|pcic_nmi
r_void
id|pcic_nmi
c_func
(paren
r_int
r_int
id|pend
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|pend
op_assign
id|flip_dword
c_func
(paren
id|pend
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcic_speculative
op_logical_or
(paren
id|pend
op_amp
id|PCI_SYS_INT_PENDING_PIO
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX On CP-1200 PCI #SERR may happen, we do not know&n;&t;&t; * what to do about it yet.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Aiee, NMI pend 0x%x pc 0x%x spec %d, hanging&bslash;n&quot;
comma
id|pend
comma
(paren
r_int
)paren
id|regs-&gt;pc
comma
id|pcic_speculative
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
)brace
)brace
id|pcic_speculative
op_assign
l_int|0
suffix:semicolon
id|pcic_trapped
op_assign
l_int|1
suffix:semicolon
id|regs-&gt;pc
op_assign
id|regs-&gt;npc
suffix:semicolon
id|regs-&gt;npc
op_add_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX  Gleb wrote me that he needs this for X server (only).&n; * Since we successfuly use XF86_FBDev, we do not need these anymore.&n; *&n; *  Following code added to handle extra PCI-related system calls &n; */
DECL|function|sys_pciconfig_read
id|asmlinkage
r_int
id|sys_pciconfig_read
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|ubyte
suffix:semicolon
r_int
r_int
id|ushort
suffix:semicolon
r_int
r_int
id|uint
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|1
suffix:colon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|ubyte
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ubyte
comma
(paren
r_int
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|ushort
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ushort
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
op_amp
id|uint
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|uint
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_pciconfig_write
id|asmlinkage
r_int
id|sys_pciconfig_write
c_func
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|dfn
comma
r_int
r_int
id|off
comma
r_int
r_int
id|len
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|ubyte
suffix:semicolon
r_int
r_int
id|ushort
suffix:semicolon
r_int
r_int
id|uint
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|1
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|ubyte
comma
(paren
r_int
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_break
suffix:semicolon
)brace
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|ubyte
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|ushort
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_break
suffix:semicolon
)brace
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|ushort
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|err
op_assign
id|get_user
c_func
(paren
id|uint
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_break
suffix:semicolon
)brace
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|dfn
comma
id|off
comma
id|uint
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|get_irqmask
r_static
r_inline
r_int
r_int
id|get_irqmask
c_func
(paren
r_int
id|irq_nr
)paren
(brace
r_return
l_int|1
op_lshift
id|irq_nr
suffix:semicolon
)brace
DECL|function|pcic_irq_itoa
r_static
r_inline
r_char
op_star
id|pcic_irq_itoa
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_static
r_char
id|buff
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buff
comma
l_string|&quot;%d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
id|buff
suffix:semicolon
)brace
DECL|function|pcic_disable_irq
r_static
r_void
id|pcic_disable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_int
r_int
id|mask
comma
id|flags
suffix:semicolon
id|mask
op_assign
id|get_irqmask
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|writel
c_func
(paren
id|mask
comma
id|pcic0.pcic_regs
op_plus
id|PCI_SYS_INT_TARGET_MASK_SET
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|pcic_enable_irq
r_static
r_void
id|pcic_enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_int
r_int
id|mask
comma
id|flags
suffix:semicolon
id|mask
op_assign
id|get_irqmask
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|writel
c_func
(paren
id|mask
comma
id|pcic0.pcic_regs
op_plus
id|PCI_SYS_INT_TARGET_MASK_CLEAR
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|pcic_clear_profile_irq
r_static
r_void
id|pcic_clear_profile_irq
c_func
(paren
r_int
id|cpu
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCIC: unimplemented code: FILE=%s LINE=%d&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
DECL|function|pcic_load_profile_irq
r_static
r_void
id|pcic_load_profile_irq
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|limit
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCIC: unimplemented code: FILE=%s LINE=%d&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
multiline_comment|/* We assume the caller is local cli()&squot;d when these are called, or else&n; * very bizarre behavior will result.&n; */
DECL|function|pcic_disable_pil_irq
r_static
r_void
id|pcic_disable_pil_irq
c_func
(paren
r_int
r_int
id|pil
)paren
(brace
id|writel
c_func
(paren
id|get_irqmask
c_func
(paren
id|pil
)paren
comma
id|pcic0.pcic_regs
op_plus
id|PCI_SYS_INT_TARGET_MASK_SET
)paren
suffix:semicolon
)brace
DECL|function|pcic_enable_pil_irq
r_static
r_void
id|pcic_enable_pil_irq
c_func
(paren
r_int
r_int
id|pil
)paren
(brace
id|writel
c_func
(paren
id|get_irqmask
c_func
(paren
id|pil
)paren
comma
id|pcic0.pcic_regs
op_plus
id|PCI_SYS_INT_TARGET_MASK_CLEAR
)paren
suffix:semicolon
)brace
DECL|function|sun4m_pci_init_IRQ
r_void
id|__init
id|sun4m_pci_init_IRQ
c_func
(paren
r_void
)paren
(brace
id|BTFIXUPSET_CALL
c_func
(paren
id|enable_irq
comma
id|pcic_enable_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|disable_irq
comma
id|pcic_disable_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|enable_pil_irq
comma
id|pcic_enable_pil_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|disable_pil_irq
comma
id|pcic_disable_pil_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|clear_clock_irq
comma
id|pcic_clear_clock_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|clear_profile_irq
comma
id|pcic_clear_profile_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|load_profile_irq
comma
id|pcic_load_profile_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|__irq_itoa
comma
id|pcic_irq_itoa
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
)brace
DECL|function|pcibios_assign_resource
r_int
id|pcibios_assign_resource
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|resource
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n; * This probably belongs here rather than ioport.c because&n; * we do not want this crud linked into SBus kernels.&n; * Also, think for a moment about likes of floppy.c that&n; * include architecture specific parts. They may want to redefine ins/outs.&n; *&n; * We do not use horroble macroses here because we want to&n; * advance pointer by sizeof(size).&n; */
DECL|function|outsb
r_void
id|outsb
c_func
(paren
r_int
r_int
id|addr
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|count
)paren
(brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_sub_assign
l_int|1
suffix:semicolon
id|writeb
c_func
(paren
op_star
(paren
r_const
r_char
op_star
)paren
id|src
comma
id|addr
)paren
suffix:semicolon
id|src
op_add_assign
l_int|1
suffix:semicolon
id|addr
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|outsw
r_void
id|outsw
c_func
(paren
r_int
r_int
id|addr
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|count
)paren
(brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
id|writew
c_func
(paren
op_star
(paren
r_const
r_int
op_star
)paren
id|src
comma
id|addr
)paren
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
id|addr
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
DECL|function|outsl
r_void
id|outsl
c_func
(paren
r_int
r_int
id|addr
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|count
)paren
(brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_sub_assign
l_int|4
suffix:semicolon
id|writel
c_func
(paren
op_star
(paren
r_const
r_int
op_star
)paren
id|src
comma
id|addr
)paren
suffix:semicolon
id|src
op_add_assign
l_int|4
suffix:semicolon
id|addr
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
DECL|function|insb
r_void
id|insb
c_func
(paren
r_int
r_int
id|addr
comma
r_void
op_star
id|dst
comma
r_int
r_int
id|count
)paren
(brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_sub_assign
l_int|1
suffix:semicolon
op_star
(paren
r_int
r_char
op_star
)paren
id|dst
op_assign
id|readb
c_func
(paren
id|addr
)paren
suffix:semicolon
id|dst
op_add_assign
l_int|1
suffix:semicolon
id|addr
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|insw
r_void
id|insw
c_func
(paren
r_int
r_int
id|addr
comma
r_void
op_star
id|dst
comma
r_int
r_int
id|count
)paren
(brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|dst
op_assign
id|readw
c_func
(paren
id|addr
)paren
suffix:semicolon
id|dst
op_add_assign
l_int|2
suffix:semicolon
id|addr
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
DECL|function|insl
r_void
id|insl
c_func
(paren
r_int
r_int
id|addr
comma
r_void
op_star
id|dst
comma
r_int
r_int
id|count
)paren
(brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX I am sure we are in for an unaligned trap here.&n;&t;&t; */
op_star
(paren
r_int
r_int
op_star
)paren
id|dst
op_assign
id|readl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|dst
op_add_assign
l_int|4
suffix:semicolon
id|addr
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
