multiline_comment|/* $Id: probe.c,v 1.39 1995/11/26 00:54:37 davem Exp $&n; * probe.c: Preliminary device tree probing routines...&n; *&n; * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/vac-ops.h&gt;
macro_line|#include &lt;asm/idprom.h&gt;
macro_line|#include &lt;asm/machines.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/mostek.h&gt;
macro_line|#include &lt;asm/auxio.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mp.h&gt;
macro_line|#include &lt;asm/mbus.h&gt;
multiline_comment|/* #define DEBUG_PROBING */
multiline_comment|/* XXX Grrr, this stuff should have it&squot;s own file, only generic stuff goes&n; * XXX here.  Possibly clock.c and timer.c?  This file should get smaller&n; * XXX and smaller as time goes on...&n; */
DECL|variable|sp_clock_typ
r_enum
id|sparc_clock_type
id|sp_clock_typ
suffix:semicolon
DECL|variable|mstk48t02_regs
r_struct
id|mostek48t02
op_star
id|mstk48t02_regs
op_assign
l_int|0
suffix:semicolon
DECL|variable|mstk48t08_regs
r_struct
id|mostek48t08
op_star
id|mstk48t08_regs
op_assign
l_int|0
suffix:semicolon
DECL|variable|master_l10_limit
r_volatile
r_int
r_int
op_star
id|master_l10_limit
op_assign
l_int|0
suffix:semicolon
DECL|variable|master_l10_counter
r_volatile
r_int
r_int
op_star
id|master_l10_counter
op_assign
l_int|0
suffix:semicolon
DECL|variable|sun4m_timers
r_struct
id|sun4m_timer_regs
op_star
id|sun4m_timers
suffix:semicolon
DECL|variable|node_str
r_static
r_char
id|node_str
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* Cpu-type information and manufacturer strings */
DECL|struct|cpu_iu_info
r_struct
id|cpu_iu_info
(brace
DECL|member|psr_impl
r_int
id|psr_impl
suffix:semicolon
DECL|member|psr_vers
r_int
id|psr_vers
suffix:semicolon
DECL|member|cpu_name
r_char
op_star
id|cpu_name
suffix:semicolon
multiline_comment|/* should be enough I hope... */
)brace
suffix:semicolon
DECL|struct|cpu_fp_info
r_struct
id|cpu_fp_info
(brace
DECL|member|psr_impl
r_int
id|psr_impl
suffix:semicolon
DECL|member|fp_vers
r_int
id|fp_vers
suffix:semicolon
DECL|member|fp_name
r_char
op_star
id|fp_name
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* In order to get the fpu type correct, you need to take the IDPROM&squot;s&n; * machine type value into consideration too.  I will fix this.&n; */
DECL|variable|linux_sparc_fpu
r_struct
id|cpu_fp_info
id|linux_sparc_fpu
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_string|&quot;Fujitsu MB86910 or Weitek WTL1164/5&quot;
)brace
comma
(brace
l_int|0
comma
l_int|1
comma
l_string|&quot;Fujitsu MB86911 or Weitek WTL1164/5 or LSI L64831&quot;
)brace
comma
(brace
l_int|0
comma
l_int|2
comma
l_string|&quot;LSI Logic L64802 or Texas Instruments ACT8847&quot;
)brace
comma
multiline_comment|/* SparcStation SLC, SparcStation1 */
(brace
l_int|0
comma
l_int|3
comma
l_string|&quot;Weitek WTL3170/2&quot;
)brace
comma
multiline_comment|/* SPARCstation-5 */
(brace
l_int|0
comma
l_int|4
comma
l_string|&quot;Lsi Logic/Meiko L64804 or compatible&quot;
)brace
comma
(brace
l_int|0
comma
l_int|5
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|0
comma
l_int|6
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|0
comma
l_int|7
comma
l_string|&quot;No FPU&quot;
)brace
comma
(brace
l_int|1
comma
l_int|0
comma
l_string|&quot;ROSS HyperSparc combined IU/FPU&quot;
)brace
comma
(brace
l_int|1
comma
l_int|1
comma
l_string|&quot;Lsi Logic L64814&quot;
)brace
comma
(brace
l_int|1
comma
l_int|2
comma
l_string|&quot;Texas Instruments TMS390-C602A&quot;
)brace
comma
(brace
l_int|1
comma
l_int|3
comma
l_string|&quot;Cypress CY7C602 FPU&quot;
)brace
comma
(brace
l_int|1
comma
l_int|4
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|1
comma
l_int|5
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|1
comma
l_int|6
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|1
comma
l_int|7
comma
l_string|&quot;No FPU&quot;
)brace
comma
(brace
l_int|2
comma
l_int|0
comma
l_string|&quot;BIT B5010 or B5110/20 or B5210&quot;
)brace
comma
(brace
l_int|2
comma
l_int|1
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|2
comma
l_int|2
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|2
comma
l_int|3
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|2
comma
l_int|4
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|2
comma
l_int|5
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|2
comma
l_int|6
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|2
comma
l_int|7
comma
l_string|&quot;No FPU&quot;
)brace
comma
multiline_comment|/* SuperSparc 50 module */
(brace
l_int|4
comma
l_int|0
comma
l_string|&quot;SuperSparc on-chip FPU&quot;
)brace
comma
multiline_comment|/* SparcClassic */
(brace
l_int|4
comma
l_int|4
comma
l_string|&quot;TI MicroSparc on chip FPU&quot;
)brace
comma
(brace
l_int|5
comma
l_int|0
comma
l_string|&quot;Matsushita MN10501&quot;
)brace
comma
(brace
l_int|5
comma
l_int|1
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|5
comma
l_int|2
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|5
comma
l_int|3
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|5
comma
l_int|4
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|5
comma
l_int|5
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|5
comma
l_int|6
comma
l_string|&quot;reserved&quot;
)brace
comma
(brace
l_int|5
comma
l_int|7
comma
l_string|&quot;No FPU&quot;
)brace
comma
)brace
suffix:semicolon
DECL|macro|NSPARCFPU
mdefine_line|#define NSPARCFPU  (sizeof(linux_sparc_fpu)/sizeof(struct cpu_fp_info))
DECL|variable|linux_sparc_chips
r_struct
id|cpu_iu_info
id|linux_sparc_chips
(braket
)braket
op_assign
(brace
multiline_comment|/* Sun4/100, 4/200, SLC */
(brace
l_int|0
comma
l_int|0
comma
l_string|&quot;Fujitsu  MB86900/1A or LSI L64831 SparcKIT-40&quot;
)brace
comma
multiline_comment|/* borned STP1012PGA */
(brace
l_int|0
comma
l_int|4
comma
l_string|&quot;Fujitsu  MB86904&quot;
)brace
comma
multiline_comment|/* SparcStation2, SparcServer 490 &amp; 690 */
(brace
l_int|1
comma
l_int|0
comma
l_string|&quot;LSI Logic Corporation - L64811&quot;
)brace
comma
multiline_comment|/* SparcStation2 */
(brace
l_int|1
comma
l_int|1
comma
l_string|&quot;Cypress/ROSS CY7C601&quot;
)brace
comma
multiline_comment|/* Embedded controller */
(brace
l_int|1
comma
l_int|3
comma
l_string|&quot;Cypress/ROSS CY7C611&quot;
)brace
comma
multiline_comment|/* Ross Technologies HyperSparc */
(brace
l_int|1
comma
l_int|0xf
comma
l_string|&quot;ROSS HyperSparc RT620&quot;
)brace
comma
(brace
l_int|1
comma
l_int|0xe
comma
l_string|&quot;ROSS HyperSparc RT625&quot;
)brace
comma
multiline_comment|/* ECL Implementation, CRAY S-MP Supercomputer... AIEEE! */
multiline_comment|/* Someone please write the code to support this beast! ;) */
(brace
l_int|2
comma
l_int|0
comma
l_string|&quot;Bipolar Integrated Technology - B5010&quot;
)brace
comma
(brace
l_int|3
comma
l_int|0
comma
l_string|&quot;LSI Logic Corporation - unknown-type&quot;
)brace
comma
(brace
l_int|4
comma
l_int|0
comma
l_string|&quot;Texas Instruments, Inc. - SuperSparc 50&quot;
)brace
comma
multiline_comment|/* SparcClassic  --  borned STP1010TAB-50*/
(brace
l_int|4
comma
l_int|1
comma
l_string|&quot;Texas Instruments, Inc. - MicroSparc&quot;
)brace
comma
(brace
l_int|4
comma
l_int|2
comma
l_string|&quot;Texas Instruments, Inc. - MicroSparc II&quot;
)brace
comma
(brace
l_int|4
comma
l_int|3
comma
l_string|&quot;Texas Instruments, Inc. - SuperSparc 51&quot;
)brace
comma
(brace
l_int|4
comma
l_int|4
comma
l_string|&quot;Texas Instruments, Inc. - SuperSparc 61&quot;
)brace
comma
(brace
l_int|4
comma
l_int|5
comma
l_string|&quot;Texas Instruments, Inc. - unknown&quot;
)brace
comma
(brace
l_int|5
comma
l_int|0
comma
l_string|&quot;Matsushita - MN10501&quot;
)brace
comma
(brace
l_int|6
comma
l_int|0
comma
l_string|&quot;Philips Corporation - unknown&quot;
)brace
comma
(brace
l_int|7
comma
l_int|0
comma
l_string|&quot;Harvest VLSI Design Center, Inc. - unknown&quot;
)brace
comma
multiline_comment|/* Gallium arsenide 200MHz, BOOOOGOOOOMIPS!!! */
(brace
l_int|8
comma
l_int|0
comma
l_string|&quot;Systems and Processes Engineering Corporation (SPEC)&quot;
)brace
comma
(brace
l_int|9
comma
l_int|0
comma
l_string|&quot;Fujitsu #3&quot;
)brace
comma
(brace
l_int|0xa
comma
l_int|0
comma
l_string|&quot;UNKNOWN CPU-VENDOR/TYPE&quot;
)brace
comma
(brace
l_int|0xb
comma
l_int|0
comma
l_string|&quot;UNKNOWN CPU-VENDOR/TYPE&quot;
)brace
comma
(brace
l_int|0xc
comma
l_int|0
comma
l_string|&quot;UNKNOWN CPU-VENDOR/TYPE&quot;
)brace
comma
(brace
l_int|0xd
comma
l_int|0
comma
l_string|&quot;UNKNOWN CPU-VENDOR/TYPE&quot;
)brace
comma
(brace
l_int|0xe
comma
l_int|0
comma
l_string|&quot;UNKNOWN CPU-VENDOR/TYPE&quot;
)brace
comma
(brace
l_int|0xf
comma
l_int|0
comma
l_string|&quot;UNKNOWN CPU-VENDOR/TYPE&quot;
)brace
comma
)brace
suffix:semicolon
DECL|macro|NSPARCCHIPS
mdefine_line|#define NSPARCCHIPS  (sizeof(linux_sparc_chips)/sizeof(struct cpu_iu_info))
DECL|variable|sparc_cpu_type
r_char
op_star
id|sparc_cpu_type
(braket
id|NCPUS
)braket
op_assign
(brace
l_string|&quot;cpu-oops&quot;
comma
l_string|&quot;cpu-oops1&quot;
comma
l_string|&quot;cpu-oops2&quot;
comma
l_string|&quot;cpu-oops3&quot;
)brace
suffix:semicolon
DECL|variable|sparc_fpu_type
r_char
op_star
id|sparc_fpu_type
(braket
id|NCPUS
)braket
op_assign
(brace
l_string|&quot;fpu-oops&quot;
comma
l_string|&quot;fpu-oops1&quot;
comma
l_string|&quot;fpu-oops2&quot;
comma
l_string|&quot;fpu-oops3&quot;
)brace
suffix:semicolon
DECL|function|find_mmu_num_contexts
r_static
r_inline
r_int
id|find_mmu_num_contexts
c_func
(paren
r_int
id|cpu
)paren
(brace
r_return
id|prom_getintdefault
c_func
(paren
id|cpu
comma
l_string|&quot;mmu-nctx&quot;
comma
l_int|0x8
)paren
suffix:semicolon
)brace
DECL|variable|fsr_storage
r_int
r_int
id|fsr_storage
suffix:semicolon
r_void
DECL|function|probe_cpu
id|probe_cpu
c_func
(paren
r_void
)paren
(brace
r_int
id|psr_impl
comma
id|psr_vers
comma
id|fpu_vers
suffix:semicolon
r_int
id|i
comma
id|cpuid
suffix:semicolon
id|cpuid
op_assign
id|get_cpuid
c_func
(paren
)paren
suffix:semicolon
id|psr_impl
op_assign
(paren
(paren
id|get_psr
c_func
(paren
)paren
op_rshift
l_int|28
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|psr_vers
op_assign
(paren
(paren
id|get_psr
c_func
(paren
)paren
op_rshift
l_int|24
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|fpu_vers
op_assign
(paren
(paren
id|get_fsr
c_func
(paren
)paren
op_rshift
l_int|17
)paren
op_amp
l_int|0x7
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSPARCCHIPS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|linux_sparc_chips
(braket
id|i
)braket
dot
id|psr_impl
op_eq
id|psr_impl
)paren
r_if
c_cond
(paren
id|linux_sparc_chips
(braket
id|i
)braket
dot
id|psr_vers
op_eq
id|psr_vers
)paren
(brace
id|sparc_cpu_type
(braket
id|cpuid
)braket
op_assign
id|linux_sparc_chips
(braket
id|i
)braket
dot
id|cpu_name
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NSPARCCHIPS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEBUG: psr.impl = 0x%x   psr.vers = 0x%x&bslash;n&quot;
comma
id|psr_impl
comma
id|psr_vers
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSPARCFPU
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|linux_sparc_fpu
(braket
id|i
)braket
dot
id|psr_impl
op_eq
id|psr_impl
)paren
r_if
c_cond
(paren
id|linux_sparc_fpu
(braket
id|i
)braket
dot
id|fp_vers
op_eq
id|fpu_vers
)paren
(brace
id|sparc_fpu_type
(braket
id|cpuid
)braket
op_assign
id|linux_sparc_fpu
(braket
id|i
)braket
dot
id|fp_name
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NSPARCFPU
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEBUG: psr.impl = 0x%x  fsr.vers = 0x%x&bslash;n&quot;
comma
id|psr_impl
comma
id|fpu_vers
)paren
suffix:semicolon
id|sparc_fpu_type
(braket
id|cpuid
)braket
op_assign
id|linux_sparc_fpu
(braket
l_int|31
)braket
dot
id|fp_name
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;cpu%d CPU: %s &bslash;n&quot;
comma
id|cpuid
comma
id|sparc_cpu_type
(braket
id|cpuid
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cpu%d FPU: %s &bslash;n&quot;
comma
id|cpuid
comma
id|sparc_fpu_type
(braket
id|cpuid
)braket
)paren
suffix:semicolon
)brace
r_void
DECL|function|probe_vac
id|probe_vac
c_func
(paren
r_void
)paren
(brace
r_int
id|propval
suffix:semicolon
id|sun4c_disable_vac
c_func
(paren
)paren
suffix:semicolon
id|sun4c_vacinfo.num_bytes
op_assign
id|prom_getintdefault
c_func
(paren
id|prom_root_node
comma
l_string|&quot;vac-size&quot;
comma
l_int|65536
)paren
suffix:semicolon
id|sun4c_vacinfo.linesize
op_assign
id|prom_getintdefault
c_func
(paren
id|prom_root_node
comma
l_string|&quot;vac-linesize&quot;
comma
l_int|16
)paren
suffix:semicolon
id|sun4c_vacinfo.num_lines
op_assign
(paren
id|sun4c_vacinfo.num_bytes
op_div
id|sun4c_vacinfo.linesize
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sun4c_vacinfo.linesize
)paren
(brace
r_case
l_int|16
suffix:colon
id|sun4c_vacinfo.log2lsize
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|sun4c_vacinfo.log2lsize
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;probe_vac: Didn&squot;t expect vac-linesize of %d, halting&bslash;n&quot;
comma
id|sun4c_vacinfo.linesize
)paren
suffix:semicolon
)brace
suffix:semicolon
id|propval
op_assign
id|prom_getintdefault
c_func
(paren
id|prom_root_node
comma
l_string|&quot;vac_hwflush&quot;
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|sun4c_vacinfo.do_hwflushes
op_assign
(paren
id|propval
op_eq
op_minus
l_int|1
ques
c_cond
id|prom_getintdefault
c_func
(paren
id|prom_root_node
comma
l_string|&quot;vac-hwflush&quot;
comma
l_int|0
)paren
suffix:colon
id|propval
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SUN4C: VAC size %d line size %d using %s flushes &quot;
comma
id|sun4c_vacinfo.num_bytes
comma
id|sun4c_vacinfo.linesize
comma
(paren
id|sun4c_vacinfo.do_hwflushes
ques
c_cond
l_string|&quot;hardware&quot;
suffix:colon
l_string|&quot;software&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sun4c_vacinfo.num_bytes
op_ne
l_int|65536
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WEIRD Sun4C VAC cache size, tell davem&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* setup the low-level assembly routine ptrs */
r_if
c_cond
(paren
id|sun4c_vacinfo.do_hwflushes
)paren
(brace
r_if
c_cond
(paren
id|sun4c_vacinfo.linesize
op_eq
l_int|16
)paren
(brace
id|sun4c_ctxflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_ctxflush_hw64KB16B
suffix:semicolon
id|sun4c_segflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_segflush_hw64KB16B
suffix:semicolon
id|sun4c_pgflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_pgflush_hw64KB16B
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sun4c_vacinfo.linesize
op_eq
l_int|32
)paren
(brace
id|sun4c_ctxflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_ctxflush_hw64KB32B
suffix:semicolon
id|sun4c_segflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_segflush_hw64KB32B
suffix:semicolon
id|sun4c_pgflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_pgflush_hw64KB32B
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;WEIRD Sun4C VAC cache line size, tell davem&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sun4c_vacinfo.linesize
op_eq
l_int|16
)paren
(brace
id|sun4c_ctxflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_ctxflush_sw64KB16B
suffix:semicolon
id|sun4c_segflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_segflush_sw64KB16B
suffix:semicolon
id|sun4c_pgflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_pgflush_sw64KB16B
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sun4c_vacinfo.linesize
op_eq
l_int|32
)paren
(brace
id|sun4c_ctxflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_ctxflush_sw64KB32B
suffix:semicolon
id|sun4c_segflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_segflush_sw64KB32B
suffix:semicolon
id|sun4c_pgflush
op_assign
(paren
r_int
r_int
)paren
id|sun4c_pgflush_sw64KB32B
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;WEIRD Sun4C VAC cache line size, tell davem&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sun4c_flush_all
c_func
(paren
)paren
suffix:semicolon
id|sun4c_enable_vac
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;enabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_extern
r_int
id|num_segmaps
comma
id|num_contexts
suffix:semicolon
multiline_comment|/* XXX Only called on sun4c XXX */
r_void
DECL|function|probe_mmu
id|probe_mmu
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
suffix:semicolon
multiline_comment|/* who are we? */
id|cpuid
op_assign
id|get_cpuid
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sparc_cpu_model
)paren
(brace
r_case
id|sun4
suffix:colon
r_case
id|sun4c
suffix:colon
r_case
id|sun4e
suffix:colon
multiline_comment|/* A sun4, sun4c or sun4e. */
id|num_segmaps
op_assign
id|prom_getintdefault
c_func
(paren
id|prom_root_node
comma
l_string|&quot;mmu-npmg&quot;
comma
l_int|128
)paren
suffix:semicolon
id|num_contexts
op_assign
id|find_mmu_num_contexts
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cpu%d MMU segmaps: %d     MMU contexts: %d&bslash;n&quot;
comma
id|cpuid
comma
id|num_segmaps
comma
id|num_contexts
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;cpu%d probe_mmu: sparc_cpu_model botch&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* Clock probing, we probe the timers here also. */
DECL|variable|foo_limit
r_volatile
r_int
r_int
id|foo_limit
suffix:semicolon
r_void
DECL|function|probe_clock
id|probe_clock
c_func
(paren
r_int
id|fchild
)paren
(brace
r_register
r_int
id|node
comma
id|type
suffix:semicolon
r_struct
id|linux_prom_registers
id|clk_reg
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* This will basically traverse the node-tree of the prom to see&n;&t; * which timer chip is on this machine.&n;&t; */
id|node
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sparc_cpu_model
op_eq
id|sun4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;probe_clock: No SUN4 Clock/Timer support yet...&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sparc_cpu_model
op_eq
id|sun4c
)paren
(brace
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sparc_cpu_model
op_eq
id|sun4m
)paren
(brace
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_searchsiblings
c_func
(paren
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
comma
l_string|&quot;obio&quot;
)paren
)paren
suffix:semicolon
)brace
id|type
op_assign
l_int|0
suffix:semicolon
id|sp_clock_typ
op_assign
id|MSTK_INVALID
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|prom_getstring
c_func
(paren
id|node
comma
l_string|&quot;model&quot;
comma
id|node_str
comma
r_sizeof
(paren
id|node_str
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|node_str
comma
l_string|&quot;mk48t02&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|sp_clock_typ
op_assign
id|MSTK48T02
suffix:semicolon
r_if
c_cond
(paren
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
id|clk_reg
comma
r_sizeof
(paren
id|clk_reg
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;probe_clock: FAILED!&bslash;n&quot;
)paren
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|prom_apply_obio_ranges
c_func
(paren
id|clk_reg
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Map the clock register io area read-only */
id|mstk48t02_regs
op_assign
(paren
r_struct
id|mostek48t02
op_star
)paren
id|sparc_alloc_io
c_func
(paren
(paren
r_void
op_star
)paren
id|clk_reg
(braket
l_int|0
)braket
dot
id|phys_addr
comma
(paren
r_void
op_star
)paren
l_int|0
comma
r_sizeof
(paren
op_star
id|mstk48t02_regs
)paren
comma
l_string|&quot;clock&quot;
comma
l_int|0x0
comma
l_int|0x0
)paren
suffix:semicolon
id|mstk48t08_regs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To catch weirdness */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|node_str
comma
l_string|&quot;mk48t08&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|sp_clock_typ
op_assign
id|MSTK48T08
suffix:semicolon
r_if
c_cond
(paren
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
id|clk_reg
comma
r_sizeof
(paren
id|clk_reg
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;probe_clock: FAILED!&bslash;n&quot;
)paren
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|prom_apply_obio_ranges
c_func
(paren
id|clk_reg
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Map the clock register io area read-only */
id|mstk48t08_regs
op_assign
(paren
r_struct
id|mostek48t08
op_star
)paren
id|sparc_alloc_io
c_func
(paren
(paren
r_void
op_star
)paren
id|clk_reg
(braket
l_int|0
)braket
dot
id|phys_addr
comma
(paren
r_void
op_star
)paren
l_int|0
comma
r_sizeof
(paren
op_star
id|mstk48t08_regs
)paren
comma
l_string|&quot;clock&quot;
comma
l_int|0x0
comma
l_int|0x0
)paren
suffix:semicolon
id|mstk48t02_regs
op_assign
op_amp
id|mstk48t08_regs-&gt;regs
suffix:semicolon
r_break
suffix:semicolon
)brace
id|node
op_assign
id|prom_getsibling
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aieee, could not find timer chip type&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sparc_cpu_model
op_eq
id|sun4c
)paren
(brace
multiline_comment|/* Map the Timer chip, this is implemented in hardware inside&n;&t;&t; * the cache chip on the sun4c.&n;&t;&t; */
id|sparc_alloc_io
(paren
(paren
r_void
op_star
)paren
id|SUN4C_TIMER_PHYSADDR
comma
(paren
r_void
op_star
)paren
id|TIMER_VADDR
comma
r_sizeof
(paren
op_star
id|SUN4C_TIMER_STRUCT
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|0x0
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* Have the level 10 timer tick at 100HZ.  We don&squot;t touch the&n;&t;&t; * level 14 timer limit since we are letting the prom handle&n;&t;&t; * them until we have a real console driver so L1-A works.&n;&t;&t; */
id|SUN4C_TIMER_STRUCT-&gt;timer_limit10
op_assign
(paren
(paren
(paren
l_int|1000000
op_div
id|HZ
)paren
op_plus
l_int|1
)paren
op_lshift
l_int|10
)paren
suffix:semicolon
id|master_l10_limit
op_assign
op_amp
(paren
id|SUN4C_TIMER_STRUCT-&gt;timer_limit10
)paren
suffix:semicolon
id|master_l10_counter
op_assign
op_amp
(paren
id|SUN4C_TIMER_STRUCT-&gt;cur_count10
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|reg_count
suffix:semicolon
r_struct
id|linux_prom_registers
id|cnt_regs
(braket
id|PROMREG_MAX
)braket
suffix:semicolon
r_int
id|obio_node
comma
id|cnt_node
suffix:semicolon
id|cnt_node
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|obio_node
op_assign
id|prom_searchsiblings
(paren
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
comma
l_string|&quot;obio&quot;
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|obio_node
op_assign
id|prom_getchild
(paren
id|obio_node
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|cnt_node
op_assign
id|prom_searchsiblings
(paren
id|obio_node
comma
l_string|&quot;counter&quot;
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;Cannot find /obio/counter node&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
(paren
)paren
suffix:semicolon
)brace
id|reg_count
op_assign
id|prom_getproperty
c_func
(paren
id|cnt_node
comma
l_string|&quot;reg&quot;
comma
(paren
r_void
op_star
)paren
id|cnt_regs
comma
r_sizeof
(paren
id|cnt_regs
)paren
)paren
suffix:semicolon
id|reg_count
op_assign
(paren
id|reg_count
op_div
r_sizeof
(paren
r_struct
id|linux_prom_registers
)paren
)paren
suffix:semicolon
multiline_comment|/* Apply the obio ranges to the timer registers. */
id|prom_apply_obio_ranges
c_func
(paren
id|cnt_regs
comma
id|reg_count
)paren
suffix:semicolon
multiline_comment|/* Map the per-cpu Counter registers. */
id|sparc_alloc_io
c_func
(paren
id|cnt_regs
(braket
l_int|0
)braket
dot
id|phys_addr
comma
(paren
r_void
op_star
)paren
id|TIMER_VADDR
comma
id|PAGE_SIZE
op_star
id|NCPUS
comma
l_string|&quot;counters_percpu&quot;
comma
id|cnt_regs
(braket
l_int|0
)braket
dot
id|which_io
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* Map the system Counter register. */
id|sparc_alloc_io
c_func
(paren
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|phys_addr
comma
(paren
r_void
op_star
)paren
id|TIMER_VADDR
op_plus
(paren
id|NCPUS
op_star
id|PAGE_SIZE
)paren
comma
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|reg_size
comma
l_string|&quot;counters_system&quot;
comma
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|which_io
comma
l_int|0x0
)paren
suffix:semicolon
id|sun4m_timers
op_assign
(paren
r_struct
id|sun4m_timer_regs
op_star
)paren
id|TIMER_VADDR
suffix:semicolon
multiline_comment|/* Avoid interrupt bombs... */
id|foo_limit
op_assign
(paren
r_volatile
)paren
id|sun4m_timers-&gt;l10_timer_limit
suffix:semicolon
multiline_comment|/* Must set the master pointer first or we will lose badly. */
id|master_l10_limit
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|sun4m_timer_regs
op_star
)paren
id|TIMER_VADDR
)paren
op_member_access_from_pointer
id|l10_timer_limit
)paren
suffix:semicolon
id|master_l10_counter
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|sun4m_timer_regs
op_star
)paren
id|TIMER_VADDR
)paren
op_member_access_from_pointer
id|l10_cur_count
)paren
suffix:semicolon
(paren
(paren
r_struct
id|sun4m_timer_regs
op_star
)paren
id|TIMER_VADDR
)paren
op_member_access_from_pointer
id|l10_timer_limit
op_assign
(paren
(paren
(paren
l_int|1000000
op_div
id|HZ
)paren
op_plus
l_int|1
)paren
op_lshift
l_int|10
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Probe and map in the Auxiliaary I/O register */
r_void
DECL|function|probe_auxio
id|probe_auxio
c_func
(paren
r_void
)paren
(brace
r_int
id|node
comma
id|auxio_nd
suffix:semicolon
r_struct
id|linux_prom_registers
id|auxregs
(braket
l_int|1
)braket
suffix:semicolon
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|auxio_nd
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;auxiliary-io&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|auxio_nd
)paren
(brace
id|node
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;obio&quot;
)paren
suffix:semicolon
id|node
op_assign
id|prom_getchild
c_func
(paren
id|node
)paren
suffix:semicolon
id|auxio_nd
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;auxio&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|auxio_nd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot find auxio node, cannot continue...&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|prom_getproperty
c_func
(paren
id|auxio_nd
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
id|auxregs
comma
r_sizeof
(paren
id|auxregs
)paren
)paren
suffix:semicolon
id|prom_apply_obio_ranges
c_func
(paren
id|auxregs
comma
l_int|0x1
)paren
suffix:semicolon
multiline_comment|/* Map the register both read and write */
id|sparc_alloc_io
c_func
(paren
id|auxregs
(braket
l_int|0
)braket
dot
id|phys_addr
comma
(paren
r_void
op_star
)paren
id|AUXIO_VADDR
comma
id|auxregs
(braket
l_int|0
)braket
dot
id|reg_size
comma
l_string|&quot;auxilliaryIO&quot;
comma
id|auxregs
(braket
l_int|0
)braket
dot
id|which_io
comma
l_int|0x0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mapped AUXIO at paddr %08lx vaddr %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|auxregs
(braket
l_int|0
)braket
dot
id|phys_addr
comma
(paren
r_int
r_int
)paren
id|AUXIO_VADDR
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|probe_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|sparc_phys_banks
id|sp_banks
(braket
id|SPARC_PHYS_BANKS
)braket
suffix:semicolon
DECL|variable|phys_bytes_of_ram
DECL|variable|end_of_phys_memory
r_int
r_int
id|phys_bytes_of_ram
comma
id|end_of_phys_memory
suffix:semicolon
r_extern
r_void
id|probe_mbus
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* #define DEBUG_PROBE_DEVICES */
DECL|variable|linux_cpus
r_struct
id|prom_cpuinfo
id|linux_cpus
(braket
id|NCPUS
)braket
suffix:semicolon
DECL|variable|linux_num_cpus
r_int
id|linux_num_cpus
suffix:semicolon
r_int
r_int
DECL|function|probe_devices
id|probe_devices
c_func
(paren
r_int
r_int
id|mem_start
)paren
(brace
r_int
id|nd
comma
id|i
comma
id|prom_node_cpu
comma
id|thismid
suffix:semicolon
r_int
id|cpu_nds
(braket
id|NCPUS
)braket
suffix:semicolon
multiline_comment|/* One node for each cpu */
r_int
id|cpu_ctr
op_assign
l_int|0
suffix:semicolon
id|prom_getstring
c_func
(paren
id|prom_root_node
comma
l_string|&quot;device_type&quot;
comma
id|node_str
comma
r_sizeof
(paren
id|node_str
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|node_str
comma
l_string|&quot;cpu&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|cpu_nds
(braket
l_int|0
)braket
op_assign
id|prom_root_node
suffix:semicolon
id|cpu_ctr
op_increment
suffix:semicolon
)brace
r_else
(brace
r_int
id|scan
suffix:semicolon
id|scan
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|nd
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|scan
op_assign
id|prom_getsibling
c_func
(paren
id|scan
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|prom_getstring
c_func
(paren
id|scan
comma
l_string|&quot;device_type&quot;
comma
id|node_str
comma
r_sizeof
(paren
id|node_str
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|node_str
comma
l_string|&quot;cpu&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|cpu_nds
(braket
id|cpu_ctr
)braket
op_assign
id|scan
suffix:semicolon
id|linux_cpus
(braket
id|cpu_ctr
)braket
dot
id|prom_node
op_assign
id|scan
suffix:semicolon
id|prom_getproperty
c_func
(paren
id|scan
comma
l_string|&quot;mid&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|thismid
comma
r_sizeof
(paren
id|thismid
)paren
)paren
suffix:semicolon
id|linux_cpus
(braket
id|cpu_ctr
)braket
dot
id|mid
op_assign
id|thismid
suffix:semicolon
id|cpu_ctr
op_increment
suffix:semicolon
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|cpu_ctr
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No CPU nodes found, cannot continue.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Probably a sun4d or sun4e, Sun is trying to trick us ;-) */
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Found %d CPU prom device tree node(s).&bslash;n&quot;
comma
id|cpu_ctr
)paren
suffix:semicolon
)brace
suffix:semicolon
id|prom_node_cpu
op_assign
id|cpu_nds
(braket
l_int|0
)braket
suffix:semicolon
id|linux_num_cpus
op_assign
id|cpu_ctr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cpu_ctr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prom_getstring
c_func
(paren
id|cpu_nds
(braket
id|i
)braket
comma
l_string|&quot;name&quot;
comma
id|node_str
comma
r_sizeof
(paren
id|node_str
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cpu%d: %s &bslash;n&quot;
comma
id|i
comma
id|node_str
)paren
suffix:semicolon
)brace
id|probe_cpu
c_func
(paren
)paren
suffix:semicolon
id|probe_auxio
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sparc_cpu_model
op_ne
id|sun4c
)paren
(brace
id|probe_mbus
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
eof
