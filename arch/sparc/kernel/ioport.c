multiline_comment|/* $Id: ioport.c,v 1.28 1999/12/27 06:08:28 anton Exp $&n; * ioport.c:  Simple io mapping allocator.&n; *&n; * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; * Copyright (C) 1995 Miguel de Icaza (miguel@nuclecu.unam.mx)&n; *&n; * 1996: sparc_free_io, 1999: ioremap()/iounmap() by Pete Zaitcev.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
r_struct
id|resource
op_star
id|sparc_find_resource_bystart
c_func
(paren
r_struct
id|resource
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_struct
id|resource
op_star
id|sparc_find_resource_by_hit
c_func
(paren
r_struct
id|resource
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
op_star
id|_sparc_ioremap
c_func
(paren
r_struct
id|resource
op_star
id|res
comma
id|u32
id|bus
comma
id|u32
id|pa
comma
r_int
id|sz
)paren
suffix:semicolon
r_static
r_void
op_star
id|_sparc_alloc_io
c_func
(paren
r_int
r_int
id|busno
comma
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_void
id|_sparc_free_io
c_func
(paren
r_struct
id|resource
op_star
id|res
)paren
suffix:semicolon
multiline_comment|/* This points to the next to use virtual memory for DVMA mappings */
DECL|variable|sparc_dvma
r_static
r_struct
id|resource
id|sparc_dvma
op_assign
(brace
l_string|&quot;sparc_dvma&quot;
comma
id|DVMA_VADDR
comma
id|DVMA_VADDR
op_plus
id|DVMA_LEN
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/* This points to the start of I/O mappings, cluable from outside. */
DECL|variable|sparc_iomap
r_struct
id|resource
id|sparc_iomap
op_assign
(brace
l_string|&quot;sparc_iomap&quot;
comma
id|IOBASE_VADDR
comma
id|IOBASE_END
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/*&n; * Our mini-allocator...&n; * Boy this is gross! We need it because we must map I/O for&n; * timers and interrupt controller before the kmalloc is available.&n; */
DECL|macro|XNMLN
mdefine_line|#define XNMLN  15
DECL|macro|XNRES
mdefine_line|#define XNRES  10&t;/* SS-10 uses 8 */
DECL|struct|xresource
r_struct
id|xresource
(brace
DECL|member|xres
r_struct
id|resource
id|xres
suffix:semicolon
multiline_comment|/* Must be first */
DECL|member|xflag
r_int
id|xflag
suffix:semicolon
multiline_comment|/* 1 == used */
DECL|member|xname
r_char
id|xname
(braket
id|XNMLN
op_plus
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|xresv
r_static
r_struct
id|xresource
id|xresv
(braket
id|XNRES
)braket
suffix:semicolon
DECL|function|xres_alloc
r_static
r_struct
id|xresource
op_star
id|xres_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|xresource
op_star
id|xrp
suffix:semicolon
r_int
id|n
suffix:semicolon
id|xrp
op_assign
id|xresv
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|XNRES
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|xrp-&gt;xflag
op_eq
l_int|0
)paren
(brace
id|xrp-&gt;xflag
op_assign
l_int|1
suffix:semicolon
r_return
id|xrp
suffix:semicolon
)brace
id|xrp
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|xres_free
r_static
r_void
id|xres_free
c_func
(paren
r_struct
id|xresource
op_star
id|xrp
)paren
(brace
id|xrp-&gt;xflag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; */
r_extern
r_void
id|sun4c_mapioaddr
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
id|bus_type
comma
r_int
id|rdonly
)paren
suffix:semicolon
r_extern
r_void
id|srmmu_mapioaddr
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
id|bus_type
comma
r_int
id|rdonly
)paren
suffix:semicolon
DECL|function|mapioaddr
r_static
r_void
id|mapioaddr
c_func
(paren
r_int
r_int
id|physaddr
comma
r_int
r_int
id|virt_addr
comma
r_int
id|bus
comma
r_int
id|rdonly
)paren
(brace
r_switch
c_cond
(paren
id|sparc_cpu_model
)paren
(brace
r_case
id|sun4c
suffix:colon
r_case
id|sun4
suffix:colon
id|sun4c_mapioaddr
c_func
(paren
id|physaddr
comma
id|virt_addr
comma
id|bus
comma
id|rdonly
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sun4m
suffix:colon
r_case
id|sun4d
suffix:colon
r_case
id|sun4e
suffix:colon
id|srmmu_mapioaddr
c_func
(paren
id|physaddr
comma
id|virt_addr
comma
id|bus
comma
id|rdonly
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;mapioaddr: Trying to map IO space for unsupported machine.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mapioaddr: sparc_cpu_model = %d&bslash;n&quot;
comma
id|sparc_cpu_model
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mapioaddr: Halting...&bslash;n&quot;
)paren
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
)brace
r_extern
r_void
id|srmmu_unmapioaddr
c_func
(paren
r_int
r_int
id|virt
)paren
suffix:semicolon
r_extern
r_void
id|sun4c_unmapioaddr
c_func
(paren
r_int
r_int
id|virt
)paren
suffix:semicolon
DECL|function|unmapioaddr
r_static
r_void
id|unmapioaddr
c_func
(paren
r_int
r_int
id|virt_addr
)paren
(brace
r_switch
c_cond
(paren
id|sparc_cpu_model
)paren
(brace
r_case
id|sun4c
suffix:colon
r_case
id|sun4
suffix:colon
id|sun4c_unmapioaddr
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sun4m
suffix:colon
r_case
id|sun4d
suffix:colon
r_case
id|sun4e
suffix:colon
id|srmmu_unmapioaddr
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;unmapioaddr: sparc_cpu_model = %d, halt...&bslash;n&quot;
comma
id|sparc_cpu_model
)paren
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * These are typically used in PCI drivers&n; * which are trying to be cross-platform.&n; *&n; * Bus type is always zero on IIep.&n; */
DECL|function|ioremap
r_void
op_star
id|ioremap
c_func
(paren
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
(brace
r_char
id|name
(braket
l_int|14
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;phys_%08x&quot;
comma
(paren
id|u32
)paren
id|offset
)paren
suffix:semicolon
r_return
id|_sparc_alloc_io
c_func
(paren
l_int|0
comma
id|offset
comma
id|size
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Comlimentary to ioremap().&n; */
DECL|function|iounmap
r_void
id|iounmap
c_func
(paren
r_void
op_star
r_virtual
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
r_int
r_int
)paren
r_virtual
op_amp
id|PAGE_MASK
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|sparc_find_resource_bystart
c_func
(paren
op_amp
id|sparc_iomap
comma
id|vaddr
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_io/iounmap: cannot free %lx&bslash;n&quot;
comma
id|vaddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|_sparc_free_io
c_func
(paren
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|res
op_ge
(paren
r_char
op_star
)paren
id|xresv
op_logical_and
(paren
r_char
op_star
)paren
id|res
OL
(paren
r_char
op_star
)paren
op_amp
id|xresv
(braket
id|XNRES
)braket
)paren
(brace
id|xres_free
c_func
(paren
(paren
r_struct
id|xresource
op_star
)paren
id|res
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Davem&squot;s version of sbus_ioremap.&n; */
DECL|function|sbus_ioremap
r_int
r_int
id|sbus_ioremap
c_func
(paren
r_struct
id|resource
op_star
id|phyres
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_return
(paren
r_int
r_int
)paren
id|_sparc_alloc_io
c_func
(paren
id|phyres-&gt;flags
op_amp
l_int|0xF
comma
id|phyres-&gt;start
op_plus
id|offset
comma
id|size
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|sbus_iounmap
r_void
id|sbus_iounmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Meat of mapping&n; */
DECL|function|_sparc_alloc_io
r_static
r_void
op_star
id|_sparc_alloc_io
c_func
(paren
r_int
r_int
id|busno
comma
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_static
r_int
id|printed_full
op_assign
l_int|0
suffix:semicolon
r_struct
id|xresource
op_star
id|xres
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_char
op_star
id|tack
suffix:semicolon
r_int
id|tlen
suffix:semicolon
r_void
op_star
id|va
suffix:semicolon
multiline_comment|/* P3 diag */
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
id|name
op_assign
l_string|&quot;???&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xres
op_assign
id|xres_alloc
c_func
(paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|tack
op_assign
id|xres-&gt;xname
suffix:semicolon
id|res
op_assign
op_amp
id|xres-&gt;xres
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|printed_full
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ioremap: done with statics, switching to malloc&bslash;n&quot;
)paren
suffix:semicolon
id|printed_full
op_assign
l_int|1
suffix:semicolon
)brace
id|tlen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|tack
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
op_plus
id|tlen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tack
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|res
op_assign
(paren
r_struct
id|resource
op_star
)paren
id|tack
suffix:semicolon
id|tack
op_add_assign
r_sizeof
(paren
r_struct
id|resource
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|tack
comma
id|name
comma
id|XNMLN
)paren
suffix:semicolon
id|tack
(braket
id|XNMLN
)braket
op_assign
l_int|0
suffix:semicolon
id|res-&gt;name
op_assign
id|tack
suffix:semicolon
id|va
op_assign
id|_sparc_ioremap
c_func
(paren
id|res
comma
id|busno
comma
id|phys
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;ioremap(0x%x:%08lx[0x%lx])=%p&bslash;n&quot;, busno, phys, size, va); */
multiline_comment|/* P3 diag */
r_return
id|va
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from _sparc_alloc_io only, we left it separate&n; * in case Davem changes his mind about interface to sbus_ioremap().&n; */
r_static
r_void
op_star
DECL|function|_sparc_ioremap
id|_sparc_ioremap
c_func
(paren
r_struct
id|resource
op_star
id|res
comma
id|u32
id|bus
comma
id|u32
id|pa
comma
r_int
id|sz
)paren
(brace
r_int
r_int
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|pa
)paren
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
r_int
r_int
id|va
suffix:semicolon
r_int
r_int
id|psz
suffix:semicolon
r_if
c_cond
(paren
id|allocate_resource
c_func
(paren
op_amp
id|sparc_iomap
comma
id|res
comma
(paren
id|offset
op_plus
id|sz
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
comma
id|sparc_iomap.start
comma
id|sparc_iomap.end
comma
id|PAGE_SIZE
comma
l_int|NULL
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Usually we cannot see printks in this case. */
id|prom_printf
c_func
(paren
l_string|&quot;alloc_io_res(%s): cannot occupy&bslash;n&quot;
comma
(paren
id|res-&gt;name
op_ne
l_int|NULL
)paren
ques
c_cond
id|res-&gt;name
suffix:colon
l_string|&quot;???&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|va
op_assign
id|res-&gt;start
suffix:semicolon
id|pa
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_for
c_loop
(paren
id|psz
op_assign
id|res-&gt;end
op_minus
id|res-&gt;start
op_plus
l_int|1
suffix:semicolon
id|psz
op_ne
l_int|0
suffix:semicolon
id|psz
op_sub_assign
id|PAGE_SIZE
)paren
(brace
id|mapioaddr
c_func
(paren
id|pa
comma
id|va
comma
id|bus
comma
l_int|0
)paren
suffix:semicolon
id|va
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pa
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXX Playing with implementation details here.&n;&t; * On sparc64 Ebus has resources with precise boundaries.&n;&t; * We share drivers with sparc64. Too clever drivers use&n;&t; * start of a resource instead of a base adress.&n;&t; *&n;&t; * XXX-2 This may be not valid anymore, clean when&n;&t; * interface to sbus_ioremap() is resolved.&n;&t; */
id|res-&gt;start
op_add_assign
id|offset
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|sz
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* not strictly necessary.. */
r_return
(paren
r_void
op_star
)paren
id|res-&gt;start
suffix:semicolon
)brace
multiline_comment|/*&n; * Comlimentary to _sparc_ioremap().&n; */
DECL|function|_sparc_free_io
r_static
r_void
id|_sparc_free_io
c_func
(paren
r_struct
id|resource
op_star
id|res
)paren
(brace
r_int
r_int
id|plen
suffix:semicolon
id|plen
op_assign
id|res-&gt;end
op_minus
id|res-&gt;start
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|plen
op_ne
l_int|0
)paren
(brace
id|plen
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|unmapioaddr
c_func
(paren
id|res-&gt;start
op_plus
id|plen
)paren
suffix:semicolon
)brace
id|release_resource
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SBUS
DECL|function|sbus_set_sbus64
r_void
id|sbus_set_sbus64
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_int
id|x
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_set_sbus64: unsupported&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a chunk of memory suitable for DMA.&n; * Typically devices use them for control blocks.&n; * CPU may access them without any explicit flushing.&n; */
DECL|function|sbus_alloc_consistant
r_void
op_star
id|sbus_alloc_consistant
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_int
id|len
comma
id|u32
op_star
id|dma_addrp
)paren
(brace
r_int
r_int
id|len_total
op_assign
(paren
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_int
r_int
id|va
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_int
id|order
suffix:semicolon
multiline_comment|/* XXX why are some lenghts signed, others unsigned? */
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* XXX So what is maxphys for us and how do drivers know it? */
r_if
c_cond
(paren
id|len
OG
l_int|256
op_star
l_int|1024
)paren
(brace
multiline_comment|/* __get_free_pages() limit */
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
l_int|6
suffix:semicolon
id|order
op_increment
)paren
multiline_comment|/* 2^6 pages == 256K */
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
(paren
id|order
op_plus
id|PAGE_SHIFT
)paren
)paren
op_ge
id|len_total
)paren
r_break
suffix:semicolon
id|va
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|va
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * printk here may be flooding... Consider removal XXX.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;sbus_alloc_consistant: no %ld pages&bslash;n&quot;
comma
id|len_total
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|res
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|free_pages
c_func
(paren
id|va
comma
id|order
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sbus_alloc_consistant: no core&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|allocate_resource
c_func
(paren
op_amp
id|sparc_dvma
comma
id|res
comma
id|len_total
comma
id|sparc_dvma.start
comma
id|sparc_dvma.end
comma
id|PAGE_SIZE
comma
l_int|NULL
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_alloc_consistant: cannot occupy 0x%lx&quot;
comma
id|len
)paren
suffix:semicolon
id|free_pages
c_func
(paren
id|va
comma
id|order
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|dma_addrp
op_assign
id|res-&gt;start
suffix:semicolon
id|mmu_map_dma_area
c_func
(paren
id|va
comma
id|res-&gt;start
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;Official&quot; or &quot;natural&quot; address of pages we got is va.&n;&t; * We want to return uncached range. We could make va[len]&n;&t; * uncached but it&squot;s difficult to make cached back [P3: hmm]&n;&t; * We use the artefact of sun4c, replicated everywhere else,&n;&t; * that CPU can use bus addresses to access the same memory.&n;&t; */
id|res-&gt;name
op_assign
(paren
r_void
op_star
)paren
id|va
suffix:semicolon
multiline_comment|/* XXX Ouch.. we got to hide it somewhere */
r_return
(paren
r_void
op_star
)paren
id|res-&gt;start
suffix:semicolon
)brace
DECL|function|sbus_free_consistant
r_void
id|sbus_free_consistant
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_int
id|n
comma
r_void
op_star
id|p
comma
id|u32
id|ba
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_int
r_int
id|pgp
suffix:semicolon
r_int
id|order
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|sparc_find_resource_bystart
c_func
(paren
op_amp
id|sparc_dvma
comma
(paren
r_int
r_int
)paren
id|p
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_free_consistant: cannot free %p&bslash;n&quot;
comma
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|p
op_amp
(paren
id|PAGE_MASK
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_free_consistant: unaligned va %p&bslash;n&quot;
comma
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|n
op_assign
(paren
id|n
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res-&gt;end
op_minus
id|res-&gt;start
)paren
op_plus
l_int|1
op_ne
id|n
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_free_consistant: region 0x%lx asked 0x%lx&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|res-&gt;end
op_minus
id|res-&gt;start
)paren
op_plus
l_int|1
)paren
comma
id|n
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mmu_inval_dma_area
c_func
(paren
(paren
r_int
r_int
)paren
id|res-&gt;name
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* XXX Ouch */
id|mmu_unmap_dma_area
c_func
(paren
id|ba
comma
id|n
)paren
suffix:semicolon
id|release_resource
c_func
(paren
id|res
)paren
suffix:semicolon
id|pgp
op_assign
(paren
r_int
r_int
)paren
id|res-&gt;name
suffix:semicolon
multiline_comment|/* XXX Ouch */
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
l_int|6
suffix:semicolon
id|order
op_increment
)paren
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
(paren
id|order
op_plus
id|PAGE_SHIFT
)paren
)paren
op_ge
id|n
)paren
r_break
suffix:semicolon
id|free_pages
c_func
(paren
id|pgp
comma
id|order
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map a chunk of memory so that devices can see it.&n; * CPU view of this memory may be inconsistent with&n; * a device view and explicit flushing is necessary.&n; */
DECL|function|sbus_map_single
id|u32
id|sbus_map_single
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_void
op_star
id|va
comma
r_int
id|len
)paren
(brace
macro_line|#if 0 /* This is the version that abuses consistant space */
r_int
r_int
id|len_total
op_assign
(paren
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
multiline_comment|/* XXX why are some lenghts signed, others unsigned? */
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* XXX So what is maxphys for us and how do drivers know it? */
r_if
c_cond
(paren
id|len
OG
l_int|256
op_star
l_int|1024
)paren
(brace
multiline_comment|/* __get_free_pages() limit */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|res
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_map_single: no core&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|res-&gt;name
op_assign
id|va
suffix:semicolon
r_if
c_cond
(paren
id|allocate_resource
c_func
(paren
op_amp
id|sparc_dvma
comma
id|res
comma
id|len_total
comma
id|sparc_dvma.start
comma
id|sparc_dvma.end
comma
id|PAGE_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_map_single: cannot occupy 0x%lx&quot;
comma
id|len
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mmu_map_dma_area
c_func
(paren
id|va
comma
id|res-&gt;start
comma
id|len_total
)paren
suffix:semicolon
id|mmu_flush_dma_area
c_func
(paren
(paren
r_int
r_int
)paren
id|va
comma
id|len_total
)paren
suffix:semicolon
multiline_comment|/* in all contexts? */
r_return
id|res-&gt;start
suffix:semicolon
macro_line|#endif
macro_line|#if 1 /* &quot;trampoline&quot; version */
multiline_comment|/* XXX why are some lenghts signed, others unsigned? */
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* XXX So what is maxphys for us and how do drivers know it? */
r_if
c_cond
(paren
id|len
OG
l_int|256
op_star
l_int|1024
)paren
(brace
multiline_comment|/* __get_free_pages() limit */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* BTFIXUPDEF_CALL(__u32, mmu_get_scsi_one, char *, unsigned long, struct sbus_bus *sbus) */
r_return
id|mmu_get_scsi_one
c_func
(paren
id|va
comma
id|len
comma
id|sdev-&gt;bus
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|sbus_unmap_single
r_void
id|sbus_unmap_single
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
id|u32
id|ba
comma
r_int
id|n
)paren
(brace
macro_line|#if 0 /* This is the version that abuses consistant space */
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_int
r_int
id|va
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|sparc_find_resource_bystart
c_func
(paren
op_amp
id|sparc_dvma
comma
id|ba
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_unmap_single: cannot find %08x&bslash;n&quot;
comma
(paren
r_int
)paren
id|ba
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|n
op_assign
(paren
id|n
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res-&gt;end
op_minus
id|res-&gt;start
)paren
op_plus
l_int|1
op_ne
id|n
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_unmap_single: region 0x%lx asked 0x%lx&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|res-&gt;end
op_minus
id|res-&gt;start
)paren
op_plus
l_int|1
)paren
comma
id|n
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|va
op_assign
(paren
r_int
r_int
)paren
id|res-&gt;name
suffix:semicolon
multiline_comment|/* XXX Ouch */
id|mmu_inval_dma_area
c_func
(paren
id|va
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* in all contexts, mm&squot;s?... */
id|mmu_unmap_dma_area
c_func
(paren
id|ba
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* iounit cache flush is here */
id|release_resource
c_func
(paren
id|res
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 1 /* &quot;trampoline&quot; version */
multiline_comment|/* BTFIXUPDEF_CALL(void,  mmu_release_scsi_one, __u32, unsigned long, struct sbus_bus *sbus) */
id|mmu_release_scsi_one
c_func
(paren
id|ba
comma
id|n
comma
id|sdev-&gt;bus
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|sbus_map_sg
r_int
id|sbus_map_sg
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n
)paren
(brace
multiline_comment|/* BTFIXUPDEF_CALL(void,  mmu_get_scsi_sgl, struct scatterlist *, int, struct sbus_bus *sbus) */
id|mmu_get_scsi_sgl
c_func
(paren
id|sg
comma
id|n
comma
id|sdev-&gt;bus
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX sparc64 can return a partial length here. sun4c should do this&n;&t; * but it currently panics if it can&squot;t fulfill the request - Anton&n;&t; */
r_return
id|n
suffix:semicolon
)brace
DECL|function|sbus_unmap_sg
r_void
id|sbus_unmap_sg
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n
)paren
(brace
multiline_comment|/* BTFIXUPDEF_CALL(void,  mmu_release_scsi_sgl, struct scatterlist *, int, struct sbus_bus *sbus) */
id|mmu_release_scsi_sgl
c_func
(paren
id|sg
comma
id|n
comma
id|sdev-&gt;bus
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * P3: I think a partial flush is permitted...&n; * We are not too efficient at doing it though.&n; *&n; * If only DaveM understood a concept of an allocation cookie,&n; * we could avoid find_resource_by_hit() here and a major&n; * performance hit.&n; */
DECL|function|sbus_dma_sync_single
r_void
id|sbus_dma_sync_single
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
id|u32
id|ba
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|va
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|res
op_assign
id|sparc_find_resource_by_hit
c_func
(paren
op_amp
id|sparc_dvma
comma
id|ba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;sbus_dma_sync_single: 0x%x&bslash;n&quot;
comma
id|ba
)paren
suffix:semicolon
id|va
op_assign
(paren
r_int
r_int
)paren
id|res-&gt;name
suffix:semicolon
multiline_comment|/* if (va == 0) */
id|mmu_inval_dma_area
c_func
(paren
id|va
comma
(paren
id|res-&gt;end
op_minus
id|res-&gt;start
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sbus_dma_sync_sg
r_void
id|sbus_dma_sync_sg
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dma_sync_sg: not implemented yet&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a version of find_resource and it belongs to kernel/resource.c.&n; * Until we have agreement with Linus and Martin, it lingers here.&n; *&n; * &quot;same start&quot; is more strict than &quot;hit into&quot;&n; */
r_struct
id|resource
op_star
DECL|function|sparc_find_resource_bystart
id|sparc_find_resource_bystart
c_func
(paren
r_struct
id|resource
op_star
id|root
comma
r_int
r_int
id|start
)paren
(brace
r_struct
id|resource
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|root-&gt;child
suffix:semicolon
id|tmp
op_ne
l_int|0
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;start
op_eq
id|start
)paren
r_return
id|tmp
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_struct
id|resource
op_star
DECL|function|sparc_find_resource_by_hit
id|sparc_find_resource_by_hit
c_func
(paren
r_struct
id|resource
op_star
id|root
comma
r_int
r_int
id|hit
)paren
(brace
r_struct
id|resource
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|root-&gt;child
suffix:semicolon
id|tmp
op_ne
l_int|0
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;sibling
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;start
op_le
id|hit
op_logical_and
id|tmp-&gt;end
op_ge
id|hit
)paren
r_return
id|tmp
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
eof
