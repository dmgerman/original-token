multiline_comment|/* $Id: ioport.c,v 1.18 1996/04/25 06:08:44 davem Exp $&n; * ioport.c:  Simple io mapping allocator.&n; *&n; * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; * Copyright (C) 1995 Miguel de Icaza (miguel@nuclecu.unam.mx)&n; *&n; * The routines in this file should be changed for a memory allocator&n; * that would be setup just like NetBSD does : you create regions that&n; * are administered by a general purpose allocator, and then you call&n; * that allocator with your handle and the block size instead of this&n; * weak stuff.&n; *&n; * XXX No joke, this needs to be rewritten badly. XXX&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/* This points to the next to use virtual memory for io mappings */
DECL|variable|next_free_region
r_static
r_int
id|next_free_region
op_assign
id|IOBASE_VADDR
suffix:semicolon
DECL|variable|dvma_next_free
r_static
r_int
id|dvma_next_free
op_assign
id|DVMA_VADDR
suffix:semicolon
multiline_comment|/*&n; * sparc_alloc_io:&n; * Map and allocates an obio device.&n; * Implements a simple linear allocator, you can force the function&n; * to use your own mapping, but in practice this should not be used.&n; *&n; * Input:&n; *  address: the obio address to map&n; *  virtual: if non zero, specifies a fixed virtual address where&n; *           the mapping should take place.&n; *  len:     the length of the mapping&n; *  bus_type: The bus on which this io area sits.&n; *&n; * Returns:&n; *  The virtual address where the mapping actually took place.&n; */
DECL|function|sparc_alloc_io
r_void
op_star
id|sparc_alloc_io
(paren
r_void
op_star
id|address
comma
r_void
op_star
r_virtual
comma
r_int
id|len
comma
r_char
op_star
id|name
comma
r_int
id|bus_type
comma
r_int
id|rdonly
)paren
(brace
r_int
r_int
id|vaddr
comma
id|base_address
suffix:semicolon
r_int
r_int
id|addr
op_assign
(paren
r_int
r_int
)paren
id|address
suffix:semicolon
r_int
r_int
id|offset
op_assign
(paren
id|addr
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
r_virtual
)paren
id|vaddr
op_assign
(paren
r_int
r_int
)paren
r_virtual
suffix:semicolon
r_else
id|vaddr
op_assign
id|next_free_region
suffix:semicolon
id|len
op_add_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
r_virtual
op_plus
id|len
)paren
OG
(paren
id|IOBASE_VADDR
op_plus
id|IOBASE_LEN
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_io: Mapping outside IOBASE area&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
(paren
(paren
id|vaddr
op_or
id|offset
)paren
comma
id|len
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_io: 0x%lx is already in use&bslash;n&quot;
comma
id|vaddr
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Tell Linux resource manager about the mapping */
id|request_region
(paren
(paren
id|vaddr
op_or
id|offset
)paren
comma
id|len
comma
id|name
)paren
suffix:semicolon
id|base_address
op_assign
id|vaddr
suffix:semicolon
multiline_comment|/* Do the actual mapping */
r_for
c_loop
(paren
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
)paren
(brace
id|mapioaddr
c_func
(paren
id|addr
comma
id|vaddr
comma
id|bus_type
comma
id|rdonly
)paren
suffix:semicolon
id|vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_virtual
)paren
id|next_free_region
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
(paren
id|base_address
op_or
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/* Does DVMA allocations with PAGE_SIZE granularity.  How this basically&n; * works is that the ESP chip can do DVMA transfers at ANY address with&n; * certain size and boundary restrictions.  But other devices that are&n; * attached to it and would like to do DVMA have to set things up in&n; * a special way, if the DVMA sees a device attached to it transfer data&n; * at addresses above DVMA_VADDR it will grab them, this way it does not&n; * now have to know the peculiarities of where to read the Lance data&n; * from. (for example)&n; */
DECL|function|sparc_dvma_malloc
r_void
op_star
id|sparc_dvma_malloc
(paren
r_int
id|len
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|vaddr
comma
id|base_address
suffix:semicolon
id|vaddr
op_assign
id|dvma_next_free
suffix:semicolon
r_if
c_cond
(paren
id|check_region
(paren
id|vaddr
comma
id|len
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_dma: 0x%lx is already in use&bslash;n&quot;
comma
id|vaddr
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vaddr
op_plus
id|len
OG
(paren
id|DVMA_VADDR
op_plus
id|DVMA_LEN
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_dvma: out of dvma memory&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Basically these can be mapped just like any old&n;&t; * IO pages, cacheable bit off, etc.  The physical&n;&t; * pages are pre-mapped in paging_init()&n;&t; */
id|base_address
op_assign
id|vaddr
suffix:semicolon
multiline_comment|/* Assign the memory area. */
id|dvma_next_free
op_assign
id|PAGE_ALIGN
c_func
(paren
id|dvma_next_free
op_plus
id|len
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|base_address
comma
id|len
comma
id|name
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|base_address
suffix:semicolon
)brace
eof
