multiline_comment|/* $Id: muldiv.c,v 1.5 1997/12/15 20:07:20 ecd Exp $&n; * muldiv.c: Hardware multiply/division illegal instruction trap&n; *&t;&t;for sun4c/sun4 (which do not have those instructions)&n; *&n; * Copyright (C) 1996 Jakub Jelinek (jj@sunsite.mff.cuni.cz)&n; * Copyright (C) 1996 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* #define DEBUG_MULDIV */
DECL|function|has_imm13
r_static
r_inline
r_int
id|has_imm13
c_func
(paren
r_int
id|insn
)paren
(brace
r_return
(paren
id|insn
op_amp
l_int|0x2000
)paren
suffix:semicolon
)brace
DECL|function|is_foocc
r_static
r_inline
r_int
id|is_foocc
c_func
(paren
r_int
id|insn
)paren
(brace
r_return
(paren
id|insn
op_amp
l_int|0x800000
)paren
suffix:semicolon
)brace
DECL|function|sign_extend_imm13
r_static
r_inline
r_int
id|sign_extend_imm13
c_func
(paren
r_int
id|imm
)paren
(brace
r_return
id|imm
op_lshift
l_int|19
op_rshift
l_int|19
suffix:semicolon
)brace
DECL|function|advance
r_static
r_inline
r_void
id|advance
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|regs-&gt;pc
op_assign
id|regs-&gt;npc
suffix:semicolon
id|regs-&gt;npc
op_add_assign
l_int|4
suffix:semicolon
)brace
DECL|function|maybe_flush_windows
r_static
r_inline
r_void
id|maybe_flush_windows
c_func
(paren
r_int
r_int
id|rs1
comma
r_int
r_int
id|rs2
comma
r_int
r_int
id|rd
)paren
(brace
r_if
c_cond
(paren
id|rs2
op_ge
l_int|16
op_logical_or
id|rs1
op_ge
l_int|16
op_logical_or
id|rd
op_ge
l_int|16
)paren
(brace
multiline_comment|/* Wheee... */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;
l_string|&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;
l_string|&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;
l_string|&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;
l_string|&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;
l_string|&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;
l_string|&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;
l_string|&quot;restore; restore; restore; restore;&bslash;n&bslash;t&quot;
l_string|&quot;restore; restore; restore;&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|macro|fetch_reg
mdefine_line|#define fetch_reg(reg, regs) ({&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct reg_window *win;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;register unsigned long ret;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(reg)) ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if((reg) &lt; 16) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = regs-&gt;u_regs[(reg)];&t;&t;&t;&t;&t;&bslash;&n;&t;} else {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;/* Ho hum, the slightly complicated case. */&t;&t;&t;&bslash;&n;&t;&t;win = (struct reg_window *)regs-&gt;u_regs[UREG_FP];&t;&t;&bslash;&n;&t;&t;if (get_user (ret, &amp;win-&gt;locals[(reg) - 16])) return -1;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
r_static
r_inline
r_int
DECL|function|store_reg
id|store_reg
c_func
(paren
r_int
r_int
id|result
comma
r_int
r_int
id|reg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|reg_window
op_star
id|win
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reg
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|16
)paren
(brace
id|regs-&gt;u_regs
(braket
id|reg
)braket
op_assign
id|result
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need to use put_user() in this case: */
id|win
op_assign
(paren
r_struct
id|reg_window
op_star
)paren
id|regs-&gt;u_regs
(braket
id|UREG_FP
)braket
suffix:semicolon
r_return
(paren
id|put_user
c_func
(paren
id|result
comma
op_amp
id|win-&gt;locals
(braket
id|reg
op_minus
l_int|16
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
r_extern
r_void
id|handle_hw_divzero
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|pc
comma
r_int
r_int
id|npc
comma
r_int
r_int
id|psr
)paren
suffix:semicolon
multiline_comment|/* Should return 0 if mul/div emulation succeeded and SIGILL should not be issued */
DECL|function|do_user_muldiv
r_int
id|do_user_muldiv
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|pc
)paren
(brace
r_int
r_int
id|insn
suffix:semicolon
r_int
id|inst
suffix:semicolon
r_int
r_int
id|rs1
comma
id|rs2
comma
id|rdv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pc
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This happens to often, I think */
r_if
c_cond
(paren
id|get_user
(paren
id|insn
comma
(paren
r_int
r_int
op_star
)paren
id|pc
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|insn
op_amp
l_int|0xc1400000
)paren
op_ne
l_int|0x80400000
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|inst
op_assign
(paren
(paren
id|insn
op_rshift
l_int|19
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inst
op_amp
l_int|0xe
)paren
op_ne
l_int|10
op_logical_and
(paren
id|inst
op_amp
l_int|0xe
)paren
op_ne
l_int|14
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now we know we have to do something with umul, smul, udiv or sdiv */
id|rs1
op_assign
(paren
id|insn
op_rshift
l_int|14
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|rs2
op_assign
id|insn
op_amp
l_int|0x1f
suffix:semicolon
id|rdv
op_assign
(paren
id|insn
op_rshift
l_int|25
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|has_imm13
c_func
(paren
id|insn
)paren
)paren
(brace
id|maybe_flush_windows
c_func
(paren
id|rs1
comma
l_int|0
comma
id|rdv
)paren
suffix:semicolon
id|rs2
op_assign
id|sign_extend_imm13
c_func
(paren
id|insn
)paren
suffix:semicolon
)brace
r_else
(brace
id|maybe_flush_windows
c_func
(paren
id|rs1
comma
id|rs2
comma
id|rdv
)paren
suffix:semicolon
id|rs2
op_assign
id|fetch_reg
c_func
(paren
id|rs2
comma
id|regs
)paren
suffix:semicolon
)brace
id|rs1
op_assign
id|fetch_reg
c_func
(paren
id|rs1
comma
id|regs
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|inst
)paren
(brace
r_case
l_int|10
suffix:colon
multiline_comment|/* umul */
macro_line|#ifdef DEBUG_MULDIV&t;
id|printk
(paren
l_string|&quot;unsigned muldiv: 0x%x * 0x%x = &quot;
comma
id|rs1
comma
id|rs2
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|__asm__
id|__volatile__
(paren
l_string|&quot;&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%0, %%o0&bslash;n&bslash;t&quot;
l_string|&quot;call&t;.umul&bslash;n&bslash;t&quot;
l_string|&quot; mov&t;%1, %%o1&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o0, %0&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o1, %1&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|rs1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|rs2
)paren
suffix:colon
suffix:colon
l_string|&quot;o0&quot;
comma
l_string|&quot;o1&quot;
comma
l_string|&quot;o2&quot;
comma
l_string|&quot;o3&quot;
comma
l_string|&quot;o4&quot;
comma
l_string|&quot;o5&quot;
comma
l_string|&quot;o7&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;0x%x%08x&bslash;n&quot;
comma
id|rs2
comma
id|rs1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|store_reg
c_func
(paren
id|rs1
comma
id|rdv
comma
id|regs
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|regs-&gt;y
op_assign
id|rs2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* smul */
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;signed muldiv: 0x%x * 0x%x = &quot;
comma
id|rs1
comma
id|rs2
)paren
suffix:semicolon
macro_line|#endif
id|__asm__
id|__volatile__
(paren
l_string|&quot;&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%0, %%o0&bslash;n&bslash;t&quot;
l_string|&quot;call&t;.mul&bslash;n&bslash;t&quot;
l_string|&quot; mov&t;%1, %%o1&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o0, %0&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o1, %1&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|rs1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|rs2
)paren
suffix:colon
suffix:colon
l_string|&quot;o0&quot;
comma
l_string|&quot;o1&quot;
comma
l_string|&quot;o2&quot;
comma
l_string|&quot;o3&quot;
comma
l_string|&quot;o4&quot;
comma
l_string|&quot;o5&quot;
comma
l_string|&quot;o7&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;0x%x%08x&bslash;n&quot;
comma
id|rs2
comma
id|rs1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|store_reg
c_func
(paren
id|rs1
comma
id|rdv
comma
id|regs
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|regs-&gt;y
op_assign
id|rs2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* udiv */
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;unsigned muldiv: 0x%x%08x / 0x%x = &quot;
comma
id|regs-&gt;y
comma
id|rs1
comma
id|rs2
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|rs2
)paren
(brace
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;DIVISION BY ZERO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|handle_hw_divzero
(paren
id|regs
comma
id|pc
comma
id|regs-&gt;npc
comma
id|regs-&gt;psr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%2, %%o0&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%0, %%o1&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%g0, %%o2&bslash;n&bslash;t&quot;
l_string|&quot;call&t;__udivdi3&bslash;n&bslash;t&quot;
l_string|&quot; mov&t;%1, %%o3&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o1, %0&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o0, %1&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|rs1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|rs2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|regs-&gt;y
)paren
suffix:colon
l_string|&quot;o0&quot;
comma
l_string|&quot;o1&quot;
comma
l_string|&quot;o2&quot;
comma
l_string|&quot;o3&quot;
comma
l_string|&quot;o4&quot;
comma
l_string|&quot;o5&quot;
comma
l_string|&quot;o7&quot;
comma
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;0x%x&bslash;n&quot;
comma
id|rs1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|store_reg
c_func
(paren
id|rs1
comma
id|rdv
comma
id|regs
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
multiline_comment|/* sdiv */
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;signed muldiv: 0x%x%08x / 0x%x = &quot;
comma
id|regs-&gt;y
comma
id|rs1
comma
id|rs2
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|rs2
)paren
(brace
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;DIVISION BY ZERO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|handle_hw_divzero
(paren
id|regs
comma
id|pc
comma
id|regs-&gt;npc
comma
id|regs-&gt;psr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%2, %%o0&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%0, %%o1&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%g0, %%o2&bslash;n&bslash;t&quot;
l_string|&quot;call&t;__divdi3&bslash;n&bslash;t&quot;
l_string|&quot; mov&t;%1, %%o3&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o1, %0&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%%o0, %1&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|rs1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|rs2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|regs-&gt;y
)paren
suffix:colon
l_string|&quot;o0&quot;
comma
l_string|&quot;o1&quot;
comma
l_string|&quot;o2&quot;
comma
l_string|&quot;o3&quot;
comma
l_string|&quot;o4&quot;
comma
l_string|&quot;o5&quot;
comma
l_string|&quot;o7&quot;
comma
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;0x%x&bslash;n&quot;
comma
id|rs1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|store_reg
c_func
(paren
id|rs1
comma
id|rdv
comma
id|regs
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_foocc
(paren
id|insn
)paren
)paren
(brace
id|regs-&gt;psr
op_and_assign
op_complement
id|PSR_ICC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inst
op_amp
l_int|0xe
)paren
op_eq
l_int|14
)paren
(brace
multiline_comment|/* ?div */
r_if
c_cond
(paren
id|rs2
)paren
id|regs-&gt;psr
op_or_assign
id|PSR_V
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rs1
)paren
id|regs-&gt;psr
op_or_assign
id|PSR_Z
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|rs1
)paren
OL
l_int|0
)paren
id|regs-&gt;psr
op_or_assign
id|PSR_N
suffix:semicolon
macro_line|#ifdef DEBUG_MULDIV
id|printk
(paren
l_string|&quot;psr muldiv: %08x&bslash;n&quot;
comma
id|regs-&gt;psr
)paren
suffix:semicolon
macro_line|#endif
)brace
id|advance
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
