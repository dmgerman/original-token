multiline_comment|/* windows.c: Routines to deal with register window management&n; *            at the C-code level.&n; *&n; * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* Do save&squot;s until all user register windows are out of the cpu. */
DECL|function|flush_user_windows
r_void
id|flush_user_windows
c_func
(paren
r_void
)paren
(brace
r_register
r_int
id|ctr
id|asm
c_func
(paren
l_string|&quot;g5&quot;
)paren
suffix:semicolon
id|ctr
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
l_int|1
suffix:colon
id|ld
(braket
op_mod
op_mod
id|g6
op_plus
op_mod
l_int|2
)braket
comma
op_mod
op_mod
id|g4
id|orcc
op_mod
op_mod
id|g0
comma
op_mod
op_mod
id|g4
comma
op_mod
op_mod
id|g0
id|add
op_mod
l_int|0
comma
l_int|1
comma
op_mod
l_int|0
id|bne
l_int|1
id|b
id|save
op_mod
op_mod
id|sp
comma
op_minus
l_int|64
comma
op_mod
op_mod
id|sp
l_int|2
suffix:colon
id|subcc
op_mod
l_int|0
comma
l_int|1
comma
op_mod
l_int|0
id|bne
l_int|2
id|b
id|restore
op_mod
op_mod
id|g0
comma
op_mod
op_mod
id|g0
comma
op_mod
op_mod
id|g0
"&quot;"
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|ctr
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|ctr
)paren
comma
l_string|&quot;i&quot;
(paren
(paren
r_const
r_int
r_int
)paren
(paren
op_amp
(paren
(paren
(paren
r_struct
id|task_struct
op_star
)paren
l_int|0
)paren
op_member_access_from_pointer
id|thread.uwinmask
)paren
)paren
)paren
suffix:colon
l_string|&quot;g4&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
DECL|function|shift_window_buffer
r_static
r_inline
r_void
id|shift_window_buffer
c_func
(paren
r_int
id|first_win
comma
r_int
id|last_win
comma
r_struct
id|thread_struct
op_star
id|tp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|first_win
suffix:semicolon
id|i
OL
id|last_win
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tp-&gt;rwbuf_stkptrs
(braket
id|i
)braket
op_assign
id|tp-&gt;rwbuf_stkptrs
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tp-&gt;reg_window
(braket
id|i
)braket
comma
op_amp
id|tp-&gt;reg_window
(braket
id|i
op_plus
l_int|1
)braket
comma
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Place as many of the user&squot;s current register windows &n; * on the stack that we can.  Even if the %sp is unaligned&n; * we still copy the window there, the only case that we don&squot;t&n; * succeed is if the %sp points to a bum mapping altogether.&n; * setup_frame() and do_sigreturn() use this before shifting&n; * the user stack around.  Future instruction and hardware&n; * bug workaround routines will need this functionality as&n; * well.&n; */
DECL|function|synchronize_user_stack
r_void
id|synchronize_user_stack
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|tp
suffix:semicolon
r_int
id|window
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;w_saved
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Ok, there is some dirty work to do. */
r_for
c_loop
(paren
id|window
op_assign
id|tp-&gt;w_saved
op_minus
l_int|1
suffix:semicolon
id|window
op_ge
l_int|0
suffix:semicolon
id|window
op_decrement
)paren
(brace
r_int
r_int
id|sp
op_assign
id|tp-&gt;rwbuf_stkptrs
(braket
id|window
)braket
suffix:semicolon
multiline_comment|/* Ok, let it rip. */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|sp
comma
op_amp
id|tp-&gt;reg_window
(braket
id|window
)braket
comma
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|shift_window_buffer
c_func
(paren
id|window
comma
id|tp-&gt;w_saved
op_minus
l_int|1
comma
id|tp
)paren
suffix:semicolon
id|tp-&gt;w_saved
op_decrement
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/* An optimization. */
r_static
r_inline
r_void
id|copy_aligned_window
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_void
op_star
id|src
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldd [%1], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x8], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x8]&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x10], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x18], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0 + 0x10]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x18]&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x20], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x28], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0 + 0x20]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x28]&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x30], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x38], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0 + 0x30]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x38]&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|dest
)paren
comma
l_string|&quot;r&quot;
(paren
id|src
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;g4&quot;
comma
l_string|&quot;g5&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Try to push the windows in a threads window buffer to the&n; * user stack.  Unaligned %sp&squot;s are not allowed here.&n; */
DECL|function|try_to_clear_window_buffer
r_void
id|try_to_clear_window_buffer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|who
)paren
(brace
r_struct
id|thread_struct
op_star
id|tp
suffix:semicolon
r_int
id|window
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_for
c_loop
(paren
id|window
op_assign
l_int|0
suffix:semicolon
id|window
OL
id|tp-&gt;w_saved
suffix:semicolon
id|window
op_increment
)paren
(brace
r_int
r_int
id|sp
op_assign
id|tp-&gt;rwbuf_stkptrs
(braket
id|window
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sp
op_amp
l_int|7
)paren
op_logical_or
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|sp
comma
op_amp
id|tp-&gt;reg_window
(braket
id|window
)braket
comma
id|REGWIN_SZ
)paren
)paren
(brace
id|do_exit
c_func
(paren
id|SIGILL
)paren
suffix:semicolon
)brace
)brace
id|tp-&gt;w_saved
op_assign
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
eof
