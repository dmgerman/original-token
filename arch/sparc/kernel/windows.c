multiline_comment|/* windows.c: Routines to deal with register window management&n; *            at the C-code level.&n; *&n; * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
multiline_comment|/* Do save&squot;s until all user register windows are out of the cpu. */
DECL|function|flush_user_windows
r_void
id|flush_user_windows
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;tss.uwinmask
)paren
(brace
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|shift_window_buffer
r_static
r_inline
r_void
id|shift_window_buffer
c_func
(paren
r_int
id|first_win
comma
r_int
id|last_win
comma
r_struct
id|thread_struct
op_star
id|tp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|first_win
suffix:semicolon
id|i
OL
id|last_win
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tp-&gt;rwbuf_stkptrs
(braket
id|i
)braket
op_assign
id|tp-&gt;rwbuf_stkptrs
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tp-&gt;reg_window
(braket
id|i
)braket
comma
op_amp
id|tp-&gt;reg_window
(braket
id|i
op_plus
l_int|1
)braket
comma
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Place as many of the user&squot;s current register windows &n; * on the stack that we can.  Even if the %sp is unaligned&n; * we still copy the window there, the only case that we don&squot;t&n; * succeed is if the %sp points to a bum mapping altogether.&n; * setup_frame() and do_sigreturn() use this before shifting&n; * the user stack around.  Future instruction and hardware&n; * bug workaround routines will need this functionality as&n; * well.&n; */
DECL|function|synchronize_user_stack
r_void
id|synchronize_user_stack
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|tp
op_assign
op_amp
id|current-&gt;tss
suffix:semicolon
r_int
id|window
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;w_saved
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Ok, there is some dirty work to do. */
r_for
c_loop
(paren
id|window
op_assign
id|tp-&gt;w_saved
op_minus
l_int|1
suffix:semicolon
id|window
op_ge
l_int|0
suffix:semicolon
id|window
op_decrement
)paren
(brace
r_int
r_int
id|sp
op_assign
id|tp-&gt;rwbuf_stkptrs
(braket
id|window
)braket
suffix:semicolon
multiline_comment|/* See if %sp is reasonable at all. */
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|sp
comma
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Ok, let it rip. */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|sp
comma
op_amp
id|tp-&gt;reg_window
(braket
id|window
)braket
comma
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
suffix:semicolon
id|shift_window_buffer
c_func
(paren
id|window
comma
id|tp-&gt;w_saved
op_minus
l_int|1
comma
id|tp
)paren
suffix:semicolon
id|tp-&gt;w_saved
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* An optimization. */
DECL|function|copy_aligned_window
r_static
r_inline
r_void
id|copy_aligned_window
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_void
op_star
id|src
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldd [%1], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x8], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x8]&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x10], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x18], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0 + 0x10]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x18]&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x20], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x28], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0 + 0x20]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x28]&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x30], %%g2&bslash;n&bslash;t&quot;
l_string|&quot;ldd [%1 + 0x38], %%g4&bslash;n&bslash;t&quot;
l_string|&quot;std %%g2, [%0 + 0x30]&bslash;n&bslash;t&quot;
l_string|&quot;std %%g4, [%0 + 0x38]&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|dest
)paren
comma
l_string|&quot;r&quot;
(paren
id|src
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;g4&quot;
comma
l_string|&quot;g5&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to push the windows in a threads window buffer to the&n; * user stack.  Unaligned %sp&squot;s are not allowed here.&n; */
DECL|macro|stack_is_bad
mdefine_line|#define stack_is_bad(sp, rw) &bslash;&n;  (((sp) &amp; 7) || verify_area(rw, (char *) (sp), sizeof(struct reg_window)))
DECL|function|try_to_clear_window_buffer
r_void
id|try_to_clear_window_buffer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|who
)paren
(brace
r_struct
id|thread_struct
op_star
id|tp
op_assign
op_amp
id|current-&gt;tss
suffix:semicolon
r_int
id|window
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|window
op_assign
l_int|0
suffix:semicolon
id|window
OL
id|tp-&gt;w_saved
suffix:semicolon
id|window
op_increment
)paren
(brace
r_int
r_int
id|sp
op_assign
id|tp-&gt;rwbuf_stkptrs
(braket
id|window
)braket
suffix:semicolon
r_if
c_cond
(paren
id|stack_is_bad
c_func
(paren
id|sp
comma
id|VERIFY_WRITE
)paren
)paren
(brace
id|do_exit
c_func
(paren
id|SIGILL
)paren
suffix:semicolon
)brace
r_else
id|copy_aligned_window
c_func
(paren
(paren
r_char
op_star
)paren
id|sp
comma
op_amp
id|tp-&gt;reg_window
(braket
id|window
)braket
)paren
suffix:semicolon
)brace
id|tp-&gt;w_saved
op_assign
l_int|0
suffix:semicolon
)brace
eof
