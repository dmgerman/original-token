multiline_comment|/*  $Id: process.c,v 1.29 1995/11/25 00:58:17 davem Exp $&n; *  linux/arch/sparc/kernel/process.c&n; *&n; *  Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of process handling..&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ldt.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;asm/auxio.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/psr.h&gt;
DECL|variable|current_user_segment
r_int
id|current_user_segment
op_assign
id|USER_DS
suffix:semicolon
multiline_comment|/* the return value from get_fs */
multiline_comment|/*&n; * the idle loop on a Sparc... ;)&n; */
DECL|function|sys_idle
id|asmlinkage
r_int
id|sys_idle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;pid
op_ne
l_int|0
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* endless idle loop with no priority at all */
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|hard_reset_now
r_void
id|hard_reset_now
c_func
(paren
r_void
)paren
(brace
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|show_regwindow
r_void
id|show_regwindow
c_func
(paren
r_struct
id|reg_window
op_star
id|rw
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;l0:%08lx l1:%08lx l2:%08lx l3:%08lx l4:%08lx l5:%08lx l6:%08lx l7:%08lx&bslash;n&quot;
comma
id|rw-&gt;locals
(braket
l_int|0
)braket
comma
id|rw-&gt;locals
(braket
l_int|1
)braket
comma
id|rw-&gt;locals
(braket
l_int|2
)braket
comma
id|rw-&gt;locals
(braket
l_int|3
)braket
comma
id|rw-&gt;locals
(braket
l_int|4
)braket
comma
id|rw-&gt;locals
(braket
l_int|5
)braket
comma
id|rw-&gt;locals
(braket
l_int|6
)braket
comma
id|rw-&gt;locals
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i0:%08lx i1:%08lx i2:%08lx i3:%08lx i4:%08lx i5:%08lx i6:%08lx i7:%08lx&bslash;n&quot;
comma
id|rw-&gt;ins
(braket
l_int|0
)braket
comma
id|rw-&gt;ins
(braket
l_int|1
)braket
comma
id|rw-&gt;ins
(braket
l_int|2
)braket
comma
id|rw-&gt;ins
(braket
l_int|3
)braket
comma
id|rw-&gt;ins
(braket
l_int|4
)braket
comma
id|rw-&gt;ins
(braket
l_int|5
)braket
comma
id|rw-&gt;ins
(braket
l_int|6
)braket
comma
id|rw-&gt;ins
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PSR: %08lx PC: %08lx NPC: %08lx Y: %08lx&bslash;n&quot;
comma
id|regs-&gt;psr
comma
id|regs-&gt;pc
comma
id|regs-&gt;npc
comma
id|regs-&gt;y
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%%g0: %08lx %%g1: %08lx %%g2: %08lx %%g3: %08lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|0
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|1
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|2
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%%g4: %08lx %%g5: %08lx %%g6: %08lx %%g7: %08lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|4
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|5
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|6
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%%o0: %08lx %%o1: %08lx %%o2: %08lx %%o3: %08lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|8
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|9
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|10
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%%o4: %08lx %%o5: %08lx %%sp: %08lx %%ret_pc: %08lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|12
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|13
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|14
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free current thread data structures etc..&n; */
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
(brace
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mmu_exit_hook
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free old dead task when we know it can never be on the cpu again.&n; */
DECL|function|release_thread
r_void
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|dead_task
)paren
(brace
id|mmu_release_hook
c_func
(paren
id|dead_task
)paren
suffix:semicolon
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Make sure old user windows don&squot;t get in the way. */
id|mmu_flush_hook
c_func
(paren
id|current
)paren
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;signal
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|SIGILL
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|current-&gt;tss.w_saved
op_assign
l_int|0
suffix:semicolon
id|current-&gt;tss.uwinmask
op_assign
l_int|0
suffix:semicolon
id|current-&gt;tss.sig_address
op_assign
l_int|0
suffix:semicolon
id|current-&gt;tss.sig_desc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Signal stack state does not inherit. XXX Really? XXX */
id|current-&gt;tss.sstk_info.cur_status
op_assign
l_int|0
suffix:semicolon
id|current-&gt;tss.sstk_info.the_stack
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|current-&gt;tss.reg_window
(braket
l_int|0
)braket
comma
l_int|0
comma
(paren
r_sizeof
(paren
r_struct
id|reg_window
)paren
op_star
id|NSWINS
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|current-&gt;tss.rwbuf_stkptrs
(braket
l_int|0
)braket
comma
l_int|0
comma
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
id|NSWINS
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy a Sparc thread.  The fork() return value conventions&n; * under SunOS are nothing short of bletcherous:&n; * Parent --&gt;  %o0 == childs  pid, %o1 == 0&n; * Child  --&gt;  %o0 == parents pid, %o1 == 1&n; *&n; * I&squot;m feeling sick...&n; */
r_extern
r_void
id|ret_sys_call
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|copy_thread
r_void
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|sp
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|childregs
suffix:semicolon
r_struct
id|sparc_stackf
op_star
id|old_stack
comma
op_star
id|new_stack
suffix:semicolon
r_int
r_int
id|stack_offset
comma
id|kthread_usp
op_assign
l_int|0
suffix:semicolon
id|mmu_task_cacheflush
c_func
(paren
id|current
)paren
suffix:semicolon
id|p-&gt;tss.context
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Calculate offset to stack_frame &amp; pt_regs */
id|stack_offset
op_assign
(paren
id|PAGE_SIZE
op_minus
id|TRACEREG_SZ
)paren
suffix:semicolon
id|childregs
op_assign
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|p-&gt;kernel_stack_page
op_plus
id|stack_offset
)paren
)paren
suffix:semicolon
op_star
id|childregs
op_assign
op_star
id|regs
suffix:semicolon
id|new_stack
op_assign
(paren
(paren
(paren
r_struct
id|sparc_stackf
op_star
)paren
id|childregs
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|old_stack
op_assign
(paren
(paren
(paren
r_struct
id|sparc_stackf
op_star
)paren
id|regs
)paren
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|new_stack
op_assign
op_star
id|old_stack
suffix:semicolon
id|p-&gt;tss.ksp
op_assign
(paren
r_int
r_int
)paren
id|new_stack
suffix:semicolon
id|p-&gt;tss.kpc
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|ret_sys_call
)paren
op_minus
l_int|0x8
)paren
suffix:semicolon
multiline_comment|/* As a special case, if this is a kernel fork we need&n;&t; * to give the child a new fresh stack for when it returns&n;&t; * from the syscall. (ie. the &quot;user&quot; stack)  This happens&n;&t; * only once and we count on the page acquisition happening&n;&t; * successfully.&n;&t; */
r_if
c_cond
(paren
id|regs-&gt;psr
op_amp
id|PSR_PS
)paren
(brace
r_int
r_int
id|n_stack
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|childregs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_assign
(paren
id|n_stack
op_or
(paren
id|sp
op_amp
l_int|0xfff
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|n_stack
comma
(paren
r_char
op_star
)paren
(paren
id|sp
op_amp
id|PAGE_MASK
)paren
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|kthread_usp
op_assign
id|n_stack
suffix:semicolon
)brace
multiline_comment|/* Set the return value for the child. */
id|childregs-&gt;u_regs
(braket
id|UREG_I0
)braket
op_assign
id|current-&gt;pid
suffix:semicolon
id|childregs-&gt;u_regs
(braket
id|UREG_I1
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set the return value for the parent. */
id|regs-&gt;u_regs
(braket
id|UREG_I1
)braket
op_assign
l_int|0
suffix:semicolon
id|mmu_fork_hook
c_func
(paren
id|p
comma
id|kthread_usp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * fill in the user structure for a core dump..&n; */
DECL|function|dump_thread
r_void
id|dump_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|user
op_star
id|dump
)paren
(brace
)brace
multiline_comment|/*&n; * fill in the fpu structure for a core dump.&n; */
DECL|function|dump_fpu
r_int
id|dump_fpu
(paren
r_void
op_star
id|fpu_structure
)paren
(brace
multiline_comment|/* Currently we report that we couldn&squot;t dump the fpu structure */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sparc_execve() executes a new program after the asm stub has set&n; * things up for us.  This should basically do what I want it to.&n; */
DECL|function|sparc_execve
id|asmlinkage
r_int
id|sparc_execve
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
id|mmu_task_cacheflush
c_func
(paren
id|current
)paren
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
(paren
r_char
op_star
)paren
id|regs-&gt;u_regs
(braket
id|UREG_I0
)braket
comma
op_amp
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
(paren
r_char
op_star
op_star
)paren
id|regs-&gt;u_regs
(braket
id|UREG_I1
)braket
comma
(paren
r_char
op_star
op_star
)paren
id|regs-&gt;u_regs
(braket
id|UREG_I2
)braket
comma
id|regs
)paren
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|start_thread
r_void
id|start_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|pc
comma
r_int
r_int
id|sp
)paren
(brace
r_int
r_int
id|saved_psr
op_assign
(paren
id|regs-&gt;psr
op_amp
(paren
id|PSR_CWP
)paren
)paren
op_or
id|PSR_S
suffix:semicolon
id|memset
c_func
(paren
id|regs
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
suffix:semicolon
id|regs-&gt;pc
op_assign
(paren
(paren
id|pc
op_amp
(paren
op_complement
l_int|3
)paren
)paren
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* whee borken a.out header fields... */
id|regs-&gt;npc
op_assign
id|regs-&gt;pc
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;psr
op_assign
id|saved_psr
suffix:semicolon
id|regs-&gt;u_regs
(braket
id|UREG_G1
)braket
op_assign
id|sp
suffix:semicolon
multiline_comment|/* Base of arg/env stack area */
multiline_comment|/* XXX More mysterious netbsd garbage... XXX */
id|regs-&gt;u_regs
(braket
id|UREG_G2
)braket
op_assign
id|regs-&gt;u_regs
(braket
id|UREG_G7
)braket
op_assign
id|regs-&gt;npc
suffix:semicolon
multiline_comment|/* Allocate one reg window because the first jump into&n;&t; * user mode will restore one register window by definition&n;&t; * of the &squot;rett&squot; instruction.  Also, SunOS crt.o code&n;&t; * depends upon the arg/envp area being _exactly_ one&n;&t; * register window above %sp when the process begins&n;&t; * execution.&n;&t; */
id|sp
op_sub_assign
id|REGWIN_SZ
suffix:semicolon
id|regs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_assign
id|sp
suffix:semicolon
)brace
eof
