multiline_comment|/*&n; *  linux/arch/alpha/kernel/setup.c&n; *&n; *  Copyright (C) 1995  David S. Miller (davem@caip.rutgers.edu)&n; */
multiline_comment|/*&n; * bootup setup stuff..&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ldt.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;    /* The PROM is your friend... */
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/kdebug.h&gt;
r_extern
r_int
r_int
id|probe_devices
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Gcc is hard to keep happy ;-)&n; */
DECL|variable|screen_info
r_struct
id|screen_info
id|screen_info
op_assign
(brace
l_int|0
comma
l_int|0
comma
multiline_comment|/* orig-x, orig-y */
(brace
l_int|0
comma
l_int|0
comma
)brace
comma
multiline_comment|/* unused */
l_int|0
comma
multiline_comment|/* orig-video-page */
l_int|0
comma
multiline_comment|/* orig-video-mode */
l_int|80
comma
multiline_comment|/* orig-video-cols */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* ega_ax, ega_bx, ega_cx */
l_int|25
multiline_comment|/* orig-video-lines */
)brace
suffix:semicolon
DECL|variable|wp_works_ok
r_char
id|wp_works_ok
op_assign
l_int|0
suffix:semicolon
DECL|function|bios32_init
r_int
r_int
id|bios32_init
c_func
(paren
r_int
r_int
id|memory_start
comma
r_int
r_int
id|memory_end
)paren
(brace
r_return
id|memory_start
suffix:semicolon
)brace
multiline_comment|/* Lame prom console routines, gets registered below. Thanks for the&n; * tip Linus.  We now use a generic putchar prom routine through the&n; * linux prom library.&n; */
DECL|function|sparc_console_print
r_void
id|sparc_console_print
c_func
(paren
r_const
r_char
op_star
id|p
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
(paren
id|p
op_increment
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|prom_putchar
c_func
(paren
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
id|prom_putchar
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Typing sync at the prom promptcalls the function pointed to by&n; * romvec-&gt;pv_synchook which I set to the following function.&n; * This should sync all filesystems and return, for now it just&n; * prints out pretty messages and returns.&n; */
DECL|function|prom_sync_me
r_void
id|prom_sync_me
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PROM SYNC COMMAND...&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Returning to prom&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|boot_flags
r_int
r_int
id|boot_flags
suffix:semicolon
DECL|macro|BOOTME_DEBUG
mdefine_line|#define BOOTME_DEBUG  0x1
DECL|macro|BOOTME_SINGLE
mdefine_line|#define BOOTME_SINGLE 0x2
DECL|macro|BOOTME_KGDB
mdefine_line|#define BOOTME_KGDB   0x3
multiline_comment|/* This routine does no error checking, make sure your string is sane&n; * before calling this!&n; * XXX This is cheese, make generic and better.&n; */
r_void
DECL|function|boot_flags_init
id|boot_flags_init
c_func
(paren
r_char
op_star
id|commands
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|strlen
c_func
(paren
id|commands
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|commands
(braket
id|i
)braket
op_eq
l_char|&squot;-&squot;
)paren
r_switch
c_cond
(paren
id|commands
(braket
id|i
op_plus
l_int|1
)braket
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
id|boot_flags
op_or_assign
id|BOOTME_DEBUG
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|boot_flags
op_or_assign
id|BOOTME_SINGLE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|printk
c_func
(paren
l_string|&quot;boot_flags_init: Found halt flag, doing so now...&bslash;n&quot;
)paren
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;k&squot;
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Found KGDB boot flag...&bslash;n&quot;
)paren
suffix:semicolon
id|boot_flags
op_or_assign
id|BOOTME_KGDB
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;boot_flags_init: Unknown boot arg (-%c)&bslash;n&quot;
comma
id|commands
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* This routine will in the future do all the nasty prom stuff&n; * to probe for the mmu type and its parameters, etc. This will&n; * also be where SMP things happen plus the Sparc specific memory&n; * physical memory probe as on the alpha.&n; */
r_extern
r_void
id|register_console
c_func
(paren
r_void
(paren
op_star
id|proc
)paren
(paren
r_const
r_char
op_star
)paren
)paren
suffix:semicolon
r_extern
r_void
id|load_mmu
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|prom_probe_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|probe_mmu
c_func
(paren
r_int
id|node
)paren
suffix:semicolon
r_extern
r_void
id|get_idprom
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|srmmu_patch_fhandlers
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|prom_iface_vers
comma
id|end_of_phys_memory
comma
id|phys_bytes_of_ram
suffix:semicolon
r_extern
r_char
id|cputypval
suffix:semicolon
r_extern
r_int
r_int
id|start
suffix:semicolon
DECL|variable|sparc_command_line
r_char
id|sparc_command_line
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* Should be enough */
DECL|variable|sparc_cpu_model
r_enum
id|sparc_cpu
id|sparc_cpu_model
suffix:semicolon
DECL|variable|sparc_ttable
r_struct
id|tt_entry
op_star
id|sparc_ttable
suffix:semicolon
multiline_comment|/* #define DEBUG_CMDLINE */
DECL|function|setup_arch
r_void
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
comma
r_int
r_int
op_star
id|memory_start_p
comma
r_int
r_int
op_star
id|memory_end_p
)paren
(brace
r_int
id|counter
comma
id|total
comma
id|i
comma
id|node
suffix:semicolon
r_char
id|devtype
(braket
l_int|64
)braket
suffix:semicolon
id|sparc_ttable
op_assign
(paren
r_struct
id|tt_entry
op_star
)paren
op_amp
id|start
suffix:semicolon
id|register_console
c_func
(paren
id|sparc_console_print
)paren
suffix:semicolon
multiline_comment|/* Initialize PROM console and command line. */
op_star
id|cmdline_p
op_assign
id|prom_getbootargs
c_func
(paren
)paren
suffix:semicolon
id|boot_flags_init
c_func
(paren
op_star
id|cmdline_p
)paren
suffix:semicolon
multiline_comment|/* Synchronize with debugger if necessary.  Grrr, have to check&n;&t; * the boot flags too. ;(&n;&t; */
r_if
c_cond
(paren
(paren
id|boot_flags
op_amp
id|BOOTME_DEBUG
)paren
op_logical_and
(paren
id|linux_dbvec
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
op_star
(paren
r_int
op_star
)paren
id|linux_dbvec
)paren
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Booted under debugger. Syncing up trap table.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Sync us up... */
(paren
op_star
(paren
id|linux_dbvec-&gt;teach_debugger
)paren
)paren
(paren
)paren
suffix:semicolon
id|SP_ENTER_DEBUGGER
suffix:semicolon
)brace
multiline_comment|/* Set sparc_cpu_model */
id|sparc_cpu_model
op_assign
id|sun_unknown
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_amp
id|cputypval
comma
l_string|&quot;sun4c&quot;
)paren
)paren
(brace
id|sparc_cpu_model
op_assign
id|sun4c
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_amp
id|cputypval
comma
l_string|&quot;sun4m&quot;
)paren
)paren
(brace
id|sparc_cpu_model
op_assign
id|sun4m
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_amp
id|cputypval
comma
l_string|&quot;sun4d&quot;
)paren
)paren
(brace
id|sparc_cpu_model
op_assign
id|sun4d
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_amp
id|cputypval
comma
l_string|&quot;sun4e&quot;
)paren
)paren
(brace
id|sparc_cpu_model
op_assign
id|sun4e
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_amp
id|cputypval
comma
l_string|&quot;sun4u&quot;
)paren
)paren
(brace
id|sparc_cpu_model
op_assign
id|sun4u
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ARCH: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sparc_cpu_model
)paren
(brace
r_case
id|sun4c
suffix:colon
id|memset
c_func
(paren
id|phys_seg_map
comma
l_int|0x0
comma
r_sizeof
(paren
id|phys_seg_map
(braket
id|PSEG_ENTRIES
)braket
)paren
)paren
suffix:semicolon
id|put_segmap
c_func
(paren
id|IOBASE_VADDR
comma
id|IOBASE_SUN4C_SEGMAP
)paren
suffix:semicolon
id|phys_seg_map
(braket
id|IOBASE_SUN4C_SEGMAP
)braket
op_assign
id|PSEG_RSV
suffix:semicolon
id|node
op_assign
id|prom_root_node
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SUN4C&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sun4m
suffix:colon
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
id|devtype
comma
r_sizeof
(paren
id|devtype
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|strcmp
c_func
(paren
id|devtype
comma
l_string|&quot;cpu&quot;
)paren
op_ne
l_int|0
)paren
(brace
id|node
op_assign
id|prom_getsibling
c_func
(paren
id|node
)paren
suffix:semicolon
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;device_type&quot;
comma
id|devtype
comma
r_sizeof
(paren
id|devtype
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Patch trap table. */
id|srmmu_patch_fhandlers
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SUN4M&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sun4d
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SUN4D&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sun4e
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SUN4E&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sun4u
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SUN4U&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UNKNOWN!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* probe_devices() expects this to be done. */
id|get_idprom
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Probe the mmu constants. */
id|probe_mmu
c_func
(paren
id|node
)paren
suffix:semicolon
multiline_comment|/* Set pointers to memory management routines. */
id|load_mmu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Probe for memory. */
id|total
op_assign
id|prom_probe_memory
c_func
(paren
)paren
suffix:semicolon
op_star
id|memory_start_p
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|end
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Physical Memory: %d bytes (in hex %08lx)&bslash;n&quot;
comma
(paren
r_int
)paren
id|total
comma
(paren
r_int
r_int
)paren
id|total
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|sp_banks
(braket
id|i
)braket
dot
id|num_bytes
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Bank %d:  base 0x%x  bytes %d&bslash;n&quot;
comma
id|i
comma
(paren
r_int
r_int
)paren
id|sp_banks
(braket
id|i
)braket
dot
id|base_addr
comma
(paren
r_int
)paren
id|sp_banks
(braket
id|i
)braket
dot
id|num_bytes
)paren
suffix:semicolon
macro_line|#endif
id|end_of_phys_memory
op_assign
id|sp_banks
(braket
id|i
)braket
dot
id|base_addr
op_plus
id|sp_banks
(braket
id|i
)braket
dot
id|num_bytes
suffix:semicolon
)brace
multiline_comment|/* Set prom sync hook pointer */
id|prom_setsync
c_func
(paren
id|prom_sync_me
)paren
suffix:semicolon
id|init_task.mm-&gt;start_code
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|init_task.mm-&gt;end_code
op_assign
id|PAGE_OFFSET
op_plus
(paren
r_int
r_int
)paren
op_amp
id|etext
suffix:semicolon
id|init_task.mm-&gt;end_data
op_assign
id|PAGE_OFFSET
op_plus
(paren
r_int
r_int
)paren
op_amp
id|edata
suffix:semicolon
id|init_task.mm-&gt;brk
op_assign
id|PAGE_OFFSET
op_plus
(paren
r_int
r_int
)paren
op_amp
id|end
suffix:semicolon
id|init_task.mm-&gt;mmap-&gt;vm_page_prot
op_assign
id|PAGE_SHARED
suffix:semicolon
multiline_comment|/* Grrr, wish I knew why I have to do this ;-( */
r_for
c_loop
(paren
id|counter
op_assign
l_int|1
suffix:semicolon
id|counter
OL
id|NR_TASKS
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|task
(braket
id|counter
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
op_star
id|memory_end_p
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
(paren
id|total
)paren
op_plus
id|PAGE_OFFSET
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|sys_ioperm
id|asmlinkage
r_int
id|sys_ioperm
c_func
(paren
r_int
r_int
id|from
comma
r_int
r_int
id|num
comma
r_int
id|on
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
eof
