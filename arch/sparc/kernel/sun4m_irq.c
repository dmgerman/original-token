multiline_comment|/*  sun4m_irq.c&n; *  arch/sparc/kernel/sun4m_irq.c:&n; *&n; *  djhr: Hacked out of irq.c into a CPU dependent version.&n; *&n; *  Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; *  Copyright (C) 1995 Miguel de Icaza (miguel@nuclecu.unam.mx)&n; *  Copyright (C) 1995 Pete A. Zaitcev (zaitcev@ipmce.su)&n; *  Copyright (C) 1996 Dave Redman (djhr@tadpole.co.uk)&n; */
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/psr.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/openprom.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|variable|dummy
r_static
r_int
r_int
id|dummy
suffix:semicolon
r_extern
r_int
id|linux_num_cpus
suffix:semicolon
DECL|variable|sun4m_interrupts
r_struct
id|sun4m_intregs
op_star
id|sun4m_interrupts
suffix:semicolon
DECL|variable|irq_rcvreg
r_int
r_int
op_star
id|irq_rcvreg
op_assign
op_amp
id|dummy
suffix:semicolon
multiline_comment|/* These tables only apply for interrupts greater than 15..&n; * &n; * any intr value below 0x10 is considered to be a soft-int&n; * this may be useful or it may not.. but thats how I&squot;ve done it.&n; * and it won&squot;t clash with what OBP is telling us about devices.&n; *&n; * take an encoded intr value and lookup if its valid&n; * then get the mask bits that match from irq_mask&n; */
DECL|variable|irq_xlate
r_static
r_int
r_char
id|irq_xlate
(braket
l_int|32
)braket
op_assign
(brace
multiline_comment|/*  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  a,  b,  c,  d,  e,  f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|3
comma
l_int|0
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|0
comma
l_int|0
comma
l_int|7
comma
l_int|0
comma
l_int|0
comma
l_int|8
comma
l_int|9
comma
l_int|0
comma
l_int|10
comma
l_int|0
comma
l_int|11
comma
l_int|0
comma
l_int|12
comma
l_int|0
comma
l_int|13
comma
l_int|0
comma
l_int|14
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|irq_mask
r_static
r_int
r_int
id|irq_mask
(braket
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/* illegal index */
id|SUN4M_INT_SCSI
comma
multiline_comment|/*  1 irq 4 */
id|SUN4M_INT_ETHERNET
comma
multiline_comment|/*  2 irq 6 */
id|SUN4M_INT_VIDEO
comma
multiline_comment|/*  3 irq 8 */
id|SUN4M_INT_REALTIME
comma
multiline_comment|/*  4 irq 10 */
id|SUN4M_INT_FLOPPY
comma
multiline_comment|/*  5 irq 11 */
(paren
id|SUN4M_INT_SERIAL
op_or
id|SUN4M_INT_KBDMS
)paren
comma
multiline_comment|/*  6 irq 12 */
id|SUN4M_INT_MODULE_ERR
comma
multiline_comment|/*  7 irq 15 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|1
)paren
comma
multiline_comment|/*  8 irq 2 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|2
)paren
comma
multiline_comment|/*  9 irq 3 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|3
)paren
comma
multiline_comment|/* 10 irq 5 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|4
)paren
comma
multiline_comment|/* 11 irq 7 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|5
)paren
comma
multiline_comment|/* 12 irq 9 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|6
)paren
comma
multiline_comment|/* 13 irq 11 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|7
)paren
multiline_comment|/* 14 irq 13 */
)brace
suffix:semicolon
DECL|function|sun4m_get_irqmask
r_inline
r_int
r_int
id|sun4m_get_irqmask
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
l_int|0x20
)paren
(brace
multiline_comment|/* OBIO/SBUS interrupts */
id|irq
op_and_assign
l_int|0x1f
suffix:semicolon
id|mask
op_assign
id|irq_mask
(braket
id|irq_xlate
(braket
id|irq
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;sun4m_get_irqmask: IRQ%d has no valid mask!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Soft Interrupts will come here&n;&t;&t; * Currently there is no way to trigger them but I&squot;m sure something&n;&t;&t; * could be cooked up.&n;&t;&t; */
id|irq
op_and_assign
l_int|0xf
suffix:semicolon
id|mask
op_assign
id|SUN4M_SOFT_INT
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
DECL|function|sun4m_disable_irq
r_static
r_void
id|sun4m_disable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_int
r_int
id|mask
comma
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_nr
OG
l_int|15
)paren
id|sun4m_interrupts-&gt;set
op_assign
id|mask
suffix:semicolon
r_else
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|set
op_assign
id|mask
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|sun4m_enable_irq
r_static
r_void
id|sun4m_enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_int
r_int
id|mask
comma
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Dreadful floppy hack. When we use 0x2b instead of&n;         * 0x0b the system blows (it starts to whistle!).&n;         * So we continue to use 0x0b. Fixme ASAP. --P3&n;         */
r_if
c_cond
(paren
id|irq_nr
op_ne
l_int|0x0b
)paren
(brace
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_nr
OG
l_int|15
)paren
id|sun4m_interrupts-&gt;clear
op_assign
id|mask
suffix:semicolon
r_else
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|clear
op_assign
id|mask
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;clear
op_assign
id|SUN4M_INT_FLOPPY
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|sun4m_send_ipi
r_void
id|sun4m_send_ipi
c_func
(paren
r_int
id|cpu
comma
r_int
id|level
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|level
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|set
op_assign
id|mask
suffix:semicolon
)brace
DECL|function|sun4m_clear_ipi
r_void
id|sun4m_clear_ipi
c_func
(paren
r_int
id|cpu
comma
r_int
id|level
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|level
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|clear
op_assign
id|mask
suffix:semicolon
)brace
DECL|function|sun4m_set_udt
r_void
id|sun4m_set_udt
c_func
(paren
r_int
id|cpu
)paren
(brace
id|sun4m_interrupts-&gt;undirected_target
op_assign
id|cpu
suffix:semicolon
)brace
DECL|macro|OBIO_INTR
mdefine_line|#define OBIO_INTR&t;0x20
DECL|macro|TIMER_IRQ
mdefine_line|#define TIMER_IRQ  &t;(OBIO_INTR | 10)
DECL|macro|PROFILE_IRQ
mdefine_line|#define PROFILE_IRQ&t;(OBIO_INTR | 14)
DECL|variable|sun4m_timers
r_struct
id|sun4m_timer_regs
op_star
id|sun4m_timers
suffix:semicolon
DECL|variable|lvl14_resolution
r_int
r_int
id|lvl14_resolution
op_assign
(paren
(paren
(paren
l_int|1000000
op_div
id|HZ
)paren
op_plus
l_int|1
)paren
op_lshift
l_int|10
)paren
suffix:semicolon
DECL|function|sun4m_clear_clock_irq
r_static
r_void
id|sun4m_clear_clock_irq
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|clear_intr
suffix:semicolon
id|clear_intr
op_assign
id|sun4m_timers-&gt;l10_timer_limit
suffix:semicolon
)brace
DECL|function|sun4m_clear_profile_irq
r_static
r_void
id|sun4m_clear_profile_irq
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|clear
suffix:semicolon
id|clear
op_assign
id|sun4m_timers-&gt;cpu_timers
(braket
l_int|0
)braket
dot
id|l14_timer_limit
suffix:semicolon
)brace
DECL|function|sun4m_load_profile_irq
r_static
r_void
id|sun4m_load_profile_irq
c_func
(paren
r_int
r_int
id|limit
)paren
(brace
id|sun4m_timers-&gt;cpu_timers
(braket
l_int|0
)braket
dot
id|l14_timer_limit
op_assign
id|limit
suffix:semicolon
)brace
DECL|function|sun4m_lvl14_handler
r_static
r_void
id|sun4m_lvl14_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_volatile
r_int
r_int
id|clear
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: TOOK A LEVEL14!&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* we do nothing with this at present&n;&t; * this is purely to prevent OBP getting its mucky paws&n;&t; * in linux.&n;&t; */
id|clear
op_assign
id|sun4m_timers-&gt;cpu_timers
(braket
l_int|0
)braket
dot
id|l14_timer_limit
suffix:semicolon
multiline_comment|/* clear interrupt */
multiline_comment|/* reload with value, this allows on the fly retuning of the level14&n;&t; * timer&n;&t; */
id|sun4m_timers-&gt;cpu_timers
(braket
l_int|0
)braket
dot
id|l14_timer_limit
op_assign
id|lvl14_resolution
suffix:semicolon
)brace
DECL|function|sun4m_init_timers
r_static
r_void
id|sun4m_init_timers
c_func
(paren
r_void
(paren
op_star
id|counter_fn
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_int
id|reg_count
comma
id|irq
comma
id|cpu
suffix:semicolon
r_struct
id|linux_prom_registers
id|cnt_regs
(braket
id|PROMREG_MAX
)braket
suffix:semicolon
r_int
id|obio_node
comma
id|cnt_node
suffix:semicolon
id|cnt_node
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|obio_node
op_assign
id|prom_searchsiblings
(paren
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
comma
l_string|&quot;obio&quot;
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|obio_node
op_assign
id|prom_getchild
(paren
id|obio_node
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|cnt_node
op_assign
id|prom_searchsiblings
(paren
id|obio_node
comma
l_string|&quot;counter&quot;
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Cannot find /obio/counter node&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|reg_count
op_assign
id|prom_getproperty
c_func
(paren
id|cnt_node
comma
l_string|&quot;reg&quot;
comma
(paren
r_void
op_star
)paren
id|cnt_regs
comma
r_sizeof
(paren
id|cnt_regs
)paren
)paren
suffix:semicolon
id|reg_count
op_assign
(paren
id|reg_count
op_div
r_sizeof
(paren
r_struct
id|linux_prom_registers
)paren
)paren
suffix:semicolon
multiline_comment|/* Apply the obio ranges to the timer registers. */
id|prom_apply_obio_ranges
c_func
(paren
id|cnt_regs
comma
id|reg_count
)paren
suffix:semicolon
id|cnt_regs
(braket
l_int|4
)braket
dot
id|phys_addr
op_assign
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|phys_addr
suffix:semicolon
id|cnt_regs
(braket
l_int|4
)braket
dot
id|reg_size
op_assign
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|cnt_regs
(braket
l_int|4
)braket
dot
id|which_io
op_assign
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
r_for
c_loop
(paren
id|obio_node
op_assign
l_int|1
suffix:semicolon
id|obio_node
OL
l_int|4
suffix:semicolon
id|obio_node
op_increment
)paren
(brace
id|cnt_regs
(braket
id|obio_node
)braket
dot
id|phys_addr
op_assign
id|cnt_regs
(braket
id|obio_node
op_minus
l_int|1
)braket
dot
id|phys_addr
op_plus
id|PAGE_SIZE
suffix:semicolon
id|cnt_regs
(braket
id|obio_node
)braket
dot
id|reg_size
op_assign
id|cnt_regs
(braket
id|obio_node
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|cnt_regs
(braket
id|obio_node
)braket
dot
id|which_io
op_assign
id|cnt_regs
(braket
id|obio_node
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
)brace
multiline_comment|/* Map the per-cpu Counter registers. */
id|sun4m_timers
op_assign
id|sparc_alloc_io
c_func
(paren
id|cnt_regs
(braket
l_int|0
)braket
dot
id|phys_addr
comma
l_int|0
comma
id|PAGE_SIZE
op_star
id|NCPUS
comma
l_string|&quot;counters_percpu&quot;
comma
id|cnt_regs
(braket
l_int|0
)braket
dot
id|which_io
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* Map the system Counter register. */
id|sparc_alloc_io
c_func
(paren
id|cnt_regs
(braket
l_int|4
)braket
dot
id|phys_addr
comma
l_int|0
comma
id|cnt_regs
(braket
l_int|4
)braket
dot
id|reg_size
comma
l_string|&quot;counters_system&quot;
comma
id|cnt_regs
(braket
l_int|4
)braket
dot
id|which_io
comma
l_int|0x0
)paren
suffix:semicolon
id|sun4m_timers-&gt;l10_timer_limit
op_assign
(paren
(paren
(paren
l_int|1000000
op_div
id|HZ
)paren
op_plus
l_int|1
)paren
op_lshift
l_int|10
)paren
suffix:semicolon
id|irq
op_assign
id|request_irq
c_func
(paren
id|TIMER_IRQ
comma
id|counter_fn
comma
(paren
id|SA_INTERRUPT
op_or
id|SA_STATIC_ALLOC
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;time_init: unable to attach IRQ%d&bslash;n&quot;
comma
id|TIMER_IRQ
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Can&squot;t cope with multiple CPUS yet so no level14 tick events */
macro_line|#if 0
r_if
c_cond
(paren
id|linux_num_cpus
OG
l_int|1
)paren
id|claim_ticker14
c_func
(paren
l_int|NULL
comma
id|PROFILE_IRQ
comma
l_int|0
)paren
suffix:semicolon
r_else
id|claim_ticker14
c_func
(paren
id|sun4m_lvl14_handler
comma
id|PROFILE_IRQ
comma
id|lvl14_resolution
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|linux_num_cpus
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
l_int|4
suffix:semicolon
id|cpu
op_increment
)paren
(brace
id|sun4m_timers-&gt;cpu_timers
(braket
id|cpu
)braket
dot
id|l14_timer_limit
op_assign
l_int|0
suffix:semicolon
)brace
id|sun4m_interrupts-&gt;set
op_assign
id|SUN4M_INT_E14
suffix:semicolon
)brace
r_else
(brace
id|sun4m_timers-&gt;cpu_timers
(braket
l_int|0
)braket
dot
id|l14_timer_limit
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|sun4m_init_IRQ
r_void
id|sun4m_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|ie_node
comma
id|i
suffix:semicolon
r_struct
id|linux_prom_registers
id|int_regs
(braket
id|PROMREG_MAX
)braket
suffix:semicolon
r_int
id|num_regs
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ie_node
op_assign
id|prom_searchsiblings
c_func
(paren
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
comma
l_string|&quot;obio&quot;
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|ie_node
op_assign
id|prom_getchild
(paren
id|ie_node
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|ie_node
op_assign
id|prom_searchsiblings
(paren
id|ie_node
comma
l_string|&quot;interrupt&quot;
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Cannot find /obio/interrupt node&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|num_regs
op_assign
id|prom_getproperty
c_func
(paren
id|ie_node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
id|int_regs
comma
r_sizeof
(paren
id|int_regs
)paren
)paren
suffix:semicolon
id|num_regs
op_assign
(paren
id|num_regs
op_div
r_sizeof
(paren
r_struct
id|linux_prom_registers
)paren
)paren
suffix:semicolon
multiline_comment|/* Apply the obio ranges to these registers. */
id|prom_apply_obio_ranges
c_func
(paren
id|int_regs
comma
id|num_regs
)paren
suffix:semicolon
id|int_regs
(braket
l_int|4
)braket
dot
id|phys_addr
op_assign
id|int_regs
(braket
id|num_regs
op_minus
l_int|1
)braket
dot
id|phys_addr
suffix:semicolon
id|int_regs
(braket
l_int|4
)braket
dot
id|reg_size
op_assign
id|int_regs
(braket
id|num_regs
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|int_regs
(braket
l_int|4
)braket
dot
id|which_io
op_assign
id|int_regs
(braket
id|num_regs
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
r_for
c_loop
(paren
id|ie_node
op_assign
l_int|1
suffix:semicolon
id|ie_node
OL
l_int|4
suffix:semicolon
id|ie_node
op_increment
)paren
(brace
id|int_regs
(braket
id|ie_node
)braket
dot
id|phys_addr
op_assign
id|int_regs
(braket
id|ie_node
op_minus
l_int|1
)braket
dot
id|phys_addr
op_plus
id|PAGE_SIZE
suffix:semicolon
id|int_regs
(braket
id|ie_node
)braket
dot
id|reg_size
op_assign
id|int_regs
(braket
id|ie_node
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|int_regs
(braket
id|ie_node
)braket
dot
id|which_io
op_assign
id|int_regs
(braket
id|ie_node
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
)brace
multiline_comment|/* Map the interrupt registers for all possible cpus. */
id|sun4m_interrupts
op_assign
id|sparc_alloc_io
c_func
(paren
id|int_regs
(braket
l_int|0
)braket
dot
id|phys_addr
comma
l_int|0
comma
id|PAGE_SIZE
op_star
id|NCPUS
comma
l_string|&quot;interrupts_percpu&quot;
comma
id|int_regs
(braket
l_int|0
)braket
dot
id|which_io
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* Map the system interrupt control registers. */
id|sparc_alloc_io
c_func
(paren
id|int_regs
(braket
l_int|4
)braket
dot
id|phys_addr
comma
l_int|0
comma
id|int_regs
(braket
l_int|4
)braket
dot
id|reg_size
comma
l_string|&quot;interrupts_system&quot;
comma
id|int_regs
(braket
l_int|4
)braket
dot
id|which_io
comma
l_int|0x0
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;set
op_assign
op_complement
id|SUN4M_INT_MASKALL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linux_num_cpus
suffix:semicolon
id|i
op_increment
)paren
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|i
)braket
dot
id|clear
op_assign
op_complement
l_int|0x17fff
suffix:semicolon
r_if
c_cond
(paren
id|linux_num_cpus
OG
l_int|1
)paren
(brace
multiline_comment|/* system wide interrupts go to cpu 0, this should always&n;&t;&t; * be safe because it is guaranteed to be fitted or OBP doesn&squot;t&n;&t;&t; * come up&n;&t;&t; *&n;&t;&t; * Not sure, but writing here on SLAVIO systems may puke&n;&t;&t; * so I don&squot;t do it unless there is more than 1 cpu.&n;&t;&t; */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Warning:&quot;
l_string|&quot;sun4m multiple CPU interrupt code requires work&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|irq_rcvreg
op_assign
op_amp
id|sun4m_interrupts-&gt;undirected_target
suffix:semicolon
id|sun4m_interrupts-&gt;undirected_target
op_assign
l_int|0
suffix:semicolon
)brace
id|enable_irq
op_assign
id|sun4m_enable_irq
suffix:semicolon
id|disable_irq
op_assign
id|sun4m_disable_irq
suffix:semicolon
id|clear_clock_irq
op_assign
id|sun4m_clear_clock_irq
suffix:semicolon
id|clear_profile_irq
op_assign
id|sun4m_clear_profile_irq
suffix:semicolon
id|load_profile_irq
op_assign
id|sun4m_load_profile_irq
suffix:semicolon
id|init_timers
op_assign
id|sun4m_init_timers
suffix:semicolon
macro_line|#ifdef __SMP__
id|set_cpu_int
op_assign
id|sun4m_send_ipi
suffix:semicolon
id|clear_cpu_int
op_assign
id|sun4m_clear_ipi
suffix:semicolon
id|set_irq_udt
op_assign
id|sun4m_set_udt
suffix:semicolon
macro_line|#endif
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
eof
