multiline_comment|/*  sun4m_irq.c&n; *  arch/sparc/kernel/sun4m_irq.c:&n; *&n; *  djhr: Hacked out of irq.c into a CPU dependent version.&n; *&n; *  Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; *  Copyright (C) 1995 Miguel de Icaza (miguel@nuclecu.unam.mx)&n; *  Copyright (C) 1995 Pete A. Zaitcev (zaitcev@ipmce.su)&n; *  Copyright (C) 1996 Dave Redman (djhr@tadpole.co.uk)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/psr.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/openprom.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|variable|dummy
r_static
r_int
r_int
id|dummy
suffix:semicolon
DECL|variable|sun4m_interrupts
r_struct
id|sun4m_intregs
op_star
id|sun4m_interrupts
suffix:semicolon
DECL|variable|irq_rcvreg
r_int
r_int
op_star
id|irq_rcvreg
op_assign
op_amp
id|dummy
suffix:semicolon
multiline_comment|/* These tables only apply for interrupts greater than 15..&n; * &n; * any intr value below 0x10 is considered to be a soft-int&n; * this may be useful or it may not.. but that&squot;s how I&squot;ve done it.&n; * and it won&squot;t clash with what OBP is telling us about devices.&n; *&n; * take an encoded intr value and lookup if it&squot;s valid&n; * then get the mask bits that match from irq_mask&n; *&n; * P3: Translation from irq 0x0d to mask 0x2000 is for MrCoffee.&n; */
DECL|variable|irq_xlate
r_static
r_int
r_char
id|irq_xlate
(braket
l_int|32
)braket
op_assign
(brace
multiline_comment|/*  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  a,  b,  c,  d,  e,  f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|3
comma
l_int|0
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|14
comma
l_int|0
comma
l_int|7
comma
l_int|0
comma
l_int|0
comma
l_int|8
comma
l_int|9
comma
l_int|0
comma
l_int|10
comma
l_int|0
comma
l_int|11
comma
l_int|0
comma
l_int|12
comma
l_int|0
comma
l_int|13
comma
l_int|0
comma
l_int|14
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|irq_mask
r_static
r_int
r_int
id|irq_mask
(braket
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/* illegal index */
id|SUN4M_INT_SCSI
comma
multiline_comment|/*  1 irq 4 */
id|SUN4M_INT_ETHERNET
comma
multiline_comment|/*  2 irq 6 */
id|SUN4M_INT_VIDEO
comma
multiline_comment|/*  3 irq 8 */
id|SUN4M_INT_REALTIME
comma
multiline_comment|/*  4 irq 10 */
id|SUN4M_INT_FLOPPY
comma
multiline_comment|/*  5 irq 11 */
(paren
id|SUN4M_INT_SERIAL
op_or
id|SUN4M_INT_KBDMS
)paren
comma
multiline_comment|/*  6 irq 12 */
id|SUN4M_INT_MODULE_ERR
comma
multiline_comment|/*  7 irq 15 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|0
)paren
comma
multiline_comment|/*  8 irq 2 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|1
)paren
comma
multiline_comment|/*  9 irq 3 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|2
)paren
comma
multiline_comment|/* 10 irq 5 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|3
)paren
comma
multiline_comment|/* 11 irq 7 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|4
)paren
comma
multiline_comment|/* 12 irq 9 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|5
)paren
comma
multiline_comment|/* 13 irq 11 */
id|SUN4M_INT_SBUS
c_func
(paren
l_int|6
)paren
multiline_comment|/* 14 irq 13 */
)brace
suffix:semicolon
DECL|function|sun4m_get_irqmask
r_inline
r_int
r_int
id|sun4m_get_irqmask
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
l_int|0x20
)paren
(brace
multiline_comment|/* OBIO/SBUS interrupts */
id|irq
op_and_assign
l_int|0x1f
suffix:semicolon
id|mask
op_assign
id|irq_mask
(braket
id|irq_xlate
(braket
id|irq
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;sun4m_get_irqmask: IRQ%d has no valid mask!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Soft Interrupts will come here.&n;&t;&t; * Currently there is no way to trigger them but I&squot;m sure&n;&t;&t; * something could be cooked up.&n;&t;&t; */
id|irq
op_and_assign
l_int|0xf
suffix:semicolon
id|mask
op_assign
id|SUN4M_SOFT_INT
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
DECL|function|sun4m_disable_irq
r_static
r_void
id|sun4m_disable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_int
r_int
id|mask
comma
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_nr
OG
l_int|15
)paren
id|sun4m_interrupts-&gt;set
op_assign
id|mask
suffix:semicolon
r_else
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|set
op_assign
id|mask
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|sun4m_enable_irq
r_static
r_void
id|sun4m_enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_int
r_int
id|mask
comma
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Dreadful floppy hack. When we use 0x2b instead of&n;         * 0x0b the system blows (it starts to whistle!).&n;         * So we continue to use 0x0b. Fixme ASAP. --P3&n;         */
r_if
c_cond
(paren
id|irq_nr
op_ne
l_int|0x0b
)paren
(brace
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_nr
OG
l_int|15
)paren
id|sun4m_interrupts-&gt;clear
op_assign
id|mask
suffix:semicolon
r_else
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|clear
op_assign
id|mask
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;clear
op_assign
id|SUN4M_INT_FLOPPY
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|variable|cpu_pil_to_imask
r_static
r_int
r_int
id|cpu_pil_to_imask
(braket
l_int|16
)braket
op_assign
(brace
multiline_comment|/*0*/
l_int|0x00000000
comma
multiline_comment|/*1*/
l_int|0x00000000
comma
multiline_comment|/*2*/
id|SUN4M_INT_SBUS
c_func
(paren
l_int|0
)paren
op_or
id|SUN4M_INT_VME
c_func
(paren
l_int|0
)paren
comma
multiline_comment|/*3*/
id|SUN4M_INT_SBUS
c_func
(paren
l_int|1
)paren
op_or
id|SUN4M_INT_VME
c_func
(paren
l_int|1
)paren
comma
multiline_comment|/*4*/
id|SUN4M_INT_SCSI
comma
multiline_comment|/*5*/
id|SUN4M_INT_SBUS
c_func
(paren
l_int|2
)paren
op_or
id|SUN4M_INT_VME
c_func
(paren
l_int|2
)paren
comma
multiline_comment|/*6*/
id|SUN4M_INT_ETHERNET
comma
multiline_comment|/*7*/
id|SUN4M_INT_SBUS
c_func
(paren
l_int|3
)paren
op_or
id|SUN4M_INT_VME
c_func
(paren
l_int|3
)paren
comma
multiline_comment|/*8*/
id|SUN4M_INT_VIDEO
comma
multiline_comment|/*9*/
id|SUN4M_INT_SBUS
c_func
(paren
l_int|4
)paren
op_or
id|SUN4M_INT_VME
c_func
(paren
l_int|4
)paren
op_or
id|SUN4M_INT_MODULE_ERR
comma
multiline_comment|/*10*/
id|SUN4M_INT_REALTIME
comma
multiline_comment|/*11*/
id|SUN4M_INT_SBUS
c_func
(paren
l_int|5
)paren
op_or
id|SUN4M_INT_VME
c_func
(paren
l_int|5
)paren
op_or
id|SUN4M_INT_FLOPPY
comma
multiline_comment|/*12*/
id|SUN4M_INT_SERIAL
op_or
id|SUN4M_INT_KBDMS
comma
multiline_comment|/*13*/
id|SUN4M_INT_AUDIO
comma
multiline_comment|/*14*/
id|SUN4M_INT_E14
comma
multiline_comment|/*15*/
l_int|0x00000000
)brace
suffix:semicolon
multiline_comment|/* We assume the caller is local cli()&squot;d when these are called, or else&n; * very bizarre behavior will result.&n; */
DECL|function|sun4m_disable_pil_irq
r_static
r_void
id|sun4m_disable_pil_irq
c_func
(paren
r_int
r_int
id|pil
)paren
(brace
id|sun4m_interrupts-&gt;set
op_assign
id|cpu_pil_to_imask
(braket
id|pil
)braket
suffix:semicolon
)brace
DECL|function|sun4m_enable_pil_irq
r_static
r_void
id|sun4m_enable_pil_irq
c_func
(paren
r_int
r_int
id|pil
)paren
(brace
id|sun4m_interrupts-&gt;clear
op_assign
id|cpu_pil_to_imask
(braket
id|pil
)braket
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|sun4m_send_ipi
r_static
r_void
id|sun4m_send_ipi
c_func
(paren
r_int
id|cpu
comma
r_int
id|level
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|level
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|set
op_assign
id|mask
suffix:semicolon
)brace
DECL|function|sun4m_clear_ipi
r_static
r_void
id|sun4m_clear_ipi
c_func
(paren
r_int
id|cpu
comma
r_int
id|level
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|mask
op_assign
id|sun4m_get_irqmask
c_func
(paren
id|level
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|cpu
)braket
dot
id|clear
op_assign
id|mask
suffix:semicolon
)brace
DECL|function|sun4m_set_udt
r_static
r_void
id|sun4m_set_udt
c_func
(paren
r_int
id|cpu
)paren
(brace
id|sun4m_interrupts-&gt;undirected_target
op_assign
id|cpu
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|OBIO_INTR
mdefine_line|#define OBIO_INTR&t;0x20
DECL|macro|TIMER_IRQ
mdefine_line|#define TIMER_IRQ  &t;(OBIO_INTR | 10)
DECL|macro|PROFILE_IRQ
mdefine_line|#define PROFILE_IRQ&t;(OBIO_INTR | 14)
DECL|variable|sun4m_timers
r_struct
id|sun4m_timer_regs
op_star
id|sun4m_timers
suffix:semicolon
DECL|variable|lvl14_resolution
r_int
r_int
id|lvl14_resolution
op_assign
(paren
(paren
(paren
l_int|1000000
op_div
id|HZ
)paren
op_plus
l_int|1
)paren
op_lshift
l_int|10
)paren
suffix:semicolon
DECL|function|sun4m_clear_clock_irq
r_static
r_void
id|sun4m_clear_clock_irq
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|clear_intr
suffix:semicolon
id|clear_intr
op_assign
id|sun4m_timers-&gt;l10_timer_limit
suffix:semicolon
)brace
DECL|function|sun4m_clear_profile_irq
r_static
r_void
id|sun4m_clear_profile_irq
c_func
(paren
r_int
id|cpu
)paren
(brace
r_volatile
r_int
r_int
id|clear
suffix:semicolon
id|clear
op_assign
id|sun4m_timers-&gt;cpu_timers
(braket
id|cpu
)braket
dot
id|l14_timer_limit
suffix:semicolon
)brace
DECL|function|sun4m_load_profile_irq
r_static
r_void
id|sun4m_load_profile_irq
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|limit
)paren
(brace
id|sun4m_timers-&gt;cpu_timers
(braket
id|cpu
)braket
dot
id|l14_timer_limit
op_assign
id|limit
suffix:semicolon
)brace
DECL|function|sun4m_irq_itoa
r_char
op_star
id|sun4m_irq_itoa
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_static
r_char
id|buff
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buff
comma
l_string|&quot;%d&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
id|buff
suffix:semicolon
)brace
DECL|function|sun4m_init_timers
r_static
r_void
id|__init
id|sun4m_init_timers
c_func
(paren
r_void
(paren
op_star
id|counter_fn
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_int
id|reg_count
comma
id|irq
comma
id|cpu
suffix:semicolon
r_struct
id|linux_prom_registers
id|cnt_regs
(braket
id|PROMREG_MAX
)braket
suffix:semicolon
r_int
id|obio_node
comma
id|cnt_node
suffix:semicolon
r_struct
id|resource
id|r
suffix:semicolon
id|cnt_node
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|obio_node
op_assign
id|prom_searchsiblings
(paren
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
comma
l_string|&quot;obio&quot;
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|obio_node
op_assign
id|prom_getchild
(paren
id|obio_node
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|cnt_node
op_assign
id|prom_searchsiblings
(paren
id|obio_node
comma
l_string|&quot;counter&quot;
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Cannot find /obio/counter node&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|reg_count
op_assign
id|prom_getproperty
c_func
(paren
id|cnt_node
comma
l_string|&quot;reg&quot;
comma
(paren
r_void
op_star
)paren
id|cnt_regs
comma
r_sizeof
(paren
id|cnt_regs
)paren
)paren
suffix:semicolon
id|reg_count
op_assign
(paren
id|reg_count
op_div
r_sizeof
(paren
r_struct
id|linux_prom_registers
)paren
)paren
suffix:semicolon
multiline_comment|/* Apply the obio ranges to the timer registers. */
id|prom_apply_obio_ranges
c_func
(paren
id|cnt_regs
comma
id|reg_count
)paren
suffix:semicolon
id|cnt_regs
(braket
l_int|4
)braket
dot
id|phys_addr
op_assign
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|phys_addr
suffix:semicolon
id|cnt_regs
(braket
l_int|4
)braket
dot
id|reg_size
op_assign
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|cnt_regs
(braket
l_int|4
)braket
dot
id|which_io
op_assign
id|cnt_regs
(braket
id|reg_count
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
r_for
c_loop
(paren
id|obio_node
op_assign
l_int|1
suffix:semicolon
id|obio_node
OL
l_int|4
suffix:semicolon
id|obio_node
op_increment
)paren
(brace
id|cnt_regs
(braket
id|obio_node
)braket
dot
id|phys_addr
op_assign
id|cnt_regs
(braket
id|obio_node
op_minus
l_int|1
)braket
dot
id|phys_addr
op_plus
id|PAGE_SIZE
suffix:semicolon
id|cnt_regs
(braket
id|obio_node
)braket
dot
id|reg_size
op_assign
id|cnt_regs
(braket
id|obio_node
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|cnt_regs
(braket
id|obio_node
)braket
dot
id|which_io
op_assign
id|cnt_regs
(braket
id|obio_node
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|r
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|resource
)paren
)paren
suffix:semicolon
multiline_comment|/* Map the per-cpu Counter registers. */
id|r.flags
op_assign
id|cnt_regs
(braket
l_int|0
)braket
dot
id|which_io
suffix:semicolon
id|r.start
op_assign
id|cnt_regs
(braket
l_int|0
)braket
dot
id|phys_addr
suffix:semicolon
id|sun4m_timers
op_assign
(paren
r_struct
id|sun4m_timer_regs
op_star
)paren
id|sbus_ioremap
c_func
(paren
op_amp
id|r
comma
l_int|0
comma
id|PAGE_SIZE
op_star
id|SUN4M_NCPUS
comma
l_string|&quot;sun4m_cpu_cnt&quot;
)paren
suffix:semicolon
multiline_comment|/* Map the system Counter register. */
multiline_comment|/* XXX Here we expect consequent calls to yeld adjusent maps. */
id|r.flags
op_assign
id|cnt_regs
(braket
l_int|4
)braket
dot
id|which_io
suffix:semicolon
id|r.start
op_assign
id|cnt_regs
(braket
l_int|4
)braket
dot
id|phys_addr
suffix:semicolon
id|sbus_ioremap
c_func
(paren
op_amp
id|r
comma
l_int|0
comma
id|cnt_regs
(braket
l_int|4
)braket
dot
id|reg_size
comma
l_string|&quot;sun4m_sys_cnt&quot;
)paren
suffix:semicolon
id|sun4m_timers-&gt;l10_timer_limit
op_assign
(paren
(paren
(paren
l_int|1000000
op_div
id|HZ
)paren
op_plus
l_int|1
)paren
op_lshift
l_int|10
)paren
suffix:semicolon
id|master_l10_counter
op_assign
op_amp
id|sun4m_timers-&gt;l10_cur_count
suffix:semicolon
id|master_l10_limit
op_assign
op_amp
id|sun4m_timers-&gt;l10_timer_limit
suffix:semicolon
id|irq
op_assign
id|request_irq
c_func
(paren
id|TIMER_IRQ
comma
id|counter_fn
comma
(paren
id|SA_INTERRUPT
op_or
id|SA_STATIC_ALLOC
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;time_init: unable to attach IRQ%d&bslash;n&quot;
comma
id|TIMER_IRQ
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|linux_num_cpus
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
l_int|4
suffix:semicolon
id|cpu
op_increment
)paren
(brace
id|sun4m_timers-&gt;cpu_timers
(braket
id|cpu
)braket
dot
id|l14_timer_limit
op_assign
l_int|0
suffix:semicolon
)brace
id|sun4m_interrupts-&gt;set
op_assign
id|SUN4M_INT_E14
suffix:semicolon
)brace
r_else
(brace
id|sun4m_timers-&gt;cpu_timers
(braket
l_int|0
)braket
dot
id|l14_timer_limit
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
(brace
r_int
r_int
id|flags
suffix:semicolon
r_extern
r_int
r_int
id|lvl14_save
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|tt_entry
op_star
id|trap_table
op_assign
op_amp
id|sparc_ttable
(braket
id|SP_TRAP_IRQ1
op_plus
(paren
l_int|14
op_minus
l_int|1
)paren
)braket
suffix:semicolon
multiline_comment|/* For SMP we use the level 14 ticker, however the bootup code&n;&t;&t; * has copied the firmwares level 14 vector into boot cpu&squot;s&n;&t;&t; * trap table, we must fix this now or we get squashed.&n;&t;&t; */
id|__save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|trap_table-&gt;inst_one
op_assign
id|lvl14_save
(braket
l_int|0
)braket
suffix:semicolon
id|trap_table-&gt;inst_two
op_assign
id|lvl14_save
(braket
l_int|1
)braket
suffix:semicolon
id|trap_table-&gt;inst_three
op_assign
id|lvl14_save
(braket
l_int|2
)braket
suffix:semicolon
id|trap_table-&gt;inst_four
op_assign
id|lvl14_save
(braket
l_int|3
)braket
suffix:semicolon
id|local_flush_cache_all
c_func
(paren
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|sun4m_init_IRQ
r_void
id|__init
id|sun4m_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|ie_node
comma
id|i
suffix:semicolon
r_struct
id|linux_prom_registers
id|int_regs
(braket
id|PROMREG_MAX
)braket
suffix:semicolon
r_int
id|num_regs
suffix:semicolon
r_struct
id|resource
id|r
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ie_node
op_assign
id|prom_searchsiblings
c_func
(paren
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
comma
l_string|&quot;obio&quot;
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|ie_node
op_assign
id|prom_getchild
(paren
id|ie_node
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|ie_node
op_assign
id|prom_searchsiblings
(paren
id|ie_node
comma
l_string|&quot;interrupt&quot;
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Cannot find /obio/interrupt node&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|num_regs
op_assign
id|prom_getproperty
c_func
(paren
id|ie_node
comma
l_string|&quot;reg&quot;
comma
(paren
r_char
op_star
)paren
id|int_regs
comma
r_sizeof
(paren
id|int_regs
)paren
)paren
suffix:semicolon
id|num_regs
op_assign
(paren
id|num_regs
op_div
r_sizeof
(paren
r_struct
id|linux_prom_registers
)paren
)paren
suffix:semicolon
multiline_comment|/* Apply the obio ranges to these registers. */
id|prom_apply_obio_ranges
c_func
(paren
id|int_regs
comma
id|num_regs
)paren
suffix:semicolon
id|int_regs
(braket
l_int|4
)braket
dot
id|phys_addr
op_assign
id|int_regs
(braket
id|num_regs
op_minus
l_int|1
)braket
dot
id|phys_addr
suffix:semicolon
id|int_regs
(braket
l_int|4
)braket
dot
id|reg_size
op_assign
id|int_regs
(braket
id|num_regs
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|int_regs
(braket
l_int|4
)braket
dot
id|which_io
op_assign
id|int_regs
(braket
id|num_regs
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
r_for
c_loop
(paren
id|ie_node
op_assign
l_int|1
suffix:semicolon
id|ie_node
OL
l_int|4
suffix:semicolon
id|ie_node
op_increment
)paren
(brace
id|int_regs
(braket
id|ie_node
)braket
dot
id|phys_addr
op_assign
id|int_regs
(braket
id|ie_node
op_minus
l_int|1
)braket
dot
id|phys_addr
op_plus
id|PAGE_SIZE
suffix:semicolon
id|int_regs
(braket
id|ie_node
)braket
dot
id|reg_size
op_assign
id|int_regs
(braket
id|ie_node
op_minus
l_int|1
)braket
dot
id|reg_size
suffix:semicolon
id|int_regs
(braket
id|ie_node
)braket
dot
id|which_io
op_assign
id|int_regs
(braket
id|ie_node
op_minus
l_int|1
)braket
dot
id|which_io
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|r
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|resource
)paren
)paren
suffix:semicolon
multiline_comment|/* Map the interrupt registers for all possible cpus. */
id|r.flags
op_assign
id|int_regs
(braket
l_int|0
)braket
dot
id|which_io
suffix:semicolon
id|r.start
op_assign
id|int_regs
(braket
l_int|0
)braket
dot
id|phys_addr
suffix:semicolon
id|sun4m_interrupts
op_assign
(paren
r_struct
id|sun4m_intregs
op_star
)paren
id|sbus_ioremap
c_func
(paren
op_amp
id|r
comma
l_int|0
comma
id|PAGE_SIZE
op_star
id|SUN4M_NCPUS
comma
l_string|&quot;interrupts_percpu&quot;
)paren
suffix:semicolon
multiline_comment|/* Map the system interrupt control registers. */
id|r.flags
op_assign
id|int_regs
(braket
l_int|4
)braket
dot
id|which_io
suffix:semicolon
id|r.start
op_assign
id|int_regs
(braket
l_int|4
)braket
dot
id|phys_addr
suffix:semicolon
id|sbus_ioremap
c_func
(paren
op_amp
id|r
comma
l_int|0
comma
id|int_regs
(braket
l_int|4
)braket
dot
id|reg_size
comma
l_string|&quot;interrupts_system&quot;
)paren
suffix:semicolon
id|sun4m_interrupts-&gt;set
op_assign
op_complement
id|SUN4M_INT_MASKALL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linux_num_cpus
suffix:semicolon
id|i
op_increment
)paren
id|sun4m_interrupts-&gt;cpu_intregs
(braket
id|i
)braket
dot
id|clear
op_assign
op_complement
l_int|0x17fff
suffix:semicolon
r_if
c_cond
(paren
id|linux_num_cpus
OG
l_int|1
)paren
(brace
multiline_comment|/* system wide interrupts go to cpu 0, this should always&n;&t;&t; * be safe because it is guaranteed to be fitted or OBP doesn&squot;t&n;&t;&t; * come up&n;&t;&t; *&n;&t;&t; * Not sure, but writing here on SLAVIO systems may puke&n;&t;&t; * so I don&squot;t do it unless there is more than 1 cpu.&n;&t;&t; */
id|irq_rcvreg
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|sun4m_interrupts-&gt;undirected_target
suffix:semicolon
id|sun4m_interrupts-&gt;undirected_target
op_assign
l_int|0
suffix:semicolon
)brace
id|BTFIXUPSET_CALL
c_func
(paren
id|enable_irq
comma
id|sun4m_enable_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|disable_irq
comma
id|sun4m_disable_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|enable_pil_irq
comma
id|sun4m_enable_pil_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|disable_pil_irq
comma
id|sun4m_disable_pil_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|clear_clock_irq
comma
id|sun4m_clear_clock_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|clear_profile_irq
comma
id|sun4m_clear_profile_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|load_profile_irq
comma
id|sun4m_load_profile_irq
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|__irq_itoa
comma
id|sun4m_irq_itoa
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|init_timers
op_assign
id|sun4m_init_timers
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|BTFIXUPSET_CALL
c_func
(paren
id|set_cpu_int
comma
id|sun4m_send_ipi
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|clear_cpu_int
comma
id|sun4m_clear_ipi
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
id|BTFIXUPSET_CALL
c_func
(paren
id|set_irq_udt
comma
id|sun4m_set_udt
comma
id|BTFIXUPCALL_NORM
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Cannot enable interrupts until OBP ticker is disabled. */
)brace
eof
