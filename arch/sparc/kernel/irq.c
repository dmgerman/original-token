multiline_comment|/*  $Id: irq.c,v 1.57 1996/11/30 02:13:53 davem Exp $&n; *  arch/sparc/kernel/irq.c:  Interrupt request handling routines. On the&n; *                            Sparc the IRQ&squot;s are basically &squot;cast in stone&squot;&n; *                            and you are supposed to probe the prom&squot;s device&n; *                            node trees to find out who&squot;s got which IRQ.&n; *&n; *  Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; *  Copyright (C) 1995 Miguel de Icaza (miguel@nuclecu.unam.mx)&n; *  Copyright (C) 1995 Pete A. Zaitcev (zaitcev@ipmce.su)&n; *  Copyright (C) 1996 Dave Redman (djhr@tadpole.co.uk)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/psr.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/openprom.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/*&n; * Dave Redman (djhr@tadpole.co.uk)&n; *&n; * IRQ numbers.. These are no longer restricted to 15..&n; *&n; * this is done to enable SBUS cards and onboard IO to be masked&n; * correctly. using the interrupt level isn&squot;t good enough.&n; *&n; * For example:&n; *   A device interrupting at sbus level6 and the Floppy both come in&n; *   at IRQ11, but enabling and disabling them requires writing to&n; *   different bits in the SLAVIO/SEC.&n; *&n; * As a result of these changes sun4m machines could now support&n; * directed CPU interrupts using the existing enable/disable irq code&n; * with tweaks.&n; *&n; */
DECL|function|irq_panic
r_static
r_void
id|irq_panic
c_func
(paren
r_void
)paren
(brace
r_extern
r_char
op_star
id|cputypval
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;machine: %s doesn&squot;t have irq handlers defined!&bslash;n&quot;
comma
id|cputypval
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|enable_irq
r_void
(paren
op_star
id|enable_irq
)paren
(paren
r_int
r_int
)paren
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|irq_panic
suffix:semicolon
DECL|variable|disable_irq
r_void
(paren
op_star
id|disable_irq
)paren
(paren
r_int
r_int
)paren
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|irq_panic
suffix:semicolon
DECL|variable|clear_clock_irq
r_void
(paren
op_star
id|clear_clock_irq
)paren
(paren
r_void
)paren
op_assign
id|irq_panic
suffix:semicolon
DECL|variable|clear_profile_irq
r_void
(paren
op_star
id|clear_profile_irq
)paren
(paren
r_void
)paren
op_assign
id|irq_panic
suffix:semicolon
DECL|variable|load_profile_irq
r_void
(paren
op_star
id|load_profile_irq
)paren
(paren
r_int
r_int
)paren
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|irq_panic
suffix:semicolon
DECL|variable|init_timers
r_void
(paren
op_star
id|init_timers
)paren
(paren
r_void
(paren
op_star
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
(paren
op_star
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
)paren
id|irq_panic
suffix:semicolon
macro_line|#ifdef __SMP__
DECL|variable|set_cpu_int
r_void
(paren
op_star
id|set_cpu_int
)paren
(paren
r_int
comma
r_int
)paren
suffix:semicolon
DECL|variable|clear_cpu_int
r_void
(paren
op_star
id|clear_cpu_int
)paren
(paren
r_int
comma
r_int
)paren
suffix:semicolon
DECL|variable|set_irq_udt
r_void
(paren
op_star
id|set_irq_udt
)paren
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Dave Redman (djhr@tadpole.co.uk)&n; *&n; * There used to be extern calls and hard coded values here.. very sucky!&n; * instead, because some of the devices attach very early, I do something&n; * equally sucky but at least we&squot;ll never try to free statically allocated&n; * space or call kmalloc before kmalloc_init :(.&n; * &n; * In fact it&squot;s the timer10 that attaches first.. then timer14&n; * then kmalloc_init is called.. then the tty interrupts attach.&n; * hmmm....&n; *&n; */
DECL|macro|MAX_STATIC_ALLOC
mdefine_line|#define MAX_STATIC_ALLOC&t;4
DECL|variable|static_irqaction
r_static
r_struct
id|irqaction
id|static_irqaction
(braket
id|MAX_STATIC_ALLOC
)braket
suffix:semicolon
DECL|variable|static_irq_count
r_static
r_int
id|static_irq_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq_action
r_static
r_struct
id|irqaction
op_star
id|irq_action
(braket
id|NR_IRQS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|get_irq_list
r_int
id|get_irq_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NR_IRQS
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|action
op_assign
op_star
(paren
id|i
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
r_continue
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%2d: %8d %c %s&quot;
comma
id|i
comma
id|kstat.interrupts
(braket
id|i
)braket
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;,%s %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_string|&quot; +&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|irqaction
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
id|cpu_irq
op_assign
id|irq
op_amp
id|NR_IRQS
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_irq
OG
l_int|14
)paren
(brace
multiline_comment|/* 14 irq levels on the sparc */
id|printk
c_func
(paren
l_string|&quot;Trying to free bogus IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_id
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_eq
id|dev_id
)paren
r_break
suffix:semicolon
id|tmp
op_assign
id|action
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free shared IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free shared IRQ%d with NULL device ID&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
multiline_comment|/* This interrupt is marked as specially allocated&n;&t;     * so it is a bad idea to free it.&n;&t;     */
id|printk
c_func
(paren
l_string|&quot;Attempt to free statically allocated IRQ%d (%s)&bslash;n&quot;
comma
id|irq
comma
id|action-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_logical_and
id|tmp
)paren
id|tmp-&gt;next
op_assign
id|action-&gt;next
suffix:semicolon
r_else
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
op_assign
id|action-&gt;next
suffix:semicolon
id|kfree_s
c_func
(paren
id|action
comma
r_sizeof
(paren
r_struct
id|irqaction
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
)paren
)paren
id|disable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|unexpected_irq
r_void
id|unexpected_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
id|cpu_irq
op_assign
id|irq
op_amp
id|NR_IRQS
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IO device interrupt, irq = %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PC = %08lx NPC = %08lx FP=%08lx&bslash;n&quot;
comma
id|regs-&gt;pc
comma
id|regs-&gt;npc
comma
id|regs-&gt;u_regs
(braket
l_int|14
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Expecting: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|action-&gt;handler
)paren
id|prom_printf
c_func
(paren
l_string|&quot;[%s:%d:0x%x] &quot;
comma
id|action-&gt;name
comma
(paren
r_int
)paren
id|i
comma
(paren
r_int
r_int
)paren
id|action-&gt;handler
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;AIEEE&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;bogus interrupt received&quot;
)paren
suffix:semicolon
)brace
DECL|function|handler_irq
r_void
id|handler_irq
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
id|cpu_irq
op_assign
id|irq
op_amp
id|NR_IRQS
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
id|kstat.interrupts
(braket
id|cpu_irq
)braket
op_increment
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|action
op_logical_or
op_logical_neg
id|action-&gt;handler
)paren
id|unexpected_irq
c_func
(paren
id|irq
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
id|action
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|action
)paren
suffix:semicolon
)brace
multiline_comment|/* Fast IRQ&squot;s on the Sparc can only have one routine attached to them,&n; * thus no sharing possible.&n; */
DECL|function|request_fast_irq
r_int
id|request_fast_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
macro_line|#ifdef __SMP__
r_struct
id|tt_entry
op_star
id|trap_table
suffix:semicolon
r_extern
r_struct
id|tt_entry
id|trapbase_cpu1
comma
id|trapbase_cpu2
comma
id|trapbase_cpu3
suffix:semicolon
macro_line|#endif
id|cpu_irq
op_assign
id|irq
op_amp
id|NR_IRQS
suffix:semicolon
r_if
c_cond
(paren
id|cpu_irq
OG
l_int|14
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq when already shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq as shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Anyway, someone already owns it so cannot be made fast. */
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register yet already owned.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* If this is flagged as statically allocated then we use our&n;&t; * private struct which is never freed.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Fast IRQ%d (%s) SA_STATIC_ALLOC failed using kmalloc&bslash;n&quot;
comma
id|irq
comma
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Dork with trap table if we get this far. */
DECL|macro|INSTANTIATE
mdefine_line|#define INSTANTIATE(table) &bslash;&n;&t;table[SP_TRAP_IRQ1+(cpu_irq-1)].inst_one = SPARC_RD_PSR_L0; &bslash;&n;&t;table[SP_TRAP_IRQ1+(cpu_irq-1)].inst_two = &bslash;&n;&t;&t;SPARC_BRANCH((unsigned long) handler, &bslash;&n;&t;&t;&t;     (unsigned long) &amp;table[SP_TRAP_IRQ1+(cpu_irq-1)].inst_two);&bslash;&n;&t;table[SP_TRAP_IRQ1+(cpu_irq-1)].inst_three = SPARC_RD_WIM_L3; &bslash;&n;&t;table[SP_TRAP_IRQ1+(cpu_irq-1)].inst_four = SPARC_NOP;
id|INSTANTIATE
c_func
(paren
id|sparc_ttable
)paren
macro_line|#ifdef __SMP__
id|trap_table
op_assign
op_amp
id|trapbase_cpu1
suffix:semicolon
id|INSTANTIATE
c_func
(paren
id|trap_table
)paren
id|trap_table
op_assign
op_amp
id|trapbase_cpu2
suffix:semicolon
id|INSTANTIATE
c_func
(paren
id|trap_table
)paren
id|trap_table
op_assign
op_amp
id|trapbase_cpu3
suffix:semicolon
id|INSTANTIATE
c_func
(paren
id|trap_table
)paren
macro_line|#endif
DECL|macro|INSTANTIATE
macro_line|#undef INSTANTIATE
multiline_comment|/*&n;&t; * XXX Correct thing whould be to flush only I- and D-cache lines&n;&t; * which contain the handler in question. But as of time of the&n;&t; * writing we have no CPU-neutral interface to fine-grained flushes.&n;&t; */
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;mask
op_assign
l_int|0
suffix:semicolon
id|action-&gt;name
op_assign
id|devname
suffix:semicolon
id|action-&gt;dev_id
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
id|cpu_irq
op_assign
id|irq
op_amp
id|NR_IRQS
suffix:semicolon
r_if
c_cond
(paren
id|cpu_irq
OG
l_int|14
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
op_logical_and
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
)paren
(brace
r_for
c_loop
(paren
id|tmp
op_assign
id|action
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
op_xor
(paren
id|irqflags
op_amp
id|SA_INTERRUPT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to mix fast and slow interrupts on IRQ%d denied&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Or else! */
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* If this is flagged as statically allocated then we use our&n;&t; * private struct which is never freed.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed using kmalloc&bslash;n&quot;
comma
id|irq
comma
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;mask
op_assign
l_int|0
suffix:semicolon
id|action-&gt;name
op_assign
id|devname
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|tmp-&gt;next
op_assign
id|action
suffix:semicolon
r_else
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We really don&squot;t need these at all on the Sparc.  We only have&n; * stubs here because they are exported to modules.&n; */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|probe_irq_off
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* djhr&n; * This could probably be made indirect too and assigned in the CPU&n; * bits of the code. That would be much nicer I think and would also&n; * fit in with the idea of being able to tune your kernel for your machine&n; * by removing unrequired machine and device support.&n; *&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|init_IRQ
c_func
(paren
r_void
)paren
)paren
(brace
r_extern
r_void
id|sun4c_init_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sun4m_init_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#if CONFIG_AP1000
r_extern
r_void
id|ap_init_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
id|ap_init_IRQ
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|sparc_cpu_model
)paren
(brace
r_case
id|sun4c
suffix:colon
id|sun4c_init_IRQ
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|sun4m
suffix:colon
id|sun4m_init_IRQ
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|prom_printf
c_func
(paren
l_string|&quot;Cannot initialize IRQ&squot;s on this Sun machine...&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
eof
