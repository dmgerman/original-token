multiline_comment|/* $Id: tree.c,v 1.8 1996/04/04 16:31:09 tridge Exp $&n; * tree.c: Basic device tree traversal/scanning for the Linux&n; *         prom library.&n; *&n; * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/openprom.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
DECL|variable|promlib_buf
r_static
r_char
id|promlib_buf
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* Return the child of node &squot;node&squot; or zero if no this node has no&n; * direct descendent.&n; */
r_int
DECL|function|prom_getchild
id|prom_getchild
c_func
(paren
r_int
id|node
)paren
(brace
r_int
id|cnode
suffix:semicolon
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getchild -&gt; 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|node
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|cnode
op_assign
id|prom_nodeops
op_member_access_from_pointer
id|no_child
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cnode
op_eq
l_int|0
)paren
op_logical_or
(paren
id|cnode
op_eq
op_minus
l_int|1
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|cnode
suffix:semicolon
)brace
multiline_comment|/* Return the next sibling of node &squot;node&squot; or zero if no more siblings&n; * at this level of depth in the tree.&n; */
r_int
DECL|function|prom_getsibling
id|prom_getsibling
c_func
(paren
r_int
id|node
)paren
(brace
r_int
id|sibnode
suffix:semicolon
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getsibling -&gt; 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|node
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|sibnode
op_assign
id|prom_nodeops
op_member_access_from_pointer
id|no_nextnode
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sibnode
op_eq
l_int|0
)paren
op_logical_or
(paren
id|sibnode
op_eq
op_minus
l_int|1
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|sibnode
suffix:semicolon
)brace
multiline_comment|/* Return the length in bytes of property &squot;prop&squot; at node &squot;node&squot;.&n; * Return -1 on error.&n; */
r_int
DECL|function|prom_getproplen
id|prom_getproplen
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|prop
)paren
(brace
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getproplen(%s) -&gt; -1&bslash;n&quot;
comma
id|prop
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_logical_neg
id|node
)paren
op_logical_or
(paren
op_logical_neg
id|prop
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|prom_nodeops
op_member_access_from_pointer
id|no_proplen
c_func
(paren
id|node
comma
id|prop
)paren
suffix:semicolon
)brace
multiline_comment|/* Acquire a property &squot;prop&squot; at node &squot;node&squot; and place it in&n; * &squot;buffer&squot; which has a size of &squot;bufsize&squot;.  If the acquisition&n; * was successful the length will be returned, else -1 is returned.&n; */
r_int
DECL|function|prom_getproperty
id|prom_getproperty
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|prop
comma
r_char
op_star
id|buffer
comma
r_int
id|bufsize
)paren
(brace
r_int
id|plen
suffix:semicolon
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getproperty(%s) -&gt; -1&bslash;n&quot;
comma
id|prop
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|plen
op_assign
id|prom_getproplen
c_func
(paren
id|node
comma
id|prop
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|plen
OG
id|bufsize
)paren
op_logical_or
(paren
id|plen
op_eq
l_int|0
)paren
op_logical_or
(paren
id|plen
op_eq
op_minus
l_int|1
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Ok, things seem all right. */
r_return
id|prom_nodeops
op_member_access_from_pointer
id|no_getprop
c_func
(paren
id|node
comma
id|prop
comma
id|buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* Acquire an integer property and return its value.  Returns -1&n; * on failure.&n; */
r_int
DECL|function|prom_getint
id|prom_getint
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|prop
)paren
(brace
r_static
r_int
id|intprop
suffix:semicolon
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getint(%s) -&gt; -1&bslash;n&quot;
comma
id|prop
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|prom_getproperty
c_func
(paren
id|node
comma
id|prop
comma
(paren
r_char
op_star
)paren
op_amp
id|intprop
comma
r_sizeof
(paren
r_int
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_return
id|intprop
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Acquire an integer property, upon error return the passed default&n; * integer.&n; */
r_int
DECL|function|prom_getintdefault
id|prom_getintdefault
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|property
comma
r_int
id|deflt
)paren
(brace
r_int
id|retval
suffix:semicolon
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getintdefault(%s) -&gt; 0&bslash;n&quot;
comma
id|property
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|retval
op_assign
id|prom_getint
c_func
(paren
id|node
comma
id|property
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
l_int|1
)paren
(brace
r_return
id|deflt
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Acquire a boolean property, 1=TRUE 0=FALSE. */
r_int
DECL|function|prom_getbool
id|prom_getbool
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|prop
)paren
(brace
r_int
id|retval
suffix:semicolon
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getbool(%s) -&gt; 0&bslash;n&quot;
comma
id|prop
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|retval
op_assign
id|prom_getproplen
c_func
(paren
id|node
comma
id|prop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Acquire a property whose value is a string, returns a null&n; * string on error.  The char pointer is the user supplied string&n; * buffer.&n; */
r_void
DECL|function|prom_getstring
id|prom_getstring
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|prop
comma
r_char
op_star
id|user_buf
comma
r_int
id|ubuf_size
)paren
(brace
r_int
id|len
suffix:semicolon
macro_line|#if CONFIG_AP1000
id|printk
c_func
(paren
l_string|&quot;prom_getstring(%s) -&gt; .&bslash;n&quot;
comma
id|prop
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
id|len
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
id|prop
comma
id|user_buf
comma
id|ubuf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
op_minus
l_int|1
)paren
(brace
r_return
suffix:semicolon
)brace
id|user_buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Does the device at node &squot;node&squot; have name &squot;name&squot;?&n; * YES = 1   NO = 0&n; */
r_int
DECL|function|prom_nodematch
id|prom_nodematch
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|name
)paren
(brace
r_static
r_char
id|namebuf
(braket
l_int|128
)braket
suffix:semicolon
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;name&quot;
comma
id|namebuf
comma
r_sizeof
(paren
id|namebuf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|namebuf
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Search siblings at &squot;node_start&squot; for a node with name&n; * &squot;nodename&squot;.  Return node if successful, zero if not.&n; */
r_int
DECL|function|prom_searchsiblings
id|prom_searchsiblings
c_func
(paren
r_int
id|node_start
comma
r_char
op_star
id|nodename
)paren
(brace
r_int
id|thisnode
comma
id|error
suffix:semicolon
r_for
c_loop
(paren
id|thisnode
op_assign
id|node_start
suffix:semicolon
id|thisnode
suffix:semicolon
id|thisnode
op_assign
id|prom_getsibling
c_func
(paren
id|thisnode
)paren
)paren
(brace
id|error
op_assign
id|prom_getproperty
c_func
(paren
id|thisnode
comma
l_string|&quot;name&quot;
comma
id|promlib_buf
comma
r_sizeof
(paren
id|promlib_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* Should this ever happen? */
r_if
c_cond
(paren
id|error
op_eq
op_minus
l_int|1
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|nodename
comma
id|promlib_buf
)paren
op_eq
l_int|0
)paren
(brace
r_return
id|thisnode
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Return the first property type for node &squot;node&squot;.&n; */
r_char
op_star
DECL|function|prom_firstprop
id|prom_firstprop
c_func
(paren
r_int
id|node
)paren
(brace
r_if
c_cond
(paren
id|node
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
r_return
id|prom_nodeops
op_member_access_from_pointer
id|no_nextprop
c_func
(paren
id|node
comma
(paren
r_char
op_star
)paren
l_int|0x0
)paren
suffix:semicolon
)brace
multiline_comment|/* Return the property type string after property type &squot;oprop&squot;&n; * at node &squot;node&squot; .  Returns NULL string if no more&n; * property types for this node.&n; */
r_char
op_star
DECL|function|prom_nextprop
id|prom_nextprop
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|oprop
)paren
(brace
r_if
c_cond
(paren
id|node
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_string|&quot;&quot;
suffix:semicolon
)brace
r_return
id|prom_nodeops
op_member_access_from_pointer
id|no_nextprop
c_func
(paren
id|node
comma
id|oprop
)paren
suffix:semicolon
)brace
r_int
DECL|function|prom_node_has_property
id|prom_node_has_property
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|prop
)paren
(brace
r_char
op_star
id|current_property
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_do
(brace
id|current_property
op_assign
id|prom_nextprop
c_func
(paren
id|node
comma
id|current_property
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|current_property
comma
id|prop
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_star
id|current_property
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set property &squot;pname&squot; at node &squot;node&squot; to value &squot;value&squot; which has a length&n; * of &squot;size&squot; bytes.  Return the number of bytes the prom accepted.&n; */
r_int
DECL|function|prom_setprop
id|prom_setprop
c_func
(paren
r_int
id|node
comma
r_char
op_star
id|pname
comma
r_char
op_star
id|value
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pname
op_eq
l_int|0
)paren
op_logical_or
(paren
id|value
op_eq
l_int|0
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|prom_nodeops
op_member_access_from_pointer
id|no_setprop
c_func
(paren
id|node
comma
id|pname
comma
id|value
comma
id|size
)paren
suffix:semicolon
)brace
eof
