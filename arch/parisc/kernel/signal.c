multiline_comment|/*&n; *  linux/arch/parisc/kernel/signal.c: Architecture-specific signal&n; *  handling support.&n; *&n; *  Copyright (C) 2000 David Huggins-Daines &lt;dhd@debian.org&gt;&n; *  Copyright (C) 2000 Linuxcare, Inc.&n; *&n; *  Based on the ia64, i386, and alpha versions.&n; *&n; *  Like the IA-64, we are a recent enough port (we are *starting*&n; *  with glibc2.2) that we do not need to support the old non-realtime&n; *  Linux signals.  Therefore we don&squot;t.  HP/UX signals will go in&n; *  arch/parisc/hpux/signal.c when we figure out how to do them.&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;asm/ucontext.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
DECL|macro|DEBUG_SIG
mdefine_line|#define DEBUG_SIG 0
DECL|macro|_BLOCKABLE
mdefine_line|#define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
r_extern
r_int
id|sys_wait4
(paren
r_int
comma
r_int
op_star
comma
r_int
comma
r_struct
id|rusage
op_star
)paren
suffix:semicolon
r_int
id|do_signal
c_func
(paren
id|sigset_t
op_star
id|oldset
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|in_syscall
)paren
suffix:semicolon
DECL|function|copy_siginfo_to_user
r_int
id|copy_siginfo_to_user
c_func
(paren
id|siginfo_t
op_star
id|to
comma
id|siginfo_t
op_star
id|from
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
(paren
id|VERIFY_WRITE
comma
id|to
comma
r_sizeof
(paren
id|siginfo_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|from-&gt;si_code
OL
l_int|0
)paren
r_return
id|__copy_to_user
c_func
(paren
id|to
comma
id|from
comma
r_sizeof
(paren
id|siginfo_t
)paren
)paren
suffix:semicolon
r_else
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If you change siginfo_t structure, please be sure&n;&t;&t; * this code is fixed accordingly.  It should never&n;&t;&t; * copy any pad contained in the structure to avoid&n;&t;&t; * security leaks, but must copy the generic 3 ints&n;&t;&t; * plus the relevant union member.&n;&t;&t; */
id|err
op_assign
id|__put_user
c_func
(paren
id|from-&gt;si_signo
comma
op_amp
id|to-&gt;si_signo
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|from-&gt;si_errno
comma
op_amp
id|to-&gt;si_errno
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
(paren
r_int
)paren
id|from-&gt;si_code
comma
op_amp
id|to-&gt;si_code
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|from-&gt;si_code
op_rshift
l_int|16
)paren
(brace
r_case
id|__SI_FAULT
op_rshift
l_int|16
suffix:colon
multiline_comment|/* FIXME: should we put the interruption code here? */
r_case
id|__SI_POLL
op_rshift
l_int|16
suffix:colon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|from-&gt;si_addr
comma
op_amp
id|to-&gt;si_addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|__SI_CHLD
op_rshift
l_int|16
suffix:colon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|from-&gt;si_utime
comma
op_amp
id|to-&gt;si_utime
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|from-&gt;si_stime
comma
op_amp
id|to-&gt;si_stime
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|from-&gt;si_status
comma
op_amp
id|to-&gt;si_status
)paren
suffix:semicolon
r_default
suffix:colon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|from-&gt;si_uid
comma
op_amp
id|to-&gt;si_uid
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|from-&gt;si_pid
comma
op_amp
id|to-&gt;si_pid
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* case __SI_RT: This is not generated by the kernel as of now.  */
)brace
r_return
id|err
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Atomically swap in the new signal mask, and wait for a signal.&n; */
macro_line|#ifdef __LP64__
macro_line|#include &quot;sys32.h&quot;
macro_line|#endif
id|asmlinkage
r_int
DECL|function|sys_rt_sigsuspend
id|sys_rt_sigsuspend
c_func
(paren
id|sigset_t
op_star
id|unewset
comma
r_int
id|sigsetsize
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|sigset_t
id|saveset
comma
id|newset
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/* XXX FIXME -- assumes 32-bit user app! */
id|sigset_t32
id|newset32
suffix:semicolon
multiline_comment|/* XXX: Don&squot;t preclude handling different sized sigset_t&squot;s.  */
r_if
c_cond
(paren
id|sigsetsize
op_ne
r_sizeof
(paren
id|sigset_t32
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|newset32
comma
(paren
id|sigset_t32
op_star
)paren
id|unewset
comma
r_sizeof
(paren
id|newset32
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|newset.sig
(braket
l_int|0
)braket
op_assign
id|newset32.sig
(braket
l_int|0
)braket
op_or
(paren
(paren
r_int
r_int
)paren
id|newset32.sig
(braket
l_int|1
)braket
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* XXX: Don&squot;t preclude handling different sized sigset_t&squot;s.  */
r_if
c_cond
(paren
id|sigsetsize
op_ne
r_sizeof
(paren
id|sigset_t
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|newset
comma
id|unewset
comma
r_sizeof
(paren
id|newset
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#endif
id|sigdelsetmask
c_func
(paren
op_amp
id|newset
comma
op_complement
id|_BLOCKABLE
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|saveset
op_assign
id|current-&gt;blocked
suffix:semicolon
id|current-&gt;blocked
op_assign
id|newset
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|regs-&gt;gr
(braket
l_int|28
)braket
op_assign
op_minus
id|EINTR
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_signal
c_func
(paren
op_amp
id|saveset
comma
id|regs
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Do a signal return - restore sigcontext.&n; */
DECL|struct|rt_sigframe
r_struct
id|rt_sigframe
(brace
DECL|member|tramp
r_int
r_int
id|tramp
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|info
r_struct
id|siginfo
id|info
suffix:semicolon
DECL|member|uc
r_struct
id|ucontext
id|uc
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Trampoline for calling rt_sigreturn() */
DECL|macro|INSN_LDI_R25_0
mdefine_line|#define INSN_LDI_R25_0&t; 0x34190000 /* ldi  0,%r25 (in_syscall=0) */
DECL|macro|INSN_LDI_R25_1
mdefine_line|#define INSN_LDI_R25_1&t; 0x34190002 /* ldi  1,%r25 (in_syscall=1) */
DECL|macro|INSN_LDI_R20
mdefine_line|#define INSN_LDI_R20&t; 0x3414015a /* ldi  __NR_rt_sigreturn,%r20 */
DECL|macro|INSN_BLE_SR2_R0
mdefine_line|#define INSN_BLE_SR2_R0  0xe4008200 /* be,l 0x100(%sr2,%r0),%sr0,%r31 */
DECL|macro|INSN_NOP
mdefine_line|#define INSN_NOP&t; 0x80000240 /* nop */
multiline_comment|/* For debugging */
DECL|macro|INSN_DIE_HORRIBLY
mdefine_line|#define INSN_DIE_HORRIBLY 0x68000ccc /* stw %r0,0x666(%sr0,%r0) */
multiline_comment|/*&n; * The 32-bit ABI wants at least 48 bytes for a function call frame:&n; * 16 bytes for arg0-arg3, and 32 bytes for magic (the only part of&n; * which Linux/parisc uses is sp-20 for the saved return pointer...)&n; * Then, the stack pointer must be rounded to a cache line (64 bytes).&n; */
DECL|macro|PARISC_RT_SIGFRAME_SIZE
mdefine_line|#define PARISC_RT_SIGFRAME_SIZE&t;&t;&t;&t;&t;&bslash;&n;&t;(((sizeof(struct rt_sigframe) + 48) + 63) &amp; -64)
r_static
r_int
DECL|function|restore_sigcontext
id|restore_sigcontext
c_func
(paren
r_struct
id|sigcontext
op_star
id|sc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
id|regs-&gt;gr
comma
id|sc-&gt;sc_gr
comma
r_sizeof
(paren
id|regs-&gt;gr
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
id|regs-&gt;fr
comma
id|sc-&gt;sc_fr
comma
r_sizeof
(paren
id|regs-&gt;fr
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
id|regs-&gt;iaoq
comma
id|sc-&gt;sc_iaoq
comma
r_sizeof
(paren
id|regs-&gt;iaoq
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
id|regs-&gt;iasq
comma
id|sc-&gt;sc_iasq
comma
r_sizeof
(paren
id|regs-&gt;iasq
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|regs-&gt;sar
comma
op_amp
id|sc-&gt;sc_sar
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;restore_sigcontext: r28 is %ld&bslash;n&quot;
comma
id|regs-&gt;gr
(braket
l_int|28
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|err
suffix:semicolon
)brace
r_void
DECL|function|sys_rt_sigreturn
id|sys_rt_sigreturn
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|in_syscall
)paren
(brace
r_struct
id|rt_sigframe
op_star
id|frame
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
id|sigset_t
id|set
suffix:semicolon
r_int
r_int
id|usp
op_assign
id|regs-&gt;gr
(braket
l_int|30
)braket
suffix:semicolon
multiline_comment|/* Unwind the user stack to get the rt_sigframe structure. */
id|frame
op_assign
(paren
r_struct
id|rt_sigframe
op_star
)paren
(paren
id|usp
op_minus
id|PARISC_RT_SIGFRAME_SIZE
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;in sys_rt_sigreturn, frame is %p&bslash;n&quot;
comma
id|frame
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Verify that it&squot;s a good sigcontext before using it */
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|frame
comma
r_sizeof
(paren
op_star
id|frame
)paren
)paren
)paren
r_goto
id|give_sigsegv
suffix:semicolon
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|set
comma
op_amp
id|frame-&gt;uc.uc_sigmask
comma
r_sizeof
(paren
id|set
)paren
)paren
)paren
r_goto
id|give_sigsegv
suffix:semicolon
id|sigdelsetmask
c_func
(paren
op_amp
id|set
comma
op_complement
id|_BLOCKABLE
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|current-&gt;blocked
op_assign
id|set
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
multiline_comment|/* Good thing we saved the old gr[30], eh? */
r_if
c_cond
(paren
id|restore_sigcontext
c_func
(paren
op_amp
id|frame-&gt;uc.uc_mcontext
comma
id|regs
)paren
)paren
r_goto
id|give_sigsegv
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;usp: %#08lx stack %p&quot;
comma
id|usp
comma
op_amp
id|frame-&gt;uc.uc_stack
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* I don&squot;t know why everyone else assumes they can call this&n;           with a pointer to a stack_t on the kernel stack.  That&n;           makes no sense.  Anyway we&squot;ll do it like m68k, since we&n;           also are using segmentation in the same way as them. */
r_if
c_cond
(paren
id|do_sigaltstack
c_func
(paren
op_amp
id|frame-&gt;uc.uc_stack
comma
l_int|NULL
comma
id|usp
)paren
op_eq
op_minus
id|EFAULT
)paren
r_goto
id|give_sigsegv
suffix:semicolon
multiline_comment|/* If we are on the syscall path IAOQ will not be restored, and&n;&t; * if we are on the interrupt path we must not corrupt gr31.&n;&t; */
r_if
c_cond
(paren
id|in_syscall
)paren
id|regs-&gt;gr
(braket
l_int|31
)braket
op_assign
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;returning to %#lx&bslash;n&quot;
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;in sys_rt_sigreturn:&bslash;n&quot;
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
id|give_sigsegv
suffix:colon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;fuckup in sys_rt_sigreturn, sending SIGSEGV&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|si.si_signo
op_assign
id|SIGSEGV
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|SI_KERNEL
suffix:semicolon
id|si.si_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|si.si_uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|si.si_addr
op_assign
op_amp
id|frame-&gt;uc
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGSEGV
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up a signal frame.&n; */
r_static
r_inline
r_void
op_star
DECL|function|get_sigframe
id|get_sigframe
c_func
(paren
r_struct
id|k_sigaction
op_star
id|ka
comma
r_int
r_int
id|sp
comma
r_int
id|frame_size
)paren
(brace
r_if
c_cond
(paren
(paren
id|ka-&gt;sa.sa_flags
op_amp
id|SA_ONSTACK
)paren
op_ne
l_int|0
op_logical_and
op_logical_neg
id|on_sig_stack
c_func
(paren
id|sp
)paren
)paren
id|sp
op_assign
id|current-&gt;sas_ss_sp
op_plus
id|current-&gt;sas_ss_size
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|sp
suffix:semicolon
multiline_comment|/* Stacks grow up.  Fun. */
)brace
r_static
r_int
DECL|function|setup_sigcontext
id|setup_sigcontext
c_func
(paren
r_struct
id|sigcontext
op_star
id|sc
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|in_syscall
)paren
(brace
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|on_sig_stack
c_func
(paren
(paren
r_int
r_int
)paren
id|sc
)paren
)paren
id|flags
op_or_assign
id|PARISC_SC_FLAG_ONSTACK
suffix:semicolon
r_if
c_cond
(paren
id|in_syscall
)paren
(brace
id|flags
op_or_assign
id|PARISC_SC_FLAG_IN_SYSCALL
suffix:semicolon
multiline_comment|/* regs-&gt;iaoq is undefined in the syscall return path */
id|err
op_or_assign
id|__put_user
c_func
(paren
id|regs-&gt;gr
(braket
l_int|31
)braket
comma
op_amp
id|sc-&gt;sc_iaoq
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|regs-&gt;gr
(braket
l_int|31
)braket
op_plus
l_int|4
comma
op_amp
id|sc-&gt;sc_iaoq
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;setup_sigcontext: iaoq %#lx/%#lx&bslash;n&quot;
comma
id|regs-&gt;gr
(braket
l_int|31
)braket
comma
id|regs-&gt;gr
(braket
l_int|31
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|err
op_or_assign
id|__copy_to_user
c_func
(paren
id|sc-&gt;sc_iaoq
comma
id|regs-&gt;iaoq
comma
r_sizeof
(paren
id|regs-&gt;iaoq
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_to_user
c_func
(paren
id|sc-&gt;sc_iasq
comma
id|regs-&gt;iasq
comma
r_sizeof
(paren
id|regs-&gt;iasq
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;setup_sigcontext: iaoq %#lx/%#lx&bslash;n&quot;
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
id|err
op_or_assign
id|__put_user
c_func
(paren
id|flags
comma
op_amp
id|sc-&gt;sc_flags
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_to_user
c_func
(paren
id|sc-&gt;sc_gr
comma
id|regs-&gt;gr
comma
r_sizeof
(paren
id|regs-&gt;gr
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_to_user
c_func
(paren
id|sc-&gt;sc_fr
comma
id|regs-&gt;fr
comma
r_sizeof
(paren
id|regs-&gt;fr
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|regs-&gt;sar
comma
op_amp
id|sc-&gt;sc_sar
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;setup_sigcontext: r28 is %ld&bslash;n&quot;
comma
id|regs-&gt;gr
(braket
l_int|28
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|setup_rt_frame
id|setup_rt_frame
c_func
(paren
r_int
id|sig
comma
r_struct
id|k_sigaction
op_star
id|ka
comma
id|siginfo_t
op_star
id|info
comma
id|sigset_t
op_star
id|set
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|in_syscall
)paren
(brace
r_struct
id|rt_sigframe
op_star
id|frame
suffix:semicolon
r_int
r_int
id|rp
comma
id|usp
comma
id|haddr
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|usp
op_assign
id|regs-&gt;gr
(braket
l_int|30
)braket
suffix:semicolon
multiline_comment|/* access_ok is broken, so do a simplistic &quot;are we stomping on&n;           kernel space&quot; assertion. */
r_if
c_cond
(paren
id|usp
OG
id|PAGE_OFFSET
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;setup_rt_frame: called on kernel space (usp=%#lx),  NOW YOU MUST DIE!!!&bslash;n&quot;
comma
id|usp
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
id|frame
op_assign
id|get_sigframe
c_func
(paren
id|ka
comma
id|usp
comma
r_sizeof
(paren
op_star
id|frame
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|frame
comma
r_sizeof
(paren
op_star
id|frame
)paren
)paren
)paren
r_goto
id|give_sigsegv
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;setup_rt_frame 1: frame %p info %p&bslash;n&quot;
comma
id|frame
comma
id|info
)paren
suffix:semicolon
macro_line|#endif
id|err
op_or_assign
id|__copy_to_user
c_func
(paren
op_amp
id|frame-&gt;info
comma
id|info
comma
r_sizeof
(paren
id|siginfo_t
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|current-&gt;sas_ss_sp
comma
op_amp
id|frame-&gt;uc.uc_stack.ss_sp
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|current-&gt;sas_ss_size
comma
op_amp
id|frame-&gt;uc.uc_stack.ss_size
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|sas_ss_flags
c_func
(paren
id|regs-&gt;gr
(braket
l_int|30
)braket
)paren
comma
op_amp
id|frame-&gt;uc.uc_stack.ss_flags
)paren
suffix:semicolon
id|err
op_or_assign
id|setup_sigcontext
c_func
(paren
op_amp
id|frame-&gt;uc.uc_mcontext
comma
id|regs
comma
id|in_syscall
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_to_user
c_func
(paren
op_amp
id|frame-&gt;uc.uc_sigmask
comma
id|set
comma
r_sizeof
(paren
op_star
id|set
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|give_sigsegv
suffix:semicolon
multiline_comment|/* Set up to return from userspace.  If provided, use a stub&n;&t;   already in userspace.  */
id|err
op_or_assign
id|__put_user
c_func
(paren
id|in_syscall
ques
c_cond
id|INSN_LDI_R25_1
suffix:colon
id|INSN_LDI_R25_0
comma
op_amp
id|frame-&gt;tramp
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|INSN_LDI_R20
comma
op_amp
id|frame-&gt;tramp
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|INSN_BLE_SR2_R0
comma
op_amp
id|frame-&gt;tramp
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|err
op_or_assign
id|__put_user
c_func
(paren
id|INSN_NOP
comma
op_amp
id|frame-&gt;tramp
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
multiline_comment|/* Assert that we&squot;re flushing in the correct space... */
(brace
r_int
id|sid
suffix:semicolon
id|asm
(paren
l_string|&quot;mfsp %%sr3,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|sid
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;flushing 64 bytes at space %#x offset %p&bslash;n&quot;
comma
id|sid
comma
id|frame-&gt;tramp
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if CACHE_FLUSHING_IS_NOT_BROKEN
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|frame-&gt;tramp
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
)paren
op_amp
id|frame-&gt;tramp
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* It should *always* be cache line-aligned, but the compiler&n;           sometimes screws up. */
id|asm
r_volatile
(paren
l_string|&quot;fdc 0(%%sr3,%0)&bslash;n&bslash;t&quot;
l_string|&quot;fdc %1(%%sr3,%0)&bslash;n&bslash;t&quot;
l_string|&quot;sync&bslash;n&bslash;t&quot;
l_string|&quot;fic 0(%%sr3,%0)&bslash;n&bslash;t&quot;
l_string|&quot;fic %1(%%sr3,%0)&bslash;n&bslash;t&quot;
l_string|&quot;sync&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|frame-&gt;tramp
)paren
comma
l_string|&quot;r&quot;
(paren
id|L1_CACHE_BYTES
)paren
)paren
suffix:semicolon
macro_line|#endif
id|rp
op_assign
(paren
r_int
r_int
)paren
id|frame-&gt;tramp
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|give_sigsegv
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/* Much more has to happen with signals than this -- but it&squot;ll at least */
multiline_comment|/* provide a pointer to some places which definitely need a look. */
DECL|macro|HACK
mdefine_line|#define HACK unsigned int
macro_line|#else
mdefine_line|#define HACK unsigned long
macro_line|#endif
id|haddr
op_assign
(paren
id|HACK
)paren
id|ka-&gt;sa.sa_handler
suffix:semicolon
multiline_comment|/* ARGH!  Fucking brain damage.  You don&squot;t want to know. */
r_if
c_cond
(paren
id|haddr
op_amp
l_int|2
)paren
(brace
id|HACK
op_star
id|plabel
suffix:semicolon
id|HACK
id|ltp
suffix:semicolon
id|plabel
op_assign
(paren
id|HACK
op_star
)paren
(paren
id|haddr
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|haddr
comma
id|plabel
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|ltp
comma
id|plabel
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|give_sigsegv
suffix:semicolon
id|regs-&gt;gr
(braket
l_int|19
)braket
op_assign
id|ltp
suffix:semicolon
)brace
multiline_comment|/* The syscall return path will create IAOQ values from r31.&n;&t; */
r_if
c_cond
(paren
id|in_syscall
)paren
id|regs-&gt;gr
(braket
l_int|31
)braket
op_assign
(paren
id|HACK
)paren
id|haddr
suffix:semicolon
r_else
(brace
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
(paren
id|HACK
)paren
id|haddr
op_or
l_int|3
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_assign
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_plus
l_int|4
suffix:semicolon
)brace
id|regs-&gt;gr
(braket
l_int|2
)braket
op_assign
id|rp
suffix:semicolon
multiline_comment|/* userland return pointer */
id|regs-&gt;gr
(braket
l_int|26
)braket
op_assign
id|sig
suffix:semicolon
multiline_comment|/* signal number */
id|regs-&gt;gr
(braket
l_int|25
)braket
op_assign
(paren
id|HACK
)paren
op_amp
id|frame-&gt;info
suffix:semicolon
multiline_comment|/* siginfo pointer */
id|regs-&gt;gr
(braket
l_int|24
)braket
op_assign
(paren
id|HACK
)paren
op_amp
id|frame-&gt;uc
suffix:semicolon
multiline_comment|/* ucontext pointer */
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;making sigreturn frame: %#lx + %#lx = %#lx&bslash;n&quot;
comma
id|regs-&gt;gr
(braket
l_int|30
)braket
comma
id|PARISC_RT_SIGFRAME_SIZE
comma
id|regs-&gt;gr
(braket
l_int|30
)braket
op_plus
id|PARISC_RT_SIGFRAME_SIZE
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Raise the user stack pointer to make a proper call frame. */
id|regs-&gt;gr
(braket
l_int|30
)braket
op_assign
(paren
(paren
id|HACK
)paren
id|frame
op_plus
id|PARISC_RT_SIGFRAME_SIZE
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;SIG deliver (%s:%d): frame=0x%p sp=%#lx iaoq=%#lx/%#lx rp=%#lx&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|frame
comma
id|regs-&gt;gr
(braket
l_int|30
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|1
)braket
comma
id|rp
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
id|give_sigsegv
suffix:colon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;fuckup in setup_rt_frame, sending SIGSEGV&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sig
op_eq
id|SIGSEGV
)paren
id|ka-&gt;sa.sa_handler
op_assign
id|SIG_DFL
suffix:semicolon
id|si.si_signo
op_assign
id|SIGSEGV
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|SI_KERNEL
suffix:semicolon
id|si.si_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|si.si_uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|si.si_addr
op_assign
id|frame
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGSEGV
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * OK, we&squot;re invoking a handler.&n; */
r_static
r_int
DECL|function|handle_signal
id|handle_signal
c_func
(paren
r_int
r_int
id|sig
comma
r_struct
id|k_sigaction
op_star
id|ka
comma
id|siginfo_t
op_star
id|info
comma
id|sigset_t
op_star
id|oldset
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|in_syscall
)paren
(brace
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;handle_signal(sig=%ld, ka=%p, info=%p, oldset=%p, regs=%p)&bslash;n&quot;
comma
id|sig
comma
id|ka
comma
id|info
comma
id|oldset
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set up the stack frame */
r_if
c_cond
(paren
op_logical_neg
id|setup_rt_frame
c_func
(paren
id|sig
comma
id|ka
comma
id|info
comma
id|oldset
comma
id|regs
comma
id|in_syscall
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ka-&gt;sa.sa_flags
op_amp
id|SA_ONESHOT
)paren
id|ka-&gt;sa.sa_handler
op_assign
id|SIG_DFL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ka-&gt;sa.sa_flags
op_amp
id|SA_NODEFER
)paren
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|sigorsets
c_func
(paren
op_amp
id|current-&gt;blocked
comma
op_amp
id|current-&gt;blocked
comma
op_amp
id|ka-&gt;sa.sa_mask
)paren
suffix:semicolon
id|sigaddset
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sig
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that &squot;init&squot; is a special process: it doesn&squot;t get signals it doesn&squot;t&n; * want to handle. Thus you cannot kill init even with a SIGKILL even by&n; * mistake.&n; *&n; * We need to be able to restore the syscall arguments (r21-r26) to&n; * restart syscalls.  Thus, the syscall path should save them in the&n; * pt_regs structure (it&squot;s okay to do so since they are caller-save&n; * registers).  As noted below, the syscall number gets restored for&n; * us due to the magic of delayed branching.&n; */
id|asmlinkage
r_int
DECL|function|do_signal
id|do_signal
c_func
(paren
id|sigset_t
op_star
id|oldset
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|in_syscall
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
r_struct
id|k_sigaction
op_star
id|ka
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;do_signal(oldset=0x%p, regs=0x%p, sr7 %#lx, pending %d, in_syscall=%d&bslash;n&quot;
comma
id|oldset
comma
id|regs
comma
id|regs-&gt;sr
(braket
l_int|7
)braket
comma
id|current-&gt;sigpending
comma
id|in_syscall
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Everyone else checks to see if they are in kernel mode at&n;&t;   this point and exits if that&squot;s the case.  I&squot;m not sure why&n;&t;   we would be called in that case, but for some reason we&n;&t;   are. */
r_if
c_cond
(paren
op_logical_neg
id|oldset
)paren
id|oldset
op_assign
op_amp
id|current-&gt;blocked
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;do_signal: oldset %08lx:%08lx&bslash;n&quot;
comma
id|oldset-&gt;sig
(braket
l_int|0
)braket
comma
id|oldset-&gt;sig
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_int
id|signr
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|signr
op_assign
id|dequeue_signal
c_func
(paren
op_amp
id|current-&gt;blocked
comma
op_amp
id|info
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;do_signal: signr=%ld, pid=%d&bslash;n&quot;
comma
id|signr
comma
id|current-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|signr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
op_logical_and
id|signr
op_ne
id|SIGKILL
)paren
(brace
multiline_comment|/* Let the debugger run.  */
id|current-&gt;exit_code
op_assign
id|signr
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_STOPPED
)paren
suffix:semicolon
id|notify_parent
c_func
(paren
id|current
comma
id|SIGCHLD
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We&squot;re back.  Did the debugger cancel the sig?  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|signr
op_assign
id|current-&gt;exit_code
)paren
)paren
r_continue
suffix:semicolon
id|current-&gt;exit_code
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The debugger continued.  Ignore SIGSTOP.  */
r_if
c_cond
(paren
id|signr
op_eq
id|SIGSTOP
)paren
r_continue
suffix:semicolon
multiline_comment|/* Update the siginfo structure.  Is this good?  */
r_if
c_cond
(paren
id|signr
op_ne
id|info.si_signo
)paren
(brace
id|info.si_signo
op_assign
id|signr
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|SI_USER
suffix:semicolon
id|info.si_pid
op_assign
id|current-&gt;p_pptr-&gt;pid
suffix:semicolon
id|info.si_uid
op_assign
id|current-&gt;p_pptr-&gt;uid
suffix:semicolon
)brace
multiline_comment|/* If the (new) signal is now blocked, requeue it.  */
r_if
c_cond
(paren
id|sigismember
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|signr
)paren
)paren
(brace
id|send_sig_info
c_func
(paren
id|signr
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|ka
op_assign
op_amp
id|current-&gt;sig-&gt;action
(braket
id|signr
op_minus
l_int|1
)braket
suffix:semicolon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;sa_handler is %lx&bslash;n&quot;
comma
id|ka-&gt;sa.sa_handler
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|ka-&gt;sa.sa_handler
op_eq
(paren
r_int
r_int
)paren
id|SIG_IGN
)paren
(brace
r_if
c_cond
(paren
id|signr
op_ne
id|SIGCHLD
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|sys_wait4
c_func
(paren
op_minus
l_int|1
comma
l_int|NULL
comma
id|WNOHANG
comma
l_int|NULL
)paren
OG
l_int|0
)paren
multiline_comment|/* nothing */
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|ka-&gt;sa.sa_handler
op_eq
(paren
r_int
r_int
)paren
id|SIG_DFL
)paren
(brace
r_int
id|exit_code
op_assign
id|signr
suffix:semicolon
multiline_comment|/* Init gets no signals it doesn&squot;t want.  */
r_if
c_cond
(paren
id|current-&gt;pid
op_eq
l_int|1
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|signr
)paren
(brace
r_case
id|SIGCONT
suffix:colon
r_case
id|SIGCHLD
suffix:colon
r_case
id|SIGWINCH
suffix:colon
r_continue
suffix:semicolon
r_case
id|SIGTSTP
suffix:colon
r_case
id|SIGTTIN
suffix:colon
r_case
id|SIGTTOU
suffix:colon
r_if
c_cond
(paren
id|is_orphaned_pgrp
c_func
(paren
id|current-&gt;pgrp
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* FALLTHRU */
r_case
id|SIGSTOP
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_STOPPED
)paren
suffix:semicolon
id|current-&gt;exit_code
op_assign
id|signr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|current-&gt;p_pptr-&gt;sig-&gt;action
(braket
id|SIGCHLD
op_minus
l_int|1
)braket
dot
id|sa.sa_flags
op_amp
id|SA_NOCLDSTOP
)paren
)paren
id|notify_parent
c_func
(paren
id|current
comma
id|SIGCHLD
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|SIGQUIT
suffix:colon
r_case
id|SIGILL
suffix:colon
r_case
id|SIGTRAP
suffix:colon
r_case
id|SIGABRT
suffix:colon
r_case
id|SIGFPE
suffix:colon
r_case
id|SIGSEGV
suffix:colon
r_case
id|SIGBUS
suffix:colon
r_case
id|SIGSYS
suffix:colon
r_case
id|SIGXCPU
suffix:colon
r_case
id|SIGXFSZ
suffix:colon
r_if
c_cond
(paren
id|signr
op_eq
id|SIGQUIT
)paren
multiline_comment|/* Userspace debugging */
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_coredump
c_func
(paren
id|signr
comma
id|regs
)paren
)paren
id|exit_code
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* FALLTHRU */
r_default
suffix:colon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|sigaddset
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|signr
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_SIGNALED
suffix:semicolon
id|do_exit
c_func
(paren
id|exit_code
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
)brace
multiline_comment|/* Restart a system call if necessary. */
r_if
c_cond
(paren
id|in_syscall
)paren
(brace
multiline_comment|/* Check the return code */
r_switch
c_cond
(paren
id|regs-&gt;gr
(braket
l_int|28
)braket
)paren
(brace
r_case
op_minus
id|ERESTARTNOHAND
suffix:colon
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;ERESTARTNOHAND: returning -EINTR&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|regs-&gt;gr
(braket
l_int|28
)braket
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ERESTARTSYS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ka-&gt;sa.sa_flags
op_amp
id|SA_RESTART
)paren
)paren
(brace
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;ERESTARTSYS: putting -EINTR&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|regs-&gt;gr
(braket
l_int|28
)braket
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fallthrough */
r_case
op_minus
id|ERESTARTNOINTR
suffix:colon
multiline_comment|/* A syscall is just a branch, so all&n;                                   we have to do is fiddle the return&n;                                   pointer. */
id|regs-&gt;gr
(braket
l_int|31
)braket
op_sub_assign
l_int|8
suffix:semicolon
multiline_comment|/* delayed branching */
multiline_comment|/* Preserve original r28. */
id|regs-&gt;gr
(braket
l_int|28
)braket
op_assign
id|regs-&gt;orig_r28
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Whee!  Actually deliver the signal.  If the&n;&t;&t;   delivery failed, we need to continue to iterate in&n;&t;&t;   this loop so we can deliver the SIGSEGV... */
r_if
c_cond
(paren
id|handle_signal
c_func
(paren
id|signr
comma
id|ka
comma
op_amp
id|info
comma
id|oldset
comma
id|regs
comma
id|in_syscall
)paren
)paren
(brace
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;Exiting do_signal (success), regs-&gt;gr[28] = %ld&bslash;n&quot;
comma
id|regs-&gt;gr
(braket
l_int|28
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Did we come from a system call? */
r_if
c_cond
(paren
id|in_syscall
)paren
(brace
multiline_comment|/* Restart the system call - no handlers present */
r_if
c_cond
(paren
id|regs-&gt;gr
(braket
l_int|28
)braket
op_eq
op_minus
id|ERESTARTNOHAND
op_logical_or
id|regs-&gt;gr
(braket
l_int|28
)braket
op_eq
op_minus
id|ERESTARTSYS
op_logical_or
id|regs-&gt;gr
(braket
l_int|28
)braket
op_eq
op_minus
id|ERESTARTNOINTR
)paren
(brace
multiline_comment|/* Hooray for delayed branching.  We don&squot;t&n;                           have to restore %r20 (the system call&n;                           number) because it gets loaded in the delay&n;                           slot of the branch external instruction. */
id|regs-&gt;gr
(braket
l_int|31
)braket
op_sub_assign
l_int|8
suffix:semicolon
multiline_comment|/* Preserve original r28. */
id|regs-&gt;gr
(braket
l_int|28
)braket
op_assign
id|regs-&gt;orig_r28
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG_SIG
id|printk
c_func
(paren
l_string|&quot;Exiting do_signal (not delivered), regs-&gt;gr[28] = %ld&bslash;n&quot;
comma
id|regs-&gt;gr
(braket
l_int|28
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
