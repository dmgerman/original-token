multiline_comment|/*&n;**  PCI Lower Bus Adapter (LBA) manager&n;**&n;**&t;(c) Copyright 1999,2000 Grant Grundler&n;**&t;(c) Copyright 1999,2000 Hewlett-Packard Company&n;**&n;**&t;This program is free software; you can redistribute it and/or modify&n;**&t;it under the terms of the GNU General Public License as published by&n;**      the Free Software Foundation; either version 2 of the License, or&n;**      (at your option) any later version.&n;**&n;**&n;** This module primarily provides access to PCI bus (config/IOport&n;** spaces) on platforms with an SBA/LBA chipset. A/B/C/J/L/N-class&n;** with 4 digit model numbers - eg C3000 (and A400...sigh).&n;**&n;** LBA driver isn&squot;t as simple as the Dino driver because:&n;**   (a) this chip has substantial bug fixes between revisions&n;**       (Only one Dino bug has a software workaround :^(  )&n;**   (b) has more options which we don&squot;t (yet) support (DMA hints, OLARD)&n;**   (c) IRQ support lives in the I/O SAPIC driver (not with PCI driver)&n;**   (d) play nicely with both PAT and &quot;Legacy&quot; PA-RISC firmware (PDC).&n;**       (dino only deals with &quot;Legacy&quot; PDC)&n;**&n;** LBA driver passes the I/O SAPIC HPA to the I/O SAPIC driver.&n;** (I/O SAPIC is integratd in the LBA chip).&n;**&n;** FIXME: Add support to SBA and LBA drivers for DMA hint sets&n;** FIXME: Add support for PCI card hot-plug (OLARD).&n;*/
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;&t;&t;/* for __init and __devinit */
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;&t;&t;/* for struct irq_region support */
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/pdcpat.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;&t;/* for register_driver() stuff */
macro_line|#include &lt;asm/iosapic.h&gt;&t;/* for iosapic_register() */
macro_line|#include &lt;asm/gsc.h&gt;&t;&t;/* gsc_read/write stuff */
macro_line|#ifndef TRUE
DECL|macro|TRUE
mdefine_line|#define TRUE (1 == 1)
DECL|macro|FALSE
mdefine_line|#define FALSE (1 == 0)
macro_line|#endif
DECL|macro|DEBUG_LBA
macro_line|#undef DEBUG_LBA&t;/* general stuff */
DECL|macro|DEBUG_LBA_PORT
macro_line|#undef DEBUG_LBA_PORT&t;/* debug I/O Port access */
DECL|macro|DEBUG_LBA_CFG
macro_line|#undef DEBUG_LBA_CFG&t;/* debug Config Space Access (ie PCI Bus walk) */
DECL|macro|DEBUG_LBA_PAT
macro_line|#undef DEBUG_LBA_PAT&t;/* debug PCI Resource Mgt code - PDC PAT only */
macro_line|#ifdef DEBUG_LBA
DECL|macro|DBG
mdefine_line|#define DBG(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_LBA_PORT
DECL|macro|DBG_PORT
mdefine_line|#define DBG_PORT(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_PORT
mdefine_line|#define DBG_PORT(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_LBA_CFG
DECL|macro|DBG_CFG
mdefine_line|#define DBG_CFG(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_CFG
mdefine_line|#define DBG_CFG(x...)
macro_line|#endif
macro_line|#ifdef DEBUG_LBA_PAT
DECL|macro|DBG_PAT
mdefine_line|#define DBG_PAT(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_PAT
mdefine_line|#define DBG_PAT(x...)
macro_line|#endif
multiline_comment|/*&n;** Config accessor functions only pass in the 8-bit bus number and not&n;** the 8-bit &quot;PCI Segment&quot; number. Each LBA will be assigned a PCI bus&n;** number based on what firmware wrote into the scratch register.&n;**&n;** The &quot;secondary&quot; bus number is set to this before calling&n;** pci_register_ops(). If any PPB&squot;s are present, the scan will&n;** discover them and update the &quot;secondary&quot; and &quot;subordinate&quot;&n;** fields in the pci_bus structure.&n;**&n;** Changes in the configuration *may* result in a different&n;** bus number for each LBA depending on what firmware does.&n;*/
DECL|macro|MODULE_NAME
mdefine_line|#define MODULE_NAME &quot;lba&quot;
r_static
r_int
id|lba_driver_callback
c_func
(paren
r_struct
id|hp_device
op_star
comma
r_struct
id|pa_iodc_driver
op_star
)paren
suffix:semicolon
DECL|variable|lba_drivers_for
r_static
r_struct
id|pa_iodc_driver
id|lba_drivers_for
(braket
)braket
op_assign
(brace
(brace
id|HPHW_BRIDGE
comma
l_int|0x782
comma
l_int|0x0
comma
l_int|0xa
comma
l_int|0
comma
l_int|0
comma
id|DRIVER_CHECK_HVERSION
op_plus
id|DRIVER_CHECK_SVERSION
op_plus
id|DRIVER_CHECK_HWTYPE
comma
id|MODULE_NAME
comma
l_string|&quot;tbd&quot;
comma
(paren
r_void
op_star
)paren
id|lba_driver_callback
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|macro|LBA_FUNC_ID
mdefine_line|#define LBA_FUNC_ID&t;0x0000&t;/* function id */
DECL|macro|LBA_FCLASS
mdefine_line|#define LBA_FCLASS&t;0x0008&t;/* function class, bist, header, rev... */
DECL|macro|LBA_CAPABLE
mdefine_line|#define LBA_CAPABLE&t;0x0030&t;/* capabilities register */
DECL|macro|LBA_PCI_CFG_ADDR
mdefine_line|#define LBA_PCI_CFG_ADDR&t;0x0040&t;/* poke CFG address here */
DECL|macro|LBA_PCI_CFG_DATA
mdefine_line|#define LBA_PCI_CFG_DATA&t;0x0048&t;/* read or write data here */
DECL|macro|LBA_PMC_MTLT
mdefine_line|#define LBA_PMC_MTLT&t;0x0050&t;/* Firmware sets this - read only. */
DECL|macro|LBA_FW_SCRATCH
mdefine_line|#define LBA_FW_SCRATCH&t;0x0058&t;/* Firmware writes the PCI bus number here. */
DECL|macro|LBA_ERROR_ADDR
mdefine_line|#define LBA_ERROR_ADDR&t;0x0070&t;/* On error, address gets logged here */
DECL|macro|LBA_ARB_MASK
mdefine_line|#define LBA_ARB_MASK&t;0x0080&t;/* bit 0 enable arbitration. PAT/PDC enables */
DECL|macro|LBA_ARB_PRI
mdefine_line|#define LBA_ARB_PRI&t;0x0088&t;/* firmware sets this. */
DECL|macro|LBA_ARB_MODE
mdefine_line|#define LBA_ARB_MODE&t;0x0090&t;/* firmware sets this. */
DECL|macro|LBA_ARB_MTLT
mdefine_line|#define LBA_ARB_MTLT&t;0x0098&t;/* firmware sets this. */
DECL|macro|LBA_MOD_ID
mdefine_line|#define LBA_MOD_ID&t;0x0100&t;/* Module ID. PDC_PAT_CELL reports 4 */
DECL|macro|LBA_STAT_CTL
mdefine_line|#define LBA_STAT_CTL&t;0x0108&t;/* Status &amp; Control */
DECL|macro|HF_ENABLE
mdefine_line|#define   HF_ENABLE&t;0x40&t;/*    enable HF mode (default is -1 mode) */
DECL|macro|LBA_LMMIO_BASE
mdefine_line|#define LBA_LMMIO_BASE&t;0x0200&t;/* &lt; 4GB I/O address range */
DECL|macro|LBA_LMMIO_MASK
mdefine_line|#define LBA_LMMIO_MASK&t;0x0208
DECL|macro|LBA_GMMIO_BASE
mdefine_line|#define LBA_GMMIO_BASE&t;0x0210&t;/* &gt; 4GB I/O address range */
DECL|macro|LBA_GMMIO_MASK
mdefine_line|#define LBA_GMMIO_MASK&t;0x0218
DECL|macro|LBA_WLMMIO_BASE
mdefine_line|#define LBA_WLMMIO_BASE&t;0x0220&t;/* All &lt; 4GB ranges under the same *SBA* */
DECL|macro|LBA_WLMMIO_MASK
mdefine_line|#define LBA_WLMMIO_MASK&t;0x0228
DECL|macro|LBA_WGMMIO_BASE
mdefine_line|#define LBA_WGMMIO_BASE&t;0x0230&t;/* All &gt; 4GB ranges under the same *SBA* */
DECL|macro|LBA_WGMMIO_MASK
mdefine_line|#define LBA_WGMMIO_MASK&t;0x0238
DECL|macro|LBA_IOS_BASE
mdefine_line|#define LBA_IOS_BASE&t;0x0240&t;/* I/O port space for this LBA */
DECL|macro|LBA_IOS_MASK
mdefine_line|#define LBA_IOS_MASK&t;0x0248
DECL|macro|LBA_ELMMIO_BASE
mdefine_line|#define LBA_ELMMIO_BASE&t;0x0250&t;/* Extra LMMIO range */
DECL|macro|LBA_ELMMIO_MASK
mdefine_line|#define LBA_ELMMIO_MASK&t;0x0258
DECL|macro|LBA_EIOS_BASE
mdefine_line|#define LBA_EIOS_BASE&t;0x0260&t;/* Extra I/O port space */
DECL|macro|LBA_EIOS_MASK
mdefine_line|#define LBA_EIOS_MASK&t;0x0268
DECL|macro|LBA_DMA_CTL
mdefine_line|#define LBA_DMA_CTL&t;0x0278&t;/* firmware sets this */
multiline_comment|/* RESET: ignore DMA stuff until we can measure performance */
DECL|macro|LBA_IBASE
mdefine_line|#define LBA_IBASE&t;0x0300&t;/* DMA support */
DECL|macro|LBA_IMASK
mdefine_line|#define LBA_IMASK&t;0x0308
DECL|macro|LBA_HINT_CFG
mdefine_line|#define LBA_HINT_CFG&t;0x0310
DECL|macro|LBA_HINT_BASE
mdefine_line|#define LBA_HINT_BASE&t;0x0380&t;/* 14 registers at every 8 bytes. */
multiline_comment|/* ERROR regs are needed for config cycle kluges */
DECL|macro|LBA_ERROR_CONFIG
mdefine_line|#define LBA_ERROR_CONFIG 0x0680
DECL|macro|LBA_ERROR_STATUS
mdefine_line|#define LBA_ERROR_STATUS 0x0688
DECL|macro|LBA_IOSAPIC_BASE
mdefine_line|#define LBA_IOSAPIC_BASE&t;0x800 /* Offset of IRQ logic */
multiline_comment|/* non-postable I/O port space, densely packed */
macro_line|#ifdef __LP64__
DECL|macro|LBA_ASTRO_PORT_BASE
mdefine_line|#define LBA_ASTRO_PORT_BASE&t;(0xfffffffffee00000UL)
macro_line|#else
DECL|macro|LBA_ASTRO_PORT_BASE
mdefine_line|#define LBA_ASTRO_PORT_BASE&t;(0xfee00000UL)
macro_line|#endif
multiline_comment|/*&n;** lba_device: Per instance Elroy data structure&n;*/
DECL|struct|lba_device
r_struct
id|lba_device
(brace
DECL|member|hba
r_struct
id|pci_hba_data
id|hba
suffix:semicolon
DECL|member|lba_lock
id|spinlock_t
id|lba_lock
suffix:semicolon
DECL|member|iosapic_obj
r_void
op_star
id|iosapic_obj
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|member|lmmio_base
r_int
r_int
id|lmmio_base
suffix:semicolon
multiline_comment|/* PA_VIEW - fixup MEM addresses */
DECL|member|gmmio_base
r_int
r_int
id|gmmio_base
suffix:semicolon
multiline_comment|/* PA_VIEW - Not used (yet) */
DECL|member|iop_base
r_int
r_int
id|iop_base
suffix:semicolon
multiline_comment|/* PA_VIEW - for IO port accessor funcs */
macro_line|#endif
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* state/functionality enabled */
DECL|member|hw_rev
r_int
id|hw_rev
suffix:semicolon
multiline_comment|/* HW revision of chip */
)brace
suffix:semicolon
DECL|variable|lba_t32
r_static
id|u32
id|lba_t32
suffix:semicolon
multiline_comment|/*&n;** lba &quot;flags&quot;&n;*/
DECL|macro|LBA_FLAG_NO_DMA_DURING_CFG
mdefine_line|#define LBA_FLAG_NO_DMA_DURING_CFG&t;0x01
DECL|macro|LBA_FLAG_SKIP_PROBE
mdefine_line|#define LBA_FLAG_SKIP_PROBE&t;0x10
multiline_comment|/* Tape Release 4 == hw_rev 5 */
DECL|macro|LBA_TR4PLUS
mdefine_line|#define LBA_TR4PLUS(d)      ((d)-&gt;hw_rev &gt; 0x4)
DECL|macro|LBA_DMA_DURING_CFG_DISABLED
mdefine_line|#define LBA_DMA_DURING_CFG_DISABLED(d) ((d)-&gt;flags &amp; LBA_FLAG_NO_DMA_DURING_CFG)
DECL|macro|LBA_SKIP_PROBE
mdefine_line|#define LBA_SKIP_PROBE(d) ((d)-&gt;flags &amp; LBA_FLAG_SKIP_PROBE)
multiline_comment|/* Looks nice and keeps the compiler happy */
DECL|macro|LBA_DEV
mdefine_line|#define LBA_DEV(d) ((struct lba_device *) (d))
multiline_comment|/*&n;** Only allow 8 subsidiary busses per LBA&n;** Problem is the PCI bus numbering is globally shared.&n;*/
DECL|macro|LBA_MAX_NUM_BUSES
mdefine_line|#define LBA_MAX_NUM_BUSES 8
multiline_comment|/************************************&n; * LBA register read and write support&n; *&n; * BE WARNED: register writes are posted.&n; *  (ie follow writes which must reach HW with a read)&n; */
DECL|macro|READ_U8
mdefine_line|#define READ_U8(addr)  gsc_readb(addr)
DECL|macro|READ_U16
mdefine_line|#define READ_U16(addr) gsc_readw((u16 *) (addr))
DECL|macro|READ_U32
mdefine_line|#define READ_U32(addr) gsc_readl((u32 *) (addr))
DECL|macro|WRITE_U8
mdefine_line|#define WRITE_U8(value, addr) gsc_writeb(value, addr)
DECL|macro|WRITE_U16
mdefine_line|#define WRITE_U16(value, addr) gsc_writew(value, (u16 *) (addr))
DECL|macro|WRITE_U32
mdefine_line|#define WRITE_U32(value, addr) gsc_writel(value, (u32 *) (addr))
DECL|macro|READ_REG8
mdefine_line|#define READ_REG8(addr)  gsc_readb(addr)
DECL|macro|READ_REG16
mdefine_line|#define READ_REG16(addr) le16_to_cpu(gsc_readw((u16 *) (addr)))
DECL|macro|READ_REG32
mdefine_line|#define READ_REG32(addr) le32_to_cpu(gsc_readl((u32 *) (addr)))
DECL|macro|WRITE_REG8
mdefine_line|#define WRITE_REG8(value, addr) gsc_writeb(value, addr)
DECL|macro|WRITE_REG16
mdefine_line|#define WRITE_REG16(value, addr) gsc_writew(cpu_to_le16(value), (u16 *) (addr))
DECL|macro|WRITE_REG32
mdefine_line|#define WRITE_REG32(value, addr) gsc_writel(cpu_to_le32(value), (u32 *) (addr))
DECL|macro|LBA_CFG_TOK
mdefine_line|#define LBA_CFG_TOK(bus,dfn) ((u32) ((bus)&lt;&lt;16 | (dfn)&lt;&lt;8))
DECL|macro|LBA_CFG_BUS
mdefine_line|#define LBA_CFG_BUS(tok)  ((u8) ((tok)&gt;&gt;16))
DECL|macro|LBA_CFG_DEV
mdefine_line|#define LBA_CFG_DEV(tok)  ((u8) ((tok)&gt;&gt;11) &amp; 0x1f)
DECL|macro|LBA_CFG_FUNC
mdefine_line|#define LBA_CFG_FUNC(tok) ((u8) ((tok)&gt;&gt;8 ) &amp; 0x7)
macro_line|#ifdef DEBUG_LBA
multiline_comment|/* Extract LBA (Rope) number from HPA */
DECL|macro|LBA_NUM
mdefine_line|#define LBA_NUM(x)    ((((uintptr_t) x) &gt;&gt; 13) &amp; 0xf)
macro_line|#endif /* DEBUG_LBA */
macro_line|#ifdef __LP64__
multiline_comment|/* PDC_PAT */
DECL|variable|pdc_result
r_static
r_int
r_int
id|pdc_result
(braket
l_int|32
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;** One time initialization to let the world know the LBA was found.&n;** This is the only routine which is NOT static.&n;** Must be called exactly once before pci_init().&n;*/
DECL|function|lba_init
r_void
id|__init
id|lba_init
c_func
(paren
r_void
)paren
(brace
id|register_driver
c_func
(paren
id|lba_drivers_for
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|lba_dump_res
id|lba_dump_res
c_func
(paren
r_struct
id|resource
op_star
id|r
comma
r_int
id|d
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|r
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(%p)&quot;
comma
id|r-&gt;parent
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|d
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%p [%lx,%lx]/%x&bslash;n&quot;
comma
id|r
comma
id|r-&gt;start
comma
id|r-&gt;end
comma
(paren
r_int
)paren
id|r-&gt;flags
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
id|r-&gt;child
comma
id|d
op_plus
l_int|2
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
id|r-&gt;sibling
comma
id|d
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** LBA rev 2.0, 2.1, 2.2, and 3.0 bus walks require a complex&n;** workaround for cfg cycles:&n;**&t;-- preserve  LBA state&n;**&t;-- LBA_FLAG_NO_DMA_DURING_CFG workaround&n;**&t;-- turn on smart mode&n;**&t;-- probe with config writes before doing config reads&n;**&t;-- check ERROR_STATUS&n;**&t;-- clear ERROR_STATUS&n;**&t;-- restore LBA state&n;**&n;** The workaround is only used for device discovery.&n;*/
r_static
r_int
DECL|function|lba_device_present
id|lba_device_present
c_func
(paren
id|u8
id|bus
comma
id|u8
id|dfn
comma
r_struct
id|lba_device
op_star
id|d
)paren
(brace
id|u8
id|first_bus
op_assign
id|d-&gt;hba.hba_bus-&gt;secondary
suffix:semicolon
id|u8
id|last_sub_bus
op_assign
id|d-&gt;hba.hba_bus-&gt;subordinate
suffix:semicolon
macro_line|#if 0
multiline_comment|/* FIXME - see below in this function */
id|u8
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|dfn
)paren
suffix:semicolon
id|u8
id|func
op_assign
id|PCI_FUNC
c_func
(paren
id|dfn
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|bus
op_ge
id|first_bus
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bus
op_le
id|last_sub_bus
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|bus
op_minus
id|first_bus
)paren
OL
id|LBA_MAX_NUM_BUSES
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
OL
id|first_bus
)paren
op_logical_or
(paren
id|bus
OG
id|last_sub_bus
)paren
op_logical_or
(paren
(paren
id|bus
op_minus
id|first_bus
)paren
op_ge
id|LBA_MAX_NUM_BUSES
)paren
)paren
(brace
multiline_comment|/* devices that fall into any of these cases won&squot;t get claimed */
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;** FIXME: Need to implement code to fill the devices bitmap based&n;** on contents of the local pci_bus tree &quot;data base&quot;.&n;** pci_register_ops() walks the bus for us and builds the tree.&n;** For now, always do the config cycle.&n;*/
id|bus
op_sub_assign
id|first_bus
suffix:semicolon
r_return
(paren
(paren
(paren
id|d-&gt;devices
(braket
id|bus
)braket
(braket
id|dev
)braket
)paren
op_rshift
id|func
)paren
op_amp
l_int|0x1
)paren
suffix:semicolon
macro_line|#else
r_return
id|TRUE
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|LBA_CFG_SETUP
mdefine_line|#define LBA_CFG_SETUP(d, tok) {&t;&t;&t;&t;&bslash;&n;    /* Save contents of error config register.  */&t;&t;&t;&bslash;&n;    error_config = READ_REG32(d-&gt;hba.base_addr + LBA_ERROR_CONFIG);&t;&t;&bslash;&n;&bslash;&n;    /* Save contents of status control register.  */&t;&t;&t;&bslash;&n;    status_control = READ_REG32(d-&gt;hba.base_addr + LBA_STAT_CTL);&t;&t;&bslash;&n;&bslash;&n;    /* For LBA rev 2.0, 2.1, 2.2, and 3.0, we must disable DMA&t;&t;&bslash;&n;    ** arbitration for full bus walks.&t;&t;&t;&t;&t;&bslash;&n;    */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (LBA_DMA_DURING_CFG_DISABLED(d)) {&t;&t;&t;&t;&bslash;&n;&t;/* Save contents of arb mask register. */&t;&t;&t;&bslash;&n;&t;arb_mask = READ_REG32(d-&gt;hba.base_addr + LBA_ARB_MASK);&t;&t;&bslash;&n;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Turn off all device arbitration bits (i.e. everything&t;&bslash;&n;&t; * except arbitration enable bit).&t;&t;&t;&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;WRITE_REG32(0x1, d-&gt;hba.base_addr + LBA_ARB_MASK);&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Set the smart mode bit so that master aborts don&squot;t cause&t;&t;&bslash;&n;     * LBA to go into PCI fatal mode (required).&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(error_config | 0x20, d-&gt;hba.base_addr + LBA_ERROR_CONFIG);&t;&bslash;&n;}
DECL|macro|LBA_CFG_PROBE
mdefine_line|#define LBA_CFG_PROBE(d, tok) {&t;&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Setup Vendor ID write and read back the address register&t;&t;&bslash;&n;     * to make sure that LBA is the bus master.&t;&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(tok | PCI_VENDOR_ID, (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Read address register to ensure that LBA is the bus master,&t;&bslash;&n;     * which implies that DMA traffic has stopped when DMA arb is off.&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Generate a cfg write cycle (will have no affect on&t;&t;&bslash;&n;     * Vendor ID register since read-only).&t;&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(~0, (d)-&gt;hba.base_addr + LBA_PCI_CFG_DATA);&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Make sure write has completed before proceeding further,&t;&t;&bslash;&n;     * i.e. before setting clear enable.&t;&t;&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&t;&bslash;&n;}
multiline_comment|/*&n; * HPREVISIT:&n; *   -- Can&squot;t tell if config cycle got the error.&n; *&n; *&t;&t;OV bit is broken until rev 4.0, so can&squot;t use OV bit and&n; *&t;&t;LBA_ERROR_LOG_ADDR to tell if error belongs to config cycle.&n; *&n; *&t;&t;As of rev 4.0, no longer need the error check.&n; *&n; *   -- Even if we could tell, we still want to return -1&n; *&t;for **ANY** error (not just master abort).&n; *&n; *   -- Only clear non-fatal errors (we don&squot;t want to bring&n; *&t;LBA out of pci-fatal mode).&n; *&n; *&t;&t;Actually, there is still a race in which&n; *&t;&t;we could be clearing a fatal error.  We will&n; *&t;&t;live with this during our real mode bus walk&n; *&t;&t;until rev 4.0 (no driver activity during&n; *&t;&t;real mode bus walk).  The real mode bus walk&n; *&t;&t;has race conditions concerning the use of&n; *&t;&t;smart mode as well.&n; */
DECL|macro|LBA_MASTER_ABORT_ERROR
mdefine_line|#define LBA_MASTER_ABORT_ERROR 0xc
DECL|macro|LBA_FATAL_ERROR
mdefine_line|#define LBA_FATAL_ERROR 0x10
DECL|macro|LBA_CFG_MASTER_ABORT_CHECK
mdefine_line|#define LBA_CFG_MASTER_ABORT_CHECK(d, base, tok, error) {&t;&t;&bslash;&n;    u32 error_status = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Set clear enable (CE) bit. Unset by HW when new&t;&t;&t;&bslash;&n;     * errors are logged -- LBA HW ERS section 14.3.3).&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(status_control | 0x20, base + LBA_STAT_CTL);&t;&bslash;&n;    error_status = READ_REG32(base + LBA_ERROR_STATUS);&t;&t;&bslash;&n;    if ((error_status &amp; 0x1f) != 0) {&t;&t;&t;&t;&t;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Fail the config read request.&t;&t;&t;&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;error = 1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((error_status &amp; LBA_FATAL_ERROR) == 0) {&t;&t;&t;&bslash;&n;&t;    /*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;     * Clear error status (if fatal bit not set) by setting&t;&bslash;&n;&t;     * clear error log bit (CL).&t;&t;&t;&t;&bslash;&n;&t;     */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    WRITE_REG32(status_control | 0x10, base + LBA_STAT_CTL);&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|LBA_CFG_TR4_ADDR_SETUP
mdefine_line|#define LBA_CFG_TR4_ADDR_SETUP(d, addr) &bslash;&n;    WRITE_REG32(((addr) &amp; ~3), (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR)
DECL|macro|LBA_CFG_ADDR_SETUP
mdefine_line|#define LBA_CFG_ADDR_SETUP(d, addr) {&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(((addr) &amp; ~3), (d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * HPREVISIT:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     *       --&t;Potentially could skip this once DMA bug fixed.&t;&t;&bslash;&n;     *&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Read address register to ensure that LBA is the bus master,&t;&bslash;&n;     * which implies that DMA traffic has stopped when DMA arb is off.&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    lba_t32 = READ_REG32((d)-&gt;hba.base_addr + LBA_PCI_CFG_ADDR);&t;&t;&bslash;&n;}
DECL|macro|LBA_CFG_RESTORE
mdefine_line|#define LBA_CFG_RESTORE(d, base) {&t;&t;&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Restore status control register (turn off clear enable).&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(status_control, base + LBA_STAT_CTL);&t;&t;&t;&bslash;&n;    /*&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;     * Restore error config register (turn off smart mode).&t;&t;&bslash;&n;     */&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    WRITE_REG32(error_config, base + LBA_ERROR_CONFIG);&t;&t;&t;&bslash;&n;    if (LBA_DMA_DURING_CFG_DISABLED(d)) {&t;&t;&t;&t;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Restore arb mask register (reenables DMA arbitration).&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;WRITE_REG32(arb_mask, base + LBA_ARB_MASK);&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
r_static
r_int
r_int
DECL|function|lba_rd_cfg
id|lba_rd_cfg
c_func
(paren
r_struct
id|lba_device
op_star
id|d
comma
id|u32
id|tok
comma
id|u8
id|reg
comma
id|u32
id|size
)paren
(brace
id|u32
id|data
op_assign
op_complement
l_int|0
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|u32
id|arb_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used by LBA_CFG_SETUP/RESTORE */
id|u32
id|error_config
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used by LBA_CFG_SETUP/RESTORE */
id|u32
id|status_control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used by LBA_CFG_SETUP/RESTORE */
id|ASSERT
c_func
(paren
(paren
id|size
op_eq
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u32
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_ne
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
id|data
suffix:semicolon
)brace
id|LBA_CFG_SETUP
c_func
(paren
id|d
comma
id|tok
)paren
suffix:semicolon
id|LBA_CFG_PROBE
c_func
(paren
id|d
comma
id|tok
)paren
suffix:semicolon
id|LBA_CFG_MASTER_ABORT_CHECK
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
comma
id|tok
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|LBA_CFG_ADDR_SETUP
c_func
(paren
id|d
comma
id|tok
op_or
id|reg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
r_sizeof
(paren
id|u8
)paren
suffix:colon
id|data
op_assign
(paren
id|u32
)paren
id|READ_REG8
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|3
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u16
)paren
suffix:colon
id|data
op_assign
(paren
id|u32
)paren
id|READ_REG16
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|2
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u32
)paren
suffix:colon
id|data
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* leave data as -1 */
)brace
)brace
id|LBA_CFG_RESTORE
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|macro|LBA_CFG_RD
mdefine_line|#define LBA_CFG_RD(size, mask) &bslash;&n;static int lba_cfg_read##size (struct pci_dev *dev, int pos, u##size *data) &bslash;&n;{ &bslash;&n;&t;struct lba_device *d = LBA_DEV(dev-&gt;bus-&gt;sysdata); &bslash;&n;&t;u32 local_bus = (dev-&gt;bus-&gt;parent == NULL) ? 0 : dev-&gt;bus-&gt;secondary; &bslash;&n;&t;u32 tok = LBA_CFG_TOK(local_bus,dev-&gt;devfn); &bslash;&n; &bslash;&n;&t;if ((!LBA_TR4PLUS(d)) &amp;&amp; (!LBA_SKIP_PROBE(d))) { &bslash;&n;&t;&t;/* original - Generate config cycle on broken elroy &bslash;&n;&t;&t;  with risk we will miss PCI bus errors. */ &bslash;&n;&t;&t;*data = (u##size) lba_rd_cfg(d, tok, pos, sizeof(u##size)); &bslash;&n;&t;&t;DBG_CFG(KERN_DEBUG &quot;%s(%s+%2x) -&gt; 0x%x (a)&bslash;n&quot;, __FUNCTION__, dev-&gt;slot_name, pos, *data); &bslash;&n;&t;&t;return(*data == (u##size) -1); &bslash;&n;&t;} &bslash;&n; &bslash;&n;&t;if (LBA_SKIP_PROBE(d) &amp;&amp; (!lba_device_present(dev-&gt;bus-&gt;secondary, dev-&gt;devfn, d))) &bslash;&n;&t;{ &bslash;&n;&t;&t;DBG_CFG(KERN_DEBUG &quot;%s(%s+%2x) -&gt; -1 (b)&bslash;n&quot;, __FUNCTION__, dev-&gt;slot_name, pos, *data); &bslash;&n;&t;&t;/* either don&squot;t want to look or know device isn&squot;t present. */ &bslash;&n;&t;&t;*data = (u##size) -1; &bslash;&n;&t;&t;return(0); &bslash;&n;&t;} &bslash;&n; &bslash;&n;&t;/* Basic Algorithm &bslash;&n;&t;** Should only get here on fully working LBA rev. &bslash;&n;&t;** This is how simple the code should have been. &bslash;&n;&t;*/ &bslash;&n;&t;LBA_CFG_TR4_ADDR_SETUP(d, tok | pos); &bslash;&n;&t;*data = READ_REG##size(d-&gt;hba.base_addr + LBA_PCI_CFG_DATA + (pos &amp; mask));&bslash;&n;&t;DBG_CFG(KERN_DEBUG &quot;%s(%s+%2x) -&gt; 0x%x (c)&bslash;n&quot;, __FUNCTION__, dev-&gt;slot_name, pos, *data);&bslash;&n;&t;return(*data == (u##size) -1); &bslash;&n;}
id|LBA_CFG_RD
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_CFG_RD
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_CFG_RD
c_func
(paren
l_int|32
comma
l_int|0
)paren
r_static
r_void
DECL|function|lba_wr_cfg
id|lba_wr_cfg
c_func
(paren
r_struct
id|lba_device
op_star
id|d
comma
id|u32
id|tok
comma
id|u8
id|reg
comma
id|u32
id|data
comma
id|u32
id|size
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|u32
id|arb_mask
op_assign
l_int|0
suffix:semicolon
id|u32
id|error_config
op_assign
l_int|0
suffix:semicolon
id|u32
id|status_control
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|size
op_eq
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_or
(paren
id|size
op_eq
r_sizeof
(paren
id|u32
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_ne
r_sizeof
(paren
id|u8
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u16
)paren
)paren
op_logical_and
(paren
id|size
op_ne
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|LBA_CFG_SETUP
c_func
(paren
id|d
comma
id|tok
)paren
suffix:semicolon
id|LBA_CFG_ADDR_SETUP
c_func
(paren
id|d
comma
id|tok
op_or
id|reg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
r_sizeof
(paren
id|u8
)paren
suffix:colon
id|WRITE_REG8
c_func
(paren
(paren
id|u8
)paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|3
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u16
)paren
suffix:colon
id|WRITE_REG16
c_func
(paren
(paren
id|u8
)paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
op_plus
(paren
id|reg
op_amp
l_int|2
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
r_sizeof
(paren
id|u32
)paren
suffix:colon
id|WRITE_REG32
c_func
(paren
id|data
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_PCI_CFG_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|LBA_CFG_MASTER_ABORT_CHECK
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
comma
id|tok
comma
id|error
)paren
suffix:semicolon
id|LBA_CFG_RESTORE
c_func
(paren
id|d
comma
id|d-&gt;hba.base_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * LBA 4.0 config write code implements non-postable semantics&n; * by doing a read of CONFIG ADDR after the write.&n; */
DECL|macro|LBA_CFG_WR
mdefine_line|#define LBA_CFG_WR(size, mask) &bslash;&n;static int lba_cfg_write##size (struct pci_dev *dev, int pos, u##size data) &bslash;&n;{ &bslash;&n;&t;struct lba_device *d = LBA_DEV(dev-&gt;bus-&gt;sysdata); &bslash;&n;&t;u32 local_bus = (dev-&gt;bus-&gt;parent == NULL) ? 0 : dev-&gt;bus-&gt;secondary; &bslash;&n;&t;u32 tok = LBA_CFG_TOK(local_bus,dev-&gt;devfn); &bslash;&n; &bslash;&n; &t;ASSERT((tok &amp; 0xff) == 0); &bslash;&n;&t;ASSERT(pos &lt; 0x100); &bslash;&n; &bslash;&n;&t;if ((!LBA_TR4PLUS(d)) &amp;&amp; (!LBA_SKIP_PROBE(d))) { &bslash;&n;&t;&t;/* Original Workaround */ &bslash;&n;&t;&t;lba_wr_cfg(d, tok, pos, (u32) data, sizeof(u##size)); &bslash;&n;&t;&t;DBG_CFG(KERN_DEBUG &quot;%s(%s+%2x) = 0x%x (a)&bslash;n&quot;, __FUNCTION__, dev-&gt;slot_name, pos, data); &bslash;&n;&t;&t;return 0; &bslash;&n;&t;} &bslash;&n; &bslash;&n;&t;if (LBA_SKIP_PROBE(d) &amp;&amp; (!lba_device_present(dev-&gt;bus-&gt;secondary, dev-&gt;devfn, d))) { &bslash;&n;&t;&t;DBG_CFG(KERN_DEBUG &quot;%s(%s+%2x) = 0x%x (b)&bslash;n&quot;, __FUNCTION__, dev-&gt;slot_name, pos, data); &bslash;&n;&t;&t;return 1; /* New Workaround */ &bslash;&n;&t;} &bslash;&n; &bslash;&n;&t;DBG_CFG(KERN_DEBUG &quot;%s(%s+%2x) = 0x%x (c)&bslash;n&quot;, __FUNCTION__, dev-&gt;slot_name, pos, data); &bslash;&n;&t;/* Basic Algorithm */ &bslash;&n;&t;LBA_CFG_TR4_ADDR_SETUP(d, tok | pos); &bslash;&n;&t;WRITE_REG##size(data, d-&gt;hba.base_addr + LBA_PCI_CFG_DATA + (pos &amp; mask)); &bslash;&n;&t;lba_t32 = READ_REG32(d-&gt;hba.base_addr + LBA_PCI_CFG_ADDR); &bslash;&n;&t;return 0; &bslash;&n;}
id|LBA_CFG_WR
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_CFG_WR
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_CFG_WR
c_func
(paren
l_int|32
comma
l_int|0
)paren
DECL|variable|lba_cfg_ops
r_static
r_struct
id|pci_ops
id|lba_cfg_ops
op_assign
(brace
id|lba_cfg_read8
comma
id|lba_cfg_read16
comma
id|lba_cfg_read32
comma
id|lba_cfg_write8
comma
id|lba_cfg_write16
comma
id|lba_cfg_write32
)brace
suffix:semicolon
r_static
r_void
DECL|function|lba_bios_init
id|lba_bios_init
c_func
(paren
r_void
)paren
(brace
id|DBG
c_func
(paren
id|KERN_DEBUG
id|MODULE_NAME
l_string|&quot;: lba_bios_init&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef __LP64__
multiline_comment|/*&n;** Determine if a device is already configured.&n;** If so, reserve it resources.&n;**&n;** Read PCI cfg command register and see if I/O or MMIO is enabled.&n;** PAT has to enable the devices it&squot;s using.&n;**&n;** Note: resources are fixed up before we try to claim them.&n;*/
r_static
r_void
DECL|function|lba_claim_dev_resources
id|lba_claim_dev_resources
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u16
id|cmd
suffix:semicolon
r_int
id|i
comma
id|srch_flags
suffix:semicolon
(paren
r_void
)paren
id|lba_cfg_read16
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|srch_flags
op_assign
(paren
id|cmd
op_amp
id|PCI_COMMAND_IO
)paren
ques
c_cond
id|IORESOURCE_IO
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
id|PCI_COMMAND_MEMORY
)paren
id|srch_flags
op_or_assign
id|IORESOURCE_MEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|srch_flags
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|PCI_ROM_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|flags
op_amp
id|srch_flags
)paren
(brace
id|pci_claim_resource
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   claimed %s %d [%lx,%lx]/%x&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|i
comma
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|start
comma
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|end
comma
(paren
r_int
)paren
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;** The algorithm is generic code.&n;** But it needs to access local data structures to get the IRQ base.&n;** Could make this a &quot;pci_fixup_irq(bus, region)&quot; but not sure&n;** it&squot;s worth it.&n;**&n;** Called by do_pci_scan_bus() immediately after each PCI bus is walked.&n;** Resources aren&squot;t allocated until recursive buswalk below HBA is completed.&n;*/
r_static
r_void
DECL|function|lba_fixup_bus
id|lba_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
id|u16
id|fbb_enable
op_assign
id|PCI_STATUS_FAST_BACK
suffix:semicolon
id|u16
id|status
suffix:semicolon
r_struct
id|lba_device
op_star
id|ldev
op_assign
id|LBA_DEV
c_func
(paren
id|bus-&gt;sysdata
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
r_int
id|i
suffix:semicolon
macro_line|#endif
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus(0x%p) bus %d sysdata 0x%p&bslash;n&quot;
comma
id|bus
comma
id|bus-&gt;secondary
comma
id|bus-&gt;sysdata
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Properly Setup MMIO resources for this bus.&n;&t;** pci_alloc_primary_bus() mangles this.&n;&t;*/
r_if
c_cond
(paren
l_int|NULL
op_eq
id|bus-&gt;self
)paren
(brace
r_int
id|err
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus() %s [%lx/%lx]/%x&bslash;n&quot;
comma
id|ldev-&gt;hba.io_space.name
comma
id|ldev-&gt;hba.io_space.start
comma
id|ldev-&gt;hba.io_space.end
comma
(paren
r_int
)paren
id|ldev-&gt;hba.io_space.flags
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;lba_fixup_bus() %s [%lx/%lx]/%x&bslash;n&quot;
comma
id|ldev-&gt;hba.mem_space.name
comma
id|ldev-&gt;hba.mem_space.start
comma
id|ldev-&gt;hba.mem_space.end
comma
(paren
r_int
)paren
id|ldev-&gt;hba.mem_space.flags
)paren
suffix:semicolon
id|err
op_assign
id|request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
op_amp
(paren
id|ldev-&gt;hba.io_space
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|ioport_resource
comma
l_int|2
)paren
suffix:semicolon
)brace
id|err
op_assign
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
(paren
id|ldev-&gt;hba.mem_space
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|iomem_resource
comma
l_int|2
)paren
suffix:semicolon
)brace
id|bus-&gt;resource
(braket
l_int|0
)braket
op_assign
op_amp
(paren
id|ldev-&gt;hba.io_space
)paren
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|1
)braket
op_assign
op_amp
(paren
id|ldev-&gt;hba.mem_space
)paren
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|ln
comma
op_amp
id|bus-&gt;devices
)paren
(brace
id|dev
op_assign
id|pci_dev_b
c_func
(paren
id|ln
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/*&n;&t;&t;** 0-5 are the &quot;standard PCI regions&quot;&n;&t;&t;** (see comments near PCI_NUM_RESOURCES in include/linux/pci.h)&n;&t;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|PCI_ROM_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
(paren
id|dev-&gt;resource
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
(brace
multiline_comment|/* &quot;Globalize&quot; PCI address */
id|res-&gt;start
op_or_assign
id|ldev-&gt;lmmio_base
suffix:semicolon
id|res-&gt;end
op_or_assign
id|ldev-&gt;lmmio_base
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t;** If one device does not support FBB transfers,&n;&t;&t;** No one on the bus can be allowed to use them.&n;&t;&t;*/
(paren
r_void
)paren
id|lba_cfg_read16
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
op_amp
id|status
)paren
suffix:semicolon
id|fbb_enable
op_and_assign
id|status
suffix:semicolon
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|pdc_pat
)paren
(brace
multiline_comment|/* Claim resources for PDC&squot;s devices */
id|lba_claim_dev_resources
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* __LP64__ */
multiline_comment|/*&n;&t;&t;** P2PB&squot;s have no IRQs. ignore them.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
r_continue
suffix:semicolon
multiline_comment|/* Adjust INTERRUPT_LINE for this dev */
id|iosapic_fixup_irq
c_func
(paren
id|LBA_DEV
c_func
(paren
id|bus-&gt;sysdata
)paren
op_member_access_from_pointer
id|iosapic_obj
comma
id|dev
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* FIXME/REVISIT - finish figuring out to set FBB on both&n;** pbus_set_ranges() clobbers PCI_BRIDGE_CONTROL.&n;** Can&squot;t fixup here anyway....garr...&n;*/
r_if
c_cond
(paren
id|fbb_enable
)paren
(brace
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
id|u8
id|control
suffix:semicolon
multiline_comment|/* enable on PPB */
(paren
r_void
)paren
id|lba_cfg_read8
c_func
(paren
id|bus-&gt;self
comma
id|PCI_BRIDGE_CONTROL
comma
op_amp
id|control
)paren
suffix:semicolon
(paren
r_void
)paren
id|lba_cfg_write8
c_func
(paren
id|bus-&gt;self
comma
id|PCI_BRIDGE_CONTROL
comma
id|control
op_or
id|PCI_STATUS_FAST_BACK
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* enable on LBA */
)brace
id|fbb_enable
op_assign
id|PCI_COMMAND_FAST_BACK
suffix:semicolon
)brace
multiline_comment|/* Lastly enable FBB/PERR/SERR on all devices too */
id|list_for_each
c_func
(paren
id|ln
comma
op_amp
id|bus-&gt;devices
)paren
(brace
(paren
r_void
)paren
id|lba_cfg_read16
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|status
)paren
suffix:semicolon
id|status
op_or_assign
id|PCI_COMMAND_PARITY
op_or
id|PCI_COMMAND_SERR
op_or
id|fbb_enable
suffix:semicolon
(paren
r_void
)paren
id|lba_cfg_write16
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|variable|lba_bios_ops
r_struct
id|pci_bios_ops
id|lba_bios_ops
op_assign
(brace
id|lba_bios_init
comma
id|lba_fixup_bus
multiline_comment|/* void lba_fixup_bus(struct pci_bus *bus) */
)brace
suffix:semicolon
multiline_comment|/*******************************************************&n;**&n;** LBA Sprockets &quot;I/O Port&quot; Space Accessor Functions&n;**&n;** This set of accessor functions is intended for use with&n;** &quot;legacy firmware&quot; (ie Sprockets on Allegro/Forte boxes).&n;**&n;** Many PCI devices don&squot;t require use of I/O port space (eg Tulip,&n;** NCR720) since they export the same registers to both MMIO and&n;** I/O port space. In general I/O port space is slower than&n;** MMIO since drivers are designed so PIO writes can be posted.&n;**&n;********************************************************/
DECL|macro|LBA_PORT_IN
mdefine_line|#define LBA_PORT_IN(size, mask) &bslash;&n;static u##size lba_astro_in##size (struct pci_hba_data *d, u16 addr) &bslash;&n;{ &bslash;&n;&t;u##size t; &bslash;&n;&t;ASSERT(bus != NULL); &bslash;&n;&t;DBG_PORT(KERN_DEBUG &quot;%s(0x%p, 0x%x) -&gt;&quot;, __FUNCTION__, bus, addr); &bslash;&n;&t;t = READ_REG##size(LBA_ASTRO_PORT_BASE + addr); &bslash;&n;&t;DBG_PORT(&quot; 0x%x&bslash;n&quot;, t); &bslash;&n;&t;return (t); &bslash;&n;}
id|LBA_PORT_IN
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|32
comma
l_int|0
)paren
multiline_comment|/*&n;** BUG X4107:  Ordering broken - DMA RD return can bypass PIO WR&n;**&n;** Fixed in Elroy 2.2. The READ_U32(..., LBA_FUNC_ID) below is&n;** guarantee non-postable completion semantics - not avoid X4107.&n;** The READ_U32 only guarantees the write data gets to elroy but&n;** out to the PCI bus. We can&squot;t read stuff from I/O port space&n;** since we don&squot;t know what has side-effects. Attempting to read&n;** from configuration space would be suicidal given the number of&n;** bugs in that elroy functionality.&n;**&n;**      Description:&n;**          DMA read results can improperly pass PIO writes (X4107).  The&n;**          result of this bug is that if a processor modifies a location in&n;**          memory after having issued PIO writes, the PIO writes are not&n;**          guaranteed to be completed before a PCI device is allowed to see&n;**          the modified data in a DMA read.&n;**&n;**          Note that IKE bug X3719 in TR1 IKEs will result in the same&n;**          symptom.&n;**&n;**      Workaround:&n;**          The workaround for this bug is to always follow a PIO write with&n;**          a PIO read to the same bus before starting DMA on that PCI bus.&n;**&n;*/
DECL|macro|LBA_PORT_OUT
mdefine_line|#define LBA_PORT_OUT(size, mask) &bslash;&n;static void lba_astro_out##size (struct pci_hba_data *d, u16 addr, u##size val) &bslash;&n;{ &bslash;&n;&t;ASSERT(bus != NULL); &bslash;&n;&t;DBG_PORT(KERN_DEBUG &quot;%s(0x%p, 0x%x, 0x%x)&bslash;n&quot;, __FUNCTION__, d, addr, val); &bslash;&n;&t;WRITE_REG##size(val, LBA_ASTRO_PORT_BASE + addr); &bslash;&n;&t;if (LBA_DEV(d)-&gt;hw_rev &lt; 3) &bslash;&n;&t;&t;lba_t32 = READ_U32(d-&gt;base_addr + LBA_FUNC_ID); &bslash;&n;}
id|LBA_PORT_OUT
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|32
comma
l_int|0
)paren
DECL|variable|lba_astro_port_ops
r_static
r_struct
id|pci_port_ops
id|lba_astro_port_ops
op_assign
(brace
id|lba_astro_in8
comma
id|lba_astro_in16
comma
id|lba_astro_in32
comma
id|lba_astro_out8
comma
id|lba_astro_out16
comma
id|lba_astro_out32
)brace
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|macro|PIOP_TO_GMMIO
mdefine_line|#define PIOP_TO_GMMIO(lba, addr) &bslash;&n;&t;((lba)-&gt;iop_base + (((addr)&amp;0xFFFC)&lt;&lt;10) + ((addr)&amp;3))
multiline_comment|/*******************************************************&n;**&n;** LBA PAT &quot;I/O Port&quot; Space Accessor Functions&n;**&n;** This set of accessor functions is intended for use with&n;** &quot;PAT PDC&quot; firmware (ie Prelude/Rhapsody/Piranha boxes).&n;**&n;** This uses the PIOP space located in the first 64MB of GMMIO.&n;** Each rope gets a full 64*KB* (ie 4 bytes per page) this way.&n;** bits 1:0 stay the same.  bits 15:2 become 25:12.&n;** Then add the base and we can generate an I/O Port cycle.&n;********************************************************/
DECL|macro|LBA_PORT_IN
macro_line|#undef LBA_PORT_IN
DECL|macro|LBA_PORT_IN
mdefine_line|#define LBA_PORT_IN(size, mask) &bslash;&n;static u##size lba_pat_in##size (struct pci_hba_data *l, u16 addr) &bslash;&n;{ &bslash;&n;&t;u##size t; &bslash;&n;&t;ASSERT(bus != NULL); &bslash;&n;&t;DBG_PORT(KERN_DEBUG &quot;%s(0x%p, 0x%x) -&gt;&quot;, __FUNCTION__, l, addr); &bslash;&n;&t;t = READ_REG##size(PIOP_TO_GMMIO(LBA_DEV(l), addr)); &bslash;&n;&t;DBG_PORT(&quot; 0x%x&bslash;n&quot;, t); &bslash;&n;&t;return (t); &bslash;&n;}
id|LBA_PORT_IN
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_IN
c_func
(paren
l_int|32
comma
l_int|0
)paren
DECL|macro|LBA_PORT_OUT
macro_line|#undef LBA_PORT_OUT
DECL|macro|LBA_PORT_OUT
mdefine_line|#define LBA_PORT_OUT(size, mask) &bslash;&n;static void lba_pat_out##size (struct pci_hba_data *l, u16 addr, u##size val) &bslash;&n;{ &bslash;&n;&t;void *where = (void *) PIOP_TO_GMMIO(LBA_DEV(l), addr); &bslash;&n;&t;ASSERT(bus != NULL); &bslash;&n;&t;DBG_PORT(KERN_DEBUG &quot;%s(0x%p, 0x%x, 0x%x)&bslash;n&quot;, __FUNCTION__, l, addr, val); &bslash;&n;&t;WRITE_REG##size(val, where); &bslash;&n;&t;/* flush the I/O down to the elroy at least */ &bslash;&n;&t;lba_t32 = READ_U32(l-&gt;base_addr + LBA_FUNC_ID); &bslash;&n;}
id|LBA_PORT_OUT
c_func
(paren
l_int|8
comma
l_int|3
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|16
comma
l_int|2
)paren
id|LBA_PORT_OUT
c_func
(paren
l_int|32
comma
l_int|0
)paren
DECL|variable|lba_pat_port_ops
r_static
r_struct
id|pci_port_ops
id|lba_pat_port_ops
op_assign
(brace
id|lba_pat_in8
comma
id|lba_pat_in16
comma
id|lba_pat_in32
comma
id|lba_pat_out8
comma
id|lba_pat_out16
comma
id|lba_pat_out32
)brace
suffix:semicolon
multiline_comment|/*&n;** make range information from PDC available to PCI subsystem.&n;** We make the PDC call here in order to get the PCI bus range&n;** numbers. The rest will get forwarded in pcibios_fixup_bus().&n;** We don&squot;t have a struct pci_bus assigned to us yet.&n;*/
r_static
r_void
DECL|function|lba_pat_resources
id|lba_pat_resources
c_func
(paren
r_struct
id|hp_device
op_star
id|d
comma
r_struct
id|lba_device
op_star
id|lba_dev
)paren
(brace
id|pdc_pat_cell_mod_maddr_block_t
id|pa_pdc_cell
suffix:semicolon
multiline_comment|/* PA_VIEW */
macro_line|#ifdef DONT_NEED_THIS_FOR_ASTRO
id|pdc_pat_cell_mod_maddr_block_t
id|io_pdc_cell
suffix:semicolon
multiline_comment|/* IO_VIEW */
r_int
id|io_count
suffix:semicolon
macro_line|#endif
r_int
id|status
suffix:semicolon
multiline_comment|/* PDC return status */
r_int
id|pa_count
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* return cell module (IO view) */
id|status
op_assign
id|pdc_pat_cell_module
c_func
(paren
op_amp
id|pdc_result
comma
id|d-&gt;pcell_loc
comma
id|d-&gt;mod_index
comma
id|PA_VIEW
comma
op_amp
id|pa_pdc_cell
)paren
suffix:semicolon
id|pa_count
op_assign
id|pa_pdc_cell.mod
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef DONT_NEED_THIS_FOR_ASTRO
id|status
op_or_assign
id|pdc_pat_cell_module
c_func
(paren
op_amp
id|pdc_result
comma
id|d-&gt;pcell_loc
comma
id|d-&gt;mod_index
comma
id|IO_VIEW
comma
op_amp
id|io_pdc_cell
)paren
suffix:semicolon
id|io_count
op_assign
id|io_pdc_cell.mod
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* We&squot;ve already done this once for device discovery...*/
r_if
c_cond
(paren
id|status
op_ne
id|PDC_RET_OK
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;pdc_pat_cell_module() call failed for LBA!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PAT_GET_ENTITY
c_func
(paren
id|pa_pdc_cell.mod_info
)paren
op_ne
id|PAT_ENTITY_LBA
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;pdc_pat_cell_module() entity returned != PAT_ENTITY_LBA!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Inspect the resources PAT tells us about&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pa_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
(brace
r_int
r_int
id|type
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
multiline_comment|/* aka finish */
)brace
op_star
id|p
suffix:semicolon
r_struct
id|resource
op_star
id|r
suffix:semicolon
id|p
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|pa_pdc_cell.mod
(braket
l_int|2
op_plus
id|i
op_star
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* Convert the PAT range data to PCI &quot;struct resource&quot; */
r_switch
c_cond
(paren
id|p-&gt;type
op_amp
l_int|0xff
)paren
(brace
r_case
id|PAT_PBNUM
suffix:colon
id|lba_dev-&gt;hba.bus_num.start
op_assign
id|p-&gt;start
suffix:semicolon
id|lba_dev-&gt;hba.bus_num.end
op_assign
id|p-&gt;end
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_LMMIO
suffix:colon
multiline_comment|/* used to fix up pre-initialized MEM BARs */
id|lba_dev-&gt;lmmio_base
op_assign
id|p-&gt;start
suffix:semicolon
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.mem_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA LMMIO&quot;
suffix:semicolon
id|r-&gt;start
op_assign
id|p-&gt;start
suffix:semicolon
id|r-&gt;end
op_assign
id|p-&gt;end
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|r-&gt;parent
op_assign
id|r-&gt;sibling
op_assign
id|r-&gt;child
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_GMMIO
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot; range[%d] : ignoring GMMIO (0x%lx)&bslash;n&quot;
comma
id|i
comma
id|p-&gt;start
)paren
suffix:semicolon
id|lba_dev-&gt;gmmio_base
op_assign
id|p-&gt;start
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_NPIOP
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot; range[%d] : ignoring NPIOP (0x%lx)&bslash;n&quot;
comma
id|i
comma
id|p-&gt;start
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_PIOP
suffix:colon
multiline_comment|/*&n;&t;&t;&t;** Postable I/O port space is per PCI host adapter.&n;&t;&t;&t;*/
multiline_comment|/* save base of 64MB PIOP region */
id|lba_dev-&gt;iop_base
op_assign
id|p-&gt;start
suffix:semicolon
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.io_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA I/O Port&quot;
suffix:semicolon
id|r-&gt;start
op_assign
id|lba_dev-&gt;hba.hba_num
op_lshift
l_int|16
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
op_plus
l_int|0xffffUL
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
id|r-&gt;parent
op_assign
id|r-&gt;sibling
op_assign
id|r-&gt;child
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot; range[%d] : unknown pat range type (0x%lx)&bslash;n&quot;
comma
id|i
comma
id|p-&gt;type
op_amp
l_int|0xff
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;/* __LP64__ */
r_static
r_void
DECL|function|lba_legacy_resources
id|lba_legacy_resources
c_func
(paren
r_struct
id|hp_device
op_star
id|d
comma
r_struct
id|lba_device
op_star
id|lba_dev
)paren
(brace
r_int
id|lba_num
suffix:semicolon
r_struct
id|resource
op_star
id|r
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/*&n;&t;** Used to sign extend instead BAR values are only 32-bit.&n;&t;** 64-bit BARs have the upper 32-bit&squot;s zero&squot;d by firmware.&n;&t;** &quot;Sprockets&quot; PDC initializes for 32-bit OS.&n;&t;*/
id|lba_dev-&gt;lmmio_base
op_assign
l_int|0xffffffff00000000UL
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** With &quot;legacy&quot; firmware, the lowest byte of FW_SCRATCH&n;&t;** represents bus-&gt;secondary and the second byte represents&n;&t;** bus-&gt;subsidiary (i.e. highest PPB programmed by firmware).&n;&t;** PCI bus walk *should* end up with the same result.&n;&t;** FIXME: But we don&squot;t have sanity checks in PCI or LBA.&n;&t;*/
id|lba_num
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hpa
op_plus
id|LBA_FW_SCRATCH
)paren
suffix:semicolon
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.bus_num
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA PCI Busses&quot;
suffix:semicolon
id|r-&gt;start
op_assign
id|lba_num
op_amp
l_int|0xff
suffix:semicolon
id|r-&gt;end
op_assign
(paren
id|lba_num
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* Set up local PCI Bus resources - we don&squot;t really need&n;&t;** them for Legacy boxes but it&squot;s nice to see in /proc.&n;&t;*/
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.mem_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA PCI LMMIO&quot;
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|r-&gt;start
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hpa
op_plus
id|LBA_LMMIO_BASE
)paren
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
op_plus
op_complement
(paren
id|READ_REG32
c_func
(paren
id|d-&gt;hpa
op_plus
id|LBA_LMMIO_MASK
)paren
)paren
suffix:semicolon
id|r
op_assign
op_amp
(paren
id|lba_dev-&gt;hba.io_space
)paren
suffix:semicolon
id|r-&gt;name
op_assign
l_string|&quot;LBA PCI I/O Ports&quot;
suffix:semicolon
id|r-&gt;flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
id|r-&gt;start
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hpa
op_plus
id|LBA_IOS_BASE
)paren
suffix:semicolon
id|r-&gt;end
op_assign
id|r-&gt;start
op_plus
(paren
id|READ_REG32
c_func
(paren
id|d-&gt;hpa
op_plus
id|LBA_IOS_MASK
)paren
op_xor
l_int|0xffff
)paren
suffix:semicolon
id|lba_num
op_assign
id|lba_dev-&gt;hba.hba_num
op_lshift
l_int|16
suffix:semicolon
id|r-&gt;start
op_or_assign
id|lba_num
suffix:semicolon
id|r-&gt;end
op_or_assign
id|lba_num
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n;**&n;**   LBA initialization code (HW and SW)&n;**&n;**   o identify LBA chip itself&n;**   o initialize LBA chip modes (HardFail)&n;**   o FIXME: initialize DMA hints for reasonable defaults&n;**   o enable configuration functions&n;**   o call pci_register_ops() to discover devs (fixup/fixup_bus get invoked)&n;**&n;**************************************************************************/
r_static
r_void
DECL|function|lba_hw_init
id|lba_hw_init
c_func
(paren
r_struct
id|lba_device
op_star
id|d
)paren
(brace
id|u32
id|stat
suffix:semicolon
multiline_comment|/* Set HF mode as the default (vs. -1 mode). */
id|stat
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hba.base_addr
op_plus
id|LBA_STAT_CTL
)paren
suffix:semicolon
id|WRITE_REG32
c_func
(paren
id|stat
op_or
id|HF_ENABLE
comma
id|d-&gt;hba.base_addr
op_plus
id|LBA_STAT_CTL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** FIXME: Hint registers are programmed with default hint&n;&t;** values by firmware. Hints should be sane even if we&n;&t;** can&squot;t reprogram them the way drivers want.&n;&t;*/
)brace
r_static
r_void
DECL|function|lba_common_init
id|lba_common_init
c_func
(paren
r_struct
id|lba_device
op_star
id|lba_dev
)paren
(brace
id|pci_bios
op_assign
op_amp
id|lba_bios_ops
suffix:semicolon
id|pcibios_register_hba
c_func
(paren
(paren
r_struct
id|pci_hba_data
op_star
)paren
id|lba_dev
)paren
suffix:semicolon
id|lba_dev-&gt;lba_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n;&t;** Set flags which depend on hw_rev&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|LBA_TR4PLUS
c_func
(paren
id|lba_dev
)paren
)paren
(brace
id|lba_dev-&gt;flags
op_or_assign
id|LBA_FLAG_NO_DMA_DURING_CFG
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** Determine if lba should claim this chip (return 0) or not (return 1).&n;** If so, initialize the chip and tell other partners in crime they&n;** have work to do.&n;*/
r_static
id|__init
r_int
DECL|function|lba_driver_callback
id|lba_driver_callback
c_func
(paren
r_struct
id|hp_device
op_star
id|d
comma
r_struct
id|pa_iodc_driver
op_star
id|dri
)paren
(brace
r_struct
id|lba_device
op_star
id|lba_dev
suffix:semicolon
r_struct
id|pci_bus
op_star
id|lba_bus
suffix:semicolon
id|u32
id|func_class
suffix:semicolon
r_void
op_star
id|tmp_obj
suffix:semicolon
multiline_comment|/* from drivers/pci/setup-bus.c */
r_extern
r_void
id|__init
id|pbus_set_ranges
c_func
(paren
r_struct
id|pci_bus
op_star
comma
r_struct
id|pbus_set_ranges_data
op_star
)paren
suffix:semicolon
multiline_comment|/* Read HW Rev First */
id|func_class
op_assign
id|READ_REG32
c_func
(paren
id|d-&gt;hpa
op_plus
id|LBA_FCLASS
)paren
suffix:semicolon
id|func_class
op_and_assign
l_int|0xf
suffix:semicolon
r_switch
c_cond
(paren
id|func_class
)paren
(brace
r_case
l_int|0
suffix:colon
id|dri-&gt;version
op_assign
l_string|&quot;TR1.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dri-&gt;version
op_assign
l_string|&quot;TR2.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|dri-&gt;version
op_assign
l_string|&quot;TR2.1&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|dri-&gt;version
op_assign
l_string|&quot;TR2.2&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|dri-&gt;version
op_assign
l_string|&quot;TR3.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|dri-&gt;version
op_assign
l_string|&quot;TR4.0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dri-&gt;version
op_assign
l_string|&quot;TR4+&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s version %s (0x%x) found at 0x%p&bslash;n&quot;
comma
id|dri-&gt;name
comma
id|dri-&gt;version
comma
id|func_class
op_amp
l_int|0xf
comma
id|d-&gt;hpa
)paren
suffix:semicolon
multiline_comment|/* Just in case we find some prototypes... */
r_if
c_cond
(paren
id|func_class
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t support LBA older than TR2.1 &quot;
l_string|&quot;- continuing under adversity.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Tell I/O SAPIC driver we have a IRQ handler/region.&n;&t;*/
id|tmp_obj
op_assign
id|iosapic_register
c_func
(paren
id|d-&gt;hpa
op_plus
id|LBA_IOSAPIC_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|tmp_obj
)paren
(brace
multiline_comment|/* iosapic may have failed. But more likely the&n;&t;&t;** slot isn&squot;t occupied and thus has no IRT entries.&n;&t;&t;** iosapic_register looks for this iosapic in the IRT&n;&t;&t;** before bothering to allocating data structures&n;&t;&t;** we don&squot;t need.&n;&t;&t;*/
id|DBG
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: iosapic_register says not used&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|lba_dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lba_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|lba_dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lba_init_chip - couldn&squot;t alloc lba_device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|lba_dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lba_device
)paren
)paren
suffix:semicolon
multiline_comment|/* ---------- First : initialize data we already have --------- */
multiline_comment|/*&n;&t;** Need hw_rev to adjust configuration space behavior.&n;&t;** LBA_TR4PLUS macro uses hw_rev field.&n;&t;*/
id|lba_dev-&gt;hw_rev
op_assign
id|func_class
suffix:semicolon
id|lba_dev-&gt;hba.base_addr
op_assign
id|d-&gt;hpa
suffix:semicolon
multiline_comment|/* faster access */
id|lba_dev-&gt;iosapic_obj
op_assign
id|tmp_obj
suffix:semicolon
multiline_comment|/* save interrupt handle */
multiline_comment|/* ------------ Second : initialize common stuff ---------- */
id|lba_common_init
c_func
(paren
id|lba_dev
)paren
suffix:semicolon
id|lba_hw_init
c_func
(paren
id|lba_dev
)paren
suffix:semicolon
multiline_comment|/* ---------- Third : setup I/O Port and MMIO resources  --------- */
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|pdc_pat
)paren
(brace
multiline_comment|/* PDC PAT firmware uses PIOP region of GMMIO space. */
id|pci_port
op_assign
op_amp
id|lba_pat_port_ops
suffix:semicolon
multiline_comment|/* Go ask PDC PAT what resources this LBA has */
id|lba_pat_resources
c_func
(paren
id|d
comma
id|lba_dev
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#endif
multiline_comment|/* Sprockets PDC uses NPIOP region */
id|pci_port
op_assign
op_amp
id|lba_astro_port_ops
suffix:semicolon
multiline_comment|/* Poke the chip a bit for /proc output */
id|lba_legacy_resources
c_func
(paren
id|d
comma
id|lba_dev
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
)brace
macro_line|#endif
multiline_comment|/* &n;&t;** Tell PCI support another PCI bus was found.&n;&t;** Walks PCI bus for us too.&n;&t;*/
id|lba_bus
op_assign
id|lba_dev-&gt;hba.hba_bus
op_assign
id|pci_scan_bus
c_func
(paren
id|lba_dev-&gt;hba.bus_num.start
comma
op_amp
id|lba_cfg_ops
comma
(paren
r_void
op_star
)paren
id|lba_dev
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|pdc_pat
)paren
(brace
multiline_comment|/* determine window sizes needed by PCI-PCI bridges */
id|DBG_PAT
c_func
(paren
l_string|&quot;LBA pcibios_size_bridge()&bslash;n&quot;
)paren
suffix:semicolon
id|pcibios_size_bridge
c_func
(paren
id|lba_bus
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* assign resources to un-initialized devices */
id|DBG_PAT
c_func
(paren
l_string|&quot;LBA pcibios_assign_unassigned_resources()&bslash;n&quot;
)paren
suffix:semicolon
id|pcibios_assign_unassigned_resources
c_func
(paren
id|lba_bus
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_LBA_PAT
id|DBG_PAT
c_func
(paren
l_string|&quot;&bslash;nLBA PIOP resource tree&bslash;n&quot;
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|lba_dev-&gt;hba.io_space
comma
l_int|2
)paren
suffix:semicolon
id|DBG_PAT
c_func
(paren
l_string|&quot;&bslash;nLBA LMMIO resource tree&bslash;n&quot;
)paren
suffix:semicolon
id|lba_dump_res
c_func
(paren
op_amp
id|lba_dev-&gt;hba.mem_space
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* program *all* PCI-PCI bridge range registers */
id|DBG_PAT
c_func
(paren
l_string|&quot;LBA pbus_set_ranges()&bslash;n&quot;
)paren
suffix:semicolon
id|pbus_set_ranges
c_func
(paren
id|lba_bus
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif /* __LP64__ */
multiline_comment|/*&n;&t;** Once PCI register ops has walked the bus, access to config&n;&t;** space is restricted. Avoids master aborts on config cycles.&n;&t;** Early LBA revs go fatal on *any* master abort.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|LBA_TR4PLUS
c_func
(paren
id|lba_dev
)paren
)paren
(brace
id|lba_dev-&gt;flags
op_or_assign
id|LBA_FLAG_SKIP_PROBE
suffix:semicolon
)brace
multiline_comment|/* Whew! Finally done! Tell services we got this one covered. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Initialize the IBASE/IMASK registers for LBA (Elroy).&n;** Only called from sba_iommu.c initialization sequence.&n;*/
DECL|function|lba_init_iregs
r_void
id|lba_init_iregs
c_func
(paren
r_void
op_star
id|sba_hpa
comma
id|u32
id|ibase
comma
id|u32
id|imask
)paren
(brace
r_extern
r_struct
id|pci_hba_data
op_star
id|hba_list
suffix:semicolon
multiline_comment|/* arch/parisc/kernel/pci.c */
r_struct
id|pci_hba_data
op_star
id|lba
suffix:semicolon
id|imask
op_lshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* adjust for hints - 2 more bits */
id|ASSERT
c_func
(paren
(paren
id|ibase
op_amp
l_int|0x003fffff
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|imask
op_amp
l_int|0x003fffff
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME: sba_hpa is intended to search some table to&n;&t;**      determine which LBA&squot;s belong to the caller&squot;s SBA.&n;&t;** IS_ASTRO: just assume only one SBA for now.&n;&t;*/
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|hba_list
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s() ibase 0x%x imask 0x%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ibase
comma
id|imask
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lba
op_assign
id|hba_list
suffix:semicolon
l_int|NULL
op_ne
id|lba
suffix:semicolon
id|lba
op_assign
id|lba-&gt;next
)paren
(brace
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s() base_addr %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|lba-&gt;base_addr
)paren
suffix:semicolon
id|WRITE_REG32
c_func
(paren
id|imask
comma
id|lba-&gt;base_addr
op_plus
id|LBA_IMASK
)paren
suffix:semicolon
id|WRITE_REG32
c_func
(paren
id|ibase
comma
id|lba-&gt;base_addr
op_plus
id|LBA_IBASE
)paren
suffix:semicolon
)brace
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s() done&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
eof
