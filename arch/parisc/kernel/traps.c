multiline_comment|/*&n; *  linux/arch/parisc/traps.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *  Copyright (C) 1999, 2000  Philipp Rumpf &lt;prumpf@tux.org&gt;&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;asm.s&squot;.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#ifdef CONFIG_KWDB
macro_line|#include &lt;kdb/break.h&gt;&t;&t;/* for BI2_KGDB_GDB */
macro_line|#include &lt;kdb/kgdb_types.h&gt;&t;/* for __() */
macro_line|#include &lt;kdb/save_state.h&gt;&t;/* for struct save_state */
macro_line|#include &lt;kdb/kgdb_machine.h&gt;&t;/* for pt_regs_to_ssp and ssp_to_pt_regs */
macro_line|#include &lt;kdb/trap.h&gt;&t;&t;/* for I_BRK_INST */
macro_line|#endif /* CONFIG_KWDB */
DECL|function|console_verbose
r_static
r_inline
r_void
id|console_verbose
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|console_loglevel
suffix:semicolon
id|console_loglevel
op_assign
l_int|15
suffix:semicolon
)brace
r_void
id|page_exception
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments.  VMALLOC_OFFSET comes from mm/vmalloc.c; MODULE_RANGE is&n; * a guess of how much space is likely to be vmalloced.&n; */
DECL|macro|VMALLOC_OFFSET
mdefine_line|#define VMALLOC_OFFSET (8*1024*1024)
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
DECL|variable|kstack_depth_to_print
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
DECL|function|printbinary
r_static
r_void
id|printbinary
c_func
(paren
r_int
r_int
id|x
comma
r_int
id|nbits
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1UL
op_lshift
(paren
id|nbits
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|mask
op_amp
id|x
ques
c_cond
l_string|&quot;1&quot;
suffix:colon
l_string|&quot;0&quot;
)paren
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|macro|RFMT
mdefine_line|#define RFMT &quot; %016lx&quot;
macro_line|#else
mdefine_line|#define RFMT &quot; %08lx&quot;
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* don&squot;t want to have that pretty register dump messed up */
id|printk
c_func
(paren
l_string|&quot;     YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI&bslash;nPSW: &quot;
)paren
suffix:semicolon
id|printbinary
c_func
(paren
id|regs-&gt;gr
(braket
l_int|0
)braket
comma
l_int|32
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_int
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r%d-%d&bslash;t&quot;
comma
id|i
comma
id|i
op_plus
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
c_func
(paren
id|RFMT
comma
id|i
op_plus
id|j
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
id|regs-&gt;gr
(braket
id|i
op_plus
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_int
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sr%d-%d&bslash;t&quot;
comma
id|i
comma
id|i
op_plus
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
c_func
(paren
id|RFMT
comma
id|regs-&gt;sr
(braket
id|i
op_plus
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if REDICULOUSLY_VERBOSE
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FR%2d : %016lx  &quot;
comma
id|i
comma
id|regs-&gt;fr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|1
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;nIASQ:&quot;
id|RFMT
id|RFMT
l_string|&quot; IAOQ:&quot;
id|RFMT
id|RFMT
l_string|&quot;&bslash;n&quot;
comma
id|regs-&gt;iasq
(braket
l_int|0
)braket
comma
id|regs-&gt;iasq
(braket
l_int|1
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; IIR: %08lx    ISR:&quot;
id|RFMT
l_string|&quot;  IOR:&quot;
id|RFMT
l_string|&quot;&bslash;nORIG_R28:&quot;
id|RFMT
l_string|&quot;&bslash;n&quot;
comma
id|regs-&gt;iir
comma
id|regs-&gt;isr
comma
id|regs-&gt;ior
comma
id|regs-&gt;orig_r28
)paren
suffix:semicolon
)brace
r_void
DECL|function|die_if_kernel
id|die_if_kernel
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
macro_line|#if 1
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* STFU */
multiline_comment|/* XXX for debugging only */
id|printk
(paren
l_string|&quot;!!die_if_kernel: %s(%d): %s %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s[%d]: %s %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Wot&squot;s wrong wif bein&squot; racy? */
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|PARISC_KERNEL_DEATH
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;die_if_kernel recursion detected.&bslash;n&quot;
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|current-&gt;thread.flags
op_or_assign
id|PARISC_KERNEL_DEATH
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|cache_flush_denied
id|asmlinkage
r_void
id|cache_flush_denied
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
)brace
DECL|function|do_general_protection
id|asmlinkage
r_void
id|do_general_protection
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
)brace
macro_line|#ifndef CONFIG_MATH_EMULATION
DECL|function|math_emulate
id|asmlinkage
r_void
id|math_emulate
c_func
(paren
r_int
id|arg
)paren
(brace
)brace
macro_line|#endif /* CONFIG_MATH_EMULATION */
DECL|function|syscall_ipi
r_int
id|syscall_ipi
c_func
(paren
r_int
(paren
op_star
id|syscall
)paren
(paren
r_struct
id|pt_regs
op_star
)paren
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|syscall
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_struct
(brace
DECL|member|retval
r_int
id|retval
suffix:semicolon
DECL|member|func
r_int
(paren
op_star
id|func
)paren
(paren
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|variable|ipi_action
)brace
id|ipi_action
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|function|ipi_interrupt
r_void
id|ipi_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|unused
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ipi_action
(braket
id|cpu
)braket
dot
id|func
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ipi_action
(braket
id|cpu
)braket
dot
id|retval
op_assign
id|ipi_action
(braket
id|cpu
)braket
dot
id|func
c_func
(paren
id|ipi_action
(braket
id|cpu
)braket
dot
id|data
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* gdb uses break 4,8 */
DECL|macro|GDB_BREAK_INSN
mdefine_line|#define GDB_BREAK_INSN 0x10004
DECL|function|handle_gdb_break
r_void
id|handle_gdb_break
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|wot
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
id|si.si_code
op_assign
id|wot
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|handle_break
r_void
id|handle_break
c_func
(paren
r_int
id|iir
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
macro_line|#ifdef CONFIG_KWDB
r_struct
id|save_state
id|ssp
suffix:semicolon
macro_line|#endif /* CONFIG_KWDB */   
id|flush_all_caches
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|iir
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* show registers, halt */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;break 0,0: pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Breakpoint&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|si.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_BREAK_INSN
suffix:colon
id|die_if_kernel
c_func
(paren
l_string|&quot;Breakpoint&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_BRKPT
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_KWDB
r_case
id|KGDB_BREAK_INSN
suffix:colon
id|mtctl
c_func
(paren
l_int|0
comma
l_int|15
)paren
suffix:semicolon
id|pt_regs_to_ssp
c_func
(paren
id|regs
comma
op_amp
id|ssp
)paren
suffix:semicolon
id|kgdb_trap
c_func
(paren
id|I_BRK_INST
comma
op_amp
id|ssp
comma
l_int|1
)paren
suffix:semicolon
id|ssp_to_pt_regs
c_func
(paren
op_amp
id|ssp
comma
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KGDB_INIT_BREAK_INSN
suffix:colon
id|mtctl
c_func
(paren
l_int|0
comma
l_int|15
)paren
suffix:semicolon
id|pt_regs_to_ssp
c_func
(paren
id|regs
comma
op_amp
id|ssp
)paren
suffix:semicolon
id|kgdb_trap
c_func
(paren
id|I_BRK_INST
comma
op_amp
id|ssp
comma
l_int|1
)paren
suffix:semicolon
id|ssp_to_pt_regs
c_func
(paren
op_amp
id|ssp
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* Advance pcoq to skip break */
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
id|regs-&gt;iaoq
(braket
l_int|1
)braket
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_add_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_KWDB */
r_default
suffix:colon
id|set_eiem
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;break %#08x: pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|iir
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|si.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Format of the floating-point exception registers. */
DECL|struct|exc_reg
r_struct
id|exc_reg
(brace
DECL|member|exception
r_int
r_int
id|exception
suffix:colon
l_int|6
suffix:semicolon
DECL|member|ei
r_int
r_int
id|ei
suffix:colon
l_int|26
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Macros for grabbing bits of the instruction format from the &squot;ei&squot;&n;   field above. */
multiline_comment|/* Major opcode 0c and 0e */
DECL|macro|FP0CE_UID
mdefine_line|#define FP0CE_UID(i) (((i) &gt;&gt; 6) &amp; 3)
DECL|macro|FP0CE_CLASS
mdefine_line|#define FP0CE_CLASS(i) (((i) &gt;&gt; 9) &amp; 3)
DECL|macro|FP0CE_SUBOP
mdefine_line|#define FP0CE_SUBOP(i) (((i) &gt;&gt; 13) &amp; 7)
DECL|macro|FP0CE_SUBOP1
mdefine_line|#define FP0CE_SUBOP1(i) (((i) &gt;&gt; 15) &amp; 7) /* Class 1 subopcode */
DECL|macro|FP0C_FORMAT
mdefine_line|#define FP0C_FORMAT(i) (((i) &gt;&gt; 11) &amp; 3)
DECL|macro|FP0E_FORMAT
mdefine_line|#define FP0E_FORMAT(i) (((i) &gt;&gt; 11) &amp; 1)
multiline_comment|/* Major opcode 0c, uid 2 (performance monitoring) */
DECL|macro|FPPM_SUBOP
mdefine_line|#define FPPM_SUBOP(i) (((i) &gt;&gt; 9) &amp; 0x1f)
multiline_comment|/* Major opcode 2e (fused operations).   */
DECL|macro|FP2E_SUBOP
mdefine_line|#define FP2E_SUBOP(i)  (((i) &gt;&gt; 5) &amp; 1)
DECL|macro|FP2E_FORMAT
mdefine_line|#define FP2E_FORMAT(i) (((i) &gt;&gt; 11) &amp; 1)
multiline_comment|/* Major opcode 26 (FMPYSUB) */
multiline_comment|/* Major opcode 06 (FMPYADD) */
DECL|macro|FPx6_FORMAT
mdefine_line|#define FPx6_FORMAT(i) ((i) &amp; 0x1f)
multiline_comment|/* Flags and enable bits of the status word. */
DECL|macro|FPSW_FLAGS
mdefine_line|#define FPSW_FLAGS(w) ((w) &gt;&gt; 27)
DECL|macro|FPSW_ENABLE
mdefine_line|#define FPSW_ENABLE(w) ((w) &amp; 0x1f)
DECL|macro|FPSW_V
mdefine_line|#define FPSW_V (1&lt;&lt;4)
DECL|macro|FPSW_Z
mdefine_line|#define FPSW_Z (1&lt;&lt;3)
DECL|macro|FPSW_O
mdefine_line|#define FPSW_O (1&lt;&lt;2)
DECL|macro|FPSW_U
mdefine_line|#define FPSW_U (1&lt;&lt;1)
DECL|macro|FPSW_I
mdefine_line|#define FPSW_I (1&lt;&lt;0)
multiline_comment|/* Emulate a floating point instruction if necessary and possible&n;   (this will be moved elsewhere eventually).  Return zero if&n;   successful or if emulation was not required, -1 if the instruction&n;   is actually illegal or unimplemented.  The status word passed as&n;   the first parameter will be modified to signal exceptions, if&n;   any. */
multiline_comment|/* FIXME!!!  This is really incomplete and, at the moment, most&n;   illegal FP instructions will simply act as no-ops.  Obviously that&n;   is *not* what we want.  Also we don&squot;t even try to handle exception&n;   types other than the &squot;unimplemented&squot; ones. */
r_int
DECL|function|fp_emul_insn
id|fp_emul_insn
c_func
(paren
id|u32
op_star
id|sw
comma
r_struct
id|exc_reg
id|exc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_switch
c_cond
(paren
id|exc.exception
)paren
(brace
r_case
l_int|0x3
suffix:colon
multiline_comment|/* Unimplemented, opcode 06 */
r_break
suffix:semicolon
r_case
l_int|0x9
suffix:colon
multiline_comment|/* Unimplemented, opcode 0c */
multiline_comment|/* We do not support quadword operations, end of&n;                   story.  There&squot;s no support for them in GCC. */
r_if
c_cond
(paren
id|FP0C_FORMAT
c_func
(paren
id|exc.ei
)paren
op_eq
l_int|3
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* SIGILL */
multiline_comment|/* Fall through. */
r_case
l_int|0xa
suffix:colon
multiline_comment|/* Unimplemented, opcode 0e */
r_if
c_cond
(paren
id|FP0CE_CLASS
c_func
(paren
id|exc.ei
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* FCNV instructions of various sorts. */
)brace
r_else
(brace
r_if
c_cond
(paren
id|FP0CE_CLASS
c_func
(paren
id|exc.ei
op_eq
l_int|0
)paren
op_logical_and
id|FP0CE_SUBOP
c_func
(paren
id|exc.ei
op_eq
l_int|5
)paren
)paren
(brace
multiline_comment|/* FRND instructions should be&n;                                   emulated, at some point, I&n;                                   guess. */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* SIGILL */
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|0x23
suffix:colon
multiline_comment|/* Unimplemented, opcode 26 */
r_break
suffix:semicolon
r_case
l_int|0x2b
suffix:colon
multiline_comment|/* Unimplemented, opcode 2e */
r_break
suffix:semicolon
r_case
l_int|0x1
suffix:colon
multiline_comment|/* Unimplemented, opcode 0e/0c */
multiline_comment|/* FIXME: How the hell are we supposed to tell which&n;                   opcode it is? */
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Punt */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Handle a floating point exception.  Return zero if the faulting&n;   instruction can be completed successfully. */
r_int
DECL|function|handle_fpe
id|handle_fpe
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
r_union
(brace
r_struct
id|fpsw
(brace
multiline_comment|/* flag bits */
r_int
r_int
id|fv
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|fz
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|fo
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|fu
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|fi
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|c
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|pad1
suffix:colon
l_int|4
suffix:semicolon
r_int
r_int
id|cq
suffix:colon
l_int|11
suffix:semicolon
r_int
r_int
id|rm
suffix:colon
l_int|2
suffix:semicolon
r_int
r_int
id|pad2
suffix:colon
l_int|2
suffix:semicolon
r_int
r_int
id|t
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|d
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* enable bits */
r_int
r_int
id|ev
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|ez
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|eo
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|eu
suffix:colon
l_int|1
suffix:semicolon
r_int
r_int
id|ei
suffix:colon
l_int|1
suffix:semicolon
)brace
id|status
suffix:semicolon
id|u32
id|word
suffix:semicolon
)brace
id|sw
suffix:semicolon
r_struct
id|exc_reg
id|excepts
(braket
l_int|7
)braket
suffix:semicolon
r_int
r_int
id|code
op_assign
l_int|0
suffix:semicolon
r_int
r_int
r_throw
suffix:semicolon
multiline_comment|/* Status word = FR0L. */
id|memcpy
c_func
(paren
op_amp
id|sw
comma
id|regs-&gt;fr
comma
r_sizeof
(paren
id|sw
)paren
)paren
suffix:semicolon
multiline_comment|/* Exception words = FR0R-FR3R. */
id|memcpy
c_func
(paren
id|excepts
comma
(paren
(paren
r_char
op_star
)paren
id|regs-&gt;fr
)paren
op_plus
l_int|4
comma
r_sizeof
(paren
id|excepts
)paren
)paren
suffix:semicolon
multiline_comment|/* This is all CPU dependent.  Since there is no public&n;           documentation on the PA2.0 processors we will just assume&n;           everything is like the 7100/7100LC/7300LC for now.&n;&n;&t;   Specifically: All exceptions are marked as &quot;unimplemented&quot;&n;&t;   in the exception word, and the only exception word used is&n;&t;   excepts[1]. */
multiline_comment|/* Try to emulate the instruction.  Also determine if it is&n;           really an illegal instruction in the process.&n;&n;&t;   FIXME: fp_emul_insn() only checks for the &quot;unimplemented&quot;&n;&t;   exceptions at the moment.  So this may break horribly on&n;&t;   PA2.0, where we may want to also check to see if we should&n;&t;   just send SIGFPE (or maybe not, let&squot;s see the documentation&n;&t;   first...) */
r_if
c_cond
(paren
id|fp_emul_insn
c_func
(paren
op_amp
id|sw.word
comma
id|excepts
(braket
l_int|1
)braket
comma
id|regs
)paren
op_eq
op_minus
l_int|1
)paren
r_goto
id|send_sigill
suffix:semicolon
multiline_comment|/* Take the intersection of the flag bits in the FPSW and the&n;           enable bits in the FPSW. */
r_throw
op_assign
id|FPSW_FLAGS
c_func
(paren
id|sw.word
)paren
op_amp
id|FPSW_ENABLE
c_func
(paren
id|sw.word
)paren
suffix:semicolon
multiline_comment|/* Concoct an appropriate si_code.  Of course we don&squot;t know&n;           what to do if multiple exceptions were enabled and multiple&n;           flags were set.  Maybe that&squot;s why HP/UX doesn&squot;t implement&n;           feenableexcept(). */
r_if
c_cond
(paren
r_throw
op_eq
l_int|0
)paren
r_goto
id|success
suffix:semicolon
multiline_comment|/* Duh. */
r_else
r_if
c_cond
(paren
r_throw
op_amp
id|FPSW_V
)paren
id|code
op_assign
id|FPE_FLTINV
suffix:semicolon
r_else
r_if
c_cond
(paren
r_throw
op_amp
id|FPSW_Z
)paren
id|code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_else
r_if
c_cond
(paren
r_throw
op_amp
id|FPSW_O
)paren
id|code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_else
r_if
c_cond
(paren
r_throw
op_amp
id|FPSW_U
)paren
id|code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_else
r_if
c_cond
(paren
r_throw
op_amp
id|FPSW_I
)paren
id|code
op_assign
id|FPE_FLTRES
suffix:semicolon
macro_line|#if 1 /* Debugging... */
id|printk
c_func
(paren
l_string|&quot;Unemulated floating point exception, pid=%d (%s)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;FP Status: %08x&bslash;n&quot;
comma
id|sw.word
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;FP Exceptions:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tExcept%d: exception %03x insn %06x&bslash;n&quot;
comma
id|i
comma
id|excepts
(braket
id|i
)braket
dot
id|exception
comma
id|excepts
(braket
id|i
)braket
dot
id|ei
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* FIXME: Should we clear the flag bits, T bit, and exception&n;           registers here? */
id|si.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|code
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|send_sigill
suffix:colon
id|si.si_signo
op_assign
id|SIGILL
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|ILL_COPROC
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGILL
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|success
suffix:colon
multiline_comment|/* We absolutely have to clear the T bit and exception&n;           registers to allow the process to recover.  Otherwise every&n;           subsequent floating point instruction will trap. */
id|sw.status.t
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|excepts
comma
l_int|0
comma
r_sizeof
(paren
id|excepts
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|regs-&gt;fr
comma
op_amp
id|sw
comma
r_sizeof
(paren
id|sw
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|regs-&gt;fr
)paren
op_plus
l_int|4
comma
id|excepts
comma
r_sizeof
(paren
id|excepts
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_toc
r_int
id|handle_toc
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|default_trap
r_void
id|default_trap
c_func
(paren
r_int
id|code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trap %d on CPU %d&bslash;n&quot;
comma
id|code
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
DECL|variable|cpu_lpmc
r_void
(paren
op_star
id|cpu_lpmc
)paren
(paren
r_int
id|code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
op_assign
id|default_trap
suffix:semicolon
macro_line|#ifdef CONFIG_KWDB
r_int
DECL|function|debug_call
id|debug_call
(paren
r_void
)paren
(brace
id|printk
(paren
l_string|&quot;Debug call.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|debug_call_leaf
id|debug_call_leaf
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KWDB */
r_extern
r_void
id|do_page_fault
c_func
(paren
r_struct
id|pt_regs
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|parisc_terminate
c_func
(paren
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|transfer_pim_to_trap_frame
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_void
id|pdc_console_restart
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|handle_interruption
r_void
id|handle_interruption
c_func
(paren
r_int
id|code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|fault_address
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|fault_space
op_assign
l_int|0
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
macro_line|#ifdef CONFIG_KWDB
r_struct
id|save_state
id|ssp
suffix:semicolon
macro_line|#endif /* CONFIG_KWDB */   
r_if
c_cond
(paren
id|code
op_eq
l_int|1
)paren
id|pdc_console_restart
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* switch back to pdc if HPMC */
r_else
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/*&n;&t; * FIXME:&n;&t; * For 32 bit processes we don&squot;t want the b bits (bits 0 &amp; 1)&n;&t; * in the ior. This is more appropriately handled in the tlb&n;&t; * miss handlers. Changes need to be made to support addresses&n;&t; * &gt;32 bits for 64 bit processes.&n;&t; */
id|regs-&gt;ior
op_and_assign
l_int|0x3FFFFFFFFFFFFFFFUL
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;interrupted with code %d, regs %p&bslash;n&quot;
comma
id|code
comma
id|regs
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
l_int|1
suffix:colon
id|parisc_terminate
c_func
(paren
l_string|&quot;High Priority Machine Check (HPMC)&quot;
comma
id|regs
comma
id|code
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOT REACHED */
r_case
l_int|3
suffix:colon
multiline_comment|/* Recovery counter trap */
id|regs-&gt;gr
(braket
l_int|0
)braket
op_and_assign
op_complement
id|PSW_R
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;iasq
(braket
l_int|0
)braket
)paren
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_TRACE
)paren
suffix:semicolon
multiline_comment|/* else this must be the start of a syscall - just let it&n;&t;&t; * run.&n;&t;&t; */
r_return
suffix:semicolon
r_case
l_int|5
suffix:colon
id|flush_all_caches
c_func
(paren
)paren
suffix:semicolon
id|cpu_lpmc
c_func
(paren
l_int|5
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|6
suffix:colon
id|fault_address
op_assign
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|fault_space
op_assign
id|regs-&gt;iasq
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
multiline_comment|/* Break Instruction */
id|handle_break
c_func
(paren
id|regs-&gt;iir
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* Assist Exception Trap, i.e. floating point exception. */
id|die_if_kernel
c_func
(paren
l_string|&quot;Floating point exception&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* quiet */
id|handle_fpe
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|15
suffix:colon
r_case
l_int|16
suffix:colon
multiline_comment|/* Non-Access TLB miss faulting address is in IOR */
r_case
l_int|17
suffix:colon
r_case
l_int|26
suffix:colon
id|fault_address
op_assign
id|regs-&gt;ior
suffix:semicolon
id|fault_space
op_assign
id|regs-&gt;isr
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
l_int|26
op_logical_and
id|fault_space
op_eq
l_int|0
)paren
id|parisc_terminate
c_func
(paren
l_string|&quot;Data access rights fault in kernel&quot;
comma
id|regs
comma
id|code
comma
id|fault_address
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19
suffix:colon
id|regs-&gt;gr
(braket
l_int|0
)braket
op_or_assign
id|PSW_X
suffix:semicolon
multiline_comment|/* So we can single-step over the trap */
multiline_comment|/* fall thru */
r_case
l_int|21
suffix:colon
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_HWBKPT
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|25
suffix:colon
multiline_comment|/* Taken branch trap */
id|regs-&gt;gr
(braket
l_int|0
)braket
op_and_assign
op_complement
id|PSW_T
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;iasq
(braket
l_int|0
)braket
)paren
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_BRANCH
)paren
suffix:semicolon
multiline_comment|/* else this must be the start of a syscall - just let it&n;&t;&t; * run.&n;&t;&t; */
r_return
suffix:semicolon
macro_line|#if 0 /* def CONFIG_KWDB */
r_case
id|I_TAKEN_BR
suffix:colon
multiline_comment|/* 25 */
id|mtctl
c_func
(paren
l_int|0
comma
l_int|15
)paren
suffix:semicolon
id|pt_regs_to_ssp
c_func
(paren
id|regs
comma
op_amp
id|ssp
)paren
suffix:semicolon
id|kgdb_trap
c_func
(paren
id|I_TAKEN_BR
comma
op_amp
id|ssp
comma
l_int|1
)paren
suffix:semicolon
id|ssp_to_pt_regs
c_func
(paren
op_amp
id|ssp
comma
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_KWDB */
r_case
l_int|8
suffix:colon
id|die_if_kernel
c_func
(paren
l_string|&quot;Illegal instruction&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|ILL_ILLOPC
suffix:semicolon
r_goto
id|give_sigill
suffix:semicolon
r_case
l_int|10
suffix:colon
id|die_if_kernel
c_func
(paren
l_string|&quot;Priviledged operation - shouldn&squot;t happen!&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|ILL_PRVOPC
suffix:semicolon
r_goto
id|give_sigill
suffix:semicolon
r_case
l_int|11
suffix:colon
id|die_if_kernel
c_func
(paren
l_string|&quot;Priviledged register - shouldn&squot;t happen!&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|ILL_PRVREG
suffix:semicolon
id|give_sigill
suffix:colon
id|si.si_signo
op_assign
id|SIGILL
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGILL
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|28
suffix:colon
multiline_comment|/* Unaligned just causes SIGBUS for now */
id|die_if_kernel
c_func
(paren
l_string|&quot;Unaligned data reference&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|BUS_ADRALN
suffix:semicolon
id|si.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;ior
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nhandle_interruption() pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* SIGBUS, for lack of a better one. */
id|si.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|si.si_code
op_assign
id|BUS_OBJERR
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;ior
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|parisc_terminate
c_func
(paren
l_string|&quot;Unexpected Interruption!&quot;
comma
id|regs
comma
id|code
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOT REACHED */
)brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_if
c_cond
(paren
id|fault_space
op_ne
id|regs-&gt;sr
(braket
l_int|7
)braket
)paren
(brace
r_if
c_cond
(paren
id|fault_space
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;User Fault on Kernel Space &quot;
)paren
suffix:semicolon
r_else
multiline_comment|/* this case should never happen, but whatever... */
id|printk
c_func
(paren
l_string|&quot;User Fault (long pointer) &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGSEGV
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|SEGV_MAPERR
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;ior
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGSEGV
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;     * The kernel should never fault on its own address space.&n;&t;     */
r_if
c_cond
(paren
id|fault_space
op_eq
l_int|0
)paren
id|parisc_terminate
c_func
(paren
l_string|&quot;Kernel Fault&quot;
comma
id|regs
comma
id|code
comma
id|fault_address
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KWDB
id|debug_call_leaf
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_KWDB */
id|do_page_fault
c_func
(paren
id|regs
comma
id|code
comma
id|fault_address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This should not be necessary.&n;&t; * However, we do not currently&n;&t; * implement flush_page_to_ram.&n;&t; *&n;&t; * The problem is that if we just&n;&t; * brought in some code through the&n;&t; * D-cache, the I-cache may not see&n;&t; * it since it hasn&squot;t been flushed&n;&t; * to ram.&n;&t; */
multiline_comment|/* &t;flush_all_caches(); */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;returning %p&bslash;n&quot;
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&t;show_regs(regs); */
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
macro_line|#if 1
r_if
c_cond
(paren
(paren
id|sp
op_amp
l_int|0xc0000000UL
)paren
op_eq
l_int|0xc0000000UL
)paren
(brace
id|__u32
op_star
id|stackptr
suffix:semicolon
id|__u32
op_star
id|dumpptr
suffix:semicolon
multiline_comment|/* Stack Dump! */
id|stackptr
op_assign
(paren
id|__u32
op_star
)paren
id|sp
suffix:semicolon
id|dumpptr
op_assign
(paren
id|__u32
op_star
)paren
(paren
id|sp
op_amp
op_complement
(paren
id|INIT_TASK_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nDumping Stack from %p to %p:&bslash;n&quot;
comma
id|dumpptr
comma
id|stackptr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dumpptr
OL
id|stackptr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%04x %08x %08x %08x %08x %08x %08x %08x %08x&bslash;n&quot;
comma
(paren
(paren
id|__u32
)paren
id|dumpptr
)paren
op_amp
l_int|0xffff
comma
id|dumpptr
(braket
l_int|0
)braket
comma
id|dumpptr
(braket
l_int|1
)braket
comma
id|dumpptr
(braket
l_int|2
)braket
comma
id|dumpptr
(braket
l_int|3
)braket
comma
id|dumpptr
(braket
l_int|4
)braket
comma
id|dumpptr
(braket
l_int|5
)braket
comma
id|dumpptr
(braket
l_int|6
)braket
comma
id|dumpptr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|dumpptr
op_add_assign
l_int|8
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
DECL|function|parisc_terminate
r_void
id|parisc_terminate
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|code
comma
r_int
r_int
id|offset
)paren
(brace
id|set_eiem
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
l_int|1
)paren
id|transfer_pim_to_trap_frame
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#if 1
id|show_stack
c_func
(paren
id|regs-&gt;gr
(braket
l_int|30
)braket
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s: Code=%d regs=%p (Addr=%08lx)&bslash;n&quot;
comma
id|msg
comma
id|code
comma
id|regs
comma
id|offset
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|transfer_pim_to_trap_frame
r_void
id|transfer_pim_to_trap_frame
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_register
r_int
id|i
suffix:semicolon
r_extern
r_int
r_int
id|hpmc_pim_data
(braket
)braket
suffix:semicolon
r_struct
id|pdc_hpmc_pim_11
op_star
id|pim_narrow
suffix:semicolon
r_struct
id|pdc_hpmc_pim_20
op_star
id|pim_wide
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpu_data.cpu_type
op_ge
id|pcxu
)paren
(brace
id|pim_wide
op_assign
(paren
r_struct
id|pdc_hpmc_pim_20
op_star
)paren
id|hpmc_pim_data
suffix:semicolon
multiline_comment|/*&n;&t; * Note: The following code will probably generate a&n;&t; * bunch of truncation error warnings from the compiler.&n;&t; * Could be handled with an ifdef, but perhaps there&n;&t; * is a better way.&n;&t; */
id|regs-&gt;gr
(braket
l_int|0
)braket
op_assign
id|pim_wide-&gt;cr
(braket
l_int|22
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;gr
(braket
id|i
)braket
op_assign
id|pim_wide-&gt;gr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;fr
(braket
id|i
)braket
op_assign
id|pim_wide-&gt;fr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;sr
(braket
id|i
)braket
op_assign
id|pim_wide-&gt;sr
(braket
id|i
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_assign
id|pim_wide-&gt;cr
(braket
l_int|17
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|1
)braket
op_assign
id|pim_wide-&gt;iasq_back
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
id|pim_wide-&gt;cr
(braket
l_int|18
)braket
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_assign
id|pim_wide-&gt;iaoq_back
suffix:semicolon
id|regs-&gt;cr30
op_assign
id|pim_wide-&gt;cr
(braket
l_int|30
)braket
suffix:semicolon
id|regs-&gt;sar
op_assign
id|pim_wide-&gt;cr
(braket
l_int|11
)braket
suffix:semicolon
id|regs-&gt;iir
op_assign
id|pim_wide-&gt;cr
(braket
l_int|19
)braket
suffix:semicolon
id|regs-&gt;isr
op_assign
id|pim_wide-&gt;cr
(braket
l_int|20
)braket
suffix:semicolon
id|regs-&gt;ior
op_assign
id|pim_wide-&gt;cr
(braket
l_int|21
)braket
suffix:semicolon
)brace
r_else
(brace
id|pim_narrow
op_assign
(paren
r_struct
id|pdc_hpmc_pim_11
op_star
)paren
id|hpmc_pim_data
suffix:semicolon
id|regs-&gt;gr
(braket
l_int|0
)braket
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|22
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;gr
(braket
id|i
)braket
op_assign
id|pim_narrow-&gt;gr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;fr
(braket
id|i
)braket
op_assign
id|pim_narrow-&gt;fr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;sr
(braket
id|i
)braket
op_assign
id|pim_narrow-&gt;sr
(braket
id|i
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|17
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|1
)braket
op_assign
id|pim_narrow-&gt;iasq_back
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|18
)braket
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_assign
id|pim_narrow-&gt;iaoq_back
suffix:semicolon
id|regs-&gt;cr30
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|30
)braket
suffix:semicolon
id|regs-&gt;sar
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|11
)braket
suffix:semicolon
id|regs-&gt;iir
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|19
)braket
suffix:semicolon
id|regs-&gt;isr
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|20
)braket
suffix:semicolon
id|regs-&gt;ior
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|21
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;     * The following fields only have meaning if we came through&n;     * another path. So just zero them here.&n;     */
id|regs-&gt;ksp
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;kpc
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;orig_r28
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|check_ivt
r_int
id|__init
id|check_ivt
c_func
(paren
r_void
op_star
id|iva
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|check
op_assign
l_int|0
suffix:semicolon
id|u32
op_star
id|ivap
suffix:semicolon
id|u32
op_star
id|hpmcp
suffix:semicolon
id|u32
id|length
suffix:semicolon
r_extern
r_void
id|os_hpmc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|os_hpmc_end
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|iva
comma
l_string|&quot;cows can fly&quot;
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ivap
op_assign
(paren
id|u32
op_star
)paren
id|iva
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
op_star
id|ivap
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute Checksum for HPMC handler */
id|length
op_assign
(paren
id|u32
)paren
(paren
(paren
r_int
r_int
)paren
id|os_hpmc_end
op_minus
(paren
r_int
r_int
)paren
id|os_hpmc
)paren
suffix:semicolon
id|ivap
(braket
l_int|7
)braket
op_assign
id|length
suffix:semicolon
id|hpmcp
op_assign
(paren
id|u32
op_star
)paren
id|os_hpmc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
op_div
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|check
op_add_assign
op_star
id|hpmcp
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|check
op_add_assign
id|ivap
(braket
id|i
)braket
suffix:semicolon
)brace
id|ivap
(braket
l_int|5
)braket
op_assign
op_minus
id|check
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef __LP64__
r_extern
r_const
r_void
id|fault_vector_11
suffix:semicolon
macro_line|#endif
r_extern
r_const
r_void
id|fault_vector_20
suffix:semicolon
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
id|eiem
suffix:semicolon
r_void
op_star
id|iva
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;trap_init&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpu_data.cpu_type
op_ge
id|pcxu
)paren
id|iva
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fault_vector_20
suffix:semicolon
r_else
macro_line|#ifdef __LP64__
id|panic
c_func
(paren
l_string|&quot;Can&squot;t boot 64-bit OS on PA1.1 processor!&quot;
)paren
suffix:semicolon
macro_line|#else
id|iva
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fault_vector_11
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|check_ivt
c_func
(paren
id|iva
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;IVT invalid&quot;
)paren
suffix:semicolon
)brace
id|mtctl
c_func
(paren
l_int|0
comma
l_int|30
)paren
suffix:semicolon
id|mtctl
c_func
(paren
l_int|90000000
comma
l_int|16
)paren
suffix:semicolon
id|set_eiem
c_func
(paren
op_minus
l_int|1L
)paren
suffix:semicolon
id|mtctl
c_func
(paren
op_minus
l_int|1L
comma
l_int|23
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;rsm 0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|eiem
)paren
)paren
suffix:semicolon
)brace
eof
