multiline_comment|/*&n; * Kernel support for the ptrace() and syscall tracing interfaces.&n; *&n; * Copyright (C) 2000 Hewlett-Packard Co, Linuxcare Inc.&n; * Copyright (C) 2000 Matthew Wilcox &lt;matthew@wil.cx&gt;&n; * Copyright (C) 2000 David Huggins-Daines &lt;dhd@debian.org&gt;&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/offset.h&gt;
multiline_comment|/* These are used in entry.S, syscall_restore_rfi.  We need to record the&n; * current stepping mode somewhere other than in PSW, because there is no&n; * concept of saving and restoring the users PSW over a syscall.  We choose&n; * to use these two bits in task-&gt;ptrace.  These bits must not clash with&n; * any PT_* defined in include/linux/sched.h, and must match with the bit&n; * tests in entry.S&n; */
DECL|macro|PT_SINGLESTEP
mdefine_line|#define PT_SINGLESTEP&t;0x10000
DECL|macro|PT_BLOCKSTEP
mdefine_line|#define PT_BLOCKSTEP&t;0x20000
DECL|function|sys_ptrace
r_int
id|sys_ptrace
c_func
(paren
r_int
id|request
comma
id|pid_t
id|pid
comma
r_int
id|addr
comma
r_int
id|data
)paren
(brace
r_struct
id|task_struct
op_star
id|child
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|request
op_eq
id|PTRACE_TRACEME
)paren
(brace
multiline_comment|/* are we already being traced? */
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* set the ptrace bit in the process flags. */
id|current-&gt;ptrace
op_or_assign
id|PT_PTRACED
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|child
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|child
)paren
id|get_task_struct
c_func
(paren
id|child
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_eq
l_int|1
)paren
multiline_comment|/* no messing around with init! */
r_goto
id|out_tsk
suffix:semicolon
r_if
c_cond
(paren
id|request
op_eq
id|PTRACE_ATTACH
)paren
(brace
r_if
c_cond
(paren
id|child
op_eq
id|current
)paren
r_goto
id|out_tsk
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|child-&gt;dumpable
op_logical_or
(paren
id|current-&gt;uid
op_ne
id|child-&gt;euid
)paren
op_logical_or
(paren
id|current-&gt;uid
op_ne
id|child-&gt;suid
)paren
op_logical_or
(paren
id|current-&gt;uid
op_ne
id|child-&gt;uid
)paren
op_logical_or
(paren
id|current-&gt;gid
op_ne
id|child-&gt;egid
)paren
op_logical_or
(paren
id|current-&gt;gid
op_ne
id|child-&gt;sgid
)paren
op_logical_or
(paren
op_logical_neg
id|cap_issubset
c_func
(paren
id|child-&gt;cap_permitted
comma
id|current-&gt;cap_permitted
)paren
)paren
op_logical_or
(paren
id|current-&gt;gid
op_ne
id|child-&gt;gid
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_PTRACE
)paren
)paren
r_goto
id|out_tsk
suffix:semicolon
multiline_comment|/* the same process cannot be attached many times */
r_if
c_cond
(paren
id|child-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
r_goto
id|out_tsk
suffix:semicolon
id|child-&gt;ptrace
op_or_assign
id|PT_PTRACED
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;p_pptr
op_ne
id|current
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tasklist_lock
comma
id|flags
)paren
suffix:semicolon
id|REMOVE_LINKS
c_func
(paren
id|child
)paren
suffix:semicolon
id|child-&gt;p_pptr
op_assign
id|current
suffix:semicolon
id|SET_LINKS
c_func
(paren
id|child
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tasklist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|send_sig
c_func
(paren
id|SIGSTOP
comma
id|child
comma
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_tsk
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|child-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
)paren
r_goto
id|out_tsk
suffix:semicolon
r_if
c_cond
(paren
id|child-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
r_if
c_cond
(paren
id|request
op_ne
id|PTRACE_KILL
)paren
r_goto
id|out_tsk
suffix:semicolon
)brace
r_if
c_cond
(paren
id|child-&gt;p_pptr
op_ne
id|current
)paren
r_goto
id|out_tsk
suffix:semicolon
r_switch
c_cond
(paren
id|request
)paren
(brace
r_case
id|PTRACE_PEEKTEXT
suffix:colon
multiline_comment|/* read word at location addr. */
r_case
id|PTRACE_PEEKDATA
suffix:colon
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_int
id|copied
suffix:semicolon
id|copied
op_assign
id|access_process_vm
c_func
(paren
id|child
comma
id|addr
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_ne
r_sizeof
(paren
id|tmp
)paren
)paren
r_goto
id|out_tsk
suffix:semicolon
id|ret
op_assign
id|put_user
c_func
(paren
id|tmp
comma
(paren
r_int
r_int
op_star
)paren
id|data
)paren
suffix:semicolon
r_goto
id|out_tsk
suffix:semicolon
)brace
multiline_comment|/* when I and D space are separate, this will have to be fixed. */
r_case
id|PTRACE_POKETEXT
suffix:colon
multiline_comment|/* write the word at location addr. */
r_case
id|PTRACE_POKEDATA
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|access_process_vm
c_func
(paren
id|child
comma
id|addr
comma
op_amp
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
l_int|1
)paren
op_eq
r_sizeof
(paren
id|data
)paren
)paren
r_goto
id|out_tsk
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_tsk
suffix:semicolon
multiline_comment|/* Read the word at location addr in the USER area.  This will need&n;&t;   to change when the kernel no longer saves all regs on a syscall. */
r_case
id|PTRACE_PEEKUSR
suffix:colon
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
l_int|3
)paren
op_logical_or
(paren
r_int
r_int
)paren
id|addr
op_ge
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
r_goto
id|out_tsk
suffix:semicolon
id|tmp
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|task_regs
c_func
(paren
id|child
)paren
op_plus
id|addr
)paren
suffix:semicolon
id|ret
op_assign
id|put_user
c_func
(paren
id|tmp
comma
(paren
r_int
r_int
op_star
)paren
id|data
)paren
suffix:semicolon
r_goto
id|out_tsk
suffix:semicolon
)brace
multiline_comment|/* Write the word at location addr in the USER area.  This will need&n;&t;   to change when the kernel no longer saves all regs on a syscall.&n;&t;   FIXME.  There is a problem at the moment in that r3-r18 are only&n;&t;   saved if the process is ptraced on syscall entry, and even then&n;&t;   those values are overwritten by actual register values on syscall&n;&t;   exit. */
r_case
id|PTRACE_POKEUSR
suffix:colon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
l_int|3
)paren
op_logical_or
(paren
r_int
r_int
)paren
id|addr
op_ge
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
r_goto
id|out_tsk
suffix:semicolon
multiline_comment|/* XXX This test probably needs adjusting.  We probably want to&n;&t;&t; * allow writes to some bits of PSW, and may want to block writes&n;&t;&t; * to (some) space registers.  Some register values written here&n;&t;&t; * may be ignored in entry.S:syscall_restore_rfi; e.g. iaoq is&n;&t;&t; * written with r31/r31+4, and not with the values in pt_regs.&n;&t;&t; */
multiline_comment|/* Allow writing of gr1-gr31, fr*, sr*, iasq*, iaoq*, sar */
r_if
c_cond
(paren
id|addr
op_eq
id|PT_PSW
op_logical_or
(paren
id|addr
OG
id|PT_IAOQ1
op_logical_and
id|addr
op_ne
id|PT_SAR
)paren
)paren
r_goto
id|out_tsk
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|task_regs
c_func
(paren
id|child
)paren
op_plus
id|addr
)paren
op_assign
id|data
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_tsk
suffix:semicolon
r_case
id|PTRACE_SYSCALL
suffix:colon
multiline_comment|/* continue and stop at next (return from) syscall */
r_case
id|PTRACE_CONT
suffix:colon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|data
OG
id|_NSIG
)paren
r_goto
id|out_tsk
suffix:semicolon
id|child-&gt;ptrace
op_and_assign
op_complement
(paren
id|PT_SINGLESTEP
op_or
id|PT_BLOCKSTEP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request
op_eq
id|PTRACE_SYSCALL
)paren
id|child-&gt;ptrace
op_or_assign
id|PT_TRACESYS
suffix:semicolon
r_else
id|child-&gt;ptrace
op_and_assign
op_complement
id|PT_TRACESYS
suffix:semicolon
id|child-&gt;exit_code
op_assign
id|data
suffix:semicolon
r_goto
id|out_wake_notrap
suffix:semicolon
r_case
id|PTRACE_KILL
suffix:colon
multiline_comment|/*&n;&t;&t; * make the child exit.  Best I can do is send it a&n;&t;&t; * sigkill.  perhaps it should be put in the status&n;&t;&t; * that it wants to exit.&n;&t;&t; */
r_if
c_cond
(paren
id|child-&gt;state
op_eq
id|TASK_ZOMBIE
)paren
multiline_comment|/* already dead */
r_goto
id|out_tsk
suffix:semicolon
id|child-&gt;exit_code
op_assign
id|SIGKILL
suffix:semicolon
r_goto
id|out_wake_notrap
suffix:semicolon
r_case
id|PTRACE_SINGLEBLOCK
suffix:colon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|data
OG
id|_NSIG
)paren
r_goto
id|out_tsk
suffix:semicolon
id|child-&gt;ptrace
op_and_assign
op_complement
(paren
id|PT_TRACESYS
op_or
id|PT_SINGLESTEP
)paren
suffix:semicolon
id|child-&gt;ptrace
op_or_assign
id|PT_BLOCKSTEP
suffix:semicolon
id|child-&gt;exit_code
op_assign
id|data
suffix:semicolon
multiline_comment|/* Enable taken branch trap. */
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|r
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|t
op_assign
l_int|1
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|h
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|l
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_wake
suffix:semicolon
r_case
id|PTRACE_SINGLESTEP
suffix:colon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|data
OG
id|_NSIG
)paren
r_goto
id|out_tsk
suffix:semicolon
id|child-&gt;ptrace
op_and_assign
op_complement
(paren
id|PT_TRACESYS
op_or
id|PT_BLOCKSTEP
)paren
suffix:semicolon
id|child-&gt;ptrace
op_or_assign
id|PT_SINGLESTEP
suffix:semicolon
id|child-&gt;exit_code
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|n
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
multiline_comment|/* Nullified, just crank over the queue. */
id|task_regs
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|iaoq
(braket
l_int|0
)braket
op_assign
id|task_regs
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|iaoq
(braket
l_int|1
)braket
suffix:semicolon
id|task_regs
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|iasq
(braket
l_int|0
)braket
op_assign
id|task_regs
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|iasq
(braket
l_int|1
)braket
suffix:semicolon
id|task_regs
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|iaoq
(braket
l_int|1
)braket
op_assign
id|task_regs
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|iaoq
(braket
l_int|0
)braket
op_plus
l_int|4
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|n
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|x
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|y
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|z
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|b
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|r
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|t
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|h
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|l
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t wake up the child, but let the&n;&t;&t;&t;   parent know something happened. */
id|si.si_code
op_assign
id|TRAP_TRACE
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|task_regs
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|iaoq
(braket
l_int|0
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|si
comma
id|child
)paren
suffix:semicolon
singleline_comment|//notify_parent(child, SIGCHLD);
singleline_comment|//ret = 0;
r_goto
id|out_wake
suffix:semicolon
)brace
multiline_comment|/* Enable recovery counter traps.  The recovery counter&n;&t;&t; * itself will be set to zero on a task switch.  If the&n;&t;&t; * task is suspended on a syscall then the syscall return&n;&t;&t; * path will overwrite the recovery counter with a suitable&n;&t;&t; * value such that it traps once back in user space.  We&n;&t;&t; * disable interrupts in the childs PSW here also, to avoid&n;&t;&t; * interrupts while the recovery counter is decrementing.&n;&t;&t; */
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|r
op_assign
l_int|1
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|t
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|h
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|l
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* give it a chance to run. */
r_goto
id|out_wake
suffix:semicolon
r_case
id|PTRACE_DETACH
suffix:colon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|data
OG
id|_NSIG
)paren
r_goto
id|out_tsk
suffix:semicolon
id|child-&gt;ptrace
op_and_assign
op_complement
(paren
id|PT_PTRACED
op_or
id|PT_TRACESYS
op_or
id|PT_SINGLESTEP
op_or
id|PT_BLOCKSTEP
)paren
suffix:semicolon
id|child-&gt;exit_code
op_assign
id|data
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|REMOVE_LINKS
c_func
(paren
id|child
)paren
suffix:semicolon
id|child-&gt;p_pptr
op_assign
id|child-&gt;p_opptr
suffix:semicolon
id|SET_LINKS
c_func
(paren
id|child
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_goto
id|out_wake_notrap
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_tsk
suffix:semicolon
)brace
id|out_wake_notrap
suffix:colon
multiline_comment|/* make sure the trap bits are not set */
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|r
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|t
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|h
op_assign
l_int|0
suffix:semicolon
id|pa_psw
c_func
(paren
id|child
)paren
op_member_access_from_pointer
id|l
op_assign
l_int|0
suffix:semicolon
id|out_wake
suffix:colon
id|wake_up_process
c_func
(paren
id|child
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out_tsk
suffix:colon
id|free_task_struct
c_func
(paren
id|child
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|syscall_trace
r_void
id|syscall_trace
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|current-&gt;ptrace
op_amp
(paren
id|PT_PTRACED
op_or
id|PT_TRACESYS
)paren
)paren
op_ne
(paren
id|PT_PTRACED
op_or
id|PT_TRACESYS
)paren
)paren
r_return
suffix:semicolon
id|current-&gt;exit_code
op_assign
id|SIGTRAP
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_STOPPED
suffix:semicolon
id|notify_parent
c_func
(paren
id|current
comma
id|SIGCHLD
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * this isn&squot;t the same as continuing with a signal, but it will do&n;&t; * for normal use.  strace only continues with a signal if the&n;&t; * stopping signal is not SIGTRAP.  -brl&n;&t; */
r_if
c_cond
(paren
id|current-&gt;exit_code
)paren
(brace
id|send_sig
c_func
(paren
id|current-&gt;exit_code
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
id|current-&gt;exit_code
op_assign
l_int|0
suffix:semicolon
)brace
)brace
eof
