multiline_comment|/* $Id: pci.c,v 1.6 2000/01/29 00:12:05 grundler Exp $&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1997, 1998 Ralf Baechle&n; * Copyright (C) 1999 SuSE GmbH&n; * Copyright (C) 1999 Hewlett-Packard Company&n; * Copyright (C) 1999, 2000 Grant Grundler&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;&t;&t;/* for __init and __devinit */
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;&t;/* for memcpy() */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#ifdef CONFIG_PCI
DECL|macro|DEBUG_RESOURCES
macro_line|#undef DEBUG_RESOURCES
macro_line|#ifdef DEBUG_RESOURCES
DECL|macro|DBG_RES
mdefine_line|#define DBG_RES(x...)&t;printk(x)
macro_line|#else
DECL|macro|DBG_RES
mdefine_line|#define DBG_RES(x...)
macro_line|#endif
multiline_comment|/* To be used as: mdelay(pci_post_reset_delay);&n;**&n;** post_reset is the time the kernel should stall to prevent anyone from&n;** accessing the PCI bus once #RESET is de-asserted. &n;** PCI spec somewhere says 1 second but with multi-PCI bus systems,&n;** this makes the boot time much longer than necessary.&n;** 20ms seems to work for all the HP PCI implementations to date.&n;*/
DECL|variable|pci_post_reset_delay
r_int
id|pci_post_reset_delay
op_assign
l_int|50
suffix:semicolon
DECL|variable|pci_port
r_struct
id|pci_port_ops
op_star
id|pci_port
suffix:semicolon
DECL|variable|pci_bios
r_struct
id|pci_bios_ops
op_star
id|pci_bios
suffix:semicolon
DECL|variable|hba_list
r_struct
id|pci_hba_data
op_star
id|hba_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|hba_count
r_int
id|hba_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;** parisc_pci_hba used by pci_port-&gt;in/out() ops to lookup bus data.&n;*/
DECL|macro|PCI_HBA_MAX
mdefine_line|#define PCI_HBA_MAX 32
DECL|variable|parisc_pci_hba
r_static
r_struct
id|pci_hba_data
op_star
id|parisc_pci_hba
(braket
id|PCI_HBA_MAX
)braket
suffix:semicolon
multiline_comment|/********************************************************************&n;**&n;** I/O port space support&n;**&n;*********************************************************************/
DECL|macro|PCI_PORT_HBA
mdefine_line|#define PCI_PORT_HBA(a) ((a)&gt;&gt;16)
DECL|macro|PCI_PORT_ADDR
mdefine_line|#define PCI_PORT_ADDR(a) ((a) &amp; 0xffffUL)
multiline_comment|/* KLUGE : inb needs to be defined differently for PCI devices than&n;** for other bus interfaces. Doing this at runtime sucks but is the&n;** only way one driver binary can support devices on different bus types.&n;**&n;*/
DECL|macro|PCI_PORT_IN
mdefine_line|#define PCI_PORT_IN(type, size) &bslash;&n;u##size in##type (int addr) &bslash;&n;{ &bslash;&n;&t;int b = PCI_PORT_HBA(addr); &bslash;&n;&t;u##size d = (u##size) -1; &bslash;&n;&t;ASSERT(pci_port); /* make sure services are defined */ &bslash;&n;&t;ASSERT(parisc_pci_hba[b]); /* make sure ioaddr are &quot;fixed up&quot; */ &bslash;&n;&t;if (parisc_pci_hba[b] == NULL) { &bslash;&n;&t;&t;printk(KERN_WARNING &quot;&bslash;nPCI Host Bus Adapter %d not registered. in&quot; #size &quot;(0x%x) returning -1&bslash;n&quot;, b, addr); &bslash;&n;&t;} else { &bslash;&n;&t;&t;d = pci_port-&gt;in##type(parisc_pci_hba[b], PCI_PORT_ADDR(addr)); &bslash;&n;&t;} &bslash;&n;&t;return d; &bslash;&n;}
id|PCI_PORT_IN
c_func
(paren
id|b
comma
l_int|8
)paren
id|PCI_PORT_IN
c_func
(paren
id|w
comma
l_int|16
)paren
id|PCI_PORT_IN
c_func
(paren
id|l
comma
l_int|32
)paren
DECL|macro|PCI_PORT_OUT
mdefine_line|#define PCI_PORT_OUT(type, size) &bslash;&n;void out##type (u##size d, int addr) &bslash;&n;{ &bslash;&n;&t;int b = PCI_PORT_HBA(addr); &bslash;&n;&t;ASSERT(pci_port); &bslash;&n;&t;pci_port-&gt;out##type(parisc_pci_hba[b], PCI_PORT_ADDR(addr), d); &bslash;&n;}
id|PCI_PORT_OUT
c_func
(paren
id|b
comma
l_int|8
)paren
id|PCI_PORT_OUT
c_func
(paren
id|w
comma
l_int|16
)paren
id|PCI_PORT_OUT
c_func
(paren
id|l
comma
l_int|32
)paren
multiline_comment|/*&n; * BIOS32 replacement.&n; */
DECL|function|pcibios_init
r_void
id|pcibios_init
c_func
(paren
r_void
)paren
(brace
id|ASSERT
c_func
(paren
id|pci_bios
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_bios
)paren
(brace
r_if
c_cond
(paren
id|pci_bios-&gt;init
)paren
(brace
(paren
op_star
id|pci_bios-&gt;init
)paren
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pci_bios != NULL but init() is!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Called from pci_do_scan_bus() *after* walking a bus but before walking PPBs. */
DECL|function|pcibios_fixup_bus
r_void
id|pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
id|ASSERT
c_func
(paren
id|pci_bios
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* If this is a bridge, get the current bases */
r_if
c_cond
(paren
id|bus-&gt;self
)paren
(brace
id|pci_read_bridge_bases
c_func
(paren
id|bus
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_bios
)paren
(brace
r_if
c_cond
(paren
id|pci_bios-&gt;fixup_bus
)paren
(brace
(paren
op_star
id|pci_bios-&gt;fixup_bus
)paren
(paren
id|bus
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pci_bios != NULL but fixup_bus() is!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|pcibios_setup
r_char
op_star
id|pcibios_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|str
suffix:semicolon
)brace
macro_line|#endif /* defined(CONFIG_PCI) */
multiline_comment|/* -------------------------------------------------------------------&n;** linux-2.4: NEW STUFF &n;** --------------------&n;*/
multiline_comment|/*&n;** Used in drivers/pci/quirks.c&n;*/
DECL|variable|pcibios_fixups
r_struct
id|pci_fixup
id|pcibios_fixups
(braket
)braket
op_assign
(brace
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n;** called by drivers/pci/setup.c:pdev_fixup_irq()&n;*/
DECL|function|pcibios_update_irq
r_void
id|__devinit
id|pcibios_update_irq
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|irq
)paren
(brace
multiline_comment|/*&n;** updates IRQ_LINE cfg register to reflect PCI-PCI bridge skewing.&n;**&n;** Calling path for Alpha is:&n;**  alpha/kernel/pci.c:common_init_pci(swizzle_func, pci_map_irq_func )&n;**&t;drivers/pci/setup.c:pci_fixup_irqs()&n;**&t;    drivers/pci/setup.c:pci_fixup_irq()&t;(for each PCI device)&n;**&t;&t;invoke swizzle and map functions&n;**&t;        alpha/kernel/pci.c:pcibios_update_irq()&n;**&n;** Don&squot;t need this for PA legacy PDC systems.&n;**&n;** On PAT PDC systems, We only support one &quot;swizzle&quot; for any number&n;** of PCI-PCI bridges deep. That&squot;s how bit3 PCI expansion chassis&n;** are implemented. The IRQ lines are &quot;skewed&quot; for all devices but&n;** *NOT* routed through the PCI-PCI bridge. Ie any device &quot;0&quot; will&n;** share an IRQ line. Legacy PDC is expecting this IRQ line routing&n;** as well.&n;**&n;** Unfortunately, PCI spec allows the IRQ lines to be routed&n;** around the PCI bridge as long as the IRQ lines are skewed&n;** based on the device number...&lt;sigh&gt;...&n;**&n;** Lastly, dino.c might be able to use pci_fixup_irq() to&n;** support RS-232 and PS/2 children. Not sure how but it&squot;s&n;** something to think about.&n;*/
)brace
multiline_comment|/* ------------------------------------&n;**&n;** Program one BAR in PCI config space.&n;**&n;** ------------------------------------&n;** PAT PDC systems need this routine. PA legacy PDC does not.&n;**&n;** Used by alpha/arm: &n;** alpha/kernel/pci.c:common_init_pci()&n;** (or arm/kernel/pci.c:pcibios_init())&n;**    drivers/pci/setup.c:pci_assign_unassigned_resources()&n;**        drivers/pci/setup.c:pdev_assign_unassigned_resources()&n;**            arch/&lt;foo&gt;/kernel/pci.c:pcibios_update_resource()&n;**&n;** When BAR&squot;s are configured by linux, this routine&n;** will update configuration space with the &quot;normalized&quot;&n;** address. &quot;root&quot; indicates where the range starts and res&n;** is some portion of that range.&n;**&n;** For all PA-RISC systems except V-class, root-&gt;start would be zero.&n;**&n;** PAT PDC can tell us which MMIO ranges are available or already in use.&n;** I/O port space and such are not memory mapped anyway for PA-Risc.&n;*/
r_void
id|__devinit
DECL|function|pcibios_update_resource
id|pcibios_update_resource
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|resource
op_star
id|root
comma
r_struct
id|resource
op_star
id|res
comma
r_int
id|barnum
)paren
(brace
r_int
id|where
suffix:semicolon
id|u32
id|barval
op_assign
l_int|0
suffix:semicolon
id|DBG_RES
c_func
(paren
l_string|&quot;pcibios_update_resource(%s, ..., %d) [%lx,%lx]/%x&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|barnum
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
(paren
r_int
)paren
id|res-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|barnum
op_ge
id|PCI_BRIDGE_RESOURCES
)paren
(brace
multiline_comment|/* handled in pbus_set_ranges_data() */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|barnum
op_eq
id|PCI_ROM_RESOURCE
)paren
(brace
id|where
op_assign
id|PCI_ROM_ADDRESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 0-5  standard PCI &quot;regions&quot; */
id|where
op_assign
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|barnum
op_star
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
(brace
id|barval
op_assign
id|PCI_PORT_ADDR
c_func
(paren
id|res-&gt;start
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
(brace
multiline_comment|/* This should work for VCLASS too */
id|barval
op_assign
id|res-&gt;start
op_amp
l_int|0xffffffffUL
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;pcibios_update_resource() WTF? flags not IO or MEM&quot;
)paren
suffix:semicolon
)brace
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|where
comma
id|barval
)paren
suffix:semicolon
multiline_comment|/* XXX FIXME - Elroy does support 64-bit (dual cycle) addressing.&n;** But at least one device (Symbios 53c896) which has 64-bit BAR&n;** doesn&squot;t actually work right with dual cycle addresses.&n;** So ignore the whole mess for now.&n;*/
r_if
c_cond
(paren
(paren
id|res-&gt;flags
op_amp
(paren
id|PCI_BASE_ADDRESS_SPACE
op_or
id|PCI_BASE_ADDRESS_MEM_TYPE_MASK
)paren
)paren
op_eq
(paren
id|PCI_BASE_ADDRESS_SPACE_MEMORY
op_or
id|PCI_BASE_ADDRESS_MEM_TYPE_64
)paren
)paren
(brace
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|where
op_plus
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI: dev %s type 64-bit&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** Called by pci_set_master() - a driver interface.&n;**&n;** Legacy PDC guarantees to set:&n;**      Map Memory BAR&squot;s into PA IO space.&n;**      Map Expansion ROM BAR into one common PA IO space per bus.&n;**      Map IO BAR&squot;s into PCI IO space.&n;**      Command (see below)&n;**      Cache Line Size&n;**      Latency Timer&n;**      Interrupt Line&n;**&t;PPB: secondary latency timer, io/mmio base/limit,&n;**&t;&t;bus numbers, bridge control&n;**&n;*/
r_void
DECL|function|pcibios_set_master
id|pcibios_set_master
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u8
id|lat
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|lat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lat
op_ge
l_int|16
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;** HP generally has fewer devices on the bus than other architectures.&n;&t;*/
id|printk
c_func
(paren
l_string|&quot;PCIBIOS: Setting latency timer of %s to 128&bslash;n&quot;
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
l_int|0x80
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** called by drivers/pci/setup-res.c:pbus_set_ranges().&n;*/
DECL|function|pcibios_fixup_pbus_ranges
r_void
id|pcibios_fixup_pbus_ranges
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_struct
id|pbus_set_ranges_data
op_star
id|ranges
)paren
(brace
multiline_comment|/*&n;&t;** I/O space may see busnumbers here. Something&n;&t;** in the form of 0xbbxxxx where bb is the bus num&n;&t;** and xxxx is the I/O port space address.&n;&t;** Remaining address translation are done in the&n;&t;** PCI Host adapter specific code - ie dino_out8.&n;&t;*/
id|ranges-&gt;io_start
op_assign
id|PCI_PORT_ADDR
c_func
(paren
id|ranges-&gt;io_start
)paren
suffix:semicolon
id|ranges-&gt;io_end
op_assign
id|PCI_PORT_ADDR
c_func
(paren
id|ranges-&gt;io_end
)paren
suffix:semicolon
id|DBG_RES
c_func
(paren
l_string|&quot;pcibios_fixup_pbus_ranges(%02x, [%lx,%lx %lx,%lx])&bslash;n&quot;
comma
id|bus-&gt;number
comma
id|ranges-&gt;io_start
comma
id|ranges-&gt;io_end
comma
id|ranges-&gt;mem_start
comma
id|ranges-&gt;mem_end
)paren
suffix:semicolon
)brace
DECL|macro|MAX
mdefine_line|#define MAX(val1, val2)   ((val1) &gt; (val2) ? (val1) : (val2))
multiline_comment|/*&n;** pcibios align resources() is called everytime generic PCI code&n;** wants to generate a new address. The process of looking for&n;** an available address, each candidate is first &quot;aligned&quot; and&n;** then checked if the resource is available until a match is found.&n;**&n;** Since we are just checking candidates, don&squot;t use any fields other&n;** than res-&gt;start.&n;*/
r_void
id|__devinit
DECL|function|pcibios_align_resource
id|pcibios_align_resource
c_func
(paren
r_void
op_star
id|data
comma
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|mask
comma
id|align
suffix:semicolon
id|DBG_RES
c_func
(paren
l_string|&quot;pcibios_align_resource(%s, (%p) [%lx,%lx]/%x, 0x%lx)&bslash;n&quot;
comma
(paren
(paren
r_struct
id|pci_dev
op_star
)paren
id|data
)paren
op_member_access_from_pointer
id|slot_name
comma
id|res-&gt;parent
comma
id|res-&gt;start
comma
id|res-&gt;end
comma
(paren
r_int
)paren
id|res-&gt;flags
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* has resource already been aligned/assigned? */
r_if
c_cond
(paren
id|res-&gt;parent
)paren
r_return
suffix:semicolon
multiline_comment|/* If it&squot;s not IO, then it&squot;s gotta be MEM */
id|align
op_assign
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
ques
c_cond
id|PCIBIOS_MIN_IO
suffix:colon
id|PCIBIOS_MIN_MEM
suffix:semicolon
multiline_comment|/* Align to largest of MIN or input size */
id|mask
op_assign
id|MAX
c_func
(paren
id|size
comma
id|align
)paren
op_minus
l_int|1
suffix:semicolon
id|res-&gt;start
op_add_assign
id|mask
suffix:semicolon
id|res-&gt;start
op_and_assign
op_complement
id|mask
suffix:semicolon
multiline_comment|/*&n;&t;** WARNING : caller is expected to update &quot;end&quot; field.&n;&t;** We can&squot;t since it might really represent the *size*.&n;&t;** The difference is &quot;end = start + size&quot; vs &quot;end += size&quot;.&n;&t;*/
)brace
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP(x, a)&t;&t;(((x) + (a) - 1) &amp; ~((a) - 1))
r_void
id|__devinit
DECL|function|pcibios_size_bridge
id|pcibios_size_bridge
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_struct
id|pbus_set_ranges_data
op_star
id|outer
)paren
(brace
r_struct
id|pbus_set_ranges_data
id|inner
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
r_struct
id|pci_dev
op_star
id|bridge
op_assign
id|bus-&gt;self
suffix:semicolon
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
multiline_comment|/* set reasonable default &quot;window&quot; for pcibios_align_resource */
id|inner.io_start
op_assign
id|inner.io_end
op_assign
l_int|0
suffix:semicolon
id|inner.mem_start
op_assign
id|inner.mem_end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Collect information about how our direct children are layed out. */
r_for
c_loop
(paren
id|ln
op_assign
id|bus-&gt;devices.next
suffix:semicolon
id|ln
op_ne
op_amp
id|bus-&gt;devices
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
r_int
id|i
suffix:semicolon
id|dev
op_assign
id|pci_dev_b
c_func
(paren
id|ln
)paren
suffix:semicolon
multiline_comment|/* Skip bridges here - we&squot;ll catch them below */
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_eq
id|PCI_CLASS_BRIDGE_PCI
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_NUM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
id|res
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|flags
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|res
comma
op_amp
id|dev-&gt;resource
(braket
id|i
)braket
comma
r_sizeof
(paren
id|res
)paren
)paren
suffix:semicolon
id|size
op_assign
id|res.end
op_minus
id|res.start
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|res.flags
op_amp
id|IORESOURCE_IO
)paren
(brace
id|res.start
op_assign
id|inner.io_end
suffix:semicolon
id|pcibios_align_resource
c_func
(paren
id|dev
comma
op_amp
id|res
comma
id|size
)paren
suffix:semicolon
id|inner.io_end
op_add_assign
id|res.start
op_plus
id|size
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res.flags
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|res.start
op_assign
id|inner.mem_end
suffix:semicolon
id|pcibios_align_resource
c_func
(paren
id|dev
comma
op_amp
id|res
comma
id|size
)paren
suffix:semicolon
id|inner.mem_end
op_assign
id|res.start
op_plus
id|size
suffix:semicolon
)brace
id|DBG_RES
c_func
(paren
l_string|&quot;    %s  inner size %lx/%x IO %lx MEM %lx&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|size
comma
id|res.flags
comma
id|inner.io_end
comma
id|inner.mem_end
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* And for all of the subordinate busses. */
r_for
c_loop
(paren
id|ln
op_assign
id|bus-&gt;children.next
suffix:semicolon
id|ln
op_ne
op_amp
id|bus-&gt;children
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
id|pcibios_size_bridge
c_func
(paren
id|pci_bus_b
c_func
(paren
id|ln
)paren
comma
op_amp
id|inner
)paren
suffix:semicolon
multiline_comment|/* turn the ending locations into sizes (subtract start) */
id|inner.io_end
op_sub_assign
id|inner.io_start
op_minus
l_int|1
suffix:semicolon
id|inner.mem_end
op_sub_assign
id|inner.mem_start
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Align the sizes up by bridge rules */
id|inner.io_end
op_assign
id|ROUND_UP
c_func
(paren
id|inner.io_end
comma
l_int|4
op_star
l_int|1024
)paren
op_minus
l_int|1
suffix:semicolon
id|inner.mem_end
op_assign
id|ROUND_UP
c_func
(paren
id|inner.mem_end
comma
l_int|1
op_star
l_int|1024
op_star
l_int|1024
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* PPB - PCI bridge Device will normaller also have &quot;outer&quot; != NULL. */
r_if
c_cond
(paren
id|bridge
)paren
(brace
multiline_comment|/* Adjust the bus&squot; allocation requirements */
multiline_comment|/* PPB&squot;s pci device Bridge resources */
id|bus-&gt;resource
(braket
l_int|0
)braket
op_assign
op_amp
id|bridge-&gt;resource
(braket
id|PCI_BRIDGE_RESOURCES
)braket
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|1
)braket
op_assign
op_amp
id|bridge-&gt;resource
(braket
id|PCI_BRIDGE_RESOURCES
op_plus
l_int|1
)braket
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|0
)braket
op_member_access_from_pointer
id|start
op_assign
id|bus-&gt;resource
(braket
l_int|1
)braket
op_member_access_from_pointer
id|start
op_assign
l_int|0
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|0
)braket
op_member_access_from_pointer
id|parent
op_assign
id|bus-&gt;resource
(braket
l_int|1
)braket
op_member_access_from_pointer
id|parent
op_assign
l_int|NULL
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|0
)braket
op_member_access_from_pointer
id|end
op_assign
id|inner.io_end
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|0
)braket
op_member_access_from_pointer
id|flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|1
)braket
op_member_access_from_pointer
id|end
op_assign
id|inner.mem_end
suffix:semicolon
id|bus-&gt;resource
(braket
l_int|1
)braket
op_member_access_from_pointer
id|flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
)brace
multiline_comment|/* adjust parent&squot;s resource requirements */
r_if
c_cond
(paren
id|outer
)paren
(brace
id|outer-&gt;io_end
op_assign
id|ROUND_UP
c_func
(paren
id|outer-&gt;io_end
comma
l_int|4
op_star
l_int|1024
)paren
suffix:semicolon
id|outer-&gt;io_end
op_add_assign
id|inner.io_end
suffix:semicolon
id|outer-&gt;mem_end
op_assign
id|ROUND_UP
c_func
(paren
id|outer-&gt;mem_end
comma
l_int|1
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
id|outer-&gt;mem_end
op_add_assign
id|inner.mem_end
suffix:semicolon
)brace
)brace
DECL|macro|ROUND_UP
macro_line|#undef ROUND_UP
r_int
id|__devinit
DECL|function|pcibios_enable_device
id|pcibios_enable_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u16
id|cmd
comma
id|old_cmd
suffix:semicolon
r_int
id|idx
suffix:semicolon
multiline_comment|/*&n;&t;** The various platform PDC&squot;s (aka &quot;BIOS&quot; for PCs) don&squot;t&n;&t;** enable all the same bits. We just make sure they are here.&n;&t;*/
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|old_cmd
op_assign
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t;** See if any resources have been allocated&n;&t;*/
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|6
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|r
op_assign
op_amp
id|dev-&gt;resource
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** System error and Parity Error reporting are enabled by default.&n;&t;** Devices that do NOT want those behaviors should clear them&n;&t;** (eg PCI graphics, possibly networking).&n;&t;** Interfaces like SCSI certainly should not. We want the&n;&t;** system to crash if a system or parity error is detected.&n;&t;** At least until the device driver can recover from such an error.&n;&t;*/
id|cmd
op_or_assign
(paren
id|PCI_COMMAND_SERR
op_or
id|PCI_COMMAND_PARITY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|old_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCIBIOS: Enabling device %s (%04x -&gt; %04x)&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|old_cmd
comma
id|cmd
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
id|__devinit
DECL|function|pcibios_assign_unassigned_resources
id|pcibios_assign_unassigned_resources
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_struct
id|list_head
op_star
id|ln
suffix:semicolon
r_for
c_loop
(paren
id|ln
op_assign
id|bus-&gt;devices.next
suffix:semicolon
id|ln
op_ne
op_amp
id|bus-&gt;devices
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
(brace
id|pdev_assign_unassigned_resources
c_func
(paren
id|pci_dev_b
c_func
(paren
id|ln
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* And for all of the sub-busses.  */
r_for
c_loop
(paren
id|ln
op_assign
id|bus-&gt;children.next
suffix:semicolon
id|ln
op_ne
op_amp
id|bus-&gt;children
suffix:semicolon
id|ln
op_assign
id|ln-&gt;next
)paren
id|pcibios_assign_unassigned_resources
c_func
(paren
id|pci_bus_b
c_func
(paren
id|ln
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** PARISC specific (unfortunately)&n;*/
DECL|function|pcibios_register_hba
r_void
id|pcibios_register_hba
c_func
(paren
r_struct
id|pci_hba_data
op_star
id|hba
)paren
(brace
id|hba-&gt;next
op_assign
id|hba_list
suffix:semicolon
id|hba_list
op_assign
id|hba
suffix:semicolon
id|ASSERT
c_func
(paren
id|hba_count
OL
id|PCI_HBA_MAX
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** pci_port-&gt;in/out() uses parisc_pci_hba to lookup parameter.&n;&t;*/
id|parisc_pci_hba
(braket
id|hba_count
)braket
op_assign
id|hba
suffix:semicolon
id|hba-&gt;hba_num
op_assign
id|hba_count
op_increment
suffix:semicolon
)brace
eof
