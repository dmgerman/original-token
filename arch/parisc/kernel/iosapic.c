multiline_comment|/*&n;** I/O Sapic Driver - PCI interrupt line support&n;**&n;**      (c) Copyright 1999 Grant Grundler&n;**      (c) Copyright 1999 Hewlett-Packard Company&n;**&n;**      This program is free software; you can redistribute it and/or modify&n;**      it under the terms of the GNU General Public License as published by&n;**      the Free Software Foundation; either version 2 of the License, or&n;**      (at your option) any later version.&n;**&n;** The I/O sapic driver manages the Interrupt Redirection Table which is&n;** the control logic to convert PCI line based interrupts into a Message&n;** Signaled Interrupt (aka Transaction Based Interrupt, TBI).&n;**&n;** Acronyms&n;** --------&n;** HPA  Hard Physical Address (aka MMIO address)&n;** IRQ  Interrupt ReQuest. Implies Line based interrupt.&n;** IRT&t;Interrupt Routing Table (provided by PAT firmware)&n;** IRdT Interrupt Redirection Table. IRQ line to TXN ADDR/DATA&n;**      table which is implemented in I/O SAPIC.&n;** ISR  Interrupt Service Routine. aka Interrupt handler.&n;** MSI&t;Message Signaled Interrupt. PCI 2.2 functionality.&n;**      aka Transaction Based Interrupt (or TBI).&n;** PA   Precision Architecture. HP&squot;s RISC architecture.&n;** RISC Reduced Instruction Set Computer.&n;**&n;**&n;** What&squot;s a Message Signalled Interrupt?&n;** -------------------------------------&n;** MSI is a write transaction which targets a processor and is similar&n;** to a processor write to memory or MMIO. MSIs can be generated by I/O&n;** devices as well as processors and require *architecture* to work.&n;**&n;** PA only supports MSI. So I/O subsystems must either natively generate&n;** MSIs (e.g. GSC or HP-PB) or convert line based interrupts into MSIs&n;** (e.g. PCI and EISA).  IA64 supports MSIs via a &quot;local SAPIC&quot; which&n;** acts on behalf of a processor.&n;**&n;** MSI allows any I/O device to interrupt any processor. This makes&n;** load balancing of the interrupt processing possible on an SMP platform.&n;** Interrupts are also ordered WRT to DMA data.  It&squot;s possible on I/O&n;** coherent systems to completely eliminate PIO reads from the interrupt&n;** path. The device and driver must be designed and implemented to&n;** guarantee all DMA has been issued (issues about atomicity here)&n;** before the MSI is issued. I/O status can then safely be read from&n;** DMA&squot;d data by the ISR.&n;**&n;**&n;** PA Firmware&n;** -----------&n;** PA-RISC platforms have two fundementally different types of firmware.&n;** For PCI devices, &quot;Legacy&quot; PDC initializes the &quot;INTERRUPT_LINE&quot; register&n;** and BARs similar to a traditional PC BIOS.&n;** The newer &quot;PAT&quot; firmware supports PDC calls which return tables.&n;** PAT firmware only initializes PCI Console and Boot interface.&n;** With these tables, the OS can progam all other PCI devices.&n;**&n;** One such PAT PDC call returns the &quot;Interrupt Routing Table&quot; (IRT).&n;** The IRT maps each PCI slot&squot;s INTA-D &quot;output&quot; line to an I/O SAPIC&n;** input line.  If the IRT is not available, this driver assumes&n;** INTERRUPT_LINE register has been programmed by firmware. The latter&n;** case also means online addition of PCI cards can NOT be supported&n;** even if HW support is present.&n;**&n;** All platforms with PAT firmware to date (Oct 1999) use one Interrupt&n;** Routing Table for the entire platform.&n;**&n;** Where&squot;s the iosapic?&n;** --------------------&n;** I/O sapic is part of the &quot;Core Electronics Complex&quot;. And on HP platforms&n;** it&squot;s integrated as part of the PCI bus adapter, &quot;lba&quot;.  So no bus walk&n;** will discover I/O Sapic. I/O Sapic driver learns about each device&n;** when lba driver advertises the presence of the I/O sapic by calling&n;** iosapic_register().&n;**&n;**&n;** IRQ region notes&n;** ----------------&n;** The data passed to iosapic_interrupt() is per IRQ line.&n;** Each IRQ line will get one txn_addr/data pair. Thus each IRQ region,&n;** will have several txn_addr/data pairs (up to 7 for current I/O SAPIC&n;** implementations).  The IRQ region &quot;sysdata&quot; will NOT be directly passed&n;** to the interrupt handler like GSCtoPCI (dino.c).&n;**&n;** iosapic interrupt handler will NOT call do_irq_mask().&n;** It doesn&squot;t need to read a bit mask to determine which IRQ line was pulled&n;** since it already knows based on vector_info passed to iosapic_interrupt().&n;**&n;** One IRQ number represents both an IRQ line and a driver ISR.&n;** The I/O sapic driver can&squot;t manage shared IRQ lines because&n;** additional data besides the IRQ number must be passed via&n;** irq_region_ops. do_irq() and request_irq() must manage&n;** a sharing a bit in the mask.&n;**&n;** iosapic_interrupt() replaces do_irq_mask() and calls do_irq().&n;** Which IRQ line was asserted is already known since each&n;** line has unique data associated with it. We could omit&n;** iosapic_interrupt() from the calling path if it did NOT need&n;** to write EOI. For unshared lines, it really doesn&squot;t.&n;**&n;** Unfortunately, can&squot;t optimize out EOI if IRQ line isn&squot;t &quot;shared&quot;.&n;** N-class console &quot;device&quot; and some sort of heartbeat actually share&n;** one line though only one driver is registered...&lt;sigh&gt;...this was&n;** true for HP-UX at least. May not be true for parisc-linux.&n;**&n;**&n;** Overview of exported iosapic functions&n;** --------------------------------------&n;** (caveat: code isn&squot;t finished yet - this is just the plan)&n;**&n;** iosapic_init:&n;**   o initialize globals (lock, etc)&n;**   o try to read IRT. Presence of IRT determines if this is&n;**     a PAT platform or not.&n;**&n;** iosapic_register():&n;**   o create iosapic_info instance data structure&n;**   o allocate vector_info array for this iosapic&n;**   o initialize vector_info - read corresponding IRdT?&n;**&n;** iosapic_xlate_pin: (only called by fixup_irq for PAT platform)&n;**   o intr_pin = read cfg (INTERRUPT_PIN);&n;**   o if (device under PCI-PCI bridge)&n;**               translate slot/pin&n;**&n;** iosapic_fixup_irq:&n;**   o if PAT platform (IRT present)&n;**&t;   intr_pin = iosapic_xlate_pin(isi,pcidev):&n;**         intr_line = find IRT entry(isi, PCI_SLOT(pcidev), intr_pin)&n;**         save IRT entry into vector_info later&n;**         write cfg INTERRUPT_LINE (with intr_line)?&n;**     else&n;**         intr_line = pcidev-&gt;irq&n;**         IRT pointer = NULL&n;**     endif&n;**   o locate vector_info (needs: isi, intr_line)&n;**   o allocate processor &quot;irq&quot; and get txn_addr/data&n;**   o request_irq(processor_irq,  iosapic_interrupt, vector_info,...)&n;**   o pcidev-&gt;irq = isi-&gt;isi_region...base + intr_line;&n;**&n;** iosapic_interrupt:&n;**   o call do_irq(vector-&gt;isi-&gt;irq_region, vector-&gt;irq_line, regs)&n;**   o assume level triggered and write EOI&n;**&n;** iosapic_enable_irq:&n;**   o clear any pending IRQ on that line&n;**   o enable IRdT - call enable_irq(vector[line]-&gt;processor_irq)&n;**   o write EOI in case line is already asserted.&n;**&n;** iosapic_disable_irq:&n;**   o disable IRdT - call disable_irq(vector[line]-&gt;processor_irq)&n;**&n;** FIXME: mask/unmask&n;*/
multiline_comment|/* FIXME: determine which include files are really needed */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/pci.h&gt;&t;&t;/* pci cfg accessor functions  */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;&t;/* irqaction */
macro_line|#include &lt;linux/irq.h&gt;&t;&t;/* irq_region support */
macro_line|#include &lt;asm/byteorder.h&gt;&t;/* get in-line asm for swab */
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/pdcpat.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/gsc.h&gt;&t;&t;/* gsc_read/write functions */
macro_line|#include &lt;asm/iosapic.h&gt;
macro_line|#include &quot;./iosapic_private.h&quot;
DECL|macro|MODULE_NAME
mdefine_line|#define MODULE_NAME &quot;iosapic&quot;
multiline_comment|/* &quot;local&quot; compile flags */
DECL|macro|IOSAPIC_CALLBACK
macro_line|#undef IOSAPIC_CALLBACK
DECL|macro|PCI_BRIDGE_FUNCS
macro_line|#undef PCI_BRIDGE_FUNCS
DECL|macro|DEBUG_IOSAPIC
macro_line|#undef DEBUG_IOSAPIC
DECL|macro|DEBUG_IOSAPIC_IRT
macro_line|#undef DEBUG_IOSAPIC_IRT
macro_line|#ifdef DEBUG_IOSAPIC
DECL|variable|assert_buf
r_static
r_char
id|assert_buf
(braket
l_int|128
)braket
suffix:semicolon
r_static
r_int
DECL|function|assert_failed
id|assert_failed
(paren
r_char
op_star
id|a
comma
r_char
op_star
id|f
comma
r_int
id|l
)paren
(brace
id|sprintf
c_func
(paren
id|assert_buf
comma
l_string|&quot;ASSERT(%s) failed!&bslash;nline %d in %s&bslash;n&quot;
comma
id|a
comma
multiline_comment|/* assertion text */
id|l
comma
multiline_comment|/* line number */
id|f
)paren
suffix:semicolon
multiline_comment|/* file name */
id|panic
c_func
(paren
id|assert_buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|ASSERT
macro_line|#undef ASSERT
DECL|macro|ASSERT
mdefine_line|#define ASSERT(EX) { if (!(EX)) assert_failed(# EX, __FILE__, __LINE__); }
DECL|macro|DBG
mdefine_line|#define DBG(x...) printk(x)
macro_line|#else /* DEBUG_IOSAPIC */
DECL|macro|DBG
mdefine_line|#define DBG(x...)
DECL|macro|ASSERT
mdefine_line|#define ASSERT(EX)
macro_line|#endif /* DEBUG_IOSAPIC */
macro_line|#ifdef DEBUG_IOSAPIC_IRT
DECL|macro|DBG_IRT
mdefine_line|#define DBG_IRT(x...) printk(x)
macro_line|#else
DECL|macro|DBG_IRT
mdefine_line|#define DBG_IRT(x...)
macro_line|#endif
DECL|macro|READ_U8
mdefine_line|#define READ_U8(addr)  gsc_readb(addr)
DECL|macro|READ_U16
mdefine_line|#define READ_U16(addr) le16_to_cpu(gsc_readw((u16 *) (addr)))
DECL|macro|READ_U32
mdefine_line|#define READ_U32(addr) le32_to_cpu(gsc_readl((u32 *) (addr)))
DECL|macro|READ_REG16
mdefine_line|#define READ_REG16(addr) gsc_readw((u16 *) (addr))
DECL|macro|READ_REG32
mdefine_line|#define READ_REG32(addr) gsc_readl((u32 *) (addr))
DECL|macro|WRITE_U8
mdefine_line|#define WRITE_U8(value, addr) gsc_writeb(value, addr)
DECL|macro|WRITE_U16
mdefine_line|#define WRITE_U16(value, addr) gsc_writew(cpu_to_le16(value), (u16 *) (addr))
DECL|macro|WRITE_U32
mdefine_line|#define WRITE_U32(value, addr) gsc_writel(cpu_to_le32(value), (u32 *) (addr))
DECL|macro|WRITE_REG16
mdefine_line|#define WRITE_REG16(value, addr) gsc_writew(value, (u16 *) (addr))
DECL|macro|WRITE_REG32
mdefine_line|#define WRITE_REG32(value, addr) gsc_writel(value, (u32 *) (addr))
DECL|macro|IOSAPIC_REG_SELECT
mdefine_line|#define IOSAPIC_REG_SELECT              0
DECL|macro|IOSAPIC_REG_WINDOW
mdefine_line|#define IOSAPIC_REG_WINDOW              0x10
DECL|macro|IOSAPIC_REG_EOI
mdefine_line|#define IOSAPIC_REG_EOI                 0x40
DECL|macro|IOSAPIC_REG_VERSION
mdefine_line|#define IOSAPIC_REG_VERSION&t;&t;0x1
DECL|macro|IOSAPIC_IRDT_ENTRY
mdefine_line|#define IOSAPIC_IRDT_ENTRY(idx)&t;&t;(0x10+(idx)*2)
DECL|macro|IOSAPIC_IRDT_ENTRY_HI
mdefine_line|#define IOSAPIC_IRDT_ENTRY_HI(idx)&t;(0x11+(idx)*2)
multiline_comment|/*&n;** FIXME: revisit which GFP flags we should really be using.&n;**     GFP_KERNEL includes __GFP_WAIT flag and that may not&n;**     be acceptable. Since this is boot time, we shouldn&squot;t have&n;**     to wait ever and this code should (will?) never get called&n;**     from the interrrupt context.&n;*/
DECL|macro|IOSAPIC_KALLOC
mdefine_line|#define&t;IOSAPIC_KALLOC(a_type, cnt) &bslash;&n;&t;&t;&t;(a_type *) kmalloc(sizeof(a_type)*(cnt), GFP_KERNEL)
DECL|macro|IOSAPIC_FREE
mdefine_line|#define IOSAPIC_FREE(addr, f_type, cnt) kfree((void *)addr)
DECL|macro|IOSAPIC_LOCK
mdefine_line|#define&t;IOSAPIC_LOCK(lck)&t;spin_lock_irqsave(lck, irqflags)
DECL|macro|IOSAPIC_UNLOCK
mdefine_line|#define&t;IOSAPIC_UNLOCK(lck)&t;spin_unlock_irqrestore(lck, irqflags)
DECL|macro|IOSAPIC_VERSION_MASK
mdefine_line|#define IOSAPIC_VERSION_MASK            0x000000ff
DECL|macro|IOSAPIC_VERSION_SHIFT
mdefine_line|#define IOSAPIC_VERSION_SHIFT           0x0
DECL|macro|IOSAPIC_VERSION
mdefine_line|#define&t;IOSAPIC_VERSION(ver)&t;&t;&t;&t;&bslash;&n;&t;&t;(int) ((ver &amp; IOSAPIC_VERSION_MASK) &gt;&gt; IOSAPIC_VERSION_SHIFT)
DECL|macro|IOSAPIC_MAX_ENTRY_MASK
mdefine_line|#define IOSAPIC_MAX_ENTRY_MASK          0x00ff0000
DECL|macro|IOSAPIC_MAX_ENTRY_SHIFT
mdefine_line|#define IOSAPIC_MAX_ENTRY_SHIFT         0x10
DECL|macro|IOSAPIC_IRDT_MAX_ENTRY
mdefine_line|#define&t;IOSAPIC_IRDT_MAX_ENTRY(ver)&t;&t;&t;&bslash;&n;&t;&t;(int) ((ver&amp;IOSAPIC_MAX_ENTRY_MASK) &gt;&gt; IOSAPIC_MAX_ENTRY_SHIFT)
multiline_comment|/* bits in the &quot;low&quot; I/O Sapic IRdT entry */
DECL|macro|IOSAPIC_IRDT_ENABLE
mdefine_line|#define IOSAPIC_IRDT_ENABLE       0x10000
DECL|macro|IOSAPIC_IRDT_PO_LOW
mdefine_line|#define IOSAPIC_IRDT_PO_LOW       0x02000
DECL|macro|IOSAPIC_IRDT_LEVEL_TRIG
mdefine_line|#define IOSAPIC_IRDT_LEVEL_TRIG   0x08000
DECL|macro|IOSAPIC_IRDT_MODE_LPRI
mdefine_line|#define IOSAPIC_IRDT_MODE_LPRI    0x00100
multiline_comment|/* bits in the &quot;high&quot; I/O Sapic IRdT entry */
DECL|macro|IOSAPIC_IRDT_ID_EID_SHIFT
mdefine_line|#define IOSAPIC_IRDT_ID_EID_SHIFT              0x10
DECL|macro|IOSAPIC_EOI
mdefine_line|#define&t;IOSAPIC_EOI(eoi_addr, eoi_data) gsc_writel(eoi_data, eoi_addr)
macro_line|#if IOSAPIC_CALLBACK
multiline_comment|/*&n;** Shouldn&squot;t use callback since SAPIC doesn&squot;t have an officially assigned&n;** H or S version numbers. Slight long term risk the number chosen would&n;** collide with something else.&n;** But benefit is cleaner lba/sapic interface.&n;** Might be worth it but for just use direct calls for now.&n;**&n;** Entry below is copied from lba driver.&n;** Only thing different is hw_type.&n;*/
DECL|variable|iosapic_driver_for
r_static
r_struct
id|pa_iodc_driver
id|iosapic_driver_for
(braket
)braket
op_assign
(brace
(brace
id|HPHW_OTHER
comma
l_int|0x782
comma
l_int|0
comma
l_int|0x0000A
comma
l_int|0
comma
l_int|0x00
comma
id|DRIVER_CHECK_HWTYPE
op_plus
id|DRIVER_CHECK_HVERSION
op_plus
id|DRIVER_CHECK_SVERSION
comma
l_string|&quot;I/O Sapic&quot;
comma
l_string|&quot;&quot;
comma
(paren
r_void
op_star
)paren
id|iosapic_callback
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
)brace
)brace
suffix:semicolon
macro_line|#endif /* IOSAPIO_CALLBACK */
DECL|variable|iosapic_list
r_static
r_struct
id|iosapic_info
op_star
id|iosapic_list
suffix:semicolon
DECL|variable|iosapic_lock
r_static
id|spinlock_t
id|iosapic_lock
suffix:semicolon
DECL|variable|iosapic_count
r_static
r_int
id|iosapic_count
suffix:semicolon
multiline_comment|/*&n;** REVISIT: future platforms may have more than one IRT.&n;** If so, the following three fields form a structure which&n;** then be linked into a list. Names are chosen to make searching&n;** for them easy - not necessarily accurate (eg &quot;cell&quot;).&n;**&n;** Alternative: iosapic_info could point to the IRT it&squot;s in.&n;** iosapic_register() could search a list of IRT&squot;s.&n;*/
DECL|variable|irt_cell
r_static
r_struct
id|irt_entry
op_star
id|irt_cell
suffix:semicolon
DECL|variable|irt_num_entry
r_static
r_int
id|irt_num_entry
suffix:semicolon
multiline_comment|/*&n;** iosapic_load_irt&n;**&n;** The &quot;Get PCI INT Routing Table Size&quot; option returns the number of &n;** entries in the PCI interrupt routing table for the cell specified &n;** in the cell_number argument.  The cell number must be for a cell &n;** within the caller&squot;s protection domain.&n;**&n;** The &quot;Get PCI INT Routing Table&quot; option returns, for the cell &n;** specified in the cell_number argument, the PCI interrupt routing &n;** table in the caller allocated memory pointed to by mem_addr.&n;** We assume the IRT only contains entries for I/O SAPIC and&n;** calculate the size based on the size of I/O sapic entries.&n;**&n;** The PCI interrupt routing table entry format is derived from the&n;** IA64 SAL Specification 2.4.   The PCI interrupt routing table defines&n;** the routing of PCI interrupt signals between the PCI device output&n;** &quot;pins&quot; and the IO SAPICs&squot; input &quot;lines&quot; (including core I/O PCI&n;** devices).  This table does NOT include information for devices/slots&n;** behind PCI to PCI bridges. See PCI to PCI Bridge Architecture Spec.&n;** for the architected method of routing of IRQ&squot;s behind PPB&squot;s.&n;*/
r_static
r_int
id|__init
multiline_comment|/* return number of entries as success/fail flag */
DECL|function|iosapic_load_irt
id|iosapic_load_irt
c_func
(paren
r_int
r_int
id|cell_num
comma
r_struct
id|irt_entry
op_star
op_star
id|irt
)paren
(brace
r_struct
id|pdc_pat_io_num
id|pdc_io_num
suffix:semicolon
multiline_comment|/* PAT PDC return block */
r_int
id|status
suffix:semicolon
multiline_comment|/* PDC return value status */
r_struct
id|irt_entry
op_star
id|table
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* start of interrupt routing tbl */
r_int
r_int
id|num_entries
op_assign
l_int|0UL
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|irt
)paren
suffix:semicolon
multiline_comment|/* FIXME ASSERT(((&amp;pdc_io_num) &amp; (0x3f)) == 0);  enforce 32-byte alignment */
multiline_comment|/* Try PAT_PDC to get interrupt routing table size */
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;calling get_irt_size&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|pdc_pat_get_irt_size
c_func
(paren
op_amp
id|pdc_io_num
comma
id|cell_num
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;get_irt_size: %ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|PDC_RET_OK
suffix:colon
multiline_comment|/* PAT box. Proceed to get the IRT */
multiline_comment|/* save the number of entries in the table */
id|num_entries
op_assign
id|pdc_io_num.num
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0UL
op_ne
id|num_entries
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** allocate memory for interrupt routing table&n;&t;&t;** This interface isn&squot;t really right. We are assuming&n;&t;&t;** the contents of the table are exclusively&n;&t;&t;** for I/O sapic devices.&n;&t;&t;*/
id|table
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|irt_entry
comma
id|num_entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: read_irt : can not alloc mem for IRT&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get PCI INT routing table */
id|status
op_assign
id|pdc_pat_get_irt
c_func
(paren
(paren
r_void
op_star
)paren
id|table
comma
id|cell_num
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pdc_pat_get_irt: %ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|status
op_eq
id|PDC_RET_OK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PDC_RET_NE_PROC
suffix:colon
multiline_comment|/* Not a PAT platform. Try PDC_PCI extensions */
multiline_comment|/*&n;&t;&t;** C3000/J5000 (and similar) platforms with &quot;legacy&quot; PDC&n;&t;&t;** will return exactly one IRT.&n;&t;&t;** So if we have one, don&squot;t need to get it again.&n;&t;&t;*/
r_if
c_cond
(paren
l_int|NULL
op_ne
id|irt_cell
)paren
r_break
suffix:semicolon
id|status
op_assign
id|pdc_pci_irt_size
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|pdc_io_num
comma
multiline_comment|/* elroy HPA (really a NOP) */
l_int|0
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|KERN_WARNING
l_string|&quot;pdc_pci_irt_size: %ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PDC_RET_OK
op_ne
id|status
)paren
(brace
multiline_comment|/* Not a &quot;legacy&quot; system with I/O SAPIC either */
r_return
l_int|0
suffix:semicolon
)brace
id|num_entries
op_assign
id|pdc_io_num.num
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0UL
op_ne
id|num_entries
)paren
suffix:semicolon
id|table
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|irt_entry
comma
id|num_entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: read_irt : can not alloc mem for IRT&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|status
op_assign
id|pdc_pci_irt
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|pdc_io_num
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
multiline_comment|/* Elroy HPA - not used */
(paren
r_void
op_star
)paren
id|table
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|PDC_RET_OK
op_eq
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: PDC_PAT_IO call failed with %ld&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* return interrupt table address */
op_star
id|irt
op_assign
id|table
suffix:semicolon
macro_line|#ifdef DEBUG_IOSAPIC_IRT
(brace
r_struct
id|irt_entry
op_star
id|p
op_assign
id|table
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|MODULE_NAME
l_string|&quot; Interrupt Routing Table (cell %ld)&bslash;n&quot;
comma
id|cell_num
)paren
suffix:semicolon
id|printk
c_func
(paren
id|MODULE_NAME
l_string|&quot; start = 0x%p num_entries %ld entry_size %d&bslash;n&quot;
comma
id|table
comma
id|num_entries
comma
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|irt_entry
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_entries
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
id|printk
c_func
(paren
id|MODULE_NAME
l_string|&quot; %02x %02x %02x %02x %02x %02x %02x %02x %08x%08x&bslash;n&quot;
comma
id|p-&gt;entry_type
comma
id|p-&gt;entry_length
comma
id|p-&gt;interrupt_type
comma
id|p-&gt;polarity_trigger
comma
id|p-&gt;src_bus_irq_devno
comma
id|p-&gt;src_bus_id
comma
id|p-&gt;src_seg_id
comma
id|p-&gt;dest_iosapic_intin
comma
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
(braket
l_int|2
)braket
comma
(paren
(paren
id|u32
op_star
)paren
id|p
)paren
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG_IOSAPIC_IRT */
r_return
id|num_entries
suffix:semicolon
)brace
r_void
id|__init
DECL|function|iosapic_init
id|iosapic_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* init global data */
id|iosapic_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|iosapic_list
op_assign
(paren
r_struct
id|iosapic_info
op_star
)paren
l_int|NULL
suffix:semicolon
id|iosapic_count
op_assign
l_int|0
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;iosapic_init()&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;**  get IRT for this cell.&n;&t;*/
id|irt_num_entry
op_assign
id|iosapic_load_irt
c_func
(paren
l_int|0L
comma
op_amp
id|irt_cell
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|irt_num_entry
)paren
id|irt_cell
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* old PDC w/o iosapic */
macro_line|#ifdef IOSAPIC_CALLBACK
multiline_comment|/*&n;&t;** When new I/O SAPICs are discovered, this callback&n;&t;** will get invoked. Implies lba driver will register&n;&t;** I/O Sapic as a device it &quot;discovered&quot; with faked&n;&t;** IODC data.&n;&t;*/
id|register_driver
c_func
(paren
id|iosapic_driver_for
)paren
suffix:semicolon
macro_line|#endif /* IOSAPIC_CALLBACK */
)brace
multiline_comment|/*&n;** Return the IRT entry in case we need to look something else up.&n;*/
r_static
r_struct
id|irt_entry
op_star
DECL|function|irt_find_irqline
id|irt_find_irqline
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
comma
id|u8
id|slot
comma
id|u8
id|intr_pin
)paren
(brace
r_struct
id|irt_entry
op_star
id|i
op_assign
id|irt_cell
suffix:semicolon
r_int
id|cnt
suffix:semicolon
multiline_comment|/* track how many entries we&squot;ve looked at */
id|u8
id|irq_devno
op_assign
(paren
id|slot
op_lshift
id|IRT_DEV_SHIFT
)paren
op_or
(paren
id|intr_pin
op_minus
l_int|1
)paren
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;irt_find_irqline() SLOT %d pin %d&bslash;n&quot;
comma
id|slot
comma
id|intr_pin
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|irt_num_entry
suffix:semicolon
id|cnt
op_increment
comma
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;** Validate: entry_type, entry_length, interrupt_type&n;&t;&t;**&n;&t;&t;** Difference between validate vs compare is the former&n;&t;&t;** should print debug info and is not expected to &quot;fail&quot;&n;&t;&t;** on current platforms.&n;&t;&t;*/
r_if
c_cond
(paren
id|i-&gt;entry_type
op_ne
id|IRT_IOSAPIC_TYPE
)paren
(brace
id|DBG_IRT
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;:find_irqline(0x%p): skipping entry %d type %d&bslash;n&quot;
comma
id|i
comma
id|cnt
comma
id|i-&gt;entry_type
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i-&gt;entry_length
op_ne
id|IRT_IOSAPIC_LENGTH
)paren
(brace
id|DBG_IRT
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;:find_irqline(0x%p): skipping entry %d  length %d&bslash;n&quot;
comma
id|i
comma
id|cnt
comma
id|i-&gt;entry_length
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i-&gt;interrupt_type
op_ne
id|IRT_VECTORED_INTR
)paren
(brace
id|DBG_IRT
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;:find_irqline(0x%p): skipping entry  %d interrupt_type %d&bslash;n&quot;
comma
id|i
comma
id|cnt
comma
id|i-&gt;interrupt_type
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Compare: dest_iosapic_addr, src_bus_irq_devno&n;&t;&t;*/
r_if
c_cond
(paren
id|i-&gt;dest_iosapic_addr
op_ne
(paren
id|u64
)paren
(paren
(paren
r_int
)paren
id|isi-&gt;isi_hpa
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i-&gt;src_bus_irq_devno
op_amp
id|IRT_IRQ_DEVNO_MASK
)paren
op_ne
id|irq_devno
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Ignore: src_bus_id and rc_seg_id correlate with&n;&t;&t;**         iosapic_info-&gt;isi_hpa on HP platforms.&n;&t;&t;**         If needed, pass in &quot;PFA&quot; (aka config space addr)&n;&t;&t;**         instead of slot.&n;&t;&t;*/
multiline_comment|/* Found it! */
r_return
id|i
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: 0x%p : no IRT entry for slot %d, pin %d&bslash;n&quot;
comma
id|isi-&gt;isi_hpa
comma
id|slot
comma
id|intr_pin
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** xlate_pin() supports the skewing of IRQ lines done by subsidiary bridges.&n;** Legacy PDC already does this translation for us and stores it in INTR_LINE.&n;**&n;** PAT PDC needs to basically do what legacy PDC does:&n;** o read PIN&n;** o adjust PIN in case device is &quot;behind&quot; a PPB&n;**     (eg 4-port 100BT and SCSI/LAN &quot;Combo Card&quot;)&n;** o convert slot/pin to I/O SAPIC input line.&n;**&n;** HP platforms only support:&n;** o one level of skewing for any number of PPBs&n;** o only support PCI-PCI Bridges.&n;*/
r_static
r_struct
id|irt_entry
op_star
DECL|function|iosapic_xlate_pin
id|iosapic_xlate_pin
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
comma
r_struct
id|pci_dev
op_star
id|pcidev
)paren
(brace
id|u8
id|intr_pin
comma
id|intr_slot
suffix:semicolon
(paren
r_void
)paren
id|pci_read_config_byte
c_func
(paren
id|pcidev
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|intr_pin
)paren
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_xlate_pin() SLOT %d pin %d&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
comma
id|intr_pin
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|intr_pin
)paren
(brace
multiline_comment|/*&n;&t;&t;** The device does NOT support/use IRQ lines.&n;&t;&t;*/
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Check if pcidev behind a PPB */
r_if
c_cond
(paren
l_int|NULL
op_ne
id|pcidev-&gt;bus-&gt;self
)paren
(brace
multiline_comment|/* Convert pcidev INTR_PIN into something we&n;&t;&t;** can lookup in the IRT.&n;&t;&t;*/
macro_line|#ifdef PCI_BRIDGE_FUNCS
multiline_comment|/*&n;&t;&t;** Proposal #1:&n;&t;&t;**&n;&t;&t;** call implementation specific translation function&n;&t;&t;** This is architecturally &quot;cleaner&quot;. HP-UX doesn&squot;t&n;&t;&t;** support other secondary bus types (eg. E/ISA) directly.&n;&t;&t;** May be needed for other processor (eg IA64) architectures&n;&t;&t;** or by some ambitous soul who wants to watch TV.&n;&t;&t;*/
r_if
c_cond
(paren
id|pci_bridge_funcs-&gt;xlate_intr_line
)paren
(brace
id|intr_pin
op_assign
(paren
op_star
id|pci_bridge_funcs-&gt;xlate_intr_line
)paren
(paren
id|pcidev
)paren
suffix:semicolon
)brace
macro_line|#else&t;/* PCI_BRIDGE_FUNCS */
r_struct
id|pci_bus
op_star
id|p
op_assign
id|pcidev-&gt;bus
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Proposal #2:&n;&t;&t;** The &quot;pin&quot; is skewed ((pin + dev - 1) % 4).&n;&t;&t;**&n;&t;&t;** This isn&squot;t very clean since I/O SAPIC must assume:&n;&t;&t;**   - all platforms only have PCI busses.&n;&t;&t;**   - only PCI-PCI bridge (eg not PCI-EISA, PCI-PCMCIA)&n;&t;&t;**   - IRQ routing is only skewed once regardless of&n;&t;&t;**     the number of PPB&squot;s between iosapic and device.&n;&t;&t;**     (Bit3 expansion chassis follows this rule)&n;&t;&t;**&n;&t;&t;** Advantage is it&squot;s really easy to implement.&n;&t;&t;*/
id|intr_pin
op_assign
(paren
(paren
id|intr_pin
op_minus
l_int|1
)paren
op_plus
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
)paren
op_mod
l_int|4
suffix:semicolon
id|intr_pin
op_increment
suffix:semicolon
multiline_comment|/* convert back to INTA-D (1-4) */
macro_line|#endif /* PCI_BRIDGE_FUNCS */
multiline_comment|/*&n;&t;&t;** Locate the host slot the PPB nearest the Host bus&n;&t;&t;** adapter.&n;&t;&t;*/
r_while
c_loop
(paren
l_int|NULL
op_ne
id|p-&gt;parent-&gt;self
)paren
id|p
op_assign
id|p-&gt;parent
suffix:semicolon
id|intr_slot
op_assign
id|PCI_SLOT
c_func
(paren
id|p-&gt;self-&gt;devfn
)paren
suffix:semicolon
)brace
r_else
(brace
id|intr_slot
op_assign
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
suffix:semicolon
)brace
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_xlate_pin:  bus %d slot %d pin %d&bslash;n&quot;
comma
id|pcidev-&gt;bus-&gt;secondary
comma
id|intr_slot
comma
id|intr_pin
)paren
suffix:semicolon
r_return
id|irt_find_irqline
c_func
(paren
id|isi
comma
id|intr_slot
comma
id|intr_pin
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_interrupt
id|iosapic_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|vector_info
op_star
id|vi
op_assign
(paren
r_struct
id|vector_info
op_star
)paren
id|dev_id
suffix:semicolon
r_extern
r_void
id|do_irq
c_func
(paren
r_struct
id|irqaction
op_star
id|a
comma
r_int
id|i
comma
r_struct
id|pt_regs
op_star
id|p
)paren
suffix:semicolon
r_int
id|irq_num
op_assign
id|vi-&gt;vi_ios-&gt;isi_region-&gt;data.irqbase
op_plus
id|vi-&gt;vi_irqline
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;iosapic_interrupt(): irq %d line %d eoi %p&bslash;n&quot;
comma
id|irq
comma
id|vi-&gt;vi_irqline
comma
id|vi-&gt;vi_eoi_addr
)paren
suffix:semicolon
multiline_comment|/* FIXME: Need to mask/unmask? processor IRQ is already masked... */
id|do_irq
c_func
(paren
op_amp
id|vi-&gt;vi_ios-&gt;isi_region-&gt;action
(braket
id|vi-&gt;vi_irqline
)braket
comma
id|irq_num
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** PCI only supports level triggered in order to share IRQ lines.&n;&t;** I/O SAPIC must always issue EOI.&n;&t;*/
id|IOSAPIC_EOI
c_func
(paren
id|vi-&gt;vi_eoi_addr
comma
id|vi-&gt;vi_eoi_data
)paren
suffix:semicolon
)brace
r_int
DECL|function|iosapic_fixup_irq
id|iosapic_fixup_irq
c_func
(paren
r_void
op_star
id|isi_obj
comma
r_struct
id|pci_dev
op_star
id|pcidev
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isi
op_assign
(paren
r_struct
id|iosapic_info
op_star
)paren
id|isi_obj
suffix:semicolon
r_struct
id|irt_entry
op_star
id|irte
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* only used if PAT PDC */
r_struct
id|vector_info
op_star
id|vi
suffix:semicolon
r_int
id|isi_line
suffix:semicolon
multiline_comment|/* line used by device */
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|isi
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MODULE_NAME
l_string|&quot;: 0x%p hpa not registered&bslash;n&quot;
comma
id|isi-&gt;isi_hpa
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* lookup IRT entry for isi/slot/pin set */
id|irte
op_assign
id|iosapic_xlate_pin
c_func
(paren
id|isi
comma
id|pcidev
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|irte
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_fixup_irq(): irte %p %x %x %x %x %x %x %x %x&bslash;n&quot;
comma
id|irte
comma
id|irte-&gt;entry_type
comma
id|irte-&gt;entry_length
comma
id|irte-&gt;polarity_trigger
comma
id|irte-&gt;src_bus_irq_devno
comma
id|irte-&gt;src_bus_id
comma
id|irte-&gt;src_seg_id
comma
id|irte-&gt;dest_iosapic_intin
comma
(paren
id|u32
)paren
id|irte-&gt;dest_iosapic_addr
)paren
suffix:semicolon
id|isi_line
op_assign
id|irte-&gt;dest_iosapic_intin
suffix:semicolon
multiline_comment|/* get vector info for this input line */
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|isi-&gt;isi_vector
)paren
suffix:semicolon
id|vi
op_assign
op_amp
(paren
id|isi-&gt;isi_vector
(braket
id|isi_line
)braket
)paren
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_fixup_irq:  line %d vi 0x%p&bslash;n&quot;
comma
id|isi_line
comma
id|vi
)paren
suffix:semicolon
id|vi-&gt;vi_irte
op_assign
id|irte
suffix:semicolon
multiline_comment|/* Allocate processor IRQ */
id|vi-&gt;vi_txn_irq
op_assign
id|txn_alloc_irq
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* XXX/FIXME The txn_alloc_irq() code and related code should be moved&n;** to enable_irq(). That way we only allocate processor IRQ bits&n;** for devices that actually have drivers claiming them.&n;** Right now we assign an IRQ to every PCI device present regardless&n;** of whether it&squot;s used or not.&n;*/
r_if
c_cond
(paren
id|vi-&gt;vi_txn_irq
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;I/O sapic: couldn&squot;t get TXN IRQ&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* enable_irq() will use txn_* to program IRdT */
id|vi-&gt;vi_txn_addr
op_assign
id|txn_alloc_addr
c_func
(paren
id|vi-&gt;vi_txn_irq
)paren
suffix:semicolon
id|vi-&gt;vi_txn_data
op_assign
id|txn_alloc_data
c_func
(paren
id|vi-&gt;vi_txn_irq
comma
l_int|8
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|vi-&gt;vi_txn_data
OL
l_int|256
)paren
suffix:semicolon
multiline_comment|/* matches 8 above */
id|tmp
op_assign
id|request_irq
c_func
(paren
id|vi-&gt;vi_txn_irq
comma
id|iosapic_interrupt
comma
l_int|0
comma
l_string|&quot;iosapic&quot;
comma
id|vi
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmp
op_eq
l_int|0
)paren
suffix:semicolon
id|vi-&gt;vi_eoi_addr
op_assign
(paren
(paren
r_void
op_star
)paren
id|isi-&gt;isi_hpa
)paren
op_plus
id|IOSAPIC_REG_EOI
suffix:semicolon
id|vi-&gt;vi_eoi_data
op_assign
id|cpu_to_le32
c_func
(paren
id|vi-&gt;vi_irqline
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|isi-&gt;isi_region
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** pcidev-&gt;irq still needs to be virtualized.&n;&t;*/
id|pcidev-&gt;irq
op_assign
id|isi-&gt;isi_region-&gt;data.irqbase
op_plus
id|isi_line
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_fixup_irq() %d:%d %x %x line %d irq %d&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|pcidev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pcidev-&gt;devfn
)paren
comma
id|pcidev-&gt;vendor
comma
id|pcidev-&gt;device
comma
id|isi_line
comma
id|pcidev-&gt;irq
)paren
suffix:semicolon
r_return
id|pcidev-&gt;irq
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_rd_irt_entry
id|iosapic_rd_irt_entry
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
comma
id|u32
op_star
id|dp0
comma
id|u32
op_star
id|dp1
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isp
op_assign
id|vi-&gt;vi_ios
suffix:semicolon
id|u8
id|idx
op_assign
id|vi-&gt;vi_irqline
suffix:semicolon
multiline_comment|/* point the window register to the lower word */
id|WRITE_U32
c_func
(paren
id|IOSAPIC_IRDT_ENTRY
c_func
(paren
id|idx
)paren
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
op_star
id|dp0
op_assign
id|READ_U32
c_func
(paren
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
multiline_comment|/* point the window register to the higher word */
id|WRITE_U32
c_func
(paren
id|IOSAPIC_IRDT_ENTRY_HI
c_func
(paren
id|idx
)paren
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
op_star
id|dp1
op_assign
id|READ_U32
c_func
(paren
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_wr_irt_entry
id|iosapic_wr_irt_entry
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
comma
id|u32
id|dp0
comma
id|u32
id|dp1
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isp
op_assign
id|vi-&gt;vi_ios
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|isp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|isp-&gt;isi_hpa
)paren
suffix:semicolon
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_wr_irt_entry(): irq %d hpa %p WINDOW %p  0x%x 0x%x&bslash;n&quot;
comma
id|vi-&gt;vi_irqline
comma
id|isp-&gt;isi_hpa
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
comma
id|dp0
comma
id|dp1
)paren
suffix:semicolon
multiline_comment|/* point the window register to the lower word */
id|WRITE_U32
c_func
(paren
id|IOSAPIC_IRDT_ENTRY
c_func
(paren
id|vi-&gt;vi_irqline
)paren
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|WRITE_U32
c_func
(paren
id|dp0
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
multiline_comment|/* Read the window register to flush the writes down to HW  */
id|dp0
op_assign
id|READ_U32
c_func
(paren
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
multiline_comment|/* point the window register to the higher word */
id|WRITE_U32
c_func
(paren
id|IOSAPIC_IRDT_ENTRY_HI
c_func
(paren
id|vi-&gt;vi_irqline
)paren
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
id|WRITE_U32
c_func
(paren
id|dp1
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
multiline_comment|/* Read the window register to flush the writes down to HW  */
id|dp1
op_assign
id|READ_U32
c_func
(paren
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** set_irt prepares the data (dp0, dp1) according to the vector_info&n;** and target cpu (id_eid).  dp0/dp1 are then used to program I/O SAPIC&n;** IRdT for the given &quot;vector&quot; (aka IRQ line).&n;*/
r_static
r_void
DECL|function|iosapic_set_irt_data
id|iosapic_set_irt_data
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
comma
id|u32
op_star
id|dp0
comma
id|u32
op_star
id|dp1
)paren
(brace
id|u32
id|mode
op_assign
l_int|0
suffix:semicolon
r_struct
id|irt_entry
op_star
id|p
op_assign
id|vi-&gt;vi_irte
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|vi-&gt;vi_irte
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;polarity_trigger
op_amp
id|IRT_PO_MASK
)paren
op_eq
id|IRT_ACTIVE_LO
)paren
id|mode
op_or_assign
id|IOSAPIC_IRDT_PO_LOW
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|p-&gt;polarity_trigger
op_rshift
id|IRT_EL_SHIFT
)paren
op_amp
id|IRT_EL_MASK
)paren
op_eq
id|IRT_LEVEL_TRIG
)paren
id|mode
op_or_assign
id|IOSAPIC_IRDT_LEVEL_TRIG
suffix:semicolon
multiline_comment|/*&n;&t;** IA64 REVISIT&n;&t;** PA doesn&squot;t support EXTINT or LPRIO bits.&n;&t;*/
id|ASSERT
c_func
(paren
id|vi-&gt;vi_txn_data
)paren
suffix:semicolon
op_star
id|dp0
op_assign
id|mode
op_or
(paren
id|u32
)paren
id|vi-&gt;vi_txn_data
suffix:semicolon
multiline_comment|/*&n;&t;** Extracting id_eid isn&squot;t a real clean way of getting it.&n;&t;** But the encoding is the same for both PA and IA64 platforms.&n;&t;*/
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|pdc_pat
)paren
(brace
multiline_comment|/*&n;&t;&t;** PAT PDC just hands it to us &quot;right&quot;.&n;&t;&t;** vi_txn_addr comes from cpu_data[x].txn_addr.&n;&t;&t;*/
op_star
id|dp1
op_assign
(paren
id|u32
)paren
(paren
id|vi-&gt;vi_txn_addr
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* &n;&t;&t;** eg if base_addr == 0xfffa0000),&n;&t;&t;**    we want to get 0xa0ff0000.&n;&t;&t;**&n;&t;&t;** eid&t;0x0ff00000 -&gt; 0x00ff0000&n;&t;&t;** id&t;0x000ff000 -&gt; 0xff000000&n;&t;&t;*/
op_star
id|dp1
op_assign
(paren
(paren
(paren
id|u32
)paren
id|vi-&gt;vi_txn_addr
op_amp
l_int|0x0ff00000
)paren
op_rshift
l_int|4
)paren
op_or
(paren
(paren
(paren
id|u32
)paren
id|vi-&gt;vi_txn_addr
op_amp
l_int|0x000ff000
)paren
op_lshift
l_int|12
)paren
suffix:semicolon
)brace
id|DBG_IRT
c_func
(paren
l_string|&quot;iosapic_set_irt_data(): 0x%x 0x%x&bslash;n&quot;
comma
op_star
id|dp0
comma
op_star
id|dp1
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_disable_irq
id|iosapic_disable_irq
c_func
(paren
r_void
op_star
id|irq_dev
comma
r_int
id|irq
)paren
(brace
id|ulong
id|irqflags
suffix:semicolon
r_struct
id|vector_info
op_star
id|vi
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|vector_info
op_star
)paren
id|irq_dev
)paren
(braket
id|irq
)braket
)paren
suffix:semicolon
id|u32
id|d0
comma
id|d1
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|vi
)paren
suffix:semicolon
id|IOSAPIC_LOCK
c_func
(paren
op_amp
id|iosapic_lock
)paren
suffix:semicolon
macro_line|#ifdef REVISIT_DESIGN_ISSUE
multiline_comment|/* &n;** XXX/FIXME&n;&n;disable_irq()/enable_irq(): drawback of using IRQ as a &quot;handle&quot;&n;&n;Current disable_irq interface only allows the irq_region support routines&n;to manage sharing of &quot;irq&quot; objects.  The problem is the disable_irq()&n;interface specifies which IRQ line needs to be disabled but does not&n;identify the particular ISR which needs to be disabled.  IO sapic&n;(and similar code in Dino) can only support one handler per IRQ&n;since they don&squot;t further encode the meaning of the IRQ number.&n;irq_region support has to hide it&squot;s implementation of &quot;shared IRQ&quot;&n;behind a function call.&n;&n;Encoding the IRQ would be possible by I/O SAPIC but makes life really&n;complicated for the IRQ handler and not help performance.&n;&n;Need more info on how Linux supports shared IRQ lines on a PC.&n;*/
macro_line|#endif /* REVISIT_DESIGN_ISSUE */
id|iosapic_rd_irt_entry
c_func
(paren
id|vi
comma
op_amp
id|d0
comma
op_amp
id|d1
)paren
suffix:semicolon
id|d0
op_or_assign
id|IOSAPIC_IRDT_ENABLE
suffix:semicolon
id|iosapic_wr_irt_entry
c_func
(paren
id|vi
comma
id|d0
comma
id|d1
)paren
suffix:semicolon
id|IOSAPIC_UNLOCK
c_func
(paren
op_amp
id|iosapic_lock
)paren
suffix:semicolon
multiline_comment|/* disable ISR for parent */
id|disable_irq
c_func
(paren
id|vi-&gt;vi_txn_irq
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_enable_irq
id|iosapic_enable_irq
c_func
(paren
r_void
op_star
id|dev
comma
r_int
id|irq
)paren
(brace
r_struct
id|vector_info
op_star
id|vi
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|vector_info
op_star
)paren
id|dev
)paren
(braket
id|irq
)braket
)paren
suffix:semicolon
id|u32
id|d0
comma
id|d1
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|vi
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|vi-&gt;vi_irte
)paren
suffix:semicolon
multiline_comment|/* data is initialized by fixup_irq */
id|ASSERT
c_func
(paren
l_int|0
OL
id|vi-&gt;vi_txn_irq
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0UL
op_ne
id|vi-&gt;vi_txn_addr
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0UL
op_ne
id|vi-&gt;vi_txn_data
)paren
suffix:semicolon
id|iosapic_set_irt_data
c_func
(paren
id|vi
comma
op_amp
id|d0
comma
op_amp
id|d1
)paren
suffix:semicolon
id|iosapic_wr_irt_entry
c_func
(paren
id|vi
comma
id|d0
comma
id|d1
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IOSAPIC_IRT
(brace
id|u32
op_star
id|t
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
id|ulong
)paren
id|vi-&gt;vi_eoi_addr
op_amp
op_complement
l_int|0xffUL
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;iosapic_enable_irq(): regs %p&quot;
comma
id|vi-&gt;vi_eoi_addr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|t
OL
id|vi-&gt;vi_eoi_addr
)paren
id|printk
c_func
(paren
l_string|&quot; %x&quot;
comma
id|READ_U32
c_func
(paren
id|t
op_increment
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;iosapic_enable_irq(): sel &quot;
)paren
suffix:semicolon
(brace
r_struct
id|iosapic_info
op_star
id|isp
op_assign
id|vi-&gt;vi_ios
suffix:semicolon
r_for
c_loop
(paren
id|d0
op_assign
l_int|0x10
suffix:semicolon
id|d0
OL
l_int|0x1e
suffix:semicolon
id|d0
op_increment
)paren
(brace
multiline_comment|/* point the window register to the lower word */
id|WRITE_U32
c_func
(paren
id|d0
comma
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
multiline_comment|/* read the word */
id|d1
op_assign
id|READ_U32
c_func
(paren
id|isp-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %x&quot;
comma
id|d1
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** KLUGE: IRQ should not be asserted when Drivers enabling their IRQ.&n;&t;**        PCI supports level triggered in order to share IRQ lines.&n;&t;**&n;&t;** Issueing I/O SAPIC an EOI causes an interrupt iff IRQ line is&n;&t;** asserted.&n;&t;*/
id|IOSAPIC_EOI
c_func
(paren
id|vi-&gt;vi_eoi_addr
comma
id|vi-&gt;vi_eoi_data
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_mask_irq
id|iosapic_mask_irq
c_func
(paren
r_void
op_star
id|dev
comma
r_int
id|irq
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_unmask_irq
id|iosapic_unmask_irq
c_func
(paren
r_void
op_star
id|dev
comma
r_int
id|irq
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|iosapic_irq_ops
r_static
r_struct
id|irq_region_ops
id|iosapic_irq_ops
op_assign
(brace
id|iosapic_disable_irq
comma
id|iosapic_enable_irq
comma
id|iosapic_mask_irq
comma
id|iosapic_unmask_irq
)brace
suffix:semicolon
multiline_comment|/*&n;** squirrel away the I/O Sapic Version&n;*/
r_static
r_int
r_int
DECL|function|iosapic_rd_version
id|iosapic_rd_version
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
)paren
(brace
id|ASSERT
c_func
(paren
id|isi
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|isi-&gt;isi_hpa
)paren
suffix:semicolon
multiline_comment|/* point window to the version register */
id|WRITE_U32
c_func
(paren
id|IOSAPIC_REG_VERSION
comma
id|isi-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_SELECT
)paren
suffix:semicolon
multiline_comment|/* now read the version register */
r_return
(paren
id|READ_U32
c_func
(paren
id|isi-&gt;isi_hpa
op_plus
id|IOSAPIC_REG_WINDOW
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifndef IOSAPIC_CALLBACK
multiline_comment|/*&n;** iosapic_register() is the alternative to iosapic_driver_for().&n;** (Only one or the other should be implemented.)&n;*/
multiline_comment|/*&n;** iosapic_register() is called by &quot;drivers&quot; with an integrated I/O SAPIC.&n;** Caller must be certain they have an I/O SAPIC and know it&squot;s MMIO address.&n;**&n;**&t;o allocate iosapic_info and add it to the list&n;**&t;o read iosapic version and squirrel that away&n;**&t;o read size of IRdT.&n;**&t;o allocate and initialize isi_vector[]&n;**&t;o allocate isi_region (registers region handlers)&n;*/
r_void
op_star
DECL|function|iosapic_register
id|iosapic_register
c_func
(paren
r_void
op_star
id|hpa
)paren
(brace
r_struct
id|iosapic_info
op_star
id|isi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|irt_entry
op_star
id|irte
op_assign
id|irt_cell
suffix:semicolon
r_struct
id|vector_info
op_star
id|vip
suffix:semicolon
r_int
id|cnt
suffix:semicolon
multiline_comment|/* track how many entries we&squot;ve looked at */
multiline_comment|/*&n;&t;** Astro based platforms can&squot;t support PCI OLARD if they&n;&t;** implement the legacy PDC (not PAT). Though Legacy PDC&n;&t;** supports an IRT, LBA&squot;s with no device under them&n;&t;** are *not* listed in the IRT.&n;&t;** Search the IRT and ignore iosapic&squot;s which aren&squot;t&n;&t;** in the IRT.&n;&t;*/
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|irte
)paren
suffix:semicolon
multiline_comment|/* always have built-in devices */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|irt_num_entry
suffix:semicolon
id|cnt
op_increment
comma
id|irte
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|IRT_IOSAPIC_TYPE
op_eq
id|irte-&gt;entry_type
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** We need sign extension of the hpa on 32-bit kernels.&n;&t;&t;** The address in the IRT is *always* 64 bit and really&n;&t;&t;** is an unsigned quantity (like all physical addresses).&n;&t;&t;*/
r_if
c_cond
(paren
id|irte-&gt;dest_iosapic_addr
op_eq
(paren
id|s64
)paren
(paren
(paren
r_int
)paren
id|hpa
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
op_ge
id|irt_num_entry
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isi
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|iosapic_info
comma
l_int|1
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|isi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|iosapic_info
)paren
)paren
suffix:semicolon
id|isi-&gt;isi_hpa
op_assign
(paren
r_int
r_char
op_star
)paren
id|hpa
suffix:semicolon
id|isi-&gt;isi_version
op_assign
id|iosapic_rd_version
c_func
(paren
id|isi
)paren
suffix:semicolon
id|isi-&gt;isi_num_vectors
op_assign
id|IOSAPIC_IRDT_MAX_ENTRY
c_func
(paren
id|isi-&gt;isi_version
)paren
op_plus
l_int|1
suffix:semicolon
id|vip
op_assign
id|isi-&gt;isi_vector
op_assign
id|IOSAPIC_KALLOC
c_func
(paren
r_struct
id|vector_info
comma
id|isi-&gt;isi_num_vectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vip
op_eq
l_int|NULL
)paren
(brace
id|IOSAPIC_FREE
c_func
(paren
id|isi
comma
r_struct
id|iosapic_info
comma
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|vip
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|vector_info
)paren
op_star
id|isi-&gt;isi_num_vectors
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Initialize vector array&n;&t;*/
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|isi-&gt;isi_num_vectors
suffix:semicolon
id|cnt
op_increment
comma
id|vip
op_increment
)paren
(brace
id|vip-&gt;vi_irqline
op_assign
(paren
r_int
r_char
)paren
id|cnt
suffix:semicolon
id|vip-&gt;vi_ios
op_assign
id|isi
suffix:semicolon
)brace
id|isi-&gt;isi_region
op_assign
id|alloc_irq_region
c_func
(paren
id|isi-&gt;isi_num_vectors
comma
op_amp
id|iosapic_irq_ops
comma
id|IRQ_REG_DIS
op_or
id|IRQ_REG_MASK
comma
l_string|&quot;I/O Sapic&quot;
comma
(paren
r_void
op_star
)paren
id|isi-&gt;isi_vector
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|isi-&gt;isi_region
)paren
suffix:semicolon
r_return
(paren
(paren
r_void
op_star
)paren
id|isi
)paren
suffix:semicolon
)brace
macro_line|#endif /* !IOSAPIC_CALLBACK */
macro_line|#ifdef DEBUG_IOSAPIC
r_static
r_void
DECL|function|iosapic_prt_irt
id|iosapic_prt_irt
c_func
(paren
r_void
op_star
id|irt
comma
r_int
id|num_entry
)paren
(brace
r_int
r_int
id|i
comma
op_star
id|irp
op_assign
(paren
r_int
r_int
op_star
)paren
id|irt
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|irt
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|MODULE_NAME
l_string|&quot;: Interrupt Routing Table (%lx entries)&bslash;n&quot;
comma
id|num_entry
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_entry
suffix:semicolon
id|i
op_increment
comma
id|irp
op_add_assign
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%p : %2d %.8x %.8x %.8x %.8x&bslash;n&quot;
comma
id|irp
comma
id|i
comma
id|irp
(braket
l_int|0
)braket
comma
id|irp
(braket
l_int|1
)braket
comma
id|irp
(braket
l_int|2
)braket
comma
id|irp
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|iosapic_prt_vi
id|iosapic_prt_vi
c_func
(paren
r_struct
id|vector_info
op_star
id|vi
)paren
(brace
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|vi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|MODULE_NAME
l_string|&quot;: vector_info[%d] is at %p&bslash;n&quot;
comma
id|vi-&gt;vi_irqline
comma
id|vi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tvi_status:&t; %.4x&bslash;n&quot;
comma
id|vi-&gt;vi_status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tvi_txn_irq:  %d&bslash;n&quot;
comma
id|vi-&gt;vi_txn_irq
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tvi_txn_addr: %lx&bslash;n&quot;
comma
id|vi-&gt;vi_txn_addr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tvi_txn_data: %lx&bslash;n&quot;
comma
id|vi-&gt;vi_txn_data
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tvi_eoi_addr: %p&bslash;n&quot;
comma
id|vi-&gt;vi_eoi_addr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tvi_eoi_data: %x&bslash;n&quot;
comma
id|vi-&gt;vi_eoi_data
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|iosapic_prt_isi
id|iosapic_prt_isi
c_func
(paren
r_struct
id|iosapic_info
op_star
id|isi
)paren
(brace
id|ASSERT
c_func
(paren
l_int|NULL
op_ne
id|isi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|MODULE_NAME
l_string|&quot;: io_sapic_info at %p&bslash;n&quot;
comma
id|isi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_hpa: %p&bslash;n&quot;
comma
id|isi-&gt;isi_hpa
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_satus:     %x&bslash;n&quot;
comma
id|isi-&gt;isi_status
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_version:   %x&bslash;n&quot;
comma
id|isi-&gt;isi_version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;t&bslash;tisi_vector:    %p&bslash;n&quot;
comma
id|isi-&gt;isi_vector
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_IOSAPIC */
eof
