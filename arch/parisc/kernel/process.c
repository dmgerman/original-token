multiline_comment|/*&n; *  linux/arch/parisc/kernel/process.c&n; *&t;based on the work for i386&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of process handling..&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/offset.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/gsc.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
DECL|variable|semaphore_wake_lock
id|spinlock_t
id|semaphore_wake_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/* The 64-bit code should work equally well in 32-bit land but I didn&squot;t&n; * want to take the time to confirm that.  -PB&n; */
r_extern
r_int
r_int
id|ret_from_kernel_thread
suffix:semicolon
macro_line|#else
id|asmlinkage
r_void
id|ret_from_kernel_thread
c_func
(paren
r_void
)paren
id|__asm__
c_func
(paren
l_string|&quot;ret_from_kernel_thread&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|hlt_counter
r_int
id|hlt_counter
op_assign
l_int|0
suffix:semicolon
DECL|function|disable_hlt
r_void
id|disable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_increment
suffix:semicolon
)brace
DECL|function|enable_hlt
r_void
id|enable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * The idle thread. There&squot;s no useful work to be&n; * done, so just try to conserve power and have a&n; * low exit latency (ie sit in a loop waiting for&n; * somebody to say that they&squot;d like to reschedule)&n; */
DECL|function|cpu_idle
r_void
id|cpu_idle
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* endless idle loop with no priority at all */
id|init_idle
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;nice
op_assign
l_int|20
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|current-&gt;need_resched
)paren
(brace
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|check_pgt_cache
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|reboot_setup
r_void
id|__init
id|reboot_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
)brace
DECL|variable|mach_notifier
r_struct
id|notifier_block
op_star
id|mach_notifier
suffix:semicolon
DECL|function|machine_restart
r_void
id|machine_restart
c_func
(paren
r_char
op_star
id|ptr
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|mach_notifier
comma
id|MACH_RESTART
comma
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|machine_halt
r_void
id|machine_halt
c_func
(paren
r_void
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|mach_notifier
comma
id|MACH_HALT
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|machine_power_on
r_void
id|machine_power_on
c_func
(paren
r_void
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|mach_notifier
comma
id|MACH_POWER_ON
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|machine_power_off
r_void
id|machine_power_off
c_func
(paren
r_void
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|mach_notifier
comma
id|MACH_POWER_OFF
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|machine_heartbeat
r_void
id|machine_heartbeat
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/*&n; * Create a kernel thread&n; */
r_extern
id|pid_t
id|__kernel_thread
c_func
(paren
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
comma
r_int
r_int
id|flags
)paren
suffix:semicolon
DECL|function|kernel_thread
id|pid_t
id|kernel_thread
c_func
(paren
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
comma
r_int
r_int
id|flags
)paren
(brace
multiline_comment|/*&n;&t; * FIXME: Once we are sure we don&squot;t need any debug here,&n;&t; *&t;  kernel_thread can become a #define.&n;&t; */
r_return
id|__kernel_thread
c_func
(paren
id|fn
comma
id|arg
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free current thread data structures etc..&n; */
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
id|set_fs
c_func
(paren
id|USER_DS
)paren
suffix:semicolon
)brace
DECL|function|release_thread
r_void
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|dead_task
)paren
(brace
)brace
multiline_comment|/*&n; * Fill in the FPU structure for a core dump.&n; */
DECL|function|dump_fpu
r_int
id|dump_fpu
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|elf_fpregset_t
op_star
id|r
)paren
(brace
id|memcpy
c_func
(paren
id|r
comma
id|regs-&gt;fr
comma
r_sizeof
op_star
id|r
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Note that &quot;fork()&quot; is implemented in terms of clone, with&n;   parameters (SIGCHLD, regs-&gt;gr[30], regs). */
r_int
DECL|function|sys_clone
id|sys_clone
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|usp
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|clone_flags
comma
id|usp
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|sys_vfork
id|sys_vfork
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|CLONE_VFORK
op_or
id|CLONE_VM
op_or
id|SIGCHLD
comma
id|regs-&gt;gr
(braket
l_int|30
)braket
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|copy_thread
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|usp
comma
r_int
r_int
id|unused
comma
multiline_comment|/* in ia64 this is &quot;user_stack_size&quot; */
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_struct
id|pt_regs
op_star
id|cregs
op_assign
op_amp
(paren
id|p-&gt;thread.regs
)paren
suffix:semicolon
r_int
id|ksp
suffix:semicolon
op_star
id|cregs
op_assign
op_star
id|pregs
suffix:semicolon
multiline_comment|/* Set the return value for the child.  Note that this is not&n;           actually restored by the syscall exit path, but we put it&n;           here for consistency in case of signals. */
id|cregs-&gt;gr
(braket
l_int|28
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* child */
multiline_comment|/*&n;&t; * We need to differentiate between a user fork and a&n;&t; * kernel fork. We can&squot;t use user_mode, because the&n;&t; * the syscall path doesn&squot;t save iaoq. Right now&n;&t; * We rely on the fact that kernel_thread passes&n;&t; * in zero for usp.&n;&t; */
r_if
c_cond
(paren
id|usp
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Kernel Thread */
id|ksp
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
(paren
id|p
)paren
)paren
op_plus
id|TASK_SZ_ALGN
)paren
suffix:semicolon
id|cregs-&gt;ksp
op_assign
id|ksp
suffix:semicolon
multiline_comment|/* always return to kernel */
macro_line|#ifdef __LP64__
id|cregs-&gt;kpc
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ret_from_kernel_thread
suffix:semicolon
macro_line|#else
id|cregs-&gt;kpc
op_assign
(paren
r_int
r_int
)paren
id|ret_from_kernel_thread
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Copy function and argument to be called from&n;&t;&t; * ret_from_kernel_thread.&n;&t;&t; */
id|cregs-&gt;gr
(braket
l_int|26
)braket
op_assign
id|pregs-&gt;gr
(braket
l_int|26
)braket
suffix:semicolon
id|cregs-&gt;gr
(braket
l_int|25
)braket
op_assign
id|pregs-&gt;gr
(braket
l_int|25
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* User Thread:&n;&t;&t; *&n;&t;&t; * Use same stack depth as parent when in wrapper&n;&t;&t; *&n;&t;&t; * Note that the fork wrappers are responsible&n;&t;&t; * for setting gr[20] and gr[21].&n;&t;&t; */
id|cregs-&gt;ksp
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|p
)paren
)paren
op_plus
(paren
id|pregs-&gt;gr
(braket
l_int|20
)braket
op_amp
(paren
id|INIT_TASK_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|cregs-&gt;kpc
op_assign
id|pregs-&gt;gr
(braket
l_int|21
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_execve() executes a new program.&n; */
DECL|function|sys_execve
id|asmlinkage
r_int
id|sys_execve
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
(paren
r_char
op_star
)paren
id|regs-&gt;gr
(braket
l_int|26
)braket
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
(paren
r_char
op_star
op_star
)paren
id|regs-&gt;gr
(braket
l_int|25
)braket
comma
(paren
r_char
op_star
op_star
)paren
id|regs-&gt;gr
(braket
l_int|24
)braket
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|current-&gt;ptrace
op_and_assign
op_complement
id|PT_DTRACE
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
eof
