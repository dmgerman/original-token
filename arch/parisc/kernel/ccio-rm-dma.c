multiline_comment|/*&n; * ccio-rm-dma.c:&n; *&t;DMA management routines for first generation cache-coherent machines.&n; *&t;&quot;Real Mode&quot; operation refers to U2/Uturn chip operation. The chip&n; *      can perform coherency checks w/o using the I/O MMU. That&squot;s all we&n; *      need until support for more than 4GB phys mem is needed.&n; * &n; *&t;This is the trivial case - basically what x86 does.&n; *&n; *&t;Drawbacks of using Real Mode are:&n; *&t;o outbound DMA is slower since one isn&squot;t using the prefetching&n; *&t;  U2 can do for outbound DMA.&n; *&t;o Ability to do scatter/gather in HW is also lost.&n; *      o only known to work with PCX-W processor. (eg C360)&n; *        (PCX-U/U+ are not coherent with U2 in real mode.)&n; *&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; *&n; * Original version/author:&n; *      CVSROOT=:pserver:anonymous@198.186.203.37:/cvsroot/linux-parisc&n; *      cvs -z3 co linux/arch/parisc/kernel/dma-rm.c&n; *&n; *&t;(C) Copyright 2000 Philipp Rumpf &lt;prumpf@tux.org&gt;&n; *&n; *&n; * Adopted for The Puffin Group&squot;s parisc-linux port by Grant Grundler.&n; *&t;(C) Copyright 2000 Grant Grundler &lt;grundler@puffin.external.hp.com&gt;&n; *&t;&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/page.h&gt;
multiline_comment|/* Only chose &quot;ccio&quot; since that&squot;s what HP-UX calls it....&n;** Make it easier for folks to migrate from one to the other :^)&n;*/
DECL|macro|MODULE_NAME
mdefine_line|#define MODULE_NAME &quot;ccio&quot;
DECL|macro|U2_IOA_RUNWAY
mdefine_line|#define U2_IOA_RUNWAY 0x580
DECL|macro|U2_BC_GSC
mdefine_line|#define U2_BC_GSC     0x501
DECL|macro|UTURN_IOA_RUNWAY
mdefine_line|#define UTURN_IOA_RUNWAY 0x581
DECL|macro|UTURN_BC_GSC
mdefine_line|#define UTURN_BC_GSC     0x502
r_static
r_int
id|ccio_driver_callback
c_func
(paren
r_struct
id|hp_device
op_star
comma
r_struct
id|pa_iodc_driver
op_star
)paren
suffix:semicolon
DECL|variable|ccio_drivers_for
r_static
r_struct
id|pa_iodc_driver
id|ccio_drivers_for
(braket
)braket
op_assign
(brace
(brace
id|HPHW_BCPORT
comma
id|U2_BC_GSC
comma
l_int|0x0
comma
l_int|0xb
comma
l_int|0
comma
l_int|0x10
comma
id|DRIVER_CHECK_HVERSION
op_plus
id|DRIVER_CHECK_SVERSION
op_plus
id|DRIVER_CHECK_HWTYPE
comma
id|MODULE_NAME
comma
l_string|&quot;U2 I/O MMU&quot;
comma
(paren
r_void
op_star
)paren
id|ccio_driver_callback
)brace
comma
(brace
id|HPHW_BCPORT
comma
id|UTURN_BC_GSC
comma
l_int|0x0
comma
l_int|0xb
comma
l_int|0
comma
l_int|0x10
comma
id|DRIVER_CHECK_HVERSION
op_plus
id|DRIVER_CHECK_SVERSION
op_plus
id|DRIVER_CHECK_HWTYPE
comma
id|MODULE_NAME
comma
l_string|&quot;Uturn I/O MMU&quot;
comma
(paren
r_void
op_star
)paren
id|ccio_driver_callback
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|macro|IS_U2
mdefine_line|#define IS_U2(id) ( &bslash;&n;    (((id)-&gt;hw_type == HPHW_IOA) &amp;&amp; ((id)-&gt;hversion == U2_IOA_RUNWAY)) || &bslash;&n;    (((id)-&gt;hw_type == HPHW_BCPORT) &amp;&amp; ((id)-&gt;hversion == U2_BC_GSC))  &bslash;&n;)
DECL|macro|IS_UTURN
mdefine_line|#define IS_UTURN(id) ( &bslash;&n;    (((id)-&gt;hw_type == HPHW_IOA) &amp;&amp; ((id)-&gt;hversion == UTURN_IOA_RUNWAY)) || &bslash;&n;    (((id)-&gt;hw_type == HPHW_BCPORT) &amp;&amp; ((id)-&gt;hversion == UTURN_BC_GSC))  &bslash;&n;)
DECL|function|ccio_init
r_void
id|__init
id|ccio_init
c_func
(paren
r_void
)paren
(brace
id|register_driver
c_func
(paren
id|ccio_drivers_for
)paren
suffix:semicolon
)brace
DECL|function|ccio_dma_supported
r_static
r_int
id|ccio_dma_supported
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|dma_addr_t
id|mask
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|MODULE_NAME
l_string|&quot;: EISA/ISA/et al not supported&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev-&gt;dma_mask
op_assign
id|mask
suffix:semicolon
multiline_comment|/* save it */
multiline_comment|/* only support 32-bit devices (ie PCI/GSC) */
r_return
(paren
r_int
)paren
(paren
id|mask
op_ge
l_int|0xffffffffUL
)paren
suffix:semicolon
)brace
DECL|function|ccio_alloc_consistent
r_static
r_void
op_star
id|ccio_alloc_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|handle
)paren
(brace
r_void
op_star
id|ret
suffix:semicolon
id|ret
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
op_star
id|handle
op_assign
id|virt_to_phys
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ccio_free_consistent
r_static
r_void
id|ccio_free_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|handle
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
DECL|function|ccio_map_single
r_static
id|dma_addr_t
id|ccio_map_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_return
id|virt_to_phys
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|ccio_unmap_single
r_static
r_void
id|ccio_unmap_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
multiline_comment|/* Nothing to do */
)brace
DECL|function|ccio_map_sg
r_static
r_int
id|ccio_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_int
id|tmp
op_assign
id|nents
suffix:semicolon
multiline_comment|/* KISS: map each buffer seperately. */
r_while
c_loop
(paren
id|nents
)paren
(brace
id|sg_dma_address
c_func
(paren
id|sglist
)paren
op_assign
id|ccio_map_single
c_func
(paren
id|dev
comma
id|sglist-&gt;address
comma
id|sglist-&gt;length
comma
id|direction
)paren
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|sglist
)paren
op_assign
id|sglist-&gt;length
suffix:semicolon
id|nents
op_decrement
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|ccio_unmap_sg
r_static
r_void
id|ccio_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
macro_line|#if 0
r_while
c_loop
(paren
id|nents
)paren
(brace
id|ccio_unmap_single
c_func
(paren
id|dev
comma
id|sg_dma_address
c_func
(paren
id|sglist
)paren
comma
id|sg_dma_len
c_func
(paren
id|sglist
)paren
comma
id|direction
)paren
suffix:semicolon
id|nents
op_decrement
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#else
multiline_comment|/* Do nothing (copied from current ccio_unmap_single()  :^) */
macro_line|#endif
)brace
DECL|variable|ccio_ops
r_static
r_struct
id|pci_dma_ops
id|ccio_ops
op_assign
(brace
id|ccio_dma_supported
comma
id|ccio_alloc_consistent
comma
id|ccio_free_consistent
comma
id|ccio_map_single
comma
id|ccio_unmap_single
comma
id|ccio_map_sg
comma
id|ccio_unmap_sg
comma
l_int|NULL
comma
multiline_comment|/* dma_sync_single : NOP for U2 */
l_int|NULL
comma
multiline_comment|/* dma_sync_sg     : ditto */
)brace
suffix:semicolon
multiline_comment|/*&n;** Determine if u2 should claim this chip (return 0) or not (return 1).&n;** If so, initialize the chip and tell other partners in crime they&n;** have work to do.&n;*/
r_static
r_int
DECL|function|ccio_driver_callback
id|ccio_driver_callback
c_func
(paren
r_struct
id|hp_device
op_star
id|d
comma
r_struct
id|pa_iodc_driver
op_star
id|dri
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s found %s at 0x%p&bslash;n&quot;
comma
id|dri-&gt;name
comma
id|dri-&gt;version
comma
id|d-&gt;hpa
)paren
suffix:semicolon
multiline_comment|/*&n;** FIXME - should check U2 registers to verify it&squot;s really running&n;** in &quot;Real Mode&quot;.&n;*/
macro_line|#if 0
multiline_comment|/* will need this for &quot;Virtual Mode&quot; operation */
id|ccio_hw_init
c_func
(paren
id|ccio_dev
)paren
suffix:semicolon
id|ccio_common_init
c_func
(paren
id|ccio_dev
)paren
suffix:semicolon
macro_line|#endif
id|hppa_dma_ops
op_assign
op_amp
id|ccio_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
