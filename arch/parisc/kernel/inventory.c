multiline_comment|/* Copyright (c) 1999 The Puffin Group */
multiline_comment|/* Written by David Kennedy and Alex deVries */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
multiline_comment|/*&n;** Debug options&n;**    DEBUG_PAT&t;Dump details which PDC PAT provides about ranges/devices.&n;*/
DECL|macro|DEBUG_PAT
macro_line|#undef DEBUG_PAT
r_extern
r_char
op_star
id|parisc_getHWtype
c_func
(paren
r_int
r_int
id|hw_type
)paren
suffix:semicolon
r_extern
r_struct
id|hp_device
op_star
id|register_module
c_func
(paren
r_void
op_star
id|hpa
)paren
suffix:semicolon
r_extern
r_void
id|print_devices
c_func
(paren
r_char
op_star
id|buf
)paren
suffix:semicolon
r_int
id|pdc_hpa_processor
c_func
(paren
r_void
op_star
id|address
)paren
suffix:semicolon
macro_line|#ifndef __LP64__ 
DECL|variable|iodc_data
r_static
id|u8
id|iodc_data
(braket
l_int|32
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
DECL|variable|model
r_static
r_struct
id|pdc_model
id|model
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|pdc_result
r_static
r_int
r_int
id|pdc_result
(braket
l_int|32
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|processor_hpa
r_static
r_struct
id|pdc_hpa
id|processor_hpa
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
DECL|variable|module_result
r_static
r_struct
id|pdc_system_map
id|module_result
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
DECL|variable|module_path
r_static
r_struct
id|pdc_module_path
id|module_path
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
macro_line|#include &lt;asm/pdcpat.h&gt;
DECL|variable|pdc_pat
r_int
id|pdc_pat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;**  The module object is filled via PDC_PAT_CELL[Return Cell Module].&n;**  If a module is found, register module will get the IODC bytes via&n;**  pdc_iodc_read() using the PA view of conf_base_addr for the hpa parameter.&n;**&n;**  The IO view can be used by PDC_PAT_CELL[Return Cell Module]&n;**  only for SBAs and LBAs.  This view will cause an invalid&n;**  argument error for all other cell module types.&n;**&n;*/
r_static
r_int
DECL|function|pat_query_module
id|pat_query_module
c_func
(paren
id|ulong
id|pcell_loc
comma
id|ulong
id|mod_index
)paren
(brace
r_extern
r_int
id|num_devices
suffix:semicolon
r_extern
r_struct
id|hp_device
id|devices
(braket
)braket
suffix:semicolon
id|pdc_pat_cell_mod_maddr_block_t
id|pa_pdc_cell
suffix:semicolon
r_struct
id|hp_device
op_star
id|dev
op_assign
op_amp
id|devices
(braket
id|num_devices
)braket
suffix:semicolon
r_uint64
id|temp
suffix:semicolon
multiline_comment|/* 64-bit scratch value */
r_int
id|status
suffix:semicolon
multiline_comment|/* PDC return value status */
multiline_comment|/* return cell module (PA or Processor view) */
id|status
op_assign
id|pdc_pat_cell_module
c_func
(paren
op_amp
id|pdc_result
comma
id|pcell_loc
comma
id|mod_index
comma
id|PA_VIEW
comma
op_amp
id|pa_pdc_cell
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|PDC_RET_OK
)paren
(brace
multiline_comment|/* no more cell modules or error */
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** save parameters in the hp_device&n;&t;** (The idea being the device driver will call pdc_pat_cell_module()&n;&t;** and store the results in it&squot;s own data structure.)&n;&t;*/
id|dev-&gt;pcell_loc
op_assign
id|pcell_loc
suffix:semicolon
id|dev-&gt;mod_index
op_assign
id|mod_index
suffix:semicolon
multiline_comment|/* save generic info returned from the call */
multiline_comment|/* REVISIT: who is the consumer of this? not sure yet... */
id|dev-&gt;mod_info
op_assign
id|pa_pdc_cell.mod_info
suffix:semicolon
multiline_comment|/* pass to PAT_GET_ENTITY() */
id|dev-&gt;pmod_loc
op_assign
id|pa_pdc_cell.mod_location
suffix:semicolon
id|dev-&gt;mod_path
op_assign
id|pa_pdc_cell.mod_path
suffix:semicolon
id|temp
op_assign
id|pa_pdc_cell.cba
suffix:semicolon
id|register_module
c_func
(paren
(paren
r_void
op_star
)paren
id|PAT_GET_CBA
c_func
(paren
id|temp
)paren
)paren
suffix:semicolon
multiline_comment|/* fills in dev-&gt;hpa */
macro_line|#ifdef DEBUG_PAT
multiline_comment|/* dump what we see so far... */
r_switch
c_cond
(paren
id|PAT_GET_ENTITY
c_func
(paren
id|dev-&gt;mod_info
)paren
)paren
(brace
id|ulong
id|i
suffix:semicolon
r_case
id|PAT_ENTITY_PROC
suffix:colon
id|printk
(paren
l_string|&quot;PAT_ENTITY_PROC: id_eid 0x%lx&bslash;n&quot;
comma
id|pa_pdc_cell.mod
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_ENTITY_MEM
suffix:colon
id|printk
(paren
l_string|&quot;PAT_ENTITY_MEM: amount 0x%lx min_gni_base 0x%lx min_gni_len 0x%lx&bslash;n&quot;
comma
id|pa_pdc_cell.mod
(braket
l_int|0
)braket
comma
id|pa_pdc_cell.mod
(braket
l_int|1
)braket
comma
id|pa_pdc_cell.mod
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_ENTITY_CA
suffix:colon
id|printk
(paren
l_string|&quot;PAT_ENTITY_CA: %ld&bslash;n&quot;
comma
id|pcell_loc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PAT_ENTITY_PBC
suffix:colon
id|printk
(paren
l_string|&quot;PAT_ENTITY_PBC: &quot;
)paren
suffix:semicolon
r_goto
id|print_ranges
suffix:semicolon
r_case
id|PAT_ENTITY_SBA
suffix:colon
id|printk
(paren
l_string|&quot;PAT_ENTITY_SBA: &quot;
)paren
suffix:semicolon
r_goto
id|print_ranges
suffix:semicolon
r_case
id|PAT_ENTITY_LBA
suffix:colon
id|printk
(paren
l_string|&quot;PAT_ENTITY_LBA: &quot;
)paren
suffix:semicolon
id|print_ranges
suffix:colon
id|printk
(paren
l_string|&quot;ranges %ld&bslash;n&quot;
comma
id|pa_pdc_cell.mod
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pa_pdc_cell.mod
(braket
l_int|1
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;&t;%ld: 0x%016lx 0x%016lx 0x%016lx&bslash;n&quot;
comma
id|i
comma
id|pa_pdc_cell.mod
(braket
l_int|2
op_plus
id|i
op_star
l_int|3
)braket
comma
multiline_comment|/* type */
id|pa_pdc_cell.mod
(braket
l_int|3
op_plus
id|i
op_star
l_int|3
)braket
comma
multiline_comment|/* start */
id|pa_pdc_cell.mod
(braket
l_int|4
op_plus
id|i
op_star
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* finish (ie end) */
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_PAT */
r_return
id|PDC_RET_OK
suffix:semicolon
)brace
DECL|function|do_pat_inventory
r_static
r_int
id|do_pat_inventory
c_func
(paren
r_void
)paren
(brace
id|ulong
id|mod_index
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
id|ulong
id|cell_num
suffix:semicolon
id|ulong
id|pcell_loc
suffix:semicolon
id|pdc_pat
op_assign
(paren
id|pdc_pat_cell_get_number
c_func
(paren
op_amp
id|pdc_result
)paren
op_eq
id|PDC_OK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdc_pat
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|cell_num
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Cell number call was made */
multiline_comment|/* As of PDC PAT ARS 2.5, ret[1] is NOT architected! */
id|pcell_loc
op_assign
id|pdc_result
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Physical location of the cell */
macro_line|#ifdef DEBUG_PAT
id|printk
c_func
(paren
l_string|&quot;CELL_GET_NUMBER: 0x%lx 0x%lx&bslash;n&quot;
comma
id|cell_num
comma
id|pcell_loc
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|pdc_pat_cell_num_to_loc
c_func
(paren
op_amp
id|pdc_result
comma
id|cell_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|PDC_BAD_OPTION
)paren
(brace
multiline_comment|/* Prelude (and it&squot;s successors: Lclass, A400/500) only&n;&t;&t;** implement PDC_PAT_CELL sub-options 0 and 2.&n;&t;&t;** &quot;Home cook&squot;n is best anyhow!&quot;&n;&t;&t;*/
)brace
r_else
r_if
c_cond
(paren
id|PDC_OK
op_eq
id|status
)paren
(brace
multiline_comment|/* so far only Halfdome supports this */
id|pcell_loc
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;WTF? CELL_GET_NUMBER give me invalid cell number?&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|PDC_RET_OK
op_eq
id|pat_query_module
c_func
(paren
id|pcell_loc
comma
id|mod_index
)paren
)paren
(brace
id|mod_index
op_increment
suffix:semicolon
)brace
r_return
id|mod_index
suffix:semicolon
)brace
macro_line|#endif /* __LP64__ */
DECL|function|do_newer_workstation_inventory
r_static
r_int
id|do_newer_workstation_inventory
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|i
comma
id|num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* So the idea here is to simply try one SYSTEM_MAP call.  If &n;&t;   that one works, great, otherwise do it another way */
id|status
op_assign
id|pdc_system_map_find_mods
c_func
(paren
op_amp
id|module_result
comma
op_amp
id|module_path
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|PDC_RET_OK
)paren
(brace
multiline_comment|/* This is for newer non-PDC-PAT boxes */
id|printk
c_func
(paren
l_string|&quot;a newer box...&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|status
op_assign
id|PDC_RET_OK
suffix:semicolon
id|status
op_ne
id|PDC_RET_NE_PROC
op_logical_and
id|status
op_ne
id|PDC_RET_NE_MOD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|status
op_assign
id|pdc_system_map_find_mods
c_func
(paren
op_amp
id|module_result
comma
op_amp
id|module_path
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|PDC_RET_OK
)paren
(brace
id|num
op_increment
suffix:semicolon
id|register_module
c_func
(paren
id|module_result.mod_addr
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
id|num
OG
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifndef __LP64__
DECL|variable|r_addr
r_static
r_struct
id|pdc_memory_map
id|r_addr
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
DECL|function|really_do_oldhw_inventory
r_static
r_int
id|really_do_oldhw_inventory
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|mod
comma
id|num
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_int
id|hw_type
suffix:semicolon
r_int
r_int
id|func
suffix:semicolon
multiline_comment|/* This is undocumented at the time of writing, but basically &n;&t;   we&squot;re setting up mod_path so that bc[0..4]=0xff, and step&n;&t;   through mod to get the &quot;Path Structure for GSC Modules&quot;.  If&n;&t;   it works, use the returned HPA and determine the hardware type.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|module_path.bc
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
l_int|0
suffix:semicolon
id|mod
OL
l_int|16
suffix:semicolon
id|mod
op_increment
)paren
(brace
r_char
op_star
id|stype
op_assign
l_int|NULL
suffix:semicolon
id|module_path.mod
op_assign
id|mod
suffix:semicolon
id|status
op_assign
id|pdc_mem_map_hpa
c_func
(paren
op_amp
id|r_addr
comma
op_amp
id|module_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|PDC_RET_OK
)paren
r_continue
suffix:semicolon
id|status
op_assign
id|pdc_iodc_read
c_func
(paren
op_amp
id|pdc_result
comma
(paren
r_void
op_star
)paren
id|r_addr.hpa
comma
l_int|0
comma
op_amp
id|iodc_data
comma
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|PDC_RET_OK
)paren
r_continue
suffix:semicolon
id|hw_type
op_assign
id|iodc_data
(braket
l_int|3
)braket
op_amp
l_int|0x1f
suffix:semicolon
r_switch
c_cond
(paren
id|hw_type
)paren
(brace
r_case
id|HPHW_NPROC
suffix:colon
multiline_comment|/* 0 */
id|stype
op_assign
l_string|&quot;Processor&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_MEMORY
suffix:colon
multiline_comment|/* 1 */
id|stype
op_assign
l_string|&quot;Memory&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_B_DMA
suffix:colon
multiline_comment|/* 2 */
id|stype
op_assign
l_string|&quot;Type B DMA&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_A_DMA
suffix:colon
multiline_comment|/* 4 */
id|stype
op_assign
l_string|&quot;Type A DMA&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_A_DIRECT
suffix:colon
multiline_comment|/* 5 */
id|stype
op_assign
l_string|&quot;Type A Direct&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_BCPORT
suffix:colon
multiline_comment|/* 7 */
id|stype
op_assign
l_string|&quot;Bus Converter Port&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_CONSOLE
suffix:colon
multiline_comment|/* 9 */
id|stype
op_assign
l_string|&quot;Console&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_FIO
suffix:colon
multiline_comment|/* 10 - Graphics */
id|stype
op_assign
l_string|&quot;Foreign I/O (Graphics)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_BA
suffix:colon
multiline_comment|/* 11 - Bus Adapter */
id|stype
op_assign
l_string|&quot;Bus Adapter&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_IOA
suffix:colon
multiline_comment|/* 12 */
id|stype
op_assign
l_string|&quot;I/O Adapter&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_BRIDGE
suffix:colon
multiline_comment|/* 13 */
id|stype
op_assign
l_string|&quot;Bridge&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_FABRIC
suffix:colon
multiline_comment|/* 14 */
id|stype
op_assign
l_string|&quot;Fabric&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_FAULTY
suffix:colon
multiline_comment|/* 31 */
id|stype
op_assign
l_string|&quot;Faulty HW&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HPHW_OTHER
suffix:colon
multiline_comment|/* 42 */
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Don&squot;t know this hw_type: %d&bslash;n&quot;
comma
id|hw_type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// This is kluged. But don&squot;t want to replicate code for
singleline_comment|// most of the above cases.
r_if
c_cond
(paren
id|stype
)paren
(brace
macro_line|#ifdef DBG_PDC_QUERY
singleline_comment|// parisc/kernel/drivers.c
r_extern
r_int
id|num_devices
suffix:semicolon
r_extern
r_struct
id|hp_device
id|devices
(braket
)braket
suffix:semicolon
r_struct
id|hp_hardware
op_star
id|h
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|pdc_mem_map_hpa
c_func
(paren
op_amp
id|r_addr
comma
op_amp
id|module_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|PDC_RET_OK
op_logical_and
id|register_module
c_func
(paren
(paren
r_void
op_star
)paren
id|r_addr.hpa
)paren
op_ne
l_int|NULL
)paren
id|num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|hw_type
op_eq
id|HPHW_BA
)paren
(brace
multiline_comment|/* Now, we&squot;re checking for devices for each&n;&t;&t;&t;   module.  I seem to think that the&n;&t;&t;&t;   modules in question are Lasi (2), 2nd Lasi (6)&n;&t;&t;&t;   Wax (5).  To do this, set bc[5]=0, and set&n;&t;&t;&t;   bc[4] to the module, and step through the&n;&t;&t;&t;   functions. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|module_path.bc
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
id|module_path.bc
(braket
l_int|4
)braket
op_assign
id|mod
suffix:semicolon
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
l_int|16
suffix:semicolon
id|func
op_increment
)paren
(brace
id|module_path.mod
op_assign
id|func
suffix:semicolon
id|module_path.bc
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|pdc_mem_map_hpa
c_func
(paren
op_amp
id|r_addr
comma
op_amp
id|module_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|PDC_RET_OK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|register_module
c_func
(paren
(paren
r_void
op_star
)paren
id|r_addr.hpa
)paren
op_ne
l_int|NULL
)paren
id|num
op_increment
suffix:semicolon
)brace
)brace
singleline_comment|// reset module_path.bc[]
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|module_path.bc
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
macro_line|#ifdef DBG_PDC_QUERY
singleline_comment|//
singleline_comment|// Let print_devices() dump everything which is registered.
singleline_comment|//
id|h
op_assign
id|devices
(braket
id|num_devices
op_minus
l_int|1
)braket
dot
id|reference
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
id|stype
op_assign
id|h-&gt;name
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Found %s at %d&bslash;n&quot;
comma
id|stype
comma
id|module_path.mod
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_return
id|num
suffix:semicolon
)brace
r_static
r_int
DECL|function|do_old_inventory
id|do_old_inventory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|bus_id
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; an older box...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Here, we&squot;re going to check the model, and decide&n;&t;   if we should even bother trying. */
id|status
op_assign
id|pdc_model_info
c_func
(paren
op_amp
id|model
)paren
suffix:semicolon
id|bus_id
op_assign
(paren
id|model.hversion
op_rshift
(paren
l_int|4
op_plus
l_int|7
)paren
)paren
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* Here, we&squot;re checking the HVERSION of the CPU.&n;&t;   We&squot;re only checking the 0th CPU, since it&squot;ll&n;&t;   be the same on an SMP box. */
r_switch
c_cond
(paren
id|bus_id
)paren
(brace
r_case
l_int|0x4
suffix:colon
multiline_comment|/* 720, 730, 750, 735, 755 */
r_case
l_int|0x6
suffix:colon
multiline_comment|/* 705, 710 */
r_case
l_int|0x7
suffix:colon
multiline_comment|/* 715, 725 */
r_case
l_int|0x8
suffix:colon
multiline_comment|/* 745, 747, 742 */
r_case
l_int|0xA
suffix:colon
multiline_comment|/* 712 and similiar */
r_case
l_int|0xC
suffix:colon
multiline_comment|/* 715/64, at least */
multiline_comment|/* Do inventory using MEM_MAP */
id|really_do_oldhw_inventory
c_func
(paren
)paren
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Everything else */
id|printk
c_func
(paren
l_string|&quot;This is a very very old machine, with a bus_id of 0x%x.&bslash;n&quot;
comma
id|bus_id
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;This will probably never run Linux.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ok
suffix:semicolon
)brace
macro_line|#endif /* !__LP64__ */
DECL|function|do_inventory
r_void
(def_block
id|do_inventory
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|pdc_hpa_processor
c_func
(paren
op_amp
id|processor_hpa
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Couldn&squot;t get the HPA of the processor.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Searching for devices in PDC firmware... &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;processor hpa 0x%lx&bslash;n&quot;
comma
id|processor_hpa.hpa
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|do_newer_workstation_inventory
c_func
(paren
)paren
macro_line|#ifdef __LP64__
op_logical_or
id|do_pat_inventory
c_func
(paren
)paren
macro_line|#else /* __LP64__ */
op_logical_or
id|do_old_inventory
c_func
(paren
)paren
macro_line|#endif /* __LP64__ */
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;I can&squot;t get the hardware inventory on this machine&quot;
)paren
suffix:semicolon
)brace
id|print_devices
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)def_block
eof
