multiline_comment|/*&n; *  linux/arch/parisc/mm/init.c&n; *&n; *  Copyright (C) 1995&t;Linus Torvalds&n; *  Copyright 1999 SuSE GmbH&n; *    changed by Philipp Rumpf&n; *  Copyright 1999 Philipp Rumpf (prumpf@tux.org)&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;&t;&t;/* for hppa_dma_ops and pcxl_dma_ops */
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
DECL|variable|totalram_pages
r_static
r_int
r_int
id|totalram_pages
suffix:semicolon
r_extern
r_int
r_int
id|max_pfn
comma
id|mem_max
suffix:semicolon
DECL|function|free_initmem
r_void
id|free_initmem
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/*&n; * Just an arbitrary offset to serve as a &quot;hole&quot; between mapping areas&n; * (between top of physical memory and a potential pcxl dma mapping&n; * area, and below the vmalloc mapping area).&n; *&n; * The current 32K value just means that there will be a 32K &quot;hole&quot;&n; * between mapping areas. That means that  any out-of-bounds memory&n; * accesses will hopefully be caught. The vmalloc() routines leaves&n; * a hole of 4kB between each vmalloced area for the same reason.&n; */
DECL|macro|VM_MAP_OFFSET
mdefine_line|#define VM_MAP_OFFSET  (32*1024)
DECL|macro|SET_MAP_OFFSET
mdefine_line|#define SET_MAP_OFFSET(x) ((void *)(((unsigned long)(x) + VM_MAP_OFFSET) &bslash;&n;&t;&t;&t;&t;     &amp; ~(VM_MAP_OFFSET-1)))
DECL|variable|vmalloc_start
r_void
op_star
id|vmalloc_start
suffix:semicolon
DECL|variable|pcxl_dma_start
r_int
r_int
id|pcxl_dma_start
suffix:semicolon
DECL|function|mem_init
r_void
id|__init
id|mem_init
c_func
(paren
r_void
)paren
(brace
id|max_mapnr
op_assign
id|num_physpages
op_assign
id|max_low_pfn
suffix:semicolon
id|high_memory
op_assign
id|__va
c_func
(paren
id|max_low_pfn
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|totalram_pages
op_add_assign
id|free_all_bootmem
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Memory: %luk available&bslash;n&quot;
comma
id|totalram_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hppa_dma_ops
op_eq
op_amp
id|pcxl_dma_ops
)paren
(brace
id|pcxl_dma_start
op_assign
(paren
r_int
r_int
)paren
id|SET_MAP_OFFSET
c_func
(paren
id|high_memory
)paren
suffix:semicolon
id|vmalloc_start
op_assign
id|SET_MAP_OFFSET
c_func
(paren
id|pcxl_dma_start
op_plus
id|PCXL_DMA_MAP_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcxl_dma_start
op_assign
l_int|0
suffix:semicolon
id|vmalloc_start
op_assign
id|SET_MAP_OFFSET
c_func
(paren
id|high_memory
)paren
suffix:semicolon
)brace
)brace
DECL|function|__bad_pgd
r_void
id|__bad_pgd
c_func
(paren
id|pgd_t
op_star
id|pgd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pgd in pmd_alloc: %08lx&bslash;n&quot;
comma
id|pgd_val
c_func
(paren
op_star
id|pgd
)paren
)paren
suffix:semicolon
id|pgd_val
c_func
(paren
op_star
id|pgd
)paren
op_assign
id|_PAGE_TABLE
op_plus
id|__pa
c_func
(paren
id|BAD_PAGETABLE
)paren
suffix:semicolon
)brace
DECL|function|__bad_pmd
r_void
id|__bad_pmd
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_plus
id|__pa
c_func
(paren
id|BAD_PAGETABLE
)paren
suffix:semicolon
)brace
DECL|function|get_pte_slow
id|pte_t
op_star
id|get_pte_slow
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|offset
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
(paren
id|pte_t
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|pte
)paren
(brace
id|clear_page
c_func
(paren
id|pte
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_plus
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
r_return
id|pte
op_plus
id|offset
suffix:semicolon
)brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_plus
id|__pa
c_func
(paren
id|BAD_PAGETABLE
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|__bad_pmd
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|offset
suffix:semicolon
)brace
DECL|function|do_check_pgt_cache
r_int
id|do_check_pgt_cache
c_func
(paren
r_int
id|low
comma
r_int
id|high
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * BAD_PAGE is the page that is used for page faults when linux&n; * is out-of-memory. Older versions of linux just did a&n; * do_exit(), but using this instead means there is less risk&n; * for a process dying in kernel mode, possibly leaving an inode&n; * unused etc..&n; *&n; * BAD_PAGETABLE is the accompanying page-table: it is initialized&n; * to point to BAD_PAGE entries.&n; *&n; * ZERO_PAGE is a special page that is used for zero-initialized&n; * data and COW.&n; */
DECL|function|__bad_pagetable
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|pte_t
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
DECL|variable|empty_zero_page
r_int
r_int
op_star
id|empty_zero_page
suffix:semicolon
DECL|variable|empty_bad_page
r_int
r_int
op_star
id|empty_bad_page
suffix:semicolon
DECL|function|__bad_page
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
(brace
r_return
op_star
(paren
id|pte_t
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
op_assign
l_int|0
comma
id|cached
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Free swap:&t; %6dkB&bslash;n&quot;
comma
id|nr_swap_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|cached
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages swap cached&bslash;n&quot;
comma
id|cached
)paren
suffix:semicolon
id|show_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|set_pte_phys
r_void
id|set_pte_phys
(paren
r_int
r_int
id|vaddr
comma
r_int
r_int
id|phys
)paren
(brace
)brace
multiline_comment|/*&n; * pagetable_init() sets up the page tables&n; *&n; * Note that gateway_init() places the Linux gateway page at page 0.&n; * Since gateway pages cannot be dereferenced this has the desirable&n; * side effect of trapping those pesky NULL-reference errors in the&n; * kernel.&n; */
DECL|function|pagetable_init
r_static
r_void
id|__init
id|pagetable_init
c_func
(paren
r_void
)paren
(brace
id|pgd_t
op_star
id|pg_dir
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pg_table
suffix:semicolon
r_int
r_int
id|tmp1
suffix:semicolon
r_int
r_int
id|tmp2
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|ro_start
suffix:semicolon
r_int
r_int
id|ro_end
suffix:semicolon
r_int
r_int
id|fv_addr
suffix:semicolon
r_extern
r_const
r_int
id|stext
suffix:semicolon
r_extern
r_int
id|data_start
suffix:semicolon
r_extern
r_const
r_int
r_int
id|fault_vector_20
suffix:semicolon
id|ro_start
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|stext
)paren
suffix:semicolon
id|ro_end
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|data_start
)paren
suffix:semicolon
id|fv_addr
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|fault_vector_20
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pagetable_init&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Map whole memory from PAGE_OFFSET */
id|pg_dir
op_assign
(paren
id|pgd_t
op_star
)paren
id|swapper_pg_dir
op_plus
id|USER_PGD_PTRS
suffix:semicolon
id|address
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|address
OL
id|mem_max
)paren
(brace
multiline_comment|/* XXX: BTLB should be done here */
macro_line|#if PTRS_PER_PMD == 1
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__pa
c_func
(paren
id|pg_dir
)paren
suffix:semicolon
macro_line|#else
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|PAGE_MASK
op_amp
id|pgd_val
c_func
(paren
op_star
id|pg_dir
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * pmd is physical at this point&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pmd
)paren
(brace
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|alloc_bootmem_low_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__pa
c_func
(paren
id|pmd
)paren
suffix:semicolon
)brace
id|pgd_val
c_func
(paren
op_star
id|pg_dir
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|pmd
suffix:semicolon
macro_line|#endif
id|pg_dir
op_increment
suffix:semicolon
multiline_comment|/* now change pmd to kernel virtual addresses */
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__va
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp1
op_assign
l_int|0
suffix:semicolon
id|tmp1
OL
id|PTRS_PER_PMD
suffix:semicolon
id|tmp1
op_increment
comma
id|pmd
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * pg_table is physical at this point&n;&t;&t;&t; */
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
(paren
id|PAGE_MASK
op_amp
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pg_table
)paren
(brace
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|alloc_bootmem_low_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|__pa
c_func
(paren
id|pg_table
)paren
suffix:semicolon
)brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|pg_table
suffix:semicolon
multiline_comment|/* now change pg_table to kernel virtual addresses */
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|__va
c_func
(paren
id|pg_table
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp2
op_assign
l_int|0
suffix:semicolon
id|tmp2
OL
id|PTRS_PER_PTE
suffix:semicolon
id|tmp2
op_increment
comma
id|pg_table
op_increment
)paren
(brace
id|pte_t
id|pte
suffix:semicolon
macro_line|#if !defined(CONFIG_KWDB) &amp;&amp; !defined(CONFIG_STI_CONSOLE)
macro_line|#warning STI console should explicitly allocate executable pages but does not
multiline_comment|/* KWDB needs to write kernel text when setting break points.&n;**&n;** The right thing to do seems like KWDB modify only the pte which&n;** has a break point on it...otherwise we might mask worse bugs.&n;*/
r_if
c_cond
(paren
id|address
op_ge
id|ro_start
op_logical_and
id|address
OL
id|ro_end
op_logical_and
id|address
op_ne
id|fv_addr
)paren
id|pte
op_assign
id|__mk_pte
c_func
(paren
id|address
comma
id|PAGE_KERNEL_RO
)paren
suffix:semicolon
r_else
macro_line|#endif
id|pte
op_assign
id|__mk_pte
c_func
(paren
id|address
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|mem_max
)paren
id|pte_val
c_func
(paren
id|pte
)paren
op_assign
l_int|0
suffix:semicolon
id|set_pte
c_func
(paren
id|pg_table
comma
id|pte
)paren
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|address
op_ge
id|mem_max
)paren
r_break
suffix:semicolon
)brace
)brace
id|empty_zero_page
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|empty_zero_page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
DECL|variable|gateway_pgd_offset
r_int
r_int
id|gateway_pgd_offset
suffix:semicolon
DECL|variable|gateway_pgd_entry
r_int
r_int
id|gateway_pgd_entry
suffix:semicolon
DECL|function|gateway_init
r_static
r_void
id|__init
id|gateway_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|hpux_gateway_page_addr
suffix:semicolon
r_int
r_int
id|linux_gateway_page_addr
suffix:semicolon
id|pgd_t
op_star
id|pg_dir
suffix:semicolon
id|pmd_t
op_star
id|pmd_base
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pg_table_base
suffix:semicolon
id|pte_t
op_star
id|pg_table
suffix:semicolon
multiline_comment|/* FIXME: These are &squot;const&squot; in order to trick the compiler&n;           into not treating them as DP-relative data. */
r_extern
r_void
op_star
r_const
id|hpux_gateway_page
suffix:semicolon
r_extern
r_void
op_star
r_const
id|linux_gateway_page
suffix:semicolon
id|pte_t
id|pte
suffix:semicolon
id|hpux_gateway_page_addr
op_assign
id|HPUX_GATEWAY_ADDR
op_amp
id|PAGE_MASK
suffix:semicolon
id|linux_gateway_page_addr
op_assign
id|LINUX_GATEWAY_ADDR
op_amp
id|PAGE_MASK
suffix:semicolon
id|gateway_pgd_offset
op_assign
id|hpux_gateway_page_addr
op_rshift
id|PGDIR_SHIFT
suffix:semicolon
multiline_comment|/*&n;&t; * Setup Linux Gateway page.&n;&t; *&n;&t; * The Linux gateway page will reside in kernel space (on virtual&n;&t; * page 0), so it doesn&squot;t need to be aliased into user space.&n;&t; */
id|pg_dir
op_assign
(paren
id|pgd_t
op_star
)paren
id|swapper_pg_dir
suffix:semicolon
macro_line|#if PTRS_PER_PMD == 1
id|pmd_base
op_assign
(paren
id|pmd_t
op_star
)paren
id|pg_dir
suffix:semicolon
id|pmd
op_assign
id|pmd_base
op_plus
(paren
(paren
id|linux_gateway_page_addr
)paren
op_rshift
id|PGDIR_SHIFT
)paren
suffix:semicolon
macro_line|#else
id|pmd_base
op_assign
(paren
id|pmd_t
op_star
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pgd_val
c_func
(paren
op_star
(paren
id|pg_dir
op_plus
(paren
id|linux_gateway_page_addr
op_rshift
id|PGDIR_SHIFT
)paren
)paren
)paren
op_assign
id|_PAGE_TABLE
op_or
id|__pa
c_func
(paren
id|pmd_base
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_base
op_plus
(paren
(paren
id|linux_gateway_page_addr
op_amp
(paren
id|PMD_MASK
)paren
op_amp
(paren
id|PGDIR_SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|PMD_SHIFT
)paren
suffix:semicolon
macro_line|#endif
id|pg_table_base
op_assign
(paren
id|pte_t
op_star
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
id|__pa
c_func
(paren
id|pg_table_base
)paren
suffix:semicolon
id|pte
op_assign
id|__mk_pte
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|linux_gateway_page
)paren
comma
id|PAGE_GATEWAY
)paren
suffix:semicolon
id|pg_table
op_assign
id|pg_table_base
op_plus
(paren
(paren
id|linux_gateway_page_addr
op_amp
(paren
id|PAGE_MASK
)paren
op_amp
(paren
id|PMD_SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg_table
comma
id|pte
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup HP-UX gateway page.&n;&t; * This page will be aliased into each user address space.&n;&t; */
id|pg_table_base
op_assign
(paren
id|pte_t
op_star
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pte
op_assign
id|__mk_pte
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|hpux_gateway_page
)paren
comma
id|PAGE_GATEWAY
)paren
suffix:semicolon
id|pg_table
op_assign
id|pg_table_base
op_plus
(paren
(paren
id|hpux_gateway_page_addr
op_amp
(paren
id|PAGE_MASK
)paren
op_amp
(paren
id|PMD_SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg_table
comma
id|pte
)paren
suffix:semicolon
macro_line|#if PTRS_PER_PMD == 1
id|pmd_base
op_assign
(paren
id|pmd_t
op_star
)paren
id|pg_table_base
suffix:semicolon
macro_line|#else
id|pmd_base
op_assign
(paren
id|pmd_t
op_star
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_base
op_plus
(paren
(paren
id|hpux_gateway_page_addr
op_amp
(paren
id|PMD_MASK
)paren
op_amp
(paren
id|PGDIR_SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|PMD_SHIFT
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
id|__pa
c_func
(paren
id|pg_table_base
)paren
suffix:semicolon
macro_line|#endif
id|gateway_pgd_entry
op_assign
id|_PAGE_TABLE
op_or
id|__pa
c_func
(paren
id|pmd_base
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We will be aliasing the HP-UX gateway page into all HP-UX&n;&t; * user spaces at the same address (not counting the space register&n;&t; * value) that will be equivalently mapped as long as space register&n;&t; * hashing is disabled. It will be a problem if anyone touches&n;&t; * the gateway pages at its &quot;kernel&quot; address, since that is&n;&t; * NOT equivalently mapped. We&squot;ll flush the caches at this&n;&t; * point, just in case some code has touched those addresses&n;&t; * previous to this, but all bets are off if they get touched&n;&t; * after this point.&n;&t; */
id|flush_all_caches
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|paging_init
r_void
id|__init
id|paging_init
c_func
(paren
r_void
)paren
(brace
id|pagetable_init
c_func
(paren
)paren
suffix:semicolon
id|gateway_init
c_func
(paren
)paren
suffix:semicolon
(brace
r_int
r_int
id|zones_size
(braket
id|MAX_NR_ZONES
)braket
op_assign
(brace
id|max_pfn
op_div
l_int|2
comma
id|max_pfn
op_div
l_int|2
comma
)brace
suffix:semicolon
id|free_area_init
c_func
(paren
id|zones_size
)paren
suffix:semicolon
)brace
)brace
DECL|macro|NR_SPACE_IDS
mdefine_line|#define NR_SPACE_IDS&t;8192
DECL|variable|space_id
r_static
r_int
r_int
id|space_id
(braket
id|NR_SPACE_IDS
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
)braket
suffix:semicolon
DECL|variable|space_id_index
r_static
r_int
r_int
id|space_id_index
suffix:semicolon
DECL|variable|free_space_ids
r_static
r_int
r_int
id|free_space_ids
op_assign
id|NR_SPACE_IDS
suffix:semicolon
multiline_comment|/*&n; * XXX: We should probably unfold the set_bit / test_bit / clear_bit&n; * locking out of these two functions and have a single spinlock on the&n; * space_id data structures.&n; *&n; * Don&squot;t bother. This is all going to be significantly changed in the&n; * very near future.&n; */
DECL|macro|SPACEID_SHIFT
mdefine_line|#define SPACEID_SHIFT (PAGE_SHIFT + (PT_NLEVELS)*(PAGE_SHIFT - PT_NLEVELS) - 32)
DECL|function|alloc_sid
r_int
r_int
id|alloc_sid
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
r_if
c_cond
(paren
id|free_space_ids
op_eq
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|free_space_ids
op_decrement
suffix:semicolon
r_do
(brace
id|index
op_assign
id|find_next_zero_bit
c_func
(paren
id|space_id
comma
id|NR_SPACE_IDS
comma
id|space_id_index
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
id|index
comma
id|space_id
)paren
)paren
(brace
suffix:semicolon
)brace
id|space_id_index
op_assign
id|index
suffix:semicolon
r_return
id|index
op_lshift
id|SPACEID_SHIFT
suffix:semicolon
)brace
DECL|function|free_sid
r_void
id|free_sid
c_func
(paren
r_int
r_int
id|spaceid
)paren
(brace
r_int
r_int
id|index
op_assign
id|spaceid
op_rshift
id|SPACEID_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|index
comma
id|space_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space_id_index
OG
id|index
)paren
(brace
id|space_id_index
op_assign
id|index
suffix:semicolon
)brace
id|free_space_ids
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|free_initrd_mem
r_void
id|free_initrd_mem
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
macro_line|#if 0
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|start
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|start
)paren
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|start
)paren
suffix:semicolon
id|totalram_pages
op_increment
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Freeing initrd memory: %ldk freed&bslash;n&quot;
comma
(paren
id|end
op_minus
id|start
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
id|val-&gt;totalram
op_assign
id|totalram_pages
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|atomic_read
c_func
(paren
op_amp
id|buffermem_pages
)paren
suffix:semicolon
macro_line|#if 0
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;totalram
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;sharedram
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|val-&gt;totalram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;sharedram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
macro_line|#endif
id|val-&gt;totalhigh
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freehigh
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
