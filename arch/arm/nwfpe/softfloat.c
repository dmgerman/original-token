multiline_comment|/*&n;===============================================================================&n;&n;This C source file is part of the SoftFloat IEC/IEEE Floating-point&n;Arithmetic Package, Release 2.&n;&n;Written by John R. Hauser.  This work was made possible in part by the&n;International Computer Science Institute, located at Suite 600, 1947 Center&n;Street, Berkeley, California 94704.  Funding was partially provided by the&n;National Science Foundation under grant MIP-9311980.  The original version&n;of this code was written as part of a project to build a fixed-point vector&n;processor in collaboration with the University of California at Berkeley,&n;overseen by Profs. Nelson Morgan and John Wawrzynek.  More information&n;is available through the web page `http://HTTP.CS.Berkeley.EDU/~jhauser/&n;arithmetic/softfloat.html&squot;.&n;&n;THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort&n;has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT&n;TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO&n;PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY&n;AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.&n;&n;Derivative works are acceptable, even for commercial purposes, so long as&n;(1) they include prominent notice that the work is derivative, and (2) they&n;include prominent notice akin to these three paragraphs for those parts of&n;this code that are retained.&n;&n;===============================================================================&n;*/
macro_line|#include &quot;milieu.h&quot;
macro_line|#include &quot;softfloat.h&quot;
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Floating-point rounding mode, extended double-precision rounding precision,&n;and exception flags.&n;-------------------------------------------------------------------------------&n;*/
DECL|variable|float_rounding_mode
id|int8
id|float_rounding_mode
op_assign
id|float_round_nearest_even
suffix:semicolon
DECL|variable|floatx80_rounding_precision
id|int8
id|floatx80_rounding_precision
op_assign
l_int|80
suffix:semicolon
DECL|variable|float_exception_flags
id|int8
id|float_exception_flags
suffix:semicolon
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Primitive arithmetic functions, including multi-word arithmetic, and&n;division and square root approximations.  (Can be specialized to target if&n;desired.)&n;-------------------------------------------------------------------------------&n;*/
macro_line|#include &quot;softfloat-macros&quot;
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Functions and definitions to determine:  (1) whether tininess for underflow&n;is detected before or after rounding by default, (2) what (if anything)&n;happens when exceptions are raised, (3) how signaling NaNs are distinguished&n;from quiet NaNs, (4) the default generated quiet NaNs, and (5) how NaNs&n;are propagated from function inputs to output.  These details are target-&n;specific.&n;-------------------------------------------------------------------------------&n;*/
macro_line|#include &quot;softfloat-specialize&quot;
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes a 64-bit fixed-point value `absZ&squot; with binary point between bits 6&n;and 7, and returns the properly rounded 32-bit integer corresponding to the&n;input.  If `zSign&squot; is nonzero, the input is negated before being converted&n;to an integer.  Bit 63 of `absZ&squot; must be zero.  Ordinarily, the fixed-point&n;input is simply rounded to an integer, with the inexact exception raised if&n;the input cannot be represented exactly as an integer.  If the fixed-point&n;input is too large, however, the invalid exception is raised and the largest&n;positive or negative integer is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|roundAndPackInt32
r_static
id|int32
id|roundAndPackInt32
c_func
(paren
id|flag
id|zSign
comma
id|bits64
id|absZ
)paren
(brace
id|int8
id|roundingMode
suffix:semicolon
id|flag
id|roundNearestEven
suffix:semicolon
id|int8
id|roundIncrement
comma
id|roundBits
suffix:semicolon
id|int32
id|z
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
id|roundNearestEven
op_assign
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
suffix:semicolon
id|roundIncrement
op_assign
l_int|0x40
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|roundNearestEven
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
(brace
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|roundIncrement
op_assign
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|roundBits
op_assign
id|absZ
op_amp
l_int|0x7F
suffix:semicolon
id|absZ
op_assign
(paren
id|absZ
op_plus
id|roundIncrement
)paren
op_rshift
l_int|7
suffix:semicolon
id|absZ
op_and_assign
op_complement
(paren
(paren
(paren
id|roundBits
op_xor
l_int|0x40
)paren
op_eq
l_int|0
)paren
op_amp
id|roundNearestEven
)paren
suffix:semicolon
id|z
op_assign
id|absZ
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
id|z
op_assign
op_minus
id|z
suffix:semicolon
r_if
c_cond
(paren
(paren
id|absZ
op_rshift
l_int|32
)paren
op_logical_or
(paren
id|z
op_logical_and
(paren
(paren
id|z
OL
l_int|0
)paren
op_xor
id|zSign
)paren
)paren
)paren
(brace
id|float_exception_flags
op_or_assign
id|float_flag_invalid
suffix:semicolon
r_return
id|zSign
ques
c_cond
l_int|0x80000000
suffix:colon
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|roundBits
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the fraction bits of the single-precision floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat32Frac
id|INLINE
id|bits32
id|extractFloat32Frac
c_func
(paren
id|float32
id|a
)paren
(brace
r_return
id|a
op_amp
l_int|0x007FFFFF
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the exponent bits of the single-precision floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat32Exp
id|INLINE
id|int16
id|extractFloat32Exp
c_func
(paren
id|float32
id|a
)paren
(brace
r_return
(paren
id|a
op_rshift
l_int|23
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the sign bit of the single-precision floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat32Sign
id|INLINE
id|flag
id|extractFloat32Sign
c_func
(paren
id|float32
id|a
)paren
(brace
r_return
id|a
op_rshift
l_int|31
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Normalizes the subnormal single-precision floating-point value represented&n;by the denormalized significand `aSig&squot;.  The normalized exponent and&n;significand are stored at the locations pointed to by `zExpPtr&squot; and&n;`zSigPtr&squot;, respectively.&n;-------------------------------------------------------------------------------&n;*/
r_static
r_void
DECL|function|normalizeFloat32Subnormal
id|normalizeFloat32Subnormal
c_func
(paren
id|bits32
id|aSig
comma
id|int16
op_star
id|zExpPtr
comma
id|bits32
op_star
id|zSigPtr
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros32
c_func
(paren
id|aSig
)paren
op_minus
l_int|8
suffix:semicolon
op_star
id|zSigPtr
op_assign
id|aSig
op_lshift
id|shiftCount
suffix:semicolon
op_star
id|zExpPtr
op_assign
l_int|1
op_minus
id|shiftCount
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Packs the sign `zSign&squot;, exponent `zExp&squot;, and significand `zSig&squot; into a&n;single-precision floating-point value, returning the result.  After being&n;shifted into the proper positions, the three fields are simply added&n;together to form the result.  This means that any integer portion of `zSig&squot;&n;will be added into the exponent.  Since a properly normalized significand&n;will have an integer portion equal to 1, the `zExp&squot; input should be 1 less&n;than the desired result exponent whenever `zSig&squot; is a complete, normalized&n;significand.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|packFloat32
id|INLINE
id|float32
id|packFloat32
c_func
(paren
id|flag
id|zSign
comma
id|int16
id|zExp
comma
id|bits32
id|zSig
)paren
(brace
macro_line|#if 0
id|float32
id|f
suffix:semicolon
id|__asm__
c_func
(paren
"&quot;@"
id|packFloat32
suffix:semicolon
id|mov
op_mod
l_int|0
comma
op_mod
l_int|1
comma
id|asl
macro_line|#31;
id|orr
op_mod
l_int|0
comma
op_mod
l_int|2
comma
id|asl
macro_line|#23;
id|orr
op_mod
l_int|0
comma
op_mod
l_int|3
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;g&quot;
(paren
id|f
)paren
comma
l_string|&quot;g&quot;
(paren
id|zSign
)paren
comma
l_string|&quot;g&quot;
(paren
id|zExp
)paren
comma
l_string|&quot;g&quot;
(paren
id|zSig
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
macro_line|#else
r_return
(paren
(paren
(paren
id|bits32
)paren
id|zSign
)paren
op_lshift
l_int|31
)paren
op_plus
(paren
(paren
(paren
id|bits32
)paren
id|zExp
)paren
op_lshift
l_int|23
)paren
op_plus
id|zSig
suffix:semicolon
macro_line|#endif 
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent `zExp&squot;,&n;and significand `zSig&squot;, and returns the proper single-precision floating-&n;point value corresponding to the abstract input.  Ordinarily, the abstract&n;value is simply rounded and packed into the single-precision format, with&n;the inexact exception raised if the abstract input cannot be represented&n;exactly.  If the abstract value is too large, however, the overflow and&n;inexact exceptions are raised and an infinity or maximal finite value is&n;returned.  If the abstract value is too small, the input value is rounded to&n;a subnormal number, and the underflow and inexact exceptions are raised if&n;the abstract input cannot be represented exactly as a subnormal single-&n;precision floating-point number.&n;    The input significand `zSig&squot; has its binary point between bits 30&n;and 29, which is 7 bits to the left of the usual location.  This shifted&n;significand must be normalized or smaller.  If `zSig&squot; is not normalized,&n;`zExp&squot; must be 0; in that case, the result returned is a subnormal number,&n;and it must not require rounding.  In the usual case that `zSig&squot; is&n;normalized, `zExp&squot; must be 1 less than the ``true&squot;&squot; floating-point exponent.&n;The handling of underflow and overflow follows the IEC/IEEE Standard for&n;Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|roundAndPackFloat32
r_static
id|float32
id|roundAndPackFloat32
c_func
(paren
id|flag
id|zSign
comma
id|int16
id|zExp
comma
id|bits32
id|zSig
)paren
(brace
id|int8
id|roundingMode
suffix:semicolon
id|flag
id|roundNearestEven
suffix:semicolon
id|int8
id|roundIncrement
comma
id|roundBits
suffix:semicolon
id|flag
id|isTiny
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
id|roundNearestEven
op_assign
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
suffix:semicolon
id|roundIncrement
op_assign
l_int|0x40
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|roundNearestEven
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
(brace
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|roundIncrement
op_assign
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|roundBits
op_assign
id|zSig
op_amp
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
l_int|0xFD
op_le
(paren
id|bits16
)paren
id|zExp
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|0xFD
OL
id|zExp
)paren
op_logical_or
(paren
(paren
id|zExp
op_eq
l_int|0xFD
)paren
op_logical_and
(paren
(paren
id|sbits32
)paren
(paren
id|zSig
op_plus
id|roundIncrement
)paren
OL
l_int|0
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_overflow
op_or
id|float_flag_inexact
)paren
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0xFF
comma
l_int|0
)paren
op_minus
(paren
id|roundIncrement
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zExp
OL
l_int|0
)paren
(brace
id|isTiny
op_assign
(paren
id|float_detect_tininess
op_eq
id|float_tininess_before_rounding
)paren
op_logical_or
(paren
id|zExp
OL
op_minus
l_int|1
)paren
op_logical_or
(paren
id|zSig
op_plus
id|roundIncrement
OL
l_int|0x80000000
)paren
suffix:semicolon
id|shift32RightJamming
c_func
(paren
id|zSig
comma
op_minus
id|zExp
comma
op_amp
id|zSig
)paren
suffix:semicolon
id|zExp
op_assign
l_int|0
suffix:semicolon
id|roundBits
op_assign
id|zSig
op_amp
l_int|0x7F
suffix:semicolon
r_if
c_cond
(paren
id|isTiny
op_logical_and
id|roundBits
)paren
id|float_raise
c_func
(paren
id|float_flag_underflow
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|roundBits
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|zSig
op_assign
(paren
id|zSig
op_plus
id|roundIncrement
)paren
op_rshift
l_int|7
suffix:semicolon
id|zSig
op_and_assign
op_complement
(paren
(paren
(paren
id|roundBits
op_xor
l_int|0x40
)paren
op_eq
l_int|0
)paren
op_amp
id|roundNearestEven
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zSig
op_eq
l_int|0
)paren
id|zExp
op_assign
l_int|0
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent `zExp&squot;,&n;and significand `zSig&squot;, and returns the proper single-precision floating-&n;point value corresponding to the abstract input.  This routine is just like&n;`roundAndPackFloat32&squot; except that `zSig&squot; does not have to be normalized in&n;any way.  In all cases, `zExp&squot; must be 1 less than the ``true&squot;&squot; floating-&n;point exponent.&n;-------------------------------------------------------------------------------&n;*/
r_static
id|float32
DECL|function|normalizeRoundAndPackFloat32
id|normalizeRoundAndPackFloat32
c_func
(paren
id|flag
id|zSign
comma
id|int16
id|zExp
comma
id|bits32
id|zSig
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros32
c_func
(paren
id|zSig
)paren
op_minus
l_int|1
suffix:semicolon
r_return
id|roundAndPackFloat32
c_func
(paren
id|zSign
comma
id|zExp
op_minus
id|shiftCount
comma
id|zSig
op_lshift
id|shiftCount
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the fraction bits of the double-precision floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat64Frac
id|INLINE
id|bits64
id|extractFloat64Frac
c_func
(paren
id|float64
id|a
)paren
(brace
r_return
id|a
op_amp
id|LIT64
c_func
(paren
l_int|0x000FFFFFFFFFFFFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the exponent bits of the double-precision floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat64Exp
id|INLINE
id|int16
id|extractFloat64Exp
c_func
(paren
id|float64
id|a
)paren
(brace
r_return
(paren
id|a
op_rshift
l_int|52
)paren
op_amp
l_int|0x7FF
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the sign bit of the double-precision floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat64Sign
id|INLINE
id|flag
id|extractFloat64Sign
c_func
(paren
id|float64
id|a
)paren
(brace
r_return
id|a
op_rshift
l_int|63
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Normalizes the subnormal double-precision floating-point value represented&n;by the denormalized significand `aSig&squot;.  The normalized exponent and&n;significand are stored at the locations pointed to by `zExpPtr&squot; and&n;`zSigPtr&squot;, respectively.&n;-------------------------------------------------------------------------------&n;*/
r_static
r_void
DECL|function|normalizeFloat64Subnormal
id|normalizeFloat64Subnormal
c_func
(paren
id|bits64
id|aSig
comma
id|int16
op_star
id|zExpPtr
comma
id|bits64
op_star
id|zSigPtr
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros64
c_func
(paren
id|aSig
)paren
op_minus
l_int|11
suffix:semicolon
op_star
id|zSigPtr
op_assign
id|aSig
op_lshift
id|shiftCount
suffix:semicolon
op_star
id|zExpPtr
op_assign
l_int|1
op_minus
id|shiftCount
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Packs the sign `zSign&squot;, exponent `zExp&squot;, and significand `zSig&squot; into a&n;double-precision floating-point value, returning the result.  After being&n;shifted into the proper positions, the three fields are simply added&n;together to form the result.  This means that any integer portion of `zSig&squot;&n;will be added into the exponent.  Since a properly normalized significand&n;will have an integer portion equal to 1, the `zExp&squot; input should be 1 less&n;than the desired result exponent whenever `zSig&squot; is a complete, normalized&n;significand.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|packFloat64
id|INLINE
id|float64
id|packFloat64
c_func
(paren
id|flag
id|zSign
comma
id|int16
id|zExp
comma
id|bits64
id|zSig
)paren
(brace
r_return
(paren
(paren
(paren
id|bits64
)paren
id|zSign
)paren
op_lshift
l_int|63
)paren
op_plus
(paren
(paren
(paren
id|bits64
)paren
id|zExp
)paren
op_lshift
l_int|52
)paren
op_plus
id|zSig
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent `zExp&squot;,&n;and significand `zSig&squot;, and returns the proper double-precision floating-&n;point value corresponding to the abstract input.  Ordinarily, the abstract&n;value is simply rounded and packed into the double-precision format, with&n;the inexact exception raised if the abstract input cannot be represented&n;exactly.  If the abstract value is too large, however, the overflow and&n;inexact exceptions are raised and an infinity or maximal finite value is&n;returned.  If the abstract value is too small, the input value is rounded to&n;a subnormal number, and the underflow and inexact exceptions are raised if&n;the abstract input cannot be represented exactly as a subnormal double-&n;precision floating-point number.&n;    The input significand `zSig&squot; has its binary point between bits 62&n;and 61, which is 10 bits to the left of the usual location.  This shifted&n;significand must be normalized or smaller.  If `zSig&squot; is not normalized,&n;`zExp&squot; must be 0; in that case, the result returned is a subnormal number,&n;and it must not require rounding.  In the usual case that `zSig&squot; is&n;normalized, `zExp&squot; must be 1 less than the ``true&squot;&squot; floating-point exponent.&n;The handling of underflow and overflow follows the IEC/IEEE Standard for&n;Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|roundAndPackFloat64
r_static
id|float64
id|roundAndPackFloat64
c_func
(paren
id|flag
id|zSign
comma
id|int16
id|zExp
comma
id|bits64
id|zSig
)paren
(brace
id|int8
id|roundingMode
suffix:semicolon
id|flag
id|roundNearestEven
suffix:semicolon
id|int16
id|roundIncrement
comma
id|roundBits
suffix:semicolon
id|flag
id|isTiny
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
id|roundNearestEven
op_assign
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
suffix:semicolon
id|roundIncrement
op_assign
l_int|0x200
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|roundNearestEven
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
(brace
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|roundIncrement
op_assign
l_int|0x3FF
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|roundBits
op_assign
id|zSig
op_amp
l_int|0x3FF
suffix:semicolon
r_if
c_cond
(paren
l_int|0x7FD
op_le
(paren
id|bits16
)paren
id|zExp
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|0x7FD
OL
id|zExp
)paren
op_logical_or
(paren
(paren
id|zExp
op_eq
l_int|0x7FD
)paren
op_logical_and
(paren
(paren
id|sbits64
)paren
(paren
id|zSig
op_plus
id|roundIncrement
)paren
OL
l_int|0
)paren
)paren
)paren
(brace
singleline_comment|//register int lr = __builtin_return_address(0);
singleline_comment|//printk(&quot;roundAndPackFloat64 called from 0x%08x&bslash;n&quot;,lr);
id|float_raise
c_func
(paren
id|float_flag_overflow
op_or
id|float_flag_inexact
)paren
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0x7FF
comma
l_int|0
)paren
op_minus
(paren
id|roundIncrement
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zExp
OL
l_int|0
)paren
(brace
id|isTiny
op_assign
(paren
id|float_detect_tininess
op_eq
id|float_tininess_before_rounding
)paren
op_logical_or
(paren
id|zExp
OL
op_minus
l_int|1
)paren
op_logical_or
(paren
id|zSig
op_plus
id|roundIncrement
OL
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
id|shift64RightJamming
c_func
(paren
id|zSig
comma
op_minus
id|zExp
comma
op_amp
id|zSig
)paren
suffix:semicolon
id|zExp
op_assign
l_int|0
suffix:semicolon
id|roundBits
op_assign
id|zSig
op_amp
l_int|0x3FF
suffix:semicolon
r_if
c_cond
(paren
id|isTiny
op_logical_and
id|roundBits
)paren
id|float_raise
c_func
(paren
id|float_flag_underflow
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|roundBits
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|zSig
op_assign
(paren
id|zSig
op_plus
id|roundIncrement
)paren
op_rshift
l_int|10
suffix:semicolon
id|zSig
op_and_assign
op_complement
(paren
(paren
(paren
id|roundBits
op_xor
l_int|0x200
)paren
op_eq
l_int|0
)paren
op_amp
id|roundNearestEven
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zSig
op_eq
l_int|0
)paren
id|zExp
op_assign
l_int|0
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent `zExp&squot;,&n;and significand `zSig&squot;, and returns the proper double-precision floating-&n;point value corresponding to the abstract input.  This routine is just like&n;`roundAndPackFloat64&squot; except that `zSig&squot; does not have to be normalized in&n;any way.  In all cases, `zExp&squot; must be 1 less than the ``true&squot;&squot; floating-&n;point exponent.&n;-------------------------------------------------------------------------------&n;*/
r_static
id|float64
DECL|function|normalizeRoundAndPackFloat64
id|normalizeRoundAndPackFloat64
c_func
(paren
id|flag
id|zSign
comma
id|int16
id|zExp
comma
id|bits64
id|zSig
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros64
c_func
(paren
id|zSig
)paren
op_minus
l_int|1
suffix:semicolon
r_return
id|roundAndPackFloat64
c_func
(paren
id|zSign
comma
id|zExp
op_minus
id|shiftCount
comma
id|zSig
op_lshift
id|shiftCount
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOATX80
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the fraction bits of the extended double-precision floating-point&n;value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloatx80Frac
id|INLINE
id|bits64
id|extractFloatx80Frac
c_func
(paren
id|floatx80
id|a
)paren
(brace
r_return
id|a.low
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the exponent bits of the extended double-precision floating-point&n;value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloatx80Exp
id|INLINE
id|int32
id|extractFloatx80Exp
c_func
(paren
id|floatx80
id|a
)paren
(brace
r_return
id|a.high
op_amp
l_int|0x7FFF
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the sign bit of the extended double-precision floating-point value&n;`a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloatx80Sign
id|INLINE
id|flag
id|extractFloatx80Sign
c_func
(paren
id|floatx80
id|a
)paren
(brace
r_return
id|a.high
op_rshift
l_int|15
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Normalizes the subnormal extended double-precision floating-point value&n;represented by the denormalized significand `aSig&squot;.  The normalized exponent&n;and significand are stored at the locations pointed to by `zExpPtr&squot; and&n;`zSigPtr&squot;, respectively.&n;-------------------------------------------------------------------------------&n;*/
r_static
r_void
DECL|function|normalizeFloatx80Subnormal
id|normalizeFloatx80Subnormal
c_func
(paren
id|bits64
id|aSig
comma
id|int32
op_star
id|zExpPtr
comma
id|bits64
op_star
id|zSigPtr
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros64
c_func
(paren
id|aSig
)paren
suffix:semicolon
op_star
id|zSigPtr
op_assign
id|aSig
op_lshift
id|shiftCount
suffix:semicolon
op_star
id|zExpPtr
op_assign
l_int|1
op_minus
id|shiftCount
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Packs the sign `zSign&squot;, exponent `zExp&squot;, and significand `zSig&squot; into an&n;extended double-precision floating-point value, returning the result.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|packFloatx80
id|INLINE
id|floatx80
id|packFloatx80
c_func
(paren
id|flag
id|zSign
comma
id|int32
id|zExp
comma
id|bits64
id|zSig
)paren
(brace
id|floatx80
id|z
suffix:semicolon
id|z.low
op_assign
id|zSig
suffix:semicolon
id|z.high
op_assign
(paren
(paren
(paren
id|bits16
)paren
id|zSign
)paren
op_lshift
l_int|15
)paren
op_plus
id|zExp
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent `zExp&squot;,&n;and extended significand formed by the concatenation of `zSig0&squot; and `zSig1&squot;,&n;and returns the proper extended double-precision floating-point value&n;corresponding to the abstract input.  Ordinarily, the abstract value is&n;rounded and packed into the extended double-precision format, with the&n;inexact exception raised if the abstract input cannot be represented&n;exactly.  If the abstract value is too large, however, the overflow and&n;inexact exceptions are raised and an infinity or maximal finite value is&n;returned.  If the abstract value is too small, the input value is rounded to&n;a subnormal number, and the underflow and inexact exceptions are raised if&n;the abstract input cannot be represented exactly as a subnormal extended&n;double-precision floating-point number.&n;    If `roundingPrecision&squot; is 32 or 64, the result is rounded to the same&n;number of bits as single or double precision, respectively.  Otherwise, the&n;result is rounded to the full precision of the extended double-precision&n;format.&n;    The input significand must be normalized or smaller.  If the input&n;significand is not normalized, `zExp&squot; must be 0; in that case, the result&n;returned is a subnormal number, and it must not require rounding.  The&n;handling of underflow and overflow follows the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
r_static
id|floatx80
DECL|function|roundAndPackFloatx80
id|roundAndPackFloatx80
c_func
(paren
id|int8
id|roundingPrecision
comma
id|flag
id|zSign
comma
id|int32
id|zExp
comma
id|bits64
id|zSig0
comma
id|bits64
id|zSig1
)paren
(brace
id|int8
id|roundingMode
suffix:semicolon
id|flag
id|roundNearestEven
comma
id|increment
comma
id|isTiny
suffix:semicolon
id|int64
id|roundIncrement
comma
id|roundMask
comma
id|roundBits
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
id|roundNearestEven
op_assign
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
suffix:semicolon
r_if
c_cond
(paren
id|roundingPrecision
op_eq
l_int|80
)paren
r_goto
id|precision80
suffix:semicolon
r_if
c_cond
(paren
id|roundingPrecision
op_eq
l_int|64
)paren
(brace
id|roundIncrement
op_assign
id|LIT64
c_func
(paren
l_int|0x0000000000000400
)paren
suffix:semicolon
id|roundMask
op_assign
id|LIT64
c_func
(paren
l_int|0x00000000000007FF
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|roundingPrecision
op_eq
l_int|32
)paren
(brace
id|roundIncrement
op_assign
id|LIT64
c_func
(paren
l_int|0x0000008000000000
)paren
suffix:semicolon
id|roundMask
op_assign
id|LIT64
c_func
(paren
l_int|0x000000FFFFFFFFFF
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|precision80
suffix:semicolon
)brace
id|zSig0
op_or_assign
(paren
id|zSig1
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|roundNearestEven
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
(brace
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|roundIncrement
op_assign
id|roundMask
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
id|roundIncrement
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|roundBits
op_assign
id|zSig0
op_amp
id|roundMask
suffix:semicolon
r_if
c_cond
(paren
l_int|0x7FFD
op_le
(paren
id|bits32
)paren
(paren
id|zExp
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|0x7FFE
OL
id|zExp
)paren
op_logical_or
(paren
(paren
id|zExp
op_eq
l_int|0x7FFE
)paren
op_logical_and
(paren
id|zSig0
op_plus
id|roundIncrement
OL
id|zSig0
)paren
)paren
)paren
(brace
r_goto
id|overflow
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zExp
op_le
l_int|0
)paren
(brace
id|isTiny
op_assign
(paren
id|float_detect_tininess
op_eq
id|float_tininess_before_rounding
)paren
op_logical_or
(paren
id|zExp
OL
l_int|0
)paren
op_logical_or
(paren
id|zSig0
op_le
id|zSig0
op_plus
id|roundIncrement
)paren
suffix:semicolon
id|shift64RightJamming
c_func
(paren
id|zSig0
comma
l_int|1
op_minus
id|zExp
comma
op_amp
id|zSig0
)paren
suffix:semicolon
id|zExp
op_assign
l_int|0
suffix:semicolon
id|roundBits
op_assign
id|zSig0
op_amp
id|roundMask
suffix:semicolon
r_if
c_cond
(paren
id|isTiny
op_logical_and
id|roundBits
)paren
id|float_raise
c_func
(paren
id|float_flag_underflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|roundBits
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|zSig0
op_add_assign
id|roundIncrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sbits64
)paren
id|zSig0
OL
l_int|0
)paren
id|zExp
op_assign
l_int|1
suffix:semicolon
id|roundIncrement
op_assign
id|roundMask
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|roundNearestEven
op_logical_and
(paren
id|roundBits
op_lshift
l_int|1
op_eq
id|roundIncrement
)paren
)paren
(brace
id|roundMask
op_or_assign
id|roundIncrement
suffix:semicolon
)brace
id|zSig0
op_and_assign
op_complement
id|roundMask
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|roundBits
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|zSig0
op_add_assign
id|roundIncrement
suffix:semicolon
r_if
c_cond
(paren
id|zSig0
OL
id|roundIncrement
)paren
(brace
op_increment
id|zExp
suffix:semicolon
id|zSig0
op_assign
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
suffix:semicolon
)brace
id|roundIncrement
op_assign
id|roundMask
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|roundNearestEven
op_logical_and
(paren
id|roundBits
op_lshift
l_int|1
op_eq
id|roundIncrement
)paren
)paren
(brace
id|roundMask
op_or_assign
id|roundIncrement
suffix:semicolon
)brace
id|zSig0
op_and_assign
op_complement
id|roundMask
suffix:semicolon
r_if
c_cond
(paren
id|zSig0
op_eq
l_int|0
)paren
id|zExp
op_assign
l_int|0
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
)paren
suffix:semicolon
id|precision80
suffix:colon
id|increment
op_assign
(paren
(paren
id|sbits64
)paren
id|zSig1
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|roundNearestEven
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
(brace
id|increment
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|zSign
)paren
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
op_logical_and
id|zSig1
suffix:semicolon
)brace
r_else
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
op_logical_and
id|zSig1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
l_int|0x7FFD
op_le
(paren
id|bits32
)paren
(paren
id|zExp
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|0x7FFE
OL
id|zExp
)paren
op_logical_or
(paren
(paren
id|zExp
op_eq
l_int|0x7FFE
)paren
op_logical_and
(paren
id|zSig0
op_eq
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
)paren
op_logical_and
id|increment
)paren
)paren
(brace
id|roundMask
op_assign
l_int|0
suffix:semicolon
id|overflow
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_overflow
op_or
id|float_flag_inexact
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
op_logical_or
(paren
id|zSign
op_logical_and
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|zSign
op_logical_and
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
)paren
)paren
(brace
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x7FFE
comma
op_complement
id|roundMask
)paren
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zExp
op_le
l_int|0
)paren
(brace
id|isTiny
op_assign
(paren
id|float_detect_tininess
op_eq
id|float_tininess_before_rounding
)paren
op_logical_or
(paren
id|zExp
OL
l_int|0
)paren
op_logical_or
op_logical_neg
id|increment
op_logical_or
(paren
id|zSig0
OL
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
)paren
suffix:semicolon
id|shift64ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
l_int|1
op_minus
id|zExp
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|isTiny
op_logical_and
id|zSig1
)paren
id|float_raise
c_func
(paren
id|float_flag_underflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zSig1
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_if
c_cond
(paren
id|roundNearestEven
)paren
(brace
id|increment
op_assign
(paren
(paren
id|sbits64
)paren
id|zSig1
OL
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|zSign
)paren
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
op_logical_and
id|zSig1
suffix:semicolon
)brace
r_else
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
op_logical_and
id|zSig1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|increment
)paren
(brace
op_increment
id|zSig0
suffix:semicolon
id|zSig0
op_and_assign
op_complement
(paren
(paren
id|zSig1
op_plus
id|zSig1
op_eq
l_int|0
)paren
op_amp
id|roundNearestEven
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sbits64
)paren
id|zSig0
OL
l_int|0
)paren
id|zExp
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|zSig1
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
op_increment
id|zSig0
suffix:semicolon
r_if
c_cond
(paren
id|zSig0
op_eq
l_int|0
)paren
(brace
op_increment
id|zExp
suffix:semicolon
id|zSig0
op_assign
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
suffix:semicolon
)brace
r_else
(brace
id|zSig0
op_and_assign
op_complement
(paren
(paren
id|zSig1
op_plus
id|zSig1
op_eq
l_int|0
)paren
op_amp
id|roundNearestEven
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|zSig0
op_eq
l_int|0
)paren
id|zExp
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent&n;`zExp&squot;, and significand formed by the concatenation of `zSig0&squot; and `zSig1&squot;,&n;and returns the proper extended double-precision floating-point value&n;corresponding to the abstract input.  This routine is just like&n;`roundAndPackFloatx80&squot; except that the input significand does not have to be&n;normalized.&n;-------------------------------------------------------------------------------&n;*/
r_static
id|floatx80
DECL|function|normalizeRoundAndPackFloatx80
id|normalizeRoundAndPackFloatx80
c_func
(paren
id|int8
id|roundingPrecision
comma
id|flag
id|zSign
comma
id|int32
id|zExp
comma
id|bits64
id|zSig0
comma
id|bits64
id|zSig1
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
r_if
c_cond
(paren
id|zSig0
op_eq
l_int|0
)paren
(brace
id|zSig0
op_assign
id|zSig1
suffix:semicolon
id|zSig1
op_assign
l_int|0
suffix:semicolon
id|zExp
op_sub_assign
l_int|64
suffix:semicolon
)brace
id|shiftCount
op_assign
id|countLeadingZeros64
c_func
(paren
id|zSig0
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|zSig0
comma
id|zSig1
comma
id|shiftCount
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_sub_assign
id|shiftCount
suffix:semicolon
r_return
id|roundAndPackFloatx80
c_func
(paren
id|roundingPrecision
comma
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef FLOAT128
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the least-significant 64 fraction bits of the quadruple-precision&n;floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat128Frac1
id|INLINE
id|bits64
id|extractFloat128Frac1
c_func
(paren
id|float128
id|a
)paren
(brace
r_return
id|a.low
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the most-significant 48 fraction bits of the quadruple-precision&n;floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat128Frac0
id|INLINE
id|bits64
id|extractFloat128Frac0
c_func
(paren
id|float128
id|a
)paren
(brace
r_return
id|a.high
op_amp
id|LIT64
c_func
(paren
l_int|0x0000FFFFFFFFFFFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the exponent bits of the quadruple-precision floating-point value&n;`a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat128Exp
id|INLINE
id|int32
id|extractFloat128Exp
c_func
(paren
id|float128
id|a
)paren
(brace
r_return
(paren
id|a.high
op_rshift
l_int|48
)paren
op_amp
l_int|0x7FFF
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the sign bit of the quadruple-precision floating-point value `a&squot;.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|extractFloat128Sign
id|INLINE
id|flag
id|extractFloat128Sign
c_func
(paren
id|float128
id|a
)paren
(brace
r_return
id|a.high
op_rshift
l_int|63
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Normalizes the subnormal quadruple-precision floating-point value&n;represented by the denormalized significand formed by the concatenation of&n;`aSig0&squot; and `aSig1&squot;.  The normalized exponent is stored at the location&n;pointed to by `zExpPtr&squot;.  The most significant 49 bits of the normalized&n;significand are stored at the location pointed to by `zSig0Ptr&squot;, and the&n;least significant 64 bits of the normalized significand are stored at the&n;location pointed to by `zSig1Ptr&squot;.&n;-------------------------------------------------------------------------------&n;*/
r_static
r_void
DECL|function|normalizeFloat128Subnormal
id|normalizeFloat128Subnormal
c_func
(paren
id|bits64
id|aSig0
comma
id|bits64
id|aSig1
comma
id|int32
op_star
id|zExpPtr
comma
id|bits64
op_star
id|zSig0Ptr
comma
id|bits64
op_star
id|zSig1Ptr
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
r_if
c_cond
(paren
id|aSig0
op_eq
l_int|0
)paren
(brace
id|shiftCount
op_assign
id|countLeadingZeros64
c_func
(paren
id|aSig1
)paren
op_minus
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|shiftCount
OL
l_int|0
)paren
(brace
op_star
id|zSig0Ptr
op_assign
id|aSig1
op_rshift
(paren
op_minus
id|shiftCount
)paren
suffix:semicolon
op_star
id|zSig1Ptr
op_assign
id|aSig1
op_lshift
(paren
id|shiftCount
op_amp
l_int|63
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|zSig0Ptr
op_assign
id|aSig1
op_lshift
id|shiftCount
suffix:semicolon
op_star
id|zSig1Ptr
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|zExpPtr
op_assign
op_minus
id|shiftCount
op_minus
l_int|63
suffix:semicolon
)brace
r_else
(brace
id|shiftCount
op_assign
id|countLeadingZeros64
c_func
(paren
id|aSig0
)paren
op_minus
l_int|15
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|shiftCount
comma
id|zSig0Ptr
comma
id|zSig1Ptr
)paren
suffix:semicolon
op_star
id|zExpPtr
op_assign
l_int|1
op_minus
id|shiftCount
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Packs the sign `zSign&squot;, the exponent `zExp&squot;, and the significand formed&n;by the concatenation of `zSig0&squot; and `zSig1&squot; into a quadruple-precision&n;floating-point value, returning the result.  After being shifted into the&n;proper positions, the three fields `zSign&squot;, `zExp&squot;, and `zSig0&squot; are simply&n;added together to form the most significant 32 bits of the result.  This&n;means that any integer portion of `zSig0&squot; will be added into the exponent.&n;Since a properly normalized significand will have an integer portion equal&n;to 1, the `zExp&squot; input should be 1 less than the desired result exponent&n;whenever `zSig0&squot; and `zSig1&squot; concatenated form a complete, normalized&n;significand.&n;-------------------------------------------------------------------------------&n;*/
id|INLINE
id|float128
DECL|function|packFloat128
id|packFloat128
c_func
(paren
id|flag
id|zSign
comma
id|int32
id|zExp
comma
id|bits64
id|zSig0
comma
id|bits64
id|zSig1
)paren
(brace
id|float128
id|z
suffix:semicolon
id|z.low
op_assign
id|zSig1
suffix:semicolon
id|z.high
op_assign
(paren
(paren
(paren
id|bits64
)paren
id|zSign
)paren
op_lshift
l_int|63
)paren
op_plus
(paren
(paren
(paren
id|bits64
)paren
id|zExp
)paren
op_lshift
l_int|48
)paren
op_plus
id|zSig0
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent `zExp&squot;,&n;and extended significand formed by the concatenation of `zSig0&squot;, `zSig1&squot;,&n;and `zSig2&squot;, and returns the proper quadruple-precision floating-point value&n;corresponding to the abstract input.  Ordinarily, the abstract value is&n;simply rounded and packed into the quadruple-precision format, with the&n;inexact exception raised if the abstract input cannot be represented&n;exactly.  If the abstract value is too large, however, the overflow and&n;inexact exceptions are raised and an infinity or maximal finite value is&n;returned.  If the abstract value is too small, the input value is rounded to&n;a subnormal number, and the underflow and inexact exceptions are raised if&n;the abstract input cannot be represented exactly as a subnormal quadruple-&n;precision floating-point number.&n;    The input significand must be normalized or smaller.  If the input&n;significand is not normalized, `zExp&squot; must be 0; in that case, the result&n;returned is a subnormal number, and it must not require rounding.  In the&n;usual case that the input significand is normalized, `zExp&squot; must be 1 less&n;than the ``true&squot;&squot; floating-point exponent.  The handling of underflow and&n;overflow follows the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
r_static
id|float128
DECL|function|roundAndPackFloat128
id|roundAndPackFloat128
c_func
(paren
id|flag
id|zSign
comma
id|int32
id|zExp
comma
id|bits64
id|zSig0
comma
id|bits64
id|zSig1
comma
id|bits64
id|zSig2
)paren
(brace
id|int8
id|roundingMode
suffix:semicolon
id|flag
id|roundNearestEven
comma
id|increment
comma
id|isTiny
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
id|roundNearestEven
op_assign
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
suffix:semicolon
id|increment
op_assign
(paren
(paren
id|sbits64
)paren
id|zSig2
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|roundNearestEven
)paren
(brace
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
(brace
id|increment
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|zSign
)paren
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
op_logical_and
id|zSig2
suffix:semicolon
)brace
r_else
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
op_logical_and
id|zSig2
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
l_int|0x7FFD
op_le
(paren
id|bits32
)paren
id|zExp
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|0x7FFD
OL
id|zExp
)paren
op_logical_or
(paren
(paren
id|zExp
op_eq
l_int|0x7FFD
)paren
op_logical_and
id|eq128
c_func
(paren
id|LIT64
c_func
(paren
l_int|0x0001FFFFFFFFFFFF
)paren
comma
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
comma
id|zSig0
comma
id|zSig1
)paren
op_logical_and
id|increment
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_overflow
op_or
id|float_flag_inexact
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|roundingMode
op_eq
id|float_round_to_zero
)paren
op_logical_or
(paren
id|zSign
op_logical_and
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|zSign
op_logical_and
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
)paren
)paren
(brace
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x7FFE
comma
id|LIT64
c_func
(paren
l_int|0x0000FFFFFFFFFFFF
)paren
comma
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
)paren
suffix:semicolon
)brace
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zExp
OL
l_int|0
)paren
(brace
id|isTiny
op_assign
(paren
id|float_detect_tininess
op_eq
id|float_tininess_before_rounding
)paren
op_logical_or
(paren
id|zExp
OL
op_minus
l_int|1
)paren
op_logical_or
op_logical_neg
id|increment
op_logical_or
id|lt128
c_func
(paren
id|zSig0
comma
id|zSig1
comma
id|LIT64
c_func
(paren
l_int|0x0001FFFFFFFFFFFF
)paren
comma
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
)paren
suffix:semicolon
id|shift128ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
id|zSig2
comma
op_minus
id|zExp
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
id|zExp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|isTiny
op_logical_and
id|zSig2
)paren
id|float_raise
c_func
(paren
id|float_flag_underflow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|roundNearestEven
)paren
(brace
id|increment
op_assign
(paren
(paren
id|sbits64
)paren
id|zSig2
OL
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|zSign
)paren
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_down
)paren
op_logical_and
id|zSig2
suffix:semicolon
)brace
r_else
(brace
id|increment
op_assign
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
op_logical_and
id|zSig2
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|zSig2
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
id|add128
c_func
(paren
id|zSig0
comma
id|zSig1
comma
l_int|0
comma
l_int|1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zSig1
op_and_assign
op_complement
(paren
(paren
id|zSig2
op_plus
id|zSig2
op_eq
l_int|0
)paren
op_amp
id|roundNearestEven
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|zSig0
op_or
id|zSig1
)paren
op_eq
l_int|0
)paren
id|zExp
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Takes an abstract floating-point value having sign `zSign&squot;, exponent `zExp&squot;,&n;and significand formed by the concatenation of `zSig0&squot; and `zSig1&squot;, and&n;returns the proper quadruple-precision floating-point value corresponding to&n;the abstract input.  This routine is just like `roundAndPackFloat128&squot; except&n;that the input significand has fewer bits and does not have to be normalized&n;in any way.  In all cases, `zExp&squot; must be 1 less than the ``true&squot;&squot; floating-&n;point exponent.&n;-------------------------------------------------------------------------------&n;*/
r_static
id|float128
DECL|function|normalizeRoundAndPackFloat128
id|normalizeRoundAndPackFloat128
c_func
(paren
id|flag
id|zSign
comma
id|int32
id|zExp
comma
id|bits64
id|zSig0
comma
id|bits64
id|zSig1
)paren
(brace
id|int8
id|shiftCount
suffix:semicolon
id|bits64
id|zSig2
suffix:semicolon
r_if
c_cond
(paren
id|zSig0
op_eq
l_int|0
)paren
(brace
id|zSig0
op_assign
id|zSig1
suffix:semicolon
id|zSig1
op_assign
l_int|0
suffix:semicolon
id|zExp
op_sub_assign
l_int|64
suffix:semicolon
)brace
id|shiftCount
op_assign
id|countLeadingZeros64
c_func
(paren
id|zSig0
)paren
op_minus
l_int|15
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|shiftCount
)paren
(brace
id|zSig2
op_assign
l_int|0
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|zSig0
comma
id|zSig1
comma
id|shiftCount
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
)brace
r_else
(brace
id|shift128ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
l_int|0
comma
op_minus
id|shiftCount
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
)brace
id|zExp
op_sub_assign
id|shiftCount
suffix:semicolon
r_return
id|roundAndPackFloat128
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the 32-bit two&squot;s complement integer `a&squot; to&n;the single-precision floating-point format.  The conversion is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|int32_to_float32
id|float32
id|int32_to_float32
c_func
(paren
id|int32
id|a
)paren
(brace
id|flag
id|zSign
suffix:semicolon
r_if
c_cond
(paren
id|a
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a
op_eq
l_int|0x80000000
)paren
r_return
id|packFloat32
c_func
(paren
l_int|1
comma
l_int|0x9E
comma
l_int|0
)paren
suffix:semicolon
id|zSign
op_assign
(paren
id|a
OL
l_int|0
)paren
suffix:semicolon
r_return
id|normalizeRoundAndPackFloat32
c_func
(paren
id|zSign
comma
l_int|0x9C
comma
id|zSign
ques
c_cond
op_minus
id|a
suffix:colon
id|a
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the 32-bit two&squot;s complement integer `a&squot; to&n;the double-precision floating-point format.  The conversion is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|int32_to_float64
id|float64
id|int32_to_float64
c_func
(paren
id|int32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|uint32
id|absA
suffix:semicolon
id|int8
id|shiftCount
suffix:semicolon
id|bits64
id|zSig
suffix:semicolon
r_if
c_cond
(paren
id|a
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|aSign
op_assign
(paren
id|a
OL
l_int|0
)paren
suffix:semicolon
id|absA
op_assign
id|aSign
ques
c_cond
op_minus
id|a
suffix:colon
id|a
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros32
c_func
(paren
id|absA
)paren
op_plus
l_int|21
suffix:semicolon
id|zSig
op_assign
id|absA
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
l_int|0x432
op_minus
id|shiftCount
comma
id|zSig
op_lshift
id|shiftCount
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOATX80
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the 32-bit two&squot;s complement integer `a&squot;&n;to the extended double-precision floating-point format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|int32_to_floatx80
id|floatx80
id|int32_to_floatx80
c_func
(paren
id|int32
id|a
)paren
(brace
id|flag
id|zSign
suffix:semicolon
id|uint32
id|absA
suffix:semicolon
id|int8
id|shiftCount
suffix:semicolon
id|bits64
id|zSig
suffix:semicolon
r_if
c_cond
(paren
id|a
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|zSign
op_assign
(paren
id|a
OL
l_int|0
)paren
suffix:semicolon
id|absA
op_assign
id|zSign
ques
c_cond
op_minus
id|a
suffix:colon
id|a
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros32
c_func
(paren
id|absA
)paren
op_plus
l_int|32
suffix:semicolon
id|zSig
op_assign
id|absA
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x403E
op_minus
id|shiftCount
comma
id|zSig
op_lshift
id|shiftCount
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef FLOAT128
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the 32-bit two&squot;s complement integer `a&squot; to&n;the quadruple-precision floating-point format.  The conversion is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|int32_to_float128
id|float128
id|int32_to_float128
c_func
(paren
id|int32
id|a
)paren
(brace
id|flag
id|zSign
suffix:semicolon
id|uint32
id|absA
suffix:semicolon
id|int8
id|shiftCount
suffix:semicolon
id|bits64
id|zSig0
suffix:semicolon
r_if
c_cond
(paren
id|a
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|zSign
op_assign
(paren
id|a
OL
l_int|0
)paren
suffix:semicolon
id|absA
op_assign
id|zSign
ques
c_cond
op_minus
id|a
suffix:colon
id|a
suffix:semicolon
id|shiftCount
op_assign
id|countLeadingZeros32
c_func
(paren
id|absA
)paren
op_plus
l_int|17
suffix:semicolon
id|zSig0
op_assign
id|absA
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x402E
op_minus
id|shiftCount
comma
id|zSig0
op_lshift
id|shiftCount
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the single-precision floating-point value&n;`a&squot; to the 32-bit two&squot;s complement integer format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic---which means in particular that the conversion is rounded&n;according to the current rounding mode.  If `a&squot; is a NaN, the largest&n;positive integer is returned.  Otherwise, if the conversion overflows, the&n;largest integer with the same sign as `a&squot; is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_to_int32
id|int32
id|float32_to_int32
c_func
(paren
id|float32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits32
id|aSig
suffix:semicolon
id|bits64
id|zSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
op_logical_and
id|aSig
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aExp
)paren
id|aSig
op_or_assign
l_int|0x00800000
suffix:semicolon
id|shiftCount
op_assign
l_int|0xAF
op_minus
id|aExp
suffix:semicolon
id|zSig
op_assign
id|aSig
suffix:semicolon
id|zSig
op_lshift_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|shiftCount
)paren
id|shift64RightJamming
c_func
(paren
id|zSig
comma
id|shiftCount
comma
op_amp
id|zSig
)paren
suffix:semicolon
r_return
id|roundAndPackInt32
c_func
(paren
id|aSign
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the single-precision floating-point value&n;`a&squot; to the 32-bit two&squot;s complement integer format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic, except that the conversion is always rounded toward zero.  If&n;`a&squot; is a NaN, the largest positive integer is returned.  Otherwise, if the&n;conversion overflows, the largest integer with the same sign as `a&squot; is&n;returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_to_int32_round_to_zero
id|int32
id|float32_to_int32_round_to_zero
c_func
(paren
id|float32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits32
id|aSig
suffix:semicolon
id|int32
id|z
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|shiftCount
op_assign
id|aExp
op_minus
l_int|0x9E
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
id|shiftCount
)paren
(brace
r_if
c_cond
(paren
id|a
op_eq
l_int|0xCF000000
)paren
r_return
l_int|0x80000000
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aSign
op_logical_or
(paren
(paren
id|aExp
op_eq
l_int|0xFF
)paren
op_logical_and
id|aSig
)paren
)paren
r_return
l_int|0x7FFFFFFF
suffix:semicolon
r_return
l_int|0x80000000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|aExp
op_le
l_int|0x7E
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_or
id|aSig
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSig
op_assign
(paren
id|aSig
op_or
l_int|0x00800000
)paren
op_lshift
l_int|8
suffix:semicolon
id|z
op_assign
id|aSig
op_rshift
(paren
op_minus
id|shiftCount
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bits32
)paren
(paren
id|aSig
op_lshift
(paren
id|shiftCount
op_amp
l_int|31
)paren
)paren
)paren
(brace
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
op_minus
id|z
suffix:colon
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the single-precision floating-point value&n;`a&squot; to the double-precision floating-point format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_to_float64
id|float64
id|float32_to_float64
c_func
(paren
id|float32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits32
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|commonNaNToFloat64
c_func
(paren
id|float32ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
op_decrement
id|aExp
suffix:semicolon
)brace
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
id|aExp
op_plus
l_int|0x380
comma
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|29
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOATX80
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the single-precision floating-point value&n;`a&squot; to the extended double-precision floating-point format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_to_floatx80
id|floatx80
id|float32_to_floatx80
c_func
(paren
id|float32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits32
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|commonNaNToFloatx80
c_func
(paren
id|float32ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|aSig
op_or_assign
l_int|0x00800000
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
id|aExp
op_plus
l_int|0x3F80
comma
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|40
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef FLOAT128
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the single-precision floating-point value&n;`a&squot; to the double-precision floating-point format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_to_float128
id|float128
id|float32_to_float128
c_func
(paren
id|float32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits32
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|commonNaNToFloat128
c_func
(paren
id|float32ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
op_decrement
id|aExp
suffix:semicolon
)brace
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
id|aExp
op_plus
l_int|0x3F80
comma
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|25
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Rounds the single-precision floating-point value `a&squot; to an integer, and&n;returns the result as a single-precision floating-point value.  The&n;operation is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_round_to_int
id|float32
id|float32_round_to_int
c_func
(paren
id|float32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits32
id|lastBitMask
comma
id|roundBitsMask
suffix:semicolon
id|int8
id|roundingMode
suffix:semicolon
id|float32
id|z
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0x96
op_le
id|aExp
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
(brace
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|a
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_le
l_int|0x7E
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits32
)paren
(paren
id|a
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|float_rounding_mode
)paren
(brace
r_case
id|float_round_nearest_even
suffix:colon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7E
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
(brace
r_return
id|packFloat32
c_func
(paren
id|aSign
comma
l_int|0x7F
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|float_round_down
suffix:colon
r_return
id|aSign
ques
c_cond
l_int|0xBF800000
suffix:colon
l_int|0
suffix:semicolon
r_case
id|float_round_up
suffix:colon
r_return
id|aSign
ques
c_cond
l_int|0x80000000
suffix:colon
l_int|0x3F800000
suffix:semicolon
)brace
r_return
id|packFloat32
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|lastBitMask
op_assign
l_int|1
suffix:semicolon
id|lastBitMask
op_lshift_assign
l_int|0x96
op_minus
id|aExp
suffix:semicolon
id|roundBitsMask
op_assign
id|lastBitMask
op_minus
l_int|1
suffix:semicolon
id|z
op_assign
id|a
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
(brace
id|z
op_add_assign
id|lastBitMask
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
op_amp
id|roundBitsMask
)paren
op_eq
l_int|0
)paren
id|z
op_and_assign
op_complement
id|lastBitMask
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|roundingMode
op_ne
id|float_round_to_zero
)paren
(brace
r_if
c_cond
(paren
id|extractFloat32Sign
c_func
(paren
id|z
)paren
op_xor
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
)paren
(brace
id|z
op_add_assign
id|roundBitsMask
suffix:semicolon
)brace
)brace
id|z
op_and_assign
op_complement
id|roundBitsMask
suffix:semicolon
r_if
c_cond
(paren
id|z
op_ne
id|a
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the absolute values of the single-precision&n;floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true, the sum is negated&n;before being returned.  `zSign&squot; is ignored if the result is a NaN.  The&n;addition is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|addFloat32Sigs
r_static
id|float32
id|addFloat32Sigs
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits32
id|aSig
comma
id|bSig
comma
id|zSig
suffix:semicolon
id|int16
id|expDiff
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|aSig
op_lshift_assign
l_int|6
suffix:semicolon
id|bSig
op_lshift_assign
l_int|6
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
op_decrement
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|bSig
op_or_assign
l_int|0x20000000
suffix:semicolon
)brace
id|shift32RightJamming
c_func
(paren
id|bSig
comma
id|expDiff
comma
op_amp
id|bSig
)paren
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
op_increment
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_or_assign
l_int|0x20000000
suffix:semicolon
)brace
id|shift32RightJamming
c_func
(paren
id|aSig
comma
op_minus
id|expDiff
comma
op_amp
id|aSig
)paren
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_or
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0
comma
(paren
id|aSig
op_plus
id|bSig
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|zSig
op_assign
l_int|0x40000000
op_plus
id|aSig
op_plus
id|bSig
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
r_goto
id|roundAndPack
suffix:semicolon
)brace
id|aSig
op_or_assign
l_int|0x20000000
suffix:semicolon
id|zSig
op_assign
(paren
id|aSig
op_plus
id|bSig
)paren
op_lshift
l_int|1
suffix:semicolon
op_decrement
id|zExp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sbits32
)paren
id|zSig
OL
l_int|0
)paren
(brace
id|zSig
op_assign
id|aSig
op_plus
id|bSig
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
)brace
id|roundAndPack
suffix:colon
r_return
id|roundAndPackFloat32
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the absolute values of the single-&n;precision floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true, the&n;difference is negated before being returned.  `zSign&squot; is ignored if the&n;result is a NaN.  The subtraction is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|subFloat32Sigs
r_static
id|float32
id|subFloat32Sigs
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits32
id|aSig
comma
id|bSig
comma
id|zSig
suffix:semicolon
id|int16
id|expDiff
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|aSig
op_lshift_assign
l_int|7
suffix:semicolon
id|bSig
op_lshift_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
r_goto
id|aExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
r_goto
id|bExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_or
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
id|aExp
op_assign
l_int|1
suffix:semicolon
id|bExp
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bSig
OL
id|aSig
)paren
r_goto
id|aBigger
suffix:semicolon
r_if
c_cond
(paren
id|aSig
OL
id|bSig
)paren
r_goto
id|bBigger
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|float_rounding_mode
op_eq
id|float_round_down
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|bExpBigger
suffix:colon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|zSign
op_xor
l_int|1
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
op_increment
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_or_assign
l_int|0x40000000
suffix:semicolon
)brace
id|shift32RightJamming
c_func
(paren
id|aSig
comma
op_minus
id|expDiff
comma
op_amp
id|aSig
)paren
suffix:semicolon
id|bSig
op_or_assign
l_int|0x40000000
suffix:semicolon
id|bBigger
suffix:colon
id|zSig
op_assign
id|bSig
op_minus
id|aSig
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
id|zSign
op_xor_assign
l_int|1
suffix:semicolon
r_goto
id|normalizeRoundAndPack
suffix:semicolon
id|aExpBigger
suffix:colon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
op_decrement
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|bSig
op_or_assign
l_int|0x40000000
suffix:semicolon
)brace
id|shift32RightJamming
c_func
(paren
id|bSig
comma
id|expDiff
comma
op_amp
id|bSig
)paren
suffix:semicolon
id|aSig
op_or_assign
l_int|0x40000000
suffix:semicolon
id|aBigger
suffix:colon
id|zSig
op_assign
id|aSig
op_minus
id|bSig
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
id|normalizeRoundAndPack
suffix:colon
op_decrement
id|zExp
suffix:semicolon
r_return
id|normalizeRoundAndPackFloat32
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the single-precision floating-point values `a&squot;&n;and `b&squot;.  The operation is performed according to the IEC/IEEE Standard for&n;Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_add
id|float32
id|float32_add
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|addFloat32Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|subFloat32Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the single-precision floating-point values&n;`a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE Standard&n;for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_sub
id|float32
id|float32_sub
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|subFloat32Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|addFloat32Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of multiplying the single-precision floating-point values&n;`a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE Standard&n;for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_mul
id|float32
id|float32_mul
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits32
id|aSig
comma
id|bSig
suffix:semicolon
id|bits64
id|zSig64
suffix:semicolon
id|bits32
id|zSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0xFF
)paren
op_logical_and
id|bSig
)paren
)paren
(brace
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bExp
op_or
id|bSig
)paren
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_plus
id|bExp
op_minus
l_int|0x7F
suffix:semicolon
id|aSig
op_assign
(paren
id|aSig
op_or
l_int|0x00800000
)paren
op_lshift
l_int|7
suffix:semicolon
id|bSig
op_assign
(paren
id|bSig
op_or
l_int|0x00800000
)paren
op_lshift
l_int|8
suffix:semicolon
id|shift64RightJamming
c_func
(paren
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_star
id|bSig
comma
l_int|32
comma
op_amp
id|zSig64
)paren
suffix:semicolon
id|zSig
op_assign
id|zSig64
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
(paren
id|sbits32
)paren
(paren
id|zSig
op_lshift
l_int|1
)paren
)paren
(brace
id|zSig
op_lshift_assign
l_int|1
suffix:semicolon
op_decrement
id|zExp
suffix:semicolon
)brace
r_return
id|roundAndPackFloat32
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of dividing the single-precision floating-point value `a&squot;&n;by the corresponding value `b&squot;.  The operation is performed according to the&n;IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_div
id|float32
id|float32_div
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits32
id|aSig
comma
id|bSig
comma
id|zSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_divbyzero
)paren
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
id|normalizeFloat32Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloat32
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_minus
id|bExp
op_plus
l_int|0x7D
suffix:semicolon
id|aSig
op_assign
(paren
id|aSig
op_or
l_int|0x00800000
)paren
op_lshift
l_int|7
suffix:semicolon
id|bSig
op_assign
(paren
id|bSig
op_or
l_int|0x00800000
)paren
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|bSig
op_le
(paren
id|aSig
op_plus
id|aSig
)paren
)paren
(brace
id|aSig
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
)brace
id|zSig
op_assign
(paren
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|32
)paren
op_div
id|bSig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zSig
op_amp
l_int|0x3F
)paren
op_eq
l_int|0
)paren
(brace
id|zSig
op_or_assign
(paren
(paren
(paren
id|bits64
)paren
id|bSig
)paren
op_star
id|zSig
op_ne
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
)brace
r_return
id|roundAndPackFloat32
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the remainder of the single-precision floating-point value `a&squot;&n;with respect to the corresponding value `b&squot;.  The operation is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_rem
id|float32
id|float32_rem
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int16
id|aExp
comma
id|bExp
comma
id|expDiff
suffix:semicolon
id|bits32
id|aSig
comma
id|bSig
suffix:semicolon
id|bits32
id|q
suffix:semicolon
id|bits64
id|aSig64
comma
id|bSig64
comma
id|q64
suffix:semicolon
id|bits32
id|alternateASig
suffix:semicolon
id|sbits32
id|sigMean
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0xFF
)paren
op_logical_and
id|bSig
)paren
)paren
(brace
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
id|normalizeFloat32Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|aSig
op_or_assign
l_int|0x00800000
suffix:semicolon
id|bSig
op_or_assign
l_int|0x00800000
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|32
)paren
(brace
id|aSig
op_lshift_assign
l_int|8
suffix:semicolon
id|bSig
op_lshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|expDiff
OL
op_minus
l_int|1
)paren
r_return
id|a
suffix:semicolon
id|aSig
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|q
op_assign
(paren
id|bSig
op_le
id|aSig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
id|aSig
op_sub_assign
id|bSig
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
(brace
id|q
op_assign
(paren
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|32
)paren
op_div
id|bSig
suffix:semicolon
id|q
op_rshift_assign
l_int|32
op_minus
id|expDiff
suffix:semicolon
id|bSig
op_rshift_assign
l_int|2
suffix:semicolon
id|aSig
op_assign
(paren
(paren
id|aSig
op_rshift
l_int|1
)paren
op_lshift
(paren
id|expDiff
op_minus
l_int|1
)paren
)paren
op_minus
id|bSig
op_star
id|q
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_rshift_assign
l_int|2
suffix:semicolon
id|bSig
op_rshift_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|bSig
op_le
id|aSig
)paren
id|aSig
op_sub_assign
id|bSig
suffix:semicolon
id|aSig64
op_assign
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|40
suffix:semicolon
id|bSig64
op_assign
(paren
(paren
id|bits64
)paren
id|bSig
)paren
op_lshift
l_int|40
suffix:semicolon
id|expDiff
op_sub_assign
l_int|64
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|expDiff
)paren
(brace
id|q64
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig64
comma
l_int|0
comma
id|bSig64
)paren
suffix:semicolon
id|q64
op_assign
(paren
l_int|2
OL
id|q64
)paren
ques
c_cond
id|q64
op_minus
l_int|2
suffix:colon
l_int|0
suffix:semicolon
id|aSig64
op_assign
op_minus
(paren
(paren
id|bSig
op_star
id|q64
)paren
op_lshift
l_int|38
)paren
suffix:semicolon
id|expDiff
op_sub_assign
l_int|62
suffix:semicolon
)brace
id|expDiff
op_add_assign
l_int|64
suffix:semicolon
id|q64
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig64
comma
l_int|0
comma
id|bSig64
)paren
suffix:semicolon
id|q64
op_assign
(paren
l_int|2
OL
id|q64
)paren
ques
c_cond
id|q64
op_minus
l_int|2
suffix:colon
l_int|0
suffix:semicolon
id|q
op_assign
id|q64
op_rshift
(paren
l_int|64
op_minus
id|expDiff
)paren
suffix:semicolon
id|bSig
op_lshift_assign
l_int|6
suffix:semicolon
id|aSig
op_assign
(paren
(paren
id|aSig64
op_rshift
l_int|33
)paren
op_lshift
(paren
id|expDiff
op_minus
l_int|1
)paren
)paren
op_minus
id|bSig
op_star
id|q
suffix:semicolon
)brace
r_do
(brace
id|alternateASig
op_assign
id|aSig
suffix:semicolon
op_increment
id|q
suffix:semicolon
id|aSig
op_sub_assign
id|bSig
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
op_le
(paren
id|sbits32
)paren
id|aSig
)paren
suffix:semicolon
id|sigMean
op_assign
id|aSig
op_plus
id|alternateASig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sigMean
OL
l_int|0
)paren
op_logical_or
(paren
(paren
id|sigMean
op_eq
l_int|0
)paren
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|aSig
op_assign
id|alternateASig
suffix:semicolon
)brace
id|zSign
op_assign
(paren
(paren
id|sbits32
)paren
id|aSig
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
id|aSig
op_assign
op_minus
id|aSig
suffix:semicolon
r_return
id|normalizeRoundAndPackFloat32
c_func
(paren
id|aSign
op_xor
id|zSign
comma
id|bExp
comma
id|aSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the square root of the single-precision floating-point value `a&squot;.&n;The operation is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_sqrt
id|float32
id|float32_sqrt
c_func
(paren
id|float32
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|zExp
suffix:semicolon
id|bits32
id|aSig
comma
id|zSig
suffix:semicolon
id|bits64
id|rem
comma
id|term
suffix:semicolon
id|aSig
op_assign
id|extractFloat32Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat32Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat32NaN
c_func
(paren
id|a
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aSign
)paren
r_return
id|a
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aSign
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float32_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|normalizeFloat32Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
(paren
(paren
id|aExp
op_minus
l_int|0x7F
)paren
op_rshift
l_int|1
)paren
op_plus
l_int|0x7E
suffix:semicolon
id|aSig
op_assign
(paren
id|aSig
op_or
l_int|0x00800000
)paren
op_lshift
l_int|8
suffix:semicolon
id|zSig
op_assign
id|estimateSqrt32
c_func
(paren
id|aExp
comma
id|aSig
)paren
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zSig
op_amp
l_int|0x7F
)paren
op_le
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|zSig
OL
l_int|2
)paren
(brace
id|zSig
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_rshift_assign
id|aExp
op_amp
l_int|1
suffix:semicolon
id|term
op_assign
(paren
(paren
id|bits64
)paren
id|zSig
)paren
op_star
id|zSig
suffix:semicolon
id|rem
op_assign
(paren
(paren
(paren
id|bits64
)paren
id|aSig
)paren
op_lshift
l_int|32
)paren
op_minus
id|term
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem
OL
l_int|0
)paren
(brace
op_decrement
id|zSig
suffix:semicolon
id|rem
op_add_assign
(paren
(paren
(paren
id|bits64
)paren
id|zSig
)paren
op_lshift
l_int|1
)paren
op_or
l_int|1
suffix:semicolon
)brace
id|zSig
op_or_assign
(paren
id|rem
op_ne
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|shift32RightJamming
c_func
(paren
id|zSig
comma
l_int|1
comma
op_amp
id|zSig
)paren
suffix:semicolon
r_return
id|roundAndPackFloat32
c_func
(paren
l_int|0
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the single-precision floating-point value `a&squot; is equal to the&n;corresponding value `b&squot;, and 0 otherwise.  The comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_eq
id|flag
id|float32_eq
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float32_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float32_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
(paren
id|bits32
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the single-precision floating-point value `a&squot; is less than or&n;equal to the corresponding value `b&squot;, and 0 otherwise.  The comparison is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_le
id|flag
id|float32_le
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_or
(paren
(paren
id|bits32
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the single-precision floating-point value `a&squot; is less than&n;the corresponding value `b&squot;, and 0 otherwise.  The comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_lt
id|flag
id|float32_lt
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_and
(paren
(paren
id|bits32
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_ne
id|b
)paren
op_logical_and
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the single-precision floating-point value `a&squot; is equal to the&n;corresponding value `b&squot;, and 0 otherwise.  The invalid exception is raised&n;if either operand is a NaN.  Otherwise, the comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_eq_signaling
id|flag
id|float32_eq_signaling
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
(paren
id|bits32
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the single-precision floating-point value `a&squot; is less than or&n;equal to the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs do not&n;cause an exception.  Otherwise, the comparison is performed according to the&n;IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_le_quiet
id|flag
id|float32_le_quiet
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
singleline_comment|//int16 aExp, bExp;
r_if
c_cond
(paren
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float32_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float32_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_or
(paren
(paren
id|bits32
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the single-precision floating-point value `a&squot; is less than&n;the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs do not cause an&n;exception.  Otherwise, the comparison is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float32_lt_quiet
id|flag
id|float32_lt_quiet
c_func
(paren
id|float32
id|a
comma
id|float32
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat32Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0xFF
)paren
op_logical_and
id|extractFloat32Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float32_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float32_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat32Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_and
(paren
(paren
id|bits32
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_ne
id|b
)paren
op_logical_and
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the double-precision floating-point value&n;`a&squot; to the 32-bit two&squot;s complement integer format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic---which means in particular that the conversion is rounded&n;according to the current rounding mode.  If `a&squot; is a NaN, the largest&n;positive integer is returned.  Otherwise, if the conversion overflows, the&n;largest integer with the same sign as `a&squot; is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_to_int32
id|int32
id|float64_to_int32
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
op_logical_and
id|aSig
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aExp
)paren
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
suffix:semicolon
id|shiftCount
op_assign
l_int|0x42C
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|shiftCount
)paren
id|shift64RightJamming
c_func
(paren
id|aSig
comma
id|shiftCount
comma
op_amp
id|aSig
)paren
suffix:semicolon
r_return
id|roundAndPackInt32
c_func
(paren
id|aSign
comma
id|aSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the double-precision floating-point value&n;`a&squot; to the 32-bit two&squot;s complement integer format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic, except that the conversion is always rounded toward zero.  If&n;`a&squot; is a NaN, the largest positive integer is returned.  Otherwise, if the&n;conversion overflows, the largest integer with the same sign as `a&squot; is&n;returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_to_int32_round_to_zero
id|int32
id|float64_to_int32_round_to_zero
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig
comma
id|savedASig
suffix:semicolon
id|int32
id|z
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|shiftCount
op_assign
l_int|0x433
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
id|shiftCount
OL
l_int|21
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
op_logical_and
id|aSig
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|52
OL
id|shiftCount
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_logical_or
id|aSig
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
suffix:semicolon
id|savedASig
op_assign
id|aSig
suffix:semicolon
id|aSig
op_rshift_assign
id|shiftCount
suffix:semicolon
id|z
op_assign
id|aSig
suffix:semicolon
r_if
c_cond
(paren
id|aSign
)paren
id|z
op_assign
op_minus
id|z
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
OL
l_int|0
)paren
op_xor
id|aSign
)paren
(brace
id|invalid
suffix:colon
id|float_exception_flags
op_or_assign
id|float_flag_invalid
suffix:semicolon
r_return
id|aSign
ques
c_cond
l_int|0x80000000
suffix:colon
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|aSig
op_lshift
id|shiftCount
)paren
op_ne
id|savedASig
)paren
(brace
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
)brace
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the double-precision floating-point value&n;`a&squot; to the 32-bit two&squot;s complement unsigned integer format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic---which means in particular that the conversion is rounded&n;according to the current rounding mode.  If `a&squot; is a NaN, the largest&n;positive integer is returned.  Otherwise, if the conversion overflows, the&n;largest positive integer is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_to_uint32
id|int32
id|float64_to_uint32
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
l_int|0
suffix:semicolon
singleline_comment|//extractFloat64Sign( a );
singleline_comment|//if ( ( aExp == 0x7FF ) &amp;&amp; aSig ) aSign = 0;
r_if
c_cond
(paren
id|aExp
)paren
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
suffix:semicolon
id|shiftCount
op_assign
l_int|0x42C
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|shiftCount
)paren
id|shift64RightJamming
c_func
(paren
id|aSig
comma
id|shiftCount
comma
op_amp
id|aSig
)paren
suffix:semicolon
r_return
id|roundAndPackInt32
c_func
(paren
id|aSign
comma
id|aSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the double-precision floating-point value&n;`a&squot; to the 32-bit two&squot;s complement integer format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic, except that the conversion is always rounded toward zero.  If&n;`a&squot; is a NaN, the largest positive integer is returned.  Otherwise, if the&n;conversion overflows, the largest positive integer is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_to_uint32_round_to_zero
id|int32
id|float64_to_uint32_round_to_zero
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig
comma
id|savedASig
suffix:semicolon
id|int32
id|z
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|shiftCount
op_assign
l_int|0x433
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
id|shiftCount
OL
l_int|21
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
op_logical_and
id|aSig
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|52
OL
id|shiftCount
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_logical_or
id|aSig
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
suffix:semicolon
id|savedASig
op_assign
id|aSig
suffix:semicolon
id|aSig
op_rshift_assign
id|shiftCount
suffix:semicolon
id|z
op_assign
id|aSig
suffix:semicolon
r_if
c_cond
(paren
id|aSign
)paren
id|z
op_assign
op_minus
id|z
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
OL
l_int|0
)paren
op_xor
id|aSign
)paren
(brace
id|invalid
suffix:colon
id|float_exception_flags
op_or_assign
id|float_flag_invalid
suffix:semicolon
r_return
id|aSign
ques
c_cond
l_int|0x80000000
suffix:colon
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|aSig
op_lshift
id|shiftCount
)paren
op_ne
id|savedASig
)paren
(brace
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
)brace
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the double-precision floating-point value&n;`a&squot; to the single-precision floating-point format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_to_float32
id|float32
id|float64_to_float32
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits64
id|aSig
suffix:semicolon
id|bits32
id|zSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|commonNaNToFloat32
c_func
(paren
id|float64ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
r_return
id|packFloat32
c_func
(paren
id|aSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
id|shift64RightJamming
c_func
(paren
id|aSig
comma
l_int|22
comma
op_amp
id|aSig
)paren
suffix:semicolon
id|zSig
op_assign
id|aSig
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_logical_or
id|zSig
)paren
(brace
id|zSig
op_or_assign
l_int|0x40000000
suffix:semicolon
id|aExp
op_sub_assign
l_int|0x381
suffix:semicolon
)brace
r_return
id|roundAndPackFloat32
c_func
(paren
id|aSign
comma
id|aExp
comma
id|zSig
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOATX80
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the double-precision floating-point value&n;`a&squot; to the extended double-precision floating-point format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_to_floatx80
id|floatx80
id|float64_to_floatx80
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits64
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|commonNaNToFloatx80
c_func
(paren
id|float64ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat64Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
id|aExp
op_plus
l_int|0x3C00
comma
(paren
id|aSig
op_or
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
)paren
op_lshift
l_int|11
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef FLOAT128
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the double-precision floating-point value&n;`a&squot; to the quadruple-precision floating-point format.  The conversion is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_to_float128
id|float128
id|float64_to_float128
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits64
id|aSig
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|commonNaNToFloat128
c_func
(paren
id|float64ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat64Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
op_decrement
id|aExp
suffix:semicolon
)brace
id|shift128Right
c_func
(paren
id|aSig
comma
l_int|0
comma
l_int|4
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
id|aExp
op_plus
l_int|0x3C00
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Rounds the double-precision floating-point value `a&squot; to an integer, and&n;returns the result as a double-precision floating-point value.  The&n;operation is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_round_to_int
id|float64
id|float64_round_to_int
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits64
id|lastBitMask
comma
id|roundBitsMask
suffix:semicolon
id|int8
id|roundingMode
suffix:semicolon
id|float64
id|z
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0x433
op_le
id|aExp
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
(brace
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|a
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_le
l_int|0x3FE
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|a
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|float_rounding_mode
)paren
(brace
r_case
id|float_round_nearest_even
suffix:colon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x3FE
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
(brace
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
l_int|0x3FF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|float_round_down
suffix:colon
r_return
id|aSign
ques
c_cond
id|LIT64
c_func
(paren
l_int|0xBFF0000000000000
)paren
suffix:colon
l_int|0
suffix:semicolon
r_case
id|float_round_up
suffix:colon
r_return
id|aSign
ques
c_cond
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
suffix:colon
id|LIT64
c_func
(paren
l_int|0x3FF0000000000000
)paren
suffix:semicolon
)brace
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|lastBitMask
op_assign
l_int|1
suffix:semicolon
id|lastBitMask
op_lshift_assign
l_int|0x433
op_minus
id|aExp
suffix:semicolon
id|roundBitsMask
op_assign
id|lastBitMask
op_minus
l_int|1
suffix:semicolon
id|z
op_assign
id|a
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
(brace
id|z
op_add_assign
id|lastBitMask
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
op_amp
id|roundBitsMask
)paren
op_eq
l_int|0
)paren
id|z
op_and_assign
op_complement
id|lastBitMask
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|roundingMode
op_ne
id|float_round_to_zero
)paren
(brace
r_if
c_cond
(paren
id|extractFloat64Sign
c_func
(paren
id|z
)paren
op_xor
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
)paren
(brace
id|z
op_add_assign
id|roundBitsMask
suffix:semicolon
)brace
)brace
id|z
op_and_assign
op_complement
id|roundBitsMask
suffix:semicolon
r_if
c_cond
(paren
id|z
op_ne
id|a
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the absolute values of the double-precision&n;floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true, the sum is negated&n;before being returned.  `zSign&squot; is ignored if the result is a NaN.  The&n;addition is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|addFloat64Sigs
r_static
id|float64
id|addFloat64Sigs
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig
suffix:semicolon
id|int16
id|expDiff
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|aSig
op_lshift_assign
l_int|9
suffix:semicolon
id|bSig
op_lshift_assign
l_int|9
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
op_decrement
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|bSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x2000000000000000
)paren
suffix:semicolon
)brace
id|shift64RightJamming
c_func
(paren
id|bSig
comma
id|expDiff
comma
op_amp
id|bSig
)paren
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
op_increment
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x2000000000000000
)paren
suffix:semicolon
)brace
id|shift64RightJamming
c_func
(paren
id|aSig
comma
op_minus
id|expDiff
comma
op_amp
id|aSig
)paren
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_or
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0
comma
(paren
id|aSig
op_plus
id|bSig
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
id|zSig
op_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
op_plus
id|aSig
op_plus
id|bSig
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
r_goto
id|roundAndPack
suffix:semicolon
)brace
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x2000000000000000
)paren
suffix:semicolon
id|zSig
op_assign
(paren
id|aSig
op_plus
id|bSig
)paren
op_lshift
l_int|1
suffix:semicolon
op_decrement
id|zExp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sbits64
)paren
id|zSig
OL
l_int|0
)paren
(brace
id|zSig
op_assign
id|aSig
op_plus
id|bSig
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
)brace
id|roundAndPack
suffix:colon
r_return
id|roundAndPackFloat64
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the absolute values of the double-&n;precision floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true, the&n;difference is negated before being returned.  `zSign&squot; is ignored if the&n;result is a NaN.  The subtraction is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|subFloat64Sigs
r_static
id|float64
id|subFloat64Sigs
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig
suffix:semicolon
id|int16
id|expDiff
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|aSig
op_lshift_assign
l_int|10
suffix:semicolon
id|bSig
op_lshift_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
r_goto
id|aExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
r_goto
id|bExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_or
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
id|aExp
op_assign
l_int|1
suffix:semicolon
id|bExp
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bSig
OL
id|aSig
)paren
r_goto
id|aBigger
suffix:semicolon
r_if
c_cond
(paren
id|aSig
OL
id|bSig
)paren
r_goto
id|bBigger
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|float_rounding_mode
op_eq
id|float_round_down
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|bExpBigger
suffix:colon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|zSign
op_xor
l_int|1
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
op_increment
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
)brace
id|shift64RightJamming
c_func
(paren
id|aSig
comma
op_minus
id|expDiff
comma
op_amp
id|aSig
)paren
suffix:semicolon
id|bSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
id|bBigger
suffix:colon
id|zSig
op_assign
id|bSig
op_minus
id|aSig
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
id|zSign
op_xor_assign
l_int|1
suffix:semicolon
r_goto
id|normalizeRoundAndPack
suffix:semicolon
id|aExpBigger
suffix:colon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
op_decrement
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|bSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
)brace
id|shift64RightJamming
c_func
(paren
id|bSig
comma
id|expDiff
comma
op_amp
id|bSig
)paren
suffix:semicolon
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
id|aBigger
suffix:colon
id|zSig
op_assign
id|aSig
op_minus
id|bSig
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
id|normalizeRoundAndPack
suffix:colon
op_decrement
id|zExp
suffix:semicolon
r_return
id|normalizeRoundAndPackFloat64
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the double-precision floating-point values `a&squot;&n;and `b&squot;.  The operation is performed according to the IEC/IEEE Standard for&n;Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_add
id|float64
id|float64_add
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|addFloat64Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|subFloat64Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the double-precision floating-point values&n;`a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE Standard&n;for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_sub
id|float64
id|float64_sub
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|subFloat64Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|addFloat64Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of multiplying the double-precision floating-point values&n;`a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE Standard&n;for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_mul
id|float64
id|float64_mul
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
op_logical_and
id|bSig
)paren
)paren
(brace
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bExp
op_or
id|bSig
)paren
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat64Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat64Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_plus
id|bExp
op_minus
l_int|0x3FF
suffix:semicolon
id|aSig
op_assign
(paren
id|aSig
op_or
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
)paren
op_lshift
l_int|10
suffix:semicolon
id|bSig
op_assign
(paren
id|bSig
op_or
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
)paren
op_lshift
l_int|11
suffix:semicolon
id|mul64To128
c_func
(paren
id|aSig
comma
id|bSig
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zSig0
op_or_assign
(paren
id|zSig1
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
(paren
id|sbits64
)paren
(paren
id|zSig0
op_lshift
l_int|1
)paren
)paren
(brace
id|zSig0
op_lshift_assign
l_int|1
suffix:semicolon
op_decrement
id|zExp
suffix:semicolon
)brace
r_return
id|roundAndPackFloat64
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of dividing the double-precision floating-point value `a&squot;&n;by the corresponding value `b&squot;.  The operation is performed according to&n;the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_div
id|float64
id|float64_div
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int16
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig
suffix:semicolon
id|bits64
id|rem0
comma
id|rem1
suffix:semicolon
id|bits64
id|term0
comma
id|term1
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_divbyzero
)paren
suffix:semicolon
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
id|normalizeFloat64Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloat64
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat64Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_minus
id|bExp
op_plus
l_int|0x3FD
suffix:semicolon
id|aSig
op_assign
(paren
id|aSig
op_or
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
)paren
op_lshift
l_int|10
suffix:semicolon
id|bSig
op_assign
(paren
id|bSig
op_or
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
)paren
op_lshift
l_int|11
suffix:semicolon
r_if
c_cond
(paren
id|bSig
op_le
(paren
id|aSig
op_plus
id|aSig
)paren
)paren
(brace
id|aSig
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
)brace
id|zSig
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig
comma
l_int|0
comma
id|bSig
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zSig
op_amp
l_int|0x1FF
)paren
op_le
l_int|2
)paren
(brace
id|mul64To128
c_func
(paren
id|bSig
comma
id|zSig
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig
comma
l_int|0
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem0
OL
l_int|0
)paren
(brace
op_decrement
id|zSig
suffix:semicolon
id|add128
c_func
(paren
id|rem0
comma
id|rem1
comma
l_int|0
comma
id|bSig
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
)brace
id|zSig
op_or_assign
(paren
id|rem1
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|roundAndPackFloat64
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the remainder of the double-precision floating-point value `a&squot;&n;with respect to the corresponding value `b&squot;.  The operation is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_rem
id|float64
id|float64_rem
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int16
id|aExp
comma
id|bExp
comma
id|expDiff
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
suffix:semicolon
id|bits64
id|q
comma
id|alternateASig
suffix:semicolon
id|sbits64
id|sigMean
suffix:semicolon
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
op_logical_and
id|bSig
)paren
)paren
(brace
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|bSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
id|normalizeFloat64Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|normalizeFloat64Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|aSig
op_assign
(paren
id|aSig
op_or
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
)paren
op_lshift
l_int|11
suffix:semicolon
id|bSig
op_assign
(paren
id|bSig
op_or
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
)paren
op_lshift
l_int|11
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|expDiff
OL
op_minus
l_int|1
)paren
r_return
id|a
suffix:semicolon
id|aSig
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|q
op_assign
(paren
id|bSig
op_le
id|aSig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
id|aSig
op_sub_assign
id|bSig
suffix:semicolon
id|expDiff
op_sub_assign
l_int|64
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|expDiff
)paren
(brace
id|q
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig
comma
l_int|0
comma
id|bSig
)paren
suffix:semicolon
id|q
op_assign
(paren
l_int|2
OL
id|q
)paren
ques
c_cond
id|q
op_minus
l_int|2
suffix:colon
l_int|0
suffix:semicolon
id|aSig
op_assign
op_minus
(paren
(paren
id|bSig
op_rshift
l_int|2
)paren
op_star
id|q
)paren
suffix:semicolon
id|expDiff
op_sub_assign
l_int|62
suffix:semicolon
)brace
id|expDiff
op_add_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
(brace
id|q
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig
comma
l_int|0
comma
id|bSig
)paren
suffix:semicolon
id|q
op_assign
(paren
l_int|2
OL
id|q
)paren
ques
c_cond
id|q
op_minus
l_int|2
suffix:colon
l_int|0
suffix:semicolon
id|q
op_rshift_assign
l_int|64
op_minus
id|expDiff
suffix:semicolon
id|bSig
op_rshift_assign
l_int|2
suffix:semicolon
id|aSig
op_assign
(paren
(paren
id|aSig
op_rshift
l_int|1
)paren
op_lshift
(paren
id|expDiff
op_minus
l_int|1
)paren
)paren
op_minus
id|bSig
op_star
id|q
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_rshift_assign
l_int|2
suffix:semicolon
id|bSig
op_rshift_assign
l_int|2
suffix:semicolon
)brace
r_do
(brace
id|alternateASig
op_assign
id|aSig
suffix:semicolon
op_increment
id|q
suffix:semicolon
id|aSig
op_sub_assign
id|bSig
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
op_le
(paren
id|sbits64
)paren
id|aSig
)paren
suffix:semicolon
id|sigMean
op_assign
id|aSig
op_plus
id|alternateASig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sigMean
OL
l_int|0
)paren
op_logical_or
(paren
(paren
id|sigMean
op_eq
l_int|0
)paren
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|aSig
op_assign
id|alternateASig
suffix:semicolon
)brace
id|zSign
op_assign
(paren
(paren
id|sbits64
)paren
id|aSig
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
id|aSig
op_assign
op_minus
id|aSig
suffix:semicolon
r_return
id|normalizeRoundAndPackFloat64
c_func
(paren
id|aSign
op_xor
id|zSign
comma
id|bExp
comma
id|aSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the square root of the double-precision floating-point value `a&squot;.&n;The operation is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_sqrt
id|float64
id|float64_sqrt
c_func
(paren
id|float64
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|zSig
suffix:semicolon
id|bits64
id|rem0
comma
id|rem1
comma
id|term0
comma
id|term1
suffix:semicolon
singleline_comment|//, shiftedRem;
singleline_comment|//float64 z;
id|aSig
op_assign
id|extractFloat64Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat64Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FF
)paren
(brace
r_if
c_cond
(paren
id|aSig
)paren
r_return
id|propagateFloat64NaN
c_func
(paren
id|a
comma
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aSign
)paren
r_return
id|a
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aSign
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
id|float64_default_nan
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|normalizeFloat64Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
(paren
(paren
id|aExp
op_minus
l_int|0x3FF
)paren
op_rshift
l_int|1
)paren
op_plus
l_int|0x3FE
suffix:semicolon
id|aSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0010000000000000
)paren
suffix:semicolon
id|zSig
op_assign
id|estimateSqrt32
c_func
(paren
id|aExp
comma
id|aSig
op_rshift
l_int|21
)paren
suffix:semicolon
id|zSig
op_lshift_assign
l_int|31
suffix:semicolon
id|aSig
op_lshift_assign
l_int|9
op_minus
(paren
id|aExp
op_amp
l_int|1
)paren
suffix:semicolon
id|zSig
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig
comma
l_int|0
comma
id|zSig
)paren
op_plus
id|zSig
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zSig
op_amp
l_int|0x3FF
)paren
op_le
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|zSig
OL
l_int|2
)paren
(brace
id|zSig
op_assign
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
suffix:semicolon
)brace
r_else
(brace
id|aSig
op_lshift_assign
l_int|2
suffix:semicolon
id|mul64To128
c_func
(paren
id|zSig
comma
id|zSig
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig
comma
l_int|0
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem0
OL
l_int|0
)paren
(brace
op_decrement
id|zSig
suffix:semicolon
id|shortShift128Left
c_func
(paren
l_int|0
comma
id|zSig
comma
l_int|1
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|term1
op_or_assign
l_int|1
suffix:semicolon
id|add128
c_func
(paren
id|rem0
comma
id|rem1
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
)brace
id|zSig
op_or_assign
(paren
(paren
id|rem0
op_or
id|rem1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|shift64RightJamming
c_func
(paren
id|zSig
comma
l_int|1
comma
op_amp
id|zSig
)paren
suffix:semicolon
r_return
id|roundAndPackFloat64
c_func
(paren
l_int|0
comma
id|zExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the double-precision floating-point value `a&squot; is equal to the&n;corresponding value `b&squot;, and 0 otherwise.  The comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_eq
id|flag
id|float64_eq
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float64_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float64_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the double-precision floating-point value `a&squot; is less than or&n;equal to the corresponding value `b&squot;, and 0 otherwise.  The comparison is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_le
id|flag
id|float64_le
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_or
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the double-precision floating-point value `a&squot; is less than&n;the corresponding value `b&squot;, and 0 otherwise.  The comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_lt
id|flag
id|float64_lt
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_and
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_ne
id|b
)paren
op_logical_and
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the double-precision floating-point value `a&squot; is equal to the&n;corresponding value `b&squot;, and 0 otherwise.  The invalid exception is raised&n;if either operand is a NaN.  Otherwise, the comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_eq_signaling
id|flag
id|float64_eq_signaling
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the double-precision floating-point value `a&squot; is less than or&n;equal to the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs do not&n;cause an exception.  Otherwise, the comparison is performed according to the&n;IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_le_quiet
id|flag
id|float64_le_quiet
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
singleline_comment|//int16 aExp, bExp;
r_if
c_cond
(paren
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float64_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float64_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_or
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_or
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the double-precision floating-point value `a&squot; is less than&n;the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs do not cause an&n;exception.  Otherwise, the comparison is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float64_lt_quiet
id|flag
id|float64_lt_quiet
c_func
(paren
id|float64
id|a
comma
id|float64
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|a
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat64Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FF
)paren
op_logical_and
id|extractFloat64Frac
c_func
(paren
id|b
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float64_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float64_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat64Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
r_return
id|aSign
op_logical_and
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a
op_or
id|b
)paren
op_lshift
l_int|1
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|a
op_ne
id|b
)paren
op_logical_and
(paren
id|aSign
op_xor
(paren
id|a
OL
id|b
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOATX80
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the extended double-precision floating-&n;point value `a&squot; to the 32-bit two&squot;s complement integer format.  The&n;conversion is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic---which means in particular that the conversion&n;is rounded according to the current rounding mode.  If `a&squot; is a NaN, the&n;largest positive integer is returned.  Otherwise, if the conversion&n;overflows, the largest integer with the same sign as `a&squot; is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_to_int32
id|int32
id|floatx80_to_int32
c_func
(paren
id|floatx80
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
id|shiftCount
op_assign
l_int|0x4037
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
id|shiftCount
op_le
l_int|0
)paren
id|shiftCount
op_assign
l_int|1
suffix:semicolon
id|shift64RightJamming
c_func
(paren
id|aSig
comma
id|shiftCount
comma
op_amp
id|aSig
)paren
suffix:semicolon
r_return
id|roundAndPackInt32
c_func
(paren
id|aSign
comma
id|aSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the extended double-precision floating-&n;point value `a&squot; to the 32-bit two&squot;s complement integer format.  The&n;conversion is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic, except that the conversion is always rounded&n;toward zero.  If `a&squot; is a NaN, the largest positive integer is returned.&n;Otherwise, if the conversion overflows, the largest integer with the same&n;sign as `a&squot; is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_to_int32_round_to_zero
id|int32
id|floatx80_to_int32_round_to_zero
c_func
(paren
id|floatx80
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig
comma
id|savedASig
suffix:semicolon
id|int32
id|z
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|shiftCount
op_assign
l_int|0x403E
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
id|shiftCount
OL
l_int|32
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|63
OL
id|shiftCount
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_logical_or
id|aSig
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|savedASig
op_assign
id|aSig
suffix:semicolon
id|aSig
op_rshift_assign
id|shiftCount
suffix:semicolon
id|z
op_assign
id|aSig
suffix:semicolon
r_if
c_cond
(paren
id|aSign
)paren
id|z
op_assign
op_minus
id|z
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
OL
l_int|0
)paren
op_xor
id|aSign
)paren
(brace
id|invalid
suffix:colon
id|float_exception_flags
op_or_assign
id|float_flag_invalid
suffix:semicolon
r_return
id|aSign
ques
c_cond
l_int|0x80000000
suffix:colon
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|aSig
op_lshift
id|shiftCount
)paren
op_ne
id|savedASig
)paren
(brace
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
)brace
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the extended double-precision floating-&n;point value `a&squot; to the single-precision floating-point format.  The&n;conversion is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_to_float32
id|float32
id|floatx80_to_float32
c_func
(paren
id|floatx80
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
suffix:semicolon
id|bits64
id|aSig
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
(brace
r_return
id|commonNaNToFloat32
c_func
(paren
id|floatx80ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_return
id|packFloat32
c_func
(paren
id|aSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
id|shift64RightJamming
c_func
(paren
id|aSig
comma
l_int|33
comma
op_amp
id|aSig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_logical_or
id|aSig
)paren
id|aExp
op_sub_assign
l_int|0x3F81
suffix:semicolon
r_return
id|roundAndPackFloat32
c_func
(paren
id|aSign
comma
id|aExp
comma
id|aSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the extended double-precision floating-&n;point value `a&squot; to the double-precision floating-point format.  The&n;conversion is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_to_float64
id|float64
id|floatx80_to_float64
c_func
(paren
id|floatx80
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
suffix:semicolon
id|bits64
id|aSig
comma
id|zSig
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
(brace
r_return
id|commonNaNToFloat64
c_func
(paren
id|floatx80ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
id|shift64RightJamming
c_func
(paren
id|aSig
comma
l_int|1
comma
op_amp
id|zSig
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_logical_or
id|aSig
)paren
id|aExp
op_sub_assign
l_int|0x3C01
suffix:semicolon
r_return
id|roundAndPackFloat64
c_func
(paren
id|aSign
comma
id|aExp
comma
id|zSig
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOAT128
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the extended double-precision floating-&n;point value `a&squot; to the quadruple-precision floating-point format.  The&n;conversion is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_to_float128
id|float128
id|floatx80_to_float128
c_func
(paren
id|floatx80
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int16
id|aExp
suffix:semicolon
id|bits64
id|aSig
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
(brace
r_return
id|commonNaNToFloat128
c_func
(paren
id|floatx80ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
)brace
id|shift128Right
c_func
(paren
id|aSig
op_lshift
l_int|1
comma
l_int|0
comma
l_int|16
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
id|aExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Rounds the extended double-precision floating-point value `a&squot; to an integer,&n;and returns the result as an extended quadruple-precision floating-point&n;value.  The operation is performed according to the IEC/IEEE Standard for&n;Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_round_to_int
id|floatx80
id|floatx80_round_to_int
c_func
(paren
id|floatx80
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
suffix:semicolon
id|bits64
id|lastBitMask
comma
id|roundBitsMask
suffix:semicolon
id|int8
id|roundingMode
suffix:semicolon
id|floatx80
id|z
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0x403E
op_le
id|aExp
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
(brace
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|a
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_le
l_int|0x3FFE
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_return
id|a
suffix:semicolon
)brace
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|float_rounding_mode
)paren
(brace
r_case
id|float_round_nearest_even
suffix:colon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x3FFE
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
(brace
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0x3FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|float_round_down
suffix:colon
r_return
id|aSign
ques
c_cond
id|packFloatx80
c_func
(paren
l_int|1
comma
l_int|0x3FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:colon
id|packFloatx80
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_case
id|float_round_up
suffix:colon
r_return
id|aSign
ques
c_cond
id|packFloatx80
c_func
(paren
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:colon
id|packFloatx80
c_func
(paren
l_int|0
comma
l_int|0x3FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|lastBitMask
op_assign
l_int|1
suffix:semicolon
id|lastBitMask
op_lshift_assign
l_int|0x403E
op_minus
id|aExp
suffix:semicolon
id|roundBitsMask
op_assign
id|lastBitMask
op_minus
l_int|1
suffix:semicolon
id|z
op_assign
id|a
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
(brace
id|z.low
op_add_assign
id|lastBitMask
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z.low
op_amp
id|roundBitsMask
)paren
op_eq
l_int|0
)paren
id|z.low
op_and_assign
op_complement
id|lastBitMask
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|roundingMode
op_ne
id|float_round_to_zero
)paren
(brace
r_if
c_cond
(paren
id|extractFloatx80Sign
c_func
(paren
id|z
)paren
op_xor
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
)paren
(brace
id|z.low
op_add_assign
id|roundBitsMask
suffix:semicolon
)brace
)brace
id|z.low
op_and_assign
op_complement
id|roundBitsMask
suffix:semicolon
r_if
c_cond
(paren
id|z.low
op_eq
l_int|0
)paren
(brace
op_increment
id|z.high
suffix:semicolon
id|z.low
op_assign
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|z.low
op_ne
id|a.low
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the absolute values of the extended double-&n;precision floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true, the sum is&n;negated before being returned.  `zSign&squot; is ignored if the result is a NaN.&n;The addition is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|addFloatx80Sigs
r_static
id|floatx80
id|addFloatx80Sigs
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|int32
id|expDiff
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
op_decrement
id|expDiff
suffix:semicolon
id|shift64ExtraRightJamming
c_func
(paren
id|bSig
comma
l_int|0
comma
id|expDiff
comma
op_amp
id|bSig
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
op_increment
id|expDiff
suffix:semicolon
id|shift64ExtraRightJamming
c_func
(paren
id|aSig
comma
l_int|0
comma
op_minus
id|expDiff
comma
op_amp
id|aSig
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
(paren
id|aSig
op_or
id|bSig
)paren
op_lshift
l_int|1
)paren
)paren
(brace
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
id|zSig1
op_assign
l_int|0
suffix:semicolon
id|zSig0
op_assign
id|aSig
op_plus
id|bSig
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
id|normalizeFloatx80Subnormal
c_func
(paren
id|zSig0
comma
op_amp
id|zExp
comma
op_amp
id|zSig0
)paren
suffix:semicolon
r_goto
id|roundAndPack
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
suffix:semicolon
r_goto
id|shiftRight1
suffix:semicolon
)brace
id|zSig0
op_assign
id|aSig
op_plus
id|bSig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sbits64
)paren
id|zSig0
OL
l_int|0
)paren
r_goto
id|roundAndPack
suffix:semicolon
id|shiftRight1
suffix:colon
id|shift64ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
l_int|1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
id|roundAndPack
suffix:colon
r_return
id|roundAndPackFloatx80
c_func
(paren
id|floatx80_rounding_precision
comma
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the absolute values of the extended&n;double-precision floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true,&n;the difference is negated before being returned.  `zSign&squot; is ignored if the&n;result is a NaN.  The subtraction is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|subFloatx80Sigs
r_static
id|floatx80
id|subFloatx80Sigs
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|int32
id|expDiff
suffix:semicolon
id|floatx80
id|z
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
r_goto
id|aExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
r_goto
id|bExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
(paren
id|aSig
op_or
id|bSig
)paren
op_lshift
l_int|1
)paren
)paren
(brace
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|floatx80_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|floatx80_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
id|aExp
op_assign
l_int|1
suffix:semicolon
id|bExp
op_assign
l_int|1
suffix:semicolon
)brace
id|zSig1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bSig
OL
id|aSig
)paren
r_goto
id|aBigger
suffix:semicolon
r_if
c_cond
(paren
id|aSig
OL
id|bSig
)paren
r_goto
id|bBigger
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|float_rounding_mode
op_eq
id|float_round_down
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|bExpBigger
suffix:colon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
op_xor
l_int|1
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
op_increment
id|expDiff
suffix:semicolon
id|shift128RightJamming
c_func
(paren
id|aSig
comma
l_int|0
comma
op_minus
id|expDiff
comma
op_amp
id|aSig
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|bBigger
suffix:colon
id|sub128
c_func
(paren
id|bSig
comma
l_int|0
comma
id|aSig
comma
id|zSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
id|zSign
op_xor_assign
l_int|1
suffix:semicolon
r_goto
id|normalizeRoundAndPack
suffix:semicolon
id|aExpBigger
suffix:colon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
op_decrement
id|expDiff
suffix:semicolon
id|shift128RightJamming
c_func
(paren
id|bSig
comma
l_int|0
comma
id|expDiff
comma
op_amp
id|bSig
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|aBigger
suffix:colon
id|sub128
c_func
(paren
id|aSig
comma
l_int|0
comma
id|bSig
comma
id|zSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
id|normalizeRoundAndPack
suffix:colon
r_return
id|normalizeRoundAndPackFloatx80
c_func
(paren
id|floatx80_rounding_precision
comma
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the extended double-precision floating-point&n;values `a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_add
id|floatx80
id|floatx80_add
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|addFloatx80Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|subFloatx80Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the extended double-precision floating-&n;point values `a&squot; and `b&squot;.  The operation is performed according to the&n;IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_sub
id|floatx80
id|floatx80_sub
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|subFloatx80Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|addFloatx80Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of multiplying the extended double-precision floating-&n;point values `a&squot; and `b&squot;.  The operation is performed according to the&n;IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_mul
id|floatx80
id|floatx80_mul
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|floatx80
id|z
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
)paren
(brace
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bExp
op_or
id|bSig
)paren
op_eq
l_int|0
)paren
r_goto
id|invalid
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
(brace
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|floatx80_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|floatx80_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloatx80Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloatx80Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_plus
id|bExp
op_minus
l_int|0x3FFE
suffix:semicolon
id|mul64To128
c_func
(paren
id|aSig
comma
id|bSig
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
(paren
id|sbits64
)paren
id|zSig0
)paren
(brace
id|shortShift128Left
c_func
(paren
id|zSig0
comma
id|zSig1
comma
l_int|1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
op_decrement
id|zExp
suffix:semicolon
)brace
r_return
id|roundAndPackFloatx80
c_func
(paren
id|floatx80_rounding_precision
comma
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of dividing the extended double-precision floating-point&n;value `a&squot; by the corresponding value `b&squot;.  The operation is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_div
id|floatx80
id|floatx80_div
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig
comma
id|bSig
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|bits64
id|rem0
comma
id|rem1
comma
id|rem2
comma
id|term0
comma
id|term1
comma
id|term2
suffix:semicolon
id|floatx80
id|z
suffix:semicolon
id|aSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig
)paren
op_eq
l_int|0
)paren
(brace
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|floatx80_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|floatx80_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_divbyzero
)paren
suffix:semicolon
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
id|normalizeFloatx80Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloatx80Subnormal
c_func
(paren
id|aSig
comma
op_amp
id|aExp
comma
op_amp
id|aSig
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_minus
id|bExp
op_plus
l_int|0x3FFE
suffix:semicolon
id|rem1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bSig
op_le
id|aSig
)paren
(brace
id|shift128Right
c_func
(paren
id|aSig
comma
l_int|0
comma
l_int|1
comma
op_amp
id|aSig
comma
op_amp
id|rem1
)paren
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
)brace
id|zSig0
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig
comma
id|rem1
comma
id|bSig
)paren
suffix:semicolon
id|mul64To128
c_func
(paren
id|bSig
comma
id|zSig0
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig
comma
id|rem1
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem0
OL
l_int|0
)paren
(brace
op_decrement
id|zSig0
suffix:semicolon
id|add128
c_func
(paren
id|rem0
comma
id|rem1
comma
l_int|0
comma
id|bSig
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
)brace
id|zSig1
op_assign
id|estimateDiv128To64
c_func
(paren
id|rem1
comma
l_int|0
comma
id|bSig
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|zSig1
op_lshift
l_int|1
)paren
op_le
l_int|8
)paren
(brace
id|mul64To128
c_func
(paren
id|bSig
comma
id|zSig1
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|rem1
comma
l_int|0
comma
id|term1
comma
id|term2
comma
op_amp
id|rem1
comma
op_amp
id|rem2
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem1
OL
l_int|0
)paren
(brace
op_decrement
id|zSig1
suffix:semicolon
id|add128
c_func
(paren
id|rem1
comma
id|rem2
comma
l_int|0
comma
id|bSig
comma
op_amp
id|rem1
comma
op_amp
id|rem2
)paren
suffix:semicolon
)brace
id|zSig1
op_or_assign
(paren
(paren
id|rem1
op_or
id|rem2
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|roundAndPackFloatx80
c_func
(paren
id|floatx80_rounding_precision
comma
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the remainder of the extended double-precision floating-point value&n;`a&squot; with respect to the corresponding value `b&squot;.  The operation is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_rem
id|floatx80
id|floatx80_rem
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int32
id|aExp
comma
id|bExp
comma
id|expDiff
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|bSig
suffix:semicolon
id|bits64
id|q
comma
id|term0
comma
id|term1
comma
id|alternateASig0
comma
id|alternateASig1
suffix:semicolon
id|floatx80
id|z
suffix:semicolon
id|aSig0
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig
op_assign
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig0
op_lshift
l_int|1
)paren
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
)paren
(brace
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_goto
id|invalid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|bSig
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bSig
op_eq
l_int|0
)paren
(brace
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|floatx80_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|floatx80_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
id|normalizeFloatx80Subnormal
c_func
(paren
id|bSig
comma
op_amp
id|bExp
comma
op_amp
id|bSig
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig0
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|normalizeFloatx80Subnormal
c_func
(paren
id|aSig0
comma
op_amp
id|aExp
comma
op_amp
id|aSig0
)paren
suffix:semicolon
)brace
id|bSig
op_or_assign
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|aSig1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|expDiff
OL
op_minus
l_int|1
)paren
r_return
id|a
suffix:semicolon
id|shift128Right
c_func
(paren
id|aSig0
comma
l_int|0
comma
l_int|1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|expDiff
op_assign
l_int|0
suffix:semicolon
)brace
id|q
op_assign
(paren
id|bSig
op_le
id|aSig0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
id|aSig0
op_sub_assign
id|bSig
suffix:semicolon
id|expDiff
op_sub_assign
l_int|64
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|expDiff
)paren
(brace
id|q
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig
)paren
suffix:semicolon
id|q
op_assign
(paren
l_int|2
OL
id|q
)paren
ques
c_cond
id|q
op_minus
l_int|2
suffix:colon
l_int|0
suffix:semicolon
id|mul64To128
c_func
(paren
id|bSig
comma
id|q
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|term0
comma
id|term1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|62
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|expDiff
op_sub_assign
l_int|62
suffix:semicolon
)brace
id|expDiff
op_add_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
(brace
id|q
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig
)paren
suffix:semicolon
id|q
op_assign
(paren
l_int|2
OL
id|q
)paren
ques
c_cond
id|q
op_minus
l_int|2
suffix:colon
l_int|0
suffix:semicolon
id|q
op_rshift_assign
l_int|64
op_minus
id|expDiff
suffix:semicolon
id|mul64To128
c_func
(paren
id|bSig
comma
id|q
op_lshift
(paren
l_int|64
op_minus
id|expDiff
)paren
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|term0
comma
id|term1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
l_int|0
comma
id|bSig
comma
l_int|64
op_minus
id|expDiff
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|le128
c_func
(paren
id|term0
comma
id|term1
comma
id|aSig0
comma
id|aSig1
)paren
)paren
(brace
op_increment
id|q
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|term0
comma
id|term1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|term1
op_assign
l_int|0
suffix:semicolon
id|term0
op_assign
id|bSig
suffix:semicolon
)brace
id|sub128
c_func
(paren
id|term0
comma
id|term1
comma
id|aSig0
comma
id|aSig1
comma
op_amp
id|alternateASig0
comma
op_amp
id|alternateASig1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lt128
c_func
(paren
id|alternateASig0
comma
id|alternateASig1
comma
id|aSig0
comma
id|aSig1
)paren
op_logical_or
(paren
id|eq128
c_func
(paren
id|alternateASig0
comma
id|alternateASig1
comma
id|aSig0
comma
id|aSig1
)paren
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|aSig0
op_assign
id|alternateASig0
suffix:semicolon
id|aSig1
op_assign
id|alternateASig1
suffix:semicolon
id|zSign
op_assign
op_logical_neg
id|zSign
suffix:semicolon
)brace
r_return
id|normalizeRoundAndPackFloatx80
c_func
(paren
l_int|80
comma
id|zSign
comma
id|bExp
op_plus
id|expDiff
comma
id|aSig0
comma
id|aSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the square root of the extended double-precision floating-point&n;value `a&squot;.  The operation is performed according to the IEC/IEEE Standard&n;for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_sqrt
id|floatx80
id|floatx80_sqrt
c_func
(paren
id|floatx80
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|bits64
id|rem0
comma
id|rem1
comma
id|rem2
comma
id|rem3
comma
id|term0
comma
id|term1
comma
id|term2
comma
id|term3
suffix:semicolon
id|bits64
id|shiftedRem0
comma
id|shiftedRem1
suffix:semicolon
id|floatx80
id|z
suffix:semicolon
id|aSig0
op_assign
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|aSig0
op_lshift
l_int|1
)paren
)paren
r_return
id|propagateFloatx80NaN
c_func
(paren
id|a
comma
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aSign
)paren
r_return
id|a
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aSign
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig0
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|floatx80_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|floatx80_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloatx80Subnormal
c_func
(paren
id|aSig0
comma
op_amp
id|aExp
comma
op_amp
id|aSig0
)paren
suffix:semicolon
)brace
id|zExp
op_assign
(paren
(paren
id|aExp
op_minus
l_int|0x3FFF
)paren
op_rshift
l_int|1
)paren
op_plus
l_int|0x3FFF
suffix:semicolon
id|zSig0
op_assign
id|estimateSqrt32
c_func
(paren
id|aExp
comma
id|aSig0
op_rshift
l_int|32
)paren
suffix:semicolon
id|zSig0
op_lshift_assign
l_int|31
suffix:semicolon
id|aSig1
op_assign
l_int|0
suffix:semicolon
id|shift128Right
c_func
(paren
id|aSig0
comma
l_int|0
comma
(paren
id|aExp
op_amp
l_int|1
)paren
op_plus
l_int|2
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|zSig0
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|zSig0
)paren
op_plus
id|zSig0
op_plus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
(paren
id|sbits64
)paren
id|zSig0
)paren
id|zSig0
op_assign
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|2
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|mul64To128
c_func
(paren
id|zSig0
comma
id|zSig0
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem0
OL
l_int|0
)paren
(brace
op_decrement
id|zSig0
suffix:semicolon
id|shortShift128Left
c_func
(paren
l_int|0
comma
id|zSig0
comma
l_int|1
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|term1
op_or_assign
l_int|1
suffix:semicolon
id|add128
c_func
(paren
id|rem0
comma
id|rem1
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
)brace
id|shortShift128Left
c_func
(paren
id|rem0
comma
id|rem1
comma
l_int|63
comma
op_amp
id|shiftedRem0
comma
op_amp
id|shiftedRem1
)paren
suffix:semicolon
id|zSig1
op_assign
id|estimateDiv128To64
c_func
(paren
id|shiftedRem0
comma
id|shiftedRem1
comma
id|zSig0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|zSig1
op_lshift
l_int|1
)paren
op_le
l_int|10
)paren
(brace
r_if
c_cond
(paren
id|zSig1
op_eq
l_int|0
)paren
id|zSig1
op_assign
l_int|1
suffix:semicolon
id|mul64To128
c_func
(paren
id|zSig0
comma
id|zSig1
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|term1
comma
id|term2
comma
l_int|1
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|rem1
comma
l_int|0
comma
id|term1
comma
id|term2
comma
op_amp
id|rem1
comma
op_amp
id|rem2
)paren
suffix:semicolon
id|mul64To128
c_func
(paren
id|zSig1
comma
id|zSig1
comma
op_amp
id|term2
comma
op_amp
id|term3
)paren
suffix:semicolon
id|sub192
c_func
(paren
id|rem1
comma
id|rem2
comma
l_int|0
comma
l_int|0
comma
id|term2
comma
id|term3
comma
op_amp
id|rem1
comma
op_amp
id|rem2
comma
op_amp
id|rem3
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem1
OL
l_int|0
)paren
(brace
op_decrement
id|zSig1
suffix:semicolon
id|shortShift192Left
c_func
(paren
l_int|0
comma
id|zSig0
comma
id|zSig1
comma
l_int|1
comma
op_amp
id|term1
comma
op_amp
id|term2
comma
op_amp
id|term3
)paren
suffix:semicolon
id|term3
op_or_assign
l_int|1
suffix:semicolon
id|add192
c_func
(paren
id|rem1
comma
id|rem2
comma
id|rem3
comma
id|term1
comma
id|term2
comma
id|term3
comma
op_amp
id|rem1
comma
op_amp
id|rem2
comma
op_amp
id|rem3
)paren
suffix:semicolon
)brace
id|zSig1
op_or_assign
(paren
(paren
id|rem1
op_or
id|rem2
op_or
id|rem3
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|roundAndPackFloatx80
c_func
(paren
id|floatx80_rounding_precision
comma
l_int|0
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the extended double-precision floating-point value `a&squot; is&n;equal to the corresponding value `b&squot;, and 0 otherwise.  The comparison is&n;performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_eq
id|flag
id|floatx80_eq
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
op_lshift
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|floatx80_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|floatx80_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a.low
op_eq
id|b.low
)paren
op_logical_and
(paren
(paren
id|a.high
op_eq
id|b.high
)paren
op_logical_or
(paren
(paren
id|a.low
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|bits16
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the extended double-precision floating-point value `a&squot; is&n;less than or equal to the corresponding value `b&squot;, and 0 otherwise.  The&n;comparison is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_le
id|flag
id|floatx80_le
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
op_lshift
l_int|1
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_or
(paren
(paren
(paren
(paren
id|bits16
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|le128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|le128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the extended double-precision floating-point value `a&squot; is&n;less than the corresponding value `b&squot;, and 0 otherwise.  The comparison&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_lt
id|flag
id|floatx80_lt
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
op_lshift
l_int|1
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_and
(paren
(paren
(paren
(paren
id|bits16
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|lt128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|lt128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the extended double-precision floating-point value `a&squot; is equal&n;to the corresponding value `b&squot;, and 0 otherwise.  The invalid exception is&n;raised if either operand is a NaN.  Otherwise, the comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_eq_signaling
id|flag
id|floatx80_eq_signaling
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
op_lshift
l_int|1
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a.low
op_eq
id|b.low
)paren
op_logical_and
(paren
(paren
id|a.high
op_eq
id|b.high
)paren
op_logical_or
(paren
(paren
id|a.low
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|bits16
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the extended double-precision floating-point value `a&squot; is less&n;than or equal to the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs&n;do not cause an exception.  Otherwise, the comparison is performed according&n;to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_le_quiet
id|flag
id|floatx80_le_quiet
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
op_lshift
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|floatx80_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|floatx80_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_or
(paren
(paren
(paren
(paren
id|bits16
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|le128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|le128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the extended double-precision floating-point value `a&squot; is less&n;than the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs do not cause&n;an exception.  Otherwise, the comparison is performed according to the&n;IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|floatx80_lt_quiet
id|flag
id|floatx80_lt_quiet
c_func
(paren
id|floatx80
id|a
comma
id|floatx80
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|a
)paren
op_lshift
l_int|1
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloatx80Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bits64
)paren
(paren
id|extractFloatx80Frac
c_func
(paren
id|b
)paren
op_lshift
l_int|1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|floatx80_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|floatx80_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloatx80Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_and
(paren
(paren
(paren
(paren
id|bits16
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|lt128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|lt128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef FLOAT128
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the quadruple-precision floating-point&n;value `a&squot; to the 32-bit two&squot;s complement integer format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic---which means in particular that the conversion is rounded&n;according to the current rounding mode.  If `a&squot; is a NaN, the largest&n;positive integer is returned.  Otherwise, if the conversion overflows, the&n;largest integer with the same sign as `a&squot; is returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_to_int32
id|int32
id|float128_to_int32
c_func
(paren
id|float128
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|aSig0
op_or
id|aSig1
)paren
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aExp
)paren
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
id|aSig0
op_or_assign
(paren
id|aSig1
op_ne
l_int|0
)paren
suffix:semicolon
id|shiftCount
op_assign
l_int|0x4028
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|shiftCount
)paren
id|shift64RightJamming
c_func
(paren
id|aSig0
comma
id|shiftCount
comma
op_amp
id|aSig0
)paren
suffix:semicolon
r_return
id|roundAndPackInt32
c_func
(paren
id|aSign
comma
id|aSig0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the quadruple-precision floating-point&n;value `a&squot; to the 32-bit two&squot;s complement integer format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic, except that the conversion is always rounded toward zero.  If&n;`a&squot; is a NaN, the largest positive integer is returned.  Otherwise, if the&n;conversion overflows, the largest integer with the same sign as `a&squot; is&n;returned.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_to_int32_round_to_zero
id|int32
id|float128_to_int32_round_to_zero
c_func
(paren
id|float128
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
comma
id|shiftCount
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|savedASig
suffix:semicolon
id|int32
id|z
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_or_assign
(paren
id|aSig1
op_ne
l_int|0
)paren
suffix:semicolon
id|shiftCount
op_assign
l_int|0x402F
op_minus
id|aExp
suffix:semicolon
r_if
c_cond
(paren
id|shiftCount
OL
l_int|17
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
id|aSig0
)paren
id|aSign
op_assign
l_int|0
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|48
OL
id|shiftCount
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_logical_or
id|aSig0
)paren
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
id|savedASig
op_assign
id|aSig0
suffix:semicolon
id|aSig0
op_rshift_assign
id|shiftCount
suffix:semicolon
id|z
op_assign
id|aSig0
suffix:semicolon
r_if
c_cond
(paren
id|aSign
)paren
id|z
op_assign
op_minus
id|z
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
OL
l_int|0
)paren
op_xor
id|aSign
)paren
(brace
id|invalid
suffix:colon
id|float_exception_flags
op_or_assign
id|float_flag_invalid
suffix:semicolon
r_return
id|aSign
ques
c_cond
l_int|0x80000000
suffix:colon
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|aSig0
op_lshift
id|shiftCount
)paren
op_ne
id|savedASig
)paren
(brace
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
)brace
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the quadruple-precision floating-point&n;value `a&squot; to the single-precision floating-point format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_to_float32
id|float32
id|float128_to_float32
c_func
(paren
id|float128
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
suffix:semicolon
id|bits32
id|zSig
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
)paren
(brace
r_return
id|commonNaNToFloat32
c_func
(paren
id|float128ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_return
id|packFloat32
c_func
(paren
id|aSign
comma
l_int|0xFF
comma
l_int|0
)paren
suffix:semicolon
)brace
id|aSig0
op_or_assign
(paren
id|aSig1
op_ne
l_int|0
)paren
suffix:semicolon
id|shift64RightJamming
c_func
(paren
id|aSig0
comma
l_int|18
comma
op_amp
id|aSig0
)paren
suffix:semicolon
id|zSig
op_assign
id|aSig0
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_logical_or
id|zSig
)paren
(brace
id|zSig
op_or_assign
l_int|0x40000000
suffix:semicolon
id|aExp
op_sub_assign
l_int|0x3F81
suffix:semicolon
)brace
r_return
id|roundAndPackFloat32
c_func
(paren
id|aSign
comma
id|aExp
comma
id|zSig
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the quadruple-precision floating-point&n;value `a&squot; to the double-precision floating-point format.  The conversion&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_to_float64
id|float64
id|float128_to_float64
c_func
(paren
id|float128
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
)paren
(brace
r_return
id|commonNaNToFloat64
c_func
(paren
id|float128ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_return
id|packFloat64
c_func
(paren
id|aSign
comma
l_int|0x7FF
comma
l_int|0
)paren
suffix:semicolon
)brace
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|14
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|aSig0
op_or_assign
(paren
id|aSig1
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_logical_or
id|aSig0
)paren
(brace
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
id|aExp
op_sub_assign
l_int|0x3C01
suffix:semicolon
)brace
r_return
id|roundAndPackFloat64
c_func
(paren
id|aSign
comma
id|aExp
comma
id|aSig0
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOATX80
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of converting the quadruple-precision floating-point&n;value `a&squot; to the extended double-precision floating-point format.  The&n;conversion is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_to_floatx80
id|floatx80
id|float128_to_floatx80
c_func
(paren
id|float128
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
)paren
(brace
r_return
id|commonNaNToFloatx80
c_func
(paren
id|float128ToCommonNaN
c_func
(paren
id|a
)paren
)paren
suffix:semicolon
)brace
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0x7FFF
comma
id|LIT64
c_func
(paren
l_int|0x8000000000000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
r_return
id|packFloatx80
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat128Subnormal
c_func
(paren
id|aSig0
comma
id|aSig1
comma
op_amp
id|aExp
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
r_else
(brace
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
)brace
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|15
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
r_return
id|roundAndPackFloatx80
c_func
(paren
l_int|80
comma
id|aSign
comma
id|aExp
comma
id|aSig0
comma
id|aSig1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Rounds the quadruple-precision floating-point value `a&squot; to an integer, and&n;returns the result as a quadruple-precision floating-point value.  The&n;operation is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_round_to_int
id|float128
id|float128_round_to_int
c_func
(paren
id|float128
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
suffix:semicolon
id|bits64
id|lastBitMask
comma
id|roundBitsMask
suffix:semicolon
id|int8
id|roundingMode
suffix:semicolon
id|float128
id|z
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0x402F
op_le
id|aExp
)paren
(brace
r_if
c_cond
(paren
l_int|0x406F
op_le
id|aExp
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
(brace
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|a
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
id|lastBitMask
op_assign
l_int|1
suffix:semicolon
id|lastBitMask
op_assign
(paren
id|lastBitMask
op_lshift
(paren
l_int|0x406E
op_minus
id|aExp
)paren
)paren
op_lshift
l_int|1
suffix:semicolon
id|roundBitsMask
op_assign
id|lastBitMask
op_minus
l_int|1
suffix:semicolon
id|z
op_assign
id|a
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
(brace
r_if
c_cond
(paren
id|lastBitMask
)paren
(brace
id|add128
c_func
(paren
id|z.high
comma
id|z.low
comma
l_int|0
comma
id|lastBitMask
op_rshift
l_int|1
comma
op_amp
id|z.high
comma
op_amp
id|z.low
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z.low
op_amp
id|roundBitsMask
)paren
op_eq
l_int|0
)paren
id|z.low
op_and_assign
op_complement
id|lastBitMask
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|sbits64
)paren
id|z.low
OL
l_int|0
)paren
(brace
op_increment
id|z.high
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bits64
)paren
(paren
id|z.low
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
id|z.high
op_and_assign
op_complement
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|roundingMode
op_ne
id|float_round_to_zero
)paren
(brace
r_if
c_cond
(paren
id|extractFloat128Sign
c_func
(paren
id|z
)paren
op_xor
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
)paren
(brace
id|add128
c_func
(paren
id|z.high
comma
id|z.low
comma
l_int|0
comma
id|roundBitsMask
comma
op_amp
id|z.high
comma
op_amp
id|z.low
)paren
suffix:semicolon
)brace
)brace
id|z.low
op_and_assign
op_complement
id|roundBitsMask
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aExp
op_le
l_int|0x3FFE
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
(paren
id|bits64
)paren
(paren
id|a.high
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|float_rounding_mode
)paren
(brace
r_case
id|float_round_nearest_even
suffix:colon
r_if
c_cond
(paren
(paren
id|aExp
op_eq
l_int|0x3FFE
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
(brace
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
l_int|0x3FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|float_round_down
suffix:colon
r_return
id|aSign
ques
c_cond
id|packFloat128
c_func
(paren
l_int|1
comma
l_int|0x3FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:colon
id|packFloat128
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_case
id|float_round_up
suffix:colon
r_return
id|aSign
ques
c_cond
id|packFloat128
c_func
(paren
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:colon
id|packFloat128
c_func
(paren
l_int|0
comma
l_int|0x3FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|packFloat128
c_func
(paren
id|aSign
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|lastBitMask
op_assign
l_int|1
suffix:semicolon
id|lastBitMask
op_lshift_assign
l_int|0x402F
op_minus
id|aExp
suffix:semicolon
id|roundBitsMask
op_assign
id|lastBitMask
op_minus
l_int|1
suffix:semicolon
id|z.low
op_assign
l_int|0
suffix:semicolon
id|z.high
op_assign
id|a.high
suffix:semicolon
id|roundingMode
op_assign
id|float_rounding_mode
suffix:semicolon
r_if
c_cond
(paren
id|roundingMode
op_eq
id|float_round_nearest_even
)paren
(brace
id|z.high
op_add_assign
id|lastBitMask
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|z.high
op_amp
id|roundBitsMask
)paren
op_or
id|a.low
)paren
op_eq
l_int|0
)paren
(brace
id|z.high
op_and_assign
op_complement
id|lastBitMask
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|roundingMode
op_ne
id|float_round_to_zero
)paren
(brace
r_if
c_cond
(paren
id|extractFloat128Sign
c_func
(paren
id|z
)paren
op_xor
(paren
id|roundingMode
op_eq
id|float_round_up
)paren
)paren
(brace
id|z.high
op_or_assign
(paren
id|a.low
op_ne
l_int|0
)paren
suffix:semicolon
id|z.high
op_add_assign
id|roundBitsMask
suffix:semicolon
)brace
)brace
id|z.high
op_and_assign
op_complement
id|roundBitsMask
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|z.low
op_ne
id|a.low
)paren
op_logical_or
(paren
id|z.high
op_ne
id|a.high
)paren
)paren
(brace
id|float_exception_flags
op_or_assign
id|float_flag_inexact
suffix:semicolon
)brace
r_return
id|z
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the absolute values of the quadruple-precision&n;floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true, the sum is negated&n;before being returned.  `zSign&squot; is ignored if the result is a NaN.  The&n;addition is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|addFloat128Sigs
r_static
id|float128
id|addFloat128Sigs
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
suffix:semicolon
id|int32
id|expDiff
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
op_decrement
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|bSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
)brace
id|shift128ExtraRightJamming
c_func
(paren
id|bSig0
comma
id|bSig1
comma
l_int|0
comma
id|expDiff
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|bSig0
op_or
id|bSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
op_increment
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
)brace
id|shift128ExtraRightJamming
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|0
comma
op_minus
id|expDiff
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
op_or
id|bSig0
op_or
id|bSig1
)paren
(brace
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
id|add128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
id|zSig2
op_assign
l_int|0
suffix:semicolon
id|zSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0002000000000000
)paren
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
r_goto
id|shiftRight1
suffix:semicolon
)brace
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
id|add128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
op_decrement
id|zExp
suffix:semicolon
r_if
c_cond
(paren
id|zSig0
OL
id|LIT64
c_func
(paren
l_int|0x0002000000000000
)paren
)paren
r_goto
id|roundAndPack
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
id|shiftRight1
suffix:colon
id|shift128ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
id|zSig2
comma
l_int|1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
id|roundAndPack
suffix:colon
r_return
id|roundAndPackFloat128
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the absolute values of the quadruple-&n;precision floating-point values `a&squot; and `b&squot;.  If `zSign&squot; is true, the&n;difference is negated before being returned.  `zSign&squot; is ignored if the&n;result is a NaN.  The subtraction is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|subFloat128Sigs
r_static
id|float128
id|subFloat128Sigs
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
comma
id|flag
id|zSign
)paren
(brace
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
id|zSig0
comma
id|zSig1
suffix:semicolon
id|int32
id|expDiff
suffix:semicolon
id|float128
id|z
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|14
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|bSig0
comma
id|bSig1
comma
l_int|14
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OL
id|expDiff
)paren
r_goto
id|aExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
r_goto
id|bExpBigger
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
op_or
id|bSig0
op_or
id|bSig1
)paren
(brace
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|float128_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|float128_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
id|aExp
op_assign
l_int|1
suffix:semicolon
id|bExp
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bSig0
OL
id|aSig0
)paren
r_goto
id|aBigger
suffix:semicolon
r_if
c_cond
(paren
id|aSig0
OL
id|bSig0
)paren
r_goto
id|bBigger
suffix:semicolon
r_if
c_cond
(paren
id|bSig1
OL
id|aSig1
)paren
r_goto
id|aBigger
suffix:semicolon
r_if
c_cond
(paren
id|aSig1
OL
id|bSig1
)paren
r_goto
id|bBigger
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|float_rounding_mode
op_eq
id|float_round_down
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|bExpBigger
suffix:colon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|bSig0
op_or
id|bSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|zSign
op_xor
l_int|1
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
op_increment
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
)brace
id|shift128RightJamming
c_func
(paren
id|aSig0
comma
id|aSig1
comma
op_minus
id|expDiff
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|bSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
id|bBigger
suffix:colon
id|sub128
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|aSig0
comma
id|aSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_assign
id|bExp
suffix:semicolon
id|zSign
op_xor_assign
l_int|1
suffix:semicolon
r_goto
id|normalizeRoundAndPack
suffix:semicolon
id|aExpBigger
suffix:colon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
op_decrement
id|expDiff
suffix:semicolon
)brace
r_else
(brace
id|bSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
)brace
id|shift128RightJamming
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|expDiff
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x4000000000000000
)paren
suffix:semicolon
id|aBigger
suffix:colon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zExp
op_assign
id|aExp
suffix:semicolon
id|normalizeRoundAndPack
suffix:colon
op_decrement
id|zExp
suffix:semicolon
r_return
id|normalizeRoundAndPackFloat128
c_func
(paren
id|zSign
comma
id|zExp
op_minus
l_int|14
comma
id|zSig0
comma
id|zSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of adding the quadruple-precision floating-point values&n;`a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE Standard&n;for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_add
id|float128
id|float128_add
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|addFloat128Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|subFloat128Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of subtracting the quadruple-precision floating-point&n;values `a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_sub
id|float128
id|float128_sub
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_eq
id|bSign
)paren
(brace
r_return
id|subFloat128Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|addFloat128Sigs
c_func
(paren
id|a
comma
id|b
comma
id|aSign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of multiplying the quadruple-precision floating-point&n;values `a&squot; and `b&squot;.  The operation is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_mul
id|float128
id|float128_mul
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
comma
id|zSig3
suffix:semicolon
id|float128
id|z
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|aSig0
op_or
id|aSig1
)paren
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bSig0
op_or
id|bSig1
)paren
)paren
)paren
(brace
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bExp
op_or
id|bSig0
op_or
id|bSig1
)paren
op_eq
l_int|0
)paren
r_goto
id|invalid
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|bSig0
op_or
id|bSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
(brace
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|float128_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|float128_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat128Subnormal
c_func
(paren
id|aSig0
comma
id|aSig1
comma
op_amp
id|aExp
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|bSig0
op_or
id|bSig1
)paren
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat128Subnormal
c_func
(paren
id|bSig0
comma
id|bSig1
comma
op_amp
id|bExp
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_plus
id|bExp
op_minus
l_int|0x4000
suffix:semicolon
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|bSig0
comma
id|bSig1
comma
l_int|16
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
id|mul128To256
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
comma
op_amp
id|zSig2
comma
op_amp
id|zSig3
)paren
suffix:semicolon
id|add128
c_func
(paren
id|zSig0
comma
id|zSig1
comma
id|aSig0
comma
id|aSig1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
)paren
suffix:semicolon
id|zSig2
op_or_assign
(paren
id|zSig3
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LIT64
c_func
(paren
l_int|0x0002000000000000
)paren
op_le
id|zSig0
)paren
(brace
id|shift128ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
id|zSig2
comma
l_int|1
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
)brace
r_return
id|roundAndPackFloat128
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the result of dividing the quadruple-precision floating-point value&n;`a&squot; by the corresponding value `b&squot;.  The operation is performed according to&n;the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_div
id|float128
id|float128_div
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int32
id|aExp
comma
id|bExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
suffix:semicolon
id|bits64
id|rem0
comma
id|rem1
comma
id|rem2
comma
id|rem3
comma
id|term0
comma
id|term1
comma
id|term2
comma
id|term3
suffix:semicolon
id|float128
id|z
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
id|zSign
op_assign
id|aSign
op_xor
id|bSign
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|bSig0
op_or
id|bSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|bSig0
op_or
id|bSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|bSig0
op_or
id|bSig1
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
(brace
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|float128_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|float128_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
id|float_raise
c_func
(paren
id|float_flag_divbyzero
)paren
suffix:semicolon
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0x7FFF
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|normalizeFloat128Subnormal
c_func
(paren
id|bSig0
comma
id|bSig1
comma
op_amp
id|bExp
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
id|zSign
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat128Subnormal
c_func
(paren
id|aSig0
comma
id|aSig1
comma
op_amp
id|aExp
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
id|zExp
op_assign
id|aExp
op_minus
id|bExp
op_plus
l_int|0x3FFD
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
op_or
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
comma
id|aSig1
comma
l_int|15
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|bSig0
op_or
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
comma
id|bSig1
comma
l_int|15
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le128
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|aSig0
comma
id|aSig1
)paren
)paren
(brace
id|shift128Right
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
op_increment
id|zExp
suffix:semicolon
)brace
id|zSig0
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
)paren
suffix:semicolon
id|mul128By64To192
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|zSig0
comma
op_amp
id|term0
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|sub192
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|0
comma
id|term0
comma
id|term1
comma
id|term2
comma
op_amp
id|rem0
comma
op_amp
id|rem1
comma
op_amp
id|rem2
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem0
OL
l_int|0
)paren
(brace
op_decrement
id|zSig0
suffix:semicolon
id|add192
c_func
(paren
id|rem0
comma
id|rem1
comma
id|rem2
comma
l_int|0
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
comma
op_amp
id|rem2
)paren
suffix:semicolon
)brace
id|zSig1
op_assign
id|estimateDiv128To64
c_func
(paren
id|rem1
comma
id|rem2
comma
id|bSig0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zSig1
op_amp
l_int|0x3FFF
)paren
op_le
l_int|4
)paren
(brace
id|mul128By64To192
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|zSig1
comma
op_amp
id|term1
comma
op_amp
id|term2
comma
op_amp
id|term3
)paren
suffix:semicolon
id|sub192
c_func
(paren
id|rem1
comma
id|rem2
comma
l_int|0
comma
id|term1
comma
id|term2
comma
id|term3
comma
op_amp
id|rem1
comma
op_amp
id|rem2
comma
op_amp
id|rem3
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem1
OL
l_int|0
)paren
(brace
op_decrement
id|zSig1
suffix:semicolon
id|add192
c_func
(paren
id|rem1
comma
id|rem2
comma
id|rem3
comma
l_int|0
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|rem1
comma
op_amp
id|rem2
comma
op_amp
id|rem3
)paren
suffix:semicolon
)brace
id|zSig1
op_or_assign
(paren
(paren
id|rem1
op_or
id|rem2
op_or
id|rem3
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
id|shift128ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
l_int|0
comma
l_int|15
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
r_return
id|roundAndPackFloat128
c_func
(paren
id|zSign
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the remainder of the quadruple-precision floating-point value `a&squot;&n;with respect to the corresponding value `b&squot;.  The operation is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_rem
id|float128
id|float128_rem
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
comma
id|zSign
suffix:semicolon
id|int32
id|aExp
comma
id|bExp
comma
id|expDiff
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
suffix:semicolon
id|bits64
id|q
comma
id|term0
comma
id|term1
comma
id|term2
comma
id|allZero
comma
id|alternateASig0
comma
id|alternateASig1
suffix:semicolon
id|bits64
id|sigMean1
suffix:semicolon
id|sbits64
id|sigMean0
suffix:semicolon
id|float128
id|z
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
suffix:semicolon
id|bExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|b
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|aSig0
op_or
id|aSig1
)paren
op_logical_or
(paren
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|bSig0
op_or
id|bSig1
)paren
)paren
)paren
(brace
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
r_goto
id|invalid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|bSig0
op_or
id|bSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|bSig0
op_or
id|bSig1
)paren
op_eq
l_int|0
)paren
(brace
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|float128_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|float128_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
id|normalizeFloat128Subnormal
c_func
(paren
id|bSig0
comma
id|bSig1
comma
op_amp
id|bExp
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|normalizeFloat128Subnormal
c_func
(paren
id|aSig0
comma
id|aSig1
comma
op_amp
id|aExp
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
id|expDiff
op_assign
id|aExp
op_minus
id|bExp
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
op_minus
l_int|1
)paren
r_return
id|a
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
op_or
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
comma
id|aSig1
comma
l_int|15
op_minus
(paren
id|expDiff
OL
l_int|0
)paren
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|bSig0
op_or
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
comma
id|bSig1
comma
l_int|15
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
id|q
op_assign
id|le128
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|aSig0
comma
id|aSig1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|expDiff
op_sub_assign
l_int|64
suffix:semicolon
r_while
c_loop
(paren
l_int|0
OL
id|expDiff
)paren
(brace
id|q
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
)paren
suffix:semicolon
id|q
op_assign
(paren
l_int|4
OL
id|q
)paren
ques
c_cond
id|q
op_minus
l_int|4
suffix:colon
l_int|0
suffix:semicolon
id|mul128By64To192
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|q
comma
op_amp
id|term0
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|shortShift192Left
c_func
(paren
id|term0
comma
id|term1
comma
id|term2
comma
l_int|61
comma
op_amp
id|term1
comma
op_amp
id|term2
comma
op_amp
id|allZero
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|61
comma
op_amp
id|aSig0
comma
op_amp
id|allZero
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
l_int|0
comma
id|term1
comma
id|term2
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|expDiff
op_sub_assign
l_int|61
suffix:semicolon
)brace
r_if
c_cond
(paren
op_minus
l_int|64
OL
id|expDiff
)paren
(brace
id|q
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
)paren
suffix:semicolon
id|q
op_assign
(paren
l_int|4
OL
id|q
)paren
ques
c_cond
id|q
op_minus
l_int|4
suffix:colon
l_int|0
suffix:semicolon
id|q
op_rshift_assign
op_minus
id|expDiff
suffix:semicolon
id|shift128Right
c_func
(paren
id|bSig0
comma
id|bSig1
comma
l_int|12
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
id|expDiff
op_add_assign
l_int|52
suffix:semicolon
r_if
c_cond
(paren
id|expDiff
OL
l_int|0
)paren
(brace
id|shift128Right
c_func
(paren
id|aSig0
comma
id|aSig1
comma
op_minus
id|expDiff
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
r_else
(brace
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|expDiff
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
id|mul128By64To192
c_func
(paren
id|bSig0
comma
id|bSig1
comma
id|q
comma
op_amp
id|term0
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|term1
comma
id|term2
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
r_else
(brace
id|shift128Right
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|12
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|shift128Right
c_func
(paren
id|bSig0
comma
id|bSig1
comma
l_int|12
comma
op_amp
id|bSig0
comma
op_amp
id|bSig1
)paren
suffix:semicolon
)brace
r_do
(brace
id|alternateASig0
op_assign
id|aSig0
suffix:semicolon
id|alternateASig1
op_assign
id|aSig1
suffix:semicolon
op_increment
id|q
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|bSig0
comma
id|bSig1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
op_le
(paren
id|sbits64
)paren
id|aSig0
)paren
suffix:semicolon
id|add128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|alternateASig0
comma
id|alternateASig1
comma
op_amp
id|sigMean0
comma
op_amp
id|sigMean1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sigMean0
OL
l_int|0
)paren
op_logical_or
(paren
(paren
(paren
id|sigMean0
op_or
id|sigMean1
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|aSig0
op_assign
id|alternateASig0
suffix:semicolon
id|aSig1
op_assign
id|alternateASig1
suffix:semicolon
)brace
id|zSign
op_assign
(paren
(paren
id|sbits64
)paren
id|aSig0
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zSign
)paren
id|sub128
c_func
(paren
l_int|0
comma
l_int|0
comma
id|aSig0
comma
id|aSig1
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
r_return
id|normalizeRoundAndPackFloat128
c_func
(paren
id|aSign
op_xor
id|zSign
comma
id|bExp
op_minus
l_int|4
comma
id|aSig0
comma
id|aSig1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns the square root of the quadruple-precision floating-point value `a&squot;.&n;The operation is performed according to the IEC/IEEE Standard for Binary&n;Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_sqrt
id|float128
id|float128_sqrt
c_func
(paren
id|float128
id|a
)paren
(brace
id|flag
id|aSign
suffix:semicolon
id|int32
id|aExp
comma
id|zExp
suffix:semicolon
id|bits64
id|aSig0
comma
id|aSig1
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
suffix:semicolon
id|bits64
id|rem0
comma
id|rem1
comma
id|rem2
comma
id|rem3
comma
id|term0
comma
id|term1
comma
id|term2
comma
id|term3
suffix:semicolon
id|bits64
id|shiftedRem0
comma
id|shiftedRem1
suffix:semicolon
id|float128
id|z
suffix:semicolon
id|aSig1
op_assign
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSig0
op_assign
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
suffix:semicolon
id|aExp
op_assign
id|extractFloat128Exp
c_func
(paren
id|a
)paren
suffix:semicolon
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0x7FFF
)paren
(brace
r_if
c_cond
(paren
id|aSig0
op_or
id|aSig1
)paren
r_return
id|propagateFloat128NaN
c_func
(paren
id|a
comma
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aSign
)paren
r_return
id|a
suffix:semicolon
r_goto
id|invalid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aSign
)paren
(brace
r_if
c_cond
(paren
(paren
id|aExp
op_or
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
r_return
id|a
suffix:semicolon
id|invalid
suffix:colon
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|z.low
op_assign
id|float128_default_nan_low
suffix:semicolon
id|z.high
op_assign
id|float128_default_nan_high
suffix:semicolon
r_return
id|z
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aExp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|aSig0
op_or
id|aSig1
)paren
op_eq
l_int|0
)paren
r_return
id|packFloat128
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|normalizeFloat128Subnormal
c_func
(paren
id|aSig0
comma
id|aSig1
comma
op_amp
id|aExp
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
)brace
id|zExp
op_assign
(paren
(paren
id|aExp
op_minus
l_int|0x3FFF
)paren
op_rshift
l_int|1
)paren
op_plus
l_int|0x3FFE
suffix:semicolon
id|aSig0
op_or_assign
id|LIT64
c_func
(paren
l_int|0x0001000000000000
)paren
suffix:semicolon
id|zSig0
op_assign
id|estimateSqrt32
c_func
(paren
id|aExp
comma
id|aSig0
op_rshift
l_int|17
)paren
suffix:semicolon
id|zSig0
op_lshift_assign
l_int|31
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|13
op_minus
(paren
id|aExp
op_amp
l_int|1
)paren
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|zSig0
op_assign
id|estimateDiv128To64
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|zSig0
)paren
op_plus
id|zSig0
op_plus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_le
(paren
id|sbits64
)paren
id|zSig0
)paren
id|zSig0
op_assign
id|LIT64
c_func
(paren
l_int|0xFFFFFFFFFFFFFFFF
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|aSig0
comma
id|aSig1
comma
l_int|2
comma
op_amp
id|aSig0
comma
op_amp
id|aSig1
)paren
suffix:semicolon
id|mul64To128
c_func
(paren
id|zSig0
comma
id|zSig0
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|aSig0
comma
id|aSig1
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem0
OL
l_int|0
)paren
(brace
op_decrement
id|zSig0
suffix:semicolon
id|shortShift128Left
c_func
(paren
l_int|0
comma
id|zSig0
comma
l_int|1
comma
op_amp
id|term0
comma
op_amp
id|term1
)paren
suffix:semicolon
id|term1
op_or_assign
l_int|1
suffix:semicolon
id|add128
c_func
(paren
id|rem0
comma
id|rem1
comma
id|term0
comma
id|term1
comma
op_amp
id|rem0
comma
op_amp
id|rem1
)paren
suffix:semicolon
)brace
id|shortShift128Left
c_func
(paren
id|rem0
comma
id|rem1
comma
l_int|63
comma
op_amp
id|shiftedRem0
comma
op_amp
id|shiftedRem1
)paren
suffix:semicolon
id|zSig1
op_assign
id|estimateDiv128To64
c_func
(paren
id|shiftedRem0
comma
id|shiftedRem1
comma
id|zSig0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zSig1
op_amp
l_int|0x3FFF
)paren
op_le
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|zSig1
op_eq
l_int|0
)paren
id|zSig1
op_assign
l_int|1
suffix:semicolon
id|mul64To128
c_func
(paren
id|zSig0
comma
id|zSig1
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|shortShift128Left
c_func
(paren
id|term1
comma
id|term2
comma
l_int|1
comma
op_amp
id|term1
comma
op_amp
id|term2
)paren
suffix:semicolon
id|sub128
c_func
(paren
id|rem1
comma
l_int|0
comma
id|term1
comma
id|term2
comma
op_amp
id|rem1
comma
op_amp
id|rem2
)paren
suffix:semicolon
id|mul64To128
c_func
(paren
id|zSig1
comma
id|zSig1
comma
op_amp
id|term2
comma
op_amp
id|term3
)paren
suffix:semicolon
id|sub192
c_func
(paren
id|rem1
comma
id|rem2
comma
l_int|0
comma
l_int|0
comma
id|term2
comma
id|term3
comma
op_amp
id|rem1
comma
op_amp
id|rem2
comma
op_amp
id|rem3
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sbits64
)paren
id|rem1
OL
l_int|0
)paren
(brace
op_decrement
id|zSig1
suffix:semicolon
id|shortShift192Left
c_func
(paren
l_int|0
comma
id|zSig0
comma
id|zSig1
comma
l_int|1
comma
op_amp
id|term1
comma
op_amp
id|term2
comma
op_amp
id|term3
)paren
suffix:semicolon
id|term3
op_or_assign
l_int|1
suffix:semicolon
id|add192
c_func
(paren
id|rem1
comma
id|rem2
comma
id|rem3
comma
id|term1
comma
id|term2
comma
id|term3
comma
op_amp
id|rem1
comma
op_amp
id|rem2
comma
op_amp
id|rem3
)paren
suffix:semicolon
)brace
id|zSig1
op_or_assign
(paren
(paren
id|rem1
op_or
id|rem2
op_or
id|rem3
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
id|shift128ExtraRightJamming
c_func
(paren
id|zSig0
comma
id|zSig1
comma
l_int|0
comma
l_int|15
comma
op_amp
id|zSig0
comma
op_amp
id|zSig1
comma
op_amp
id|zSig2
)paren
suffix:semicolon
r_return
id|roundAndPackFloat128
c_func
(paren
l_int|0
comma
id|zExp
comma
id|zSig0
comma
id|zSig1
comma
id|zSig2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the quadruple-precision floating-point value `a&squot; is equal to&n;the corresponding value `b&squot;, and 0 otherwise.  The comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_eq
id|flag
id|float128_eq
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float128_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float128_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a.low
op_eq
id|b.low
)paren
op_logical_and
(paren
(paren
id|a.high
op_eq
id|b.high
)paren
op_logical_or
(paren
(paren
id|a.low
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the quadruple-precision floating-point value `a&squot; is less than&n;or equal to the corresponding value `b&squot;, and 0 otherwise.  The comparison&n;is performed according to the IEC/IEEE Standard for Binary Floating-point&n;Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_le
id|flag
id|float128_le
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_or
(paren
(paren
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|le128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|le128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the quadruple-precision floating-point value `a&squot; is less than&n;the corresponding value `b&squot;, and 0 otherwise.  The comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_lt
id|flag
id|float128_lt
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_and
(paren
(paren
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|lt128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|lt128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the quadruple-precision floating-point value `a&squot; is equal to&n;the corresponding value `b&squot;, and 0 otherwise.  The invalid exception is&n;raised if either operand is a NaN.  Otherwise, the comparison is performed&n;according to the IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_eq_signaling
id|flag
id|float128_eq_signaling
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
)paren
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|a.low
op_eq
id|b.low
)paren
op_logical_and
(paren
(paren
id|a.high
op_eq
id|b.high
)paren
op_logical_or
(paren
(paren
id|a.low
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
op_eq
l_int|0
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the quadruple-precision floating-point value `a&squot; is less than&n;or equal to the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs do not&n;cause an exception.  Otherwise, the comparison is performed according to the&n;IEC/IEEE Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_le_quiet
id|flag
id|float128_le_quiet
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float128_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float128_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_or
(paren
(paren
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|le128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|le128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;-------------------------------------------------------------------------------&n;Returns 1 if the quadruple-precision floating-point value `a&squot; is less than&n;the corresponding value `b&squot;, and 0 otherwise.  Quiet NaNs do not cause an&n;exception.  Otherwise, the comparison is performed according to the IEC/IEEE&n;Standard for Binary Floating-point Arithmetic.&n;-------------------------------------------------------------------------------&n;*/
DECL|function|float128_lt_quiet
id|flag
id|float128_lt_quiet
c_func
(paren
id|float128
id|a
comma
id|float128
id|b
)paren
(brace
id|flag
id|aSign
comma
id|bSign
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|a
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|a
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|a
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|extractFloat128Exp
c_func
(paren
id|b
)paren
op_eq
l_int|0x7FFF
)paren
op_logical_and
(paren
id|extractFloat128Frac0
c_func
(paren
id|b
)paren
op_or
id|extractFloat128Frac1
c_func
(paren
id|b
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|float128_is_signaling_nan
c_func
(paren
id|a
)paren
op_logical_or
id|float128_is_signaling_nan
c_func
(paren
id|b
)paren
)paren
(brace
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|aSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|a
)paren
suffix:semicolon
id|bSign
op_assign
id|extractFloat128Sign
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aSign
op_ne
id|bSign
)paren
(brace
r_return
id|aSign
op_logical_and
(paren
(paren
(paren
(paren
id|bits64
)paren
(paren
(paren
id|a.high
op_or
id|b.high
)paren
op_lshift
l_int|1
)paren
)paren
op_or
id|a.low
op_or
id|b.low
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|aSign
ques
c_cond
id|lt128
c_func
(paren
id|b.high
comma
id|b.low
comma
id|a.high
comma
id|a.low
)paren
suffix:colon
id|lt128
c_func
(paren
id|a.high
comma
id|a.low
comma
id|b.high
comma
id|b.low
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
