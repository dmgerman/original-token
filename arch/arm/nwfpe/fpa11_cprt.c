multiline_comment|/*&n;    NetWinder Floating Point Emulator&n;    (c) Rebel.com, 1998-1999&n;    (c) Philip Blundell, 1999&n;&n;    Direct questions, comments to Scott Bambrough &lt;scottb@netwinder.org&gt;&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*/
macro_line|#include &quot;milieu.h&quot;
macro_line|#include &quot;softfloat.h&quot;
macro_line|#include &quot;fpopcode.h&quot;
macro_line|#include &quot;fpa11.h&quot;
macro_line|#include &quot;fpa11.inl&quot;
macro_line|#include &quot;fpmodule.h&quot;
macro_line|#include &quot;fpmodule.inl&quot;
r_extern
id|flag
id|floatx80_is_nan
c_func
(paren
id|floatx80
)paren
suffix:semicolon
r_extern
id|flag
id|float64_is_nan
c_func
(paren
id|float64
)paren
suffix:semicolon
r_extern
id|flag
id|float32_is_nan
c_func
(paren
id|float32
)paren
suffix:semicolon
r_void
id|SetRoundingMode
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
suffix:semicolon
r_int
r_int
id|PerformFLT
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
suffix:semicolon
r_int
r_int
id|PerformFIX
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
suffix:semicolon
r_static
r_int
r_int
id|PerformComparison
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
suffix:semicolon
DECL|function|EmulateCPRT
r_int
r_int
id|EmulateCPRT
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
(brace
r_int
r_int
id|nRc
op_assign
l_int|1
suffix:semicolon
singleline_comment|//printk(&quot;EmulateCPRT(0x%08x)&bslash;n&quot;,opcode);
r_if
c_cond
(paren
id|opcode
op_amp
l_int|0x800000
)paren
(brace
multiline_comment|/* This is some variant of a comparison (PerformComparison will&n;&t;sort out which one).  Since most of the other CPRT&n;&t;instructions are oddball cases of some sort or other it makes&n;&t;sense to pull this out into a fast path.  */
r_return
id|PerformComparison
c_func
(paren
id|opcode
)paren
suffix:semicolon
)brace
multiline_comment|/* Hint to GCC that we&squot;d like a jump table rather than a load of CMPs */
r_switch
c_cond
(paren
(paren
id|opcode
op_amp
l_int|0x700000
)paren
op_rshift
l_int|20
)paren
(brace
r_case
id|FLT_CODE
op_rshift
l_int|20
suffix:colon
id|nRc
op_assign
id|PerformFLT
c_func
(paren
id|opcode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIX_CODE
op_rshift
l_int|20
suffix:colon
id|nRc
op_assign
id|PerformFIX
c_func
(paren
id|opcode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFS_CODE
op_rshift
l_int|20
suffix:colon
id|writeFPSR
c_func
(paren
id|readRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RFS_CODE
op_rshift
l_int|20
suffix:colon
id|writeRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
comma
id|readFPSR
c_func
(paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0    /* We currently have no use for the FPCR, so there&squot;s no point&n;&t;    in emulating it. */
r_case
id|WFC_CODE
op_rshift
l_int|20
suffix:colon
id|writeFPCR
c_func
(paren
id|readRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
)paren
)paren
suffix:semicolon
r_case
id|RFC_CODE
op_rshift
l_int|20
suffix:colon
id|writeRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
comma
id|readFPCR
c_func
(paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|nRc
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|nRc
suffix:semicolon
)brace
DECL|function|PerformFLT
r_int
r_int
id|PerformFLT
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
(brace
r_int
r_int
id|nRc
op_assign
l_int|1
suffix:semicolon
id|SetRoundingMode
c_func
(paren
id|opcode
)paren
suffix:semicolon
id|SetRoundingPrecision
c_func
(paren
id|opcode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
op_amp
id|MASK_ROUNDING_PRECISION
)paren
(brace
r_case
id|ROUND_SINGLE
suffix:colon
(brace
id|fpa11-&gt;fType
(braket
id|getFn
c_func
(paren
id|opcode
)paren
)braket
op_assign
id|typeSingle
suffix:semicolon
id|fpa11-&gt;fpreg
(braket
id|getFn
c_func
(paren
id|opcode
)paren
)braket
dot
id|fSingle
op_assign
id|int32_to_float32
c_func
(paren
id|readRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUND_DOUBLE
suffix:colon
(brace
id|fpa11-&gt;fType
(braket
id|getFn
c_func
(paren
id|opcode
)paren
)braket
op_assign
id|typeDouble
suffix:semicolon
id|fpa11-&gt;fpreg
(braket
id|getFn
c_func
(paren
id|opcode
)paren
)braket
dot
id|fDouble
op_assign
id|int32_to_float64
c_func
(paren
id|readRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUND_EXTENDED
suffix:colon
(brace
id|fpa11-&gt;fType
(braket
id|getFn
c_func
(paren
id|opcode
)paren
)braket
op_assign
id|typeExtended
suffix:semicolon
id|fpa11-&gt;fpreg
(braket
id|getFn
c_func
(paren
id|opcode
)paren
)braket
dot
id|fExtended
op_assign
id|int32_to_floatx80
c_func
(paren
id|readRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|nRc
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|nRc
suffix:semicolon
)brace
DECL|function|PerformFIX
r_int
r_int
id|PerformFIX
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
(brace
r_int
r_int
id|nRc
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|Fn
op_assign
id|getFm
c_func
(paren
id|opcode
)paren
suffix:semicolon
id|SetRoundingMode
c_func
(paren
id|opcode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|fpa11-&gt;fType
(braket
id|Fn
)braket
)paren
(brace
r_case
id|typeSingle
suffix:colon
(brace
id|writeRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
comma
id|float32_to_int32
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fSingle
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|typeDouble
suffix:colon
(brace
id|writeRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
comma
id|float64_to_int32
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fDouble
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|typeExtended
suffix:colon
(brace
id|writeRegister
c_func
(paren
id|getRd
c_func
(paren
id|opcode
)paren
comma
id|floatx80_to_int32
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fExtended
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|nRc
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|nRc
suffix:semicolon
)brace
r_static
r_int
r_int
id|__inline__
DECL|function|PerformComparisonOperation
id|PerformComparisonOperation
c_func
(paren
id|floatx80
id|Fn
comma
id|floatx80
id|Fm
)paren
(brace
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* test for less than condition */
r_if
c_cond
(paren
id|floatx80_lt
c_func
(paren
id|Fn
comma
id|Fm
)paren
)paren
(brace
id|flags
op_or_assign
id|CC_NEGATIVE
suffix:semicolon
)brace
multiline_comment|/* test for equal condition */
r_if
c_cond
(paren
id|floatx80_eq
c_func
(paren
id|Fn
comma
id|Fm
)paren
)paren
(brace
id|flags
op_or_assign
id|CC_ZERO
suffix:semicolon
)brace
multiline_comment|/* test for greater than or equal condition */
r_if
c_cond
(paren
id|floatx80_lt
c_func
(paren
id|Fm
comma
id|Fn
)paren
)paren
(brace
id|flags
op_or_assign
id|CC_CARRY
suffix:semicolon
)brace
id|writeConditionCodes
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This instruction sets the flags N, Z, C, V in the FPSR. */
DECL|function|PerformComparison
r_static
r_int
r_int
id|PerformComparison
c_func
(paren
r_const
r_int
r_int
id|opcode
)paren
(brace
r_int
r_int
id|Fn
comma
id|Fm
suffix:semicolon
id|floatx80
id|rFn
comma
id|rFm
suffix:semicolon
r_int
id|e_flag
op_assign
id|opcode
op_amp
l_int|0x400000
suffix:semicolon
multiline_comment|/* 1 if CxFE */
r_int
id|n_flag
op_assign
id|opcode
op_amp
l_int|0x200000
suffix:semicolon
multiline_comment|/* 1 if CNxx */
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
singleline_comment|//printk(&quot;PerformComparison(0x%08x)&bslash;n&quot;,opcode);
id|Fn
op_assign
id|getFn
c_func
(paren
id|opcode
)paren
suffix:semicolon
id|Fm
op_assign
id|getFm
c_func
(paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/* Check for unordered condition and convert all operands to 80-bit&n;      format.&n;      ?? Might be some mileage in avoiding this conversion if possible.&n;      Eg, if both operands are 32-bit, detect this and do a 32-bit&n;      comparison (cheaper than an 80-bit one).  */
r_switch
c_cond
(paren
id|fpa11-&gt;fType
(braket
id|Fn
)braket
)paren
(brace
r_case
id|typeSingle
suffix:colon
singleline_comment|//printk(&quot;single.&bslash;n&quot;);
r_if
c_cond
(paren
id|float32_is_nan
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fSingle
)paren
)paren
r_goto
id|unordered
suffix:semicolon
id|rFn
op_assign
id|float32_to_floatx80
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fSingle
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|typeDouble
suffix:colon
singleline_comment|//printk(&quot;double.&bslash;n&quot;);
r_if
c_cond
(paren
id|float64_is_nan
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fDouble
)paren
)paren
r_goto
id|unordered
suffix:semicolon
id|rFn
op_assign
id|float64_to_floatx80
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fDouble
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|typeExtended
suffix:colon
singleline_comment|//printk(&quot;extended.&bslash;n&quot;);
r_if
c_cond
(paren
id|floatx80_is_nan
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fExtended
)paren
)paren
r_goto
id|unordered
suffix:semicolon
id|rFn
op_assign
id|fpa11-&gt;fpreg
(braket
id|Fn
)braket
dot
id|fExtended
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CONSTANT_FM
c_func
(paren
id|opcode
)paren
)paren
(brace
singleline_comment|//printk(&quot;Fm is a constant: #%d.&bslash;n&quot;,Fm);
id|rFm
op_assign
id|getExtendedConstant
c_func
(paren
id|Fm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|floatx80_is_nan
c_func
(paren
id|rFm
)paren
)paren
r_goto
id|unordered
suffix:semicolon
)brace
r_else
(brace
singleline_comment|//printk(&quot;Fm = r%d which contains a &quot;,Fm);
r_switch
c_cond
(paren
id|fpa11-&gt;fType
(braket
id|Fm
)braket
)paren
(brace
r_case
id|typeSingle
suffix:colon
singleline_comment|//printk(&quot;single.&bslash;n&quot;);
r_if
c_cond
(paren
id|float32_is_nan
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fm
)braket
dot
id|fSingle
)paren
)paren
r_goto
id|unordered
suffix:semicolon
id|rFm
op_assign
id|float32_to_floatx80
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fm
)braket
dot
id|fSingle
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|typeDouble
suffix:colon
singleline_comment|//printk(&quot;double.&bslash;n&quot;);
r_if
c_cond
(paren
id|float64_is_nan
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fm
)braket
dot
id|fDouble
)paren
)paren
r_goto
id|unordered
suffix:semicolon
id|rFm
op_assign
id|float64_to_floatx80
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fm
)braket
dot
id|fDouble
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|typeExtended
suffix:colon
singleline_comment|//printk(&quot;extended.&bslash;n&quot;);
r_if
c_cond
(paren
id|floatx80_is_nan
c_func
(paren
id|fpa11-&gt;fpreg
(braket
id|Fm
)braket
dot
id|fExtended
)paren
)paren
r_goto
id|unordered
suffix:semicolon
id|rFm
op_assign
id|fpa11-&gt;fpreg
(braket
id|Fm
)braket
dot
id|fExtended
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|n_flag
)paren
(brace
id|rFm.high
op_xor_assign
l_int|0x8000
suffix:semicolon
)brace
r_return
id|PerformComparisonOperation
c_func
(paren
id|rFn
comma
id|rFm
)paren
suffix:semicolon
id|unordered
suffix:colon
multiline_comment|/* ?? The FPA data sheet is pretty vague about this, in particular&n;      about whether the non-E comparisons can ever raise exceptions.&n;      This implementation is based on a combination of what it says in&n;      the data sheet, observation of how the Acorn emulator actually&n;      behaves (and how programs expect it to) and guesswork.  */
id|flags
op_or_assign
id|CC_OVERFLOW
suffix:semicolon
id|flags
op_and_assign
op_complement
(paren
id|CC_ZERO
op_or
id|CC_NEGATIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BIT_AC
op_amp
id|readFPSR
c_func
(paren
)paren
)paren
id|flags
op_or_assign
id|CC_CARRY
suffix:semicolon
r_if
c_cond
(paren
id|e_flag
)paren
id|float_raise
c_func
(paren
id|float_flag_invalid
)paren
suffix:semicolon
id|writeConditionCodes
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
