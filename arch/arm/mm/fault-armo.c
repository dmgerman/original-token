multiline_comment|/*&n; *  linux/arch/arm/mm/fault-armo.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; *  Modifications for ARM processor (c) 1995-1999 Russell King&n; */
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|macro|FAULT_CODE_FORCECOW
mdefine_line|#define FAULT_CODE_FORCECOW&t;0x80
DECL|macro|FAULT_CODE_PREFETCH
mdefine_line|#define FAULT_CODE_PREFETCH&t;0x04
DECL|macro|FAULT_CODE_WRITE
mdefine_line|#define FAULT_CODE_WRITE&t;0x02
DECL|macro|FAULT_CODE_USER
mdefine_line|#define FAULT_CODE_USER&t;&t;0x01
DECL|macro|DO_COW
mdefine_line|#define DO_COW(m)&t;&t;((m) &amp; (FAULT_CODE_WRITE|FAULT_CODE_FORCECOW))
DECL|macro|READ_FAULT
mdefine_line|#define READ_FAULT(m)&t;&t;(!((m) &amp; FAULT_CODE_WRITE))
macro_line|#include &quot;fault-common.c&quot;
DECL|function|alloc_table
r_static
r_void
op_star
id|alloc_table
c_func
(paren
r_int
id|size
comma
r_int
id|prio
)paren
(brace
r_if
c_cond
(paren
id|size
op_ne
l_int|128
)paren
id|printk
c_func
(paren
l_string|&quot;invalid table size&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|get_page_8k
c_func
(paren
id|prio
)paren
suffix:semicolon
)brace
DECL|function|free_table
r_void
id|free_table
c_func
(paren
r_void
op_star
id|table
)paren
(brace
id|free_page_8k
c_func
(paren
(paren
r_int
r_int
)paren
id|table
)paren
suffix:semicolon
)brace
DECL|function|get_pgd_slow
id|pgd_t
op_star
id|get_pgd_slow
c_func
(paren
r_void
)paren
(brace
id|pgd_t
op_star
id|pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|alloc_table
c_func
(paren
id|PTRS_PER_PGD
op_star
id|BYTES_PER_PTR
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|pgd_t
op_star
id|init
suffix:semicolon
r_if
c_cond
(paren
id|pgd
)paren
(brace
id|init
op_assign
id|pgd_offset
c_func
(paren
op_amp
id|init_mm
comma
l_int|0
)paren
suffix:semicolon
id|memzero
c_func
(paren
id|pgd
comma
id|USER_PTRS_PER_PGD
op_star
id|BYTES_PER_PTR
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pgd
op_plus
id|USER_PTRS_PER_PGD
comma
id|init
op_plus
id|USER_PTRS_PER_PGD
comma
(paren
id|PTRS_PER_PGD
op_minus
id|USER_PTRS_PER_PGD
)paren
op_star
id|BYTES_PER_PTR
)paren
suffix:semicolon
)brace
r_return
id|pgd
suffix:semicolon
)brace
DECL|function|get_pte_slow
id|pte_t
op_star
id|get_pte_slow
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|offset
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
(paren
id|pte_t
op_star
)paren
id|alloc_table
c_func
(paren
id|PTRS_PER_PTE
op_star
id|BYTES_PER_PTR
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|pte
)paren
(brace
id|memzero
c_func
(paren
id|pte
comma
id|PTRS_PER_PTE
op_star
id|BYTES_PER_PTR
)paren
suffix:semicolon
id|set_pmd
c_func
(paren
id|pmd
comma
id|mk_pmd
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
r_return
id|pte
op_plus
id|offset
suffix:semicolon
)brace
id|set_pmd
c_func
(paren
id|pmd
comma
id|mk_pmd
c_func
(paren
id|BAD_PAGETABLE
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_table
c_func
(paren
(paren
r_void
op_star
)paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|__bad_pmd
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle a data abort.  Note that we have to handle a range of addresses&n; * on ARM2/3 for ldm.  If both pages are zero-mapped, then we have to force&n; * a copy-on-write.  However, on the second page, we always force COW.&n; */
id|asmlinkage
r_void
DECL|function|do_DataAbort
id|do_DataAbort
c_func
(paren
r_int
r_int
id|min_addr
comma
r_int
r_int
id|max_addr
comma
r_int
id|mode
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|do_page_fault
c_func
(paren
id|min_addr
comma
id|mode
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|min_addr
op_xor
id|max_addr
)paren
op_rshift
id|PAGE_SHIFT
)paren
id|do_page_fault
c_func
(paren
id|max_addr
comma
id|mode
op_or
id|FAULT_CODE_FORCECOW
comma
id|regs
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|do_PrefetchAbort
id|do_PrefetchAbort
c_func
(paren
r_int
r_int
id|addr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|the
id|memc
id|mapping
r_for
id|this
id|page
id|exists
op_minus
id|can
id|check
id|now
dot
dot
dot
)paren
(brace
id|printk
(paren
l_string|&quot;Page in, but got abort (undefined instruction?)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|do_page_fault
c_func
(paren
id|addr
comma
id|FAULT_CODE_USER
op_or
id|FAULT_CODE_PREFETCH
comma
id|regs
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
