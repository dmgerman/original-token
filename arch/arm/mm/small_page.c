multiline_comment|/*&n; *  linux/arch/arm/mm/small_page.c&n; *&n; *  Copyright (C) 1996  Russell King&n; *&n; * Changelog:&n; *  26/01/1996&t;RMK&t;Cleaned up various areas to make little more generic&n; *  07/02/1999&t;RMK&t;Support added for 16K and 32K page sizes&n; *&t;&t;&t;containing 8K blocks&n; */
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#if PAGE_SIZE == 4096
multiline_comment|/* 2K blocks */
DECL|macro|SMALL_ALLOC_SHIFT
mdefine_line|#define SMALL_ALLOC_SHIFT&t;(11)
DECL|macro|NAME
mdefine_line|#define NAME(x)&t;&t;&t;x##_2k
macro_line|#elif PAGE_SIZE == 32768 || PAGE_SIZE == 16384
multiline_comment|/* 8K blocks */
DECL|macro|SMALL_ALLOC_SHIFT
mdefine_line|#define SMALL_ALLOC_SHIFT&t;(13)
DECL|macro|NAME
mdefine_line|#define NAME(x)&t;&t;&t;x##_8k
macro_line|#endif
DECL|macro|SMALL_ALLOC_SIZE
mdefine_line|#define SMALL_ALLOC_SIZE&t;(1 &lt;&lt; SMALL_ALLOC_SHIFT)
DECL|macro|NR_BLOCKS
mdefine_line|#define NR_BLOCKS&t;&t;(PAGE_SIZE / SMALL_ALLOC_SIZE)
DECL|macro|BLOCK_MASK
mdefine_line|#define BLOCK_MASK&t;&t;((1 &lt;&lt; NR_BLOCKS) - 1)
DECL|macro|USED
mdefine_line|#define USED(pg)&t;&t;((atomic_read(&amp;(pg)-&gt;count) &gt;&gt; 8) &amp; BLOCK_MASK)
DECL|macro|SET_USED
mdefine_line|#define SET_USED(pg,off)&t;(atomic_read(&amp;(pg)-&gt;count) |= 256 &lt;&lt; off)
DECL|macro|CLEAR_USED
mdefine_line|#define CLEAR_USED(pg,off)&t;(atomic_read(&amp;(pg)-&gt;count) &amp;= ~(256 &lt;&lt; off))
DECL|macro|ALL_USED
mdefine_line|#define ALL_USED&t;&t;BLOCK_MASK
DECL|macro|IS_FREE
mdefine_line|#define IS_FREE(pg,off)&t;&t;(!(atomic_read(&amp;(pg)-&gt;count) &amp; (256 &lt;&lt; off)))
DECL|macro|SM_PAGE_PTR
mdefine_line|#define SM_PAGE_PTR(page,block)&t;((struct free_small_page *)((page) + &bslash;&n;&t;&t;&t;&t;&t;((block) &lt;&lt; SMALL_ALLOC_SHIFT)))
macro_line|#if NR_BLOCKS != 2 &amp;&amp; NR_BLOCKS != 4
macro_line|#error I only support 2 or 4 blocks per page
macro_line|#endif
DECL|struct|free_small_page
r_struct
id|free_small_page
(brace
DECL|member|next
r_int
r_int
id|next
suffix:semicolon
DECL|member|prev
r_int
r_int
id|prev
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * To handle allocating small pages, we use the main get_free_page routine,&n; * and split the page up into 4.  The page is marked in mem_map as reserved,&n; * so it can&squot;t be free&squot;d by free_page.  The count field is used to keep track&n; * of which sections of this page are allocated.&n; */
DECL|variable|small_page_ptr
r_static
r_int
r_int
id|small_page_ptr
suffix:semicolon
DECL|variable|offsets
r_static
r_int
r_char
id|offsets
(braket
l_int|1
op_lshift
id|NR_BLOCKS
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/* 0000 */
l_int|1
comma
multiline_comment|/* 0001 */
l_int|0
comma
multiline_comment|/* 0010 */
l_int|2
comma
multiline_comment|/* 0011 */
macro_line|#if NR_BLOCKS == 4
l_int|0
comma
multiline_comment|/* 0100 */
l_int|1
comma
multiline_comment|/* 0101 */
l_int|0
comma
multiline_comment|/* 0110 */
l_int|3
comma
multiline_comment|/* 0111 */
l_int|0
comma
multiline_comment|/* 1000 */
l_int|1
comma
multiline_comment|/* 1001 */
l_int|0
comma
multiline_comment|/* 1010 */
l_int|2
comma
multiline_comment|/* 1011 */
l_int|0
comma
multiline_comment|/* 1100 */
l_int|1
comma
multiline_comment|/* 1101 */
l_int|0
comma
multiline_comment|/* 1110 */
l_int|4
multiline_comment|/* 1111 */
macro_line|#endif
)brace
suffix:semicolon
DECL|function|clear_page_links
r_static
r_inline
r_void
id|clear_page_links
c_func
(paren
r_int
r_int
id|page
)paren
(brace
r_struct
id|free_small_page
op_star
id|fsp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BLOCKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fsp
op_assign
id|SM_PAGE_PTR
c_func
(paren
id|page
comma
id|i
)paren
suffix:semicolon
id|fsp-&gt;next
op_assign
id|fsp-&gt;prev
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|set_page_links_prev
r_static
r_inline
r_void
id|set_page_links_prev
c_func
(paren
r_int
r_int
id|page
comma
r_int
r_int
id|prev
)paren
(brace
r_struct
id|free_small_page
op_star
id|fsp
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
suffix:semicolon
id|mask
op_assign
id|USED
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BLOCKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_continue
suffix:semicolon
id|fsp
op_assign
id|SM_PAGE_PTR
c_func
(paren
id|page
comma
id|i
)paren
suffix:semicolon
id|fsp-&gt;prev
op_assign
id|prev
suffix:semicolon
)brace
)brace
DECL|function|set_page_links_next
r_static
r_inline
r_void
id|set_page_links_next
c_func
(paren
r_int
r_int
id|page
comma
r_int
r_int
id|next
)paren
(brace
r_struct
id|free_small_page
op_star
id|fsp
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
suffix:semicolon
id|mask
op_assign
id|USED
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BLOCKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_continue
suffix:semicolon
id|fsp
op_assign
id|SM_PAGE_PTR
c_func
(paren
id|page
comma
id|i
)paren
suffix:semicolon
id|fsp-&gt;next
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|get_page
r_int
r_int
id|NAME
c_func
(paren
id|get_page
)paren
(paren
r_int
id|priority
)paren
(brace
r_struct
id|free_small_page
op_star
id|fsp
suffix:semicolon
r_int
r_int
id|new_page
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|small_page_ptr
)paren
r_goto
id|need_new_page
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|again
suffix:colon
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|small_page_ptr
)paren
suffix:semicolon
id|offset
op_assign
id|offsets
(braket
id|USED
c_func
(paren
id|page
)paren
)braket
suffix:semicolon
id|SET_USED
c_func
(paren
id|page
comma
id|offset
)paren
suffix:semicolon
id|new_page
op_assign
(paren
r_int
r_int
)paren
id|SM_PAGE_PTR
c_func
(paren
id|small_page_ptr
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|USED
c_func
(paren
id|page
)paren
op_eq
id|ALL_USED
)paren
(brace
id|fsp
op_assign
(paren
r_struct
id|free_small_page
op_star
)paren
id|new_page
suffix:semicolon
id|set_page_links_prev
(paren
id|fsp-&gt;next
comma
l_int|0
)paren
suffix:semicolon
id|small_page_ptr
op_assign
id|fsp-&gt;next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|new_page
suffix:semicolon
id|need_new_page
suffix:colon
id|new_page
op_assign
id|__get_free_page
c_func
(paren
id|priority
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|small_page_ptr
)paren
(brace
r_if
c_cond
(paren
id|new_page
)paren
(brace
id|set_bit
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|new_page
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
id|clear_page_links
(paren
id|new_page
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|small_page_ptr
op_assign
id|new_page
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|free_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
DECL|function|free_page
r_void
id|NAME
c_func
(paren
id|free_page
)paren
(paren
r_int
r_int
id|spage
)paren
(brace
r_struct
id|free_small_page
op_star
id|ofsp
comma
op_star
id|cfsp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|offset
comma
id|oldoffset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spage
)paren
r_goto
id|none
suffix:semicolon
id|offset
op_assign
(paren
id|spage
op_rshift
id|SMALL_ALLOC_SHIFT
)paren
op_amp
(paren
id|NR_BLOCKS
op_minus
l_int|1
)paren
suffix:semicolon
id|spage
op_sub_assign
id|offset
op_lshift
id|SMALL_ALLOC_SHIFT
suffix:semicolon
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|spage
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_or
op_logical_neg
id|USED
c_func
(paren
id|page
)paren
)paren
r_goto
id|non_small
suffix:semicolon
r_if
c_cond
(paren
id|IS_FREE
c_func
(paren
id|page
comma
id|offset
)paren
)paren
r_goto
id|free
suffix:semicolon
id|save_flags_cli
(paren
id|flags
)paren
suffix:semicolon
id|oldoffset
op_assign
id|offsets
(braket
id|USED
c_func
(paren
id|page
)paren
)braket
suffix:semicolon
id|CLEAR_USED
c_func
(paren
id|page
comma
id|offset
)paren
suffix:semicolon
id|ofsp
op_assign
id|SM_PAGE_PTR
c_func
(paren
id|spage
comma
id|oldoffset
)paren
suffix:semicolon
id|cfsp
op_assign
id|SM_PAGE_PTR
c_func
(paren
id|spage
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldoffset
op_eq
id|NR_BLOCKS
)paren
(brace
multiline_comment|/* going from totally used to mostly used */
id|cfsp-&gt;prev
op_assign
l_int|0
suffix:semicolon
id|cfsp-&gt;next
op_assign
id|small_page_ptr
suffix:semicolon
id|set_page_links_prev
(paren
id|small_page_ptr
comma
id|spage
)paren
suffix:semicolon
id|small_page_ptr
op_assign
id|spage
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|USED
c_func
(paren
id|page
)paren
)paren
(brace
id|set_page_links_prev
(paren
id|ofsp-&gt;next
comma
id|ofsp-&gt;prev
)paren
suffix:semicolon
id|set_page_links_next
(paren
id|ofsp-&gt;prev
comma
id|ofsp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spage
op_eq
id|small_page_ptr
)paren
id|small_page_ptr
op_assign
id|ofsp-&gt;next
suffix:semicolon
id|clear_bit
(paren
id|PG_reserved
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|free_page
(paren
id|spage
)paren
suffix:semicolon
)brace
r_else
op_star
id|cfsp
op_assign
op_star
id|ofsp
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|non_small
suffix:colon
id|printk
(paren
l_string|&quot;Trying to free non-small page from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|free
suffix:colon
id|printk
(paren
l_string|&quot;Trying to free free small page from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|none
suffix:colon
r_return
suffix:semicolon
)brace
eof
