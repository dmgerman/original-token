multiline_comment|/*&n; *  linux/arch/arm/mm/small_page.c&n; *&n; *  Copyright (C) 1996  Russell King&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; *  Changelog:&n; *   26/01/1996&t;RMK&t;Cleaned up various areas to make little more generic&n; *   07/02/1999&t;RMK&t;Support added for 16K and 32K page sizes&n; *&t;&t;&t;containing 8K blocks&n; */
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|macro|PEDANTIC
mdefine_line|#define PEDANTIC
multiline_comment|/*&n; * Requirement:&n; *  We need to be able to allocate naturally aligned memory of finer&n; *  granularity than the page size.  This is typically used for the&n; *  second level page tables on 32-bit ARMs.&n; *&n; * Theory:&n; *  We &quot;misuse&quot; the Linux memory management system.  We use alloc_page&n; *  to allocate a page and then mark it as reserved.  The Linux memory&n; *  management system will then ignore the &quot;offset&quot;, &quot;next_hash&quot; and&n; *  &quot;pprev_hash&quot; entries in the mem_map for this page.&n; *&n; *  We then use a bitstring in the &quot;offset&quot; field to mark which segments&n; *  of the page are in use, and manipulate this as required during the&n; *  allocation and freeing of these small pages.&n; *&n; *  We also maintain a queue of pages being used for this purpose using&n; *  the &quot;next_hash&quot; and &quot;pprev_hash&quot; entries of mem_map;&n; */
DECL|struct|order
r_struct
id|order
(brace
DECL|member|queue
r_struct
id|page
op_star
id|queue
suffix:semicolon
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
multiline_comment|/* (1 &lt;&lt; shift) - 1&t;&t;*/
DECL|member|shift
r_int
r_int
id|shift
suffix:semicolon
multiline_comment|/* (1 &lt;&lt; shift) size of page&t;*/
DECL|member|block_mask
r_int
r_int
id|block_mask
suffix:semicolon
multiline_comment|/* nr_blocks - 1&t;&t;*/
DECL|member|all_used
r_int
r_int
id|all_used
suffix:semicolon
multiline_comment|/* (1 &lt;&lt; nr_blocks) - 1&t;&t;*/
)brace
suffix:semicolon
DECL|variable|orders
r_static
r_struct
id|order
id|orders
(braket
)braket
op_assign
(brace
macro_line|#if PAGE_SIZE == 4096
(brace
l_int|NULL
comma
l_int|2047
comma
l_int|11
comma
l_int|1
comma
l_int|0x00000003
)brace
macro_line|#elif PAGE_SIZE == 32768
(brace
l_int|NULL
comma
l_int|2047
comma
l_int|11
comma
l_int|15
comma
l_int|0x0000ffff
)brace
comma
(brace
l_int|NULL
comma
l_int|8191
comma
l_int|13
comma
l_int|3
comma
l_int|0x0000000f
)brace
macro_line|#else
macro_line|#error unsupported page size
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|USED_MAP
mdefine_line|#define USED_MAP(pg)&t;&t;&t;((pg)-&gt;index)
DECL|macro|TEST_AND_CLEAR_USED
mdefine_line|#define TEST_AND_CLEAR_USED(pg,off)&t;(test_and_clear_bit(off, &amp;USED_MAP(pg)))
DECL|macro|SET_USED
mdefine_line|#define SET_USED(pg,off)&t;&t;(set_bit(off, &amp;USED_MAP(pg)))
DECL|variable|small_page_lock
r_static
id|spinlock_t
id|small_page_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|add_page_to_queue
r_static
r_void
id|add_page_to_queue
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|page
op_star
op_star
id|p
)paren
(brace
macro_line|#ifdef PEDANTIC
r_if
c_cond
(paren
id|page-&gt;pprev_hash
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#endif
id|page-&gt;next_hash
op_assign
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|pprev_hash
op_assign
op_amp
id|page-&gt;next_hash
suffix:semicolon
op_star
id|p
op_assign
id|page
suffix:semicolon
id|page-&gt;pprev_hash
op_assign
id|p
suffix:semicolon
)brace
DECL|function|remove_page_from_queue
r_static
r_void
id|remove_page_from_queue
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;pprev_hash
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;next_hash
)paren
id|page-&gt;next_hash-&gt;pprev_hash
op_assign
id|page-&gt;pprev_hash
suffix:semicolon
op_star
id|page-&gt;pprev_hash
op_assign
id|page-&gt;next_hash
suffix:semicolon
id|page-&gt;pprev_hash
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|__get_small_page
r_static
r_int
r_int
id|__get_small_page
c_func
(paren
r_int
id|priority
comma
r_struct
id|order
op_star
id|order
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|order-&gt;queue
)paren
r_goto
id|need_new_page
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|small_page_lock
comma
id|flags
)paren
suffix:semicolon
id|page
op_assign
id|order-&gt;queue
suffix:semicolon
id|again
suffix:colon
macro_line|#ifdef PEDANTIC
r_if
c_cond
(paren
id|USED_MAP
c_func
(paren
id|page
)paren
op_amp
op_complement
id|order-&gt;all_used
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#endif
id|offset
op_assign
id|ffz
c_func
(paren
id|USED_MAP
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|SET_USED
c_func
(paren
id|page
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|USED_MAP
c_func
(paren
id|page
)paren
op_eq
id|order-&gt;all_used
)paren
id|remove_page_from_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|small_page_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
(paren
id|offset
op_lshift
id|order-&gt;shift
)paren
suffix:semicolon
id|need_new_page
suffix:colon
id|page
op_assign
id|alloc_page
c_func
(paren
id|priority
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|small_page_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|order-&gt;queue
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_page
suffix:semicolon
id|SetPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|USED_MAP
c_func
(paren
id|page
)paren
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|add_page_to_queue
c_func
(paren
id|page
comma
op_amp
id|order-&gt;queue
)paren
suffix:semicolon
)brace
r_else
(brace
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|page
op_assign
id|order-&gt;queue
suffix:semicolon
)brace
r_goto
id|again
suffix:semicolon
id|no_page
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|small_page_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__free_small_page
r_static
r_void
id|__free_small_page
c_func
(paren
r_int
r_int
id|spage
comma
r_struct
id|order
op_star
id|order
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|spage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|VALID_PAGE
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The container-page must be marked Reserved&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_or
id|spage
op_amp
id|order-&gt;mask
)paren
r_goto
id|non_small
suffix:semicolon
macro_line|#ifdef PEDANTIC
r_if
c_cond
(paren
id|USED_MAP
c_func
(paren
id|page
)paren
op_amp
op_complement
id|order-&gt;all_used
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#endif
id|spage
op_assign
id|spage
op_rshift
id|order-&gt;shift
suffix:semicolon
id|spage
op_and_assign
id|order-&gt;block_mask
suffix:semicolon
multiline_comment|/*&n;&t;&t; * the following must be atomic wrt get_page&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|small_page_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|USED_MAP
c_func
(paren
id|page
)paren
op_eq
id|order-&gt;all_used
)paren
id|add_page_to_queue
c_func
(paren
id|page
comma
op_amp
id|order-&gt;queue
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TEST_AND_CLEAR_USED
c_func
(paren
id|page
comma
id|spage
)paren
)paren
r_goto
id|already_free
suffix:semicolon
r_if
c_cond
(paren
id|USED_MAP
c_func
(paren
id|page
)paren
op_eq
l_int|0
)paren
r_goto
id|free_page
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|small_page_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|free_page
suffix:colon
multiline_comment|/*&n;&t; * unlink the page from the small page queue and free it&n;&t; */
id|remove_page_from_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|small_page_lock
comma
id|flags
)paren
suffix:semicolon
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|non_small
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Trying to free non-small page from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|already_free
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Trying to free free small page from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|get_page_2k
r_int
r_int
id|get_page_2k
c_func
(paren
r_int
id|priority
)paren
(brace
r_return
id|__get_small_page
c_func
(paren
id|priority
comma
id|orders
op_plus
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|free_page_2k
r_void
id|free_page_2k
c_func
(paren
r_int
r_int
id|spage
)paren
(brace
id|__free_small_page
c_func
(paren
id|spage
comma
id|orders
op_plus
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if PAGE_SIZE &gt; 8192
DECL|function|get_page_8k
r_int
r_int
id|get_page_8k
c_func
(paren
r_int
id|priority
)paren
(brace
r_return
id|__get_small_page
c_func
(paren
id|priority
comma
id|orders
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|free_page_8k
r_void
id|free_page_8k
c_func
(paren
r_int
r_int
id|spage
)paren
(brace
id|__free_small_page
c_func
(paren
id|spage
comma
id|orders
op_plus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
