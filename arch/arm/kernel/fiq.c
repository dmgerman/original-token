multiline_comment|/*&n; *  linux/arch/arm/kernel/fiq.c&n; *&n; *  Copyright (C) 1998 Russell King&n; *  FIQ support written by Philip Blundell &lt;philb@gnu.org&gt;, 1998.&n; *&n; *  FIQ support re-written by Russell King to be more generic&n; *&n; * We now properly support a method by which the FIQ handlers can&n; * be stacked onto the vector.  We still do not support sharing&n; * the FIQ vector itself.&n; *&n; * Operation is as follows:&n; *  1. Owner A claims FIQ:&n; *     - default_fiq relinquishes control.&n; *  2. Owner A:&n; *     - inserts code.&n; *     - sets any registers,&n; *     - enables FIQ.&n; *  3. Owner B claims FIQ:&n; *     - if owner A has a relinquish function.&n; *       - disable FIQs.&n; *       - saves any registers.&n; *       - returns zero.&n; *  4. Owner B:&n; *     - inserts code.&n; *     - sets any registers,&n; *     - enables FIQ.&n; *  5. Owner B releases FIQ:&n; *     - Owner A is asked to reacquire FIQ:&n; *&t; - inserts code.&n; *&t; - restores saved registers.&n; *&t; - enables FIQ.&n; *  6. Goto 3&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/fiq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|FIQ_VECTOR
mdefine_line|#define FIQ_VECTOR 0x1c
DECL|variable|no_fiq_insn
r_static
r_int
r_int
id|no_fiq_insn
suffix:semicolon
macro_line|#ifdef CONFIG_CPU_32
DECL|function|unprotect_page_0
r_static
r_inline
r_void
id|unprotect_page_0
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mcr&t;p15, 0, %0, c3, c0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|DOMAIN_USER_MANAGER
op_or
id|DOMAIN_KERNEL_CLIENT
op_or
id|DOMAIN_IO_CLIENT
)paren
)paren
suffix:semicolon
)brace
DECL|function|protect_page_0
r_static
r_inline
r_void
id|protect_page_0
c_func
(paren
r_void
)paren
(brace
id|set_fs
c_func
(paren
id|get_fs
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|unprotect_page_0
mdefine_line|#define unprotect_page_0()
DECL|macro|protect_page_0
mdefine_line|#define protect_page_0()
macro_line|#endif
multiline_comment|/* Default reacquire function&n; * - we always relinquish FIQ control&n; * - we always reacquire FIQ control&n; */
DECL|function|fiq_def_op
r_int
id|fiq_def_op
c_func
(paren
r_void
op_star
id|ref
comma
r_int
id|relinquish
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|relinquish
)paren
(brace
id|unprotect_page_0
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|FIQ_VECTOR
op_assign
id|no_fiq_insn
suffix:semicolon
id|protect_page_0
c_func
(paren
)paren
suffix:semicolon
id|__flush_entry_to_ram
c_func
(paren
id|FIQ_VECTOR
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|default_owner
r_static
r_struct
id|fiq_handler
id|default_owner
op_assign
(brace
l_int|NULL
comma
l_string|&quot;default&quot;
comma
id|fiq_def_op
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|current_fiq
r_static
r_struct
id|fiq_handler
op_star
id|current_fiq
op_assign
op_amp
id|default_owner
suffix:semicolon
DECL|function|get_fiq_list
r_int
id|get_fiq_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|current_fiq
op_ne
op_amp
id|default_owner
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;FIQ:              %s&bslash;n&quot;
comma
id|current_fiq-&gt;name
)paren
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
DECL|function|set_fiq_handler
r_void
id|set_fiq_handler
c_func
(paren
r_void
op_star
id|start
comma
r_int
r_int
id|length
)paren
(brace
id|unprotect_page_0
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|FIQ_VECTOR
comma
id|start
comma
id|length
)paren
suffix:semicolon
id|protect_page_0
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This doesn&squot;w work correctly.  Ok, it&squot;s a misuse&n;&t; * of the DMA flushing code, but it ought to work.&n;&t; * More investigation required.  Maybe it really&n;&t; * needs the cache flushed.&n;&t; */
id|dma_cache_wback
c_func
(paren
id|FIQ_VECTOR
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|processor.u.armv3v4
dot
id|_flush_cache_area
c_func
(paren
id|FIQ_VECTOR
comma
id|FIQ_VECTOR
op_plus
id|length
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|set_fiq_regs
r_void
id|set_fiq_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* not yet -&n;&t; * this is temporary to get the floppy working&n;&t; * again on RiscPC.  It *will* become more&n;&t; * generic.&n;&t; */
macro_line|#ifdef CONFIG_ARCH_ACORN
r_extern
r_void
id|floppy_fiqsetup
c_func
(paren
r_int
r_int
id|len
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|port
)paren
suffix:semicolon
id|floppy_fiqsetup
c_func
(paren
id|regs-&gt;ARM_r9
comma
id|regs-&gt;ARM_r10
comma
id|regs-&gt;ARM_fp
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|get_fiq_regs
r_void
id|get_fiq_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* not yet */
)brace
DECL|function|claim_fiq
r_int
id|claim_fiq
c_func
(paren
r_struct
id|fiq_handler
op_star
id|f
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current_fiq
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|current_fiq-&gt;fiq_op
op_ne
l_int|NULL
)paren
id|ret
op_assign
id|current_fiq
op_member_access_from_pointer
id|fiq_op
c_func
(paren
id|current_fiq-&gt;dev_id
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|f-&gt;next
op_assign
id|current_fiq
suffix:semicolon
id|current_fiq
op_assign
id|f
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|release_fiq
r_void
id|release_fiq
c_func
(paren
r_struct
id|fiq_handler
op_star
id|f
)paren
(brace
r_if
c_cond
(paren
id|current_fiq
op_ne
id|f
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s FIQ trying to release %s FIQ&bslash;n&quot;
comma
id|f-&gt;name
comma
id|current_fiq-&gt;name
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_ERRORS
id|__backtrace
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_do
id|current_fiq
op_assign
id|current_fiq-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|current_fiq
op_member_access_from_pointer
id|fiq_op
c_func
(paren
id|current_fiq-&gt;dev_id
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|init_FIQ
c_func
(paren
r_void
)paren
)paren
(brace
id|no_fiq_insn
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|FIQ_VECTOR
suffix:semicolon
id|set_fs
c_func
(paren
id|get_fs
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
eof
