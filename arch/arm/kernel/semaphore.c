multiline_comment|/*&n; *  ARM semaphore implementation, taken from&n; *&n; *  i386 semaphore implementation.&n; *&n; *  (C) Copyright 1999 Linus Torvalds&n; *&n; *  Modified for ARM by Russell King&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/*&n; * Semaphores are implemented using a two-way counter:&n; * The &quot;count&quot; variable is decremented for each process&n; * that tries to acquire the semaphore, while the &quot;sleeping&quot;&n; * variable is a count of such acquires.&n; *&n; * Notably, the inline &quot;up()&quot; and &quot;down()&quot; functions can&n; * efficiently test if they need to do any extra work (up&n; * needs to do something only if count was negative before&n; * the increment operation.&n; *&n; * &quot;sleeping&quot; and the contention routine ordering is&n; * protected by the semaphore spinlock.&n; *&n; * Note that these functions are only called when there is&n; * contention on the lock, and as such all this is the&n; * &quot;non-critical&quot; part of the whole semaphore business. The&n; * critical part is the inline stuff in &lt;asm/semaphore.h&gt;&n; * where we want to avoid any extra jumps and calls.&n; */
multiline_comment|/*&n; * Logic:&n; *  - only on a boundary condition do we need to care. When we go&n; *    from a negative count to a non-negative, we wake people up.&n; *  - when we go from a non-negative count to a negative do we&n; *    (a) synchronize with the &quot;sleeper&quot; count and (b) make sure&n; *    that we&squot;re on the wakeup list before we synchronize so that&n; *    we cannot lose wakeup events.&n; */
DECL|function|__up
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|variable|semaphore_lock
r_static
id|spinlock_t
id|semaphore_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|__down
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|sem-&gt;sleepers
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|sleepers
op_assign
id|sem-&gt;sleepers
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add &quot;everybody else&quot; into it. They aren&squot;t&n;&t;&t; * playing, because we own the spinlock.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
)paren
(brace
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sem-&gt;sleepers
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* us - see -1 above */
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|function|__down_interruptible
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|sem-&gt;sleepers
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|sleepers
op_assign
id|sem-&gt;sleepers
suffix:semicolon
multiline_comment|/*&n;&t;&t; * With signals pending, this turns into&n;&t;&t; * the trylock failure case - we won&squot;t be&n;&t;&t; * sleeping, and we* can&squot;t get the lock as&n;&t;&t; * it has contention. Just correct the count&n;&t;&t; * and exit.&n;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
id|atomic_add
c_func
(paren
id|sleepers
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Add &quot;everybody else&quot; into it. They aren&squot;t&n;&t;&t; * playing, because we own the spinlock. The&n;&t;&t; * &quot;-1&quot; is because we&squot;re still hoping to get&n;&t;&t; * the lock.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
)paren
(brace
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sem-&gt;sleepers
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* us - see -1 above */
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|semaphore_lock
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Trylock failed - make sure we correct for&n; * having decremented the count.&n; *&n; * We could have done the trylock with a&n; * single &quot;cmpxchg&quot; without failure cases,&n; * but then it wouldn&squot;t work on a 386.&n; */
DECL|function|__down_trylock
r_int
id|__down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|sleepers
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
id|sleepers
op_assign
id|sem-&gt;sleepers
op_plus
l_int|1
suffix:semicolon
id|sem-&gt;sleepers
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Add &quot;everybody else&quot; and us into it. They aren&squot;t&n;&t; * playing, because we own the spinlock.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_add_negative
c_func
(paren
id|sleepers
comma
op_amp
id|sem-&gt;count
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|down_read_failed_biased
r_struct
id|rw_semaphore
op_star
id|down_read_failed_biased
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* put ourselves at the head of the list */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|sem-&gt;read_bias_granted
op_logical_and
id|xchg
c_func
(paren
op_amp
id|sem-&gt;read_bias_granted
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sem-&gt;read_bias_granted
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
DECL|function|down_write_failed_biased
r_struct
id|rw_semaphore
op_star
id|down_write_failed_biased
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* put ourselves at the end of the list */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|sem-&gt;write_bias_granted
op_logical_and
id|xchg
c_func
(paren
op_amp
id|sem-&gt;write_bias_granted
comma
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sem-&gt;write_bias_granted
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* if the lock is currently unbiased, awaken the sleepers&n;&t; * FIXME: this wakes up the readers early in a bit of a&n;&t; * stampede -&gt; bad!&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
op_ge
l_int|0
)paren
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/* Wait for the lock to become unbiased.  Readers&n; * are non-exclusive. =)&n; */
DECL|function|down_read_failed
r_struct
id|rw_semaphore
op_star
id|down_read_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* this takes care of granting the lock */
id|__up_op_read
c_func
(paren
id|sem
comma
id|__rwsem_wake
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
OL
l_int|0
)paren
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/* Wait for the lock to become unbiased. Since we&squot;re&n; * a writer, we&squot;ll make ourselves exclusive.&n; */
DECL|function|down_write_failed
r_struct
id|rw_semaphore
op_star
id|down_write_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* this takes care of granting the lock */
id|__up_op_write
c_func
(paren
id|sem
comma
id|__rwsem_wake
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
OL
l_int|0
)paren
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
op_ge
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* we must attempt to acquire or bias the lock */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/* Called when someone has done an up that transitioned from&n; * negative to non-negative, meaning that the lock has been&n; * granted to whomever owned the bias.&n; */
DECL|function|rwsem_wake_readers
r_struct
id|rw_semaphore
op_star
id|rwsem_wake_readers
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_if
c_cond
(paren
id|xchg
c_func
(paren
op_amp
id|sem-&gt;read_bias_granted
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
DECL|function|rwsem_wake_writer
r_struct
id|rw_semaphore
op_star
id|rwsem_wake_writer
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_if
c_cond
(paren
id|xchg
c_func
(paren
op_amp
id|sem-&gt;write_bias_granted
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
)paren
suffix:semicolon
r_return
id|sem
suffix:semicolon
)brace
multiline_comment|/*&n; * The semaphore operations have a special calling sequence that&n; * allow us to do a simpler in-line version of them. These routines&n; * need to convert that sequence back into the C sequence when&n; * there is contention on the semaphore.&n; *&n; * ip contains the semaphore pointer on entry. Save the C-clobbered&n; * registers (r0 to r3 and lr), but not ip, as we use it as a return&n; * value in some cases..&n; */
macro_line|#ifdef CONFIG_CPU_26
id|asm
c_func
(paren
"&quot;"
dot
id|section
dot
id|text.lock
comma
"&bslash;&quot;"
id|ax
"&bslash;&quot;"
dot
id|align
l_int|5
dot
id|globl
id|__down_failed
id|__down_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__down
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
dot
id|align
l_int|5
dot
id|globl
id|__down_interruptible_failed
id|__down_interruptible_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__down_interruptible
id|mov
id|ip
comma
id|r0
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
dot
id|align
l_int|5
dot
id|globl
id|__down_trylock_failed
id|__down_trylock_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__down_trylock
id|mov
id|ip
comma
id|r0
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
dot
id|align
l_int|5
dot
id|globl
id|__up_wakeup
id|__up_wakeup
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__up
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
dot
id|align
l_int|5
dot
id|globl
id|__down_read_failed
id|__down_read_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bcc
l_float|1f
l_int|1
suffix:colon
id|bl
id|down_read_failed_biased
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
l_int|2
suffix:colon
id|bl
id|down_read_failed
id|mov
id|r1
comma
id|pc
id|orr
id|r2
comma
id|r1
comma
macro_line|#
id|teqp
id|r2
comma
macro_line|#0
id|ldr
id|r3
comma
(braket
id|r0
)braket
id|subs
id|r3
comma
id|r3
comma
macro_line|#1
id|str
id|r3
comma
(braket
id|r0
)braket
id|ldmplfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
id|orrcs
id|r1
comma
id|r1
comma
macro_line|#0x20000000   @ Set carry
id|teqp
id|r1
comma
macro_line|#0
id|bcc
l_int|2
id|b
id|b
l_int|1
id|b
dot
id|align
l_int|5
dot
id|globl
id|__down_write_failed
id|__down_write_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bcc
l_float|1f
l_int|1
suffix:colon
id|bl
id|down_write_failed_biased
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
l_int|2
suffix:colon
id|bl
id|down_write_failed
id|mov
id|r1
comma
id|pc
id|orr
id|r2
comma
id|r1
comma
macro_line|#128
id|teqp
id|r2
comma
macro_line|#0
id|ldr
id|r3
comma
(braket
id|r0
)braket
id|subs
id|r3
comma
id|r3
comma
macro_line|#&quot;RW_LOCK_BIAS_STR&quot;
id|str
id|r3
comma
(braket
id|r0
)braket
id|ldmeqfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
id|orrcs
id|r1
comma
id|r1
comma
macro_line|#0x20000000   @ Set carry
id|teqp
id|r1
comma
macro_line|#0
id|bcc
l_int|2
id|b
id|b
l_int|1
id|b
dot
id|align
l_int|5
dot
id|globl
id|__rwsem_wake
id|__rwsem_wake
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|beq
l_float|1f
id|bl
id|rwsem_wake_readers
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
l_int|1
suffix:colon
id|bl
id|rwsem_wake_writer
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
op_xor
dot
id|previous
"&quot;"
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* 32 bit version */
id|asm
c_func
(paren
"&quot;"
dot
id|section
dot
id|text.lock
comma
"&bslash;&quot;"
id|ax
"&bslash;&quot;"
dot
id|align
l_int|5
dot
id|globl
id|__down_failed
id|__down_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__down
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
dot
id|align
l_int|5
dot
id|globl
id|__down_interruptible_failed
id|__down_interruptible_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__down_interruptible
id|mov
id|ip
comma
id|r0
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
dot
id|align
l_int|5
dot
id|globl
id|__down_trylock_failed
id|__down_trylock_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__down_trylock
id|mov
id|ip
comma
id|r0
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
dot
id|align
l_int|5
dot
id|globl
id|__up_wakeup
id|__up_wakeup
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bl
id|__up
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
dot
id|align
l_int|5
dot
id|globl
id|__down_read_failed
id|__down_read_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bcc
l_float|1f
l_int|1
suffix:colon
id|bl
id|down_read_failed_biased
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
l_int|2
suffix:colon
id|bl
id|down_read_failed
id|mrs
id|r1
comma
id|cpsr
id|orr
id|r2
comma
id|r1
comma
macro_line|#128
id|msr
id|cpsr_c
comma
id|r2
id|ldr
id|r3
comma
(braket
id|r0
)braket
id|subs
id|r3
comma
id|r3
comma
macro_line|#1
id|str
id|r3
comma
(braket
id|r0
)braket
id|msr
id|cpsr_c
comma
id|r1
id|ldmplfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
id|bcc
l_int|2
id|b
id|b
l_int|1
id|b
dot
id|align
l_int|5
dot
id|globl
id|__down_write_failed
id|__down_write_failed
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|bcc
l_float|1f
l_int|1
suffix:colon
id|bl
id|down_write_failed_biased
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
l_int|2
suffix:colon
id|bl
id|down_write_failed
id|mrs
id|r1
comma
id|cpsr
id|orr
id|r2
comma
id|r1
comma
macro_line|#128
id|msr
id|cpsr_c
comma
id|r2
id|ldr
id|r3
comma
(braket
id|r0
)braket
id|subs
id|r3
comma
id|r3
comma
macro_line|#&quot;RW_LOCK_BIAS_STR&quot;
id|str
id|r3
comma
(braket
id|r0
)braket
id|msr
id|cpsr_c
comma
id|r1
id|ldmeqfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
id|bcc
l_int|2
id|b
id|b
l_int|1
id|b
dot
id|align
l_int|5
dot
id|globl
id|__rwsem_wake
id|__rwsem_wake
suffix:colon
id|stmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|lr
)brace
id|mov
id|r0
comma
id|ip
id|beq
l_float|1f
id|bl
id|rwsem_wake_readers
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
l_int|1
suffix:colon
id|bl
id|rwsem_wake_writer
id|ldmfd
id|sp
op_logical_neg
comma
(brace
id|r0
op_minus
id|r3
comma
id|pc
)brace
dot
id|previous
"&quot;"
)paren
suffix:semicolon
macro_line|#endif
eof
