multiline_comment|/*&n; * Program to hack in a PT_NOTE program header entry in an ELF file.&n; * This is needed for OF on RS/6000s to load an image correctly.&n; * Note that OF needs a program header entry for the note, not an&n; * ELF section.&n; *&n; * Copyright 2000 Paul Mackerras.&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * Usage: addnote zImage&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;string.h&gt;
DECL|variable|arch
r_char
id|arch
(braket
)braket
op_assign
l_string|&quot;PowerPC&quot;
suffix:semicolon
DECL|macro|N_DESCR
mdefine_line|#define N_DESCR&t;6
DECL|variable|descr
r_int
r_int
id|descr
(braket
id|N_DESCR
)braket
op_assign
(brace
macro_line|#if 1
multiline_comment|/* values for IBM RS/6000 machines */
l_int|0xffffffff
comma
multiline_comment|/* real-mode = true */
l_int|0x00c00000
comma
multiline_comment|/* real-base, i.e. where we expect OF to be */
l_int|0xffffffff
comma
multiline_comment|/* real-size */
l_int|0xffffffff
comma
multiline_comment|/* virt-base */
l_int|0xffffffff
comma
multiline_comment|/* virt-size */
l_int|0x4000
comma
multiline_comment|/* load-base */
macro_line|#else
multiline_comment|/* values for longtrail CHRP */
l_int|0
comma
multiline_comment|/* real-mode = false */
l_int|0xffffffff
comma
multiline_comment|/* real-base */
l_int|0xffffffff
comma
multiline_comment|/* real-size */
l_int|0xffffffff
comma
multiline_comment|/* virt-base */
l_int|0xffffffff
comma
multiline_comment|/* virt-size */
l_int|0x00600000
comma
multiline_comment|/* load-base */
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|buf
r_int
r_char
id|buf
(braket
l_int|512
)braket
suffix:semicolon
DECL|macro|GET_16BE
mdefine_line|#define GET_16BE(off)&t;((buf[off] &lt;&lt; 8) + (buf[(off)+1]))
DECL|macro|GET_32BE
mdefine_line|#define GET_32BE(off)&t;((GET_16BE(off) &lt;&lt; 16) + GET_16BE((off)+2))
DECL|macro|PUT_16BE
mdefine_line|#define PUT_16BE(off, v)&t;(buf[off] = ((v) &gt;&gt; 8) &amp; 0xff, &bslash;&n;&t;&t;&t;&t; buf[(off) + 1] = (v) &amp; 0xff)
DECL|macro|PUT_32BE
mdefine_line|#define PUT_32BE(off, v)&t;(PUT_16BE((off), (v) &gt;&gt; 16), &bslash;&n;&t;&t;&t;&t; PUT_16BE((off) + 2, (v)))
multiline_comment|/* Structure of an ELF file */
DECL|macro|E_IDENT
mdefine_line|#define E_IDENT&t;&t;0&t;/* ELF header */
DECL|macro|E_PHOFF
mdefine_line|#define&t;E_PHOFF&t;&t;28
DECL|macro|E_PHENTSIZE
mdefine_line|#define E_PHENTSIZE&t;42
DECL|macro|E_PHNUM
mdefine_line|#define E_PHNUM&t;&t;44
DECL|macro|E_HSIZE
mdefine_line|#define E_HSIZE&t;&t;52&t;/* size of ELF header */
DECL|macro|EI_MAGIC
mdefine_line|#define EI_MAGIC&t;0&t;/* offsets in E_IDENT area */
DECL|macro|EI_CLASS
mdefine_line|#define EI_CLASS&t;4
DECL|macro|EI_DATA
mdefine_line|#define EI_DATA&t;&t;5
DECL|macro|PH_TYPE
mdefine_line|#define PH_TYPE&t;&t;0&t;/* ELF program header */
DECL|macro|PH_OFFSET
mdefine_line|#define PH_OFFSET&t;4
DECL|macro|PH_FILESZ
mdefine_line|#define PH_FILESZ&t;16
DECL|macro|PH_HSIZE
mdefine_line|#define PH_HSIZE&t;32&t;/* size of program header */
DECL|macro|PT_NOTE
mdefine_line|#define PT_NOTE&t;&t;4&t;/* Program header type = note */
DECL|macro|ELFCLASS32
mdefine_line|#define ELFCLASS32&t;1
DECL|macro|ELFDATA2MSB
mdefine_line|#define ELFDATA2MSB&t;2
DECL|variable|elf_magic
r_int
r_char
id|elf_magic
(braket
l_int|4
)braket
op_assign
(brace
l_int|0x7f
comma
l_char|&squot;E&squot;
comma
l_char|&squot;L&squot;
comma
l_char|&squot;F&squot;
)brace
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|ac
comma
r_char
op_star
op_star
id|av
)paren
(brace
r_int
id|fd
comma
id|n
comma
id|i
suffix:semicolon
r_int
id|ph
comma
id|ps
comma
id|np
suffix:semicolon
r_int
id|nnote
comma
id|ns
suffix:semicolon
r_if
c_cond
(paren
id|ac
op_ne
l_int|2
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: %s elf-file&bslash;n&quot;
comma
id|av
(braket
l_int|0
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|fd
op_assign
id|open
c_func
(paren
id|av
(braket
l_int|1
)braket
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|av
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|nnote
op_assign
id|strlen
c_func
(paren
id|arch
)paren
op_plus
l_int|1
op_plus
(paren
id|N_DESCR
op_plus
l_int|3
)paren
op_star
l_int|4
suffix:semicolon
id|n
op_assign
id|read
c_func
(paren
id|fd
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;read&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OL
id|E_HSIZE
op_logical_or
id|memcmp
c_func
(paren
op_amp
id|buf
(braket
id|E_IDENT
op_plus
id|EI_MAGIC
)braket
comma
id|elf_magic
comma
l_int|4
)paren
op_ne
l_int|0
)paren
r_goto
id|notelf
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|E_IDENT
op_plus
id|EI_CLASS
)braket
op_ne
id|ELFCLASS32
op_logical_or
id|buf
(braket
id|E_IDENT
op_plus
id|EI_DATA
)braket
op_ne
id|ELFDATA2MSB
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s is not a big-endian 32-bit ELF image&bslash;n&quot;
comma
id|av
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|ph
op_assign
id|GET_32BE
c_func
(paren
id|E_PHOFF
)paren
suffix:semicolon
id|ps
op_assign
id|GET_16BE
c_func
(paren
id|E_PHENTSIZE
)paren
suffix:semicolon
id|np
op_assign
id|GET_16BE
c_func
(paren
id|E_PHNUM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ph
OL
id|E_HSIZE
op_logical_or
id|ps
OL
id|PH_HSIZE
op_logical_or
id|np
OL
l_int|1
)paren
r_goto
id|notelf
suffix:semicolon
r_if
c_cond
(paren
id|ph
op_plus
(paren
id|np
op_plus
l_int|1
)paren
op_star
id|ps
op_plus
id|nnote
OG
id|n
)paren
r_goto
id|nospace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|GET_32BE
c_func
(paren
id|ph
op_plus
id|PH_TYPE
)paren
op_eq
id|PT_NOTE
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s already has a note entry&bslash;n&quot;
comma
id|av
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|ph
op_add_assign
id|ps
suffix:semicolon
)brace
multiline_comment|/* XXX check that the area we want to use is all zeroes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ps
op_plus
id|nnote
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|buf
(braket
id|ph
op_plus
id|i
)braket
op_ne
l_int|0
)paren
r_goto
id|nospace
suffix:semicolon
multiline_comment|/* fill in the program header entry */
id|ns
op_assign
id|ph
op_plus
id|ps
suffix:semicolon
id|PUT_32BE
c_func
(paren
id|ph
op_plus
id|PH_TYPE
comma
id|PT_NOTE
)paren
suffix:semicolon
id|PUT_32BE
c_func
(paren
id|ph
op_plus
id|PH_OFFSET
comma
id|ns
)paren
suffix:semicolon
id|PUT_32BE
c_func
(paren
id|ph
op_plus
id|PH_FILESZ
comma
id|nnote
)paren
suffix:semicolon
multiline_comment|/* fill in the note area we point to */
multiline_comment|/* XXX we should probably make this a proper section */
id|PUT_32BE
c_func
(paren
id|ns
comma
id|strlen
c_func
(paren
id|arch
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|PUT_32BE
c_func
(paren
id|ns
op_plus
l_int|4
comma
id|N_DESCR
op_star
l_int|4
)paren
suffix:semicolon
id|PUT_32BE
c_func
(paren
id|ns
op_plus
l_int|8
comma
l_int|0x1275
)paren
suffix:semicolon
id|strcpy
c_func
(paren
op_amp
id|buf
(braket
id|ns
op_plus
l_int|12
)braket
comma
id|arch
)paren
suffix:semicolon
id|ns
op_add_assign
l_int|12
op_plus
id|strlen
c_func
(paren
id|arch
)paren
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_DESCR
suffix:semicolon
op_increment
id|i
)paren
id|PUT_32BE
c_func
(paren
id|ns
op_plus
id|i
op_star
l_int|4
comma
id|descr
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Update the number of program headers */
id|PUT_16BE
c_func
(paren
id|E_PHNUM
comma
id|np
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* write back */
id|lseek
c_func
(paren
id|fd
comma
(paren
r_int
)paren
l_int|0
comma
id|SEEK_SET
)paren
suffix:semicolon
id|i
op_assign
id|write
c_func
(paren
id|fd
comma
id|buf
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;write&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|n
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: write truncated&bslash;n&quot;
comma
id|av
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
m_exit
(paren
l_int|0
)paren
suffix:semicolon
id|notelf
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s does not appear to be an ELF file&bslash;n&quot;
comma
id|av
(braket
l_int|0
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
id|nospace
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;sorry, I can&squot;t find space in %s to put the note&bslash;n&quot;
comma
id|av
(braket
l_int|0
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
eof
