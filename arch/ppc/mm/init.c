multiline_comment|/*&n; *  $Id: init.c,v 1.195 1999/10/15 16:39:39 cort Exp $&n; *&n; *  PowerPC version &n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)&n; *  and Cort Dougan (PReP) (cort@cs.nmt.edu)&n; *    Copyright (C) 1996 Paul Mackerras&n; *  Amiga/APUS changes by Jesper Skov (jskov@cygnus.co.uk).&n; *&n; *  Derived from &quot;arch/i386/mm/init.c&quot;&n; *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/openpic.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
macro_line|#include &lt;linux/blk.h&gt;&t;&t;/* for initrd_* */
macro_line|#endif
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_8xx
macro_line|#include &lt;asm/8xx_immap.h&gt;
macro_line|#include &lt;asm/mpc8xx.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_8260
macro_line|#include &lt;asm/immap_8260.h&gt;
macro_line|#include &lt;asm/mpc8260.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/bootx.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#include &lt;asm/gemini.h&gt;
macro_line|#include &quot;mem_pieces.h&quot;
macro_line|#if defined(CONFIG_4xx)
macro_line|#include &quot;4xx_tlb.h&quot;
macro_line|#endif
DECL|macro|MAX_LOW_MEM
mdefine_line|#define MAX_LOW_MEM&t;(640 &lt;&lt; 20)
DECL|macro|PGTOKB
mdefine_line|#define&t;PGTOKB(pages)&t;(((pages) * PAGE_SIZE) &gt;&gt; 10)
DECL|variable|prom_trashed
r_int
id|prom_trashed
suffix:semicolon
DECL|variable|next_mmu_context
id|atomic_t
id|next_mmu_context
suffix:semicolon
DECL|variable|end_of_DRAM
r_int
r_int
op_star
id|end_of_DRAM
suffix:semicolon
DECL|variable|total_memory
r_int
r_int
id|total_memory
suffix:semicolon
DECL|variable|total_lowmem
r_int
r_int
id|total_lowmem
suffix:semicolon
DECL|variable|mem_init_done
r_int
id|mem_init_done
suffix:semicolon
DECL|variable|init_bootmem_done
r_int
id|init_bootmem_done
suffix:semicolon
DECL|variable|boot_mapsize
r_int
id|boot_mapsize
suffix:semicolon
DECL|variable|totalram_pages
r_int
r_int
id|totalram_pages
suffix:semicolon
DECL|variable|totalhigh_pages
r_int
r_int
id|totalhigh_pages
suffix:semicolon
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
)braket
suffix:semicolon
r_extern
r_char
id|_start
(braket
)braket
comma
id|_end
(braket
)braket
suffix:semicolon
r_extern
r_char
id|etext
(braket
)braket
comma
id|_stext
(braket
)braket
suffix:semicolon
r_extern
r_char
id|__init_begin
comma
id|__init_end
suffix:semicolon
r_extern
r_char
id|__prep_begin
comma
id|__prep_end
suffix:semicolon
r_extern
r_char
id|__chrp_begin
comma
id|__chrp_end
suffix:semicolon
r_extern
r_char
id|__pmac_begin
comma
id|__pmac_end
suffix:semicolon
r_extern
r_char
id|__apus_begin
comma
id|__apus_end
suffix:semicolon
r_extern
r_char
id|__openfirmware_begin
comma
id|__openfirmware_end
suffix:semicolon
DECL|variable|memory_node
r_struct
id|device_node
op_star
id|memory_node
suffix:semicolon
DECL|variable|ioremap_base
r_int
r_int
id|ioremap_base
suffix:semicolon
DECL|variable|ioremap_bot
r_int
r_int
id|ioremap_bot
suffix:semicolon
DECL|variable|avail_start
r_int
r_int
id|avail_start
suffix:semicolon
r_extern
r_int
id|num_memory
suffix:semicolon
r_extern
r_struct
id|mem_info
id|memory
(braket
)braket
suffix:semicolon
r_extern
id|boot_infos_t
op_star
id|boot_infos
suffix:semicolon
r_extern
r_int
r_int
id|rtas_data
comma
id|rtas_size
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
DECL|variable|quicklists
r_struct
id|pgtable_cache_struct
id|quicklists
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_HIGHMEM
DECL|variable|kmap_pte
id|pte_t
op_star
id|kmap_pte
suffix:semicolon
DECL|variable|kmap_prot
id|pgprot_t
id|kmap_prot
suffix:semicolon
macro_line|#endif
r_void
id|MMU_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|MMU_get_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|prep_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|pmac_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|apus_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|gemini_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_8xx
r_int
r_int
id|m8xx_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
macro_line|#ifdef CONFIG_4xx
r_int
r_int
id|oak_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_8260
r_int
r_int
id|m8260_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_8260 */
r_static
r_void
id|mapin_ram
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|map_page
c_func
(paren
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
suffix:semicolon
r_void
id|set_phys_avail
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
suffix:semicolon
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_char
id|_start
(braket
)braket
comma
id|_end
(braket
)braket
suffix:semicolon
r_extern
r_char
id|_stext
(braket
)braket
comma
id|etext
(braket
)braket
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|current_set
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|phys_mem
r_struct
id|mem_pieces
id|phys_mem
suffix:semicolon
DECL|variable|klimit
r_char
op_star
id|klimit
op_assign
id|_end
suffix:semicolon
DECL|variable|phys_avail
r_struct
id|mem_pieces
id|phys_avail
suffix:semicolon
DECL|variable|Hash
DECL|variable|Hash_end
id|PTE
op_star
id|Hash
comma
op_star
id|Hash_end
suffix:semicolon
DECL|variable|Hash_size
DECL|variable|Hash_mask
r_int
r_int
id|Hash_size
comma
id|Hash_mask
suffix:semicolon
macro_line|#if !defined(CONFIG_4xx) &amp;&amp; !defined(CONFIG_8xx)
DECL|variable|_SDR1
r_int
r_int
id|_SDR1
suffix:semicolon
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|union|ubat
r_union
id|ubat
(brace
multiline_comment|/* BAT register values to be loaded */
DECL|member|bat
id|BAT
id|bat
suffix:semicolon
macro_line|#ifdef CONFIG_PPC64BRIDGE
DECL|member|word
id|u64
id|word
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#else
DECL|member|word
id|u32
id|word
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif&t;
DECL|variable|BATS
)brace
id|BATS
(braket
l_int|4
)braket
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* 4 pairs of IBAT, DBAT */
DECL|struct|batrange
r_struct
id|batrange
(brace
multiline_comment|/* stores address ranges mapped by BATs */
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
DECL|member|phys
r_int
r_int
id|phys
suffix:semicolon
DECL|variable|bat_addrs
)brace
id|bat_addrs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n; * Return PA for this VA if it is mapped by a BAT, or 0&n; */
DECL|function|v_mapped_by_bats
r_static
r_inline
r_int
r_int
id|v_mapped_by_bats
c_func
(paren
r_int
r_int
id|va
)paren
(brace
r_int
id|b
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
r_if
c_cond
(paren
id|va
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|va
OL
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
r_return
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
op_plus
(paren
id|va
op_minus
id|bat_addrs
(braket
id|b
)braket
dot
id|start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return VA for a given PA or 0 if not mapped&n; */
DECL|function|p_mapped_by_bats
r_static
r_inline
r_int
r_int
id|p_mapped_by_bats
c_func
(paren
r_int
r_int
id|pa
)paren
(brace
r_int
id|b
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
r_if
c_cond
(paren
id|pa
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
op_logical_and
id|pa
OL
(paren
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
op_minus
id|bat_addrs
(braket
id|b
)braket
dot
id|start
)paren
op_plus
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
)paren
r_return
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_plus
(paren
id|pa
op_minus
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else /* CONFIG_4xx || CONFIG_8xx */
DECL|macro|v_mapped_by_bats
mdefine_line|#define v_mapped_by_bats(x)&t;(0UL)
DECL|macro|p_mapped_by_bats
mdefine_line|#define p_mapped_by_bats(x)&t;(0UL)
macro_line|#endif /* !CONFIG_4xx &amp;&amp; !CONFIG_8xx */
multiline_comment|/*&n; * this tells the system to map all of ram with the segregs&n; * (i.e. page tables) instead of the bats.&n; * -- Cort&n; */
DECL|variable|__map_without_bats
r_int
id|__map_without_bats
suffix:semicolon
multiline_comment|/* max amount of RAM to use */
DECL|variable|__max_memory
r_int
r_int
id|__max_memory
suffix:semicolon
DECL|function|__bad_pte
r_void
id|__bad_pte
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
)brace
DECL|function|get_pte_slow
id|pte_t
op_star
id|get_pte_slow
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|offset
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mem_init_done
)paren
id|pte
op_assign
(paren
id|pte_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|pte
op_assign
(paren
id|pte_t
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
id|clear_page
c_func
(paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte
)paren
(brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pte
suffix:semicolon
r_return
id|pte
op_plus
id|offset
suffix:semicolon
)brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|__bad_pte
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|offset
suffix:semicolon
)brace
DECL|function|do_check_pgt_cache
r_int
id|do_check_pgt_cache
c_func
(paren
r_int
id|low
comma
r_int
id|high
)paren
(brace
r_int
id|freed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pgtable_cache_size
OG
id|high
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|pgd_quicklist
)paren
(brace
id|free_pgd_slow
c_func
(paren
id|get_pgd_fast
c_func
(paren
)paren
)paren
comma
id|freed
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_quicklist
)paren
(brace
id|free_pmd_slow
c_func
(paren
id|get_pmd_fast
c_func
(paren
)paren
)paren
comma
id|freed
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pte_quicklist
)paren
(brace
id|free_pte_slow
c_func
(paren
id|get_pte_fast
c_func
(paren
)paren
)paren
comma
id|freed
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|pgtable_cache_size
OG
id|low
)paren
(brace
suffix:semicolon
)brace
)brace
r_return
id|freed
suffix:semicolon
)brace
multiline_comment|/*&n; * BAD_PAGE is the page that is used for page faults when linux&n; * is out-of-memory. Older versions of linux just did a&n; * do_exit(), but using this instead means there is less risk&n; * for a process dying in kernel mode, possibly leaving a inode&n; * unused etc..&n; *&n; * BAD_PAGETABLE is the accompanying page-table: it is initialized&n; * to point to BAD_PAGE entries.&n; *&n; * ZERO_PAGE is a special page that is used for zero-initialized&n; * data and COW.&n; */
DECL|variable|empty_bad_page_table
id|pte_t
op_star
id|empty_bad_page_table
suffix:semicolon
DECL|function|__bad_pagetable
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
(brace
id|clear_page
c_func
(paren
id|empty_bad_page_table
)paren
suffix:semicolon
r_return
id|empty_bad_page_table
suffix:semicolon
)brace
DECL|variable|empty_bad_page
r_void
op_star
id|empty_bad_page
suffix:semicolon
DECL|function|__bad_page
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
(brace
id|clear_page
c_func
(paren
id|empty_bad_page
)paren
suffix:semicolon
r_return
id|pte_mkdirty
c_func
(paren
id|mk_pte_phys
c_func
(paren
id|__pa
c_func
(paren
id|empty_bad_page
)paren
comma
id|PAGE_SHARED
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
op_assign
l_int|0
comma
id|cached
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|highmem
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Free swap:       %6dkB&bslash;n&quot;
comma
id|nr_swap_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageHighMem
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|highmem
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|cached
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|page_count
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages of HIGHMEM&bslash;n&quot;
comma
id|highmem
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d free pages&bslash;n&quot;
comma
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages swap cached&bslash;n&quot;
comma
id|cached
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages in page table cache&bslash;n&quot;
comma
(paren
r_int
)paren
id|pgtable_cache_size
)paren
suffix:semicolon
id|show_buffers
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%-8s %3s %8s %8s %8s %9s %8s&quot;
comma
l_string|&quot;Process&quot;
comma
l_string|&quot;Pid&quot;
comma
l_string|&quot;Ctx&quot;
comma
l_string|&quot;Ctx&lt;&lt;4&quot;
comma
l_string|&quot;Last Sys&quot;
comma
l_string|&quot;pc&quot;
comma
l_string|&quot;task&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printk
c_func
(paren
l_string|&quot; %3s&quot;
comma
l_string|&quot;CPU&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%-8.8s %3d %8ld %8ld %8ld %c%08lx %08lx &quot;
comma
id|p-&gt;comm
comma
id|p-&gt;pid
comma
(paren
id|p-&gt;mm
)paren
ques
c_cond
id|p-&gt;mm-&gt;context
suffix:colon
l_int|0
comma
(paren
id|p-&gt;mm
)paren
ques
c_cond
(paren
id|p-&gt;mm-&gt;context
op_lshift
l_int|4
)paren
suffix:colon
l_int|0
comma
id|p-&gt;thread.last_syscall
comma
(paren
id|p-&gt;thread.regs
)paren
ques
c_cond
id|user_mode
c_func
(paren
id|p-&gt;thread.regs
)paren
ques
c_cond
l_char|&squot;u&squot;
suffix:colon
l_char|&squot;k&squot;
suffix:colon
l_char|&squot;?&squot;
comma
(paren
id|p-&gt;thread.regs
)paren
ques
c_cond
id|p-&gt;thread.regs-&gt;nip
suffix:colon
l_int|0
comma
(paren
id|ulong
)paren
id|p
)paren
suffix:semicolon
(brace
r_int
id|iscur
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printk
c_func
(paren
l_string|&quot;%3d &quot;
comma
id|p-&gt;processor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;processor
op_ne
id|NO_PROC_ID
)paren
op_logical_and
(paren
id|p
op_eq
id|current_set
(braket
id|p-&gt;processor
)braket
)paren
)paren
(brace
id|iscur
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
(brace
id|iscur
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|last_task_used_math
)paren
(brace
r_if
c_cond
(paren
id|iscur
)paren
id|printk
c_func
(paren
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last math&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
id|val-&gt;totalram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|atomic_read
c_func
(paren
op_amp
id|buffermem_pages
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;totalram
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;sharedram
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|val-&gt;totalhigh
op_assign
id|totalhigh_pages
suffix:semicolon
id|val-&gt;freehigh
op_assign
id|nr_free_highpages
c_func
(paren
)paren
suffix:semicolon
id|val-&gt;mem_unit
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_void
op_star
DECL|function|ioremap
id|ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|__ioremap
c_func
(paren
id|addr
comma
id|size
comma
id|_PAGE_NO_CACHE
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|__ioremap
id|__ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|p
comma
id|v
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Choose an address to map it to.&n;&t; * Once the vmalloc system is running, we use it.&n;&t; * Before then, we map addresses &gt;= ioremap_base&n;&t; * virt == phys; for addresses below this we use&n;&t; * space going down from ioremap_base (ioremap_bot&n;&t; * records where we&squot;re up to).&n;&t; */
id|p
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
op_plus
id|size
)paren
op_minus
id|p
suffix:semicolon
multiline_comment|/*&n;&t; * If the address lies within the first 16 MB, assume it&squot;s in ISA&n;&t; * memory space&n;&t; */
r_if
c_cond
(paren
id|p
OL
l_int|16
op_star
l_int|1024
op_star
l_int|1024
)paren
id|p
op_add_assign
id|_ISA_MEM_BASE
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t allow anybody to remap normal RAM that we&squot;re using.&n;&t; * mem_init() sets high_memory so only do the check after that.&n;&t; */
r_if
c_cond
(paren
id|mem_init_done
op_logical_and
(paren
id|p
OL
id|virt_to_phys
c_func
(paren
id|high_memory
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;__ioremap(): phys addr %0lx is RAM lr %p&bslash;n&quot;
comma
id|p
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Is it already mapped?  Perhaps overlapped by a previous&n;&t; * BAT mapping.  If the whole area is mapped then we&squot;re done,&n;&t; * otherwise remap it since we want to keep the virt addrs for&n;&t; * each request contiguous.&n;&t; *&n;&t; * We make the assumption here that if the bottom and top&n;&t; * of the range we want are mapped then it&squot;s mapped to the&n;&t; * same virt address (and this is contiguous).&n;&t; *  -- Cort&n;&t; */
r_if
c_cond
(paren
(paren
id|v
op_assign
id|p_mapped_by_bats
c_func
(paren
id|p
)paren
)paren
multiline_comment|/*&amp;&amp; p_mapped_by_bats(p+size-1)*/
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
r_struct
id|vm_struct
op_star
id|area
suffix:semicolon
id|area
op_assign
id|get_vm_area
c_func
(paren
id|size
comma
id|VM_IOREMAP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|v
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|area-&gt;addr
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p
op_ge
id|ioremap_base
)paren
id|v
op_assign
id|p
suffix:semicolon
r_else
id|v
op_assign
(paren
id|ioremap_bot
op_sub_assign
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|_PAGE_PRESENT
)paren
op_eq
l_int|0
)paren
id|flags
op_or_assign
id|pgprot_val
c_func
(paren
id|PAGE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|_PAGE_NO_CACHE
op_or
id|_PAGE_WRITETHRU
)paren
)paren
id|flags
op_or_assign
id|_PAGE_GUARDED
suffix:semicolon
multiline_comment|/*&n;&t; * Is it a candidate for a BAT mapping?&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_add_assign
id|PAGE_SIZE
)paren
id|map_page
c_func
(paren
id|v
op_plus
id|i
comma
id|p
op_plus
id|i
comma
id|flags
)paren
suffix:semicolon
id|out
suffix:colon
r_return
(paren
r_void
op_star
)paren
(paren
id|v
op_plus
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
DECL|function|iounmap
r_void
id|iounmap
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
OG
id|high_memory
op_logical_and
(paren
r_int
r_int
)paren
id|addr
OL
id|ioremap_bot
)paren
id|vfree
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|PAGE_MASK
op_amp
(paren
r_int
r_int
)paren
id|addr
)paren
)paren
suffix:semicolon
)brace
DECL|function|iopa
r_int
r_int
id|iopa
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|pa
suffix:semicolon
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
multiline_comment|/* Check the BATs */
id|pa
op_assign
id|v_mapped_by_bats
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pa
)paren
r_return
id|pa
suffix:semicolon
multiline_comment|/* Do we have a page table? */
r_if
c_cond
(paren
id|init_mm.pgd
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use upper 10 bits of addr to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|init_mm.pgd
op_plus
(paren
id|addr
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use middle 10 bits of addr to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|addr
)paren
suffix:semicolon
r_return
(paren
id|pte_val
c_func
(paren
op_star
id|pg
)paren
op_amp
id|PAGE_MASK
)paren
op_or
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
)brace
r_void
DECL|function|map_page
id|map_page
c_func
(paren
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pd
comma
id|oldpd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
multiline_comment|/* Use upper 10 bits of VA to index the first level map */
id|pd
op_assign
id|pmd_offset
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|va
)paren
comma
id|va
)paren
suffix:semicolon
id|oldpd
op_assign
op_star
id|pd
suffix:semicolon
multiline_comment|/* Use middle 10 bits of VA to index the second-level map */
id|pg
op_assign
id|pte_alloc
c_func
(paren
id|pd
comma
id|va
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
id|oldpd
)paren
op_logical_and
id|mem_init_done
)paren
id|set_pgdir
c_func
(paren
id|va
comma
op_star
(paren
id|pgd_t
op_star
)paren
id|pd
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg
comma
id|mk_pte_phys
c_func
(paren
id|pa
op_amp
id|PAGE_MASK
comma
id|__pgprot
c_func
(paren
id|flags
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|va
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_8xx
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(mm, start, end) flushes a range of pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * Flush all tlb/hash table entries (except perhaps for those&n; * mapping RAM starting at PAGE_OFFSET, since they never change).&n; */
r_void
DECL|function|local_flush_tlb_all
id|local_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_PPC64BRIDGE
multiline_comment|/* XXX this assumes that the vmalloc arena starts no lower than&n;&t; * 0xd0000000 on 64-bit machines. */
id|flush_hash_segments
c_func
(paren
l_int|0xd
comma
l_int|0xffffff
)paren
suffix:semicolon
macro_line|#else
id|__clear_user
c_func
(paren
id|Hash
comma
id|Hash_size
)paren
suffix:semicolon
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
macro_line|#endif /* CONFIG_PPC64BRIDGE */
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
r_void
DECL|function|local_flush_tlb_mm
id|local_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
id|activate_mm
c_func
(paren
id|mm
comma
id|mm
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
r_void
DECL|function|local_flush_tlb_page
id|local_flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_if
c_cond
(paren
id|vmaddr
OL
id|TASK_SIZE
)paren
id|flush_hash_page
c_func
(paren
id|vma-&gt;vm_mm-&gt;context
comma
id|vmaddr
)paren
suffix:semicolon
r_else
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|vmaddr
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; * for each page addr in the range, call MMU_invalidate_page()&n; * if the range is very large and the hash table is small it might be&n; * faster to do a search of the hash table and just invalidate pages&n; * that are in the range but that&squot;s for study later.&n; * -- Cort&n; */
r_void
DECL|function|local_flush_tlb_range
id|local_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
OG
l_int|20
op_star
id|PAGE_SIZE
)paren
(brace
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
op_logical_and
id|start
OL
id|TASK_SIZE
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|flush_hash_page
c_func
(paren
id|mm-&gt;context
comma
id|start
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; * The context counter has overflowed.&n; * We set mm-&gt;context to NO_CONTEXT for all mm&squot;s in the system.&n; * We assume we can get to all mm&squot;s by looking as tsk-&gt;mm for&n; * all tasks in the system.&n; */
r_void
DECL|function|mmu_context_overflow
id|mmu_context_overflow
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmu_context_overflow&bslash;n&quot;
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
id|tsk-&gt;mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|flush_hash_segments
c_func
(paren
l_int|0x10
comma
l_int|0xffffff
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;
id|atomic_set
c_func
(paren
op_amp
id|next_mmu_context
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* make sure current always has a context */
id|current-&gt;mm-&gt;context
op_assign
id|MUNGE_CONTEXT
c_func
(paren
id|atomic_inc_return
c_func
(paren
op_amp
id|next_mmu_context
)paren
)paren
suffix:semicolon
multiline_comment|/* The PGD is only a placeholder.  It is only used on&n;&t; * 8xx processors.&n;&t; */
id|set_context
c_func
(paren
id|current-&gt;mm-&gt;context
comma
id|current-&gt;mm-&gt;pgd
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_8xx */
DECL|function|flush_page_to_ram
r_void
id|flush_page_to_ram
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
r_int
r_int
)paren
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|__flush_page_to_ram
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
macro_line|#if !defined(CONFIG_4xx) &amp;&amp; !defined(CONFIG_8xx)
r_static
r_void
id|get_mem_prop
c_func
(paren
r_char
op_star
comma
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_ALL_PPC)
multiline_comment|/*&n; * Read in a property describing some pieces of memory.&n; */
DECL|function|get_mem_prop
r_static
r_void
id|__init
id|get_mem_prop
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_int
id|s
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|memory_node
comma
id|name
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;error: couldn&squot;t get %s property on /memory&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|s
op_div
r_sizeof
(paren
id|mp-&gt;regions
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mp-&gt;regions
comma
id|rp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* Make sure the pieces are sorted. */
id|mem_pieces_sort
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mem_pieces_coalesce
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ALL_PPC */
multiline_comment|/*&n; * Set up one of the I/D BAT (block address translation) register pairs.&n; * The parameters are not checked; in particular size must be a power&n; * of 2 between 128k and 256M.&n; */
DECL|function|setbat
r_void
id|__init
id|setbat
c_func
(paren
r_int
id|index
comma
r_int
r_int
id|virt
comma
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|bl
suffix:semicolon
r_int
id|wimgxpp
suffix:semicolon
r_union
id|ubat
op_star
id|bat
op_assign
id|BATS
(braket
id|index
)braket
suffix:semicolon
id|bl
op_assign
(paren
id|size
op_rshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* 603, 604, etc. */
multiline_comment|/* Do DBAT first */
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
op_or
id|_PAGE_GUARDED
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
id|BPP_RW
suffix:colon
id|BPP_RX
suffix:semicolon
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
(paren
id|bl
op_lshift
l_int|2
)paren
op_or
l_int|2
suffix:semicolon
multiline_comment|/* Vs=1, Vp=0 */
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|wimgxpp
suffix:semicolon
macro_line|#ifndef CONFIG_KGDB /* want user access for breakpoints */
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
macro_line|#endif
id|bat
(braket
l_int|1
)braket
dot
id|bat.batu.vp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_GUARDED
)paren
(brace
multiline_comment|/* G bit must be zero in IBATs */
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make IBAT same as DBAT */
id|bat
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|1
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 601 cpu */
r_if
c_cond
(paren
id|bl
OG
id|BL_8M
)paren
id|bl
op_assign
id|BL_8M
suffix:semicolon
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
(paren
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
ques
c_cond
id|PP_RWRW
suffix:colon
id|PP_RWXX
)paren
suffix:colon
id|PP_RXRX
suffix:semicolon
id|bat-&gt;word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
id|wimgxpp
op_or
l_int|4
suffix:semicolon
multiline_comment|/* Ks=0, Ku=1 */
id|bat-&gt;word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|bl
op_or
l_int|0x40
suffix:semicolon
multiline_comment|/* V=1 */
)brace
id|bat_addrs
(braket
id|index
)braket
dot
id|start
op_assign
id|virt
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|limit
op_assign
id|virt
op_plus
(paren
(paren
id|bl
op_plus
l_int|1
)paren
op_lshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|phys
op_assign
id|phys
suffix:semicolon
)brace
DECL|macro|IO_PAGE
mdefine_line|#define IO_PAGE&t;(_PAGE_NO_CACHE | _PAGE_GUARDED | _PAGE_RW)
macro_line|#ifdef CONFIG_SMP
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_RW|_PAGE_COHERENT)
macro_line|#else
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_RW)
macro_line|#endif
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/*&n; * Map in all of physical memory starting at KERNELBASE.&n; */
DECL|macro|PAGE_KERNEL_RO
mdefine_line|#define PAGE_KERNEL_RO&t;__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
DECL|function|mapin_ram
r_static
r_void
id|__init
id|mapin_ram
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|v
comma
id|p
comma
id|s
comma
id|f
suffix:semicolon
macro_line|#if !defined(CONFIG_4xx) &amp;&amp; !defined(CONFIG_8xx) &amp;&amp; !defined(CONFIG_POWER4)
r_if
c_cond
(paren
op_logical_neg
id|__map_without_bats
)paren
(brace
r_int
r_int
id|tot
comma
id|mem_base
comma
id|bl
comma
id|done
suffix:semicolon
r_int
r_int
id|max_size
op_assign
(paren
l_int|256
op_lshift
l_int|20
)paren
suffix:semicolon
r_int
r_int
id|align
suffix:semicolon
multiline_comment|/* Set up BAT2 and if necessary BAT3 to cover RAM. */
id|mem_base
op_assign
id|__pa
c_func
(paren
id|KERNELBASE
)paren
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t map a block larger than the&n;&t;&t;   smallest alignment of the physical address. */
multiline_comment|/* alignment of mem_base */
id|align
op_assign
op_complement
(paren
id|mem_base
op_minus
l_int|1
)paren
op_amp
id|mem_base
suffix:semicolon
multiline_comment|/* set BAT block size to MIN(max_size, align) */
r_if
c_cond
(paren
id|align
op_logical_and
id|align
OL
id|max_size
)paren
id|max_size
op_assign
id|align
suffix:semicolon
id|tot
op_assign
id|total_lowmem
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
id|max_size
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
)brace
id|setbat
c_func
(paren
l_int|2
comma
id|KERNELBASE
comma
id|mem_base
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
id|done
op_assign
(paren
r_int
r_int
)paren
id|bat_addrs
(braket
l_int|2
)braket
dot
id|limit
op_minus
id|KERNELBASE
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|done
OL
id|tot
)paren
op_logical_and
op_logical_neg
id|bat_addrs
(braket
l_int|3
)braket
dot
id|limit
)paren
(brace
multiline_comment|/* use BAT3 to cover a bit more */
id|tot
op_sub_assign
id|done
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
id|max_size
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
id|setbat
c_func
(paren
l_int|3
comma
id|KERNELBASE
op_plus
id|done
comma
id|mem_base
op_plus
id|done
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* !CONFIG_4xx &amp;&amp; !CONFIG_8xx &amp;&amp; !CONFIG_POWER4 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|v
op_assign
(paren
id|ulong
)paren
id|__va
c_func
(paren
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|p
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|total_lowmem
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|s
op_add_assign
id|PAGE_SIZE
)paren
(brace
multiline_comment|/* On the MPC8xx, we want the page shared so we&n;                         * don&squot;t get ASID compares on kernel space.&n;                         */
id|f
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
op_or
id|_PAGE_SHARED
suffix:semicolon
macro_line|#if defined(CONFIG_KGDB) || defined(CONFIG_XMON)
multiline_comment|/* Allows stub to set breakpoints everywhere */
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|v
OL
id|_stext
op_logical_or
(paren
r_char
op_star
)paren
id|v
op_ge
id|etext
)paren
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_else
multiline_comment|/* On the powerpc (not 8xx), no user access&n;&t;&t;&t;&t;   forces R/W kernel access */
id|f
op_or_assign
id|_PAGE_USER
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
macro_line|#endif /* CONFIG_KGDB */
id|map_page
c_func
(paren
id|v
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|v
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|total_lowmem
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* In fact this is only called until mem_init is done. */
DECL|function|MMU_get_page
r_static
r_void
id|__init
op_star
id|MMU_get_page
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
id|p
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|init_bootmem_done
)paren
(brace
id|p
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|mem_pieces_find
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get a page in MMU_get_page&quot;
)paren
suffix:semicolon
id|__clear_user
c_func
(paren
id|p
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|free_sec
r_static
r_void
id|free_sec
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|virt_to_page
c_func
(paren
id|start
)paren
op_member_access_from_pointer
id|flags
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|virt_to_page
c_func
(paren
id|start
)paren
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|start
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
)paren
id|printk
c_func
(paren
l_string|&quot; %ldk %s&quot;
comma
id|PGTOKB
c_func
(paren
id|cnt
)paren
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|free_initmem
r_void
id|free_initmem
c_func
(paren
r_void
)paren
(brace
DECL|macro|FREESEC
mdefine_line|#define FREESEC(TYPE) &bslash;&n;&t;free_sec((unsigned long)(&amp;__ ## TYPE ## _begin), &bslash;&n;&t;&t; (unsigned long)(&amp;__ ## TYPE ## _end), &bslash;&n;&t;&t; #TYPE);
id|printk
(paren
l_string|&quot;Freeing unused kernel memory:&quot;
)paren
suffix:semicolon
id|FREESEC
c_func
(paren
id|init
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
id|FREESEC
c_func
(paren
id|pmac
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_chrp
)paren
id|FREESEC
c_func
(paren
id|chrp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_prep
)paren
id|FREESEC
c_func
(paren
id|prep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_apus
)paren
id|FREESEC
c_func
(paren
id|apus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_of
)paren
id|FREESEC
c_func
(paren
id|openfirmware
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
DECL|macro|FREESEC
macro_line|#undef FREESEC
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|free_initrd_mem
r_void
id|free_initrd_mem
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|start
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|virt_to_page
c_func
(paren
id|start
)paren
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|start
)paren
suffix:semicolon
id|totalram_pages
op_increment
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Freeing initrd memory: %ldk freed&bslash;n&quot;
comma
(paren
id|end
op_minus
id|start
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
macro_line|#endif
r_extern
id|boot_infos_t
op_star
id|disp_bi
suffix:semicolon
multiline_comment|/*&n; * Do very early mm setup such as finding the size of memory&n; * and setting up the hash table.&n; * A lot of this is prep/pmac specific but a lot of it could&n; * still be merged.&n; * -- Cort&n; */
macro_line|#if defined(CONFIG_4xx)
r_void
id|__init
DECL|function|MMU_init
id|MMU_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * The Zone Protection Register (ZPR) defines how protection will&n;&t; * be applied to every page which is a member of a given zone. At&n;&t; * present, we utilize only two of the 4xx&squot;s zones. The first, zone&n;&t; * 0, is set at &squot;00b and only allows access in supervisor-mode based&n;&t; * on the EX and WR bits. No user-mode access is allowed. The second,&n;&t; * zone 1, is set at &squot;10b and in supervisor-mode allows access&n;&t; * without regard to the EX and WR bits. In user-mode, access is&n;&t; * allowed based on the EX and WR bits.&n;&t; */
id|mtspr
c_func
(paren
id|SPRN_ZPR
comma
l_int|0x2aaaaaaa
)paren
suffix:semicolon
multiline_comment|/* Hardwire any TLB entries necessary here. */
id|PPC4xx_tlb_pin
c_func
(paren
id|KERNELBASE
comma
l_int|0
comma
id|TLB_PAGESZ
c_func
(paren
id|PAGESZ_16M
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the top of physical memory and map all of it in starting&n;&t; * at KERNELBASE.&n;&t; */
id|total_memory
op_assign
id|total_lowmem
op_assign
id|oak_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
id|end_of_DRAM
op_assign
id|__va
c_func
(paren
id|total_memory
)paren
suffix:semicolon
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the real-mode cache parameters for the exception vector&n;&t; * handlers (which are run in real-mode).&n;&t; */
id|mtspr
c_func
(paren
id|SPRN_DCWR
comma
l_int|0x00000000
)paren
suffix:semicolon
multiline_comment|/* All caching is write-back */
multiline_comment|/*&n;&t; * Cache instruction and data space where the exception&n;&t; * vectors and the kernel live in real-mode.&n;&t; */
id|mtspr
c_func
(paren
id|SPRN_DCCR
comma
l_int|0x80000000
)paren
suffix:semicolon
multiline_comment|/* 128 MB of data space at 0x0. */
id|mtspr
c_func
(paren
id|SPRN_ICCR
comma
l_int|0x80000000
)paren
suffix:semicolon
multiline_comment|/* 128 MB of instr. space at 0x0. */
)brace
macro_line|#else
multiline_comment|/* How about ppc_md.md_find_end_of_memory instead of these&n;&t; * ifdefs?  -- Dan.&n;&t; */
macro_line|#ifdef CONFIG_BOOTX_TEXT
r_extern
id|boot_infos_t
op_star
id|disp_bi
suffix:semicolon
macro_line|#endif
DECL|function|MMU_init
r_void
id|__init
id|MMU_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;MMU:enter&quot;
comma
l_int|0x111
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_if
c_cond
(paren
id|have_of
)paren
id|total_memory
op_assign
id|pmac_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_APUS
r_else
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_apus
)paren
id|total_memory
op_assign
id|apus_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_GEMINI&t;
r_else
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_gemini
)paren
id|total_memory
op_assign
id|gemini_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_GEMINI&t;*/
macro_line|#if defined(CONFIG_8260)
r_else
id|total_memory
op_assign
id|m8260_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
r_else
multiline_comment|/* prep */
id|total_memory
op_assign
id|prep_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|total_lowmem
op_assign
id|total_memory
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
r_if
c_cond
(paren
id|total_lowmem
OG
id|MAX_LOW_MEM
)paren
(brace
id|total_lowmem
op_assign
id|MAX_LOW_MEM
suffix:semicolon
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|total_lowmem
comma
id|total_memory
op_minus
id|total_lowmem
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HIGHMEM */
id|end_of_DRAM
op_assign
id|__va
c_func
(paren
id|total_lowmem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;MMU:hash init&quot;
comma
l_int|0x300
)paren
suffix:semicolon
id|hash_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_PPC64BRIDGE
id|_SDR1
op_assign
id|__pa
c_func
(paren
id|Hash
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
macro_line|#endif
id|ioremap_base
op_assign
l_int|0xf8000000
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;MMU:mapin&quot;
comma
l_int|0x301
)paren
suffix:semicolon
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_POWER4
id|ioremap_base
op_assign
id|ioremap_bot
op_assign
l_int|0xfffff000
suffix:semicolon
id|isa_io_base
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
l_int|0xffd00000
comma
l_int|0x200000
)paren
op_plus
l_int|0x100000
suffix:semicolon
macro_line|#else /* CONFIG_POWER4 */
multiline_comment|/*&n;&t; * Setup the bat mappings we&squot;re going to load that cover&n;&t; * the io areas.  RAM was mapped by mapin_ram().&n;&t; * -- Cort&n;&t; */
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;MMU:setbat&quot;
comma
l_int|0x302
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|_machine
)paren
(brace
r_case
id|_MACH_prep
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0x80000000
comma
l_int|0x80000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|1
comma
l_int|0xf0000000
comma
l_int|0xc0000000
comma
l_int|0x08000000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|ioremap_base
op_assign
l_int|0xf0000000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_chrp
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf8000000
comma
l_int|0xf8000000
comma
l_int|0x08000000
comma
id|IO_PAGE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC64BRIDGE
id|setbat
c_func
(paren
l_int|1
comma
l_int|0x80000000
comma
l_int|0xc0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
macro_line|#else
id|setbat
c_func
(paren
l_int|1
comma
l_int|0x80000000
comma
l_int|0x80000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|3
comma
l_int|0x90000000
comma
l_int|0x90000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|_MACH_Pmac
suffix:colon
id|ioremap_base
op_assign
l_int|0xfe000000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_apus
suffix:colon
multiline_comment|/* Map PPC exception vectors. */
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xfff00000
comma
l_int|0xfff00000
comma
l_int|0x00020000
comma
id|RAM_PAGE
)paren
suffix:semicolon
multiline_comment|/* Map chip and ZorroII memory */
id|setbat
c_func
(paren
l_int|1
comma
id|zTwoBase
comma
l_int|0x00000000
comma
l_int|0x01000000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_gemini
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf0000000
comma
l_int|0xf0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|1
comma
l_int|0x80000000
comma
l_int|0x80000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_8260
suffix:colon
multiline_comment|/* Map the IMMR, plus anything else we can cover&n;&t;&t; * in that upper space according to the memory controller&n;&t;&t; * chip select mapping.  Grab another bunch of space&n;&t;&t; * below that for stuff we can&squot;t cover in the upper.&n;&t;&t; */
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf0000000
comma
l_int|0xf0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|1
comma
l_int|0xe0000000
comma
l_int|0xe0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|ioremap_base
op_assign
l_int|0xe0000000
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ioremap_bot
op_assign
id|ioremap_base
suffix:semicolon
macro_line|#endif /* CONFIG_POWER4 */
macro_line|#else /* CONFIG_8xx */
id|total_memory
op_assign
id|total_lowmem
op_assign
id|m8xx_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
r_if
c_cond
(paren
id|total_lowmem
OG
id|MAX_LOW_MEM
)paren
(brace
id|total_lowmem
op_assign
id|MAX_LOW_MEM
suffix:semicolon
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|total_lowmem
comma
id|total_memory
op_minus
id|total_lowmem
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HIGHMEM */
id|end_of_DRAM
op_assign
id|__va
c_func
(paren
id|total_lowmem
)paren
suffix:semicolon
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now map in some of the I/O space that is generically needed&n;         * or shared with multiple devices.&n;         * All of this fits into the same 4Mbyte region, so it only&n;         * requires one page table page.&n;         */
id|ioremap
c_func
(paren
id|IMAP_ADDR
comma
id|IMAP_SIZE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MBX
id|ioremap
c_func
(paren
id|NVRAM_ADDR
comma
id|NVRAM_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|MBX_CSR_ADDR
comma
id|MBX_CSR_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|PCI_CSR_ADDR
comma
id|PCI_CSR_SIZE
)paren
suffix:semicolon
multiline_comment|/* Map some of the PCI/ISA I/O space to get the IDE interface.&n;&t;*/
id|ioremap
c_func
(paren
id|PCI_ISA_IO_ADDR
comma
l_int|0x4000
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|PCI_IDE_ADDR
comma
l_int|0x4000
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_RPXLITE
id|ioremap
c_func
(paren
id|RPX_CSR_ADDR
comma
id|RPX_CSR_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|HIOX_CSR_ADDR
comma
id|HIOX_CSR_SIZE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_RPXCLASSIC
id|ioremap
c_func
(paren
id|PCI_CSR_ADDR
comma
id|PCI_CSR_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|RPX_CSR_ADDR
comma
id|RPX_CSR_SIZE
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* CONFIG_8xx */
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;MMU:exit&quot;
comma
l_int|0x211
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BOOTX_TEXT
multiline_comment|/* Must be done last, or ppc_md.progress will die */
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_Pmac
op_logical_or
id|_machine
op_eq
id|_MACH_chrp
)paren
id|map_bootx_text
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* CONFIG_4xx */
multiline_comment|/*&n; * Initialize the bootmem system and give it all the memory we&n; * have available.&n; */
DECL|function|do_init_bootmem
r_void
id|__init
id|do_init_bootmem
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|start
comma
id|size
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Find an area to use for the bootmem bitmap.&n;&t; * We look for the first area which is at least&n;&t; * 128kB in length (128kB is enough for a bitmap&n;&t; * for 4GB of memory, using 4kB pages), plus 1 page&n;&t; * (in case the address isn&squot;t page-aligned).&n;&t; */
id|start
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|a
op_assign
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_int
r_int
id|s
op_assign
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|s
op_le
id|size
)paren
r_continue
suffix:semicolon
id|start
op_assign
id|a
suffix:semicolon
id|size
op_assign
id|s
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ge
l_int|33
op_star
id|PAGE_SIZE
)paren
r_break
suffix:semicolon
)brace
id|start
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start
)paren
suffix:semicolon
id|boot_mapsize
op_assign
id|init_bootmem
c_func
(paren
id|start
op_rshift
id|PAGE_SHIFT
comma
id|total_lowmem
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* remove the bootmem bitmap from the available memory */
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|start
comma
id|boot_mapsize
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* add everything in phys_avail into the bootmem map */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
id|free_bootmem
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
comma
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|init_bootmem_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * paging_init() sets up the page tables - in fact we&squot;ve already done this.&n; */
DECL|function|paging_init
r_void
id|__init
id|paging_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|zones_size
(braket
id|MAX_NR_ZONES
)braket
comma
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
id|map_page
c_func
(paren
id|PKMAP_BASE
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* XXX gross */
id|pkmap_page_table
op_assign
id|pte_offset
c_func
(paren
id|pmd_offset
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|PKMAP_BASE
)paren
comma
id|PKMAP_BASE
)paren
comma
id|PKMAP_BASE
)paren
suffix:semicolon
id|map_page
c_func
(paren
id|KMAP_FIX_BEGIN
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* XXX gross */
id|kmap_pte
op_assign
id|pte_offset
c_func
(paren
id|pmd_offset
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|KMAP_FIX_BEGIN
)paren
comma
id|KMAP_FIX_BEGIN
)paren
comma
id|KMAP_FIX_BEGIN
)paren
suffix:semicolon
id|kmap_prot
op_assign
id|PAGE_KERNEL
suffix:semicolon
macro_line|#endif /* CONFIG_HIGHMEM */
multiline_comment|/*&n;&t; * Grab some memory for bad_page and bad_pagetable to use.&n;&t; */
id|empty_bad_page
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|empty_bad_page_table
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * All pages are DMA-able so we put them all in the DMA zone.&n;&t; */
id|zones_size
(braket
id|ZONE_DMA
)braket
op_assign
id|total_lowmem
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|zones_size
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
id|zones_size
(braket
id|ZONE_HIGHMEM
)braket
op_assign
(paren
id|total_memory
op_minus
id|total_lowmem
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
macro_line|#endif /* CONFIG_HIGHMEM */
id|free_area_init
c_func
(paren
id|zones_size
)paren
suffix:semicolon
)brace
DECL|function|mem_init
r_void
id|__init
id|mem_init
c_func
(paren
r_void
)paren
(brace
r_extern
r_char
op_star
id|sysmap
suffix:semicolon
r_extern
r_int
r_int
id|sysmap_size
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_int
id|codepages
op_assign
l_int|0
suffix:semicolon
r_int
id|datapages
op_assign
l_int|0
suffix:semicolon
r_int
id|initpages
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
r_int
r_int
id|highmem_mapnr
suffix:semicolon
id|highmem_mapnr
op_assign
id|total_lowmem
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|highmem_start_page
op_assign
id|mem_map
op_plus
id|highmem_mapnr
suffix:semicolon
id|max_mapnr
op_assign
id|total_memory
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|totalram_pages
op_add_assign
id|max_mapnr
op_minus
id|highmem_mapnr
suffix:semicolon
macro_line|#else
id|max_mapnr
op_assign
id|max_low_pfn
suffix:semicolon
macro_line|#endif /* CONFIG_HIGHMEM */
id|high_memory
op_assign
(paren
r_void
op_star
)paren
id|__va
c_func
(paren
id|max_low_pfn
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|num_physpages
op_assign
id|max_mapnr
suffix:semicolon
multiline_comment|/* RAM is assumed contiguous */
id|totalram_pages
op_add_assign
id|free_all_bootmem
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
multiline_comment|/* if we are booted from BootX with an initial ramdisk,&n;&t;   make sure the ramdisk pages aren&squot;t reserved. */
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
r_for
c_loop
(paren
id|addr
op_assign
id|initrd_start
suffix:semicolon
id|addr
OL
id|initrd_end
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|virt_to_page
c_func
(paren
id|addr
)paren
op_member_access_from_pointer
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
macro_line|#if defined(CONFIG_ALL_PPC)&t;
multiline_comment|/* mark the RTAS pages as reserved */
r_if
c_cond
(paren
id|rtas_data
)paren
r_for
c_loop
(paren
id|addr
op_assign
id|rtas_data
suffix:semicolon
id|addr
OL
id|PAGE_ALIGN
c_func
(paren
id|rtas_data
op_plus
id|rtas_size
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
id|SetPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
macro_line|#endif /* defined(CONFIG_ALL_PPC) */
r_if
c_cond
(paren
id|sysmap_size
)paren
r_for
c_loop
(paren
id|addr
op_assign
(paren
r_int
r_int
)paren
id|sysmap
suffix:semicolon
id|addr
OL
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|sysmap
op_plus
id|sysmap_size
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
id|SetPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|addr
OL
(paren
r_int
r_int
)paren
id|end_of_DRAM
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|etext
)paren
id|codepages
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|__init_begin
op_logical_and
id|addr
OL
(paren
r_int
r_int
)paren
op_amp
id|__init_end
)paren
id|initpages
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|klimit
)paren
id|datapages
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HIGHMEM
(brace
r_int
r_int
id|pfn
suffix:semicolon
r_for
c_loop
(paren
id|pfn
op_assign
id|highmem_mapnr
suffix:semicolon
id|pfn
OL
id|max_mapnr
suffix:semicolon
op_increment
id|pfn
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|mem_map
op_plus
id|pfn
suffix:semicolon
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_highmem
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|page-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|totalhigh_pages
op_increment
suffix:semicolon
)brace
id|totalram_pages
op_add_assign
id|totalhigh_pages
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HIGHMEM */
id|printk
c_func
(paren
l_string|&quot;Memory: %luk available (%dk kernel code, %dk data, %dk init, %ldk highmem)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|nr_free_pages
c_func
(paren
)paren
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|codepages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|datapages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|initpages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
(paren
r_int
r_int
)paren
(paren
id|totalhigh_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
)paren
suffix:semicolon
id|mem_init_done
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if !defined(CONFIG_4xx) &amp;&amp; !defined(CONFIG_8xx)
macro_line|#if defined(CONFIG_ALL_PPC)
multiline_comment|/*&n; * On systems with Open Firmware, collect information about&n; * physical RAM and which pieces are already in use.&n; * At this point, we have (at least) the first 8MB mapped with a BAT.&n; * Our text, data, bss use something over 1MB, starting at 0.&n; * Open Firmware may be using 1MB at the 4MB point.&n; */
DECL|function|pmac_find_end_of_memory
r_int
r_int
id|__init
id|pmac_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|a
comma
id|total
suffix:semicolon
r_int
r_int
id|ram_limit
op_assign
l_int|0xe0000000
op_minus
id|KERNELBASE
suffix:semicolon
id|memory_node
op_assign
id|find_devices
c_func
(paren
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memory_node
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;can&squot;t find memory node&bslash;n&quot;
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find out where physical memory is, and check that it&n;&t; * starts at 0 and is contiguous.  It seems that RAM is&n;&t; * always physically contiguous on Power Macintoshes,&n;&t; * because MacOS can&squot;t cope if it isn&squot;t.&n;&t; *&n;&t; * Supporting discontiguous physical memory isn&squot;t hard,&n;&t; * it just makes the virtual &lt;-&gt; physical mapping functions&n;&t; * more complicated (or else you end up wasting space&n;&t; * in mem_map).&n;&t; */
id|get_mem_prop
c_func
(paren
l_string|&quot;reg&quot;
comma
op_amp
id|phys_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.n_regions
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;No RAM??&quot;
)paren
suffix:semicolon
id|a
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_if
c_cond
(paren
id|a
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;RAM doesn&squot;t start at physical address 0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__max_memory
op_eq
l_int|0
op_logical_or
id|__max_memory
OG
id|ram_limit
)paren
id|__max_memory
op_assign
id|ram_limit
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_ge
id|__max_memory
)paren
(brace
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_assign
id|__max_memory
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
)brace
id|total
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.n_regions
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAM starting at 0x%x is not contiguous&bslash;n&quot;
comma
id|phys_mem.regions
(braket
l_int|1
)braket
dot
id|address
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using RAM from 0 to 0x%lx&bslash;n&quot;
comma
id|total
op_minus
l_int|1
)paren
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
)brace
id|set_phys_avail
c_func
(paren
op_amp
id|phys_mem
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ALL_PPC */
macro_line|#if defined(CONFIG_ALL_PPC)
multiline_comment|/*&n; * This finds the amount of physical ram and does necessary&n; * setup for prep.  This is pretty architecture specific so&n; * this will likely stay separate from the pmac.&n; * -- Cort&n; */
DECL|function|prep_find_end_of_memory
r_int
r_int
id|__init
id|prep_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|total
suffix:semicolon
id|total
op_assign
id|res-&gt;TotalMemory
suffix:semicolon
r_if
c_cond
(paren
id|total
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * I need a way to probe the amount of memory if the residual&n;&t;&t; * data doesn&squot;t contain it. -- Cort&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Ramsize from residual data was 0 -- Probing for value&bslash;n&quot;
)paren
suffix:semicolon
id|total
op_assign
l_int|0x02000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ramsize default to be %ldM&bslash;n&quot;
comma
id|total
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
id|mem_pieces_append
c_func
(paren
op_amp
id|phys_mem
comma
l_int|0
comma
id|total
)paren
suffix:semicolon
id|set_phys_avail
c_func
(paren
op_amp
id|phys_mem
)paren
suffix:semicolon
r_return
(paren
id|total
)paren
suffix:semicolon
)brace
macro_line|#endif /* defined(CONFIG_ALL_PPC) */
macro_line|#if defined(CONFIG_GEMINI)
DECL|function|gemini_find_end_of_memory
r_int
r_int
id|__init
id|gemini_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|total
suffix:semicolon
r_int
r_char
id|reg
suffix:semicolon
id|reg
op_assign
id|readb
c_func
(paren
id|GEMINI_MEMCFG
)paren
suffix:semicolon
id|total
op_assign
(paren
(paren
l_int|1
op_lshift
(paren
(paren
id|reg
op_amp
l_int|0x7
)paren
op_minus
l_int|1
)paren
)paren
op_star
(paren
l_int|8
op_lshift
(paren
(paren
id|reg
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
)paren
)paren
)paren
suffix:semicolon
id|total
op_mul_assign
(paren
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_assign
id|total
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
id|set_phys_avail
c_func
(paren
op_amp
id|phys_mem
)paren
suffix:semicolon
r_return
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
)brace
macro_line|#endif /* defined(CONFIG_GEMINI) */
macro_line|#ifdef CONFIG_8260
multiline_comment|/*&n; * Same hack as 8xx.&n; */
DECL|function|m8260_find_end_of_memory
r_int
r_int
id|__init
id|m8260_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
id|bd_t
op_star
id|binfo
suffix:semicolon
r_extern
r_int
r_char
id|__res
(braket
)braket
suffix:semicolon
id|binfo
op_assign
(paren
id|bd_t
op_star
)paren
id|__res
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_assign
id|binfo-&gt;bi_memsize
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
id|set_phys_avail
c_func
(paren
op_amp
id|phys_mem
)paren
suffix:semicolon
r_return
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_8260 */
macro_line|#ifdef CONFIG_APUS
DECL|macro|HARDWARE_MAPPED_SIZE
mdefine_line|#define HARDWARE_MAPPED_SIZE (512*1024)
DECL|function|apus_find_end_of_memory
r_int
r_int
id|__init
id|apus_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
id|shadow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The memory size reported by ADOS excludes the 512KB&n;&t;   reserved for PPC exception registers and possibly 512KB&n;&t;   containing a shadow of the ADOS ROM. */
(brace
r_int
r_int
id|size
op_assign
id|memory
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
multiline_comment|/* If 2MB aligned, size was probably user&n;                   specified. We can&squot;t tell anything about shadowing&n;                   in this case so skip shadow assignment. */
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|size
op_amp
l_int|0x1fffff
)paren
)paren
(brace
multiline_comment|/* Align to 512KB to ensure correct handling&n;&t;&t;&t;   of both memfile and system specified&n;&t;&t;&t;   sizes. */
id|size
op_assign
(paren
(paren
id|size
op_plus
l_int|0x0007ffff
)paren
op_amp
l_int|0xfff80000
)paren
suffix:semicolon
multiline_comment|/* If memory is 1MB aligned, assume&n;                           shadowing. */
id|shadow
op_assign
op_logical_neg
(paren
id|size
op_amp
l_int|0x80000
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the chunk that ADOS does not see. by aligning&n;                   the size to the nearest 2MB limit upwards.  */
id|memory
(braket
l_int|0
)braket
dot
id|size
op_assign
(paren
(paren
id|size
op_plus
l_int|0x001fffff
)paren
op_amp
l_int|0xffe00000
)paren
suffix:semicolon
)brace
multiline_comment|/* Now register the memory block. */
id|mem_pieces_append
c_func
(paren
op_amp
id|phys_mem
comma
id|memory
(braket
l_int|0
)braket
dot
id|addr
comma
id|memory
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
id|set_phys_avail
c_func
(paren
op_amp
id|phys_mem
)paren
suffix:semicolon
multiline_comment|/* Remove the memory chunks that are controlled by special&n;           Phase5 hardware. */
(brace
r_int
r_int
id|top
op_assign
id|memory
(braket
l_int|0
)braket
dot
id|addr
op_plus
id|memory
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
multiline_comment|/* Remove the upper 512KB if it contains a shadow of&n;&t;&t;   the ADOS ROM. FIXME: It might be possible to&n;&t;&t;   disable this shadow HW. Check the booter&n;&t;&t;   (ppc_boot.c) */
r_if
c_cond
(paren
id|shadow
)paren
(brace
id|top
op_sub_assign
id|HARDWARE_MAPPED_SIZE
suffix:semicolon
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|top
comma
id|HARDWARE_MAPPED_SIZE
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove the upper 512KB where the PPC exception&n;                   vectors are mapped. */
id|top
op_sub_assign
id|HARDWARE_MAPPED_SIZE
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This would be neat, but it breaks on A3000 machines!? */
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|top
comma
l_int|16384
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|top
comma
id|HARDWARE_MAPPED_SIZE
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Linux/APUS only handles one block of memory -- the one on&n;&t;   the PowerUP board. Other system memory is horrible slow in&n;&t;   comparison. The user can use other memory for swapping&n;&t;   using the z2ram device. */
r_return
id|memory
(braket
l_int|0
)braket
dot
id|addr
op_plus
id|memory
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_APUS */
multiline_comment|/*&n; * Initialize the hash table and patch the instructions in head.S.&n; */
DECL|function|hash_init
r_static
r_void
id|__init
id|hash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|Hash_bits
comma
id|mb
comma
id|mb2
suffix:semicolon
r_int
r_int
id|hmask
comma
id|ramsize
comma
id|h
suffix:semicolon
r_extern
r_int
r_int
id|hash_page_patch_A
(braket
)braket
comma
id|hash_page_patch_B
(braket
)braket
comma
id|hash_page_patch_C
(braket
)braket
comma
id|hash_page
(braket
)braket
suffix:semicolon
id|ramsize
op_assign
(paren
id|ulong
)paren
id|end_of_DRAM
op_minus
id|KERNELBASE
suffix:semicolon
macro_line|#ifdef CONFIG_PPC64BRIDGE
multiline_comment|/* The hash table has already been allocated and initialized&n;&t;   in prom.c */
id|Hash_mask
op_assign
(paren
id|Hash_size
op_rshift
l_int|7
)paren
op_minus
l_int|1
suffix:semicolon
id|hmask
op_assign
id|Hash_mask
op_rshift
l_int|9
suffix:semicolon
id|Hash_bits
op_assign
id|__ilog2
c_func
(paren
id|Hash_size
)paren
op_minus
l_int|7
suffix:semicolon
id|mb
op_assign
l_int|25
op_minus
id|Hash_bits
suffix:semicolon
r_if
c_cond
(paren
id|Hash_bits
OG
l_int|16
)paren
id|Hash_bits
op_assign
l_int|16
suffix:semicolon
id|mb2
op_assign
l_int|25
op_minus
id|Hash_bits
suffix:semicolon
macro_line|#else /* CONFIG_PPC64BRIDGE */
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;hash:enter&quot;
comma
l_int|0x105
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allow 64k of hash table for every 16MB of memory,&n;&t; * up to a maximum of 2MB.&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|64
op_lshift
l_int|10
suffix:semicolon
id|h
OL
id|ramsize
op_div
l_int|256
op_logical_and
id|h
OL
(paren
l_int|2
op_lshift
l_int|20
)paren
suffix:semicolon
id|h
op_mul_assign
l_int|2
)paren
suffix:semicolon
id|Hash_size
op_assign
id|h
suffix:semicolon
id|Hash_mask
op_assign
(paren
id|h
op_rshift
l_int|6
)paren
op_minus
l_int|1
suffix:semicolon
id|hmask
op_assign
id|Hash_mask
op_rshift
l_int|10
suffix:semicolon
id|Hash_bits
op_assign
id|__ilog2
c_func
(paren
id|h
)paren
op_minus
l_int|6
suffix:semicolon
id|mb
op_assign
l_int|26
op_minus
id|Hash_bits
suffix:semicolon
r_if
c_cond
(paren
id|Hash_bits
OG
l_int|16
)paren
id|Hash_bits
op_assign
l_int|16
suffix:semicolon
id|mb2
op_assign
l_int|26
op_minus
id|Hash_bits
suffix:semicolon
multiline_comment|/* shrink the htab since we don&squot;t use it on 603&squot;s -- Cort */
r_switch
c_cond
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
(brace
r_case
l_int|3
suffix:colon
multiline_comment|/* 603 */
r_case
l_int|6
suffix:colon
multiline_comment|/* 603e */
r_case
l_int|7
suffix:colon
multiline_comment|/* 603ev */
r_case
l_int|0x0081
suffix:colon
multiline_comment|/* 82xx */
id|Hash_size
op_assign
l_int|0
suffix:semicolon
id|Hash_mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* on 601/4 let things be */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;hash:find piece&quot;
comma
l_int|0x322
)paren
suffix:semicolon
multiline_comment|/* Find some memory for the hash table. */
r_if
c_cond
(paren
id|Hash_size
)paren
(brace
id|Hash
op_assign
id|mem_pieces_find
c_func
(paren
id|Hash_size
comma
id|Hash_size
)paren
suffix:semicolon
id|cacheable_memzero
c_func
(paren
id|Hash
comma
id|Hash_size
)paren
suffix:semicolon
)brace
r_else
id|Hash
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_PPC64BRIDGE */
id|printk
c_func
(paren
l_string|&quot;Total memory = %dMB; using %ldkB for hash table (at %p)&bslash;n&quot;
comma
id|ramsize
op_rshift
l_int|20
comma
id|Hash_size
op_rshift
l_int|10
comma
id|Hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Hash_size
)paren
(brace
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;hash:patch&quot;
comma
l_int|0x345
)paren
suffix:semicolon
id|Hash_end
op_assign
(paren
id|PTE
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|Hash
op_plus
id|Hash_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Patch up the instructions in head.S:hash_page&n;&t;&t; */
id|hash_page_patch_A
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|__pa
c_func
(paren
id|Hash
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|1
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
id|mb
op_lshift
l_int|6
)paren
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|2
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|2
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
id|mb2
op_lshift
l_int|6
)paren
suffix:semicolon
id|hash_page_patch_B
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_B
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
id|hmask
suffix:semicolon
id|hash_page_patch_C
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_C
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
id|hmask
suffix:semicolon
macro_line|#if 0&t;/* see hash_page in head.S, note also patch_C ref below */
id|hash_page_patch_D
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_D
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
id|hmask
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Ensure that the locations we&squot;ve patched have been written&n;&t;&t; * out from the data cache and invalidated in the instruction&n;&t;&t; * cache, on those machines with split caches.&n;&t;&t; */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|hash_page_patch_A
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
)paren
op_amp
id|hash_page_patch_C
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|Hash_end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put a blr (procedure return) instruction at the&n;&t;&t; * start of hash_page, since we can still get DSI&n;&t;&t; * exceptions on a 603.&n;&t;&t; */
id|hash_page
(braket
l_int|0
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|hash_page
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
)paren
op_amp
id|hash_page
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;hash:done&quot;
comma
l_int|0x205
)paren
suffix:semicolon
)brace
macro_line|#elif defined(CONFIG_8xx)
multiline_comment|/*&n; * This is a big hack right now, but it may turn into something real&n; * someday.&n; *&n; * For the 8xx boards (at this time anyway), there is nothing to initialize&n; * associated the PROM.  Rather than include all of the prom.c&n; * functions in the image just to get prom_init, all we really need right&n; * now is the initialization of the physical memory region.&n; */
DECL|function|m8xx_find_end_of_memory
r_int
r_int
id|__init
id|m8xx_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
id|bd_t
op_star
id|binfo
suffix:semicolon
r_extern
r_int
r_char
id|__res
(braket
)braket
suffix:semicolon
id|binfo
op_assign
(paren
id|bd_t
op_star
)paren
id|__res
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_assign
id|binfo-&gt;bi_memsize
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
id|set_phys_avail
c_func
(paren
op_amp
id|phys_mem
)paren
suffix:semicolon
r_return
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_plus
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_4xx &amp;&amp; !CONFIG_8xx */
macro_line|#ifdef CONFIG_OAK
multiline_comment|/*&n; * Return the virtual address representing the top of physical RAM&n; * on the Oak board.&n; */
r_int
r_int
id|__init
DECL|function|oak_find_end_of_memory
id|oak_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
r_char
id|__res
(braket
)braket
suffix:semicolon
r_int
r_int
op_star
id|ret
suffix:semicolon
id|bd_t
op_star
id|bip
op_assign
(paren
id|bd_t
op_star
)paren
id|__res
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_assign
id|bip-&gt;bi_memsize
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
id|set_phys_avail
c_func
(paren
op_amp
id|phys_mem
)paren
suffix:semicolon
r_return
(paren
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_plus
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Set phys_avail to phys_mem less the kernel text/data/bss.&n; */
r_void
id|__init
DECL|function|set_phys_avail
id|set_phys_avail
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
multiline_comment|/*&n;&t; * Initially, available phyiscal memory is equivalent to all&n;&t; * physical memory.&n;&t; */
id|phys_avail
op_assign
op_star
id|mp
suffix:semicolon
multiline_comment|/*&n;&t; * Map out the kernel text/data/bss from the available physical&n;&t; * memory.&n;&t; */
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|klimit
op_minus
id|_stext
)paren
suffix:semicolon
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
l_int|0
comma
l_int|0x4000
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_INITRD)
multiline_comment|/* Remove the init RAM disk from the available memory. */
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|__pa
c_func
(paren
id|initrd_start
)paren
comma
id|initrd_end
op_minus
id|initrd_start
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
macro_line|#ifdef CONFIG_ALL_PPC
multiline_comment|/* remove the RTAS pages from the available memory */
r_if
c_cond
(paren
id|rtas_data
)paren
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|rtas_data
comma
id|rtas_size
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_ALL_PPC */
macro_line|#ifdef CONFIG_PPC64BRIDGE
multiline_comment|/* Remove the hash table from the available memory */
r_if
c_cond
(paren
id|Hash
)paren
id|mem_pieces_remove
c_func
(paren
op_amp
id|phys_avail
comma
id|__pa
c_func
(paren
id|Hash
)paren
comma
id|Hash_size
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PPC64BRIDGE */
)brace
eof
