multiline_comment|/*&n; *  $Id: init.c,v 1.94 1998/05/06 02:07:36 paulus Exp $&n; *&n; *  PowerPC version &n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)&n; *  and Cort Dougan (PReP) (cort@cs.nmt.edu)&n; *    Copyright (C) 1996 Paul Mackerras&n; *  Amiga/APUS changes by Jesper Skov (jskov@cygnus.co.uk).&n; *&n; *  Derived from &quot;arch/i386/mm/init.c&quot;&n; *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
macro_line|#include &lt;linux/blk.h&gt;&t;&t;/* for initrd_* */
macro_line|#endif
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_8xx
macro_line|#include &lt;asm/8xx_immap.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_MBX
macro_line|#include &lt;asm/mbx.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_APUS /* ifdef APUS specific stuff until the merge is completed. -jskov */
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#endif
DECL|variable|prom_trashed
r_int
id|prom_trashed
suffix:semicolon
DECL|variable|next_mmu_context
r_int
id|next_mmu_context
suffix:semicolon
DECL|variable|end_of_DRAM
r_int
r_int
op_star
id|end_of_DRAM
suffix:semicolon
DECL|variable|mem_init_done
r_int
id|mem_init_done
suffix:semicolon
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
)braket
suffix:semicolon
r_extern
r_char
id|_start
(braket
)braket
comma
id|_end
(braket
)braket
suffix:semicolon
r_extern
r_char
id|etext
(braket
)braket
comma
id|_stext
(braket
)braket
suffix:semicolon
r_extern
r_char
id|__init_begin
comma
id|__init_end
suffix:semicolon
r_extern
r_char
id|__prep_begin
comma
id|__prep_end
suffix:semicolon
r_extern
r_char
id|__pmac_begin
comma
id|__pmac_end
suffix:semicolon
r_extern
r_char
id|__openfirmware_begin
comma
id|__openfirmware_end
suffix:semicolon
r_extern
id|RESIDUAL
id|res
suffix:semicolon
DECL|variable|klimit
r_char
op_star
id|klimit
op_assign
id|_end
suffix:semicolon
DECL|variable|memory_node
r_struct
id|device_node
op_star
id|memory_node
suffix:semicolon
DECL|variable|ioremap_base
r_int
r_int
id|ioremap_base
suffix:semicolon
DECL|variable|ioremap_bot
r_int
r_int
id|ioremap_bot
suffix:semicolon
DECL|variable|avail_start
r_int
r_int
id|avail_start
suffix:semicolon
macro_line|#ifndef __SMP__
DECL|variable|quicklists
r_struct
id|pgtable_cache_struct
id|quicklists
suffix:semicolon
macro_line|#endif
r_void
id|MMU_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|MMU_get_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
op_star
id|prep_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
op_star
id|pmac_find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
op_star
id|find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mapin_ram
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|show_net_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|current_set
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
DECL|variable|_SDR1
r_int
r_int
id|_SDR1
suffix:semicolon
DECL|variable|Hash
DECL|variable|Hash_end
id|PTE
op_star
id|Hash
comma
op_star
id|Hash_end
suffix:semicolon
DECL|variable|Hash_size
DECL|variable|Hash_mask
r_int
r_int
id|Hash_size
comma
id|Hash_mask
suffix:semicolon
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|union|ubat
r_union
id|ubat
(brace
multiline_comment|/* BAT register values to be loaded */
DECL|member|bat
id|BAT
id|bat
suffix:semicolon
DECL|member|bat_601
id|P601_BAT
id|bat_601
suffix:semicolon
DECL|member|word
id|u32
id|word
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|BATS
)brace
id|BATS
(braket
l_int|4
)braket
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* 4 pairs of IBAT, DBAT */
DECL|struct|batrange
r_struct
id|batrange
(brace
multiline_comment|/* stores address ranges mapped by BATs */
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
DECL|member|phys
r_int
r_int
id|phys
suffix:semicolon
DECL|variable|bat_addrs
)brace
id|bat_addrs
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
macro_line|#ifdef CONFIG_MBX
r_void
id|set_mbx_memory
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_MBX */
multiline_comment|/*&n; * this tells the system to map all of ram with the segregs&n; * (i.e. page tables) instead of the bats.&n; * -- Cort&n; */
DECL|macro|MAP_RAM_WITH_SEGREGS
macro_line|#undef MAP_RAM_WITH_SEGREGS 1
multiline_comment|/* optimization for 603 to load the tlb directly from the linux table -- Cort */
DECL|macro|NO_RELOAD_HTAB
mdefine_line|#define NO_RELOAD_HTAB 1 /* change in kernel/head.S too! */
DECL|function|__bad_pte
r_void
id|__bad_pte
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
)brace
DECL|function|get_pte_slow
id|pte_t
op_star
id|get_pte_slow
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|offset
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
(paren
id|pte_t
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|pte
)paren
(brace
id|clear_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pte
suffix:semicolon
r_return
id|pte
op_plus
id|offset
suffix:semicolon
)brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|__bad_pte
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|offset
suffix:semicolon
)brace
DECL|function|do_check_pgt_cache
r_int
id|do_check_pgt_cache
c_func
(paren
r_int
id|low
comma
r_int
id|high
)paren
(brace
r_int
id|freed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pgtable_cache_size
OG
id|high
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|pgd_quicklist
)paren
(brace
id|free_pgd_slow
c_func
(paren
id|get_pgd_fast
c_func
(paren
)paren
)paren
comma
id|freed
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_quicklist
)paren
(brace
id|free_pmd_slow
c_func
(paren
id|get_pmd_fast
c_func
(paren
)paren
)paren
comma
id|freed
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pte_quicklist
)paren
(brace
id|free_pte_slow
c_func
(paren
id|get_pte_fast
c_func
(paren
)paren
)paren
comma
id|freed
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|pgtable_cache_size
OG
id|low
)paren
(brace
suffix:semicolon
)brace
)brace
r_return
id|freed
suffix:semicolon
)brace
multiline_comment|/*&n; * BAD_PAGE is the page that is used for page faults when linux&n; * is out-of-memory. Older versions of linux just did a&n; * do_exit(), but using this instead means there is less risk&n; * for a process dying in kernel mode, possibly leaving a inode&n; * unused etc..&n; *&n; * BAD_PAGETABLE is the accompanying page-table: it is initialized&n; * to point to BAD_PAGE entries.&n; *&n; * ZERO_PAGE is a special page that is used for zero-initialized&n; * data and COW.&n; */
DECL|variable|empty_bad_page_table
r_int
r_int
id|empty_bad_page_table
suffix:semicolon
DECL|function|__bad_pagetable
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*memset((void *)empty_bad_page_table, 0, PAGE_SIZE);*/
id|__clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page_table
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
(paren
id|pte_t
op_star
)paren
id|empty_bad_page_table
suffix:semicolon
)brace
DECL|variable|empty_bad_page
r_int
r_int
id|empty_bad_page
suffix:semicolon
DECL|function|__bad_page
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*memset((void *)empty_bad_page, 0, PAGE_SIZE);*/
id|__clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|pte_mkdirty
c_func
(paren
id|mk_pte
c_func
(paren
id|empty_bad_page
comma
id|PAGE_SHARED
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
op_assign
l_int|0
comma
id|cached
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Free swap:       %6dkB&bslash;n&quot;
comma
id|nr_swap_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|cached
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d free pages&bslash;n&quot;
comma
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages swap cached&bslash;n&quot;
comma
id|cached
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages in page table cache&bslash;n&quot;
comma
(paren
r_int
)paren
id|pgtable_cache_size
)paren
suffix:semicolon
id|show_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET
id|show_net_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%-8s %3s %3s %8s %8s %8s %9s %8s&quot;
comma
l_string|&quot;Process&quot;
comma
l_string|&quot;Pid&quot;
comma
l_string|&quot;Cnt&quot;
comma
l_string|&quot;Ctx&quot;
comma
l_string|&quot;Ctx&lt;&lt;4&quot;
comma
l_string|&quot;Last Sys&quot;
comma
l_string|&quot;pc&quot;
comma
l_string|&quot;task&quot;
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
id|printk
c_func
(paren
l_string|&quot; %3s&quot;
comma
l_string|&quot;CPU&quot;
)paren
suffix:semicolon
macro_line|#endif /* __SMP__ */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%-8.8s %3d %3d %8ld %8ld %8ld %c%08lx %08lx &quot;
comma
id|p-&gt;comm
comma
id|p-&gt;pid
comma
id|p-&gt;mm-&gt;count
comma
id|p-&gt;mm-&gt;context
comma
id|p-&gt;mm-&gt;context
op_lshift
l_int|4
comma
id|p-&gt;tss.last_syscall
comma
id|user_mode
c_func
(paren
id|p-&gt;tss.regs
)paren
ques
c_cond
l_char|&squot;u&squot;
suffix:colon
l_char|&squot;k&squot;
comma
id|p-&gt;tss.regs-&gt;nip
comma
(paren
id|ulong
)paren
id|p
)paren
suffix:semicolon
(brace
r_int
id|iscur
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __SMP__
id|printk
c_func
(paren
l_string|&quot;%3d &quot;
comma
id|p-&gt;processor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;processor
op_ne
id|NO_PROC_ID
)paren
op_logical_and
(paren
id|p
op_eq
id|current_set
(braket
id|p-&gt;processor
)braket
)paren
)paren
macro_line|#else&t;&t;
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
macro_line|#endif /* __SMP__ */
(brace
id|iscur
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|last_task_used_math
)paren
(brace
r_if
c_cond
(paren
id|iscur
)paren
id|printk
c_func
(paren
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last math&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
id|val-&gt;totalram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|buffermem
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;totalram
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;sharedram
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|val-&gt;totalram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;sharedram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
op_star
DECL|function|ioremap
id|ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|__ioremap
c_func
(paren
id|addr
comma
id|size
comma
id|_PAGE_NO_CACHE
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|__ioremap
id|__ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|p
comma
id|v
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Choose an address to map it to.&n;&t; * Once the vmalloc system is running, we use it.&n;&t; * Before then, we map addresses &gt;= ioremap_base&n;&t; * virt == phys; for addresses below this we use&n;&t; * space going down from ioremap_base (ioremap_bot&n;&t; * records where we&squot;re up to).&n;&t; *&n;&t; * We should also look out for a frame buffer and&n;&t; * map it with a free BAT register, if there is one.&n;&t; */
id|p
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
op_plus
id|size
)paren
op_minus
id|p
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
r_struct
id|vm_struct
op_star
id|area
suffix:semicolon
id|area
op_assign
id|get_vm_area
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|v
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|area-&gt;addr
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p
op_ge
id|ioremap_base
)paren
id|v
op_assign
id|p
suffix:semicolon
r_else
id|v
op_assign
(paren
id|ioremap_bot
op_sub_assign
id|size
)paren
suffix:semicolon
)brace
id|flags
op_or_assign
id|pgprot_val
c_func
(paren
id|PAGE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|_PAGE_NO_CACHE
op_or
id|_PAGE_WRITETHRU
)paren
)paren
id|flags
op_or_assign
id|_PAGE_GUARDED
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_add_assign
id|PAGE_SIZE
)paren
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
op_plus
id|i
comma
id|p
op_plus
id|i
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
(paren
id|v
op_plus
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
DECL|function|iounmap
r_void
id|iounmap
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
multiline_comment|/* XXX todo */
)brace
DECL|function|iopa
r_int
r_int
id|iopa
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|idx
suffix:semicolon
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
id|b
suffix:semicolon
macro_line|#endif
id|idx
op_assign
id|addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|addr
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
multiline_comment|/* Check the BATs */
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
r_if
c_cond
(paren
id|addr
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|addr
op_le
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
macro_line|#ifndef CONFIG_APUS
r_return
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
op_or
id|idx
suffix:semicolon
macro_line|#else
multiline_comment|/* Do a more precise remapping of virtual address */
multiline_comment|/* --Carsten */
r_return
(paren
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
op_minus
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_plus
id|addr
)paren
op_or
id|idx
suffix:semicolon
macro_line|#endif /* CONFIG_APUS */
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/* Do we have a page table? */
r_if
c_cond
(paren
id|init_task.mm-&gt;pgd
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use upper 10 bits of addr to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|init_task.mm-&gt;pgd
op_plus
(paren
id|addr
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use middle 10 bits of addr to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|addr
)paren
suffix:semicolon
r_return
(paren
id|pte_val
c_func
(paren
op_star
id|pg
)paren
op_amp
id|PAGE_MASK
)paren
op_or
id|idx
suffix:semicolon
)brace
r_void
DECL|function|map_page
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
id|b
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;pgd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Allocate upper level page map */
id|tsk-&gt;mm-&gt;pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Use upper 10 bits of VA to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|tsk-&gt;mm-&gt;pgd
op_plus
(paren
id|va
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
(brace
macro_line|#ifndef CONFIG_8xx
multiline_comment|/*&n;&t;&t; * Need to allocate second-level table, but first&n;&t;&t; * check whether this address is already mapped by&n;&t;&t; * the BATs; if so, don&squot;t bother allocating the page.&n;&t;&t; */
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
(brace
r_if
c_cond
(paren
id|va
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|va
op_le
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
(brace
multiline_comment|/* XXX should check the phys address matches */
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_8xx */
id|pg
op_assign
(paren
id|pte_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pg
suffix:semicolon
)brace
multiline_comment|/* Use middle 10 bits of VA to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|va
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg
comma
id|mk_pte_phys
c_func
(paren
id|pa
op_amp
id|PAGE_MASK
comma
id|__pgprot
c_func
(paren
id|flags
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|va
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(mm, start, end) flushes a range of pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * Flush all tlb/hash table entries (except perhaps for those&n; * mapping RAM starting at PAGE_OFFSET, since they never change).&n; */
r_void
DECL|function|local_flush_tlb_all
id|local_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|__clear_user
c_func
(paren
id|Hash
comma
id|Hash_size
)paren
suffix:semicolon
multiline_comment|/*memset(Hash, 0, Hash_size);*/
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
r_void
DECL|function|local_flush_tlb_mm
id|local_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
id|activate_context
c_func
(paren
id|current
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|local_flush_tlb_page
id|local_flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_if
c_cond
(paren
id|vmaddr
OL
id|TASK_SIZE
)paren
id|flush_hash_page
c_func
(paren
id|vma-&gt;vm_mm-&gt;context
comma
id|vmaddr
)paren
suffix:semicolon
r_else
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|vmaddr
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * for each page addr in the range, call MMU_invalidate_page()&n; * if the range is very large and the hash table is small it might be&n; * faster to do a search of the hash table and just invalidate pages&n; * that are in the range but that&squot;s for study later.&n; * -- Cort&n; */
r_void
DECL|function|local_flush_tlb_range
id|local_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
OG
l_int|20
op_star
id|PAGE_SIZE
)paren
(brace
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
op_logical_and
id|start
OL
id|TASK_SIZE
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|flush_hash_page
c_func
(paren
id|mm-&gt;context
comma
id|start
)paren
suffix:semicolon
)brace
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The context counter has overflowed.&n; * We set mm-&gt;context to NO_CONTEXT for all mm&squot;s in the system.&n; * We assume we can get to all mm&squot;s by looking as tsk-&gt;mm for&n; * all tasks in the system.&n; */
r_void
DECL|function|mmu_context_overflow
id|mmu_context_overflow
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmu_context_overflow&bslash;n&quot;
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
id|tsk-&gt;mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|flush_hash_segments
c_func
(paren
l_int|0x10
comma
l_int|0xffffff
)paren
suffix:semicolon
id|next_mmu_context
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure current always has a context */
id|current-&gt;mm-&gt;context
op_assign
id|MUNGE_CONTEXT
c_func
(paren
op_increment
id|next_mmu_context
)paren
suffix:semicolon
id|set_context
c_func
(paren
id|current-&gt;mm-&gt;context
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* We set the value to -1 because it is pre-incremented before&n;&t; * before use.&n;&t; */
id|next_mmu_context
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The following stuff defines a data structure for representing&n; * areas of memory as an array of (address, length) pairs, and&n; * procedures for manipulating them.&n; */
DECL|macro|MAX_MEM_REGIONS
mdefine_line|#define MAX_MEM_REGIONS&t;32
DECL|struct|mem_pieces
r_struct
id|mem_pieces
(brace
DECL|member|n_regions
r_int
id|n_regions
suffix:semicolon
DECL|member|regions
r_struct
id|reg_property
id|regions
(braket
id|MAX_MEM_REGIONS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|phys_mem
r_struct
id|mem_pieces
id|phys_mem
suffix:semicolon
DECL|variable|phys_avail
r_struct
id|mem_pieces
id|phys_avail
suffix:semicolon
DECL|variable|prom_mem
r_struct
id|mem_pieces
id|prom_mem
suffix:semicolon
r_static
r_void
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
op_star
id|find_mem_piece
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Scan a region for a piece of a given size with the required alignment.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
op_star
id|find_mem_piece
c_func
(paren
r_int
id|size
comma
r_int
id|align
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|a
comma
id|e
suffix:semicolon
r_struct
id|mem_pieces
op_star
id|mp
op_assign
op_amp
id|phys_avail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|e
op_assign
id|a
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
(paren
id|a
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
op_minus
id|align
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|size
op_le
id|e
)paren
(brace
id|remove_mem_piece
c_func
(paren
id|mp
comma
id|a
comma
id|size
comma
l_int|1
)paren
suffix:semicolon
r_return
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t find %u bytes at %u alignment&bslash;n&quot;
comma
id|size
comma
id|align
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove some memory from an array of pieces&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|must_exist
)paren
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|end
comma
id|rs
comma
id|re
suffix:semicolon
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|rp
op_assign
id|mp-&gt;regions
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|end
OG
id|rp-&gt;address
op_logical_and
id|start
OL
id|rp-&gt;address
op_plus
id|rp-&gt;size
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|mp-&gt;n_regions
)paren
(brace
r_if
c_cond
(paren
id|must_exist
)paren
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: [%x,%x) not in any region&bslash;n&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
template_param
id|rp-&gt;address
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
id|rs
op_assign
id|rp-&gt;address
suffix:semicolon
id|re
op_assign
id|rs
op_plus
id|rp-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|must_exist
op_logical_and
(paren
id|start
template_param
id|re
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: bad overlap [%x,%x) with&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|print_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
id|must_exist
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
OG
id|rs
)paren
(brace
id|rp-&gt;size
op_assign
id|start
op_minus
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
multiline_comment|/* need to split this entry */
r_if
c_cond
(paren
id|mp-&gt;n_regions
op_ge
id|MAX_MEM_REGIONS
)paren
id|panic
c_func
(paren
l_string|&quot;eek... mem_pieces overflow&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|mp-&gt;n_regions
suffix:semicolon
id|j
OG
id|i
op_plus
l_int|1
suffix:semicolon
op_decrement
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_minus
l_int|1
)braket
suffix:semicolon
op_increment
id|mp-&gt;n_regions
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|address
op_assign
id|end
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
id|rp-&gt;address
op_assign
id|end
suffix:semicolon
id|rp-&gt;size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need to delete this entry */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|mp-&gt;n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
op_decrement
id|mp-&gt;n_regions
suffix:semicolon
op_decrement
id|i
suffix:semicolon
op_decrement
id|rp
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; [%x, %x)&quot;
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_8xx
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|get_mem_prop
c_func
(paren
r_char
op_star
comma
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|sort_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|coalesce_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|append_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|sort_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
)paren
(brace
r_int
r_int
id|a
comma
id|s
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|s
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
op_decrement
id|j
)paren
(brace
r_if
c_cond
(paren
id|a
op_ge
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
)paren
r_break
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
)braket
suffix:semicolon
)brace
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|address
op_assign
id|a
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|size
op_assign
id|s
suffix:semicolon
)brace
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|coalesce_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
)paren
(brace
r_int
r_int
id|a
comma
id|e
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|d
suffix:semicolon
id|d
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
id|i
op_assign
id|j
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|e
op_assign
id|a
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|mp-&gt;n_regions
op_logical_and
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
op_le
id|e
suffix:semicolon
op_increment
id|j
)paren
id|e
op_assign
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
op_plus
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|size
suffix:semicolon
id|mp-&gt;regions
(braket
id|d
)braket
dot
id|address
op_assign
id|a
suffix:semicolon
id|mp-&gt;regions
(braket
id|d
)braket
dot
id|size
op_assign
id|e
op_minus
id|a
suffix:semicolon
op_increment
id|d
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|d
suffix:semicolon
)brace
multiline_comment|/*&n; * Add some memory to an array of pieces&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|append_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
comma
r_int
id|start
comma
r_int
id|size
)paren
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;n_regions
op_ge
id|MAX_MEM_REGIONS
)paren
r_return
suffix:semicolon
id|rp
op_assign
op_amp
id|mp-&gt;regions
(braket
id|mp-&gt;n_regions
op_increment
)braket
suffix:semicolon
id|rp-&gt;address
op_assign
id|start
suffix:semicolon
id|rp-&gt;size
op_assign
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in a property describing some pieces of memory.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|get_mem_prop
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|mem_pieces
op_star
id|mp
)paren
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_int
id|s
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|memory_node
comma
id|name
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;error: couldn&squot;t get %s property on /memory&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|s
op_div
r_sizeof
(paren
id|mp-&gt;regions
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mp-&gt;regions
comma
id|rp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* Make sure the pieces are sorted. */
id|sort_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
id|coalesce_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_8xx */
macro_line|#ifndef CONFIG_8xx
multiline_comment|/*&n; * Set up one of the I/D BAT (block address translation) register pairs.&n; * The parameters are not checked; in particular size must be a power&n; * of 2 between 128k and 256M.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|setbat
c_func
(paren
r_int
id|index
comma
r_int
r_int
id|virt
comma
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_int
id|flags
)paren
)paren
(brace
r_int
r_int
id|bl
suffix:semicolon
r_int
id|wimgxpp
suffix:semicolon
r_union
id|ubat
op_star
id|bat
op_assign
id|BATS
(braket
id|index
)braket
suffix:semicolon
id|bl
op_assign
(paren
id|size
op_rshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* 603, 604, etc. */
multiline_comment|/* Do DBAT first */
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
op_or
id|_PAGE_GUARDED
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
id|BPP_RW
suffix:colon
id|BPP_RX
suffix:semicolon
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
(paren
id|bl
op_lshift
l_int|2
)paren
op_or
l_int|2
suffix:semicolon
multiline_comment|/* Vs=1, Vp=0 */
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|wimgxpp
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
id|bat
(braket
l_int|1
)braket
dot
id|bat.batu.vp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_GUARDED
)paren
(brace
multiline_comment|/* G bit must be zero in IBATs */
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make IBAT same as DBAT */
id|bat
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|1
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 601 cpu */
r_if
c_cond
(paren
id|bl
OG
id|BL_8M
)paren
id|bl
op_assign
id|BL_8M
suffix:semicolon
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
(paren
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
ques
c_cond
id|PP_RWRW
suffix:colon
id|PP_RWXX
)paren
suffix:colon
id|PP_RXRX
suffix:semicolon
id|bat-&gt;word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
id|wimgxpp
op_or
l_int|4
suffix:semicolon
multiline_comment|/* Ks=0, Ku=1 */
id|bat-&gt;word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|bl
op_or
l_int|0x40
suffix:semicolon
multiline_comment|/* V=1 */
)brace
id|bat_addrs
(braket
id|index
)braket
dot
id|start
op_assign
id|virt
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|limit
op_assign
id|virt
op_plus
(paren
(paren
id|bl
op_plus
l_int|1
)paren
op_lshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|phys
op_assign
id|phys
suffix:semicolon
)brace
DECL|macro|IO_PAGE
mdefine_line|#define IO_PAGE&t;(_PAGE_NO_CACHE | _PAGE_GUARDED | _PAGE_RW)
macro_line|#ifdef __SMP__
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_COHERENT | _PAGE_RW)
macro_line|#else
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_RW)
macro_line|#endif
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/*&n; * Map in all of physical memory starting at KERNELBASE.&n; */
DECL|macro|PAGE_KERNEL_RO
mdefine_line|#define PAGE_KERNEL_RO&t;__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|mapin_ram
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|v
comma
id|p
comma
id|s
comma
id|f
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
r_int
id|tot
comma
id|mem_base
comma
id|bl
comma
id|done
suffix:semicolon
macro_line|#ifndef MAP_RAM_WITH_SEGREGS
multiline_comment|/* Set up BAT2 and if necessary BAT3 to cover RAM. */
id|tot
op_assign
(paren
r_int
r_int
)paren
id|end_of_DRAM
op_minus
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
l_int|256
op_lshift
l_int|20
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
id|mem_base
op_assign
id|__pa
c_func
(paren
id|KERNELBASE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|2
comma
id|KERNELBASE
comma
id|mem_base
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
id|done
op_assign
(paren
r_int
r_int
)paren
id|bat_addrs
(braket
l_int|2
)braket
dot
id|limit
op_minus
id|KERNELBASE
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|done
OL
id|tot
)paren
(brace
multiline_comment|/* use BAT3 to cover a bit more */
id|tot
op_sub_assign
id|done
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
l_int|256
op_lshift
l_int|20
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
id|setbat
c_func
(paren
l_int|3
comma
id|KERNELBASE
op_plus
id|done
comma
id|mem_base
op_plus
id|done
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|v
op_assign
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|p
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|s
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|f
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|v
OL
id|_stext
op_logical_or
(paren
r_char
op_star
)paren
id|v
op_ge
id|etext
)paren
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
r_else
multiline_comment|/* On the powerpc, no user access&n;&t;&t;&t;&t;   forces R/W kernel access */
id|f
op_or_assign
id|_PAGE_USER
suffix:semicolon
macro_line|#else&t;/* CONFIG_8xx */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|v
op_assign
(paren
id|ulong
)paren
id|__va
c_func
(paren
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|p
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|s
op_add_assign
id|PAGE_SIZE
)paren
(brace
multiline_comment|/* On the MPC8xx, we want the page shared so we&n;                         * don&squot;t get ASID compares on kernel space.&n;                         */
id|f
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
op_or
id|_PAGE_SHARED
suffix:semicolon
multiline_comment|/* I don&squot;t really need the rest of this code, but&n;                         * I grabbed it because I think the line:&n;                         *      f |= _PAGE_USER&n;                         * is incorrect.  It needs to be set to bits we&n;                         * don&squot;t define to cause a kernel read-only.  On&n;                         * the MPC8xx, the PAGE_DIRTY takes care of that&n;                         * for us (along with the RW software state).&n;                         */
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|v
OL
id|_stext
op_logical_or
(paren
r_char
op_star
)paren
id|v
op_ge
id|etext
)paren
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|v
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
op_star
id|MMU_get_page
c_func
(paren
r_void
)paren
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
id|p
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get a page in MMU_get_page&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|find_mem_piece
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*memset(p, 0, PAGE_SIZE);*/
id|__clear_user
c_func
(paren
id|p
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|free_initmem
c_func
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|a
suffix:semicolon
r_int
r_int
id|num_freed_pages
op_assign
l_int|0
comma
id|num_prep_pages
op_assign
l_int|0
comma
id|num_pmac_pages
op_assign
l_int|0
suffix:semicolon
DECL|macro|FREESEC
mdefine_line|#define FREESEC(START,END,CNT) do { &bslash;&n;&t;a = (unsigned long)(&amp;START); &bslash;&n;&t;for (; a &lt; (unsigned long)(&amp;END); a += PAGE_SIZE) { &bslash;&n;&t;  &t;clear_bit(PG_reserved, &amp;mem_map[MAP_NR(a)].flags); &bslash;&n;&t;&t;atomic_set(&amp;mem_map[MAP_NR(a)].count, 1); &bslash;&n;&t;&t;free_page(a); &bslash;&n;&t;&t;CNT++; &bslash;&n;&t;} &bslash;&n;} while (0)
id|FREESEC
c_func
(paren
id|__init_begin
comma
id|__init_end
comma
id|num_freed_pages
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|_machine
)paren
(brace
r_case
id|_MACH_Pmac
suffix:colon
r_case
id|_MACH_chrp
suffix:colon
id|FREESEC
c_func
(paren
id|__prep_begin
comma
id|__prep_end
comma
id|num_prep_pages
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_prep
suffix:colon
id|FREESEC
c_func
(paren
id|__pmac_begin
comma
id|__pmac_end
comma
id|num_pmac_pages
)paren
suffix:semicolon
id|FREESEC
c_func
(paren
id|__openfirmware_begin
comma
id|__openfirmware_end
comma
id|num_pmac_pages
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_mbx
suffix:colon
id|FREESEC
c_func
(paren
id|__pmac_begin
comma
id|__pmac_end
comma
id|num_pmac_pages
)paren
suffix:semicolon
id|FREESEC
c_func
(paren
id|__openfirmware_begin
comma
id|__openfirmware_end
comma
id|num_pmac_pages
)paren
suffix:semicolon
id|FREESEC
c_func
(paren
id|__prep_begin
comma
id|__prep_end
comma
id|num_prep_pages
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Freeing unused kernel memory: %ldk init&quot;
comma
(paren
id|num_freed_pages
op_star
id|PAGE_SIZE
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_prep_pages
)paren
id|printk
c_func
(paren
l_string|&quot; %ldk prep&quot;
comma
(paren
id|num_prep_pages
op_star
id|PAGE_SIZE
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_pmac_pages
)paren
id|printk
c_func
(paren
l_string|&quot; %ldk pmac&quot;
comma
(paren
id|num_pmac_pages
op_star
id|PAGE_SIZE
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do very early mm setup such as finding the size of memory&n; * and setting up the hash table.&n; * A lot of this is prep/pmac specific but a lot of it could&n; * still be merged.&n; * -- Cort&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|MMU_init
c_func
(paren
r_void
)paren
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_if
c_cond
(paren
id|have_of
)paren
id|end_of_DRAM
op_assign
id|pmac_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_APUS
r_else
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_apus
)paren
id|end_of_DRAM
op_assign
id|apus_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_else
multiline_comment|/* prep */
id|end_of_DRAM
op_assign
id|prep_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
id|hash_init
c_func
(paren
)paren
suffix:semicolon
id|_SDR1
op_assign
id|__pa
c_func
(paren
id|Hash
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
id|ioremap_base
op_assign
l_int|0xf8000000
suffix:semicolon
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the bat mappings we&squot;re going to load that cover&n;&t; * the io areas.  RAM was mapped by mapin_ram().&n;&t; * -- Cort&n;&t; */
r_switch
c_cond
(paren
id|_machine
)paren
(brace
r_case
id|_MACH_prep
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0x80000000
comma
l_int|0x80000000
comma
l_int|0x10000000
comma
id|IO_PAGE
op_plus
(paren
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
ques
c_cond
id|_PAGE_USER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|1
comma
l_int|0xd0000000
comma
l_int|0xc0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
op_plus
(paren
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
ques
c_cond
id|_PAGE_USER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_chrp
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf8000000
comma
l_int|0xf8000000
comma
l_int|0x20000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_Pmac
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf3000000
comma
l_int|0xf3000000
comma
l_int|0x100000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|ioremap_base
op_assign
l_int|0xf0000000
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_APUS
r_case
id|_MACH_apus
suffix:colon
multiline_comment|/* Map Cyberstorm PPC registers. */
multiline_comment|/* FIXME:APUS: Performance penalty here. Restrict it&n;&t;&t; *             to the Cyberstorm registers.&n;&t;&t; */
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xfff00000
comma
l_int|0xfff00000
comma
l_int|0x00080000
comma
id|IO_PAGE
)paren
suffix:semicolon
multiline_comment|/* Map chip and ZorroII memory */
id|setbat
c_func
(paren
l_int|1
comma
id|zTwoBase
comma
l_int|0x00000000
comma
l_int|0x01000000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
id|ioremap_bot
op_assign
id|ioremap_base
suffix:semicolon
macro_line|#else /* CONFIG_8xx */
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now map in some of the I/O space that is generically needed&n;         * or shared with multiple devices.&n;         * All of this fits into the same 4Mbyte region, so it only&n;         * requires one page table page.&n;         */
id|ioremap
c_func
(paren
id|NVRAM_ADDR
comma
id|NVRAM_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|MBX_CSR_ADDR
comma
id|MBX_CSR_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|MBX_IMAP_ADDR
comma
id|MBX_IMAP_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|PCI_CSR_ADDR
comma
id|PCI_CSR_SIZE
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
)brace
r_static
r_void
op_star
DECL|function|MMU_get_page
id|MMU_get_page
c_func
(paren
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
id|p
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get a page in MMU_get_page&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|find_mem_piece
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_void
op_star
DECL|function|ioremap
id|ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|__ioremap
c_func
(paren
id|addr
comma
id|size
comma
id|_PAGE_NO_CACHE
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|__ioremap
id|__ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|p
comma
id|v
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Choose an address to map it to.&n;&t; * Once the vmalloc system is running, we use it.&n;&t; * Before then, we map addresses &gt;= ioremap_base&n;&t; * virt == phys; for addresses below this we use&n;&t; * space going down from ioremap_base (ioremap_bot&n;&t; * records where we&squot;re up to).&n;&t; *&n;&t; * We should also look out for a frame buffer and&n;&t; * map it with a free BAT register, if there is one.&n;&t; */
id|p
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
op_plus
id|size
)paren
op_minus
id|p
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
r_struct
id|vm_struct
op_star
id|area
suffix:semicolon
id|area
op_assign
id|get_vm_area
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|v
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|area-&gt;addr
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p
op_ge
id|ioremap_base
)paren
id|v
op_assign
id|p
suffix:semicolon
r_else
id|v
op_assign
(paren
id|ioremap_bot
op_sub_assign
id|size
)paren
suffix:semicolon
)brace
id|flags
op_or_assign
id|pgprot_val
c_func
(paren
id|PAGE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|_PAGE_NO_CACHE
op_or
id|_PAGE_WRITETHRU
)paren
)paren
id|flags
op_or_assign
id|_PAGE_GUARDED
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_add_assign
id|PAGE_SIZE
)paren
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
op_plus
id|i
comma
id|p
op_plus
id|i
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
(paren
id|v
op_plus
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
DECL|function|iounmap
r_void
id|iounmap
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
multiline_comment|/* XXX todo */
)brace
DECL|function|iopa
r_int
r_int
id|iopa
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|idx
suffix:semicolon
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
id|b
suffix:semicolon
macro_line|#endif
id|idx
op_assign
id|addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|addr
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
multiline_comment|/* Check the BATs */
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
r_if
c_cond
(paren
id|addr
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|addr
op_le
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
r_return
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
op_or
id|idx
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/* Do we have a page table? */
r_if
c_cond
(paren
id|init_task.mm-&gt;pgd
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use upper 10 bits of addr to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|init_task.mm-&gt;pgd
op_plus
(paren
id|addr
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use middle 10 bits of addr to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|addr
)paren
suffix:semicolon
r_return
(paren
id|pte_val
c_func
(paren
op_star
id|pg
)paren
op_amp
id|PAGE_MASK
)paren
op_or
id|idx
suffix:semicolon
)brace
r_void
DECL|function|map_page
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
id|b
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;pgd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Allocate upper level page map */
id|tsk-&gt;mm-&gt;pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Use upper 10 bits of VA to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|tsk-&gt;mm-&gt;pgd
op_plus
(paren
id|va
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
(brace
macro_line|#ifndef CONFIG_8xx
multiline_comment|/*&n;&t;&t; * Need to allocate second-level table, but first&n;&t;&t; * check whether this address is already mapped by&n;&t;&t; * the BATs; if so, don&squot;t bother allocating the page.&n;&t;&t; */
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
(brace
r_if
c_cond
(paren
id|va
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|va
op_le
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
(brace
multiline_comment|/* XXX should check the phys address matches */
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_8xx */
id|pg
op_assign
(paren
id|pte_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pg
suffix:semicolon
)brace
multiline_comment|/* Use middle 10 bits of VA to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|va
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg
comma
id|mk_pte_phys
c_func
(paren
id|pa
op_amp
id|PAGE_MASK
comma
id|__pgprot
c_func
(paren
id|flags
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|va
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(mm, start, end) flushes a range of pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * Flush all tlb/hash table entries (except perhaps for those&n; * mapping RAM starting at PAGE_OFFSET, since they never change).&n; */
r_void
DECL|function|local_flush_tlb_all
id|local_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|memset
c_func
(paren
id|Hash
comma
l_int|0
comma
id|Hash_size
)paren
suffix:semicolon
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
r_void
DECL|function|local_flush_tlb_mm
id|local_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
id|activate_context
c_func
(paren
id|current
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|local_flush_tlb_page
id|local_flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_if
c_cond
(paren
id|vmaddr
OL
id|TASK_SIZE
)paren
id|flush_hash_page
c_func
(paren
id|vma-&gt;vm_mm-&gt;context
comma
id|vmaddr
)paren
suffix:semicolon
r_else
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|vmaddr
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * for each page addr in the range, call MMU_invalidate_page()&n; * if the range is very large and the hash table is small it might be&n; * faster to do a search of the hash table and just invalidate pages&n; * that are in the range but that&squot;s for study later.&n; * -- Cort&n; */
r_void
DECL|function|local_flush_tlb_range
id|local_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
OG
l_int|20
op_star
id|PAGE_SIZE
)paren
(brace
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
op_logical_and
id|start
OL
id|TASK_SIZE
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|flush_hash_page
c_func
(paren
id|mm-&gt;context
comma
id|start
)paren
suffix:semicolon
)brace
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The context counter has overflowed.&n; * We set mm-&gt;context to NO_CONTEXT for all mm&squot;s in the system.&n; * We assume we can get to all mm&squot;s by looking as tsk-&gt;mm for&n; * all tasks in the system.&n; */
r_void
DECL|function|mmu_context_overflow
id|mmu_context_overflow
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmu_context_overflow&bslash;n&quot;
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
id|tsk-&gt;mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|flush_hash_segments
c_func
(paren
l_int|0x10
comma
l_int|0xffffff
)paren
suffix:semicolon
id|next_mmu_context
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure current always has a context */
id|current-&gt;mm-&gt;context
op_assign
id|MUNGE_CONTEXT
c_func
(paren
op_increment
id|next_mmu_context
)paren
suffix:semicolon
id|set_context
c_func
(paren
id|current-&gt;mm-&gt;context
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* We set the value to -1 because it is pre-incremented before&n;&t; * before use.&n;&t; */
id|next_mmu_context
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if 0
multiline_comment|/*&n; * Cache flush functions - these functions cause caches to be flushed&n; * on _all_ processors due to their use of dcbf.  local_flush_cache_all() is&n; * the only function that will not act on all processors in the system.&n; * -- Cort&n; */
r_void
id|local_flush_cache_all
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0  
r_int
r_int
id|hid0
comma
id|tmp
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;mfspr %0,1008 &bslash;n&bslash;t&quot;
l_string|&quot;mr    %1,%0 &bslash;n&bslash;t&quot;
l_string|&quot;or    %0,%2,%2 &bslash;n&bslash;t&quot;
l_string|&quot;mtspr 1008,%0 &bslash;n&bslash;t&quot;
l_string|&quot;sync &bslash;n&bslash;t&quot;
l_string|&quot;isync &bslash;n&bslash;t&quot;
l_string|&quot;andc  %0,%0,%2 &bslash;n&bslash;t&quot;
l_string|&quot;mtspr 1008,%0 &bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=r&quot;
(paren
id|hid0
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|HID0_ICFI
op_or
id|HID0_DCI
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
r_void
id|local_flush_cache_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|vma
)paren
(brace
id|local_flush_cache_range
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
)brace
r_void
id|local_flush_cache_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|vmaddr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|vmaddr
suffix:semicolon
id|i
op_le
(paren
id|vmaddr
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
id|i
op_add_assign
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;dcbf %0,%1&bslash;n&bslash;ticbi %0,%1&bslash;n&bslash;t&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|i
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_void
id|local_flush_cache_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start
suffix:semicolon
id|i
op_le
id|end
suffix:semicolon
id|i
op_add_assign
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;dcbf %0,%1&bslash;n&bslash;ticbi %0,%1&bslash;n&bslash;t&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|i
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_MBX
multiline_comment|/*&n; * This is a big hack right now, but it may turn into something real&n; * someday.&n; *&n; * For the MBX860 (at this time anyway), there is nothing to initialize&n; * the associated PROM.  Rather than include all of the prom.c&n; * functions in the image just to get prom_init, all we really need right&n; * now is the initialization of the physical memory region.&n; */
r_void
DECL|function|set_mbx_memory
id|set_mbx_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
id|bd_t
op_star
id|binfo
suffix:semicolon
macro_line|#ifdef DIMM_8xx
r_volatile
id|memctl8xx_t
op_star
id|mcp
suffix:semicolon
macro_line|#endif
id|binfo
op_assign
(paren
id|bd_t
op_star
)paren
op_amp
id|res
suffix:semicolon
multiline_comment|/* The MBX can have up to three memory regions, the on-board&n;&t; * DRAM plus two more banks of DIMM socket memory.  The DIMM is&n;&t; * 64 bits, seen from the processor as two 32 bit banks.&n;&t; * The on-board DRAM is reflected in the board information&n;&t; * structure, and is either 4 Mbytes or 16 Mbytes.&n;&t; * I think there is a way to program the serial EEPROM information&n;&t; * so EPPC-Bug will initialize this memory, but I have not&n;&t; * done that and it may not be a wise thing to do.  If you&n;&t; * remove the DIMM without reprogramming the EEPROM, bad things&n;&t; * could happen since EPPC-Bug tries to use the upper 128K of&n;&t; * memory.&n;&t; */
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_assign
id|binfo-&gt;bi_memsize
suffix:semicolon
id|end_of_DRAM
op_assign
id|__va
c_func
(paren
id|binfo-&gt;bi_memsize
)paren
suffix:semicolon
macro_line|#ifdef DIMM_8xx
multiline_comment|/* This is a big hack.  It assumes my 32 Mbyte DIMM in a 40 MHz&n;&t; * MPC860.  Don&squot;t do this (or change this) if you are running&n;&t; * something else.&n;&t; */
id|mcp
op_assign
(paren
id|memctl8xx_t
op_star
)paren
(paren
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|MBX_IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_memctl
)paren
)paren
suffix:semicolon
id|mcp-&gt;memc_or2
op_assign
(paren
op_complement
(paren
id|DIMM_SIZE
op_minus
l_int|1
)paren
op_or
l_int|0x00000400
)paren
suffix:semicolon
id|mcp-&gt;memc_br2
op_assign
id|DIMM_SIZE
op_or
l_int|0x00000081
suffix:semicolon
id|mcp-&gt;memc_or3
op_assign
(paren
op_complement
(paren
(paren
l_int|2
op_star
id|DIMM_SIZE
)paren
op_minus
l_int|1
)paren
op_or
l_int|0x00000400
)paren
suffix:semicolon
id|mcp-&gt;memc_br3
op_assign
l_int|2
op_star
id|DIMM_SIZE
op_or
l_int|0x00000081
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
)braket
dot
id|address
op_assign
id|DIMM_SIZE
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
op_increment
)braket
dot
id|size
op_assign
id|DIMM_SIZE
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
)braket
dot
id|address
op_assign
l_int|2
op_star
id|DIMM_SIZE
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
op_increment
)braket
dot
id|size
op_assign
id|DIMM_SIZE
suffix:semicolon
id|end_of_DRAM
op_assign
id|__va
c_func
(paren
l_int|3
op_star
id|DIMM_SIZE
)paren
suffix:semicolon
macro_line|#endif
id|phys_avail
op_assign
id|phys_mem
suffix:semicolon
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|_end
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
