multiline_comment|/*&n; *  arch/ppc/mm/init.c&n; *&n; *  PowerPC version &n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)&n; *  and Cort Dougan (PReP) (cort@cs.nmt.edu)&n; *    Copyright (C) 1996 Paul Mackerras&n; *&n; *  Derived from &quot;arch/i386/mm/init.c&quot;&n; *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
macro_line|#include &lt;linux/blk.h&gt;&t;&t;/* for initrd_* */
macro_line|#endif
DECL|variable|prom_trashed
r_int
id|prom_trashed
suffix:semicolon
DECL|variable|next_mmu_context
r_int
id|next_mmu_context
suffix:semicolon
DECL|variable|_SDR1
r_int
r_int
id|_SDR1
suffix:semicolon
DECL|variable|Hash
DECL|variable|Hash_end
id|PTE
op_star
id|Hash
comma
op_star
id|Hash_end
suffix:semicolon
DECL|variable|Hash_size
DECL|variable|Hash_mask
r_int
r_int
id|Hash_size
comma
id|Hash_mask
suffix:semicolon
DECL|variable|end_of_DRAM
r_int
r_int
op_star
id|end_of_DRAM
suffix:semicolon
DECL|variable|mem_init_done
r_int
id|mem_init_done
suffix:semicolon
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
)braket
suffix:semicolon
r_extern
r_char
id|_start
(braket
)braket
comma
id|_end
(braket
)braket
suffix:semicolon
r_extern
r_char
id|etext
(braket
)braket
comma
id|_stext
(braket
)braket
suffix:semicolon
r_extern
r_char
id|__init_begin
comma
id|__init_end
suffix:semicolon
r_extern
id|RESIDUAL
id|res
suffix:semicolon
DECL|variable|klimit
r_char
op_star
id|klimit
op_assign
id|_end
suffix:semicolon
DECL|variable|memory_node
r_struct
id|device_node
op_star
id|memory_node
suffix:semicolon
r_void
op_star
id|find_mem_piece
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|mapin_ram
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|MMU_get_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|show_net_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
op_star
id|find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|current_set
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/*&n; * this tells the system to map all of ram with the segregs&n; * (i.e. page tables) instead of the bats.&n; */
DECL|macro|MAP_RAM_WITH_SEGREGS
macro_line|#undef MAP_RAM_WITH_SEGREGS 1
multiline_comment|/* optimization for 603 to load the tlb directly from the linux table */
DECL|macro|NO_RELOAD_HTAB
mdefine_line|#define NO_RELOAD_HTAB 1 /* change in kernel/head.S too! */
multiline_comment|/*&n; * BAD_PAGE is the page that is used for page faults when linux&n; * is out-of-memory. Older versions of linux just did a&n; * do_exit(), but using this instead means there is less risk&n; * for a process dying in kernel mode, possibly leaving a inode&n; * unused etc..&n; *&n; * BAD_PAGETABLE is the accompanying page-table: it is initialized&n; * to point to BAD_PAGE entries.&n; *&n; * ZERO_PAGE is a special page that is used for zero-initialized&n; * data and COW.&n; */
DECL|variable|empty_bad_page_table
r_int
r_int
id|empty_bad_page_table
suffix:semicolon
DECL|function|__bad_pagetable
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page_table
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
(paren
id|pte_t
op_star
)paren
id|empty_bad_page_table
suffix:semicolon
)brace
DECL|variable|empty_bad_page
r_int
r_int
id|empty_bad_page
suffix:semicolon
DECL|function|__bad_page
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|pte_mkdirty
c_func
(paren
id|mk_pte
c_func
(paren
id|empty_bad_page
comma
id|PAGE_SHARED
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following stuff defines a data structure for representing&n; * areas of memory as an array of (address, length) pairs, and&n; * procedures for manipulating them.&n; */
DECL|macro|MAX_MEM_REGIONS
mdefine_line|#define MAX_MEM_REGIONS&t;32
DECL|struct|mem_pieces
r_struct
id|mem_pieces
(brace
DECL|member|n_regions
r_int
id|n_regions
suffix:semicolon
DECL|member|regions
r_struct
id|reg_property
id|regions
(braket
id|MAX_MEM_REGIONS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|phys_mem
r_struct
id|mem_pieces
id|phys_mem
suffix:semicolon
DECL|variable|phys_avail
r_struct
id|mem_pieces
id|phys_avail
suffix:semicolon
DECL|variable|prom_mem
r_struct
id|mem_pieces
id|prom_mem
suffix:semicolon
r_static
r_void
id|get_mem_prop
c_func
(paren
r_char
op_star
comma
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|sort_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|coalesce_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|append_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
DECL|function|sort_mem_pieces
id|sort_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
r_int
id|a
comma
id|s
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|s
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
op_decrement
id|j
)paren
(brace
r_if
c_cond
(paren
id|a
op_ge
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
)paren
r_break
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
)braket
suffix:semicolon
)brace
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|address
op_assign
id|a
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|size
op_assign
id|s
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|coalesce_mem_pieces
id|coalesce_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
r_int
id|a
comma
id|e
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|d
suffix:semicolon
id|d
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
id|i
op_assign
id|j
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|e
op_assign
id|a
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|mp-&gt;n_regions
op_logical_and
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
op_le
id|e
suffix:semicolon
op_increment
id|j
)paren
id|e
op_assign
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
op_plus
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|size
suffix:semicolon
id|mp-&gt;regions
(braket
id|d
)braket
dot
id|address
op_assign
id|a
suffix:semicolon
id|mp-&gt;regions
(braket
id|d
)braket
dot
id|size
op_assign
id|e
op_minus
id|a
suffix:semicolon
op_increment
id|d
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|d
suffix:semicolon
)brace
multiline_comment|/*&n; * Add some memory to an array of pieces&n; */
r_static
r_void
DECL|function|append_mem_piece
id|append_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
comma
r_int
id|start
comma
r_int
id|size
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;n_regions
op_ge
id|MAX_MEM_REGIONS
)paren
r_return
suffix:semicolon
id|rp
op_assign
op_amp
id|mp-&gt;regions
(braket
id|mp-&gt;n_regions
op_increment
)braket
suffix:semicolon
id|rp-&gt;address
op_assign
id|start
suffix:semicolon
id|rp-&gt;size
op_assign
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove some memory from an array of pieces&n; */
r_static
r_void
DECL|function|remove_mem_piece
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|must_exist
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|end
comma
id|rs
comma
id|re
suffix:semicolon
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|rp
op_assign
id|mp-&gt;regions
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|end
OG
id|rp-&gt;address
op_logical_and
id|start
OL
id|rp-&gt;address
op_plus
id|rp-&gt;size
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|mp-&gt;n_regions
)paren
(brace
r_if
c_cond
(paren
id|must_exist
)paren
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: [%x,%x) not in any region&bslash;n&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
template_param
id|rp-&gt;address
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
id|rs
op_assign
id|rp-&gt;address
suffix:semicolon
id|re
op_assign
id|rs
op_plus
id|rp-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|must_exist
op_logical_and
(paren
id|start
template_param
id|re
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: bad overlap [%x,%x) with&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|print_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
id|must_exist
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
OG
id|rs
)paren
(brace
id|rp-&gt;size
op_assign
id|start
op_minus
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
multiline_comment|/* need to split this entry */
r_if
c_cond
(paren
id|mp-&gt;n_regions
op_ge
id|MAX_MEM_REGIONS
)paren
id|panic
c_func
(paren
l_string|&quot;eek... mem_pieces overflow&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|mp-&gt;n_regions
suffix:semicolon
id|j
OG
id|i
op_plus
l_int|1
suffix:semicolon
op_decrement
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_minus
l_int|1
)braket
suffix:semicolon
op_increment
id|mp-&gt;n_regions
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|address
op_assign
id|end
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
id|rp-&gt;address
op_assign
id|end
suffix:semicolon
id|rp-&gt;size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need to delete this entry */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|mp-&gt;n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
op_decrement
id|mp-&gt;n_regions
suffix:semicolon
op_decrement
id|i
suffix:semicolon
op_decrement
id|rp
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
DECL|function|print_mem_pieces
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; [%x, %x)&quot;
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan a region for a piece of a given size with the required alignment.&n; */
r_void
op_star
DECL|function|find_mem_piece
id|find_mem_piece
c_func
(paren
r_int
id|size
comma
r_int
id|align
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|a
comma
id|e
suffix:semicolon
r_struct
id|mem_pieces
op_star
id|mp
op_assign
op_amp
id|phys_avail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|e
op_assign
id|a
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
(paren
id|a
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
op_minus
id|align
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|size
op_le
id|e
)paren
(brace
id|remove_mem_piece
c_func
(paren
id|mp
comma
id|a
comma
id|size
comma
l_int|1
)paren
suffix:semicolon
r_return
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t find %u bytes at %u alignment&bslash;n&quot;
comma
id|size
comma
id|align
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in a property describing some pieces of memory.&n; */
r_static
r_void
DECL|function|get_mem_prop
id|get_mem_prop
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_int
id|s
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|memory_node
comma
id|name
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;error: couldn&squot;t get %s property on /memory&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|s
op_div
r_sizeof
(paren
id|mp-&gt;regions
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mp-&gt;regions
comma
id|rp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* Make sure the pieces are sorted. */
id|sort_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
id|coalesce_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On systems with Open Firmware, collect information about&n; * physical RAM and which pieces are already in use.&n; * At this point, we have (at least) the first 8MB mapped with a BAT.&n; * Our text, data, bss use something over 1MB, starting at 0.&n; * Open Firmware may be using 1MB at the 4MB point.&n; */
DECL|function|pmac_find_end_of_memory
r_int
r_int
op_star
id|pmac_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|a
comma
id|total
suffix:semicolon
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memory_node
op_assign
id|find_devices
c_func
(paren
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memory_node
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;can&squot;t find memory node&bslash;n&quot;
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find out where physical memory is, and check that it&n;&t; * starts at 0 and is contiguous.  It seems that RAM is&n;&t; * always physically contiguous on Power Macintoshes,&n;&t; * because MacOS can&squot;t cope if it isn&squot;t.&n;&t; *&n;&t; * Supporting discontiguous physical memory isn&squot;t hard,&n;&t; * it just makes the virtual &lt;-&gt; physical mapping functions&n;&t; * more complicated (or else you end up wasting space&n;&t; * in mem_map).&n;&t; */
id|get_mem_prop
c_func
(paren
l_string|&quot;reg&quot;
comma
op_amp
id|phys_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.n_regions
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;No RAM??&quot;
)paren
suffix:semicolon
id|a
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_if
c_cond
(paren
id|a
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;RAM doesn&squot;t start at physical address 0&quot;
)paren
suffix:semicolon
id|total
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.n_regions
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAM starting at 0x%x is not contiguous&bslash;n&quot;
comma
id|phys_mem.regions
(braket
l_int|1
)braket
dot
id|address
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using RAM from 0 to 0x%lx&bslash;n&quot;
comma
id|total
op_minus
l_int|1
)paren
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* record which bits the prom is using */
id|get_mem_prop
c_func
(paren
l_string|&quot;available&quot;
comma
op_amp
id|phys_avail
)paren
suffix:semicolon
id|prom_mem
op_assign
id|phys_mem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
comma
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * phys_avail records memory we can use now.&n;&t; * prom_mem records memory allocated by the prom that we&n;&t; * don&squot;t want to use now, but we&squot;ll reclaim later.&n;&t; * Make sure the kernel text/data/bss is in neither.&n;&t; */
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|klimit
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
l_int|0
comma
l_int|0x4000
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
l_int|0
comma
l_int|0x4000
comma
l_int|0
)paren
suffix:semicolon
r_return
id|__va
c_func
(paren
id|total
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find some memory for setup_arch to return.&n; * We use the last chunk of available memory as the area&n; * that setup_arch returns, making sure that there are at&n; * least 32 pages unused before this for MMU_get_page to use.&n; */
DECL|variable|avail_start
r_int
r_int
id|avail_start
suffix:semicolon
DECL|function|find_available_memory
r_int
r_int
id|find_available_memory
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|a
comma
id|free
suffix:semicolon
r_int
r_int
id|start
comma
id|end
suffix:semicolon
id|free
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|start
op_assign
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|free
op_add_assign
(paren
id|end
op_amp
id|PAGE_MASK
)paren
op_minus
id|PAGE_ALIGN
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free
OL
l_int|32
op_star
id|PAGE_SIZE
)paren
id|a
op_add_assign
l_int|32
op_star
id|PAGE_SIZE
op_minus
id|free
suffix:semicolon
id|avail_start
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
r_return
id|avail_start
suffix:semicolon
)brace
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Free swap:       %6dkB&bslash;n&quot;
comma
id|nr_swap_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d free pages&bslash;n&quot;
comma
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|show_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET
id|show_net_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%-8s %3s %3s %8s %8s %8s %9s %8s&quot;
comma
l_string|&quot;Process&quot;
comma
l_string|&quot;Pid&quot;
comma
l_string|&quot;Cnt&quot;
comma
l_string|&quot;Ctx&quot;
comma
l_string|&quot;Ctx&lt;&lt;4&quot;
comma
l_string|&quot;Last Sys&quot;
comma
l_string|&quot;pc&quot;
comma
l_string|&quot;task&quot;
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
id|printk
c_func
(paren
l_string|&quot; %3s&quot;
comma
l_string|&quot;CPU&quot;
)paren
suffix:semicolon
macro_line|#endif /* __SMP__ */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%-8.8s %3d %3d %8ld %8ld %8ld %c%08lx %08lx &quot;
comma
id|p-&gt;comm
comma
id|p-&gt;pid
comma
id|p-&gt;mm-&gt;count
comma
id|p-&gt;mm-&gt;context
comma
id|p-&gt;mm-&gt;context
op_lshift
l_int|4
comma
id|p-&gt;tss.last_syscall
comma
id|user_mode
c_func
(paren
id|p-&gt;tss.regs
)paren
ques
c_cond
l_char|&squot;u&squot;
suffix:colon
l_char|&squot;k&squot;
comma
id|p-&gt;tss.regs-&gt;nip
comma
(paren
id|ulong
)paren
id|p
)paren
suffix:semicolon
(brace
r_int
id|iscur
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __SMP__
id|printk
c_func
(paren
l_string|&quot;%3d &quot;
comma
id|p-&gt;processor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;processor
op_ne
id|NO_PROC_ID
)paren
op_logical_and
(paren
id|p
op_eq
id|current_set
(braket
id|p-&gt;processor
)braket
)paren
)paren
macro_line|#else&t;&t;
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
macro_line|#endif /* __SMP__ */
(brace
id|iscur
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|last_task_used_math
)paren
(brace
r_if
c_cond
(paren
id|iscur
)paren
id|printk
c_func
(paren
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last math&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_extern
r_int
r_int
id|free_area_init
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * paging_init() sets up the page tables - in fact we&squot;ve already done this.&n; */
DECL|function|paging_init
r_int
r_int
id|paging_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
(brace
multiline_comment|/*&n;&t; * Grab some memory for bad_page and bad_pagetable to use.&n;&t; */
id|empty_bad_page
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start_mem
)paren
suffix:semicolon
id|empty_bad_page_table
op_assign
id|empty_bad_page
op_plus
id|PAGE_SIZE
suffix:semicolon
id|start_mem
op_assign
id|empty_bad_page
op_plus
l_int|2
op_star
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* note: free_area_init uses its second argument&n;&t;   to size the mem_map array. */
id|start_mem
op_assign
id|free_area_init
c_func
(paren
id|start_mem
comma
id|end_mem
)paren
suffix:semicolon
r_return
id|start_mem
suffix:semicolon
)brace
DECL|function|mem_init
r_void
id|mem_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|a
comma
id|lim
suffix:semicolon
r_int
id|codepages
op_assign
l_int|0
suffix:semicolon
r_int
id|datapages
op_assign
l_int|0
suffix:semicolon
r_int
id|initpages
op_assign
l_int|0
suffix:semicolon
id|end_mem
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|high_memory
op_assign
(paren
r_void
op_star
)paren
id|end_mem
suffix:semicolon
id|max_mapnr
op_assign
id|MAP_NR
c_func
(paren
id|high_memory
)paren
suffix:semicolon
id|num_physpages
op_assign
id|max_mapnr
suffix:semicolon
multiline_comment|/* RAM is assumed contiguous */
multiline_comment|/* mark usable pages in the mem_map[] */
id|start_mem
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start_mem
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|__pa
c_func
(paren
id|avail_start
)paren
comma
id|start_mem
op_minus
id|avail_start
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|addr
OL
id|end_mem
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|lim
op_assign
id|a
op_plus
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|a
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|lim
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|phys_avail.n_regions
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* free the prom&squot;s memory - no-op on prep */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prom_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|prom_mem.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|lim
op_assign
id|a
op_plus
id|prom_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|a
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|lim
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|prom_trashed
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|addr
OL
id|end_mem
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|etext
)paren
id|codepages
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|__init_begin
op_logical_and
id|addr
OL
(paren
r_int
r_int
)paren
op_amp
id|__init_end
)paren
id|initpages
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|start_mem
)paren
id|datapages
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
op_logical_neg
id|initrd_start
op_logical_or
id|addr
OL
(paren
id|initrd_start
op_amp
id|PAGE_MASK
)paren
op_logical_or
id|addr
op_ge
id|initrd_end
)paren
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
id|free_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Memory: %luk available (%dk kernel code, %dk data, %dk init) [%08x,%08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|nr_free_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|codepages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|datapages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|initpages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|PAGE_OFFSET
comma
id|end_mem
)paren
suffix:semicolon
id|mem_init_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Unfortunately, we can&squot;t put initialization functions in their&n; * own section and free that at this point, because gas gets some&n; * relocations wrong if we do. :-(  But this code is here for when&n; * gas gets fixed.&n; */
DECL|function|free_initmem
r_void
id|free_initmem
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|a
suffix:semicolon
r_int
r_int
id|num_freed_pages
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_begin
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_end
)paren
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|a
)paren
suffix:semicolon
id|num_freed_pages
op_increment
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Freeing unused kernel memory: %ldk freed&bslash;n&quot;
comma
(paren
id|num_freed_pages
op_star
id|PAGE_SIZE
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
id|val-&gt;totalram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|buffermem
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;totalram
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;sharedram
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|val-&gt;totalram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;sharedram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|union|ubat
r_union
id|ubat
(brace
multiline_comment|/* BAT register values to be loaded */
DECL|member|bat
id|BAT
id|bat
suffix:semicolon
DECL|member|bat_601
id|P601_BAT
id|bat_601
suffix:semicolon
DECL|member|word
id|u32
id|word
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|BATS
)brace
id|BATS
(braket
l_int|4
)braket
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* 4 pairs of IBAT, DBAT */
DECL|struct|batrange
r_struct
id|batrange
(brace
multiline_comment|/* stores address ranges mapped by BATs */
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
DECL|member|phys
r_int
r_int
id|phys
suffix:semicolon
DECL|variable|bat_addrs
)brace
id|bat_addrs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n; * Set up one of the I/D BAT (block address translation) register pairs.&n; * The parameters are not checked; in particular size must be a power&n; * of 2 between 128k and 256M.&n; */
r_void
DECL|function|setbat
id|setbat
c_func
(paren
r_int
id|index
comma
r_int
r_int
id|virt
comma
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|bl
suffix:semicolon
r_int
id|wimgxpp
suffix:semicolon
r_union
id|ubat
op_star
id|bat
op_assign
id|BATS
(braket
id|index
)braket
suffix:semicolon
id|bl
op_assign
(paren
id|size
op_rshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* 603, 604, etc. */
multiline_comment|/* Do DBAT first */
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
op_or
id|_PAGE_GUARDED
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
id|BPP_RW
suffix:colon
id|BPP_RX
suffix:semicolon
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
(paren
id|bl
op_lshift
l_int|2
)paren
op_or
l_int|2
suffix:semicolon
multiline_comment|/* Vs=1, Vp=0 */
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|wimgxpp
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
id|bat
(braket
l_int|1
)braket
dot
id|bat.batu.vp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_GUARDED
)paren
(brace
multiline_comment|/* G bit must be zero in IBATs */
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make IBAT same as DBAT */
id|bat
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|1
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 601 cpu */
r_if
c_cond
(paren
id|bl
OG
id|BL_8M
)paren
id|bl
op_assign
id|BL_8M
suffix:semicolon
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
(paren
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
ques
c_cond
id|PP_RWRW
suffix:colon
id|PP_RWXX
)paren
suffix:colon
id|PP_RXRX
suffix:semicolon
id|bat-&gt;word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
id|wimgxpp
op_or
l_int|4
suffix:semicolon
multiline_comment|/* Ks=0, Ku=1 */
id|bat-&gt;word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|bl
op_or
l_int|0x40
suffix:semicolon
multiline_comment|/* V=1 */
)brace
id|bat_addrs
(braket
id|index
)braket
dot
id|start
op_assign
id|virt
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|limit
op_assign
id|virt
op_plus
(paren
(paren
id|bl
op_plus
l_int|1
)paren
op_lshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|phys
op_assign
id|phys
suffix:semicolon
)brace
DECL|macro|IO_PAGE
mdefine_line|#define IO_PAGE&t;(_PAGE_NO_CACHE | _PAGE_GUARDED | _PAGE_RW)
macro_line|#ifdef __SMP__
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_COHERENT | _PAGE_RW)
macro_line|#else
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_RW)
macro_line|#endif
multiline_comment|/*&n; * This finds the amount of physical ram and does necessary&n; * setup for prep.  This is pretty architecture specific so&n; * this will likely stay seperate from the pmac.&n; * -- Cort&n; */
DECL|function|prep_find_end_of_memory
r_int
r_int
op_star
id|prep_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
r_int
r_int
id|total
suffix:semicolon
id|total
op_assign
id|res.TotalMemory
suffix:semicolon
r_if
c_cond
(paren
id|total
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * I need a way to probe the amount of memory if the residual&n;&t;&t; * data doesn&squot;t contain it. -- Cort&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Ramsize from residual data was 0 -- Probing for value&bslash;n&quot;
)paren
suffix:semicolon
id|total
op_assign
l_int|0x02000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ramsize default to be %ldM&bslash;n&quot;
comma
id|total
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
id|append_mem_piece
c_func
(paren
op_amp
id|phys_mem
comma
l_int|0
comma
id|total
)paren
suffix:semicolon
id|phys_avail
op_assign
id|phys_mem
suffix:semicolon
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|klimit
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
l_int|0
comma
l_int|0x4000
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|__va
c_func
(paren
id|total
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map in all of physical memory starting at KERNELBASE.&n; */
DECL|macro|PAGE_KERNEL_RO
mdefine_line|#define PAGE_KERNEL_RO&t;__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
DECL|function|mapin_ram
r_static
r_void
id|mapin_ram
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|tot
comma
id|bl
comma
id|done
suffix:semicolon
r_int
r_int
id|v
comma
id|p
comma
id|s
comma
id|f
suffix:semicolon
macro_line|#ifndef MAP_RAM_WITH_SEGREGS
multiline_comment|/* Set up BAT2 and if necessary BAT3 to cover RAM. */
id|tot
op_assign
(paren
r_int
r_int
)paren
id|end_of_DRAM
op_minus
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
l_int|256
op_lshift
l_int|20
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
id|setbat
c_func
(paren
l_int|2
comma
id|KERNELBASE
comma
l_int|0
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
id|done
op_assign
id|__pa
c_func
(paren
id|bat_addrs
(braket
l_int|2
)braket
dot
id|limit
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|done
OL
id|tot
)paren
(brace
multiline_comment|/* use BAT3 to cover a bit more */
id|tot
op_sub_assign
id|done
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
l_int|256
op_lshift
l_int|20
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
id|setbat
c_func
(paren
l_int|3
comma
id|KERNELBASE
op_plus
id|done
comma
id|done
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|v
op_assign
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|p
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|s
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|f
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|v
OL
id|_stext
op_logical_or
(paren
r_char
op_star
)paren
id|v
op_ge
id|etext
)paren
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
r_else
multiline_comment|/* On the powerpc, no user access&n;&t;&t;&t;&t;   forces R/W kernel access */
id|f
op_or_assign
id|_PAGE_USER
suffix:semicolon
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|v
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Initialize the hash table and patch the instructions in head.S.&n; */
DECL|function|hash_init
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|Hash_bits
suffix:semicolon
r_int
r_int
id|h
comma
id|ramsize
suffix:semicolon
r_extern
r_int
r_int
id|hash_page_patch_A
(braket
)braket
comma
id|hash_page_patch_B
(braket
)braket
comma
id|hash_page_patch_C
(braket
)braket
comma
id|hash_page_patch_D
(braket
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Allow 64k of hash table for every 16MB of memory,&n;&t; * up to a maximum of 2MB.&n;&t; */
id|ramsize
op_assign
(paren
id|ulong
)paren
id|end_of_DRAM
op_minus
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|64
op_lshift
l_int|10
suffix:semicolon
id|h
OL
id|ramsize
op_div
l_int|256
op_logical_and
id|h
OL
l_int|2
op_lshift
l_int|20
suffix:semicolon
id|h
op_mul_assign
l_int|2
)paren
suffix:semicolon
id|Hash_size
op_assign
id|h
suffix:semicolon
id|Hash_mask
op_assign
(paren
id|h
op_rshift
l_int|6
)paren
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef NO_RELOAD_HTAB
multiline_comment|/* shrink the htab since we don&squot;t use it on 603&squot;s -- Cort */
r_switch
c_cond
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
(brace
r_case
l_int|3
suffix:colon
multiline_comment|/* 603 */
r_case
l_int|6
suffix:colon
multiline_comment|/* 603e */
r_case
l_int|7
suffix:colon
multiline_comment|/* 603ev */
id|Hash_size
op_assign
l_int|0
suffix:semicolon
id|Hash_mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* on 601/4 let things be */
r_break
suffix:semicolon
)brace
macro_line|#endif /* NO_RELOAD_HTAB */
multiline_comment|/* Find some memory for the hash table. */
r_if
c_cond
(paren
id|Hash_size
)paren
id|Hash
op_assign
id|find_mem_piece
c_func
(paren
id|Hash_size
comma
id|Hash_size
)paren
suffix:semicolon
r_else
id|Hash
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Total memory = %ldMB; using %ldkB for hash table (at %p)&bslash;n&quot;
comma
id|ramsize
op_rshift
l_int|20
comma
id|Hash_size
op_rshift
l_int|10
comma
id|Hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Hash_size
)paren
(brace
id|memset
c_func
(paren
id|Hash
comma
l_int|0
comma
id|Hash_size
)paren
suffix:semicolon
id|Hash_end
op_assign
(paren
id|PTE
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|Hash
op_plus
id|Hash_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Patch up the instructions in head.S:hash_page&n;&t;&t; */
id|Hash_bits
op_assign
id|ffz
c_func
(paren
op_complement
id|Hash_size
)paren
op_minus
l_int|6
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|__pa
c_func
(paren
id|Hash
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|1
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
(paren
l_int|26
op_minus
id|Hash_bits
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Hash_bits
OG
l_int|16
)paren
id|Hash_bits
op_assign
l_int|16
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|2
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|2
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
(paren
l_int|26
op_minus
id|Hash_bits
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|hash_page_patch_B
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_B
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
id|hash_page_patch_C
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_C
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
id|hash_page_patch_D
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_D
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ensure that the locations we&squot;ve patched have been written&n;&t;&t; * out from the data cache and invalidated in the instruction&n;&t;&t; * cache, on those machines with split caches.&n;&t;&t; */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|hash_page_patch_A
comma
(paren
r_int
r_int
)paren
(paren
id|hash_page_patch_D
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
id|Hash_end
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Do very early mm setup such as finding the size of memory&n; * and setting up the hash table.&n; * A lot of this is prep/pmac specific but a lot of it could&n; * still be merged.&n; * -- Cort&n; */
r_void
DECL|function|MMU_init
id|MMU_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|have_of
)paren
id|end_of_DRAM
op_assign
id|pmac_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
r_else
multiline_comment|/* prep */
id|end_of_DRAM
op_assign
id|prep_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
id|hash_init
c_func
(paren
)paren
suffix:semicolon
id|_SDR1
op_assign
id|__pa
c_func
(paren
id|Hash
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the bat mappings we&squot;re going to load that cover&n;&t; * the io areas.  RAM was mapped by mapin_ram().&n;&t; * -- Cort&n;&t; */
r_switch
c_cond
(paren
id|_machine
)paren
(brace
r_case
id|_MACH_prep
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0x80000000
comma
l_int|0x80000000
comma
l_int|0x10000000
comma
id|IO_PAGE
op_plus
(paren
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
ques
c_cond
id|_PAGE_USER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|1
comma
l_int|0xd0000000
comma
l_int|0xc0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
op_plus
(paren
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
ques
c_cond
id|_PAGE_USER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_chrp
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xc0000000
comma
l_int|0xc0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|1
comma
l_int|0xf8000000
comma
l_int|0xf8000000
comma
l_int|0x20000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|3
comma
l_int|0x80000000
comma
l_int|0x80000000
comma
l_int|0x10000000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_Pmac
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf3000000
comma
l_int|0xf3000000
comma
l_int|0x100000
comma
id|IO_PAGE
)paren
suffix:semicolon
multiline_comment|/* this is used to cover registers used by smp boards -- Cort */
id|setbat
c_func
(paren
l_int|3
comma
l_int|0xf8000000
comma
l_int|0xf8000000
comma
l_int|0x100000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_static
r_void
op_star
DECL|function|MMU_get_page
id|MMU_get_page
c_func
(paren
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
id|p
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get a page in MMU_get_page&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|find_mem_piece
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_void
op_star
DECL|function|ioremap
id|ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|p
comma
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
)paren
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|p
comma
id|p
comma
id|pgprot_val
c_func
(paren
id|PAGE_KERNEL_CI
)paren
op_or
id|_PAGE_GUARDED
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
)brace
DECL|function|iounmap
r_void
id|iounmap
c_func
(paren
r_int
r_int
op_star
id|addr
)paren
(brace
multiline_comment|/* XXX todo */
)brace
r_void
DECL|function|map_page
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
r_int
id|b
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;pgd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Allocate upper level page map */
id|tsk-&gt;mm-&gt;pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Use upper 10 bits of VA to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|tsk-&gt;mm-&gt;pgd
op_plus
(paren
id|va
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Need to allocate second-level table, but first&n;&t;&t; * check whether this address is already mapped by&n;&t;&t; * the BATs; if so, don&squot;t bother allocating the page.&n;&t;&t; */
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
(brace
r_if
c_cond
(paren
id|va
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|va
op_le
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
(brace
multiline_comment|/* XXX should check the phys address matches */
r_return
suffix:semicolon
)brace
)brace
id|pg
op_assign
(paren
id|pte_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pg
suffix:semicolon
)brace
multiline_comment|/* Use middle 10 bits of VA to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|va
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg
comma
id|mk_pte_phys
c_func
(paren
id|pa
op_amp
id|PAGE_MASK
comma
id|__pgprot
c_func
(paren
id|flags
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*flush_hash_page(va &gt;&gt; 28, va);*/
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|va
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(mm, start, end) flushes a range of pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * Flush all tlb/hash table entries (except perhaps for those&n; * mapping RAM starting at PAGE_OFFSET, since they never change).&n; */
r_void
DECL|function|local_flush_tlb_all
id|local_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
id|Hash
comma
l_int|0
comma
id|Hash_size
)paren
suffix:semicolon
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
r_void
DECL|function|local_flush_tlb_mm
id|local_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
(brace
id|get_mmu_context
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* done by get_mmu_context() now -- Cort */
multiline_comment|/*set_context(current-&gt;mm-&gt;context);*/
)brace
)brace
r_void
DECL|function|local_flush_tlb_page
id|local_flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_if
c_cond
(paren
id|vmaddr
OL
id|TASK_SIZE
)paren
id|flush_hash_page
c_func
(paren
id|vma-&gt;vm_mm-&gt;context
comma
id|vmaddr
)paren
suffix:semicolon
r_else
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|vmaddr
)paren
suffix:semicolon
)brace
multiline_comment|/* for each page addr in the range, call MMU_invalidate_page()&n;   if the range is very large and the hash table is small it might be faster to&n;   do a search of the hash table and just invalidate pages that are in the range&n;   but that&squot;s for study later.&n;        -- Cort&n;   */
r_void
DECL|function|local_flush_tlb_range
id|local_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
OG
l_int|20
op_star
id|PAGE_SIZE
)paren
(brace
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
op_logical_and
id|start
OL
id|TASK_SIZE
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|flush_hash_page
c_func
(paren
id|mm-&gt;context
comma
id|start
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The context counter has overflowed.&n; * We set mm-&gt;context to NO_CONTEXT for all mm&squot;s in the system.&n; * We assume we can get to all mm&squot;s by looking as tsk-&gt;mm for&n; * all tasks in the system.&n; */
r_void
DECL|function|mmu_context_overflow
id|mmu_context_overflow
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmu_context_overflow&bslash;n&quot;
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
id|tsk-&gt;mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|flush_hash_segments
c_func
(paren
l_int|0x10
comma
l_int|0xffffff
)paren
suffix:semicolon
id|next_mmu_context
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure current always has a context */
id|current-&gt;mm-&gt;context
op_assign
id|MUNGE_CONTEXT
c_func
(paren
op_increment
id|next_mmu_context
)paren
suffix:semicolon
id|set_context
c_func
(paren
id|current-&gt;mm-&gt;context
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Cache flush functions - these functions cause caches to be flushed&n; * on _all_ processors due to their use of dcbf.  local_flush_cache_all() is&n; * the only function that will not act on all processors in the system.&n; * -- Cort&n; */
r_void
id|local_flush_cache_all
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0  
r_int
r_int
id|hid0
comma
id|tmp
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;mfspr %0,1008 &bslash;n&bslash;t&quot;
l_string|&quot;mr    %1,%0 &bslash;n&bslash;t&quot;
l_string|&quot;or    %0,%2,%2 &bslash;n&bslash;t&quot;
l_string|&quot;mtspr 1008,%0 &bslash;n&bslash;t&quot;
l_string|&quot;sync &bslash;n&bslash;t&quot;
l_string|&quot;isync &bslash;n&bslash;t&quot;
l_string|&quot;andc  %0,%0,%2 &bslash;n&bslash;t&quot;
l_string|&quot;mtspr 1008,%0 &bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=r&quot;
(paren
id|hid0
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|HID0_ICFI
op_or
id|HID0_DCI
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
r_void
id|local_flush_cache_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|vma
)paren
(brace
id|local_flush_cache_range
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
)brace
r_void
id|local_flush_cache_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|vmaddr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|vmaddr
suffix:semicolon
id|i
op_le
(paren
id|vmaddr
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
id|i
op_add_assign
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;dcbf %0,%1&bslash;n&bslash;ticbi %0,%1&bslash;n&bslash;t&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|i
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_void
id|local_flush_cache_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start
suffix:semicolon
id|i
op_le
id|end
suffix:semicolon
id|i
op_add_assign
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;dcbf %0,%1&bslash;n&bslash;ticbi %0,%1&bslash;n&bslash;t&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|i
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
