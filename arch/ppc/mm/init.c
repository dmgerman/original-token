multiline_comment|/*&n; *  arch/ppc/mm/init.c&n; *&n; *  PowerPC version &n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)&n; *  and Cort Dougan (PReP) (cort@cs.nmt.edu)&n; *    Copyright (C) 1996 Paul Mackerras&n; *&n; *  Derived from &quot;arch/i386/mm/init.c&quot;&n; *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
macro_line|#include &lt;linux/blk.h&gt;&t;&t;/* for initrd_* */
macro_line|#endif
DECL|variable|prom_trashed
r_int
id|prom_trashed
suffix:semicolon
DECL|variable|next_mmu_context
r_int
id|next_mmu_context
suffix:semicolon
DECL|variable|_SDR1
r_int
r_int
id|_SDR1
suffix:semicolon
DECL|variable|Hash
DECL|variable|Hash_end
id|PTE
op_star
id|Hash
comma
op_star
id|Hash_end
suffix:semicolon
DECL|variable|Hash_size
DECL|variable|Hash_mask
r_int
r_int
id|Hash_size
comma
id|Hash_mask
suffix:semicolon
DECL|variable|end_of_DRAM
r_int
r_int
op_star
id|end_of_DRAM
suffix:semicolon
DECL|variable|mem_init_done
r_int
id|mem_init_done
suffix:semicolon
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
)braket
suffix:semicolon
r_extern
r_char
id|_start
(braket
)braket
comma
id|_end
(braket
)braket
suffix:semicolon
r_extern
r_char
id|etext
(braket
)braket
comma
id|_stext
(braket
)braket
suffix:semicolon
r_extern
r_char
id|__init_begin
comma
id|__init_end
suffix:semicolon
r_extern
id|RESIDUAL
id|res
suffix:semicolon
r_void
op_star
id|find_mem_piece
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|mapin_ram
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|inherit_prom_translations
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|MMU_get_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|show_net_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
op_star
id|find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * this tells the prep system to map all of ram with the segregs&n; * instead of the bats.  I&squot;d like to get this to apply to the&n; * pmac as well then have everything use the bats -- Cort&n; */
DECL|macro|MAP_RAM_WITH_SEGREGS
macro_line|#undef MAP_RAM_WITH_SEGREGS 1 
multiline_comment|/*&n; * these are used to setup the initial page tables&n; * They can waste up to an entire page since the&n; * I&squot;ll fix this shortly -- Cort&n; */
DECL|macro|MAX_MMU_PAGES
mdefine_line|#define MAX_MMU_PAGES&t;16
DECL|variable|probingmem
r_int
r_int
id|probingmem
op_assign
l_int|0
suffix:semicolon
DECL|variable|mmu_pages_count
r_int
r_int
id|mmu_pages_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|mmu_pages
r_char
id|mmu_pages
(braket
(paren
id|MAX_MMU_PAGES
op_plus
l_int|1
)paren
op_star
id|PAGE_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n; * BAD_PAGE is the page that is used for page faults when linux&n; * is out-of-memory. Older versions of linux just did a&n; * do_exit(), but using this instead means there is less risk&n; * for a process dying in kernel mode, possibly leaving a inode&n; * unused etc..&n; *&n; * BAD_PAGETABLE is the accompanying page-table: it is initialized&n; * to point to BAD_PAGE entries.&n; *&n; * ZERO_PAGE is a special page that is used for zero-initialized&n; * data and COW.&n; */
DECL|variable|empty_bad_page_table
r_int
r_int
id|empty_bad_page_table
suffix:semicolon
DECL|function|__bad_pagetable
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page_table
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
(paren
id|pte_t
op_star
)paren
id|empty_bad_page_table
suffix:semicolon
)brace
DECL|variable|empty_bad_page
r_int
r_int
id|empty_bad_page
suffix:semicolon
DECL|function|__bad_page
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|pte_mkdirty
c_func
(paren
id|mk_pte
c_func
(paren
id|empty_bad_page
comma
id|PAGE_SHARED
)paren
)paren
suffix:semicolon
)brace
DECL|macro|MAX_MEM_REGIONS
mdefine_line|#define MAX_MEM_REGIONS&t;32
DECL|variable|memory_pkg
id|phandle
id|memory_pkg
suffix:semicolon
DECL|struct|mem_pieces
r_struct
id|mem_pieces
(brace
DECL|member|n_regions
r_int
id|n_regions
suffix:semicolon
DECL|member|regions
r_struct
id|reg_property
id|regions
(braket
id|MAX_MEM_REGIONS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|phys_mem
r_struct
id|mem_pieces
id|phys_mem
suffix:semicolon
DECL|variable|phys_avail
r_struct
id|mem_pieces
id|phys_avail
suffix:semicolon
DECL|variable|prom_mem
r_struct
id|mem_pieces
id|prom_mem
suffix:semicolon
r_static
r_void
id|get_mem_prop
c_func
(paren
r_char
op_star
comma
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
DECL|variable|avail_start
r_int
r_int
id|avail_start
suffix:semicolon
multiline_comment|/*&n; * Read in a property describing some pieces of memory.&n; */
r_static
r_void
DECL|function|get_mem_prop
id|get_mem_prop
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
id|s
comma
id|i
suffix:semicolon
id|s
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|memory_pkg
comma
id|name
comma
id|mp-&gt;regions
comma
r_sizeof
(paren
id|mp-&gt;regions
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
r_sizeof
(paren
id|mp-&gt;regions
(braket
l_int|0
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;getprop /memory %s returned %d&bslash;n&quot;
comma
id|name
comma
id|s
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|s
op_div
r_sizeof
(paren
id|mp-&gt;regions
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the pieces are sorted.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|a
comma
id|s
suffix:semicolon
r_int
id|j
suffix:semicolon
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|s
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
op_decrement
id|j
)paren
(brace
r_if
c_cond
(paren
id|a
op_ge
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
)paren
r_break
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
)braket
suffix:semicolon
)brace
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|address
op_assign
id|a
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|size
op_assign
id|s
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove some memory from an array of pieces&n; */
r_static
r_void
DECL|function|remove_mem_piece
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|must_exist
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|end
comma
id|rs
comma
id|re
suffix:semicolon
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|rp
op_assign
id|mp-&gt;regions
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|end
OG
id|rp-&gt;address
op_logical_and
id|start
OL
id|rp-&gt;address
op_plus
id|rp-&gt;size
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|mp-&gt;n_regions
)paren
(brace
r_if
c_cond
(paren
id|must_exist
)paren
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: [%x,%x) not in any region&bslash;n&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
template_param
id|rp-&gt;address
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
id|rs
op_assign
id|rp-&gt;address
suffix:semicolon
id|re
op_assign
id|rs
op_plus
id|rp-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|must_exist
op_logical_and
(paren
id|start
template_param
id|re
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: bad overlap [%x,%x) with&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|print_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
id|must_exist
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
OG
id|rs
)paren
(brace
id|rp-&gt;size
op_assign
id|start
op_minus
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
multiline_comment|/* need to split this entry */
r_if
c_cond
(paren
id|mp-&gt;n_regions
op_ge
id|MAX_MEM_REGIONS
)paren
id|panic
c_func
(paren
l_string|&quot;eek... mem_pieces overflow&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|mp-&gt;n_regions
suffix:semicolon
id|j
OG
id|i
op_plus
l_int|1
suffix:semicolon
op_decrement
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_minus
l_int|1
)braket
suffix:semicolon
op_increment
id|mp-&gt;n_regions
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|address
op_assign
id|end
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
id|rp-&gt;address
op_assign
id|end
suffix:semicolon
id|rp-&gt;size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need to delete this entry */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|mp-&gt;n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
op_decrement
id|mp-&gt;n_regions
suffix:semicolon
op_decrement
id|i
suffix:semicolon
op_decrement
id|rp
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
DECL|function|print_mem_pieces
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; [%x, %x)&quot;
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|find_mem_piece
id|find_mem_piece
c_func
(paren
r_int
id|size
comma
r_int
id|align
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|a
comma
id|e
suffix:semicolon
r_struct
id|mem_pieces
op_star
id|mp
op_assign
op_amp
id|phys_avail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|e
op_assign
id|a
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
(paren
id|a
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
op_minus
id|align
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|size
op_le
id|e
)paren
(brace
id|remove_mem_piece
c_func
(paren
id|mp
comma
id|a
comma
id|size
comma
l_int|1
)paren
suffix:semicolon
r_return
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t find %u bytes at %u alignment&bslash;n&quot;
comma
id|size
comma
id|align
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Collect information about RAM and which pieces are already in use.&n; * At this point, we have the first 8MB mapped with a BAT.&n; * Our text, data, bss use something over 1MB, starting at 0.&n; * Open Firmware may be using 1MB at the 4MB point.&n; */
DECL|function|pmac_find_end_of_memory
r_int
r_int
op_star
id|pmac_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|a
comma
id|total
suffix:semicolon
r_int
r_int
id|h
comma
id|kstart
comma
id|ksize
suffix:semicolon
r_extern
r_char
id|_stext
(braket
)braket
comma
id|_end
(braket
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memory_pkg
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;/memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memory_pkg
op_eq
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
id|panic
c_func
(paren
l_string|&quot;can&squot;t find memory package&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find out where physical memory is, and check that it&n;&t; * starts at 0 and is contiguous.  It seems that RAM is&n;&t; * always physically contiguous on Power Macintoshes,&n;&t; * because MacOS can&squot;t cope if it isn&squot;t.&n;&t; */
id|get_mem_prop
c_func
(paren
l_string|&quot;reg&quot;
comma
op_amp
id|phys_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.n_regions
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;No RAM??&quot;
)paren
suffix:semicolon
id|a
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_if
c_cond
(paren
id|a
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;RAM doesn&squot;t start at physical address 0&quot;
)paren
suffix:semicolon
id|total
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_if
c_cond
(paren
id|a
op_ne
id|total
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAM starting at 0x%lx is not contiguous&bslash;n&quot;
comma
id|a
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using RAM from 0 to 0x%lx&bslash;n&quot;
comma
id|total
op_minus
l_int|1
)paren
suffix:semicolon
id|phys_mem.n_regions
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
id|total
op_add_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
multiline_comment|/* record which bits the prom is using */
id|get_mem_prop
c_func
(paren
l_string|&quot;available&quot;
comma
op_amp
id|phys_avail
)paren
suffix:semicolon
id|prom_mem
op_assign
id|phys_mem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
comma
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * phys_avail records memory we can use now.&n;&t; * prom_mem records memory allocated by the prom that we&n;&t; * don&squot;t want to use now, but we&squot;ll reclaim later.&n;&t; * Make sure the kernel text/data/bss is in neither.&n;&t; */
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|_end
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allow 64k of hash table for every 16MB of memory,&n;&t; * up to a maximum of 2MB.&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|64
op_lshift
l_int|10
suffix:semicolon
id|h
OL
id|total
op_div
l_int|256
op_logical_and
id|h
OL
l_int|2
op_lshift
l_int|20
suffix:semicolon
id|h
op_mul_assign
l_int|2
)paren
suffix:semicolon
id|Hash_size
op_assign
id|h
suffix:semicolon
id|Hash_mask
op_assign
(paren
id|h
op_rshift
l_int|6
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Find some memory for the hash table. */
id|Hash
op_assign
id|find_mem_piece
c_func
(paren
id|Hash_size
comma
id|Hash_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Total memory = %ldMB; using %ldkB for hash table (at %p)&bslash;n&quot;
comma
id|total
op_rshift
l_int|20
comma
id|Hash_size
op_rshift
l_int|10
comma
id|Hash
)paren
suffix:semicolon
r_return
id|__va
c_func
(paren
id|total
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find some memory for setup_arch to return.&n; * We use the last chunk of available memory as the area&n; * that setup_arch returns, making sure that there are at&n; * least 32 pages unused before this for MMU_get_page to use.&n; */
DECL|function|find_available_memory
r_int
r_int
id|find_available_memory
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|a
comma
id|free
suffix:semicolon
r_int
r_int
id|start
comma
id|end
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
r_return
l_int|0
suffix:semicolon
id|free
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|start
op_assign
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|free
op_add_assign
(paren
id|end
op_amp
id|PAGE_MASK
)paren
op_minus
id|PAGE_ALIGN
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free
OL
l_int|32
op_star
id|PAGE_SIZE
)paren
id|a
op_add_assign
l_int|32
op_star
id|PAGE_SIZE
op_minus
id|free
suffix:semicolon
id|avail_start
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
r_return
id|avail_start
suffix:semicolon
)brace
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Free swap:       %6dkB&bslash;n&quot;
comma
id|nr_swap_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d free pages&bslash;n&quot;
comma
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|show_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET
id|show_net_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%-8s %3s %3s %8s %8s %8s %9s %8s&bslash;n&quot;
comma
l_string|&quot;Process&quot;
comma
l_string|&quot;Pid&quot;
comma
l_string|&quot;Cnt&quot;
comma
l_string|&quot;Ctx&quot;
comma
l_string|&quot;Ctx&lt;&lt;4&quot;
comma
l_string|&quot;Last Sys&quot;
comma
l_string|&quot;pc&quot;
comma
l_string|&quot;task&quot;
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%-8.8s %3d %3d %8ld %8ld %8ld %c%08lx %08lx &quot;
comma
id|p-&gt;comm
comma
id|p-&gt;pid
comma
id|p-&gt;mm-&gt;count
comma
id|p-&gt;mm-&gt;context
comma
id|p-&gt;mm-&gt;context
op_lshift
l_int|4
comma
id|p-&gt;tss.last_syscall
comma
id|user_mode
c_func
(paren
id|p-&gt;tss.regs
)paren
ques
c_cond
l_char|&squot;u&squot;
suffix:colon
l_char|&squot;k&squot;
comma
id|p-&gt;tss.regs-&gt;nip
comma
(paren
id|ulong
)paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot;current&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|last_task_used_math
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last math&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_extern
r_int
r_int
id|free_area_init
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * paging_init() sets up the page tables - in fact we&squot;ve already done this.&n; */
DECL|function|paging_init
r_int
r_int
id|paging_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
(brace
multiline_comment|/*&n;&t; * Grab some memory for bad_page and bad_pagetable to use.&n;&t; */
id|empty_bad_page
op_assign
id|start_mem
suffix:semicolon
id|empty_bad_page_table
op_assign
id|start_mem
op_plus
id|PAGE_SIZE
suffix:semicolon
id|start_mem
op_add_assign
l_int|2
op_star
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* note: free_area_init uses its second argument&n;&t;   to size the mem_map array. */
id|start_mem
op_assign
id|free_area_init
c_func
(paren
id|start_mem
comma
id|end_mem
)paren
suffix:semicolon
r_return
id|start_mem
suffix:semicolon
)brace
DECL|function|mem_init
r_void
id|mem_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|a
comma
id|lim
suffix:semicolon
r_int
id|codepages
op_assign
l_int|0
suffix:semicolon
r_int
id|datapages
op_assign
l_int|0
suffix:semicolon
r_int
id|initpages
op_assign
l_int|0
suffix:semicolon
id|end_mem
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|high_memory
op_assign
(paren
r_void
op_star
)paren
id|end_mem
suffix:semicolon
id|max_mapnr
op_assign
id|MAP_NR
c_func
(paren
id|high_memory
)paren
suffix:semicolon
id|num_physpages
op_assign
id|max_mapnr
suffix:semicolon
multiline_comment|/* RAM is assumed contiguous */
multiline_comment|/* mark usable pages in the mem_map[] */
id|start_mem
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_Pmac
)paren
(brace
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|__pa
c_func
(paren
id|avail_start
)paren
comma
id|start_mem
op_minus
id|avail_start
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
id|KERNELBASE
suffix:semicolon
id|addr
OL
id|end_mem
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|lim
op_assign
id|a
op_plus
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|a
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|lim
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|phys_avail.n_regions
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* free the prom&squot;s memory */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prom_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|prom_mem.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|lim
op_assign
id|a
op_plus
id|prom_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|a
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|lim
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|prom_trashed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/* prep */
(brace
multiline_comment|/* mark mem used by kernel as reserved, mark other unreserved */
r_for
c_loop
(paren
id|addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|addr
OL
id|end_mem
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
multiline_comment|/* skip hash table gap */
r_if
c_cond
(paren
(paren
id|addr
OG
(paren
id|ulong
)paren
id|_end
)paren
op_logical_and
(paren
id|addr
OL
(paren
id|ulong
)paren
id|Hash
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
multiline_comment|/*Hash_end*/
id|start_mem
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
r_else
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|addr
OL
id|end_mem
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|etext
)paren
id|codepages
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|__init_begin
op_logical_and
id|addr
OL
(paren
r_int
r_int
)paren
op_amp
id|__init_end
)paren
)paren
(brace
id|initpages
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|start_mem
)paren
id|datapages
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
op_logical_neg
id|initrd_start
op_logical_or
(paren
id|addr
OL
id|initrd_start
op_logical_or
id|addr
op_ge
id|initrd_end
)paren
)paren
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
id|free_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Memory: %luk available (%dk kernel code, %dk data, %dk init) [%08x,%08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|nr_free_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|codepages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|datapages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|initpages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|PAGE_OFFSET
comma
id|end_mem
)paren
suffix:semicolon
id|mem_init_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * this should reclaim gap between _end[] and hash table&n; * as well as unused mmu_pages[] on prep systems.&n; * When I get around to it, I&squot;ll put initialization functions&n; * (called only at boot) in their own .section and free that -- Cort&n; */
DECL|function|free_initmem
r_void
id|free_initmem
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|a
suffix:semicolon
r_int
r_int
id|num_freed_pages
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* free unused mmu_pages[] */
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|mmu_pages
)paren
op_plus
(paren
id|mmu_pages_count
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|mmu_pages
)paren
op_plus
(paren
id|MAX_MMU_PAGES
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|a
)paren
suffix:semicolon
id|num_freed_pages
op_increment
suffix:semicolon
)brace
id|a
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_begin
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_end
)paren
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|PG_reserved
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Freeing unused kernel memory: %ldk freed&bslash;n&quot;
comma
(paren
id|num_freed_pages
op_star
id|PAGE_SIZE
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
id|val-&gt;totalram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|buffermem
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;totalram
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;sharedram
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|val-&gt;totalram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;sharedram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|BAT0
id|BAT
id|BAT0
op_assign
(brace
(brace
l_int|0x80000000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
id|BL_256M
comma
multiline_comment|/* bl */
l_int|1
comma
multiline_comment|/* vs -- supervisor mode valid */
l_int|1
comma
multiline_comment|/* vp -- user mode valid */
)brace
comma
(brace
l_int|0x80000000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|1
comma
multiline_comment|/* write-through */
l_int|1
comma
multiline_comment|/* cache-inhibited */
l_int|0
comma
multiline_comment|/* memory coherence */
l_int|1
comma
multiline_comment|/* guarded */
id|BPP_RW
multiline_comment|/* protection */
)brace
)brace
suffix:semicolon
DECL|variable|BAT1
id|BAT
id|BAT1
op_assign
(brace
(brace
l_int|0xC0000000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
id|BL_256M
comma
multiline_comment|/* bl */
l_int|1
comma
multiline_comment|/* vs */
l_int|1
comma
multiline_comment|/* vp */
)brace
comma
(brace
l_int|0xC0000000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|1
comma
multiline_comment|/* w */
l_int|1
comma
multiline_comment|/* i (cache disabled) */
l_int|0
comma
multiline_comment|/* m */
l_int|1
comma
multiline_comment|/* g */
id|BPP_RW
multiline_comment|/* pp */
)brace
)brace
suffix:semicolon
DECL|variable|BAT2
id|BAT
id|BAT2
op_assign
(brace
(brace
l_int|0x90000000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
id|BL_256M
comma
multiline_comment|/* this gets set to amount of phys ram */
l_int|1
comma
multiline_comment|/* vs */
l_int|0
comma
multiline_comment|/* vp */
)brace
comma
(brace
l_int|0x00000000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|0
comma
multiline_comment|/* w */
l_int|0
comma
multiline_comment|/* i */
macro_line|#ifdef __SMP__    
l_int|1
comma
multiline_comment|/* m */
macro_line|#else    
l_int|0
comma
multiline_comment|/* m */
macro_line|#endif    
l_int|0
comma
multiline_comment|/* g */
id|BPP_RW
multiline_comment|/* pp */
)brace
)brace
suffix:semicolon
DECL|variable|BAT3
id|BAT
id|BAT3
op_assign
(brace
(brace
l_int|0x00000000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
id|BL_256M
comma
multiline_comment|/* bl */
l_int|0
comma
multiline_comment|/* vs */
l_int|0
comma
multiline_comment|/* vp */
)brace
comma
(brace
l_int|0x00000000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|0
comma
multiline_comment|/* w */
l_int|0
comma
multiline_comment|/* i (cache disabled) */
l_int|1
comma
multiline_comment|/* m */
l_int|0
comma
multiline_comment|/* g */
id|BPP_RW
multiline_comment|/* pp */
)brace
)brace
suffix:semicolon
DECL|variable|BAT0_601
id|P601_BAT
id|BAT0_601
op_assign
(brace
(brace
l_int|0x80000000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
l_int|1
comma
l_int|1
comma
l_int|0
comma
multiline_comment|/* wim */
l_int|1
comma
l_int|0
comma
multiline_comment|/* vs, vp */
id|BPP_RW
comma
multiline_comment|/* pp */
)brace
comma
(brace
l_int|0x80000000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|1
comma
multiline_comment|/* v */
id|BL_8M
comma
multiline_comment|/* bl */
)brace
)brace
suffix:semicolon
DECL|variable|BAT1_601
id|P601_BAT
id|BAT1_601
op_assign
(brace
(brace
l_int|0xC0000000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
l_int|1
comma
l_int|1
comma
l_int|0
comma
multiline_comment|/* wim */
l_int|1
comma
l_int|0
comma
multiline_comment|/* vs, vp */
id|BPP_RW
comma
multiline_comment|/* pp */
)brace
comma
(brace
l_int|0xC0000000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|1
comma
multiline_comment|/* v */
id|BL_8M
comma
multiline_comment|/* bl */
)brace
)brace
suffix:semicolon
DECL|variable|BAT2_601
id|P601_BAT
id|BAT2_601
op_assign
(brace
(brace
l_int|0x90000000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* wim */
l_int|1
comma
l_int|0
comma
multiline_comment|/* vs, vp */
id|BPP_RW
comma
multiline_comment|/* pp */
)brace
comma
(brace
l_int|0x00000000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|1
comma
multiline_comment|/* v */
id|BL_8M
comma
multiline_comment|/* bl */
)brace
)brace
suffix:semicolon
DECL|variable|BAT3_601
id|P601_BAT
id|BAT3_601
op_assign
(brace
(brace
l_int|0x90800000
op_rshift
l_int|17
comma
multiline_comment|/* bepi */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* wim */
l_int|1
comma
l_int|0
comma
multiline_comment|/* vs, vp */
id|BPP_RW
comma
multiline_comment|/* pp */
)brace
comma
(brace
l_int|0x00800000
op_rshift
l_int|17
comma
multiline_comment|/* brpn */
l_int|1
comma
multiline_comment|/* v */
id|BL_8M
comma
multiline_comment|/* bl */
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * This finds the amount of physical ram and does necessary&n; * setup for prep.  This is pretty architecture specific so&n; * this will likely stay seperate from the pmac.&n; * -- Cort&n; */
DECL|function|prep_find_end_of_memory
r_int
r_int
op_star
id|prep_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|h
suffix:semicolon
multiline_comment|/* setup the hash table */
r_if
c_cond
(paren
id|res.TotalMemory
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * I need a way to probe the amount of memory if the residual&n;&t;&t; * data doesn&squot;t contain it. -- Cort&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Ramsize from residual data was 0 -- Probing for value&bslash;n&quot;
)paren
suffix:semicolon
id|res.TotalMemory
op_assign
l_int|0x03000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ramsize default to be %ldM&bslash;n&quot;
comma
id|res.TotalMemory
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* linux has trouble with &gt; 64M ram -- Cort */
r_if
c_cond
(paren
id|res.TotalMemory
OG
l_int|0x04000000
multiline_comment|/* 64M */
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Only using first 64M of ram.&bslash;n&quot;
)paren
suffix:semicolon
id|res.TotalMemory
op_assign
l_int|0x04000000
suffix:semicolon
)brace
macro_line|#endif&t;
multiline_comment|/* setup the bat2 mapping to cover physical ram */
id|BAT2.batu.bl
op_assign
l_int|0x1
suffix:semicolon
multiline_comment|/* 256k mapping */
r_for
c_loop
(paren
id|h
op_assign
l_int|256
op_star
l_int|1024
multiline_comment|/* 256k */
suffix:semicolon
(paren
id|h
op_le
id|res.TotalMemory
)paren
op_logical_and
(paren
id|h
op_le
l_int|256
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
id|h
op_mul_assign
l_int|2
)paren
id|BAT2.batu.bl
op_assign
(paren
id|BAT2.batu.bl
op_lshift
l_int|1
)paren
op_or
id|BAT2.batu.bl
suffix:semicolon
multiline_comment|/*&n;&t; * Allow 64k of hash table for every 16MB of memory,&n;&t; * up to a maximum of 2MB.&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|64
op_lshift
l_int|10
suffix:semicolon
id|h
OL
id|res.TotalMemory
op_div
l_int|256
op_logical_and
id|h
OL
l_int|2
op_lshift
l_int|20
suffix:semicolon
id|h
op_mul_assign
l_int|2
)paren
suffix:semicolon
id|Hash_size
op_assign
id|h
suffix:semicolon
id|Hash_mask
op_assign
(paren
id|h
op_rshift
l_int|6
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* align htab on a Hash_size boundry above _end[] */
id|Hash
op_assign
(paren
id|PTE
op_star
)paren
id|_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|_end
comma
id|Hash_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|Hash
comma
id|Hash_size
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if this is a 601, we can only map sizes of 8M with the BAT&squot;s&n;&t; * so we have to map what we can&squot;t map with the bats with the segregs&n;&t; * head.S will copy in the appropriate BAT&squot;s according to the processor&n;&t; * since the 601_BAT{2,3} structures are already setup to map&n;&t; * the first 16M correctly&n;&t; * -- Cort&n;&t; */
macro_line|#ifndef MAP_RAM_WITH_SEGREGS     /* don&squot;t need to do it twice */
r_if
c_cond
(paren
id|_get_PVR
c_func
(paren
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* map in rest of ram with seg regs */
r_if
c_cond
(paren
id|res.TotalMemory
OG
l_int|0x01000000
multiline_comment|/* 16M */
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|KERNELBASE
op_plus
l_int|0x01000000
suffix:semicolon
id|i
OL
id|KERNELBASE
op_plus
id|res.TotalMemory
suffix:semicolon
id|i
op_add_assign
id|PAGE_SIZE
)paren
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|i
comma
id|__pa
c_func
(paren
id|i
)paren
comma
id|_PAGE_PRESENT
op_or
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_ACCESSED
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MAP_RAM_WITH_SEGREGS */
macro_line|#ifdef MAP_RAM_WITH_SEGREGS
multiline_comment|/* turn off bat mapping kernel since being done with segregs */
id|memset
c_func
(paren
op_amp
id|BAT2
comma
r_sizeof
(paren
id|BAT2
)paren
comma
l_int|0
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|BAT2_601
comma
r_sizeof
(paren
id|BAT2
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* in case we&squot;re on a 601 */
id|memset
c_func
(paren
op_amp
id|BAT3_601
comma
r_sizeof
(paren
id|BAT2
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* map all of ram for kernel with segregs */
r_for
c_loop
(paren
id|i
op_assign
id|KERNELBASE
suffix:semicolon
id|i
OL
id|KERNELBASE
op_plus
id|res.TotalMemory
suffix:semicolon
id|i
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|i
OL
(paren
r_int
r_int
)paren
id|etext
)paren
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|i
comma
id|__pa
c_func
(paren
id|i
)paren
comma
id|_PAGE_PRESENT
multiline_comment|/*| _PAGE_RW*/
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_ACCESSED
)paren
suffix:semicolon
r_else
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|i
comma
id|__pa
c_func
(paren
id|i
)paren
comma
id|_PAGE_PRESENT
op_or
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_ACCESSED
)paren
suffix:semicolon
)brace
macro_line|#endif /* MAP_RAM_WITH_SEGREGS */
id|printk
c_func
(paren
l_string|&quot;Total memory = %ldMB; using %ldkB for hash table (at %p)&bslash;n&quot;
comma
id|res.TotalMemory
op_rshift
l_int|20
comma
id|Hash_size
op_rshift
l_int|10
comma
id|Hash
)paren
suffix:semicolon
r_return
(paren
(paren
r_int
r_int
op_star
)paren
id|res.TotalMemory
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map in all of physical memory starting at KERNELBASE.&n; */
r_extern
r_int
id|n_mem_regions
suffix:semicolon
r_extern
r_struct
id|reg_property
id|mem_regions
(braket
)braket
suffix:semicolon
DECL|macro|PAGE_KERNEL_RO
mdefine_line|#define PAGE_KERNEL_RO&t;__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
DECL|function|mapin_ram
r_static
r_void
id|mapin_ram
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|v
comma
id|p
comma
id|s
comma
id|f
suffix:semicolon
id|v
op_assign
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|p
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|s
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|f
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|v
OL
id|_stext
op_logical_or
(paren
r_char
op_star
)paren
id|v
op_ge
id|etext
)paren
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
r_else
multiline_comment|/* On the powerpc, no user access forces R/W kernel access */
id|f
op_or_assign
id|_PAGE_USER
suffix:semicolon
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|v
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
)brace
DECL|macro|MAX_PROM_TRANSLATIONS
mdefine_line|#define MAX_PROM_TRANSLATIONS&t;64
DECL|variable|prom_translations
r_static
r_struct
id|translation_property
id|prom_translations
(braket
id|MAX_PROM_TRANSLATIONS
)braket
suffix:semicolon
DECL|variable|n_translations
r_int
id|n_translations
suffix:semicolon
DECL|variable|mmu_pkg
id|phandle
id|mmu_pkg
suffix:semicolon
r_extern
id|ihandle
id|prom_chosen
suffix:semicolon
DECL|function|inherit_prom_translations
r_static
r_void
id|inherit_prom_translations
c_func
(paren
)paren
(brace
r_int
id|s
comma
id|i
comma
id|f
suffix:semicolon
r_int
r_int
id|v
comma
id|p
comma
id|n
suffix:semicolon
r_struct
id|translation_property
op_star
id|tp
suffix:semicolon
id|ihandle
id|mmu_inst
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|prom_chosen
comma
l_string|&quot;mmu&quot;
comma
op_amp
id|mmu_inst
comma
r_sizeof
(paren
id|mmu_inst
)paren
)paren
op_ne
r_sizeof
(paren
id|mmu_inst
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get /chosen mmu property&quot;
)paren
suffix:semicolon
id|mmu_pkg
op_assign
id|call_prom
c_func
(paren
l_string|&quot;instance-to-package&quot;
comma
l_int|1
comma
l_int|1
comma
id|mmu_inst
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mmu_pkg
op_eq
(paren
id|phandle
)paren
op_minus
l_int|1
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get mmu package&quot;
)paren
suffix:semicolon
id|s
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|mmu_pkg
comma
l_string|&quot;translations&quot;
comma
op_amp
id|prom_translations
comma
r_sizeof
(paren
id|prom_translations
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
OL
r_sizeof
(paren
id|prom_translations
(braket
l_int|0
)braket
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get mmu translations property&quot;
)paren
suffix:semicolon
id|n_translations
op_assign
id|s
op_div
r_sizeof
(paren
id|prom_translations
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tp
op_assign
id|prom_translations
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n_translations
suffix:semicolon
op_increment
id|i
comma
op_increment
id|tp
)paren
(brace
multiline_comment|/* ignore stuff mapped down low */
r_if
c_cond
(paren
id|tp-&gt;virt
OL
l_int|0x10000000
op_logical_and
id|tp-&gt;phys
OL
l_int|0x10000000
)paren
r_continue
suffix:semicolon
multiline_comment|/* map PPC mmu flags to linux mm flags */
id|f
op_assign
(paren
id|tp-&gt;flags
op_amp
(paren
id|_PAGE_NO_CACHE
op_or
id|_PAGE_WRITETHRU
op_or
id|_PAGE_COHERENT
op_or
id|_PAGE_GUARDED
)paren
)paren
op_or
id|pgprot_val
c_func
(paren
id|PAGE_KERNEL
)paren
suffix:semicolon
multiline_comment|/* add these pages to the mappings */
id|v
op_assign
id|tp-&gt;virt
suffix:semicolon
id|p
op_assign
id|tp-&gt;phys
suffix:semicolon
id|n
op_assign
id|tp-&gt;size
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n
op_ne
l_int|0
suffix:semicolon
id|n
op_sub_assign
id|PAGE_SIZE
)paren
(brace
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|v
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Initialize the hash table and patch the instructions in head.S.&n; */
DECL|function|hash_init
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|Hash_bits
suffix:semicolon
r_extern
r_int
r_int
id|hash_page_patch_A
(braket
)braket
comma
id|hash_page_patch_B
(braket
)braket
comma
id|hash_page_patch_C
(braket
)braket
suffix:semicolon
id|memset
c_func
(paren
id|Hash
comma
l_int|0
comma
id|Hash_size
)paren
suffix:semicolon
id|Hash_end
op_assign
(paren
id|PTE
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|Hash
op_plus
id|Hash_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Patch up the instructions in head.S:hash_page&n;&t; */
id|Hash_bits
op_assign
id|ffz
c_func
(paren
op_complement
id|Hash_size
)paren
op_minus
l_int|6
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|__pa
c_func
(paren
id|Hash
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|1
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
(paren
l_int|26
op_minus
id|Hash_bits
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Hash_bits
OG
l_int|16
)paren
id|Hash_bits
op_assign
l_int|16
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|2
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|2
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
(paren
l_int|26
op_minus
id|Hash_bits
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|hash_page_patch_B
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_B
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
id|hash_page_patch_C
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_C
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the locations we&squot;ve patched have been written&n;&t; * out from the data cache and invalidated in the instruction&n;&t; * cache, on those machines with split caches.&n;&t; */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|hash_page_patch_A
comma
(paren
r_int
r_int
)paren
(paren
id|hash_page_patch_C
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do very early mm setup such as finding the size of memory&n; * and setting up the hash table.&n; * A lot of this is prep/pmac specific but a lot of it could&n; * still be merged.&n; * -- Cort&n; */
r_void
DECL|function|MMU_init
id|MMU_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_Pmac
)paren
id|end_of_DRAM
op_assign
id|pmac_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
r_else
multiline_comment|/* prep */
id|end_of_DRAM
op_assign
id|prep_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
id|hash_init
c_func
(paren
)paren
suffix:semicolon
id|_SDR1
op_assign
id|__pa
c_func
(paren
id|Hash
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_Pmac
)paren
(brace
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Copy mappings from the prom */
id|inherit_prom_translations
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
op_star
DECL|function|MMU_get_page
id|MMU_get_page
c_func
(paren
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
id|p
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get a page in MMU_get_page&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|is_prep
)paren
(brace
id|mmu_pages_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mmu_pages_count
OG
id|MAX_MMU_PAGES
)paren
id|printk
c_func
(paren
l_string|&quot;out of mmu pages!&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
id|pte
op_star
)paren
(paren
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|mmu_pages
)paren
op_plus
(paren
id|mmu_pages_count
op_plus
id|PAGE_SIZE
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* pmac */
(brace
id|p
op_assign
id|find_mem_piece
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_void
op_star
DECL|function|ioremap
id|ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|p
comma
id|end
op_assign
id|addr
op_plus
id|size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
)paren
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|p
comma
id|p
comma
id|pgprot_val
c_func
(paren
id|PAGE_KERNEL_CI
)paren
op_or
id|_PAGE_GUARDED
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
)brace
r_void
DECL|function|map_page
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;pgd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Allocate upper level page map */
id|tsk-&gt;mm-&gt;pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Use upper 10 bits of VA to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|tsk-&gt;mm-&gt;pgd
op_plus
(paren
id|va
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
(brace
multiline_comment|/* Need to allocate second-level table */
id|pg
op_assign
(paren
id|pte_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pg
suffix:semicolon
)brace
multiline_comment|/* Use middle 10 bits of VA to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|va
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg
comma
id|mk_pte_phys
c_func
(paren
id|pa
op_amp
id|PAGE_MASK
comma
id|__pgprot
c_func
(paren
id|flags
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*flush_hash_page(va &gt;&gt; 28, va);*/
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|va
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(mm, start, end) flushes a range of pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * Flush all tlb/hash table entries except for the kernel&squot;s.&n; * We use the fact that only kernel mappings use VSIDs 0 - 15.&n; */
r_void
DECL|function|flush_tlb_all
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
id|tsk-&gt;mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|get_mmu_context
c_func
(paren
id|current
)paren
suffix:semicolon
id|set_context
c_func
(paren
id|current-&gt;mm-&gt;context
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
r_void
DECL|function|flush_tlb_mm
id|flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
(brace
id|get_mmu_context
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* done by get_mmu_context() now -- Cort */
multiline_comment|/*set_context(current-&gt;mm-&gt;context);*/
)brace
)brace
multiline_comment|/* for each page addr in the range, call MMU_invalidate_page()&n;   if the range is very large and the hash table is small it might be faster to&n;   do a search of the hash table and just invalidate pages that are in the range&n;   but that&squot;s for study later.&n;        -- Cort&n;   */
r_void
DECL|function|flush_tlb_range
id|flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
op_logical_and
id|start
OL
id|TASK_SIZE
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|flush_hash_page
c_func
(paren
id|mm-&gt;context
comma
id|start
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The context counter has overflowed.&n; * We set mm-&gt;context to NO_CONTEXT for all mm&squot;s in the system.&n; * We assume we can get to all mm&squot;s by looking as tsk-&gt;mm for&n; * all tasks in the system.&n; */
r_void
DECL|function|mmu_context_overflow
id|mmu_context_overflow
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmu_context_overflow&bslash;n&quot;
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
id|tsk-&gt;mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|flush_hash_segments
c_func
(paren
l_int|0x10
comma
l_int|0xffffff
)paren
suffix:semicolon
id|next_mmu_context
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure current always has a context */
id|current-&gt;mm-&gt;context
op_assign
id|MUNGE_CONTEXT
c_func
(paren
op_increment
id|next_mmu_context
)paren
suffix:semicolon
id|set_context
c_func
(paren
id|current-&gt;mm-&gt;context
)paren
suffix:semicolon
)brace
eof
