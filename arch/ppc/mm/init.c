multiline_comment|/*&n; *  arch/ppc/mm/init.c&n; *&n; *  PowerPC version &n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)&n; *  and Cort Dougan (PReP) (cort@cs.nmt.edu)&n; *    Copyright (C) 1996 Paul Mackerras&n; *  Amiga/APUS changes by Jesper Skov (jskov@cygnus.co.uk).&n; *&n; *  Derived from &quot;arch/i386/mm/init.c&quot;&n; *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
macro_line|#include &lt;linux/blk.h&gt;&t;&t;/* for initrd_* */
macro_line|#endif
macro_line|#ifdef CONFIG_8xx
macro_line|#include &lt;asm/8xx_immap.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_MBX
macro_line|#include &lt;asm/mbx.h&gt;
macro_line|#endif
macro_line|#ifndef CONFIG_8xx
DECL|variable|_SDR1
r_int
r_int
id|_SDR1
suffix:semicolon
DECL|variable|Hash
DECL|variable|Hash_end
id|PTE
op_star
id|Hash
comma
op_star
id|Hash_end
suffix:semicolon
DECL|variable|Hash_size
DECL|variable|Hash_mask
r_int
r_int
id|Hash_size
comma
id|Hash_mask
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/* ifdef APUS specific stuff until the merge is completed. -jskov */
macro_line|#ifdef CONFIG_APUS
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#endif
DECL|variable|prom_trashed
r_int
id|prom_trashed
suffix:semicolon
DECL|variable|next_mmu_context
r_int
id|next_mmu_context
suffix:semicolon
DECL|variable|end_of_DRAM
r_int
r_int
op_star
id|end_of_DRAM
suffix:semicolon
DECL|variable|mem_init_done
r_int
id|mem_init_done
suffix:semicolon
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
)braket
suffix:semicolon
r_extern
r_char
id|_start
(braket
)braket
comma
id|_end
(braket
)braket
suffix:semicolon
r_extern
r_char
id|etext
(braket
)braket
comma
id|_stext
(braket
)braket
suffix:semicolon
r_extern
r_char
id|__init_begin
comma
id|__init_end
suffix:semicolon
r_extern
id|RESIDUAL
id|res
suffix:semicolon
DECL|variable|klimit
r_char
op_star
id|klimit
op_assign
id|_end
suffix:semicolon
DECL|variable|memory_node
r_struct
id|device_node
op_star
id|memory_node
suffix:semicolon
DECL|variable|ioremap_base
r_int
r_int
id|ioremap_base
suffix:semicolon
DECL|variable|ioremap_bot
r_int
r_int
id|ioremap_bot
suffix:semicolon
macro_line|#ifndef __SMP__
DECL|variable|quicklists
r_struct
id|pgtable_cache_struct
id|quicklists
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_8xx
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
r_static
r_void
id|mapin_ram
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|MMU_get_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|show_net_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
op_star
id|find_end_of_memory
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|current_set
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_MBX
multiline_comment|/* This is a big hack that may not yet work correctly.&n; * The MBX8xx boards have a single DIMM socket for additional memory.&n; * Although it appears you can set magical locations in the serial&n; * EEPROM to get EPPC-Bug to configure this memory, there are no tools&n; * (i.e. commands) to make this easy.  If you screw up, you will most&n; * likely end up with a board that will not boot until you find a&n; * way to program the EEPROM correctly.  I decided to simply program&n; * the memory controller here to add the additional memory.&n; * The reason this may not work correctly is that depending upon the&n; * on-board and DIMM memory size, there may be holes in the physical&n; * address space.  This is the case for me, I have a 4 MB local memory&n; * and a 32 MB DIMM.&n; * The DIMM is 64 bits wide, and we see it as two banks of 32 bit&n; * memory.  The holes are caused by the requirement to map the&n; * memory on a natural alignment, that is a 16 MB bank must begin on&n; * a 16 MB boundary.  The DIMM_SIZE below represents the size of the&n; * bank, which is the total size divided by two.&n; * Although I may not have all of this working, the intention is to&n; * mark all of the page maps in the &quot;hole&quot; as reserved, and adjust&n; * num_physpages accordingly.  In the current implementation, this&n; * seems to work, but there are some assumptions about contiguous&n; * memory.  The correct solution is to modify the memory allocators&n; * to know about holes, but that will have to wait for another day.&n; *&n; * define DIMM_8xx to enable this feature.&n; * define DIMM_SIZE to reflect the bank size (DIMM size divided by two).&n; */
multiline_comment|/*#define DIMM_8xx      1 */
DECL|macro|DIMM_SIZE
mdefine_line|#define DIMM_SIZE       (16 * 1024 * 1024)
macro_line|#endif /* CONFIG_MBX */
multiline_comment|/*&n; * this tells the system to map all of ram with the segregs&n; * (i.e. page tables) instead of the bats.&n; */
DECL|macro|MAP_RAM_WITH_SEGREGS
macro_line|#undef MAP_RAM_WITH_SEGREGS 1
multiline_comment|/* optimization for 603 to load the tlb directly from the linux table */
DECL|macro|NO_RELOAD_HTAB
mdefine_line|#define NO_RELOAD_HTAB 1 /* change in kernel/head.S too! */
DECL|function|__bad_pte
r_void
id|__bad_pte
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
)brace
DECL|function|get_pte_slow
id|pte_t
op_star
id|get_pte_slow
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|offset
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
(paren
id|pte_t
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|pte
)paren
(brace
id|clear_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pte
suffix:semicolon
r_return
id|pte
op_plus
id|offset
suffix:semicolon
)brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|__bad_pte
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * BAD_PAGE is the page that is used for page faults when linux&n; * is out-of-memory. Older versions of linux just did a&n; * do_exit(), but using this instead means there is less risk&n; * for a process dying in kernel mode, possibly leaving a inode&n; * unused etc..&n; *&n; * BAD_PAGETABLE is the accompanying page-table: it is initialized&n; * to point to BAD_PAGE entries.&n; *&n; * ZERO_PAGE is a special page that is used for zero-initialized&n; * data and COW.&n; */
DECL|variable|empty_bad_page_table
r_int
r_int
id|empty_bad_page_table
suffix:semicolon
DECL|function|__bad_pagetable
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page_table
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
(paren
id|pte_t
op_star
)paren
id|empty_bad_page_table
suffix:semicolon
)brace
DECL|variable|empty_bad_page
r_int
r_int
id|empty_bad_page
suffix:semicolon
DECL|function|__bad_page
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_bad_page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|pte_mkdirty
c_func
(paren
id|mk_pte
c_func
(paren
id|empty_bad_page
comma
id|PAGE_SHARED
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following stuff defines a data structure for representing&n; * areas of memory as an array of (address, length) pairs, and&n; * procedures for manipulating them.&n; */
DECL|macro|MAX_MEM_REGIONS
mdefine_line|#define MAX_MEM_REGIONS&t;32
DECL|struct|mem_pieces
r_struct
id|mem_pieces
(brace
DECL|member|n_regions
r_int
id|n_regions
suffix:semicolon
DECL|member|regions
r_struct
id|reg_property
id|regions
(braket
id|MAX_MEM_REGIONS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|phys_mem
r_struct
id|mem_pieces
id|phys_mem
suffix:semicolon
DECL|variable|phys_avail
r_struct
id|mem_pieces
id|phys_avail
suffix:semicolon
DECL|variable|prom_mem
r_struct
id|mem_pieces
id|prom_mem
suffix:semicolon
r_static
r_void
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_void
op_star
id|find_mem_piece
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Scan a region for a piece of a given size with the required alignment.&n; */
r_void
op_star
DECL|function|find_mem_piece
id|find_mem_piece
c_func
(paren
r_int
id|size
comma
r_int
id|align
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|a
comma
id|e
suffix:semicolon
r_struct
id|mem_pieces
op_star
id|mp
op_assign
op_amp
id|phys_avail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|e
op_assign
id|a
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
(paren
id|a
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
op_minus
id|align
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|size
op_le
id|e
)paren
(brace
id|remove_mem_piece
c_func
(paren
id|mp
comma
id|a
comma
id|size
comma
l_int|1
)paren
suffix:semicolon
r_return
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t find %u bytes at %u alignment&bslash;n&quot;
comma
id|size
comma
id|align
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove some memory from an array of pieces&n; */
r_static
r_void
DECL|function|remove_mem_piece
id|remove_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
comma
r_int
id|start
comma
r_int
id|size
comma
r_int
id|must_exist
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|end
comma
id|rs
comma
id|re
suffix:semicolon
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|rp
op_assign
id|mp-&gt;regions
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
r_if
c_cond
(paren
id|end
OG
id|rp-&gt;address
op_logical_and
id|start
OL
id|rp-&gt;address
op_plus
id|rp-&gt;size
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|mp-&gt;n_regions
)paren
(brace
r_if
c_cond
(paren
id|must_exist
)paren
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: [%x,%x) not in any region&bslash;n&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
template_param
id|rp-&gt;address
suffix:semicolon
op_increment
id|i
comma
op_increment
id|rp
)paren
(brace
id|rs
op_assign
id|rp-&gt;address
suffix:semicolon
id|re
op_assign
id|rs
op_plus
id|rp-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|must_exist
op_logical_and
(paren
id|start
template_param
id|re
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;remove_mem_piece: bad overlap [%x,%x) with&quot;
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|print_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
id|must_exist
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
OG
id|rs
)paren
(brace
id|rp-&gt;size
op_assign
id|start
op_minus
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
multiline_comment|/* need to split this entry */
r_if
c_cond
(paren
id|mp-&gt;n_regions
op_ge
id|MAX_MEM_REGIONS
)paren
id|panic
c_func
(paren
l_string|&quot;eek... mem_pieces overflow&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|mp-&gt;n_regions
suffix:semicolon
id|j
OG
id|i
op_plus
l_int|1
suffix:semicolon
op_decrement
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_minus
l_int|1
)braket
suffix:semicolon
op_increment
id|mp-&gt;n_regions
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|address
op_assign
id|end
suffix:semicolon
id|rp
(braket
l_int|1
)braket
dot
id|size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|end
OL
id|re
)paren
(brace
id|rp-&gt;address
op_assign
id|end
suffix:semicolon
id|rp-&gt;size
op_assign
id|re
op_minus
id|end
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need to delete this entry */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|mp-&gt;n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|j
)paren
id|mp-&gt;regions
(braket
id|j
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
op_decrement
id|mp-&gt;n_regions
suffix:semicolon
op_decrement
id|i
suffix:semicolon
op_decrement
id|rp
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
DECL|function|print_mem_pieces
id|print_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; [%x, %x)&quot;
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
comma
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_8xx
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|get_mem_prop
c_func
(paren
r_char
op_star
comma
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|sort_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|coalesce_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
)paren
suffix:semicolon
r_static
r_void
id|append_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
DECL|function|sort_mem_pieces
id|sort_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
r_int
id|a
comma
id|s
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|s
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
op_decrement
id|j
)paren
(brace
r_if
c_cond
(paren
id|a
op_ge
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
)paren
r_break
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
op_assign
id|mp-&gt;regions
(braket
id|j
)braket
suffix:semicolon
)brace
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|address
op_assign
id|a
suffix:semicolon
id|mp-&gt;regions
(braket
id|j
op_plus
l_int|1
)braket
dot
id|size
op_assign
id|s
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|coalesce_mem_pieces
id|coalesce_mem_pieces
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_int
r_int
id|a
comma
id|e
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|d
suffix:semicolon
id|d
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;n_regions
suffix:semicolon
id|i
op_assign
id|j
)paren
(brace
id|a
op_assign
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|e
op_assign
id|a
op_plus
id|mp-&gt;regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|mp-&gt;n_regions
op_logical_and
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
op_le
id|e
suffix:semicolon
op_increment
id|j
)paren
id|e
op_assign
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|address
op_plus
id|mp-&gt;regions
(braket
id|j
)braket
dot
id|size
suffix:semicolon
id|mp-&gt;regions
(braket
id|d
)braket
dot
id|address
op_assign
id|a
suffix:semicolon
id|mp-&gt;regions
(braket
id|d
)braket
dot
id|size
op_assign
id|e
op_minus
id|a
suffix:semicolon
op_increment
id|d
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|d
suffix:semicolon
)brace
multiline_comment|/*&n; * Add some memory to an array of pieces&n; */
r_static
r_void
DECL|function|append_mem_piece
id|append_mem_piece
c_func
(paren
r_struct
id|mem_pieces
op_star
id|mp
comma
r_int
id|start
comma
r_int
id|size
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;n_regions
op_ge
id|MAX_MEM_REGIONS
)paren
r_return
suffix:semicolon
id|rp
op_assign
op_amp
id|mp-&gt;regions
(braket
id|mp-&gt;n_regions
op_increment
)braket
suffix:semicolon
id|rp-&gt;address
op_assign
id|start
suffix:semicolon
id|rp-&gt;size
op_assign
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in a property describing some pieces of memory.&n; */
r_static
r_void
DECL|function|get_mem_prop
id|get_mem_prop
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|mem_pieces
op_star
id|mp
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_int
id|s
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|memory_node
comma
id|name
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;error: couldn&squot;t get %s property on /memory&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
id|mp-&gt;n_regions
op_assign
id|s
op_div
r_sizeof
(paren
id|mp-&gt;regions
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mp-&gt;regions
comma
id|rp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* Make sure the pieces are sorted. */
id|sort_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
id|coalesce_mem_pieces
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On systems with Open Firmware, collect information about&n; * physical RAM and which pieces are already in use.&n; * At this point, we have (at least) the first 8MB mapped with a BAT.&n; * Our text, data, bss use something over 1MB, starting at 0.&n; * Open Firmware may be using 1MB at the 4MB point.&n; */
DECL|function|pmac_find_end_of_memory
r_int
r_int
op_star
id|pmac_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|a
comma
id|total
suffix:semicolon
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memory_node
op_assign
id|find_devices
c_func
(paren
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memory_node
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;can&squot;t find memory node&bslash;n&quot;
)paren
suffix:semicolon
m_abort
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find out where physical memory is, and check that it&n;&t; * starts at 0 and is contiguous.  It seems that RAM is&n;&t; * always physically contiguous on Power Macintoshes,&n;&t; * because MacOS can&squot;t cope if it isn&squot;t.&n;&t; *&n;&t; * Supporting discontiguous physical memory isn&squot;t hard,&n;&t; * it just makes the virtual &lt;-&gt; physical mapping functions&n;&t; * more complicated (or else you end up wasting space&n;&t; * in mem_map).&n;&t; */
id|get_mem_prop
c_func
(paren
l_string|&quot;reg&quot;
comma
op_amp
id|phys_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.n_regions
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;No RAM??&quot;
)paren
suffix:semicolon
id|a
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_if
c_cond
(paren
id|a
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;RAM doesn&squot;t start at physical address 0&quot;
)paren
suffix:semicolon
id|total
op_assign
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|phys_mem.n_regions
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAM starting at 0x%x is not contiguous&bslash;n&quot;
comma
id|phys_mem.regions
(braket
l_int|1
)braket
dot
id|address
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Using RAM from 0 to 0x%lx&bslash;n&quot;
comma
id|total
op_minus
l_int|1
)paren
suffix:semicolon
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* record which bits the prom is using */
id|get_mem_prop
c_func
(paren
l_string|&quot;available&quot;
comma
op_amp
id|phys_avail
)paren
suffix:semicolon
id|prom_mem
op_assign
id|phys_mem
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
comma
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * phys_avail records memory we can use now.&n;&t; * prom_mem records memory allocated by the prom that we&n;&t; * don&squot;t want to use now, but we&squot;ll reclaim later.&n;&t; * Make sure the kernel text/data/bss is in neither.&n;&t; */
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|klimit
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
l_int|0
comma
l_int|0x4000
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|prom_mem
comma
l_int|0
comma
l_int|0x4000
comma
l_int|0
)paren
suffix:semicolon
r_return
id|__va
c_func
(paren
id|total
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_8xx */
macro_line|#ifdef CONFIG_APUS
DECL|macro|HARDWARE_MAPPED_SIZE
mdefine_line|#define HARDWARE_MAPPED_SIZE (512*1024)
DECL|function|apus_find_end_of_memory
r_int
r_int
op_star
id|apus_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
multiline_comment|/* Add the chunk that ADOS does not see. Removed again below. */
id|m68k_memory
(braket
l_int|0
)braket
dot
id|size
op_add_assign
id|HARDWARE_MAPPED_SIZE
suffix:semicolon
id|append_mem_piece
c_func
(paren
op_amp
id|phys_mem
comma
id|m68k_memory
(braket
l_int|0
)braket
dot
id|addr
comma
id|m68k_memory
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
id|phys_avail
op_assign
id|phys_mem
suffix:semicolon
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|klimit
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Remove the upper HARDWARE_MAPPED_SIZE bytes where the address&n;&t; * range 0xfff00000-0xfffx0000 is mapped to.&n;&t; * We do it this way to ensure that the memory registered in the&n;&t; * system has a power-of-two size.&n;&t; */
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
(paren
id|m68k_memory
(braket
l_int|0
)braket
dot
id|addr
op_plus
id|m68k_memory
(braket
l_int|0
)braket
dot
id|size
op_minus
id|HARDWARE_MAPPED_SIZE
)paren
comma
id|HARDWARE_MAPPED_SIZE
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* FIXME:APUS: Only handles one block of memory! Problem is&n;&t; * that the VTOP/PTOV code in head.S would be a mess if it had&n;&t; * to handle more than one block.&n;&t; */
r_return
id|__va
c_func
(paren
id|m68k_memory
(braket
l_int|0
)braket
dot
id|addr
op_plus
id|m68k_memory
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Find some memory for setup_arch to return.&n; * We use the last chunk of available memory as the area&n; * that setup_arch returns, making sure that there are at&n; * least 32 pages unused before this for MMU_get_page to use.&n; */
DECL|variable|avail_start
r_int
r_int
id|avail_start
suffix:semicolon
DECL|function|find_available_memory
r_int
r_int
id|find_available_memory
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|a
comma
id|free
suffix:semicolon
r_int
r_int
id|start
comma
id|end
suffix:semicolon
id|free
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_mbx
)paren
(brace
multiline_comment|/* Return the first, not the last region, because we&n;                 * may not yet have properly initialized the additonal&n;                 * memory DIMM.&n;                 */
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|phys_avail.regions
(braket
l_int|0
)braket
dot
id|address
)paren
suffix:semicolon
id|avail_start
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
r_return
id|avail_start
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|start
op_assign
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|free
op_add_assign
(paren
id|end
op_amp
id|PAGE_MASK
)paren
op_minus
id|PAGE_ALIGN
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free
OL
l_int|32
op_star
id|PAGE_SIZE
)paren
id|a
op_add_assign
l_int|32
op_star
id|PAGE_SIZE
op_minus
id|free
suffix:semicolon
id|avail_start
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|a
)paren
suffix:semicolon
r_return
id|avail_start
suffix:semicolon
)brace
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
op_assign
l_int|0
comma
id|cached
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Free swap:       %6dkB&bslash;n&quot;
comma
id|nr_swap_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|cached
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d free pages&bslash;n&quot;
comma
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages swap cached&bslash;n&quot;
comma
id|cached
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d pages in page table cache&bslash;n&quot;
comma
(paren
r_int
)paren
id|pgtable_cache_size
)paren
suffix:semicolon
id|show_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NET
id|show_net_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%-8s %3s %3s %8s %8s %8s %9s %8s&quot;
comma
l_string|&quot;Process&quot;
comma
l_string|&quot;Pid&quot;
comma
l_string|&quot;Cnt&quot;
comma
l_string|&quot;Ctx&quot;
comma
l_string|&quot;Ctx&lt;&lt;4&quot;
comma
l_string|&quot;Last Sys&quot;
comma
l_string|&quot;pc&quot;
comma
l_string|&quot;task&quot;
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
id|printk
c_func
(paren
l_string|&quot; %3s&quot;
comma
l_string|&quot;CPU&quot;
)paren
suffix:semicolon
macro_line|#endif /* __SMP__ */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%-8.8s %3d %3d %8ld %8ld %8ld %c%08lx %08lx &quot;
comma
id|p-&gt;comm
comma
id|p-&gt;pid
comma
id|p-&gt;mm-&gt;count
comma
id|p-&gt;mm-&gt;context
comma
id|p-&gt;mm-&gt;context
op_lshift
l_int|4
comma
id|p-&gt;tss.last_syscall
comma
id|user_mode
c_func
(paren
id|p-&gt;tss.regs
)paren
ques
c_cond
l_char|&squot;u&squot;
suffix:colon
l_char|&squot;k&squot;
comma
id|p-&gt;tss.regs-&gt;nip
comma
(paren
id|ulong
)paren
id|p
)paren
suffix:semicolon
(brace
r_int
id|iscur
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __SMP__
id|printk
c_func
(paren
l_string|&quot;%3d &quot;
comma
id|p-&gt;processor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;processor
op_ne
id|NO_PROC_ID
)paren
op_logical_and
(paren
id|p
op_eq
id|current_set
(braket
id|p-&gt;processor
)braket
)paren
)paren
macro_line|#else&t;&t;
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
macro_line|#endif /* __SMP__ */
(brace
id|iscur
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|last_task_used_math
)paren
(brace
r_if
c_cond
(paren
id|iscur
)paren
id|printk
c_func
(paren
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last math&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_extern
r_int
r_int
id|free_area_init
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * paging_init() sets up the page tables - in fact we&squot;ve already done this.&n; */
DECL|function|paging_init
r_int
r_int
id|paging_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
(brace
multiline_comment|/*&n;&t; * Grab some memory for bad_page and bad_pagetable to use.&n;&t; */
id|empty_bad_page
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start_mem
)paren
suffix:semicolon
id|empty_bad_page_table
op_assign
id|empty_bad_page
op_plus
id|PAGE_SIZE
suffix:semicolon
id|start_mem
op_assign
id|empty_bad_page
op_plus
l_int|2
op_star
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* note: free_area_init uses its second argument&n;&t;   to size the mem_map array. */
id|start_mem
op_assign
id|free_area_init
c_func
(paren
id|start_mem
comma
id|end_mem
)paren
suffix:semicolon
r_return
id|start_mem
suffix:semicolon
)brace
DECL|function|mem_init
r_void
id|mem_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|a
comma
id|lim
suffix:semicolon
r_int
id|codepages
op_assign
l_int|0
suffix:semicolon
r_int
id|datapages
op_assign
l_int|0
suffix:semicolon
r_int
id|initpages
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
r_int
id|rtas_data
comma
id|rtas_size
suffix:semicolon
id|end_mem
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|high_memory
op_assign
(paren
r_void
op_star
)paren
id|end_mem
suffix:semicolon
id|max_mapnr
op_assign
id|MAP_NR
c_func
(paren
id|high_memory
)paren
suffix:semicolon
id|num_physpages
op_assign
id|max_mapnr
suffix:semicolon
multiline_comment|/* RAM is assumed contiguous */
multiline_comment|/* mark usable pages in the mem_map[] */
id|start_mem
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start_mem
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|__pa
c_func
(paren
id|avail_start
)paren
comma
id|start_mem
op_minus
id|avail_start
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|addr
OL
id|end_mem
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
id|set_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|lim
op_assign
id|a
op_plus
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|a
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|lim
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|phys_avail.n_regions
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* free the prom&squot;s memory - no-op on prep */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prom_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|prom_mem.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|lim
op_assign
id|a
op_plus
id|prom_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|a
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|lim
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|prom_trashed
op_assign
l_int|1
suffix:semicolon
macro_line|#else /* CONFIG_8xx */
multiline_comment|/* When we get here, all of the page maps have been set up and&n;         * Linux thinks we have contiguous memory.  Since the MBX can&n;         * have memory holes, we need to compensate for that here.&n;         * The memory holes are currently pages marked reserved (all&n;         * pages right now are marked reserved).&n;         * All of the memory allocated by the kernel up to this point&n;         * had to come from region 0.&n;         */
multiline_comment|/* First, unreserve all memory from the page following start_mem&n;         * to the end of region 0.&n;         */
r_for
c_loop
(paren
id|addr
op_assign
id|start_mem
op_plus
id|PAGE_SIZE
suffix:semicolon
id|addr
OL
(paren
id|ulong
)paren
id|__va
c_func
(paren
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Now add any additional regions to the system.&n;        */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|phys_avail.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|phys_avail.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|lim
op_assign
id|a
op_plus
id|phys_avail.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|a
op_assign
id|PAGE_ALIGN
c_func
(paren
id|a
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
id|lim
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
)brace
id|phys_avail.n_regions
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Nothing available, kernel owns */
multiline_comment|/* Count up the size of the holes.  We look for the space&n;         * between the end of one region and the start of the next.&n;         */
id|lim
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|a
op_add_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|lim
op_add_assign
id|phys_mem.regions
(braket
id|i
op_plus
l_int|1
)braket
dot
id|address
op_minus
id|a
suffix:semicolon
)brace
multiline_comment|/* It appears that num_physpages is only used for quota checking,&n;         * when pages are locked down.  We subtract the size of the holes&n;         * from it now.&n;         */
id|num_physpages
op_sub_assign
id|lim
op_div
id|PAGE_SIZE
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
r_for
c_loop
(paren
id|addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|addr
OL
id|end_mem
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|etext
)paren
id|codepages
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|__init_begin
op_logical_and
id|addr
OL
(paren
r_int
r_int
)paren
op_amp
id|__init_end
)paren
id|initpages
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
OL
(paren
id|ulong
)paren
id|start_mem
)paren
id|datapages
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
op_logical_neg
id|initrd_start
op_logical_or
id|addr
OL
(paren
id|initrd_start
op_amp
id|PAGE_MASK
)paren
op_logical_or
id|addr
op_ge
id|initrd_end
)paren
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
macro_line|#ifndef CONFIG_8xx&t;&t;  
r_if
c_cond
(paren
op_logical_neg
id|rtas_data
op_logical_or
id|addr
OL
(paren
id|rtas_data
op_amp
id|PAGE_MASK
)paren
op_logical_or
id|addr
op_ge
(paren
id|rtas_data
op_plus
id|rtas_size
)paren
)paren
macro_line|#endif /* CONFIG_8xx */
id|free_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Memory: %luk available (%dk kernel code, %dk data, %dk init) [%08x,%08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|nr_free_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|codepages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|datapages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|initpages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|PAGE_OFFSET
comma
id|end_mem
)paren
suffix:semicolon
id|mem_init_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Unfortunately, we can&squot;t put initialization functions in their&n; * own section and free that at this point, because gas gets some&n; * relocations wrong if we do. :-(  But this code is here for when&n; * gas gets fixed.&n; */
DECL|function|free_initmem
r_void
id|free_initmem
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|a
suffix:semicolon
r_int
r_int
id|num_freed_pages
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_begin
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|a
OL
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_end
)paren
suffix:semicolon
id|a
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|clear_bit
c_func
(paren
id|PG_reserved
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|a
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|a
)paren
suffix:semicolon
id|num_freed_pages
op_increment
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Freeing unused kernel memory: %ldk freed&bslash;n&quot;
comma
(paren
id|num_freed_pages
op_star
id|PAGE_SIZE
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
id|val-&gt;totalram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|buffermem
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;totalram
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
)paren
r_continue
suffix:semicolon
id|val-&gt;sharedram
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
dot
id|count
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|val-&gt;totalram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;sharedram
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_8xx
DECL|union|ubat
r_union
id|ubat
(brace
multiline_comment|/* BAT register values to be loaded */
DECL|member|bat
id|BAT
id|bat
suffix:semicolon
DECL|member|bat_601
id|P601_BAT
id|bat_601
suffix:semicolon
DECL|member|word
id|u32
id|word
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|BATS
)brace
id|BATS
(braket
l_int|4
)braket
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* 4 pairs of IBAT, DBAT */
DECL|struct|batrange
r_struct
id|batrange
(brace
multiline_comment|/* stores address ranges mapped by BATs */
DECL|member|start
r_int
r_int
id|start
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
DECL|member|phys
r_int
r_int
id|phys
suffix:semicolon
DECL|variable|bat_addrs
)brace
id|bat_addrs
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n; * Set up one of the I/D BAT (block address translation) register pairs.&n; * The parameters are not checked; in particular size must be a power&n; * of 2 between 128k and 256M.&n; */
r_void
DECL|function|setbat
id|setbat
c_func
(paren
r_int
id|index
comma
r_int
r_int
id|virt
comma
r_int
r_int
id|phys
comma
r_int
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|bl
suffix:semicolon
r_int
id|wimgxpp
suffix:semicolon
r_union
id|ubat
op_star
id|bat
op_assign
id|BATS
(braket
id|index
)braket
suffix:semicolon
id|bl
op_assign
(paren
id|size
op_rshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* 603, 604, etc. */
multiline_comment|/* Do DBAT first */
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
op_or
id|_PAGE_GUARDED
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
id|BPP_RW
suffix:colon
id|BPP_RX
suffix:semicolon
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
(paren
id|bl
op_lshift
l_int|2
)paren
op_or
l_int|2
suffix:semicolon
multiline_comment|/* Vs=1, Vp=0 */
id|bat
(braket
l_int|1
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|wimgxpp
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
id|bat
(braket
l_int|1
)braket
dot
id|bat.batu.vp
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|_PAGE_GUARDED
)paren
(brace
multiline_comment|/* G bit must be zero in IBATs */
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|0
)braket
dot
id|word
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* make IBAT same as DBAT */
id|bat
(braket
l_int|0
)braket
op_assign
id|bat
(braket
l_int|1
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* 601 cpu */
r_if
c_cond
(paren
id|bl
OG
id|BL_8M
)paren
id|bl
op_assign
id|BL_8M
suffix:semicolon
id|wimgxpp
op_assign
id|flags
op_amp
(paren
id|_PAGE_WRITETHRU
op_or
id|_PAGE_NO_CACHE
op_or
id|_PAGE_COHERENT
)paren
suffix:semicolon
id|wimgxpp
op_or_assign
(paren
id|flags
op_amp
id|_PAGE_RW
)paren
ques
c_cond
(paren
(paren
id|flags
op_amp
id|_PAGE_USER
)paren
ques
c_cond
id|PP_RWRW
suffix:colon
id|PP_RWXX
)paren
suffix:colon
id|PP_RXRX
suffix:semicolon
id|bat-&gt;word
(braket
l_int|0
)braket
op_assign
id|virt
op_or
id|wimgxpp
op_or
l_int|4
suffix:semicolon
multiline_comment|/* Ks=0, Ku=1 */
id|bat-&gt;word
(braket
l_int|1
)braket
op_assign
id|phys
op_or
id|bl
op_or
l_int|0x40
suffix:semicolon
multiline_comment|/* V=1 */
)brace
id|bat_addrs
(braket
id|index
)braket
dot
id|start
op_assign
id|virt
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|limit
op_assign
id|virt
op_plus
(paren
(paren
id|bl
op_plus
l_int|1
)paren
op_lshift
l_int|17
)paren
op_minus
l_int|1
suffix:semicolon
id|bat_addrs
(braket
id|index
)braket
dot
id|phys
op_assign
id|phys
suffix:semicolon
)brace
DECL|macro|IO_PAGE
mdefine_line|#define IO_PAGE&t;(_PAGE_NO_CACHE | _PAGE_GUARDED | _PAGE_RW)
macro_line|#ifdef __SMP__
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_COHERENT | _PAGE_RW)
macro_line|#else
DECL|macro|RAM_PAGE
mdefine_line|#define RAM_PAGE (_PAGE_RW)
macro_line|#endif
multiline_comment|/*&n; * This finds the amount of physical ram and does necessary&n; * setup for prep.  This is pretty architecture specific so&n; * this will likely stay seperate from the pmac.&n; * -- Cort&n; */
DECL|function|prep_find_end_of_memory
r_int
r_int
op_star
id|prep_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
r_int
r_int
id|total
suffix:semicolon
id|total
op_assign
id|res.TotalMemory
suffix:semicolon
r_if
c_cond
(paren
id|total
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * I need a way to probe the amount of memory if the residual&n;&t;&t; * data doesn&squot;t contain it. -- Cort&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Ramsize from residual data was 0 -- Probing for value&bslash;n&quot;
)paren
suffix:semicolon
id|total
op_assign
l_int|0x02000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ramsize default to be %ldM&bslash;n&quot;
comma
id|total
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
id|append_mem_piece
c_func
(paren
op_amp
id|phys_mem
comma
l_int|0
comma
id|total
)paren
suffix:semicolon
id|phys_avail
op_assign
id|phys_mem
suffix:semicolon
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|klimit
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
l_int|0
comma
l_int|0x4000
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|__va
c_func
(paren
id|total
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/*&n; * Map in all of physical memory starting at KERNELBASE.&n; */
DECL|macro|PAGE_KERNEL_RO
mdefine_line|#define PAGE_KERNEL_RO&t;__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
DECL|function|mapin_ram
r_static
r_void
id|mapin_ram
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|v
comma
id|p
comma
id|s
comma
id|f
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
r_int
id|tot
comma
id|mem_base
comma
id|bl
comma
id|done
suffix:semicolon
macro_line|#ifndef MAP_RAM_WITH_SEGREGS
multiline_comment|/* Set up BAT2 and if necessary BAT3 to cover RAM. */
id|tot
op_assign
(paren
r_int
r_int
)paren
id|end_of_DRAM
op_minus
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
l_int|256
op_lshift
l_int|20
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
id|mem_base
op_assign
id|__pa
c_func
(paren
id|KERNELBASE
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|2
comma
id|KERNELBASE
comma
id|mem_base
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
id|done
op_assign
(paren
r_int
r_int
)paren
id|bat_addrs
(braket
l_int|2
)braket
dot
id|limit
op_minus
id|KERNELBASE
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|done
OL
id|tot
)paren
(brace
multiline_comment|/* use BAT3 to cover a bit more */
id|tot
op_sub_assign
id|done
suffix:semicolon
r_for
c_loop
(paren
id|bl
op_assign
l_int|128
op_lshift
l_int|10
suffix:semicolon
id|bl
OL
l_int|256
op_lshift
l_int|20
suffix:semicolon
id|bl
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|bl
op_star
l_int|2
OG
id|tot
)paren
r_break
suffix:semicolon
id|setbat
c_func
(paren
l_int|3
comma
id|KERNELBASE
op_plus
id|done
comma
id|mem_base
op_plus
id|done
comma
id|bl
comma
id|RAM_PAGE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|v
op_assign
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|p
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|s
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|f
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
suffix:semicolon
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|v
OL
id|_stext
op_logical_or
(paren
r_char
op_star
)paren
id|v
op_ge
id|etext
)paren
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
r_else
multiline_comment|/* On the powerpc, no user access&n;&t;&t;&t;&t;   forces R/W kernel access */
id|f
op_or_assign
id|_PAGE_USER
suffix:semicolon
macro_line|#else&t;/* CONFIG_8xx */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|phys_mem.n_regions
suffix:semicolon
op_increment
id|i
)paren
(brace
id|v
op_assign
(paren
id|ulong
)paren
id|__va
c_func
(paren
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
id|p
op_assign
id|phys_mem.regions
(braket
id|i
)braket
dot
id|address
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
l_int|0
suffix:semicolon
id|s
OL
id|phys_mem.regions
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|s
op_add_assign
id|PAGE_SIZE
)paren
(brace
multiline_comment|/* On the MPC8xx, we want the page shared so we&n;                         * don&squot;t get ASID compares on kernel space.&n;                         */
id|f
op_assign
id|_PAGE_PRESENT
op_or
id|_PAGE_ACCESSED
op_or
id|_PAGE_SHARED
suffix:semicolon
multiline_comment|/* I don&squot;t really need the rest of this code, but&n;                         * I grabbed it because I think the line:&n;                         *      f |= _PAGE_USER&n;                         * is incorrect.  It needs to be set to bits we&n;                         * don&squot;t define to cause a kernel read-only.  On&n;                         * the MPC8xx, the PAGE_DIRTY takes care of that&n;                         * for us (along with the RW software state).&n;                         */
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|v
OL
id|_stext
op_logical_or
(paren
r_char
op_star
)paren
id|v
op_ge
id|etext
)paren
id|f
op_or_assign
id|_PAGE_RW
op_or
id|_PAGE_DIRTY
op_or
id|_PAGE_HWWRITE
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|v
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|p
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifndef CONFIG_8xx
multiline_comment|/*&n; * Initialize the hash table and patch the instructions in head.S.&n; */
DECL|function|hash_init
r_static
r_void
id|hash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|Hash_bits
suffix:semicolon
r_int
r_int
id|h
comma
id|ramsize
suffix:semicolon
r_extern
r_int
r_int
id|hash_page_patch_A
(braket
)braket
comma
id|hash_page_patch_B
(braket
)braket
comma
id|hash_page_patch_C
(braket
)braket
comma
id|hash_page_patch_D
(braket
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Allow 64k of hash table for every 16MB of memory,&n;&t; * up to a maximum of 2MB.&n;&t; */
id|ramsize
op_assign
(paren
id|ulong
)paren
id|end_of_DRAM
op_minus
id|KERNELBASE
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|64
op_lshift
l_int|10
suffix:semicolon
id|h
OL
id|ramsize
op_div
l_int|256
op_logical_and
id|h
OL
l_int|2
op_lshift
l_int|20
suffix:semicolon
id|h
op_mul_assign
l_int|2
)paren
suffix:semicolon
id|Hash_size
op_assign
id|h
suffix:semicolon
id|Hash_mask
op_assign
(paren
id|h
op_rshift
l_int|6
)paren
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef NO_RELOAD_HTAB
multiline_comment|/* shrink the htab since we don&squot;t use it on 603&squot;s -- Cort */
r_switch
c_cond
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
(brace
r_case
l_int|3
suffix:colon
multiline_comment|/* 603 */
r_case
l_int|6
suffix:colon
multiline_comment|/* 603e */
r_case
l_int|7
suffix:colon
multiline_comment|/* 603ev */
id|Hash_size
op_assign
l_int|0
suffix:semicolon
id|Hash_mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* on 601/4 let things be */
r_break
suffix:semicolon
)brace
macro_line|#endif /* NO_RELOAD_HTAB */
multiline_comment|/* Find some memory for the hash table. */
r_if
c_cond
(paren
id|Hash_size
)paren
id|Hash
op_assign
id|find_mem_piece
c_func
(paren
id|Hash_size
comma
id|Hash_size
)paren
suffix:semicolon
r_else
id|Hash
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Total memory = %ldMB; using %ldkB for hash table (at %p)&bslash;n&quot;
comma
id|ramsize
op_rshift
l_int|20
comma
id|Hash_size
op_rshift
l_int|10
comma
id|Hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Hash_size
)paren
(brace
id|memset
c_func
(paren
id|Hash
comma
l_int|0
comma
id|Hash_size
)paren
suffix:semicolon
id|Hash_end
op_assign
(paren
id|PTE
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|Hash
op_plus
id|Hash_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Patch up the instructions in head.S:hash_page&n;&t;&t; */
id|Hash_bits
op_assign
id|ffz
c_func
(paren
op_complement
id|Hash_size
)paren
op_minus
l_int|6
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|__pa
c_func
(paren
id|Hash
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|1
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
(paren
l_int|26
op_minus
id|Hash_bits
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Hash_bits
OG
l_int|16
)paren
id|Hash_bits
op_assign
l_int|16
suffix:semicolon
id|hash_page_patch_A
(braket
l_int|2
)braket
op_assign
(paren
id|hash_page_patch_A
(braket
l_int|2
)braket
op_amp
op_complement
l_int|0x7c0
)paren
op_or
(paren
(paren
l_int|26
op_minus
id|Hash_bits
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|hash_page_patch_B
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_B
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
id|hash_page_patch_C
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_C
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
id|hash_page_patch_D
(braket
l_int|0
)braket
op_assign
(paren
id|hash_page_patch_D
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0xffff
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ensure that the locations we&squot;ve patched have been written&n;&t;&t; * out from the data cache and invalidated in the instruction&n;&t;&t; * cache, on those machines with split caches.&n;&t;&t; */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|hash_page_patch_A
comma
(paren
r_int
r_int
)paren
(paren
id|hash_page_patch_D
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
id|Hash_end
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/*&n; * Do very early mm setup such as finding the size of memory&n; * and setting up the hash table.&n; * A lot of this is prep/pmac specific but a lot of it could&n; * still be merged.&n; * -- Cort&n; */
r_void
DECL|function|MMU_init
id|MMU_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_if
c_cond
(paren
id|have_of
)paren
id|end_of_DRAM
op_assign
id|pmac_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_APUS
r_else
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_apus
)paren
id|end_of_DRAM
op_assign
id|apus_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_else
multiline_comment|/* prep */
id|end_of_DRAM
op_assign
id|prep_find_end_of_memory
c_func
(paren
)paren
suffix:semicolon
id|hash_init
c_func
(paren
)paren
suffix:semicolon
id|_SDR1
op_assign
id|__pa
c_func
(paren
id|Hash
)paren
op_or
(paren
id|Hash_mask
op_rshift
l_int|10
)paren
suffix:semicolon
id|ioremap_base
op_assign
l_int|0xf8000000
suffix:semicolon
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the bat mappings we&squot;re going to load that cover&n;&t; * the io areas.  RAM was mapped by mapin_ram().&n;&t; * -- Cort&n;&t; */
r_switch
c_cond
(paren
id|_machine
)paren
(brace
r_case
id|_MACH_prep
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0x80000000
comma
l_int|0x80000000
comma
l_int|0x10000000
comma
id|IO_PAGE
op_plus
(paren
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
ques
c_cond
id|_PAGE_USER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|setbat
c_func
(paren
l_int|1
comma
l_int|0xd0000000
comma
l_int|0xc0000000
comma
l_int|0x10000000
comma
id|IO_PAGE
op_plus
(paren
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
ques
c_cond
id|_PAGE_USER
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_chrp
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf8000000
comma
l_int|0xf8000000
comma
l_int|0x20000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_MACH_Pmac
suffix:colon
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xf3000000
comma
l_int|0xf3000000
comma
l_int|0x100000
comma
id|IO_PAGE
)paren
suffix:semicolon
id|ioremap_base
op_assign
l_int|0xf0000000
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_APUS
r_case
id|_MACH_apus
suffix:colon
multiline_comment|/* Map Cyberstorm PPC registers. */
multiline_comment|/* FIXME:APUS: Performance penalty here. Restrict it&n;&t;&t; *             to the Cyberstorm registers.&n;&t;&t; */
id|setbat
c_func
(paren
l_int|0
comma
l_int|0xfff00000
comma
l_int|0xfff00000
comma
l_int|0x00080000
comma
id|IO_PAGE
)paren
suffix:semicolon
multiline_comment|/* Map chip and ZorroII memory */
id|setbat
c_func
(paren
l_int|1
comma
id|zTwoBase
comma
l_int|0x00000000
comma
l_int|0x01000000
comma
id|IO_PAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
id|ioremap_bot
op_assign
id|ioremap_base
suffix:semicolon
macro_line|#else /* CONFIG_8xx */
multiline_comment|/* Map in all of RAM starting at KERNELBASE */
id|mapin_ram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now map in some of the I/O space that is generically needed&n;         * or shared with multiple devices.&n;         * All of this fits into the same 4Mbyte region, so it only&n;         * requires one page table page.&n;         */
id|ioremap
c_func
(paren
id|NVRAM_ADDR
comma
id|NVRAM_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|MBX_CSR_ADDR
comma
id|MBX_CSR_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|MBX_IMAP_ADDR
comma
id|MBX_IMAP_SIZE
)paren
suffix:semicolon
id|ioremap
c_func
(paren
id|PCI_CSR_ADDR
comma
id|PCI_CSR_SIZE
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
)brace
r_static
r_void
op_star
DECL|function|MMU_get_page
id|MMU_get_page
c_func
(paren
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
id|p
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;couldn&squot;t get a page in MMU_get_page&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|find_mem_piece
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_void
op_star
DECL|function|ioremap
id|ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|__ioremap
c_func
(paren
id|addr
comma
id|size
comma
id|_PAGE_NO_CACHE
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|__ioremap
id|__ioremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|p
comma
id|v
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Choose an address to map it to.&n;&t; * Once the vmalloc system is running, we use it.&n;&t; * Before then, we map addresses &gt;= ioremap_base&n;&t; * virt == phys; for addresses below this we use&n;&t; * space going down from ioremap_base (ioremap_bot&n;&t; * records where we&squot;re up to).&n;&t; *&n;&t; * We should also look out for a frame buffer and&n;&t; * map it with a free BAT register, if there is one.&n;&t; */
id|p
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
op_plus
id|size
)paren
op_minus
id|p
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
(brace
r_struct
id|vm_struct
op_star
id|area
suffix:semicolon
id|area
op_assign
id|get_vm_area
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|v
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|area-&gt;addr
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p
op_ge
id|ioremap_base
)paren
id|v
op_assign
id|p
suffix:semicolon
r_else
id|v
op_assign
(paren
id|ioremap_bot
op_sub_assign
id|size
)paren
suffix:semicolon
)brace
id|flags
op_or_assign
id|pgprot_val
c_func
(paren
id|PAGE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|_PAGE_NO_CACHE
op_or
id|_PAGE_WRITETHRU
)paren
)paren
id|flags
op_or_assign
id|_PAGE_GUARDED
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_add_assign
id|PAGE_SIZE
)paren
id|map_page
c_func
(paren
op_amp
id|init_task
comma
id|v
op_plus
id|i
comma
id|p
op_plus
id|i
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
(paren
id|v
op_plus
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
DECL|function|iounmap
r_void
id|iounmap
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
multiline_comment|/* XXX todo */
)brace
DECL|function|iopa
r_int
r_int
id|iopa
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|idx
suffix:semicolon
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
id|b
suffix:semicolon
macro_line|#endif
id|idx
op_assign
id|addr
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|addr
op_assign
id|addr
op_amp
id|PAGE_MASK
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
multiline_comment|/* Check the BATs */
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
r_if
c_cond
(paren
id|addr
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|addr
op_le
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
r_return
id|bat_addrs
(braket
id|b
)braket
dot
id|phys
op_or
id|idx
suffix:semicolon
macro_line|#endif /* CONFIG_8xx */
multiline_comment|/* Do we have a page table? */
r_if
c_cond
(paren
id|init_task.mm-&gt;pgd
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use upper 10 bits of addr to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|init_task.mm-&gt;pgd
op_plus
(paren
id|addr
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use middle 10 bits of addr to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|addr
)paren
suffix:semicolon
r_return
(paren
id|pte_val
c_func
(paren
op_star
id|pg
)paren
op_amp
id|PAGE_MASK
)paren
op_or
id|idx
suffix:semicolon
)brace
r_void
DECL|function|map_page
id|map_page
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|va
comma
r_int
r_int
id|pa
comma
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pd
suffix:semicolon
id|pte_t
op_star
id|pg
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
r_int
id|b
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;pgd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Allocate upper level page map */
id|tsk-&gt;mm-&gt;pgd
op_assign
(paren
id|pgd_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Use upper 10 bits of VA to index the first level map */
id|pd
op_assign
(paren
id|pmd_t
op_star
)paren
(paren
id|tsk-&gt;mm-&gt;pgd
op_plus
(paren
id|va
op_rshift
id|PGDIR_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pd
)paren
)paren
(brace
macro_line|#ifndef CONFIG_8xx
multiline_comment|/*&n;&t;&t; * Need to allocate second-level table, but first&n;&t;&t; * check whether this address is already mapped by&n;&t;&t; * the BATs; if so, don&squot;t bother allocating the page.&n;&t;&t; */
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|4
suffix:semicolon
op_increment
id|b
)paren
(brace
r_if
c_cond
(paren
id|va
op_ge
id|bat_addrs
(braket
id|b
)braket
dot
id|start
op_logical_and
id|va
op_le
id|bat_addrs
(braket
id|b
)braket
dot
id|limit
)paren
(brace
multiline_comment|/* XXX should check the phys address matches */
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_8xx */
id|pg
op_assign
(paren
id|pte_t
op_star
)paren
id|MMU_get_page
c_func
(paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pd
)paren
op_assign
(paren
r_int
r_int
)paren
id|pg
suffix:semicolon
)brace
multiline_comment|/* Use middle 10 bits of VA to index the second-level map */
id|pg
op_assign
id|pte_offset
c_func
(paren
id|pd
comma
id|va
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|pg
comma
id|mk_pte_phys
c_func
(paren
id|pa
op_amp
id|PAGE_MASK
comma
id|__pgprot
c_func
(paren
id|flags
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_8xx
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|va
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(mm, start, end) flushes a range of pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * Flush all tlb/hash table entries (except perhaps for those&n; * mapping RAM starting at PAGE_OFFSET, since they never change).&n; */
r_void
DECL|function|local_flush_tlb_all
id|local_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|memset
c_func
(paren
id|Hash
comma
l_int|0
comma
id|Hash_size
)paren
suffix:semicolon
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
r_void
DECL|function|local_flush_tlb_mm
id|local_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
id|activate_context
c_func
(paren
id|current
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|local_flush_tlb_page
id|local_flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_if
c_cond
(paren
id|vmaddr
OL
id|TASK_SIZE
)paren
id|flush_hash_page
c_func
(paren
id|vma-&gt;vm_mm-&gt;context
comma
id|vmaddr
)paren
suffix:semicolon
r_else
id|flush_hash_page
c_func
(paren
l_int|0
comma
id|vmaddr
)paren
suffix:semicolon
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * for each page addr in the range, call MMU_invalidate_page()&n; * if the range is very large and the hash table is small it might be&n; * faster to do a search of the hash table and just invalidate pages&n; * that are in the range but that&squot;s for study later.&n; * -- Cort&n; */
r_void
DECL|function|local_flush_tlb_range
id|local_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
macro_line|#ifndef CONFIG_8xx
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
op_minus
id|start
OG
l_int|20
op_star
id|PAGE_SIZE
)paren
(brace
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
op_logical_and
id|start
OL
id|TASK_SIZE
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|flush_hash_page
c_func
(paren
id|mm-&gt;context
comma
id|start
)paren
suffix:semicolon
)brace
macro_line|#else
id|asm
r_volatile
(paren
l_string|&quot;tlbia&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The context counter has overflowed.&n; * We set mm-&gt;context to NO_CONTEXT for all mm&squot;s in the system.&n; * We assume we can get to all mm&squot;s by looking as tsk-&gt;mm for&n; * all tasks in the system.&n; */
r_void
DECL|function|mmu_context_overflow
id|mmu_context_overflow
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_8xx
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;mmu_context_overflow&bslash;n&quot;
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm
)paren
id|tsk-&gt;mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|flush_hash_segments
c_func
(paren
l_int|0x10
comma
l_int|0xffffff
)paren
suffix:semicolon
id|next_mmu_context
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* make sure current always has a context */
id|current-&gt;mm-&gt;context
op_assign
id|MUNGE_CONTEXT
c_func
(paren
op_increment
id|next_mmu_context
)paren
suffix:semicolon
id|set_context
c_func
(paren
id|current-&gt;mm-&gt;context
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* We set the value to -1 because it is pre-incremented before&n;&t; * before use.&n;&t; */
id|next_mmu_context
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if 0
multiline_comment|/*&n; * Cache flush functions - these functions cause caches to be flushed&n; * on _all_ processors due to their use of dcbf.  local_flush_cache_all() is&n; * the only function that will not act on all processors in the system.&n; * -- Cort&n; */
r_void
id|local_flush_cache_all
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0  
r_int
r_int
id|hid0
comma
id|tmp
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;mfspr %0,1008 &bslash;n&bslash;t&quot;
l_string|&quot;mr    %1,%0 &bslash;n&bslash;t&quot;
l_string|&quot;or    %0,%2,%2 &bslash;n&bslash;t&quot;
l_string|&quot;mtspr 1008,%0 &bslash;n&bslash;t&quot;
l_string|&quot;sync &bslash;n&bslash;t&quot;
l_string|&quot;isync &bslash;n&bslash;t&quot;
l_string|&quot;andc  %0,%0,%2 &bslash;n&bslash;t&quot;
l_string|&quot;mtspr 1008,%0 &bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=r&quot;
(paren
id|hid0
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|HID0_ICFI
op_or
id|HID0_DCI
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
r_void
id|local_flush_cache_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|vma
)paren
(brace
id|local_flush_cache_range
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
)brace
r_void
id|local_flush_cache_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|vmaddr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|vmaddr
suffix:semicolon
id|i
op_le
(paren
id|vmaddr
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
id|i
op_add_assign
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;dcbf %0,%1&bslash;n&bslash;ticbi %0,%1&bslash;n&bslash;t&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|i
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_void
id|local_flush_cache_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start
suffix:semicolon
id|i
op_le
id|end
suffix:semicolon
id|i
op_add_assign
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;dcbf %0,%1&bslash;n&bslash;ticbi %0,%1&bslash;n&bslash;t&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|i
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_MBX
multiline_comment|/*&n; * This is a big hack right now, but it may turn into something real&n; * someday.&n; *&n; * For the MBX860 (at this time anyway), there is nothing to initialize&n; * associated the the PROM.  Rather than include all of the prom.c&n; * functions in the image just to get prom_init, all we really need right&n; * now is the initialization of the physical memory region.&n; */
r_void
DECL|function|set_mbx_memory
id|set_mbx_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|kstart
comma
id|ksize
suffix:semicolon
id|bd_t
op_star
id|binfo
suffix:semicolon
macro_line|#ifdef DIMM_8xx
r_volatile
id|memctl8xx_t
op_star
id|mcp
suffix:semicolon
macro_line|#endif
id|binfo
op_assign
(paren
id|bd_t
op_star
)paren
op_amp
id|res
suffix:semicolon
multiline_comment|/* The MBX can have up to three memory regions, the on-board&n;&t; * DRAM plus two more banks of DIMM socket memory.  The DIMM is&n;&t; * 64 bits, seen from the processor as two 32 bit banks.&n;&t; * The on-board DRAM is reflected in the board information&n;&t; * structure, and is either 4 Mbytes or 16 Mbytes.&n;&t; * I think there is a way to program the serial EEPROM information&n;&t; * so EPPC-Bug will initialize this memory, but I have not&n;&t; * done that and it may not be a wise thing to do.  If you&n;&t; * remove the DIMM without reprogramming the EEPROM, bad things&n;&t; * could happen since EPPC-Bug tries to use the upper 128K of&n;&t; * memory.&n;&t; */
id|phys_mem.n_regions
op_assign
l_int|1
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
id|phys_mem.regions
(braket
l_int|0
)braket
dot
id|size
op_assign
id|binfo-&gt;bi_memsize
suffix:semicolon
id|end_of_DRAM
op_assign
id|__va
c_func
(paren
id|binfo-&gt;bi_memsize
)paren
suffix:semicolon
macro_line|#ifdef DIMM_8xx
multiline_comment|/* This is a big hack.  It assumes my 32 Mbyte DIMM in a 40 MHz&n;&t; * MPC860.  Don&squot;t do this (or change this) if you are running&n;&t; * something else.&n;&t; */
id|mcp
op_assign
(paren
id|memctl8xx_t
op_star
)paren
(paren
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|MBX_IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_memctl
)paren
)paren
suffix:semicolon
id|mcp-&gt;memc_or2
op_assign
(paren
op_complement
(paren
id|DIMM_SIZE
op_minus
l_int|1
)paren
op_or
l_int|0x00000400
)paren
suffix:semicolon
id|mcp-&gt;memc_br2
op_assign
id|DIMM_SIZE
op_or
l_int|0x00000081
suffix:semicolon
id|mcp-&gt;memc_or3
op_assign
(paren
op_complement
(paren
(paren
l_int|2
op_star
id|DIMM_SIZE
)paren
op_minus
l_int|1
)paren
op_or
l_int|0x00000400
)paren
suffix:semicolon
id|mcp-&gt;memc_br3
op_assign
l_int|2
op_star
id|DIMM_SIZE
op_or
l_int|0x00000081
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
)braket
dot
id|address
op_assign
id|DIMM_SIZE
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
op_increment
)braket
dot
id|size
op_assign
id|DIMM_SIZE
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
)braket
dot
id|address
op_assign
l_int|2
op_star
id|DIMM_SIZE
suffix:semicolon
id|phys_mem.regions
(braket
id|phys_mem.n_regions
op_increment
)braket
dot
id|size
op_assign
id|DIMM_SIZE
suffix:semicolon
id|end_of_DRAM
op_assign
id|__va
c_func
(paren
l_int|3
op_star
id|DIMM_SIZE
)paren
suffix:semicolon
macro_line|#endif
id|phys_avail
op_assign
id|phys_mem
suffix:semicolon
id|kstart
op_assign
id|__pa
c_func
(paren
id|_stext
)paren
suffix:semicolon
multiline_comment|/* should be 0 */
id|ksize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|_end
op_minus
id|_stext
)paren
suffix:semicolon
id|remove_mem_piece
c_func
(paren
op_amp
id|phys_avail
comma
id|kstart
comma
id|ksize
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
