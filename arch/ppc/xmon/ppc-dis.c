multiline_comment|/* ppc-dis.c -- Disassemble PowerPC instructions&n;   Copyright 1994 Free Software Foundation, Inc.&n;   Written by Ian Lance Taylor, Cygnus Support&n;&n;This file is part of GDB, GAS, and the GNU binutils.&n;&n;GDB, GAS, and the GNU binutils are free software; you can redistribute&n;them and/or modify them under the terms of the GNU General Public&n;License as published by the Free Software Foundation; either version&n;2, or (at your option) any later version.&n;&n;GDB, GAS, and the GNU binutils are distributed in the hope that they&n;will be useful, but WITHOUT ANY WARRANTY; without even the implied&n;warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n;the GNU General Public License for more details.&n;&n;You should have received a copy of the GNU General Public License&n;along with this file; see the file COPYING.  If not, write to the Free&n;Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
macro_line|#include &quot;nonstdio.h&quot;
macro_line|#include &quot;ansidecl.h&quot;
macro_line|#include &quot;ppc.h&quot;
r_static
r_int
id|print_insn_powerpc
id|PARAMS
(paren
(paren
id|FILE
op_star
comma
r_int
r_int
id|insn
comma
r_int
id|memaddr
comma
r_int
id|dialect
)paren
)paren
suffix:semicolon
r_extern
r_void
id|print_address
id|PARAMS
c_func
(paren
(paren
r_int
id|memaddr
)paren
)paren
suffix:semicolon
multiline_comment|/* Print a big endian PowerPC instruction.  For convenience, also&n;   disassemble instructions supported by the Motorola PowerPC 601.  */
r_int
DECL|function|print_insn_big_powerpc
id|print_insn_big_powerpc
(paren
id|FILE
op_star
id|out
comma
r_int
r_int
id|insn
comma
r_int
id|memaddr
)paren
(brace
r_return
id|print_insn_powerpc
(paren
id|out
comma
id|insn
comma
id|memaddr
comma
id|PPC_OPCODE_PPC
op_or
id|PPC_OPCODE_601
)paren
suffix:semicolon
)brace
multiline_comment|/* Print a PowerPC or POWER instruction.  */
r_static
r_int
DECL|function|print_insn_powerpc
id|print_insn_powerpc
(paren
id|FILE
op_star
id|out
comma
r_int
r_int
id|insn
comma
r_int
id|memaddr
comma
r_int
id|dialect
)paren
(brace
r_const
r_struct
id|powerpc_opcode
op_star
id|opcode
suffix:semicolon
r_const
r_struct
id|powerpc_opcode
op_star
id|opcode_end
suffix:semicolon
r_int
r_int
id|op
suffix:semicolon
multiline_comment|/* Get the major opcode of the instruction.  */
id|op
op_assign
id|PPC_OP
(paren
id|insn
)paren
suffix:semicolon
multiline_comment|/* Find the first match in the opcode table.  We could speed this up&n;     a bit by doing a binary search on the major opcode.  */
id|opcode_end
op_assign
id|powerpc_opcodes
op_plus
id|powerpc_num_opcodes
suffix:semicolon
r_for
c_loop
(paren
id|opcode
op_assign
id|powerpc_opcodes
suffix:semicolon
id|opcode
OL
id|opcode_end
suffix:semicolon
id|opcode
op_increment
)paren
(brace
r_int
r_int
id|table_op
suffix:semicolon
r_const
r_int
r_char
op_star
id|opindex
suffix:semicolon
r_const
r_struct
id|powerpc_operand
op_star
id|operand
suffix:semicolon
r_int
id|invalid
suffix:semicolon
r_int
id|need_comma
suffix:semicolon
r_int
id|need_paren
suffix:semicolon
id|table_op
op_assign
id|PPC_OP
(paren
id|opcode-&gt;opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op
OL
id|table_op
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|op
OG
id|table_op
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|insn
op_amp
id|opcode-&gt;mask
)paren
op_ne
id|opcode-&gt;opcode
op_logical_or
(paren
id|opcode-&gt;flags
op_amp
id|dialect
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Make two passes over the operands.  First see if any of them&n;&t;&t; have extraction functions, and, if they do, make sure the&n;&t;&t; instruction is valid.  */
id|invalid
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|opindex
op_assign
id|opcode-&gt;operands
suffix:semicolon
op_star
id|opindex
op_ne
l_int|0
suffix:semicolon
id|opindex
op_increment
)paren
(brace
id|operand
op_assign
id|powerpc_operands
op_plus
op_star
id|opindex
suffix:semicolon
r_if
c_cond
(paren
id|operand-&gt;extract
)paren
(paren
op_star
id|operand-&gt;extract
)paren
(paren
id|insn
comma
op_amp
id|invalid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|invalid
)paren
r_continue
suffix:semicolon
multiline_comment|/* The instruction is valid.  */
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;%s&quot;
comma
id|opcode-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opcode-&gt;operands
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;&bslash;t&quot;
)paren
suffix:semicolon
multiline_comment|/* Now extract and print the operands.  */
id|need_comma
op_assign
l_int|0
suffix:semicolon
id|need_paren
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|opindex
op_assign
id|opcode-&gt;operands
suffix:semicolon
op_star
id|opindex
op_ne
l_int|0
suffix:semicolon
id|opindex
op_increment
)paren
(brace
r_int
id|value
suffix:semicolon
id|operand
op_assign
id|powerpc_operands
op_plus
op_star
id|opindex
suffix:semicolon
multiline_comment|/* Operands that are marked FAKE are simply ignored.  We&n;&t;&t;     already made sure that the extract function considered&n;&t;&t;     the instruction to be valid.  */
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_FAKE
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Extract the value from the instruction.  */
r_if
c_cond
(paren
id|operand-&gt;extract
)paren
id|value
op_assign
(paren
op_star
id|operand-&gt;extract
)paren
(paren
id|insn
comma
(paren
r_int
op_star
)paren
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|value
op_assign
(paren
id|insn
op_rshift
id|operand-&gt;shift
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
id|operand-&gt;bits
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_SIGNED
)paren
op_ne
l_int|0
op_logical_and
(paren
id|value
op_amp
(paren
l_int|1
op_lshift
(paren
id|operand-&gt;bits
op_minus
l_int|1
)paren
)paren
)paren
op_ne
l_int|0
)paren
id|value
op_sub_assign
l_int|1
op_lshift
id|operand-&gt;bits
suffix:semicolon
)brace
multiline_comment|/* If the operand is optional, and the value is zero, don&squot;t&n;&t;&t;     print anything.  */
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_OPTIONAL
)paren
op_ne
l_int|0
op_logical_and
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_NEXT
)paren
op_eq
l_int|0
op_logical_and
id|value
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|need_comma
)paren
(brace
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|need_comma
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Print the operand as directed by the flags.  */
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_GPR
)paren
op_ne
l_int|0
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;r%ld&quot;
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_FPR
)paren
op_ne
l_int|0
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;f%ld&quot;
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_RELATIVE
)paren
op_ne
l_int|0
)paren
id|print_address
(paren
id|memaddr
op_plus
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_ABSOLUTE
)paren
op_ne
l_int|0
)paren
id|print_address
(paren
id|value
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_CR
)paren
op_eq
l_int|0
op_logical_or
(paren
id|dialect
op_amp
id|PPC_OPCODE_PPC
)paren
op_eq
l_int|0
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;%ld&quot;
comma
id|value
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|operand-&gt;bits
op_eq
l_int|3
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;cr%d&quot;
comma
id|value
)paren
suffix:semicolon
r_else
(brace
r_static
r_const
r_char
op_star
id|cbnames
(braket
l_int|4
)braket
op_assign
(brace
l_string|&quot;lt&quot;
comma
l_string|&quot;gt&quot;
comma
l_string|&quot;eq&quot;
comma
l_string|&quot;so&quot;
)brace
suffix:semicolon
r_int
id|cr
suffix:semicolon
r_int
id|cc
suffix:semicolon
id|cr
op_assign
id|value
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|cr
op_ne
l_int|0
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;4*cr%d&quot;
comma
id|cr
)paren
suffix:semicolon
id|cc
op_assign
id|value
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cr
op_ne
l_int|0
)paren
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;%s&quot;
comma
id|cbnames
(braket
id|cc
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|need_paren
)paren
(brace
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;)&quot;
)paren
suffix:semicolon
id|need_paren
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|operand-&gt;flags
op_amp
id|PPC_OPERAND_PARENS
)paren
op_eq
l_int|0
)paren
id|need_comma
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;(&quot;
)paren
suffix:semicolon
id|need_paren
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* We have found and printed an instruction; return.  */
r_return
l_int|4
suffix:semicolon
)brace
multiline_comment|/* We could not find a match.  */
id|fprintf
c_func
(paren
id|out
comma
l_string|&quot;.long 0x%lx&quot;
comma
id|insn
)paren
suffix:semicolon
r_return
l_int|4
suffix:semicolon
)brace
eof
