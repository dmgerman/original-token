multiline_comment|/*&n; * Copyright (C) 1996 Paul Mackerras.&n; * Copyright (C) 2000 Dan Malek.&n; * Quick hack of Paul&squot;s code to make XMON work on 8xx processors.  Lots&n; * of assumptions, like the SMC1 is used, it has been initialized by the&n; * loader at some point, and we can just stuff and suck bytes.&n; * We rely upon the 8xx uart driver to support us, as the interface&n; * changes between boot up and operational phases of the kernel.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/8xx_immap.h&gt;
macro_line|#include &lt;asm/mpc8xx.h&gt;
macro_line|#include &quot;commproc.h&quot;
r_extern
r_void
id|xmon_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_int
id|xmon_8xx_write
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|nb
)paren
suffix:semicolon
r_extern
r_int
id|xmon_8xx_read_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|xmon_8xx_read_char
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|prom_drawhex
c_func
(paren
id|uint
)paren
suffix:semicolon
r_void
id|prom_drawstring
c_func
(paren
r_const
r_char
op_star
id|str
)paren
suffix:semicolon
DECL|variable|use_screen
r_static
r_int
id|use_screen
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* default */
DECL|macro|TB_SPEED
mdefine_line|#define TB_SPEED&t;25000000
DECL|function|readtb
r_static
r_inline
r_int
r_int
id|readtb
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;mftb %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
suffix:colon
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|buf_access
r_void
id|buf_access
c_func
(paren
r_void
)paren
(brace
)brace
r_void
DECL|function|xmon_map_scc
id|xmon_map_scc
c_func
(paren
r_void
)paren
(brace
id|cpmp
op_assign
(paren
id|cpm8xx_t
op_star
)paren
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm
)paren
suffix:semicolon
id|use_screen
op_assign
l_int|0
suffix:semicolon
id|prom_drawstring
c_func
(paren
l_string|&quot;xmon uses serial port&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|scc_initialized
r_static
r_int
id|scc_initialized
op_assign
l_int|0
suffix:semicolon
r_void
id|xmon_init_scc
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
DECL|function|xmon_write
id|xmon_write
c_func
(paren
r_void
op_star
id|handle
comma
r_void
op_star
id|ptr
comma
r_int
id|nb
)paren
(brace
r_char
op_star
id|p
op_assign
id|ptr
suffix:semicolon
r_int
id|i
comma
id|c
comma
id|ct
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc_initialized
)paren
id|xmon_init_scc
c_func
(paren
)paren
suffix:semicolon
r_return
id|xmon_8xx_write
c_func
(paren
id|ptr
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|variable|xmon_wants_key
r_int
id|xmon_wants_key
suffix:semicolon
r_int
DECL|function|xmon_read
id|xmon_read
c_func
(paren
r_void
op_star
id|handle
comma
r_void
op_star
id|ptr
comma
r_int
id|nb
)paren
(brace
r_char
op_star
id|p
op_assign
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc_initialized
)paren
id|xmon_init_scc
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nb
suffix:semicolon
op_increment
id|i
)paren
(brace
op_star
id|p
op_increment
op_assign
id|xmon_8xx_read_char
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
r_int
DECL|function|xmon_read_poll
id|xmon_read_poll
c_func
(paren
r_void
)paren
(brace
r_return
id|xmon_8xx_read_poll
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|xmon_init_scc
id|xmon_init_scc
c_func
(paren
)paren
(brace
id|scc_initialized
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if 0
r_extern
r_int
(paren
op_star
id|prom_entry
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
r_int
id|xmon_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|prom_args
(brace
r_char
op_star
id|service
suffix:semicolon
)brace
id|args
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|args.service
op_assign
l_string|&quot;exit&quot;
suffix:semicolon
(paren
op_star
id|prom_entry
)paren
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|variable|xmon_stdin
r_void
op_star
id|xmon_stdin
suffix:semicolon
DECL|variable|xmon_stdout
r_void
op_star
id|xmon_stdout
suffix:semicolon
DECL|variable|xmon_stderr
r_void
op_star
id|xmon_stderr
suffix:semicolon
r_void
DECL|function|xmon_init
id|xmon_init
c_func
(paren
r_void
)paren
(brace
)brace
r_int
DECL|function|xmon_putc
id|xmon_putc
c_func
(paren
r_int
id|c
comma
r_void
op_star
id|f
)paren
(brace
r_char
id|ch
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|xmon_putc
c_func
(paren
l_char|&squot;&bslash;r&squot;
comma
id|f
)paren
suffix:semicolon
r_return
id|xmon_write
c_func
(paren
id|f
comma
op_amp
id|ch
comma
l_int|1
)paren
op_eq
l_int|1
ques
c_cond
id|c
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_putchar
id|xmon_putchar
c_func
(paren
r_int
id|c
)paren
(brace
r_return
id|xmon_putc
c_func
(paren
id|c
comma
id|xmon_stdout
)paren
suffix:semicolon
)brace
r_int
DECL|function|xmon_fputs
id|xmon_fputs
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|f
)paren
(brace
r_int
id|n
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_return
id|xmon_write
c_func
(paren
id|f
comma
id|str
comma
id|n
)paren
op_eq
id|n
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_readchar
id|xmon_readchar
c_func
(paren
r_void
)paren
(brace
r_char
id|ch
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_switch
c_cond
(paren
id|xmon_read
c_func
(paren
id|xmon_stdin
comma
op_amp
id|ch
comma
l_int|1
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
id|ch
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
id|xmon_printf
c_func
(paren
l_string|&quot;read(stdin) returned -1&bslash;r&bslash;n&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|lineptr
r_static
r_char
op_star
id|lineptr
suffix:semicolon
DECL|variable|lineleft
r_static
r_int
id|lineleft
suffix:semicolon
macro_line|#if 0
r_int
id|xmon_expect
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|c
suffix:semicolon
r_int
r_int
id|t0
suffix:semicolon
id|timeout
op_mul_assign
id|TB_SPEED
suffix:semicolon
id|t0
op_assign
id|readtb
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|lineptr
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|c
op_assign
id|xmon_read_poll
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|readtb
c_func
(paren
)paren
op_minus
id|t0
OG
id|timeout
)paren
r_return
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_char|&squot;&bslash;r&squot;
op_logical_and
id|lineptr
OL
op_amp
id|line
(braket
r_sizeof
(paren
id|line
)paren
op_minus
l_int|1
)braket
)paren
op_star
id|lineptr
op_increment
op_assign
id|c
suffix:semicolon
)brace
op_star
id|lineptr
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|strstr
c_func
(paren
id|line
comma
id|str
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_int
DECL|function|xmon_getchar
id|xmon_getchar
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
id|lineleft
op_eq
l_int|0
)paren
(brace
id|lineptr
op_assign
id|line
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|c
op_assign
id|xmon_readchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
op_minus
l_int|1
op_logical_or
id|c
op_eq
l_int|4
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
op_star
id|lineptr
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_int|0177
suffix:colon
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|lineptr
OG
id|line
)paren
(brace
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
op_decrement
id|lineptr
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;U&squot;
op_amp
l_int|0x1F
suffix:colon
r_while
c_loop
(paren
id|lineptr
OG
id|line
)paren
(brace
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
op_decrement
id|lineptr
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|lineptr
op_ge
op_amp
id|line
(braket
r_sizeof
(paren
id|line
)paren
op_minus
l_int|1
)braket
)paren
id|xmon_putchar
c_func
(paren
l_char|&squot;&bslash;a&squot;
)paren
suffix:semicolon
r_else
(brace
id|xmon_putchar
c_func
(paren
id|c
)paren
suffix:semicolon
op_star
id|lineptr
op_increment
op_assign
id|c
suffix:semicolon
)brace
)brace
)brace
id|lineleft
op_assign
id|lineptr
op_minus
id|line
suffix:semicolon
id|lineptr
op_assign
id|line
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lineleft
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
op_decrement
id|lineleft
suffix:semicolon
r_return
op_star
id|lineptr
op_increment
suffix:semicolon
)brace
r_char
op_star
DECL|function|xmon_fgets
id|xmon_fgets
c_func
(paren
r_char
op_star
id|str
comma
r_int
id|nb
comma
r_void
op_star
id|f
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
id|c
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|str
suffix:semicolon
id|p
OL
id|str
op_plus
id|nb
op_minus
l_int|1
suffix:semicolon
)paren
(brace
id|c
op_assign
id|xmon_getchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|str
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
)brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
r_return
id|str
suffix:semicolon
)brace
r_void
DECL|function|prom_drawhex
id|prom_drawhex
c_func
(paren
id|uint
id|val
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
(braket
id|val
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|val
op_rshift_assign
l_int|4
suffix:semicolon
)brace
id|buf
(braket
l_int|8
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|xmon_fputs
c_func
(paren
id|buf
comma
id|xmon_stdout
)paren
suffix:semicolon
)brace
r_void
DECL|function|prom_drawstring
id|prom_drawstring
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
id|xmon_fputs
c_func
(paren
id|str
comma
id|xmon_stdout
)paren
suffix:semicolon
)brace
eof
