multiline_comment|/*&n; * Routines providing a simple monitor for use on the PowerMac.&n; *&n; * Copyright (C) 1996 Paul Mackerras.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &quot;nonstdio.h&quot;
macro_line|#include &quot;privinst.h&quot;
DECL|macro|scanhex
mdefine_line|#define scanhex&t;xmon_scanhex
DECL|macro|skipbl
mdefine_line|#define skipbl&t;xmon_skipbl
DECL|variable|adrs
r_static
r_int
id|adrs
suffix:semicolon
DECL|variable|size
r_static
r_int
id|size
op_assign
l_int|1
suffix:semicolon
DECL|variable|ndump
r_static
r_int
id|ndump
op_assign
l_int|64
suffix:semicolon
DECL|variable|nidump
r_static
r_int
id|nidump
op_assign
l_int|16
suffix:semicolon
DECL|variable|termch
r_static
r_int
id|termch
suffix:semicolon
DECL|variable|bus_error_jmp
r_static
id|u_int
id|bus_error_jmp
(braket
l_int|100
)braket
suffix:semicolon
DECL|macro|setjmp
mdefine_line|#define setjmp xmon_setjmp
DECL|macro|longjmp
mdefine_line|#define longjmp xmon_longjmp
multiline_comment|/* Breakpoint stuff */
DECL|struct|bpt
r_struct
id|bpt
(brace
DECL|member|address
r_int
id|address
suffix:semicolon
DECL|member|instr
r_int
id|instr
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|enabled
r_int
r_char
id|enabled
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NBPTS
mdefine_line|#define NBPTS&t;16
DECL|variable|bpts
r_static
r_struct
id|bpt
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
DECL|variable|dabr
r_static
r_struct
id|bpt
id|dabr
suffix:semicolon
DECL|variable|iabr
r_static
r_struct
id|bpt
id|iabr
suffix:semicolon
DECL|variable|bpinstr
r_static
r_int
id|bpinstr
op_assign
l_int|0x7fe00008
suffix:semicolon
multiline_comment|/* trap */
multiline_comment|/* Prototypes */
r_extern
r_void
(paren
op_star
id|debugger_fault_handler
)paren
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|mread
c_func
(paren
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mwrite
c_func
(paren
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|byterev
c_func
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|memex
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|bsesc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|dump
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|prdump
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#ifdef __MWERKS__
r_static
r_void
id|prndump
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|nvreadb
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|ppc_inst_dump
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|print_address
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_int
id|getsp
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|dump_hash_table
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|memops
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|memlocate
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memzcan
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|memdiffs
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_char
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
id|skipbl
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|scanhex
c_func
(paren
r_int
op_star
id|valp
)paren
suffix:semicolon
r_static
r_void
id|scannl
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|hexdigit
c_func
(paren
r_int
)paren
suffix:semicolon
r_void
id|getstring
c_func
(paren
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|flush_input
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|inchar
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|take_input
c_func
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* static void openforth(void); */
r_static
r_int
id|read_spr
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|write_spr
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|super_regs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|print_sysmap
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|remove_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|insert_bpts
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|bpt
op_star
id|at_breakpoint
c_func
(paren
r_int
id|pc
)paren
suffix:semicolon
r_static
r_void
id|bpt_cmds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|cacheflush
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_char
op_star
id|pretty_print_addr
c_func
(paren
r_int
r_int
id|addr
)paren
suffix:semicolon
r_static
r_char
op_star
id|lookup_name
c_func
(paren
r_int
r_int
id|addr
)paren
suffix:semicolon
r_extern
r_int
id|print_insn_big_powerpc
c_func
(paren
id|FILE
op_star
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_int
id|putchar
c_func
(paren
r_int
id|ch
)paren
suffix:semicolon
r_extern
r_int
m_setjmp
(paren
id|u_int
op_star
)paren
suffix:semicolon
r_extern
r_void
m_longjmp
(paren
id|u_int
op_star
comma
r_int
)paren
suffix:semicolon
DECL|macro|GETWORD
mdefine_line|#define GETWORD(v)&t;(((v)[0] &lt;&lt; 24) + ((v)[1] &lt;&lt; 16) + ((v)[2] &lt;&lt; 8) + (v)[3])
DECL|variable|help_string
r_static
r_char
op_star
id|help_string
op_assign
l_string|&quot;&bslash;&n;Commands:&bslash;n&bslash;&n;  d&t;dump bytes&bslash;n&bslash;&n;  di&t;dump instructions&bslash;n&bslash;&n;  df&t;dump float values&bslash;n&bslash;&n;  dd&t;dump double values&bslash;n&bslash;&n;  e&t;print exception information&bslash;n&bslash;&n;  h&t;dump hash table&bslash;n&bslash;&n;  m&t;examine/change memory&bslash;n&bslash;&n;  mm&t;move a block of memory&bslash;n&bslash;&n;  ms&t;set a block of memory&bslash;n&bslash;&n;  md&t;compare two blocks of memory&bslash;n&bslash;&n;  M&t;print System.map&bslash;n&bslash;&n;  r&t;print registers&bslash;n&bslash;&n;  S&t;print special registers&bslash;n&bslash;&n;  t&t;print backtrace&bslash;n&bslash;&n;  x&t;exit monitor&bslash;n&bslash;&n;&quot;
suffix:semicolon
DECL|variable|xmon_trace
r_static
r_int
id|xmon_trace
suffix:semicolon
DECL|macro|SSTEP
mdefine_line|#define SSTEP&t;1&t;&t;/* stepping because of &squot;s&squot; command */
DECL|macro|BRSTEP
mdefine_line|#define BRSTEP&t;2&t;&t;/* stepping over breakpoint */
r_void
DECL|function|xmon
id|xmon
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_int
id|msr
comma
id|cmd
comma
id|i
suffix:semicolon
r_int
op_star
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;stw&t;0,0(%0)&bslash;n&bslash;&n;&t;&t;&t;lwz&t;0,0(1)&bslash;n&bslash;&n;&t;&t;&t;stw&t;0,4(%0)&bslash;n&bslash;&n;&t;&t;&t;stmw&t;2,8(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;b&quot;
(paren
op_amp
id|regs
)paren
)paren
suffix:semicolon
id|regs.nip
op_assign
id|regs.link
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|regs.gpr
(braket
l_int|1
)braket
)paren
(braket
l_int|1
)braket
suffix:semicolon
id|regs.msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|regs.ctr
op_assign
id|get_ctr
c_func
(paren
)paren
suffix:semicolon
id|regs.xer
op_assign
id|get_xer
c_func
(paren
)paren
suffix:semicolon
id|regs.ccr
op_assign
id|get_cr
c_func
(paren
)paren
suffix:semicolon
id|regs.trap
op_assign
l_int|0
suffix:semicolon
id|excp
op_assign
op_amp
id|regs
suffix:semicolon
)brace
id|prom_drawstring
c_func
(paren
l_string|&quot;xmon pc=&quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|excp-&gt;nip
)paren
suffix:semicolon
id|prom_drawstring
c_func
(paren
l_string|&quot; lr=&quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|excp-&gt;link
)paren
suffix:semicolon
id|prom_drawstring
c_func
(paren
l_string|&quot; msr=&quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|excp-&gt;msr
)paren
suffix:semicolon
id|prom_drawstring
c_func
(paren
l_string|&quot; trap=&quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|excp-&gt;trap
)paren
suffix:semicolon
id|prom_drawstring
c_func
(paren
l_string|&quot; sp=&quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|excp-&gt;gpr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|sp
op_assign
(paren
r_int
op_star
)paren
op_amp
id|excp-&gt;gpr
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
id|prom_drawstring
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|prom_drawstring
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|sp
op_assign
(paren
r_int
op_star
)paren
id|excp-&gt;gpr
(braket
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|prom_drawstring
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|sp
)paren
suffix:semicolon
id|prom_drawstring
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|prom_drawstring
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|prom_drawhex
c_func
(paren
id|sp
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|prom_drawstring
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|msr
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|set_msr
c_func
(paren
id|msr
op_amp
op_complement
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|excp
)paren
suffix:semicolon
id|cmd
op_assign
id|cmds
c_func
(paren
id|excp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;s&squot;
)paren
(brace
id|xmon_trace
op_assign
id|SSTEP
suffix:semicolon
id|excp-&gt;msr
op_or_assign
l_int|0x400
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|at_breakpoint
c_func
(paren
id|excp-&gt;nip
)paren
)paren
(brace
id|xmon_trace
op_assign
id|BRSTEP
suffix:semicolon
id|excp-&gt;msr
op_or_assign
l_int|0x400
suffix:semicolon
)brace
r_else
(brace
id|xmon_trace
op_assign
l_int|0
suffix:semicolon
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_msr
c_func
(paren
id|msr
)paren
suffix:semicolon
multiline_comment|/* restore interrupt enable */
)brace
r_void
DECL|function|xmon_irq
id|xmon_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|d
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Keyboard interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_int
DECL|function|xmon_bpt
id|xmon_bpt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|regs-&gt;nip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;count
)paren
(brace
op_decrement
id|bp-&gt;count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
l_int|0x400
suffix:semicolon
)brace
r_else
(brace
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_sstep
id|xmon_sstep
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xmon_trace
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xmon_trace
op_eq
id|BRSTEP
)paren
(brace
id|xmon_trace
op_assign
l_int|0
suffix:semicolon
id|insert_bpts
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_dabr_match
id|xmon_dabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|dabr.enabled
op_logical_and
id|dabr.count
)paren
(brace
op_decrement
id|dabr.count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
l_int|0x400
suffix:semicolon
)brace
r_else
(brace
id|dabr.instr
op_assign
id|regs-&gt;nip
suffix:semicolon
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|xmon_iabr_match
id|xmon_iabr_match
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|iabr.enabled
op_logical_and
id|iabr.count
)paren
(brace
op_decrement
id|iabr.count
suffix:semicolon
id|remove_bpts
c_func
(paren
)paren
suffix:semicolon
id|excprint
c_func
(paren
id|regs
)paren
suffix:semicolon
id|xmon_trace
op_assign
id|BRSTEP
suffix:semicolon
id|regs-&gt;msr
op_or_assign
l_int|0x400
suffix:semicolon
)brace
r_else
(brace
id|xmon
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_struct
id|bpt
op_star
DECL|function|at_breakpoint
id|at_breakpoint
c_func
(paren
r_int
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
op_logical_and
id|pc
op_eq
id|dabr.instr
)paren
r_return
op_amp
id|dabr
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
op_logical_and
id|pc
op_eq
id|iabr.address
)paren
r_return
op_amp
id|iabr
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
r_if
c_cond
(paren
id|bp-&gt;enabled
op_logical_and
id|pc
op_eq
id|bp-&gt;address
)paren
r_return
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|insert_bpts
id|insert_bpts
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
comma
l_int|4
)paren
op_ne
l_int|4
op_logical_or
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bpinstr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t insert breakpoint at %x, disabling&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dabr.enabled
)paren
id|set_dabr
c_func
(paren
id|dabr.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|set_iabr
c_func
(paren
id|iabr.address
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|remove_bpts
id|remove_bpts
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
r_int
id|instr
suffix:semicolon
id|set_dabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_iabr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|bp
op_assign
id|bpts
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
comma
op_increment
id|bp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|instr
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
id|instr
op_eq
id|bpinstr
op_logical_and
id|mwrite
c_func
(paren
id|bp-&gt;address
comma
op_amp
id|bp-&gt;instr
comma
l_int|4
)paren
op_ne
l_int|4
)paren
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t remove breakpoint at %x&bslash;n&quot;
comma
id|bp-&gt;address
)paren
suffix:semicolon
)brace
)brace
DECL|variable|last_cmd
r_static
r_char
op_star
id|last_cmd
suffix:semicolon
multiline_comment|/* Command interpreting routine */
r_static
r_int
DECL|function|cmds
id|cmds
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
id|cmd
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;mon&gt; &quot;
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|flush_input
c_func
(paren
)paren
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|last_cmd
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|take_input
c_func
(paren
id|last_cmd
)paren
suffix:semicolon
id|last_cmd
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;s&squot;
suffix:colon
r_case
l_char|&squot;d&squot;
suffix:colon
id|memops
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|memlocate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;z&squot;
suffix:colon
id|memzcan
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
id|memex
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|dump
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
id|excp
op_ne
l_int|NULL
)paren
id|prregs
c_func
(paren
id|excp
)paren
suffix:semicolon
multiline_comment|/* print regs */
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
r_if
c_cond
(paren
id|excp
op_eq
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot;No exception information&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|excprint
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|print_sysmap
c_func
(paren
)paren
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
id|super_regs
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|backtrace
c_func
(paren
id|excp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|cacheflush
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|dump_hash_table
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
id|EOF
suffix:colon
r_return
id|cmd
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|printf
c_func
(paren
id|help_string
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Unrecognized command: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
l_char|&squot; &squot;
OL
id|cmd
op_logical_and
id|cmd
op_le
l_char|&squot;~&squot;
)paren
(brace
id|putchar
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&bslash;x%x&quot;
comma
id|cmd
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; (type ? for help)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|bpt_cmds
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|bpt_cmds
id|bpt_cmds
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
id|a
suffix:semicolon
r_int
id|mode
comma
id|i
suffix:semicolon
r_struct
id|bpt
op_star
id|bp
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
id|mode
op_assign
l_int|7
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;r&squot;
)paren
id|mode
op_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;w&squot;
)paren
id|mode
op_assign
l_int|6
suffix:semicolon
r_else
id|termch
op_assign
id|cmd
suffix:semicolon
id|dabr.address
op_assign
l_int|0
suffix:semicolon
id|dabr.count
op_assign
l_int|0
suffix:semicolon
id|dabr.enabled
op_assign
id|scanhex
c_func
(paren
op_amp
id|dabr.address
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|dabr.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
)paren
id|dabr.address
op_assign
(paren
id|dabr.address
op_amp
op_complement
l_int|7
)paren
op_or
id|mode
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
id|iabr.address
op_assign
l_int|0
suffix:semicolon
id|iabr.count
op_assign
l_int|0
suffix:semicolon
id|iabr.enabled
op_assign
id|scanhex
c_func
(paren
op_amp
id|iabr.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|iabr.address
op_or_assign
l_int|3
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|iabr.count
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* clear all breakpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBPTS
suffix:semicolon
op_increment
id|i
)paren
id|bpts
(braket
id|i
)braket
dot
id|enabled
op_assign
l_int|0
suffix:semicolon
id|iabr.enabled
op_assign
l_int|0
suffix:semicolon
id|dabr.enabled
op_assign
l_int|0
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;All breakpoints cleared&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;No breakpoint at %x&bslash;n&quot;
comma
id|a
)paren
suffix:semicolon
)brace
r_else
(brace
id|bp-&gt;enabled
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|termch
op_assign
id|cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scanhex
c_func
(paren
op_amp
id|a
)paren
)paren
(brace
multiline_comment|/* print all breakpoints */
id|printf
c_func
(paren
l_string|&quot;type  address   count&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.enabled
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;data %.8x %8x [&quot;
comma
id|dabr.address
op_amp
op_complement
l_int|7
comma
id|dabr.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.address
op_amp
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabr.address
op_amp
l_int|2
)paren
id|printf
c_func
(paren
l_string|&quot;w&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iabr.enabled
)paren
id|printf
c_func
(paren
l_string|&quot;inst %.8x %8x&bslash;n&quot;
comma
id|iabr.address
op_amp
op_complement
l_int|3
comma
id|iabr.count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
)paren
r_if
c_cond
(paren
id|bp-&gt;enabled
)paren
id|printf
c_func
(paren
l_string|&quot;trap %.8x %8x&bslash;n&quot;
comma
id|bp-&gt;address
comma
id|bp-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bp
op_assign
id|at_breakpoint
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|bp
op_assign
id|bpts
suffix:semicolon
id|bp
OL
op_amp
id|bpts
(braket
id|NBPTS
)braket
suffix:semicolon
op_increment
id|bp
)paren
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;enabled
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ge
op_amp
id|bpts
(braket
id|NBPTS
)braket
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Sorry, no free breakpoints&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|bp-&gt;enabled
op_assign
l_int|1
suffix:semicolon
id|bp-&gt;address
op_assign
id|a
suffix:semicolon
id|bp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|bp-&gt;count
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|backtrace
id|backtrace
c_func
(paren
r_struct
id|pt_regs
op_star
id|excp
)paren
(brace
r_int
id|sp
suffix:semicolon
r_int
id|stack
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
r_extern
r_char
id|ret_from_intercept
comma
id|ret_from_syscall_1
comma
id|ret_from_syscall_2
suffix:semicolon
r_extern
r_char
id|lost_irq_ret
comma
id|do_bottom_half_ret
comma
id|do_signal_ret
suffix:semicolon
r_extern
r_char
id|ret_from_except
suffix:semicolon
r_if
c_cond
(paren
id|excp
op_ne
l_int|NULL
)paren
id|sp
op_assign
id|excp-&gt;gpr
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|sp
op_assign
id|getsp
c_func
(paren
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|sp
)paren
suffix:semicolon
id|scannl
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|sp
op_ne
l_int|0
suffix:semicolon
id|sp
op_assign
id|stack
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
comma
id|stack
comma
r_sizeof
(paren
id|stack
)paren
)paren
op_ne
r_sizeof
(paren
id|stack
)paren
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%x &quot;
comma
id|stack
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stack
(braket
l_int|1
)braket
op_eq
(paren
r_int
)paren
op_amp
id|ret_from_intercept
op_logical_or
id|stack
(braket
l_int|1
)braket
op_eq
(paren
r_int
)paren
op_amp
id|ret_from_except
op_logical_or
id|stack
(braket
l_int|1
)braket
op_eq
(paren
r_int
)paren
op_amp
id|ret_from_syscall_1
op_logical_or
id|stack
(braket
l_int|1
)braket
op_eq
(paren
r_int
)paren
op_amp
id|ret_from_syscall_2
op_logical_or
id|stack
(braket
l_int|1
)braket
op_eq
(paren
r_int
)paren
op_amp
id|lost_irq_ret
op_logical_or
id|stack
(braket
l_int|1
)braket
op_eq
(paren
r_int
)paren
op_amp
id|do_bottom_half_ret
op_logical_or
id|stack
(braket
l_int|1
)braket
op_eq
(paren
r_int
)paren
op_amp
id|do_signal_ret
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
op_plus
l_int|16
comma
op_amp
id|regs
comma
r_sizeof
(paren
id|regs
)paren
)paren
op_ne
r_sizeof
(paren
id|regs
)paren
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nexception:%x [%x] %x &quot;
comma
id|regs.trap
comma
id|sp
op_plus
l_int|16
comma
id|regs.nip
)paren
suffix:semicolon
id|sp
op_assign
id|regs.gpr
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mread
c_func
(paren
id|sp
comma
id|stack
comma
r_sizeof
(paren
id|stack
)paren
)paren
op_ne
r_sizeof
(paren
id|stack
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_int
DECL|function|getsp
id|getsp
c_func
(paren
)paren
(brace
r_int
id|x
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|x
)paren
suffix:colon
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
r_void
DECL|function|excprint
id|excprint
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;vector: %x at pc = %x&quot;
comma
id|fp-&gt;trap
comma
id|fp-&gt;nip
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;, lr = %x, msr = %x, sp = %x [%x]&bslash;n&quot;
comma
id|fp-&gt;link
comma
id|fp-&gt;msr
comma
id|fp-&gt;gpr
(braket
l_int|1
)braket
comma
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;trap
op_eq
l_int|0x300
op_logical_or
id|fp-&gt;trap
op_eq
l_int|0x600
)paren
id|printf
c_func
(paren
l_string|&quot;dar = %x, dsisr = %x&bslash;n&quot;
comma
id|fp-&gt;dar
comma
id|fp-&gt;dsisr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
)paren
id|printf
c_func
(paren
l_string|&quot;current = %x, pid = %d, comm = %s&bslash;n&quot;
comma
id|current
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
)brace
r_void
DECL|function|prregs
id|prregs
c_func
(paren
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
id|base
suffix:semicolon
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|base
)paren
)paren
id|fp
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|base
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|32
suffix:semicolon
op_increment
id|n
)paren
id|printf
c_func
(paren
l_string|&quot;R%.2d = %.8x%s&quot;
comma
id|n
comma
id|fp-&gt;gpr
(braket
id|n
)braket
comma
(paren
id|n
op_amp
l_int|3
)paren
op_eq
l_int|3
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot;   &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;pc  = %.8x   msr = %.8x   lr  = %.8x   cr  = %.8x&bslash;n&quot;
comma
id|fp-&gt;nip
comma
id|fp-&gt;msr
comma
id|fp-&gt;link
comma
id|fp-&gt;ccr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ctr = %.8x   xer = %.8x   trap = %4x&bslash;n&quot;
comma
id|fp-&gt;ctr
comma
id|fp-&gt;xer
comma
id|fp-&gt;trap
)paren
suffix:semicolon
)brace
r_void
DECL|function|cacheflush
id|cacheflush
c_func
(paren
r_void
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_int
id|nflush
suffix:semicolon
id|cmd
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
id|termch
op_assign
id|cmd
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|nflush
op_assign
l_int|1
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|nflush
)paren
suffix:semicolon
id|nflush
op_assign
(paren
id|nflush
op_plus
l_int|31
)paren
op_div
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_char|&squot;i&squot;
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
l_int|0x20
)paren
id|cflush
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
suffix:semicolon
id|nflush
OG
l_int|0
suffix:semicolon
op_decrement
id|nflush
comma
id|adrs
op_add_assign
l_int|0x20
)paren
id|cinval
c_func
(paren
(paren
r_void
op_star
)paren
id|adrs
)paren
suffix:semicolon
)brace
)brace
r_int
r_int
DECL|function|read_spr
id|read_spr
c_func
(paren
r_int
id|n
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
(paren
op_star
id|code
)paren
(paren
r_void
)paren
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6002a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
(paren
op_star
)paren
(paren
r_void
)paren
)paren
id|instrs
suffix:semicolon
r_return
id|code
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|write_spr
id|write_spr
c_func
(paren
r_int
id|n
comma
r_int
r_int
id|val
)paren
(brace
r_int
r_int
id|instrs
(braket
l_int|2
)braket
suffix:semicolon
r_int
(paren
op_star
id|code
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
id|instrs
(braket
l_int|0
)braket
op_assign
l_int|0x7c6003a6
op_plus
(paren
(paren
id|n
op_amp
l_int|0x1F
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
id|n
op_amp
l_int|0x3e0
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|instrs
(braket
l_int|1
)braket
op_assign
l_int|0x4e800020
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
)paren
suffix:semicolon
id|store_inst
c_func
(paren
id|instrs
op_plus
l_int|1
)paren
suffix:semicolon
id|code
op_assign
(paren
r_int
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|instrs
suffix:semicolon
id|code
c_func
(paren
id|val
)paren
suffix:semicolon
)brace
DECL|variable|regno
r_static
r_int
r_int
id|regno
suffix:semicolon
r_extern
r_char
id|exc_prolog
suffix:semicolon
r_extern
r_char
id|dec_exc
suffix:semicolon
r_void
DECL|function|print_sysmap
id|print_sysmap
c_func
(paren
r_void
)paren
(brace
r_extern
r_char
op_star
id|sysmap
suffix:semicolon
r_if
c_cond
(paren
id|sysmap
)paren
id|printf
c_func
(paren
l_string|&quot;System.map: &bslash;n%s&quot;
comma
id|sysmap
)paren
suffix:semicolon
)brace
r_void
DECL|function|super_regs
id|super_regs
c_func
(paren
)paren
(brace
r_int
id|i
comma
id|cmd
suffix:semicolon
r_int
id|val
suffix:semicolon
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;msr = %x, pvr = %x&bslash;n&quot;
comma
id|get_msr
c_func
(paren
)paren
comma
id|get_pvr
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sprg0-3 = %x %x %x %x&bslash;n&quot;
comma
id|get_sprg0
c_func
(paren
)paren
comma
id|get_sprg1
c_func
(paren
)paren
comma
id|get_sprg2
c_func
(paren
)paren
comma
id|get_sprg3
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;srr0 = %x, srr1 = %x&bslash;n&quot;
comma
id|get_srr0
c_func
(paren
)paren
comma
id|get_srr1
c_func
(paren
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sr0-15 =&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot; %x&quot;
comma
id|get_sr
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|i
)paren
suffix:colon
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sp = %x &quot;
comma
id|i
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mr %0,2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|i
)paren
suffix:colon
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;toc = %x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scanhex
c_func
(paren
op_amp
id|regno
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;w&squot;
suffix:colon
id|val
op_assign
id|read_spr
c_func
(paren
id|regno
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|write_spr
c_func
(paren
id|regno
comma
id|val
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_char|&squot;r&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;spr %x = %x&bslash;n&quot;
comma
id|regno
comma
id|read_spr
c_func
(paren
id|regno
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|val
op_assign
id|get_sr
c_func
(paren
id|regno
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|set_sr
c_func
(paren
id|regno
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|val
op_assign
id|get_msr
c_func
(paren
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|set_msr
c_func
(paren
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|scannl
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|openforth
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_char
id|cmd
(braket
l_int|1024
)braket
suffix:semicolon
r_int
id|args
(braket
l_int|5
)braket
suffix:semicolon
r_extern
r_int
(paren
op_star
id|prom_entry
)paren
(paren
r_int
op_star
)paren
suffix:semicolon
id|p
op_assign
id|cmd
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|args
(braket
l_int|0
)braket
op_assign
(paren
r_int
)paren
l_string|&quot;interpret&quot;
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
l_int|1
suffix:semicolon
id|args
(braket
l_int|3
)braket
op_assign
(paren
r_int
)paren
id|cmd
suffix:semicolon
(paren
op_star
id|prom_entry
)paren
(paren
id|args
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|4
)braket
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;error %x&bslash;n&quot;
comma
id|args
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_void
DECL|function|dump_hash_table_seg
id|dump_hash_table_seg
c_func
(paren
r_int
id|seg
comma
r_int
id|start
comma
r_int
id|end
)paren
(brace
r_extern
r_void
op_star
id|Hash
suffix:semicolon
r_extern
r_int
r_int
id|Hash_size
suffix:semicolon
r_int
op_star
id|htab
op_assign
id|Hash
suffix:semicolon
r_int
id|hsize
op_assign
id|Hash_size
suffix:semicolon
r_int
id|v
comma
id|hmask
comma
id|va
comma
id|last_va
suffix:semicolon
r_int
id|found
comma
id|last_found
comma
id|i
suffix:semicolon
r_int
op_star
id|hg
comma
id|w1
comma
id|last_w2
comma
id|last_va0
suffix:semicolon
id|last_found
op_assign
l_int|0
suffix:semicolon
id|hmask
op_assign
id|hsize
op_div
l_int|64
op_minus
l_int|1
suffix:semicolon
id|va
op_assign
id|start
suffix:semicolon
id|start
op_assign
(paren
id|start
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|end
op_assign
(paren
id|end
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
id|start
suffix:semicolon
id|v
OL
id|end
suffix:semicolon
op_increment
id|v
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
id|hg
op_assign
id|htab
op_plus
(paren
(paren
(paren
id|v
op_xor
id|seg
)paren
op_amp
id|hmask
)paren
op_star
l_int|16
)paren
suffix:semicolon
id|w1
op_assign
l_int|0x80000000
op_or
(paren
id|seg
op_lshift
l_int|7
)paren
op_or
(paren
id|v
op_rshift
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
comma
id|hg
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_star
id|hg
op_eq
id|w1
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|w1
op_xor_assign
l_int|0x40
suffix:semicolon
id|hg
op_assign
id|htab
op_plus
(paren
(paren
op_complement
(paren
id|v
op_xor
id|seg
)paren
op_amp
id|hmask
)paren
op_star
l_int|16
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
comma
id|hg
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_star
id|hg
op_eq
id|w1
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|last_found
op_logical_and
id|found
op_logical_and
(paren
id|hg
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x180
)paren
op_eq
id|last_w2
op_plus
l_int|4096
)paren
)paren
(brace
r_if
c_cond
(paren
id|last_found
)paren
(brace
r_if
c_cond
(paren
id|last_va
op_ne
id|last_va0
)paren
id|printf
c_func
(paren
l_string|&quot; ... %x&quot;
comma
id|last_va
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%x to %x&quot;
comma
id|va
comma
id|hg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|last_va0
op_assign
id|va
suffix:semicolon
)brace
id|last_found
op_assign
id|found
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|last_w2
op_assign
id|hg
(braket
l_int|1
)braket
op_amp
op_complement
l_int|0x180
suffix:semicolon
id|last_va
op_assign
id|va
suffix:semicolon
)brace
id|va
op_add_assign
l_int|4096
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_found
)paren
id|printf
c_func
(paren
l_string|&quot; ... %x&bslash;n&quot;
comma
id|last_va
)paren
suffix:semicolon
)brace
DECL|variable|hash_ctx
r_static
r_int
id|hash_ctx
suffix:semicolon
DECL|variable|hash_start
r_static
r_int
id|hash_start
suffix:semicolon
DECL|variable|hash_end
r_static
r_int
id|hash_end
suffix:semicolon
r_static
r_void
DECL|function|dump_hash_table
id|dump_hash_table
c_func
(paren
)paren
(brace
r_int
id|seg
suffix:semicolon
r_int
id|seg_start
comma
id|seg_end
suffix:semicolon
id|hash_ctx
op_assign
l_int|0
suffix:semicolon
id|hash_start
op_assign
l_int|0
suffix:semicolon
id|hash_end
op_assign
l_int|0xfffff000
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|hash_ctx
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|hash_start
)paren
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|hash_end
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Mappings for context %x&bslash;n&quot;
comma
id|hash_ctx
)paren
suffix:semicolon
id|seg_start
op_assign
id|hash_start
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
id|hash_start
op_rshift
l_int|28
suffix:semicolon
id|seg
op_le
id|hash_end
op_rshift
l_int|28
suffix:semicolon
op_increment
id|seg
)paren
(brace
id|seg_end
op_assign
(paren
id|seg
op_lshift
l_int|28
)paren
op_or
l_int|0x0ffff000
suffix:semicolon
r_if
c_cond
(paren
id|seg_end
OG
id|hash_end
)paren
id|seg_end
op_assign
id|hash_end
suffix:semicolon
id|dump_hash_table_seg
c_func
(paren
(paren
id|hash_ctx
op_lshift
l_int|4
)paren
op_plus
id|seg
comma
id|seg_start
comma
id|seg_end
)paren
suffix:semicolon
id|seg_start
op_assign
id|seg_end
op_plus
l_int|0x1000
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Stuff for reading and writing memory safely&n; */
DECL|function|sync
r_extern
r_inline
r_void
id|sync
c_func
(paren
r_void
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;sync; isync&quot;
)paren
suffix:semicolon
)brace
DECL|function|__delay
r_extern
r_inline
r_void
id|__delay
c_func
(paren
r_int
r_int
id|loops
)paren
(brace
r_if
c_cond
(paren
id|loops
op_ne
l_int|0
)paren
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mtctr %0; 1: bdnz 1b&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|loops
)paren
suffix:colon
l_string|&quot;ctr&quot;
)paren
suffix:semicolon
)brace
r_int
DECL|function|mread
id|mread
c_func
(paren
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|q
op_assign
op_star
(paren
r_int
op_star
)paren
id|p
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|q
op_increment
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait a little while to see if we get a machine check */
id|__delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
id|debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_int
DECL|function|mwrite
id|mwrite
c_func
(paren
r_int
id|adrs
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_volatile
r_int
id|n
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
m_setjmp
(paren
id|bus_error_jmp
)paren
op_eq
l_int|0
)paren
(brace
id|debugger_fault_handler
op_assign
id|handle_fault
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|adrs
suffix:semicolon
id|q
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
op_star
)paren
id|p
op_assign
op_star
(paren
r_int
op_star
)paren
id|q
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|size
suffix:semicolon
op_increment
id|n
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
id|sync
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|sync
c_func
(paren
)paren
suffix:semicolon
id|n
op_assign
id|size
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;*** Error writing address %x&bslash;n&quot;
comma
id|adrs
op_plus
id|n
)paren
suffix:semicolon
)brace
id|debugger_fault_handler
op_assign
l_int|0
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|variable|fault_type
r_static
r_int
id|fault_type
suffix:semicolon
DECL|variable|fault_chars
r_static
r_char
op_star
id|fault_chars
(braket
)braket
op_assign
(brace
l_string|&quot;--&quot;
comma
l_string|&quot;**&quot;
comma
l_string|&quot;##&quot;
)brace
suffix:semicolon
r_static
r_void
DECL|function|handle_fault
id|handle_fault
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|fault_type
op_assign
id|regs-&gt;trap
op_eq
l_int|0x200
ques
c_cond
l_int|0
suffix:colon
id|regs-&gt;trap
op_eq
l_int|0x300
ques
c_cond
l_int|1
suffix:colon
l_int|2
suffix:semicolon
m_longjmp
(paren
id|bus_error_jmp
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|macro|SWAP
mdefine_line|#define SWAP(a, b, t)&t;((t) = (a), (a) = (b), (b) = (t))
r_void
DECL|function|byterev
id|byterev
c_func
(paren
r_int
r_char
op_star
id|val
comma
r_int
id|size
)paren
(brace
r_int
id|t
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|1
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|SWAP
c_func
(paren
id|val
(braket
l_int|0
)braket
comma
id|val
(braket
l_int|3
)braket
comma
id|t
)paren
suffix:semicolon
id|SWAP
c_func
(paren
id|val
(braket
l_int|1
)braket
comma
id|val
(braket
l_int|2
)braket
comma
id|t
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|brev
r_static
r_int
id|brev
suffix:semicolon
DECL|variable|mnoread
r_static
r_int
id|mnoread
suffix:semicolon
r_void
DECL|function|memex
id|memex
c_func
(paren
)paren
(brace
r_int
id|cmd
comma
id|inc
comma
id|i
comma
id|nslash
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;m&bslash;n&quot;
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|adrs
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;b&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
(brace
id|size
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OG
l_int|4
)paren
(brace
id|size
op_assign
l_int|4
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
id|n
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.8x%c&quot;
comma
id|adrs
comma
id|brev
ques
c_cond
l_char|&squot;r&squot;
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mnoread
)paren
(brace
r_if
c_cond
(paren
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|val
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
id|nslash
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|scanhex
c_func
(paren
op_amp
id|n
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
)brace
id|cmd
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_break
suffix:semicolon
id|inc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;&bslash;&squot;&squot;
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|n
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|n
op_assign
id|bsesc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|val
(braket
id|i
)braket
op_assign
id|n
op_rshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brev
)paren
id|byterev
c_func
(paren
id|val
comma
id|size
)paren
suffix:semicolon
id|mwrite
c_func
(paren
id|adrs
comma
id|val
comma
id|size
)paren
suffix:semicolon
id|adrs
op_add_assign
id|size
suffix:semicolon
)brace
id|adrs
op_sub_assign
id|size
suffix:semicolon
id|inc
op_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;,&squot;
suffix:colon
id|adrs
op_add_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;.&squot;
suffix:colon
id|mnoread
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;;&squot;
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;x&squot;
suffix:colon
r_case
id|EOF
suffix:colon
id|scannl
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
r_case
l_char|&squot;v&squot;
suffix:colon
id|size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;w&squot;
suffix:colon
id|size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
id|adrs
op_sub_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;/&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OG
l_int|0
)paren
id|adrs
op_sub_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_add_assign
l_int|4
suffix:semicolon
id|adrs
op_add_assign
l_int|1
op_lshift
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_if
c_cond
(paren
id|nslash
OL
l_int|0
)paren
id|adrs
op_add_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_else
id|nslash
op_assign
l_int|0
suffix:semicolon
id|nslash
op_sub_assign
l_int|4
suffix:semicolon
id|adrs
op_sub_assign
l_int|1
op_lshift
op_minus
id|nslash
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|scanhex
c_func
(paren
op_amp
id|adrs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|mnoread
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|brev
op_assign
op_logical_neg
id|brev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&lt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_sub_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
id|n
op_assign
id|size
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|n
)paren
suffix:semicolon
id|adrs
op_add_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|adrs
op_add_assign
id|inc
suffix:semicolon
)brace
)brace
r_int
DECL|function|bsesc
id|bsesc
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;n&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;b&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|c
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|macro|isxdigit
mdefine_line|#define isxdigit(c)&t;((&squot;0&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;9&squot;) &bslash;&n;&t;&t;&t; || (&squot;a&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;f&squot;) &bslash;&n;&t;&t;&t; || (&squot;A&squot; &lt;= (c) &amp;&amp; (c) &lt;= &squot;F&squot;))
r_void
DECL|function|dump
id|dump
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isxdigit
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;f&squot;
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
id|c
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|adrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;i&squot;
)paren
(brace
id|scanhex
c_func
(paren
op_amp
id|nidump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nidump
op_eq
l_int|0
)paren
(brace
id|nidump
op_assign
l_int|16
suffix:semicolon
)brace
id|adrs
op_add_assign
id|ppc_inst_dump
c_func
(paren
id|adrs
comma
id|nidump
)paren
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;di&bslash;n&quot;
suffix:semicolon
)brace
r_else
(brace
id|scanhex
c_func
(paren
op_amp
id|ndump
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ndump
op_eq
l_int|0
)paren
(brace
id|ndump
op_assign
l_int|64
suffix:semicolon
)brace
id|prdump
c_func
(paren
id|adrs
comma
id|ndump
)paren
suffix:semicolon
id|adrs
op_add_assign
id|ndump
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;d&bslash;n&quot;
suffix:semicolon
)brace
)brace
r_void
DECL|function|prdump
id|prdump
c_func
(paren
r_int
id|adrs
comma
r_int
id|ndump
)paren
(brace
r_register
r_int
id|n
comma
id|m
comma
id|c
comma
id|r
comma
id|nr
suffix:semicolon
r_int
r_char
id|temp
(braket
l_int|16
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|ndump
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.8x&quot;
comma
id|adrs
)paren
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|r
op_assign
id|n
OL
l_int|16
ques
c_cond
id|n
suffix:colon
l_int|16
suffix:semicolon
id|nr
op_assign
id|mread
c_func
(paren
id|adrs
comma
id|temp
comma
id|r
)paren
suffix:semicolon
id|adrs
op_add_assign
id|nr
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
id|putchar
c_func
(paren
(paren
id|m
op_amp
l_int|3
)paren
op_eq
l_int|0
op_logical_and
id|m
OG
l_int|0
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|temp
(braket
id|m
)braket
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fault_chars
(braket
id|fault_type
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;   &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;  |&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|r
suffix:semicolon
op_increment
id|m
)paren
(brace
r_if
c_cond
(paren
id|m
OL
id|nr
)paren
(brace
id|c
op_assign
id|temp
(braket
id|m
)braket
suffix:semicolon
id|putchar
c_func
(paren
l_char|&squot; &squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;~&squot;
ques
c_cond
id|c
suffix:colon
l_char|&squot;.&squot;
)paren
suffix:semicolon
)brace
r_else
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|n
op_sub_assign
id|r
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|m
OL
l_int|16
suffix:semicolon
op_increment
id|m
)paren
(brace
id|putchar
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
id|r
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_int
DECL|function|ppc_inst_dump
id|ppc_inst_dump
c_func
(paren
r_int
id|adr
comma
r_int
id|count
)paren
(brace
r_int
id|nr
comma
id|dotted
suffix:semicolon
r_int
id|first_adr
suffix:semicolon
r_int
r_int
id|inst
comma
id|last_inst
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|dotted
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|first_adr
op_assign
id|adr
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
op_decrement
id|count
comma
id|adr
op_add_assign
l_int|4
)paren
(brace
id|nr
op_assign
id|mread
c_func
(paren
id|adr
comma
id|val
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
l_int|0
)paren
(brace
r_const
r_char
op_star
id|x
op_assign
id|fault_chars
(braket
id|fault_type
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.8x  %s%s%s%s&bslash;n&quot;
comma
id|adr
comma
id|x
comma
id|x
comma
id|x
comma
id|x
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|inst
op_assign
id|GETWORD
c_func
(paren
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adr
OG
id|first_adr
op_logical_and
id|inst
op_eq
id|last_inst
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dotted
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; ...&bslash;n&quot;
)paren
suffix:semicolon
id|dotted
op_assign
l_int|1
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|dotted
op_assign
l_int|0
suffix:semicolon
id|last_inst
op_assign
id|inst
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.8x  &quot;
comma
id|adr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;t&quot;
comma
id|inst
)paren
suffix:semicolon
id|print_insn_big_powerpc
c_func
(paren
id|stdout
comma
id|inst
comma
id|adr
)paren
suffix:semicolon
multiline_comment|/* always returns 4 */
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|adr
op_minus
id|first_adr
suffix:semicolon
)brace
r_void
DECL|function|print_address
id|print_address
c_func
(paren
id|addr
)paren
r_int
id|addr
suffix:semicolon
(brace
id|printf
c_func
(paren
l_string|&quot;0x%x&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Memory operations - move, set, print differences&n; */
DECL|variable|mdest
r_static
r_int
id|mdest
suffix:semicolon
multiline_comment|/* destination address */
DECL|variable|msrc
r_static
r_int
id|msrc
suffix:semicolon
multiline_comment|/* source address */
DECL|variable|mval
r_static
r_int
id|mval
suffix:semicolon
multiline_comment|/* byte value to set memory to */
DECL|variable|mcount
r_static
r_int
id|mcount
suffix:semicolon
multiline_comment|/* # bytes to affect */
DECL|variable|mdiffs
r_static
r_int
id|mdiffs
suffix:semicolon
multiline_comment|/* max # differences to print */
r_void
DECL|function|memops
id|memops
c_func
(paren
r_int
id|cmd
)paren
(brace
id|scanhex
c_func
(paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
id|cmd
op_eq
l_char|&squot;s&squot;
ques
c_cond
op_amp
id|mval
suffix:colon
op_amp
id|msrc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
op_amp
id|mcount
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_char|&squot;m&squot;
suffix:colon
id|memmove
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
(paren
r_void
op_star
)paren
id|msrc
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|mdest
comma
id|mval
comma
id|mcount
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
id|scanhex
c_func
(paren
op_amp
id|mdiffs
)paren
suffix:semicolon
id|memdiffs
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mdest
comma
(paren
r_int
r_char
op_star
)paren
id|msrc
comma
id|mcount
comma
id|mdiffs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_void
DECL|function|memdiffs
id|memdiffs
c_func
(paren
r_int
r_char
op_star
id|p1
comma
r_int
r_char
op_star
id|p2
comma
r_int
id|nb
comma
r_int
id|maxpr
)paren
(brace
r_int
id|n
comma
id|prt
suffix:semicolon
id|prt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|nb
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
op_decrement
id|n
)paren
r_if
c_cond
(paren
op_star
id|p1
op_increment
op_ne
op_star
id|p2
op_increment
)paren
r_if
c_cond
(paren
op_increment
id|prt
op_le
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.8x %.2x # %.8x %.2x&bslash;n&quot;
comma
(paren
r_int
)paren
id|p1
op_minus
l_int|1
comma
id|p1
(braket
op_minus
l_int|1
)braket
comma
(paren
r_int
)paren
id|p2
op_minus
l_int|1
comma
id|p2
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prt
OG
id|maxpr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Total of %d differences&bslash;n&quot;
comma
id|prt
)paren
suffix:semicolon
)brace
)brace
DECL|variable|mend
r_static
r_int
id|mend
suffix:semicolon
DECL|variable|mask
r_static
r_int
id|mask
suffix:semicolon
r_void
DECL|function|memlocate
id|memlocate
c_func
(paren
)paren
(brace
r_int
id|a
comma
id|n
suffix:semicolon
r_int
r_char
id|val
(braket
l_int|4
)braket
suffix:semicolon
id|last_cmd
op_assign
l_string|&quot;ml&quot;
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mval
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mask
)paren
suffix:semicolon
)brace
)brace
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mend
suffix:semicolon
id|a
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|mread
c_func
(paren
id|a
comma
id|val
comma
l_int|4
)paren
op_eq
l_int|4
op_logical_and
(paren
(paren
id|GETWORD
c_func
(paren
id|val
)paren
op_xor
id|mval
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.8x:  %.8x&bslash;n&quot;
comma
id|a
comma
id|GETWORD
c_func
(paren
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|n
op_ge
l_int|10
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|variable|mskip
r_static
r_int
id|mskip
op_assign
l_int|0x1000
suffix:semicolon
DECL|variable|mlim
r_static
r_int
id|mlim
op_assign
l_int|0xffffffff
suffix:semicolon
r_void
DECL|function|memzcan
id|memzcan
c_func
(paren
)paren
(brace
r_int
r_char
id|v
suffix:semicolon
r_int
id|a
suffix:semicolon
r_int
id|ok
comma
id|ook
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mdest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mskip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|termch
op_assign
l_int|0
suffix:semicolon
id|scanhex
c_func
(paren
op_amp
id|mlim
)paren
suffix:semicolon
id|ook
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|mdest
suffix:semicolon
id|a
OL
id|mlim
suffix:semicolon
id|a
op_add_assign
id|mskip
)paren
(brace
id|ok
op_assign
id|mread
c_func
(paren
id|a
comma
op_amp
id|v
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
op_logical_and
op_logical_neg
id|ook
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%.8x .. &quot;
comma
id|a
)paren
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ok
op_logical_and
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
id|ook
op_assign
id|ok
suffix:semicolon
r_if
c_cond
(paren
id|a
op_plus
id|mskip
OL
id|a
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ook
)paren
id|printf
c_func
(paren
l_string|&quot;%.8x&bslash;n&quot;
comma
id|a
op_minus
id|mskip
)paren
suffix:semicolon
)brace
multiline_comment|/* Input scanning routines */
r_int
DECL|function|skipbl
id|skipbl
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
r_if
c_cond
(paren
id|termch
op_ne
l_int|0
)paren
(brace
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
r_int
DECL|function|scanhex
id|scanhex
c_func
(paren
id|vp
)paren
r_int
op_star
id|vp
suffix:semicolon
(brace
r_int
id|c
comma
id|d
suffix:semicolon
r_int
id|v
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
id|EOF
)paren
(brace
id|termch
op_assign
id|c
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|v
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|v
op_assign
(paren
id|v
op_lshift
l_int|4
)paren
op_plus
id|d
suffix:semicolon
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
id|d
op_assign
id|hexdigit
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|d
op_ne
id|EOF
)paren
(brace
suffix:semicolon
)brace
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|vp
op_assign
id|v
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|scannl
id|scannl
c_func
(paren
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|termch
suffix:semicolon
id|termch
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|hexdigit
id|hexdigit
c_func
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
l_char|&squot;0&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
(brace
r_return
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;A&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
l_char|&squot;a&squot;
op_le
id|c
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
(brace
r_return
id|c
op_minus
(paren
l_char|&squot;a&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_return
id|EOF
suffix:semicolon
)brace
r_void
DECL|function|getstring
id|getstring
c_func
(paren
r_char
op_star
id|s
comma
r_int
id|size
)paren
(brace
r_int
id|c
suffix:semicolon
id|c
op_assign
id|skipbl
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|size
OG
l_int|1
)paren
(brace
op_star
id|s
op_increment
op_assign
id|c
suffix:semicolon
op_decrement
id|size
suffix:semicolon
)brace
id|c
op_assign
id|inchar
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot; &squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;t&squot;
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
suffix:semicolon
)brace
id|termch
op_assign
id|c
suffix:semicolon
op_star
id|s
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|line
r_static
r_char
id|line
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|lineptr
r_static
r_char
op_star
id|lineptr
suffix:semicolon
r_void
DECL|function|flush_input
id|flush_input
c_func
(paren
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_int
DECL|function|inchar
id|inchar
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|lineptr
op_eq
l_int|NULL
op_logical_or
op_star
id|lineptr
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|stdin
)paren
op_eq
l_int|NULL
)paren
(brace
id|lineptr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|EOF
suffix:semicolon
)brace
id|lineptr
op_assign
id|line
suffix:semicolon
)brace
r_return
op_star
id|lineptr
op_increment
suffix:semicolon
)brace
r_void
DECL|function|take_input
id|take_input
c_func
(paren
id|str
)paren
r_char
op_star
id|str
suffix:semicolon
(brace
id|lineptr
op_assign
id|str
suffix:semicolon
)brace
DECL|function|pretty_print_addr
r_static
r_char
op_star
id|pretty_print_addr
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%08x&quot;
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lookup_name
c_func
(paren
id|addr
)paren
)paren
id|printf
c_func
(paren
l_string|&quot; %s&quot;
comma
id|lookup_name
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|lookup_name
r_static
r_char
op_star
id|lookup_name
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_extern
r_char
op_star
id|sysmap
suffix:semicolon
r_extern
r_int
r_int
id|sysmap_size
suffix:semicolon
r_char
op_star
id|c
op_assign
id|sysmap
suffix:semicolon
r_int
r_int
id|cmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sysmap
op_logical_or
op_logical_neg
id|sysmap_size
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
macro_line|#if 0
id|cmp
op_assign
id|simple_strtoul
c_func
(paren
id|c
comma
op_amp
id|c
comma
l_int|8
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|last
comma
id|strsep
c_func
(paren
op_amp
id|c
comma
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
OL
(paren
id|sysmap
op_plus
id|sysmap_size
)paren
)paren
(brace
id|cmp
op_assign
id|simple_strtoul
c_func
(paren
id|c
comma
op_amp
id|c
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OL
id|addr
)paren
r_break
suffix:semicolon
id|strcpy
c_func
(paren
id|last
comma
id|strsep
c_func
(paren
op_amp
id|c
comma
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|NULLlast
suffix:semicolon
macro_line|#endif&t;
)brace
eof
