multiline_comment|/*&n; * This program will make a type 0x41 load image from an&n; * executable file.  Note:  assumes that the executable has&n; * already been &quot;flattened&quot; by &squot;mkboot&squot;.&n; *&n; * usage: mk_type41 flat-file image&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
DECL|function|_LE
id|_LE
c_func
(paren
r_int
id|val
comma
r_int
r_char
op_star
id|le
)paren
(brace
id|le
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
id|le
(braket
l_int|1
)braket
op_assign
id|val
op_rshift
l_int|8
suffix:semicolon
id|le
(braket
l_int|2
)braket
op_assign
id|val
op_rshift
l_int|16
suffix:semicolon
id|le
(braket
l_int|3
)braket
op_assign
id|val
op_rshift
l_int|24
suffix:semicolon
)brace
DECL|function|main
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|in_fd
comma
id|out_fd
comma
id|len
comma
id|size
suffix:semicolon
r_struct
id|stat
id|info
suffix:semicolon
r_char
id|buf
(braket
l_int|8192
)braket
suffix:semicolon
r_struct
id|hdr
(brace
r_int
r_int
id|entry_point
suffix:semicolon
r_int
r_int
id|image_length
suffix:semicolon
)brace
id|hdr
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;usage: mk_type41 &lt;boot-file&gt; &lt;image&gt;&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|in_fd
op_assign
id|open
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t open input file: &squot;%s&squot;: %s&bslash;n&quot;
comma
id|argv
(braket
l_int|1
)braket
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|out_fd
op_assign
id|creat
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
l_int|0666
)paren
)paren
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t create outpue file: &squot;%s&squot;: %s&bslash;n&quot;
comma
id|argv
(braket
l_int|2
)braket
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|in_fd
comma
op_amp
id|info
)paren
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t get info on input file: %s&bslash;n&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|write_prep_boot_partition
c_func
(paren
id|out_fd
)paren
suffix:semicolon
id|_LE
c_func
(paren
l_int|0x400
comma
op_amp
id|hdr.entry_point
)paren
suffix:semicolon
id|_LE
c_func
(paren
id|info.st_size
op_plus
l_int|0x400
comma
op_amp
id|hdr.image_length
)paren
suffix:semicolon
id|lseek
c_func
(paren
id|out_fd
comma
l_int|0x200
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
c_func
(paren
id|out_fd
comma
op_amp
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
op_ne
r_sizeof
(paren
id|hdr
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t write output file: %s&bslash;n&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|lseek
c_func
(paren
id|out_fd
comma
l_int|0x400
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len
op_assign
id|read
c_func
(paren
id|in_fd
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|write
c_func
(paren
id|out_fd
comma
id|buf
comma
id|len
)paren
op_ne
id|len
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t write output file: %s&bslash;n&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t read input file: %s&bslash;n&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
m_exit
(paren
l_int|6
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|in_fd
)paren
suffix:semicolon
id|close
c_func
(paren
id|out_fd
)paren
suffix:semicolon
)brace
multiline_comment|/* Adapted from IBM Naked Application Package (NAP) */
DECL|macro|Align
mdefine_line|#define Align(value,boundary)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(((value) + (boundary) - 1) &amp; ~((boundary) - 1))
DECL|macro|HiByte
mdefine_line|#define HiByte(word)&t;&t;((word_t)(word) &gt;&gt; 8)
DECL|macro|LoByte
mdefine_line|#define LoByte(word)&t;&t;((word_t)(word) &amp; 0xFF)
DECL|macro|HiWord
mdefine_line|#define HiWord(dword)&t;&t;((dword_t)(dword) &gt;&gt; 16)
DECL|macro|LoWord
mdefine_line|#define LoWord(dword)&t;&t;((dword_t)(dword) &amp; 0xFFFF)
multiline_comment|/*&n; * Little-endian stuff&n; */
DECL|macro|LeWord
mdefine_line|#define LeWord(word)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(((word_t)(word) &gt;&gt; 8) | ((word_t)(word) &lt;&lt; 8))
DECL|macro|LeDword
mdefine_line|#define LeDword(dword)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(LeWord(LoWord(dword)) &lt;&lt; 16) | LeWord(HiWord(dword))
DECL|macro|PcDword
mdefine_line|#define PcDword(dword)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(LeWord(LoWord(dword)) &lt;&lt; 16) | LeWord(HiWord(dword))
DECL|typedef|dword_t
r_typedef
r_int
r_int
id|dword_t
suffix:semicolon
DECL|typedef|word_t
r_typedef
r_int
r_int
id|word_t
suffix:semicolon
DECL|typedef|byte_t
r_typedef
r_int
r_char
id|byte_t
suffix:semicolon
DECL|typedef|block_t
r_typedef
id|byte_t
id|block_t
(braket
l_int|512
)braket
suffix:semicolon
DECL|typedef|page_t
r_typedef
id|byte_t
id|page_t
(braket
l_int|4096
)braket
suffix:semicolon
multiline_comment|/*&n; * Partition table entry&n; *  - from the PReP spec&n; */
DECL|struct|partition_entry
r_typedef
r_struct
id|partition_entry
(brace
DECL|member|boot_indicator
id|byte_t
id|boot_indicator
suffix:semicolon
DECL|member|starting_head
id|byte_t
id|starting_head
suffix:semicolon
DECL|member|starting_sector
id|byte_t
id|starting_sector
suffix:semicolon
DECL|member|starting_cylinder
id|byte_t
id|starting_cylinder
suffix:semicolon
DECL|member|system_indicator
id|byte_t
id|system_indicator
suffix:semicolon
DECL|member|ending_head
id|byte_t
id|ending_head
suffix:semicolon
DECL|member|ending_sector
id|byte_t
id|ending_sector
suffix:semicolon
DECL|member|ending_cylinder
id|byte_t
id|ending_cylinder
suffix:semicolon
DECL|member|beginning_sector
id|dword_t
id|beginning_sector
suffix:semicolon
DECL|member|number_of_sectors
id|dword_t
id|number_of_sectors
suffix:semicolon
DECL|typedef|partition_entry_t
)brace
id|partition_entry_t
suffix:semicolon
DECL|macro|BootActive
mdefine_line|#define BootActive&t;0x80
DECL|macro|SystemPrep
mdefine_line|#define SystemPrep&t;0x41
multiline_comment|/*&n; * Writes the &quot;boot record&quot;, which contains the partition table, to the&n; * diskette, followed by the dummy PC boot block and load image descriptor&n; * block.  It returns the number of bytes it has written to the load&n; * image.&n; *&n; * The boot record is the first block of the diskette and identifies the&n; * &quot;PReP&quot; partition.  The &quot;PReP&quot; partition contains the &quot;load image&quot; starting&n; * at offset zero within the partition.  The first block of the load image is&n; * a dummy PC boot block.  The second block is the &quot;load image descriptor&quot;&n; * which contains the size of the load image and the entry point into the&n; * image.  The actual boot image starts at offset 1024 bytes (third sector)&n; * in the partition.&n; */
r_void
DECL|function|write_prep_boot_partition
id|write_prep_boot_partition
c_func
(paren
r_int
id|out_fd
)paren
(brace
id|block_t
id|block
suffix:semicolon
id|partition_entry_t
op_star
id|pe
op_assign
(paren
id|partition_entry_t
op_star
)paren
op_amp
id|block
(braket
l_int|0x1BE
)braket
suffix:semicolon
id|dword_t
op_star
id|entry
op_assign
(paren
id|dword_t
op_star
)paren
op_amp
id|block
(braket
l_int|0
)braket
suffix:semicolon
id|dword_t
op_star
id|length
op_assign
(paren
id|dword_t
op_star
)paren
op_amp
id|block
(braket
l_int|4
)braket
suffix:semicolon
id|bzero
c_func
(paren
op_amp
id|block
comma
r_sizeof
id|block
)paren
suffix:semicolon
multiline_comment|/*&n;     * Magic marker&n;     */
id|block
(braket
l_int|510
)braket
op_assign
l_int|0x55
suffix:semicolon
id|block
(braket
l_int|511
)braket
op_assign
l_int|0xAA
suffix:semicolon
multiline_comment|/*&n;     * Build a &quot;PReP&quot; partition table entry in the boot record&n;     *  - &quot;PReP&quot; may only look at the system_indicator&n;     */
id|pe-&gt;boot_indicator
op_assign
id|BootActive
suffix:semicolon
id|pe-&gt;system_indicator
op_assign
id|SystemPrep
suffix:semicolon
multiline_comment|/*&n;     * The first block of the diskette is used by this &quot;boot record&quot; which&n;     * actually contains the partition table. (The first block of the&n;     * partition contains the boot image, but I digress...)  We&squot;ll set up&n;     * one partition on the diskette and it shall contain the rest of the&n;     * diskette.&n;     */
id|pe-&gt;starting_head
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero-based&t;&t;&t;     */
id|pe-&gt;starting_sector
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* one-based&t;&t;&t;     */
id|pe-&gt;starting_cylinder
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero-based&t;&t;&t;     */
id|pe-&gt;ending_head
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* assumes two heads&t;&t;     */
id|pe-&gt;ending_sector
op_assign
l_int|18
suffix:semicolon
multiline_comment|/* assumes 18 sectors/track&t;     */
id|pe-&gt;ending_cylinder
op_assign
l_int|79
suffix:semicolon
multiline_comment|/* assumes 80 cylinders/diskette     */
multiline_comment|/*&n;     * The &quot;PReP&quot; software ignores the above fields and just looks at&n;     * the next two.&n;     *   - size of the diskette is (assumed to be)&n;     *     (2 tracks/cylinder)(18 sectors/tracks)(80 cylinders/diskette)&n;     *   - unlike the above sector nunbers, the beginning sector is zero-based!&n;     */
macro_line|#if 0     
id|pe-&gt;beginning_sector
op_assign
id|LeDword
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* This has to be 0 on the PowerStack? */
id|pe-&gt;beginning_sector
op_assign
id|LeDword
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif    
id|pe-&gt;number_of_sectors
op_assign
id|LeDword
c_func
(paren
l_int|2
op_star
l_int|18
op_star
l_int|80
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;     * Write the partition table&n;     */
id|lseek
c_func
(paren
id|out_fd
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|write
c_func
(paren
id|out_fd
comma
id|block
comma
r_sizeof
id|block
)paren
suffix:semicolon
)brace
eof
