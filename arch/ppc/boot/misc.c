multiline_comment|/*&n; * misc.c&n; *&n; * $Id: misc.c,v 1.52 1998/09/19 01:21:24 cort Exp $&n; * &n; * Adapted for PowerPC by Gary Thomas&n; *&n; * Rewritten by Cort Dougan (cort@cs.nmt.edu)&n; * One day to be replaced by a single bootloader for chrp/prep/pmac. -- Cort&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &quot;../coffboot/zlib.h&quot;
macro_line|#include &quot;asm/residual.h&quot;
macro_line|#include &lt;elf.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#ifdef CONFIG_MBX
macro_line|#include &lt;asm/mbx.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_FADS
macro_line|#include &lt;asm/fads.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Please send me load/board info and such data for hardware not&n; * listed here so I can keep track since things are getting tricky&n; * with the different load addrs with different firmware.  This will&n; * help to avoid breaking the load/boot process.&n; * -- Cort&n; */
DECL|variable|avail_ram
r_char
op_star
id|avail_ram
suffix:semicolon
DECL|variable|end_avail
r_char
op_star
id|end_avail
suffix:semicolon
multiline_comment|/* Because of the limited amount of memory on the MBX, it presents&n; * loading problems.  The biggest is that we load this boot program&n; * into a relatively low memory address, and the Linux kernel Bss often&n; * extends into this space when it get loaded.  When the kernel starts&n; * and zeros the BSS space, it also writes over the information we&n; * save here and pass to the kernel (command line and board info).&n; * On the MBX we grab some known memory holes to hold this information.&n; */
DECL|variable|cmd_buf
r_char
id|cmd_buf
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|cmd_line
r_char
op_star
id|cmd_line
op_assign
id|cmd_buf
suffix:semicolon
macro_line|#if defined(CONFIG_MBX) || defined(CONFIG_FADS)
DECL|variable|root_string
r_char
op_star
id|root_string
op_assign
l_string|&quot;root=/dev/nfs&quot;
suffix:semicolon
DECL|variable|nfsaddrs_string
r_char
op_star
id|nfsaddrs_string
op_assign
l_string|&quot;nfsaddrs=&quot;
suffix:semicolon
DECL|variable|nfsroot_string
r_char
op_star
id|nfsroot_string
op_assign
l_string|&quot;nfsroot=&quot;
suffix:semicolon
DECL|variable|defroot_string
r_char
op_star
id|defroot_string
op_assign
l_string|&quot;/sys/mbxroot&quot;
suffix:semicolon
r_int
id|do_ipaddrs
c_func
(paren
r_char
op_star
op_star
id|cmd_cp
comma
r_int
id|echo
)paren
suffix:semicolon
r_void
id|do_nfsroot
c_func
(paren
r_char
op_star
op_star
id|cmd_cp
comma
r_char
op_star
id|dp
)paren
suffix:semicolon
r_int
id|strncmp
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
comma
r_int
id|count
)paren
suffix:semicolon
r_char
op_star
id|strrchr
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|c
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|hold_resid_buf
id|RESIDUAL
id|hold_resid_buf
suffix:semicolon
DECL|variable|hold_residual
id|RESIDUAL
op_star
id|hold_residual
op_assign
op_amp
id|hold_resid_buf
suffix:semicolon
DECL|variable|initrd_start
DECL|variable|initrd_end
r_int
r_int
id|initrd_start
op_assign
l_int|0
comma
id|initrd_end
op_assign
l_int|0
suffix:semicolon
DECL|variable|zimage_start
r_char
op_star
id|zimage_start
suffix:semicolon
DECL|variable|zimage_size
r_int
id|zimage_size
suffix:semicolon
DECL|variable|vidmem
r_char
op_star
id|vidmem
op_assign
(paren
r_char
op_star
)paren
l_int|0xC00B8000
suffix:semicolon
DECL|variable|lines
DECL|variable|cols
r_int
id|lines
comma
id|cols
suffix:semicolon
DECL|variable|orig_x
DECL|variable|orig_y
r_int
id|orig_x
comma
id|orig_y
suffix:semicolon
r_void
id|puts
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_void
id|putc
c_func
(paren
r_const
r_char
id|c
)paren
suffix:semicolon
r_void
id|puthex
c_func
(paren
r_int
r_int
id|val
)paren
suffix:semicolon
r_void
id|_bcopy
c_func
(paren
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_void
op_star
id|memcpy
c_func
(paren
r_void
op_star
id|__dest
comma
id|__const
r_void
op_star
id|__src
comma
r_int
id|__n
)paren
suffix:semicolon
r_void
id|gunzip
c_func
(paren
r_void
op_star
comma
r_int
comma
r_int
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
DECL|function|pause
r_void
id|pause
c_func
(paren
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;pause&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|exit
r_void
m_exit
(paren
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;exit&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
macro_line|#if !defined(CONFIG_MBX) &amp;&amp; !defined(CONFIG_FADS)
DECL|function|clear_screen
r_static
r_void
id|clear_screen
c_func
(paren
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lines
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|cols
suffix:semicolon
id|j
op_increment
)paren
(brace
id|vidmem
(braket
(paren
(paren
id|i
op_star
id|cols
)paren
op_plus
id|j
)paren
op_star
l_int|2
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|vidmem
(braket
(paren
(paren
id|i
op_star
id|cols
)paren
op_plus
id|j
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
op_assign
l_int|0x07
suffix:semicolon
)brace
)brace
)brace
DECL|function|scroll
r_static
r_void
id|scroll
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|memcpy
(paren
id|vidmem
comma
id|vidmem
op_plus
id|cols
op_star
l_int|2
comma
(paren
id|lines
op_minus
l_int|1
)paren
op_star
id|cols
op_star
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
id|lines
op_minus
l_int|1
)paren
op_star
id|cols
op_star
l_int|2
suffix:semicolon
id|i
OL
id|lines
op_star
id|cols
op_star
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|vidmem
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
DECL|function|tstc
id|tstc
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|CRT_tstc
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|getc
id|getc
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|CRT_tstc
c_func
(paren
)paren
)paren
r_return
(paren
id|CRT_getc
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|putc
id|putc
c_func
(paren
r_const
r_char
id|c
)paren
(brace
r_int
id|x
comma
id|y
suffix:semicolon
id|x
op_assign
id|orig_x
suffix:semicolon
id|y
op_assign
id|orig_y
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
id|scroll
c_func
(paren
)paren
suffix:semicolon
id|y
op_decrement
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;b&squot;
)paren
(brace
r_if
c_cond
(paren
id|x
OG
l_int|0
)paren
(brace
id|x
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
id|vidmem
(braket
(paren
id|x
op_plus
id|cols
op_star
id|y
)paren
op_star
l_int|2
)braket
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|x
op_ge
id|cols
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
id|scroll
c_func
(paren
)paren
suffix:semicolon
id|y
op_decrement
suffix:semicolon
)brace
)brace
)brace
id|cursor
c_func
(paren
id|x
comma
id|y
)paren
suffix:semicolon
id|orig_x
op_assign
id|x
suffix:semicolon
id|orig_y
op_assign
id|y
suffix:semicolon
)brace
DECL|function|puts
r_void
id|puts
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|x
comma
id|y
suffix:semicolon
r_char
id|c
suffix:semicolon
id|x
op_assign
id|orig_x
suffix:semicolon
id|y
op_assign
id|orig_y
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|s
op_increment
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
id|scroll
c_func
(paren
)paren
suffix:semicolon
id|y
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
id|vidmem
(braket
(paren
id|x
op_plus
id|cols
op_star
id|y
)paren
op_star
l_int|2
)braket
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|x
op_ge
id|cols
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
id|scroll
c_func
(paren
)paren
suffix:semicolon
id|y
op_decrement
suffix:semicolon
)brace
)brace
)brace
)brace
id|orig_x
op_assign
id|x
suffix:semicolon
id|orig_y
op_assign
id|y
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* The MBX is just the serial port.&n;*/
DECL|function|tstc
id|tstc
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|serial_tstc
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|getc
id|getc
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|serial_tstc
c_func
(paren
)paren
)paren
r_return
(paren
id|serial_getc
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|putc
id|putc
c_func
(paren
r_const
r_char
id|c
)paren
(brace
id|serial_putchar
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|puts
r_void
id|puts
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_char
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|s
op_increment
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|serial_putchar
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|serial_putchar
c_func
(paren
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_MBX */
DECL|function|memcpy
r_void
op_star
id|memcpy
c_func
(paren
r_void
op_star
id|__dest
comma
id|__const
r_void
op_star
id|__src
comma
r_int
id|__n
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|d
op_assign
(paren
r_char
op_star
)paren
id|__dest
comma
op_star
id|s
op_assign
(paren
r_char
op_star
)paren
id|__src
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|__n
suffix:semicolon
id|i
op_increment
)paren
id|d
(braket
id|i
)braket
op_assign
id|s
(braket
id|i
)braket
suffix:semicolon
)brace
DECL|function|memcmp
r_int
id|memcmp
c_func
(paren
id|__const
r_void
op_star
id|__dest
comma
id|__const
r_void
op_star
id|__src
comma
r_int
id|__n
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|d
op_assign
(paren
r_char
op_star
)paren
id|__dest
comma
op_star
id|s
op_assign
(paren
r_char
op_star
)paren
id|__src
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|__n
suffix:semicolon
id|i
op_increment
comma
id|d
op_increment
comma
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|d
op_ne
op_star
id|s
)paren
(brace
r_return
(paren
op_star
id|s
op_minus
op_star
id|d
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|error
r_void
id|error
c_func
(paren
r_char
op_star
id|x
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
id|x
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&bslash;n -- System halted&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Halt */
)brace
DECL|function|zalloc
r_void
op_star
id|zalloc
c_func
(paren
r_void
op_star
id|x
comma
r_int
id|items
comma
r_int
id|size
)paren
(brace
r_void
op_star
id|p
op_assign
id|avail_ram
suffix:semicolon
id|size
op_mul_assign
id|items
suffix:semicolon
id|size
op_assign
(paren
id|size
op_plus
l_int|7
)paren
op_amp
op_minus
l_int|8
suffix:semicolon
id|avail_ram
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|avail_ram
OG
id|end_avail
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;oops... out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|pause
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|function|zfree
r_void
id|zfree
c_func
(paren
r_void
op_star
id|x
comma
r_void
op_star
id|addr
comma
r_int
id|nb
)paren
(brace
)brace
DECL|macro|HEAD_CRC
mdefine_line|#define HEAD_CRC&t;2
DECL|macro|EXTRA_FIELD
mdefine_line|#define EXTRA_FIELD&t;4
DECL|macro|ORIG_NAME
mdefine_line|#define ORIG_NAME&t;8
DECL|macro|COMMENT
mdefine_line|#define COMMENT&t;&t;0x10
DECL|macro|RESERVED
mdefine_line|#define RESERVED&t;0xe0
DECL|macro|DEFLATED
mdefine_line|#define DEFLATED&t;8
DECL|function|gunzip
r_void
id|gunzip
c_func
(paren
r_void
op_star
id|dst
comma
r_int
id|dstlen
comma
r_int
r_char
op_star
id|src
comma
r_int
op_star
id|lenp
)paren
(brace
id|z_stream
id|s
suffix:semicolon
r_int
id|r
comma
id|i
comma
id|flags
suffix:semicolon
multiline_comment|/* skip header */
id|i
op_assign
l_int|10
suffix:semicolon
id|flags
op_assign
id|src
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|src
(braket
l_int|2
)braket
op_ne
id|DEFLATED
op_logical_or
(paren
id|flags
op_amp
id|RESERVED
)paren
op_ne
l_int|0
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;bad gzipped data&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|EXTRA_FIELD
)paren
op_ne
l_int|0
)paren
id|i
op_assign
l_int|12
op_plus
id|src
(braket
l_int|10
)braket
op_plus
(paren
id|src
(braket
l_int|11
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|ORIG_NAME
)paren
op_ne
l_int|0
)paren
r_while
c_loop
(paren
id|src
(braket
id|i
op_increment
)braket
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|COMMENT
)paren
op_ne
l_int|0
)paren
r_while
c_loop
(paren
id|src
(braket
id|i
op_increment
)braket
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|HEAD_CRC
)paren
op_ne
l_int|0
)paren
id|i
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
op_star
id|lenp
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;gunzip: ran out of data in header&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
)paren
suffix:semicolon
)brace
id|s.zalloc
op_assign
id|zalloc
suffix:semicolon
id|s.zfree
op_assign
id|zfree
suffix:semicolon
id|r
op_assign
id|inflateInit2
c_func
(paren
op_amp
id|s
comma
op_minus
id|MAX_WBITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|Z_OK
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;inflateInit2 returned %d&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
)paren
suffix:semicolon
)brace
id|s.next_in
op_assign
id|src
op_plus
id|i
suffix:semicolon
id|s.avail_in
op_assign
op_star
id|lenp
op_minus
id|i
suffix:semicolon
id|s.next_out
op_assign
id|dst
suffix:semicolon
id|s.avail_out
op_assign
id|dstlen
suffix:semicolon
id|r
op_assign
id|inflate
c_func
(paren
op_amp
id|s
comma
id|Z_FINISH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|Z_OK
op_logical_and
id|r
op_ne
id|Z_STREAM_END
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;inflate returned %d&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
)paren
suffix:semicolon
)brace
op_star
id|lenp
op_assign
id|s.next_out
op_minus
(paren
r_int
r_char
op_star
)paren
id|dst
suffix:semicolon
id|inflateEnd
c_func
(paren
op_amp
id|s
)paren
suffix:semicolon
)brace
DECL|variable|sanity
r_int
r_char
id|sanity
(braket
l_int|0x2000
)braket
suffix:semicolon
r_int
r_int
DECL|function|decompress_kernel
id|decompress_kernel
c_func
(paren
r_int
r_int
id|load_addr
comma
r_int
id|num_words
comma
r_int
r_int
id|cksum
comma
id|RESIDUAL
op_star
id|residual
)paren
(brace
r_int
id|timer
suffix:semicolon
r_extern
r_int
r_int
id|start
suffix:semicolon
r_char
op_star
id|cp
comma
id|ch
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|BATU
op_star
id|u
suffix:semicolon
id|BATL
op_star
id|l
suffix:semicolon
macro_line|#if defined(CONFIG_MBX) || defined(CONFIG_KB)
r_char
op_star
id|dp
suffix:semicolon
macro_line|#endif
id|lines
op_assign
l_int|25
suffix:semicolon
id|cols
op_assign
l_int|80
suffix:semicolon
id|orig_x
op_assign
l_int|0
suffix:semicolon
id|orig_y
op_assign
l_int|24
suffix:semicolon
macro_line|#if !defined(CONFIG_MBX) &amp;&amp; !defined(CONFIG_FADS)
multiline_comment|/*&n;&t; * IBM&squot;s have the MMU on, so we have to disable it or&n;&t; * things get really unhappy in the kernel when&n;&t; * trying to setup the BATs with the MMU on&n;&t; * -- Cort&n;&t; */
id|flush_instruction_cache
c_func
(paren
)paren
suffix:semicolon
id|_put_HID0
c_func
(paren
id|_get_HID0
c_func
(paren
)paren
op_amp
op_complement
l_int|0x0000C000
)paren
suffix:semicolon
id|_put_MSR
c_func
(paren
id|_get_MSR
c_func
(paren
)paren
op_amp
op_complement
l_int|0x0030
)paren
suffix:semicolon
id|vga_init
c_func
(paren
l_int|0xC0000000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|residual
)paren
id|memcpy
c_func
(paren
id|hold_residual
comma
id|residual
comma
r_sizeof
(paren
id|RESIDUAL
)paren
)paren
suffix:semicolon
macro_line|#else /* CONFIG_MBX */
multiline_comment|/* Grab some space for the command line and board info.  Since&n;&t; * we no longer use the ELF header, but it was loaded, grab&n;&t; * that space.&n;&t; */
id|cmd_line
op_assign
(paren
r_char
op_star
)paren
(paren
id|load_addr
op_minus
l_int|0x10000
)paren
suffix:semicolon
id|hold_residual
op_assign
(paren
id|RESIDUAL
op_star
)paren
(paren
id|cmd_line
op_plus
r_sizeof
(paren
id|cmd_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* copy board data */
r_if
c_cond
(paren
id|residual
)paren
id|memcpy
c_func
(paren
id|hold_residual
comma
id|residual
comma
r_sizeof
(paren
id|bd_t
)paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_MBX */
multiline_comment|/* MBX/prep sometimes put the residual/board info at the end of mem &n;&t; * assume 16M for now  -- Cort&n;&t; * To boot on standard MBX boards with 4M, we can&squot;t use initrd,&n;&t; * and we have to assume less memory.  -- Dan&n;&t; */
r_if
c_cond
(paren
id|INITRD_OFFSET
)paren
id|end_avail
op_assign
(paren
r_char
op_star
)paren
l_int|0x01000000
suffix:semicolon
r_else
id|end_avail
op_assign
(paren
r_char
op_star
)paren
l_int|0x00400000
suffix:semicolon
multiline_comment|/* let residual data tell us it&squot;s higher */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|residual
OG
l_int|0x00800000
)paren
id|end_avail
op_assign
(paren
r_char
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|residual
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;loaded at:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|load_addr
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|load_addr
op_plus
(paren
l_int|4
op_star
id|num_words
)paren
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|load_addr
op_ne
(paren
r_int
r_int
)paren
op_amp
id|start
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;relocated to:  &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
op_plus
(paren
l_int|4
op_star
id|num_words
)paren
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|residual
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;board data at: &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|residual
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MBX) || defined(CONFIG_FADS)
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
id|residual
op_plus
r_sizeof
(paren
id|bd_t
)paren
)paren
)paren
suffix:semicolon
macro_line|#else
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
id|residual
op_plus
r_sizeof
(paren
id|RESIDUAL
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;relocated to:  &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|hold_residual
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MBX) || defined(CONFIG_FADS)
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
id|hold_residual
op_plus
r_sizeof
(paren
id|bd_t
)paren
)paren
)paren
suffix:semicolon
macro_line|#else
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
id|hold_residual
op_plus
r_sizeof
(paren
id|RESIDUAL
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* we have to subtract 0x10000 here to correct for objdump including the&n;&t;   size of the elf header which we strip -- Cort */
id|zimage_start
op_assign
(paren
r_char
op_star
)paren
(paren
id|load_addr
op_minus
l_int|0x10000
op_plus
id|ZIMAGE_OFFSET
)paren
suffix:semicolon
id|zimage_size
op_assign
id|ZIMAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|INITRD_OFFSET
)paren
id|initrd_start
op_assign
id|load_addr
op_minus
l_int|0x10000
op_plus
id|INITRD_OFFSET
suffix:semicolon
r_else
id|initrd_start
op_assign
l_int|0
suffix:semicolon
id|initrd_end
op_assign
id|INITRD_SIZE
op_plus
id|initrd_start
suffix:semicolon
multiline_comment|/*&n;&t; * setup avail_ram - this is the first part of ram usable&n;&t; * by the uncompress code. -- Cort&n;&t; */
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|zimage_start
op_plus
id|zimage_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|load_addr
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
OG
(paren
r_int
r_int
)paren
id|avail_ram
)paren
op_logical_and
(paren
id|load_addr
op_le
l_int|0x01000000
)paren
)paren
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
(paren
id|load_addr
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
OG
(paren
r_int
r_int
)paren
id|avail_ram
)paren
op_logical_and
(paren
id|load_addr
op_le
l_int|0x01000000
)paren
)paren
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* relocate zimage */
id|puts
c_func
(paren
l_string|&quot;zimage at:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|zimage_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|zimage_size
op_plus
id|zimage_start
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t relocate the zimage if it was loaded above 16M since&n;&t; * things get weird if we try to relocate -- Cort&n;&t; * We don&squot;t relocate zimage on a base MBX board because of&n;&t; * insufficient memory.  In this case we don&squot;t have initrd either,&n;&t; * so use that as an indicator.  -- Dan&n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|zimage_start
op_le
l_int|0x01000000
)paren
op_logical_and
id|initrd_start
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
op_minus
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|end_avail
op_minus
id|zimage_size
)paren
comma
(paren
r_void
op_star
)paren
id|zimage_start
comma
id|zimage_size
)paren
suffix:semicolon
id|zimage_start
op_assign
(paren
r_char
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
op_minus
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|end_avail
op_minus
id|zimage_size
)paren
suffix:semicolon
id|end_avail
op_assign
(paren
r_char
op_star
)paren
id|zimage_start
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;relocated to:  &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|zimage_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|zimage_size
op_plus
(paren
r_int
r_int
)paren
id|zimage_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* relocate initrd */
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;initrd at:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_end
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Memory is really tight on the MBX (we can assume 4M)&n;&t;&t; * so put the initrd at the TOP of ram, and set end_avail&n;&t;&t; * to right after that.&n;&t;&t; *&n;&t;&t; * I should do something like this for prep, too and keep&n;&t;&t; * a variable end_of_DRAM to keep track of what we think the&n;&t;&t; * max ram is.&n;&t;&t; * -- Cort&n;&t;&t; */
macro_line|#if 0&t;&t;
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
op_minus
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|end_avail
op_minus
id|INITRD_SIZE
)paren
comma
(paren
r_void
op_star
)paren
id|initrd_start
comma
id|INITRD_SIZE
)paren
suffix:semicolon
id|initrd_start
op_assign
id|PAGE_ALIGN
c_func
(paren
op_minus
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|end_avail
op_minus
id|INITRD_SIZE
)paren
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|INITRD_SIZE
suffix:semicolon
id|end_avail
op_assign
(paren
r_char
op_star
)paren
id|initrd_start
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;relocated to:  &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_end
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;
)brace
macro_line|#ifndef CONFIG_MBX
multiline_comment|/* this is safe, just use it */
multiline_comment|/* I don&squot;t know why it didn&squot;t work for me on the MBX with 20 MB&n;&t; * memory.  I guess something was saved up there, but I can&squot;t&n;&t; * figure it out......we are running on luck.  -- Dan.&n;&t; */
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
l_int|0x00400000
suffix:semicolon
id|end_avail
op_assign
(paren
r_char
op_star
)paren
l_int|0x00600000
suffix:semicolon
macro_line|#endif
id|puts
c_func
(paren
l_string|&quot;avail ram:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|avail_ram
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|end_avail
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if !defined(CONFIG_MBX) &amp;&amp; !defined(CONFIG_FADS)
id|CRT_tstc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Forces keyboard to be initialized */
macro_line|#endif
id|puts
c_func
(paren
l_string|&quot;&bslash;nLinux/PPC load: &quot;
)paren
suffix:semicolon
id|timer
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|cmd_line
suffix:semicolon
r_while
c_loop
(paren
id|timer
op_increment
OL
l_int|5
op_star
l_int|1000
)paren
(brace
r_if
c_cond
(paren
id|tstc
c_func
(paren
)paren
)paren
(brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getc
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|ch
op_ne
l_char|&squot;&bslash;r&squot;
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;b&squot;
)paren
(brace
r_if
c_cond
(paren
id|cp
op_ne
id|cmd_line
)paren
(brace
id|cp
op_decrement
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;b &bslash;b&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MBX
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;?&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_ipaddrs
c_func
(paren
op_amp
id|cp
comma
l_int|1
)paren
)paren
(brace
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
id|putc
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
id|putc
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
multiline_comment|/* Exit &squot;timer&squot; loop */
)brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* 1 msec */
)brace
op_star
id|cp
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_MBX
multiline_comment|/* The MBX does not currently have any default boot strategy.&n;&t; * If the command line is not filled in, we will automatically&n;&t; * create the default network boot.&n;&t; */
r_if
c_cond
(paren
id|cmd_line
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
id|dp
op_assign
id|root_string
suffix:semicolon
r_while
c_loop
(paren
op_star
id|dp
op_ne
l_int|0
)paren
op_star
id|cp
op_increment
op_assign
op_star
id|dp
op_increment
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|dp
op_assign
id|nfsaddrs_string
suffix:semicolon
r_while
c_loop
(paren
op_star
id|dp
op_ne
l_int|0
)paren
op_star
id|cp
op_increment
op_assign
op_star
id|dp
op_increment
suffix:semicolon
id|dp
op_assign
id|cp
suffix:semicolon
id|do_ipaddrs
c_func
(paren
op_amp
id|cp
comma
l_int|0
)paren
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
multiline_comment|/* Add the server address to the root file system path.&n;&t;&t;*/
id|dp
op_assign
id|strrchr
c_func
(paren
id|dp
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
id|dp
op_increment
suffix:semicolon
id|do_nfsroot
c_func
(paren
op_amp
id|cp
comma
id|dp
)paren
suffix:semicolon
op_star
id|cp
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* mappings on early boot can only handle 16M */
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|cmd_line
(braket
l_int|0
)braket
)paren
OG
(paren
l_int|16
op_lshift
l_int|20
)paren
)paren
id|puts
c_func
(paren
l_string|&quot;cmd_line located &gt; 16M&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|hold_residual
OG
(paren
l_int|16
op_lshift
l_int|20
)paren
)paren
id|puts
c_func
(paren
l_string|&quot;hold_residual located &gt; 16M&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initrd_start
OG
(paren
l_int|16
op_lshift
l_int|20
)paren
)paren
id|puts
c_func
(paren
l_string|&quot;initrd_start located &gt; 16M&bslash;n&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;Uncompressing Linux...&quot;
)paren
suffix:semicolon
id|gunzip
c_func
(paren
l_int|0
comma
l_int|0x400000
comma
id|zimage_start
comma
op_amp
id|zimage_size
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;Now booting the kernel&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|hold_residual
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MBX
r_int
DECL|function|do_ipaddrs
id|do_ipaddrs
c_func
(paren
r_char
op_star
op_star
id|cmd_cp
comma
r_int
id|echo
)paren
(brace
r_char
op_star
id|cp
comma
op_star
id|ip
comma
id|ch
suffix:semicolon
r_int
r_char
id|ipd
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|retval
suffix:semicolon
multiline_comment|/* We need to create the string:&n;&t; *&t;&lt;my_ip&gt;:&lt;serv_ip&gt;&n;&t; */
id|cp
op_assign
op_star
id|cmd_cp
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp
op_minus
l_int|9
)paren
op_ge
id|cmd_line
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|cp
op_minus
l_int|9
comma
l_string|&quot;nfsaddrs=&quot;
comma
l_int|9
)paren
op_eq
l_int|0
)paren
(brace
id|ip
op_assign
(paren
r_char
op_star
)paren
l_int|0xfa000060
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|2
suffix:semicolon
id|j
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ipd
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|ch
op_assign
id|ipd
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
(brace
id|ch
op_add_assign
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|echo
)paren
id|putc
c_func
(paren
id|ch
)paren
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
id|ipd
op_sub_assign
l_int|100
op_star
(paren
id|ch
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
id|ch
op_assign
id|ipd
op_div
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
(brace
id|ch
op_add_assign
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|echo
)paren
id|putc
c_func
(paren
id|ch
)paren
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
id|ipd
op_sub_assign
l_int|10
op_star
(paren
id|ch
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
id|ch
op_assign
id|ipd
op_plus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|echo
)paren
id|putc
c_func
(paren
id|ch
)paren
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
id|ch
op_assign
l_char|&squot;.&squot;
suffix:semicolon
r_if
c_cond
(paren
id|echo
)paren
id|putc
c_func
(paren
id|ch
)paren
suffix:semicolon
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
)brace
multiline_comment|/* At the end of the string, remove the&n;&t;&t;&t;&t; * &squot;.&squot; and replace it with a &squot;:&squot;.&n;&t;&t;&t;&t; */
op_star
(paren
id|cp
op_minus
l_int|1
)paren
op_assign
l_char|&squot;:&squot;
suffix:semicolon
r_if
c_cond
(paren
id|echo
)paren
(brace
id|putc
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;:&squot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* At the end of the second string, remove the&n;&t;&t;&t; * &squot;.&squot; from both the command line and the&n;&t;&t;&t; * screen.&n;&t;&t;&t; */
op_decrement
id|cp
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;&bslash;b&squot;
)paren
suffix:semicolon
)brace
)brace
op_star
id|cmd_cp
op_assign
id|cp
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_void
DECL|function|do_nfsroot
id|do_nfsroot
c_func
(paren
r_char
op_star
op_star
id|cmd_cp
comma
r_char
op_star
id|dp
)paren
(brace
r_char
op_star
id|cp
comma
op_star
id|rp
comma
op_star
id|ep
suffix:semicolon
multiline_comment|/* The boot argument (i.e /sys/mbxroot/zImage) is stored&n;&t; * at offset 0x0078 in NVRAM.  We use this path name to&n;&t; * construct the root file system path.&n;&t; */
id|cp
op_assign
op_star
id|cmd_cp
suffix:semicolon
multiline_comment|/* build command string.&n;&t;*/
id|rp
op_assign
id|nfsroot_string
suffix:semicolon
r_while
c_loop
(paren
op_star
id|rp
op_ne
l_int|0
)paren
op_star
id|cp
op_increment
op_assign
op_star
id|rp
op_increment
suffix:semicolon
multiline_comment|/* Add the server address to the path.&n;&t;*/
r_while
c_loop
(paren
op_star
id|dp
op_ne
l_char|&squot; &squot;
)paren
op_star
id|cp
op_increment
op_assign
op_star
id|dp
op_increment
suffix:semicolon
op_star
id|cp
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|rp
op_assign
(paren
r_char
op_star
)paren
l_int|0xfa000078
suffix:semicolon
id|ep
op_assign
id|strrchr
c_func
(paren
id|rp
comma
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_ne
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|rp
OL
id|ep
)paren
op_star
id|cp
op_increment
op_assign
op_star
id|rp
op_increment
suffix:semicolon
)brace
r_else
(brace
id|rp
op_assign
id|defroot_string
suffix:semicolon
r_while
c_loop
(paren
op_star
id|rp
op_ne
l_int|0
)paren
op_star
id|cp
op_increment
op_assign
op_star
id|rp
op_increment
suffix:semicolon
)brace
op_star
id|cmd_cp
op_assign
id|cp
suffix:semicolon
)brace
DECL|function|strlen
r_int
id|strlen
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_const
r_char
op_star
id|sc
suffix:semicolon
r_for
c_loop
(paren
id|sc
op_assign
id|s
suffix:semicolon
op_star
id|sc
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_increment
id|sc
)paren
multiline_comment|/* nothing */
suffix:semicolon
r_return
id|sc
op_minus
id|s
suffix:semicolon
)brace
DECL|function|strncmp
r_int
id|strncmp
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
comma
r_int
id|count
)paren
(brace
r_register
r_int
r_char
id|__res
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
(paren
id|__res
op_assign
op_star
id|cs
op_minus
op_star
id|ct
op_increment
)paren
op_ne
l_int|0
op_logical_or
op_logical_neg
op_star
id|cs
op_increment
)paren
r_break
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_return
id|__res
suffix:semicolon
)brace
DECL|function|strrchr
r_char
op_star
id|strrchr
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|c
)paren
(brace
r_const
r_char
op_star
id|p
op_assign
id|s
op_plus
id|strlen
c_func
(paren
id|s
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
(paren
r_char
)paren
id|c
)paren
r_return
(paren
r_char
op_star
)paren
id|p
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|p
op_ge
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
DECL|function|puthex
r_void
id|puthex
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
(braket
id|val
op_amp
l_int|0x0F
)braket
suffix:semicolon
id|val
op_rshift_assign
l_int|4
suffix:semicolon
)brace
id|buf
(braket
l_int|8
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|puts
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * PCI/ISA I/O support&n; */
DECL|variable|ISA_io
r_volatile
r_int
r_char
op_star
id|ISA_io
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|0x80000000
suffix:semicolon
DECL|variable|ISA_mem
r_volatile
r_int
r_char
op_star
id|ISA_mem
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|0xC0000000
suffix:semicolon
r_void
DECL|function|outb
id|outb
c_func
(paren
r_int
id|port
comma
r_char
id|val
)paren
(brace
multiline_comment|/* Ensure I/O operations complete */
id|__asm__
r_volatile
(paren
l_string|&quot;eieio&quot;
)paren
suffix:semicolon
id|ISA_io
(braket
id|port
)braket
op_assign
id|val
suffix:semicolon
)brace
r_int
r_char
DECL|function|inb
id|inb
c_func
(paren
r_int
id|port
)paren
(brace
multiline_comment|/* Ensure I/O operations complete */
id|__asm__
r_volatile
(paren
l_string|&quot;eieio&quot;
)paren
suffix:semicolon
r_return
(paren
id|ISA_io
(braket
id|port
)braket
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|local_to_PCI
id|local_to_PCI
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_return
(paren
(paren
id|addr
op_amp
l_int|0x7FFFFFFF
)paren
op_or
l_int|0x80000000
)paren
suffix:semicolon
)brace
r_void
DECL|function|_bcopy
id|_bcopy
c_func
(paren
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
)paren
(brace
r_while
c_loop
(paren
id|len
op_decrement
)paren
op_star
id|dst
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
)brace
eof
