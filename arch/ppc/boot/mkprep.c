multiline_comment|/*&n; * Makes a prep bootable image which can be dd&squot;d onto&n; * a disk device to make a bootdisk.  Will take&n; * as input a elf executable, strip off the header&n; * and write out a boot image as:&n; * 1) default - strips elf header&n; *      suitable as a network boot image&n; * 2) -pbp - strips elf header and writes out prep boot partition image&n; *      cat or dd onto disk for booting&n; * 3) -asm - strips elf header and writes out as asm data&n; *      useful for generating data for a compressed image&n; *                  -- Cort&n; *&n; * Modified for x86 hosted builds by Matt Porter &lt;porter@neta.com&gt;&n; */
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;errno.h&gt;
DECL|macro|cpu_to_le32
mdefine_line|#define cpu_to_le32(x) le32_to_cpu((x))
DECL|function|le32_to_cpu
r_int
r_int
id|le32_to_cpu
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_return
(paren
(paren
(paren
id|x
op_amp
l_int|0x000000ffU
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|x
op_amp
l_int|0x0000ff00U
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|x
op_amp
l_int|0x00ff0000U
)paren
op_rshift
l_int|8
)paren
op_or
(paren
(paren
id|x
op_amp
l_int|0xff000000U
)paren
op_rshift
l_int|24
)paren
)paren
suffix:semicolon
)brace
DECL|macro|cpu_to_le16
mdefine_line|#define cpu_to_le16(x) le16_to_cpu((x))
DECL|function|le16_to_cpu
r_int
r_int
id|le16_to_cpu
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_return
(paren
(paren
(paren
id|x
op_amp
l_int|0x00ff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|x
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
DECL|macro|cpu_to_be32
mdefine_line|#define cpu_to_be32(x) (x)
DECL|macro|be32_to_cpu
mdefine_line|#define be32_to_cpu(x) (x)
DECL|macro|cpu_to_be16
mdefine_line|#define cpu_to_be16(x) (x)
DECL|macro|be16_to_cpu
mdefine_line|#define be16_to_cpu(x) (x)
multiline_comment|/* size of read buffer */
DECL|macro|SIZE
mdefine_line|#define SIZE 0x1000
DECL|typedef|dword_t
r_typedef
r_int
r_int
id|dword_t
suffix:semicolon
DECL|typedef|word_t
r_typedef
r_int
r_int
id|word_t
suffix:semicolon
DECL|typedef|byte_t
r_typedef
r_int
r_char
id|byte_t
suffix:semicolon
DECL|typedef|block_t
r_typedef
id|byte_t
id|block_t
(braket
l_int|512
)braket
suffix:semicolon
DECL|typedef|page_t
r_typedef
id|byte_t
id|page_t
(braket
l_int|4096
)braket
suffix:semicolon
multiline_comment|/*&n; * Partition table entry&n; *  - from the PReP spec&n; */
DECL|struct|partition_entry
r_typedef
r_struct
id|partition_entry
(brace
DECL|member|boot_indicator
id|byte_t
id|boot_indicator
suffix:semicolon
DECL|member|starting_head
id|byte_t
id|starting_head
suffix:semicolon
DECL|member|starting_sector
id|byte_t
id|starting_sector
suffix:semicolon
DECL|member|starting_cylinder
id|byte_t
id|starting_cylinder
suffix:semicolon
DECL|member|system_indicator
id|byte_t
id|system_indicator
suffix:semicolon
DECL|member|ending_head
id|byte_t
id|ending_head
suffix:semicolon
DECL|member|ending_sector
id|byte_t
id|ending_sector
suffix:semicolon
DECL|member|ending_cylinder
id|byte_t
id|ending_cylinder
suffix:semicolon
DECL|member|beginning_sector
id|dword_t
id|beginning_sector
suffix:semicolon
DECL|member|number_of_sectors
id|dword_t
id|number_of_sectors
suffix:semicolon
DECL|typedef|partition_entry_t
)brace
id|partition_entry_t
suffix:semicolon
DECL|macro|BootActive
mdefine_line|#define BootActive&t;0x80
DECL|macro|SystemPrep
mdefine_line|#define SystemPrep&t;0x41
r_void
id|copy_image
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|write_prep_partition
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
r_void
id|write_asm_data
c_func
(paren
r_int
id|in
comma
r_int
id|out
)paren
suffix:semicolon
DECL|variable|elfhdr_size
r_int
r_int
id|elfhdr_size
op_assign
l_int|65536
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|in_fd
comma
id|out_fd
suffix:semicolon
r_int
id|argptr
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|prep
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|asmoutput
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|argc
OL
l_int|3
)paren
op_logical_or
(paren
id|argc
OG
l_int|4
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;usage: %s [-pbp] [-asm] &lt;boot-file&gt; &lt;image&gt;&bslash;n&quot;
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* needs to handle args more elegantly -- but this is a small/simple program */
multiline_comment|/* check for -pbp */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
id|argptr
)braket
comma
l_string|&quot;-pbp&quot;
)paren
)paren
(brace
id|prep
op_assign
l_int|1
suffix:semicolon
id|argptr
op_increment
suffix:semicolon
)brace
multiline_comment|/* check for -asm */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
id|argptr
)braket
comma
l_string|&quot;-asm&quot;
)paren
)paren
(brace
id|asmoutput
op_assign
l_int|1
suffix:semicolon
id|argptr
op_increment
suffix:semicolon
)brace
multiline_comment|/* input file */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
id|argptr
)braket
comma
l_string|&quot;-&quot;
)paren
)paren
id|in_fd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* stdin */
r_else
r_if
c_cond
(paren
(paren
id|in_fd
op_assign
id|open
c_func
(paren
id|argv
(braket
id|argptr
)braket
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|argptr
op_increment
suffix:semicolon
multiline_comment|/* output file */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
id|argptr
)braket
comma
l_string|&quot;-&quot;
)paren
)paren
id|out_fd
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* stdout */
r_else
r_if
c_cond
(paren
(paren
id|out_fd
op_assign
id|creat
c_func
(paren
id|argv
(braket
id|argptr
)braket
comma
l_int|0755
)paren
)paren
OL
l_int|0
)paren
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|argptr
op_increment
suffix:semicolon
multiline_comment|/* skip elf header in input file */
multiline_comment|/*if ( !prep )*/
id|lseek
c_func
(paren
id|in_fd
comma
id|elfhdr_size
comma
id|SEEK_SET
)paren
suffix:semicolon
multiline_comment|/* write prep partition if necessary */
r_if
c_cond
(paren
id|prep
)paren
id|write_prep_partition
c_func
(paren
id|in_fd
comma
id|out_fd
)paren
suffix:semicolon
multiline_comment|/* write input image to bootimage */
r_if
c_cond
(paren
id|asmoutput
)paren
id|write_asm_data
c_func
(paren
id|in_fd
comma
id|out_fd
)paren
suffix:semicolon
r_else
id|copy_image
c_func
(paren
id|in_fd
comma
id|out_fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_prep_partition
r_void
id|write_prep_partition
c_func
(paren
r_int
id|in
comma
r_int
id|out
)paren
(brace
r_int
r_char
id|block
(braket
l_int|512
)braket
suffix:semicolon
id|partition_entry_t
op_star
id|pe
op_assign
(paren
id|partition_entry_t
op_star
)paren
op_amp
id|block
(braket
l_int|0x1BE
)braket
suffix:semicolon
id|dword_t
op_star
id|entry
op_assign
(paren
id|dword_t
op_star
)paren
op_amp
id|block
(braket
l_int|0
)braket
suffix:semicolon
id|dword_t
op_star
id|length
op_assign
(paren
id|dword_t
op_star
)paren
op_amp
id|block
(braket
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
r_struct
id|stat
id|info
suffix:semicolon
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|in
comma
op_amp
id|info
)paren
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;info failed&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|bzero
c_func
(paren
id|block
comma
r_sizeof
id|block
)paren
suffix:semicolon
multiline_comment|/* set entry point and boot image size skipping over elf header */
macro_line|#ifdef __i386__
op_star
id|entry
op_assign
l_int|0x400
multiline_comment|/*+65536*/
suffix:semicolon
op_star
id|length
op_assign
id|info.st_size
op_minus
id|elfhdr_size
op_plus
l_int|0x400
suffix:semicolon
macro_line|#else
op_star
id|entry
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0x400
multiline_comment|/*+65536*/
)paren
suffix:semicolon
op_star
id|length
op_assign
id|cpu_to_le32
c_func
(paren
id|info.st_size
op_minus
id|elfhdr_size
op_plus
l_int|0x400
)paren
suffix:semicolon
macro_line|#endif /* __i386__ */
multiline_comment|/* sets magic number for msdos partition (used by linux) */
id|block
(braket
l_int|510
)braket
op_assign
l_int|0x55
suffix:semicolon
id|block
(braket
l_int|511
)braket
op_assign
l_int|0xAA
suffix:semicolon
multiline_comment|/*&n;   * Build a &quot;PReP&quot; partition table entry in the boot record&n;   *  - &quot;PReP&quot; may only look at the system_indicator&n;   */
id|pe-&gt;boot_indicator
op_assign
id|BootActive
suffix:semicolon
id|pe-&gt;system_indicator
op_assign
id|SystemPrep
suffix:semicolon
multiline_comment|/*&n;   * The first block of the diskette is used by this &quot;boot record&quot; which&n;   * actually contains the partition table. (The first block of the&n;   * partition contains the boot image, but I digress...)  We&squot;ll set up&n;   * one partition on the diskette and it shall contain the rest of the&n;   * diskette.&n;   */
id|pe-&gt;starting_head
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero-based&t;&t;&t;     */
id|pe-&gt;starting_sector
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* one-based&t;&t;&t;     */
id|pe-&gt;starting_cylinder
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* zero-based&t;&t;&t;     */
id|pe-&gt;ending_head
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* assumes two heads&t;&t;     */
id|pe-&gt;ending_sector
op_assign
l_int|18
suffix:semicolon
multiline_comment|/* assumes 18 sectors/track&t;     */
id|pe-&gt;ending_cylinder
op_assign
l_int|79
suffix:semicolon
multiline_comment|/* assumes 80 cylinders/diskette     */
multiline_comment|/*&n;   * The &quot;PReP&quot; software ignores the above fields and just looks at&n;   * the next two.&n;   *   - size of the diskette is (assumed to be)&n;   *     (2 tracks/cylinder)(18 sectors/tracks)(80 cylinders/diskette)&n;   *   - unlike the above sector numbers, the beginning sector is zero-based!&n;   */
macro_line|#if 0
id|pe-&gt;beginning_sector
op_assign
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* This has to be 0 on the PowerStack? */
macro_line|#ifdef __i386__
id|pe-&gt;beginning_sector
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|pe-&gt;beginning_sector
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* __i386__ */
macro_line|#endif    
macro_line|#ifdef __i386__
id|pe-&gt;number_of_sectors
op_assign
l_int|2
op_star
l_int|18
op_star
l_int|80
op_minus
l_int|1
suffix:semicolon
macro_line|#else
id|pe-&gt;number_of_sectors
op_assign
id|cpu_to_le32
c_func
(paren
l_int|2
op_star
l_int|18
op_star
l_int|80
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* __i386__ */
id|write
c_func
(paren
id|out
comma
id|block
comma
r_sizeof
(paren
id|block
)paren
)paren
suffix:semicolon
id|write
c_func
(paren
id|out
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|write
c_func
(paren
id|out
comma
id|length
comma
r_sizeof
(paren
op_star
id|length
)paren
)paren
suffix:semicolon
multiline_comment|/* set file position to 2nd sector where image will be written */
id|lseek
c_func
(paren
id|out
comma
l_int|0x400
comma
id|SEEK_SET
)paren
suffix:semicolon
)brace
r_void
DECL|function|copy_image
id|copy_image
c_func
(paren
r_int
id|in
comma
r_int
id|out
)paren
(brace
r_char
id|buf
(braket
id|SIZE
)braket
suffix:semicolon
r_int
id|n
suffix:semicolon
r_while
c_loop
(paren
(paren
id|n
op_assign
id|read
c_func
(paren
id|in
comma
id|buf
comma
id|SIZE
)paren
)paren
OG
l_int|0
)paren
id|write
c_func
(paren
id|out
comma
id|buf
comma
id|n
)paren
suffix:semicolon
)brace
r_void
DECL|function|write_asm_data
id|write_asm_data
c_func
(paren
r_int
id|in
comma
r_int
id|out
)paren
(brace
r_int
id|i
comma
id|cnt
comma
id|pos
comma
id|len
suffix:semicolon
r_int
r_int
id|cksum
comma
id|val
suffix:semicolon
r_int
r_char
op_star
id|lp
suffix:semicolon
r_int
r_char
id|buf
(braket
id|SIZE
)braket
suffix:semicolon
r_int
r_char
id|str
(braket
l_int|256
)braket
suffix:semicolon
id|write
c_func
(paren
id|out
comma
l_string|&quot;&bslash;t.data&bslash;n&bslash;t.globl input_data&bslash;ninput_data:&bslash;n&quot;
comma
id|strlen
c_func
(paren
l_string|&quot;&bslash;t.data&bslash;n&bslash;t.globl input_data&bslash;ninput_data:&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
id|cksum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|len
op_assign
id|read
c_func
(paren
id|in
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
)paren
OG
l_int|0
)paren
(brace
id|cnt
op_assign
l_int|0
suffix:semicolon
id|lp
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* Round up to longwords */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|cnt
op_eq
l_int|0
)paren
(brace
id|write
c_func
(paren
id|out
comma
l_string|&quot;&bslash;t.long&bslash;t&quot;
comma
id|strlen
c_func
(paren
l_string|&quot;&bslash;t.long&bslash;t&quot;
)paren
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;0x%02X%02X%02X%02X&quot;
comma
id|lp
(braket
l_int|0
)braket
comma
id|lp
(braket
l_int|1
)braket
comma
id|lp
(braket
l_int|2
)braket
comma
id|lp
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|write
c_func
(paren
id|out
comma
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
)paren
suffix:semicolon
id|val
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|lp
suffix:semicolon
id|cksum
op_xor_assign
id|val
suffix:semicolon
id|lp
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|cnt
op_eq
l_int|4
)paren
(brace
id|cnt
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot; # %x &bslash;n&quot;
comma
id|pos
op_plus
id|i
op_minus
l_int|12
)paren
suffix:semicolon
id|write
c_func
(paren
id|out
comma
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|write
c_func
(paren
id|out
comma
l_string|&quot;,&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cnt
)paren
(brace
id|write
c_func
(paren
id|out
comma
l_string|&quot;0&bslash;n&quot;
comma
l_int|2
)paren
suffix:semicolon
)brace
id|pos
op_add_assign
id|len
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;&bslash;t.globl input_len&bslash;ninput_len:&bslash;t.long&bslash;t0x%x&bslash;n&quot;
comma
id|pos
)paren
suffix:semicolon
id|write
c_func
(paren
id|out
comma
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;cksum = %x&bslash;n&quot;
comma
id|cksum
)paren
suffix:semicolon
)brace
eof
