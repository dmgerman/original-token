multiline_comment|/*&n; * This file is derived from various .h and .c files from the zlib-0.95&n; * distribution by Jean-loup Gailly and Mark Adler, with some additions&n; * by Paul Mackerras to aid in implementing Deflate compression and&n; * decompression for PPP packets.  See zlib.h for conditions of&n; * distribution and use.&n; *&n; * Changes that have been made include:&n; * - changed functions not used outside this file to &quot;local&quot;&n; * - added minCompression parameter to deflateInit2&n; * - added Z_PACKET_FLUSH (see zlib.h for details)&n; * - added inflateIncomp&n; *&n; * $Id: zlib.c,v 1.3 1999/05/27 22:22:54 cort Exp $&n; */
multiline_comment|/*+++++*/
multiline_comment|/* zutil.h -- internal interface and configuration of the compression library&n; * Copyright (C) 1995 Jean-loup Gailly.&n; * For conditions of distribution and use, see copyright notice in zlib.h&n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
multiline_comment|/* From: zutil.h,v 1.9 1995/05/03 17:27:12 jloup Exp */
DECL|macro|_Z_UTIL_H
mdefine_line|#define _Z_UTIL_H
macro_line|#include &quot;zlib.h&quot;
macro_line|#ifndef local
DECL|macro|local
macro_line|#  define local static
macro_line|#endif
multiline_comment|/* compile with -Dlocal if your debugger can&squot;t find static symbols */
DECL|macro|FAR
mdefine_line|#define FAR
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
DECL|typedef|uchf
r_typedef
id|uch
id|FAR
id|uchf
suffix:semicolon
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
DECL|typedef|ushf
r_typedef
id|ush
id|FAR
id|ushf
suffix:semicolon
DECL|typedef|ulg
r_typedef
r_int
r_int
id|ulg
suffix:semicolon
r_extern
r_char
op_star
id|z_errmsg
(braket
)braket
suffix:semicolon
multiline_comment|/* indexed by 1-zlib_error */
DECL|macro|ERR_RETURN
mdefine_line|#define ERR_RETURN(strm,err) return (strm-&gt;msg=z_errmsg[1-err], err)
multiline_comment|/* To be used only when the state is known to be valid */
macro_line|#ifndef NULL
DECL|macro|NULL
mdefine_line|#define NULL&t;((void *) 0)
macro_line|#endif
multiline_comment|/* common constants */
DECL|macro|DEFLATED
mdefine_line|#define DEFLATED   8
macro_line|#ifndef DEF_WBITS
DECL|macro|DEF_WBITS
macro_line|#  define DEF_WBITS MAX_WBITS
macro_line|#endif
multiline_comment|/* default windowBits for decompression. MAX_WBITS is for compression only */
macro_line|#if MAX_MEM_LEVEL &gt;= 8
DECL|macro|DEF_MEM_LEVEL
macro_line|#  define DEF_MEM_LEVEL 8
macro_line|#else
DECL|macro|DEF_MEM_LEVEL
macro_line|#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
macro_line|#endif
multiline_comment|/* default memLevel */
DECL|macro|STORED_BLOCK
mdefine_line|#define STORED_BLOCK 0
DECL|macro|STATIC_TREES
mdefine_line|#define STATIC_TREES 1
DECL|macro|DYN_TREES
mdefine_line|#define DYN_TREES    2
multiline_comment|/* The three kinds of block type */
DECL|macro|MIN_MATCH
mdefine_line|#define MIN_MATCH  3
DECL|macro|MAX_MATCH
mdefine_line|#define MAX_MATCH  258
multiline_comment|/* The minimum and maximum match lengths */
multiline_comment|/* functions */
macro_line|#include &lt;linux/string.h&gt;
DECL|macro|zmemcpy
mdefine_line|#define zmemcpy memcpy
DECL|macro|zmemzero
mdefine_line|#define zmemzero(dest, len)&t;memset(dest, 0, len)
multiline_comment|/* Diagnostic functions */
macro_line|#ifdef DEBUG_ZLIB
macro_line|#  include &lt;stdio.h&gt;
macro_line|#  ifndef verbose
DECL|macro|verbose
macro_line|#    define verbose 0
macro_line|#  endif
DECL|macro|Assert
macro_line|#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
DECL|macro|Trace
macro_line|#  define Trace(x) fprintf x
DECL|macro|Tracev
macro_line|#  define Tracev(x) {if (verbose) fprintf x ;}
DECL|macro|Tracevv
macro_line|#  define Tracevv(x) {if (verbose&gt;1) fprintf x ;}
DECL|macro|Tracec
macro_line|#  define Tracec(c,x) {if (verbose &amp;&amp; (c)) fprintf x ;}
DECL|macro|Tracecv
macro_line|#  define Tracecv(c,x) {if (verbose&gt;1 &amp;&amp; (c)) fprintf x ;}
macro_line|#else
DECL|macro|Assert
macro_line|#  define Assert(cond,msg)
DECL|macro|Trace
macro_line|#  define Trace(x)
DECL|macro|Tracev
macro_line|#  define Tracev(x)
DECL|macro|Tracevv
macro_line|#  define Tracevv(x)
DECL|macro|Tracec
macro_line|#  define Tracec(c,x)
DECL|macro|Tracecv
macro_line|#  define Tracecv(c,x)
macro_line|#endif
DECL|typedef|check_func
r_typedef
id|uLong
(paren
op_star
id|check_func
)paren
id|OF
c_func
(paren
(paren
id|uLong
id|check
comma
id|Bytef
op_star
id|buf
comma
id|uInt
id|len
)paren
)paren
suffix:semicolon
multiline_comment|/* voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size)); */
multiline_comment|/* void   zcfree  OF((voidpf opaque, voidpf ptr)); */
DECL|macro|ZALLOC
mdefine_line|#define ZALLOC(strm, items, size) &bslash;&n;           (*((strm)-&gt;zalloc))((strm)-&gt;opaque, (items), (size))
DECL|macro|ZFREE
mdefine_line|#define ZFREE(strm, addr, size)&t;&bslash;&n;&t;   (*((strm)-&gt;zfree))((strm)-&gt;opaque, (voidpf)(addr), (size))
DECL|macro|TRY_FREE
mdefine_line|#define TRY_FREE(s, p, n) {if (p) ZFREE(s, p, n);}
multiline_comment|/* deflate.h -- internal compression state&n; * Copyright (C) 1995 Jean-loup Gailly&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
multiline_comment|/*+++++*/
multiline_comment|/* infblock.h -- header to use infblock.c&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
r_struct
id|inflate_blocks_state
suffix:semicolon
DECL|typedef|inflate_blocks_statef
r_typedef
r_struct
id|inflate_blocks_state
id|FAR
id|inflate_blocks_statef
suffix:semicolon
id|local
id|inflate_blocks_statef
op_star
id|inflate_blocks_new
id|OF
c_func
(paren
(paren
id|z_stream
op_star
id|z
comma
id|check_func
id|c
comma
multiline_comment|/* check function */
id|uInt
id|w
)paren
)paren
suffix:semicolon
multiline_comment|/* window size */
id|local
r_int
id|inflate_blocks
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_stream
op_star
comma
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* initial return code */
id|local
r_void
id|inflate_blocks_reset
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_stream
op_star
comma
id|uLongf
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* check value on output */
id|local
r_int
id|inflate_blocks_free
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_stream
op_star
comma
id|uLongf
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* check value on output */
id|local
r_int
id|inflate_addhistory
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_stream
op_star
)paren
)paren
suffix:semicolon
id|local
r_int
id|inflate_packet_flush
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*+++++*/
multiline_comment|/* inftrees.h -- header to use inftrees.c&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
multiline_comment|/* Huffman code lookup table entry--this entry is four bytes for machines&n;   that have 16-bit pointers (e.g. PC&squot;s in the small or medium model). */
DECL|typedef|inflate_huft
r_typedef
r_struct
id|inflate_huft_s
id|FAR
id|inflate_huft
suffix:semicolon
DECL|struct|inflate_huft_s
r_struct
id|inflate_huft_s
(brace
r_union
(brace
r_struct
(brace
DECL|member|Exop
id|Byte
id|Exop
suffix:semicolon
multiline_comment|/* number of extra bits or operation */
DECL|member|Bits
id|Byte
id|Bits
suffix:semicolon
multiline_comment|/* number of bits in this code or subcode */
DECL|member|what
)brace
id|what
suffix:semicolon
DECL|member|Nalloc
id|uInt
id|Nalloc
suffix:semicolon
multiline_comment|/* number of these allocated here */
DECL|member|pad
id|Bytef
op_star
id|pad
suffix:semicolon
multiline_comment|/* pad structure to a power of 2 (4 bytes for */
DECL|member|word
)brace
id|word
suffix:semicolon
multiline_comment|/*  16-bit, 8 bytes for 32-bit machines) */
r_union
(brace
DECL|member|Base
id|uInt
id|Base
suffix:semicolon
multiline_comment|/* literal, length base, or distance base */
DECL|member|Next
id|inflate_huft
op_star
id|Next
suffix:semicolon
multiline_comment|/* pointer to next level of table */
DECL|member|more
)brace
id|more
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
DECL|variable|inflate_hufts
id|local
id|uInt
id|inflate_hufts
suffix:semicolon
macro_line|#endif
id|local
r_int
id|inflate_trees_bits
id|OF
c_func
(paren
(paren
id|uIntf
op_star
comma
multiline_comment|/* 19 code lengths */
id|uIntf
op_star
comma
multiline_comment|/* bits tree desired/actual depth */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* bits tree result */
id|z_stream
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* for zalloc, zfree functions */
id|local
r_int
id|inflate_trees_dynamic
id|OF
c_func
(paren
(paren
id|uInt
comma
multiline_comment|/* number of literal/length codes */
id|uInt
comma
multiline_comment|/* number of distance codes */
id|uIntf
op_star
comma
multiline_comment|/* that many (total) code lengths */
id|uIntf
op_star
comma
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
comma
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* distance tree result */
id|z_stream
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* for zalloc, zfree functions */
id|local
r_int
id|inflate_trees_fixed
id|OF
c_func
(paren
(paren
id|uIntf
op_star
comma
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
comma
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* distance tree result */
id|local
r_int
id|inflate_trees_free
id|OF
c_func
(paren
(paren
id|inflate_huft
op_star
comma
multiline_comment|/* tables to free */
id|z_stream
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* for zfree function */
multiline_comment|/*+++++*/
multiline_comment|/* infcodes.h -- header to use infcodes.c&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
r_struct
id|inflate_codes_state
suffix:semicolon
DECL|typedef|inflate_codes_statef
r_typedef
r_struct
id|inflate_codes_state
id|FAR
id|inflate_codes_statef
suffix:semicolon
id|local
id|inflate_codes_statef
op_star
id|inflate_codes_new
id|OF
c_func
(paren
(paren
id|uInt
comma
id|uInt
comma
id|inflate_huft
op_star
comma
id|inflate_huft
op_star
comma
id|z_stream
op_star
)paren
)paren
suffix:semicolon
id|local
r_int
id|inflate_codes
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_stream
op_star
comma
r_int
)paren
)paren
suffix:semicolon
id|local
r_void
id|inflate_codes_free
id|OF
c_func
(paren
(paren
id|inflate_codes_statef
op_star
comma
id|z_stream
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*+++++*/
multiline_comment|/* inflate.c -- zlib interface to inflate modules&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* inflate private state */
DECL|struct|internal_state
r_struct
id|internal_state
(brace
multiline_comment|/* mode */
r_enum
(brace
DECL|enumerator|METHOD
id|METHOD
comma
multiline_comment|/* waiting for method byte */
DECL|enumerator|FLAG
id|FLAG
comma
multiline_comment|/* waiting for flag byte */
DECL|enumerator|BLOCKS
id|BLOCKS
comma
multiline_comment|/* decompressing blocks */
DECL|enumerator|CHECK4
id|CHECK4
comma
multiline_comment|/* four check bytes to go */
DECL|enumerator|CHECK3
id|CHECK3
comma
multiline_comment|/* three check bytes to go */
DECL|enumerator|CHECK2
id|CHECK2
comma
multiline_comment|/* two check bytes to go */
DECL|enumerator|CHECK1
id|CHECK1
comma
multiline_comment|/* one check byte to go */
DECL|enumerator|DONE
id|DONE
comma
multiline_comment|/* finished check, done */
DECL|enumerator|BAD
id|BAD
)brace
multiline_comment|/* got an error--stay here */
DECL|member|mode
id|mode
suffix:semicolon
multiline_comment|/* current inflate mode */
multiline_comment|/* mode dependent information */
r_union
(brace
DECL|member|method
id|uInt
id|method
suffix:semicolon
multiline_comment|/* if FLAGS, method byte */
r_struct
(brace
DECL|member|was
id|uLong
id|was
suffix:semicolon
multiline_comment|/* computed check value */
DECL|member|need
id|uLong
id|need
suffix:semicolon
multiline_comment|/* stream check value */
DECL|member|check
)brace
id|check
suffix:semicolon
multiline_comment|/* if CHECK, check values to compare */
DECL|member|marker
id|uInt
id|marker
suffix:semicolon
multiline_comment|/* if BAD, inflateSync&squot;s marker bytes count */
DECL|member|sub
)brace
id|sub
suffix:semicolon
multiline_comment|/* submode */
multiline_comment|/* mode independent information */
DECL|member|nowrap
r_int
id|nowrap
suffix:semicolon
multiline_comment|/* flag for no wrapper */
DECL|member|wbits
id|uInt
id|wbits
suffix:semicolon
multiline_comment|/* log2(window size)  (8..15, defaults to 15) */
id|inflate_blocks_statef
DECL|member|blocks
op_star
id|blocks
suffix:semicolon
multiline_comment|/* current inflate_blocks state */
)brace
suffix:semicolon
DECL|function|inflateReset
r_int
id|inflateReset
c_func
(paren
id|z
)paren
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|uLong
id|c
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|z-&gt;total_in
op_assign
id|z-&gt;total_out
op_assign
l_int|0
suffix:semicolon
id|z-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|z-&gt;state-&gt;nowrap
ques
c_cond
id|BLOCKS
suffix:colon
id|METHOD
suffix:semicolon
id|inflate_blocks_reset
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
op_amp
id|c
)paren
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflateEnd
r_int
id|inflateEnd
c_func
(paren
id|z
)paren
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|uLong
id|c
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;zfree
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;blocks
op_ne
id|Z_NULL
)paren
id|inflate_blocks_free
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
op_amp
id|c
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|z-&gt;state
comma
r_sizeof
(paren
r_struct
id|internal_state
)paren
)paren
suffix:semicolon
id|z-&gt;state
op_assign
id|Z_NULL
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: end&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflateInit2
r_int
id|inflateInit2
c_func
(paren
id|z
comma
id|w
)paren
id|z_stream
op_star
id|z
suffix:semicolon
r_int
id|w
suffix:semicolon
(brace
multiline_comment|/* initialize state */
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
multiline_comment|/*  if (z-&gt;zalloc == Z_NULL) z-&gt;zalloc = zcalloc; */
multiline_comment|/*  if (z-&gt;zfree == Z_NULL) z-&gt;zfree = zcfree; */
r_if
c_cond
(paren
(paren
id|z-&gt;state
op_assign
(paren
r_struct
id|internal_state
id|FAR
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
l_int|1
comma
r_sizeof
(paren
r_struct
id|internal_state
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
r_return
id|Z_MEM_ERROR
suffix:semicolon
id|z-&gt;state-&gt;blocks
op_assign
id|Z_NULL
suffix:semicolon
multiline_comment|/* handle undocumented nowrap option (no zlib header or check) */
id|z-&gt;state-&gt;nowrap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|w
OL
l_int|0
)paren
(brace
id|w
op_assign
op_minus
id|w
suffix:semicolon
id|z-&gt;state-&gt;nowrap
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set window size */
r_if
c_cond
(paren
id|w
template_param
l_int|15
)paren
(brace
id|inflateEnd
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|z-&gt;state-&gt;wbits
op_assign
(paren
id|uInt
)paren
id|w
suffix:semicolon
multiline_comment|/* create inflate_blocks state */
r_if
c_cond
(paren
(paren
id|z-&gt;state-&gt;blocks
op_assign
id|inflate_blocks_new
c_func
(paren
id|z
comma
id|z-&gt;state-&gt;nowrap
ques
c_cond
id|Z_NULL
suffix:colon
id|adler32
comma
l_int|1
op_lshift
id|w
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|inflateEnd
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_MEM_ERROR
suffix:semicolon
)brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: allocated&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* reset state */
id|inflateReset
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflateInit
r_int
id|inflateInit
c_func
(paren
id|z
)paren
id|z_stream
op_star
id|z
suffix:semicolon
(brace
r_return
id|inflateInit2
c_func
(paren
id|z
comma
id|DEF_WBITS
)paren
suffix:semicolon
)brace
DECL|macro|NEEDBYTE
mdefine_line|#define NEEDBYTE {if(z-&gt;avail_in==0)goto empty;r=Z_OK;}
DECL|macro|NEXTBYTE
mdefine_line|#define NEXTBYTE (z-&gt;avail_in--,z-&gt;total_in++,*z-&gt;next_in++)
DECL|function|inflate
r_int
id|inflate
c_func
(paren
id|z
comma
id|f
)paren
id|z_stream
op_star
id|z
suffix:semicolon
r_int
id|f
suffix:semicolon
(brace
r_int
id|r
suffix:semicolon
id|uInt
id|b
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;next_in
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|r
op_assign
id|Z_BUF_ERROR
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
r_switch
c_cond
(paren
id|z-&gt;state-&gt;mode
)paren
(brace
r_case
id|METHOD
suffix:colon
id|NEEDBYTE
r_if
c_cond
(paren
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_assign
id|NEXTBYTE
)paren
op_amp
l_int|0xf
)paren
op_ne
id|DEFLATED
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;unknown compression method&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_rshift
l_int|4
)paren
op_plus
l_int|8
OG
id|z-&gt;state-&gt;wbits
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;invalid window size&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|FLAG
suffix:semicolon
r_case
id|FLAG
suffix:colon
id|NEEDBYTE
r_if
c_cond
(paren
(paren
id|b
op_assign
id|NEXTBYTE
)paren
op_amp
l_int|0x20
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;invalid reserved bit&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_lshift
l_int|8
)paren
op_plus
id|b
)paren
op_mod
l_int|31
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;incorrect header check&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: zlib header ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_case
id|BLOCKS
suffix:colon
id|r
op_assign
id|inflate_blocks
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
op_eq
id|Z_PACKET_FLUSH
op_logical_and
id|z-&gt;avail_in
op_eq
l_int|0
op_logical_and
id|z-&gt;avail_out
op_ne
l_int|0
)paren
id|r
op_assign
id|inflate_packet_flush
c_func
(paren
id|z-&gt;state-&gt;blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
op_ne
id|Z_STREAM_END
)paren
r_return
id|r
suffix:semicolon
id|r
op_assign
id|Z_OK
suffix:semicolon
id|inflate_blocks_reset
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
op_amp
id|z-&gt;state-&gt;sub.check.was
)paren
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;nowrap
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|DONE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|CHECK4
suffix:semicolon
r_case
id|CHECK4
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|24
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK3
suffix:semicolon
r_case
id|CHECK3
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|16
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK2
suffix:semicolon
r_case
id|CHECK2
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|8
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK1
suffix:semicolon
r_case
id|CHECK1
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;sub.check.was
op_ne
id|z-&gt;state-&gt;sub.check.need
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;incorrect data check&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate: zlib check ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DONE
suffix:semicolon
r_case
id|DONE
suffix:colon
r_return
id|Z_STREAM_END
suffix:semicolon
r_case
id|BAD
suffix:colon
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_default
suffix:colon
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|empty
suffix:colon
r_if
c_cond
(paren
id|f
op_ne
id|Z_PACKET_FLUSH
)paren
r_return
id|r
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can try inflateSync */
r_return
id|Z_DATA_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n; * This subroutine adds the data at next_in/avail_in to the output history&n; * without performing any output.  The output buffer must be &quot;caught up&quot;;&n; * i.e. no pending output (hence s-&gt;read equals s-&gt;write), and the state must&n; * be BLOCKS (i.e. we should be willing to see the start of a series of&n; * BLOCKS).  On exit, the output will also be caught up, and the checksum&n; * will have been updated if need be.&n; */
DECL|function|inflateIncomp
r_int
id|inflateIncomp
c_func
(paren
id|z
)paren
id|z_stream
op_star
id|z
suffix:semicolon
(brace
r_if
c_cond
(paren
id|z-&gt;state-&gt;mode
op_ne
id|BLOCKS
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_return
id|inflate_addhistory
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
)paren
suffix:semicolon
)brace
DECL|function|inflateSync
r_int
id|inflateSync
c_func
(paren
id|z
)paren
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of bytes to look at */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* pointer to bytes */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* number of marker bytes found in a row */
id|uLong
id|r
comma
id|w
suffix:semicolon
multiline_comment|/* temporaries to save total_in and total_out */
multiline_comment|/* set up */
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;mode
op_ne
id|BAD
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n
op_assign
id|z-&gt;avail_in
)paren
op_eq
l_int|0
)paren
r_return
id|Z_BUF_ERROR
suffix:semicolon
id|p
op_assign
id|z-&gt;next_in
suffix:semicolon
id|m
op_assign
id|z-&gt;state-&gt;sub.marker
suffix:semicolon
multiline_comment|/* search */
r_while
c_loop
(paren
id|n
op_logical_and
id|m
OL
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
(paren
id|Byte
)paren
(paren
id|m
OL
l_int|2
ques
c_cond
l_int|0
suffix:colon
l_int|0xff
)paren
)paren
id|m
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|p
)paren
id|m
op_assign
l_int|0
suffix:semicolon
r_else
id|m
op_assign
l_int|4
op_minus
id|m
suffix:semicolon
id|p
op_increment
comma
id|n
op_decrement
suffix:semicolon
)brace
multiline_comment|/* restore */
id|z-&gt;total_in
op_add_assign
id|p
op_minus
id|z-&gt;next_in
suffix:semicolon
id|z-&gt;next_in
op_assign
id|p
suffix:semicolon
id|z-&gt;avail_in
op_assign
id|n
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
id|m
suffix:semicolon
multiline_comment|/* return no joy or set up to restart on a new block */
r_if
c_cond
(paren
id|m
op_ne
l_int|4
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|r
op_assign
id|z-&gt;total_in
suffix:semicolon
id|w
op_assign
id|z-&gt;total_out
suffix:semicolon
id|inflateReset
c_func
(paren
id|z
)paren
suffix:semicolon
id|z-&gt;total_in
op_assign
id|r
suffix:semicolon
id|z-&gt;total_out
op_assign
id|w
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|macro|NEEDBYTE
macro_line|#undef NEEDBYTE
DECL|macro|NEXTBYTE
macro_line|#undef NEXTBYTE
multiline_comment|/*+++++*/
multiline_comment|/* infutil.h -- types and macros common to blocks and codes&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
multiline_comment|/* inflate blocks semi-private state */
DECL|struct|inflate_blocks_state
r_struct
id|inflate_blocks_state
(brace
multiline_comment|/* mode */
r_enum
(brace
DECL|enumerator|TYPE
id|TYPE
comma
multiline_comment|/* get type bits (3, including end bit) */
DECL|enumerator|LENS
id|LENS
comma
multiline_comment|/* get lengths for stored */
DECL|enumerator|STORED
id|STORED
comma
multiline_comment|/* processing stored block */
DECL|enumerator|TABLE
id|TABLE
comma
multiline_comment|/* get table lengths */
DECL|enumerator|BTREE
id|BTREE
comma
multiline_comment|/* get bit lengths tree for a dynamic block */
DECL|enumerator|DTREE
id|DTREE
comma
multiline_comment|/* get length, distance trees for a dynamic block */
DECL|enumerator|CODES
id|CODES
comma
multiline_comment|/* processing fixed or dynamic block */
DECL|enumerator|DRY
id|DRY
comma
multiline_comment|/* output remaining window bytes */
DECL|enumerator|DONEB
id|DONEB
comma
multiline_comment|/* finished last block, done */
DECL|enumerator|BADB
id|BADB
)brace
multiline_comment|/* got a data error--stuck here */
DECL|member|mode
id|mode
suffix:semicolon
multiline_comment|/* current inflate_block mode */
multiline_comment|/* mode dependent information */
r_union
(brace
DECL|member|left
id|uInt
id|left
suffix:semicolon
multiline_comment|/* if STORED, bytes left to copy */
r_struct
(brace
DECL|member|table
id|uInt
id|table
suffix:semicolon
multiline_comment|/* table lengths (14 bits) */
DECL|member|index
id|uInt
id|index
suffix:semicolon
multiline_comment|/* index into blens (or border) */
DECL|member|blens
id|uIntf
op_star
id|blens
suffix:semicolon
multiline_comment|/* bit lengths of codes */
DECL|member|bb
id|uInt
id|bb
suffix:semicolon
multiline_comment|/* bit length tree depth */
DECL|member|tb
id|inflate_huft
op_star
id|tb
suffix:semicolon
multiline_comment|/* bit length decoding tree */
DECL|member|nblens
r_int
id|nblens
suffix:semicolon
multiline_comment|/* # elements allocated at blens */
DECL|member|trees
)brace
id|trees
suffix:semicolon
multiline_comment|/* if DTREE, decoding info for trees */
r_struct
(brace
DECL|member|tl
DECL|member|td
id|inflate_huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
multiline_comment|/* trees to free */
id|inflate_codes_statef
DECL|member|codes
op_star
id|codes
suffix:semicolon
DECL|member|decode
)brace
id|decode
suffix:semicolon
multiline_comment|/* if CODES, current state */
DECL|member|sub
)brace
id|sub
suffix:semicolon
multiline_comment|/* submode */
DECL|member|last
id|uInt
id|last
suffix:semicolon
multiline_comment|/* true if this block is the last block */
multiline_comment|/* mode independent information */
DECL|member|bitk
id|uInt
id|bitk
suffix:semicolon
multiline_comment|/* bits in bit buffer */
DECL|member|bitb
id|uLong
id|bitb
suffix:semicolon
multiline_comment|/* bit buffer */
DECL|member|window
id|Bytef
op_star
id|window
suffix:semicolon
multiline_comment|/* sliding window */
DECL|member|end
id|Bytef
op_star
id|end
suffix:semicolon
multiline_comment|/* one byte after sliding window */
DECL|member|read
id|Bytef
op_star
id|read
suffix:semicolon
multiline_comment|/* window read pointer */
DECL|member|write
id|Bytef
op_star
id|write
suffix:semicolon
multiline_comment|/* window write pointer */
DECL|member|checkfn
id|check_func
id|checkfn
suffix:semicolon
multiline_comment|/* check function */
DECL|member|check
id|uLong
id|check
suffix:semicolon
multiline_comment|/* check on output */
)brace
suffix:semicolon
multiline_comment|/* defines for inflate input/output */
multiline_comment|/*   update pointers and return */
DECL|macro|UPDBITS
mdefine_line|#define UPDBITS {s-&gt;bitb=b;s-&gt;bitk=k;}
DECL|macro|UPDIN
mdefine_line|#define UPDIN {z-&gt;avail_in=n;z-&gt;total_in+=p-z-&gt;next_in;z-&gt;next_in=p;}
DECL|macro|UPDOUT
mdefine_line|#define UPDOUT {s-&gt;write=q;}
DECL|macro|UPDATE
mdefine_line|#define UPDATE {UPDBITS UPDIN UPDOUT}
DECL|macro|LEAVE
mdefine_line|#define LEAVE {UPDATE return inflate_flush(s,z,r);}
multiline_comment|/*   get bytes and bits */
DECL|macro|LOADIN
mdefine_line|#define LOADIN {p=z-&gt;next_in;n=z-&gt;avail_in;b=s-&gt;bitb;k=s-&gt;bitk;}
DECL|macro|NEEDBYTE
mdefine_line|#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
DECL|macro|NEXTBYTE
mdefine_line|#define NEXTBYTE (n--,*p++)
DECL|macro|NEEDBITS
mdefine_line|#define NEEDBITS(j) {while(k&lt;(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)&lt;&lt;k;k+=8;}}
DECL|macro|DUMPBITS
mdefine_line|#define DUMPBITS(j) {b&gt;&gt;=(j);k-=(j);}
multiline_comment|/*   output bytes */
DECL|macro|WAVAIL
mdefine_line|#define WAVAIL (q&lt;s-&gt;read?s-&gt;read-q-1:s-&gt;end-q)
DECL|macro|LOADOUT
mdefine_line|#define LOADOUT {q=s-&gt;write;m=WAVAIL;}
DECL|macro|WRAP
mdefine_line|#define WRAP {if(q==s-&gt;end&amp;&amp;s-&gt;read!=s-&gt;window){q=s-&gt;window;m=WAVAIL;}}
DECL|macro|FLUSH
mdefine_line|#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
DECL|macro|NEEDOUT
mdefine_line|#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
DECL|macro|OUTBYTE
mdefine_line|#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
multiline_comment|/*   load local pointers */
DECL|macro|LOAD
mdefine_line|#define LOAD {LOADIN LOADOUT}
multiline_comment|/*&n; * The IBM 150 firmware munges the data right after _etext[].  This&n; * protects it. -- Cort&n; */
DECL|variable|protect_mask
id|local
id|uInt
id|protect_mask
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* And&squot;ing with mask[n] masks the lower n bits */
DECL|variable|inflate_mask
id|local
id|uInt
id|inflate_mask
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x0001
comma
l_int|0x0003
comma
l_int|0x0007
comma
l_int|0x000f
comma
l_int|0x001f
comma
l_int|0x003f
comma
l_int|0x007f
comma
l_int|0x00ff
comma
l_int|0x01ff
comma
l_int|0x03ff
comma
l_int|0x07ff
comma
l_int|0x0fff
comma
l_int|0x1fff
comma
l_int|0x3fff
comma
l_int|0x7fff
comma
l_int|0xffff
)brace
suffix:semicolon
multiline_comment|/* copy as much as possible from the sliding window to the output area */
id|local
r_int
id|inflate_flush
id|OF
c_func
(paren
(paren
id|inflate_blocks_statef
op_star
comma
id|z_stream
op_star
comma
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/*+++++*/
multiline_comment|/* inffast.h -- header to use inffast.c&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* WARNING: this file should *not* be used by applications. It is&n;   part of the implementation of the compression library and is&n;   subject to change. Applications should only use zlib.h.&n; */
id|local
r_int
id|inflate_fast
id|OF
c_func
(paren
(paren
id|uInt
comma
id|uInt
comma
id|inflate_huft
op_star
comma
id|inflate_huft
op_star
comma
id|inflate_blocks_statef
op_star
comma
id|z_stream
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*+++++*/
multiline_comment|/* infblock.c -- interpret and process block types to last block&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* Table for deflate from PKZIP&squot;s appnote.txt. */
DECL|variable|border
id|local
id|uInt
id|border
(braket
)braket
op_assign
(brace
multiline_comment|/* Order of the bit length code lengths */
l_int|16
comma
l_int|17
comma
l_int|18
comma
l_int|0
comma
l_int|8
comma
l_int|7
comma
l_int|9
comma
l_int|6
comma
l_int|10
comma
l_int|5
comma
l_int|11
comma
l_int|4
comma
l_int|12
comma
l_int|3
comma
l_int|13
comma
l_int|2
comma
l_int|14
comma
l_int|1
comma
l_int|15
)brace
suffix:semicolon
multiline_comment|/*&n;   Notes beyond the 1.93a appnote.txt:&n;&n;   1. Distance pointers never point before the beginning of the output&n;      stream.&n;   2. Distance pointers can point back across blocks, up to 32k away.&n;   3. There is an implied maximum of 7 bits for the bit length table and&n;      15 bits for the actual data.&n;   4. If only one code exists, then it is encoded using one bit.  (Zero&n;      would be more efficient, but perhaps a little confusing.)  If two&n;      codes exist, they are coded using one bit each (0 and 1).&n;   5. There is no way of sending zero distance codes--a dummy must be&n;      sent if there are none.  (History: a pre 2.0 version of PKZIP would&n;      store blocks with no distance codes, but this was discovered to be&n;      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow&n;      zero distance codes, which is sent as one code of zero bits in&n;      length.&n;   6. There are up to 286 literal/length codes.  Code 256 represents the&n;      end-of-block.  Note however that the static length tree defines&n;      288 codes just to fill out the Huffman codes.  Codes 286 and 287&n;      cannot be used though, since there is no length base or extra bits&n;      defined for them.  Similarily, there are up to 30 distance codes.&n;      However, static trees define 32 codes (all 5 bits) to fill out the&n;      Huffman codes, but the last two had better not show up in the data.&n;   7. Unzip can check dynamic Huffman blocks for complete code sets.&n;      The exception is that a single code would not be complete (see #4).&n;   8. The five bits following the block type is really the number of&n;      literal codes sent minus 257.&n;   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits&n;      (1+6+6).  Therefore, to output three times the length, you output&n;      three codes (1+1+1), whereas to output four times the same length,&n;      you only need two codes (1+3).  Hmm.&n;  10. In the tree reconstruction algorithm, Code = Code + Increment&n;      only if BitLength(i) is not zero.  (Pretty obvious.)&n;  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)&n;  12. Note: length code 284 can represent 227-258, but length code 285&n;      really is 258.  The last length deserves its own, short code&n;      since it gets used a lot in very redundant files.  The length&n;      258 is special since 258 - 3 (the min match length) is 255.&n;  13. The literal/length and distance code bit lengths are read as a&n;      single stream of lengths.  It is possible (and advantageous) for&n;      a repeat code (16, 17, or 18) to go across the boundary between&n;      the two sets of lengths.&n; */
DECL|function|inflate_blocks_reset
id|local
r_void
id|inflate_blocks_reset
c_func
(paren
id|s
comma
id|z
comma
id|c
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
id|uLongf
op_star
id|c
suffix:semicolon
(brace
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
op_star
id|c
op_assign
id|s-&gt;check
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_eq
id|BTREE
op_logical_or
id|s-&gt;mode
op_eq
id|DTREE
)paren
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;sub.trees.blens
comma
id|s-&gt;sub.trees.nblens
op_star
r_sizeof
(paren
id|uInt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_eq
id|CODES
)paren
(brace
id|inflate_codes_free
c_func
(paren
id|s-&gt;sub.decode.codes
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.td
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.tl
comma
id|z
)paren
suffix:semicolon
)brace
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
id|s-&gt;bitk
op_assign
l_int|0
suffix:semicolon
id|s-&gt;bitb
op_assign
l_int|0
suffix:semicolon
id|s-&gt;read
op_assign
id|s-&gt;write
op_assign
id|s-&gt;window
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
l_int|0L
comma
id|Z_NULL
comma
l_int|0
)paren
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:   blocks reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|inflate_blocks_new
id|local
id|inflate_blocks_statef
op_star
id|inflate_blocks_new
c_func
(paren
id|z
comma
id|c
comma
id|w
)paren
id|z_stream
op_star
id|z
suffix:semicolon
id|check_func
id|c
suffix:semicolon
id|uInt
id|w
suffix:semicolon
(brace
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
(paren
id|inflate_blocks_statef
op_star
)paren
id|ZALLOC
(paren
id|z
comma
l_int|1
comma
r_sizeof
(paren
r_struct
id|inflate_blocks_state
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
r_return
id|s
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;window
op_assign
(paren
id|Bytef
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
l_int|1
comma
id|w
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|ZFREE
c_func
(paren
id|z
comma
id|s
comma
r_sizeof
(paren
r_struct
id|inflate_blocks_state
)paren
)paren
suffix:semicolon
r_return
id|Z_NULL
suffix:semicolon
)brace
id|s-&gt;end
op_assign
id|s-&gt;window
op_plus
id|w
suffix:semicolon
id|s-&gt;checkfn
op_assign
id|c
suffix:semicolon
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:   blocks allocated&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inflate_blocks_reset
c_func
(paren
id|s
comma
id|z
comma
op_amp
id|s-&gt;check
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
DECL|function|inflate_blocks
id|local
r_int
id|inflate_blocks
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
r_int
id|r
suffix:semicolon
(brace
id|uInt
id|t
suffix:semicolon
multiline_comment|/* temporary storage */
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
multiline_comment|/* copy input/output information to locals (UPDATE macro restores) */
id|LOAD
multiline_comment|/* process input based on current state */
r_while
c_loop
(paren
l_int|1
)paren
r_switch
c_cond
(paren
id|s-&gt;mode
)paren
(brace
r_case
id|TYPE
suffix:colon
id|NEEDBITS
c_func
(paren
l_int|3
)paren
id|t
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|7
suffix:semicolon
id|s-&gt;last
op_assign
id|t
op_amp
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|t
op_rshift
l_int|1
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* stored */
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:     stored block%s&bslash;n&quot;
comma
id|s-&gt;last
ques
c_cond
l_string|&quot; (last)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|t
op_assign
id|k
op_amp
l_int|7
suffix:semicolon
multiline_comment|/* go to byte boundary */
id|DUMPBITS
c_func
(paren
id|t
)paren
id|s-&gt;mode
op_assign
id|LENS
suffix:semicolon
multiline_comment|/* get length of stored block */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* fixed */
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:     fixed codes block%s&bslash;n&quot;
comma
id|s-&gt;last
ques
c_cond
l_string|&quot; (last)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
(brace
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
id|inflate_trees_fixed
c_func
(paren
op_amp
id|bl
comma
op_amp
id|bd
comma
op_amp
id|tl
comma
op_amp
id|td
)paren
suffix:semicolon
id|s-&gt;sub.decode.codes
op_assign
id|inflate_codes_new
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;sub.decode.codes
op_eq
id|Z_NULL
)paren
(brace
id|r
op_assign
id|Z_MEM_ERROR
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.decode.tl
op_assign
id|Z_NULL
suffix:semicolon
multiline_comment|/* don&squot;t try to free these */
id|s-&gt;sub.decode.td
op_assign
id|Z_NULL
suffix:semicolon
)brace
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;mode
op_assign
id|CODES
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* dynamic */
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:     dynamic codes block%s&bslash;n&quot;
comma
id|s-&gt;last
ques
c_cond
l_string|&quot; (last)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;mode
op_assign
id|TABLE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* illegal */
id|DUMPBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;invalid block type&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
r_break
suffix:semicolon
r_case
id|LENS
suffix:colon
id|NEEDBITS
c_func
(paren
l_int|32
)paren
r_if
c_cond
(paren
(paren
(paren
op_complement
id|b
)paren
op_rshift
l_int|16
)paren
op_ne
(paren
id|b
op_amp
l_int|0xffff
)paren
)paren
(brace
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;invalid stored block lengths&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.left
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|0xffff
suffix:semicolon
id|b
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* dump bits */
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       stored length %u&bslash;n&quot;
comma
id|s-&gt;sub.left
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|s-&gt;sub.left
ques
c_cond
id|STORED
suffix:colon
id|TYPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STORED
suffix:colon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
id|LEAVE
id|NEEDOUT
id|t
op_assign
id|s-&gt;sub.left
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|n
)paren
id|t
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|t
OG
id|m
)paren
id|t
op_assign
id|m
suffix:semicolon
id|zmemcpy
c_func
(paren
id|q
comma
id|p
comma
id|t
)paren
suffix:semicolon
id|p
op_add_assign
id|t
suffix:semicolon
id|n
op_sub_assign
id|t
suffix:semicolon
id|q
op_add_assign
id|t
suffix:semicolon
id|m
op_sub_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sub.left
op_sub_assign
id|t
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       stored end, %lu total out&bslash;n&quot;
comma
id|z-&gt;total_out
op_plus
(paren
id|q
op_ge
id|s-&gt;read
ques
c_cond
id|q
op_minus
id|s-&gt;read
suffix:colon
(paren
id|s-&gt;end
op_minus
id|s-&gt;read
)paren
op_plus
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|s-&gt;last
ques
c_cond
id|DRY
suffix:colon
id|TYPE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TABLE
suffix:colon
id|NEEDBITS
c_func
(paren
l_int|14
)paren
id|s-&gt;sub.trees.table
op_assign
id|t
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|0x3fff
suffix:semicolon
macro_line|#ifndef PKZIP_BUG_WORKAROUND
r_if
c_cond
(paren
(paren
id|t
op_amp
l_int|0x1f
)paren
OG
l_int|29
op_logical_or
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
OG
l_int|29
)paren
(brace
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;too many length or distance symbols&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
macro_line|#endif
id|t
op_assign
l_int|258
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
l_int|19
)paren
id|t
op_assign
l_int|19
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sub.trees.blens
op_assign
(paren
id|uIntf
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
id|t
comma
r_sizeof
(paren
id|uInt
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|r
op_assign
id|Z_MEM_ERROR
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.trees.nblens
op_assign
id|t
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|14
)paren
id|s-&gt;sub.trees.index
op_assign
l_int|0
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       table sizes ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|BTREE
suffix:semicolon
r_case
id|BTREE
suffix:colon
r_while
c_loop
(paren
id|s-&gt;sub.trees.index
OL
l_int|4
op_plus
(paren
id|s-&gt;sub.trees.table
op_rshift
l_int|10
)paren
)paren
(brace
id|NEEDBITS
c_func
(paren
l_int|3
)paren
id|s-&gt;sub.trees.blens
(braket
id|border
(braket
id|s-&gt;sub.trees.index
op_increment
)braket
)braket
op_assign
(paren
id|uInt
)paren
id|b
op_amp
l_int|7
suffix:semicolon
id|DUMPBITS
c_func
(paren
l_int|3
)paren
)brace
r_while
c_loop
(paren
id|s-&gt;sub.trees.index
OL
l_int|19
)paren
id|s-&gt;sub.trees.blens
(braket
id|border
(braket
id|s-&gt;sub.trees.index
op_increment
)braket
)braket
op_assign
l_int|0
suffix:semicolon
id|s-&gt;sub.trees.bb
op_assign
l_int|7
suffix:semicolon
id|t
op_assign
id|inflate_trees_bits
c_func
(paren
id|s-&gt;sub.trees.blens
comma
op_amp
id|s-&gt;sub.trees.bb
comma
op_amp
id|s-&gt;sub.trees.tb
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|Z_OK
)paren
(brace
id|r
op_assign
id|t
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|LEAVE
)brace
id|s-&gt;sub.trees.index
op_assign
l_int|0
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       bits tree ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|DTREE
suffix:semicolon
r_case
id|DTREE
suffix:colon
r_while
c_loop
(paren
id|t
op_assign
id|s-&gt;sub.trees.table
comma
id|s-&gt;sub.trees.index
OL
l_int|258
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
)paren
(brace
id|inflate_huft
op_star
id|h
suffix:semicolon
id|uInt
id|i
comma
id|j
comma
id|c
suffix:semicolon
id|t
op_assign
id|s-&gt;sub.trees.bb
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|t
)paren
id|h
op_assign
id|s-&gt;sub.trees.tb
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|t
)braket
)paren
suffix:semicolon
id|t
op_assign
id|h-&gt;word.what.Bits
suffix:semicolon
id|c
op_assign
id|h-&gt;more.Base
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_int|16
)paren
(brace
id|DUMPBITS
c_func
(paren
id|t
)paren
id|s-&gt;sub.trees.blens
(braket
id|s-&gt;sub.trees.index
op_increment
)braket
op_assign
id|c
suffix:semicolon
)brace
r_else
multiline_comment|/* c == 16..18 */
(brace
id|i
op_assign
id|c
op_eq
l_int|18
ques
c_cond
l_int|7
suffix:colon
id|c
op_minus
l_int|14
suffix:semicolon
id|j
op_assign
id|c
op_eq
l_int|18
ques
c_cond
l_int|11
suffix:colon
l_int|3
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|t
op_plus
id|i
)paren
id|DUMPBITS
c_func
(paren
id|t
)paren
id|j
op_add_assign
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|i
)braket
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|i
)paren
id|i
op_assign
id|s-&gt;sub.trees.index
suffix:semicolon
id|t
op_assign
id|s-&gt;sub.trees.table
suffix:semicolon
r_if
c_cond
(paren
id|i
op_plus
id|j
OG
l_int|258
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
op_logical_or
(paren
id|c
op_eq
l_int|16
op_logical_and
id|i
OL
l_int|1
)paren
)paren
(brace
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;invalid bit length repeat&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
)brace
id|c
op_assign
id|c
op_eq
l_int|16
ques
c_cond
id|s-&gt;sub.trees.blens
(braket
id|i
op_minus
l_int|1
)braket
suffix:colon
l_int|0
suffix:semicolon
r_do
(brace
id|s-&gt;sub.trees.blens
(braket
id|i
op_increment
)braket
op_assign
id|c
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|j
)paren
suffix:semicolon
id|s-&gt;sub.trees.index
op_assign
id|i
suffix:semicolon
)brace
)brace
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.trees.tb
comma
id|z
)paren
suffix:semicolon
id|s-&gt;sub.trees.tb
op_assign
id|Z_NULL
suffix:semicolon
(brace
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
id|inflate_codes_statef
op_star
id|c
suffix:semicolon
id|bl
op_assign
l_int|9
suffix:semicolon
multiline_comment|/* must be &lt;= 9 for lookahead assumptions */
id|bd
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* must be &lt;= 9 for lookahead assumptions */
id|t
op_assign
id|s-&gt;sub.trees.table
suffix:semicolon
id|t
op_assign
id|inflate_trees_dynamic
c_func
(paren
l_int|257
op_plus
(paren
id|t
op_amp
l_int|0x1f
)paren
comma
l_int|1
op_plus
(paren
(paren
id|t
op_rshift
l_int|5
)paren
op_amp
l_int|0x1f
)paren
comma
id|s-&gt;sub.trees.blens
comma
op_amp
id|bl
comma
op_amp
id|bd
comma
op_amp
id|tl
comma
op_amp
id|td
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|Z_OK
)paren
(brace
r_if
c_cond
(paren
id|t
op_eq
(paren
id|uInt
)paren
id|Z_DATA_ERROR
)paren
id|s-&gt;mode
op_assign
id|BADB
suffix:semicolon
id|r
op_assign
id|t
suffix:semicolon
id|LEAVE
)brace
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       trees ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|inflate_codes_new
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|inflate_trees_free
c_func
(paren
id|td
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|tl
comma
id|z
)paren
suffix:semicolon
id|r
op_assign
id|Z_MEM_ERROR
suffix:semicolon
id|LEAVE
)brace
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;sub.trees.blens
comma
id|s-&gt;sub.trees.nblens
op_star
r_sizeof
(paren
id|uInt
)paren
)paren
suffix:semicolon
id|s-&gt;sub.decode.codes
op_assign
id|c
suffix:semicolon
id|s-&gt;sub.decode.tl
op_assign
id|tl
suffix:semicolon
id|s-&gt;sub.decode.td
op_assign
id|td
suffix:semicolon
)brace
id|s-&gt;mode
op_assign
id|CODES
suffix:semicolon
r_case
id|CODES
suffix:colon
id|UPDATE
r_if
c_cond
(paren
(paren
id|r
op_assign
id|inflate_codes
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
)paren
op_ne
id|Z_STREAM_END
)paren
r_return
id|inflate_flush
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
suffix:semicolon
id|r
op_assign
id|Z_OK
suffix:semicolon
id|inflate_codes_free
c_func
(paren
id|s-&gt;sub.decode.codes
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.td
comma
id|z
)paren
suffix:semicolon
id|inflate_trees_free
c_func
(paren
id|s-&gt;sub.decode.tl
comma
id|z
)paren
suffix:semicolon
id|LOAD
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       codes end, %lu total out&bslash;n&quot;
comma
id|z-&gt;total_out
op_plus
(paren
id|q
op_ge
id|s-&gt;read
ques
c_cond
id|q
op_minus
id|s-&gt;read
suffix:colon
(paren
id|s-&gt;end
op_minus
id|s-&gt;read
)paren
op_plus
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;last
)paren
(brace
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OG
l_int|7
)paren
multiline_comment|/* return unused byte, if any */
(brace
id|Assert
c_func
(paren
id|k
OL
l_int|16
comma
l_string|&quot;inflate_codes grabbed too many bytes&quot;
)paren
id|k
op_sub_assign
l_int|8
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|p
op_decrement
suffix:semicolon
multiline_comment|/* can always return one */
)brace
id|s-&gt;mode
op_assign
id|DRY
suffix:semicolon
r_case
id|DRY
suffix:colon
id|FLUSH
r_if
c_cond
(paren
id|s-&gt;read
op_ne
id|s-&gt;write
)paren
id|LEAVE
id|s-&gt;mode
op_assign
id|DONEB
suffix:semicolon
r_case
id|DONEB
suffix:colon
id|r
op_assign
id|Z_STREAM_END
suffix:semicolon
id|LEAVE
r_case
id|BADB
suffix:colon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_default
suffix:colon
id|r
op_assign
id|Z_STREAM_ERROR
suffix:semicolon
id|LEAVE
)brace
)brace
DECL|function|inflate_blocks_free
id|local
r_int
id|inflate_blocks_free
c_func
(paren
id|s
comma
id|z
comma
id|c
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
id|uLongf
op_star
id|c
suffix:semicolon
(brace
id|inflate_blocks_reset
c_func
(paren
id|s
comma
id|z
comma
id|c
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|s-&gt;window
comma
id|s-&gt;end
op_minus
id|s-&gt;window
)paren
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|s
comma
r_sizeof
(paren
r_struct
id|inflate_blocks_state
)paren
)paren
suffix:semicolon
id|Trace
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:   blocks freed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * This subroutine adds the data at next_in/avail_in to the output history&n; * without performing any output.  The output buffer must be &quot;caught up&quot;;&n; * i.e. no pending output (hence s-&gt;read equals s-&gt;write), and the state must&n; * be BLOCKS (i.e. we should be willing to see the start of a series of&n; * BLOCKS).  On exit, the output will also be caught up, and the checksum&n; * will have been updated if need be.&n; */
DECL|function|inflate_addhistory
id|local
r_int
id|inflate_addhistory
c_func
(paren
id|s
comma
id|z
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
multiline_comment|/* NOT USED HERE */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
multiline_comment|/* NOT USED HERE */
id|uInt
id|t
suffix:semicolon
multiline_comment|/* temporary storage */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
r_if
c_cond
(paren
id|s-&gt;read
op_ne
id|s-&gt;write
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_ne
id|TYPE
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
multiline_comment|/* we&squot;re ready to rock */
id|LOAD
multiline_comment|/* while there is input ready, copy to output buffer, moving&n;     * pointers as needed.&n;     */
r_while
c_loop
(paren
id|n
)paren
(brace
id|t
op_assign
id|n
suffix:semicolon
multiline_comment|/* how many to do */
multiline_comment|/* is there room until end of buffer? */
r_if
c_cond
(paren
id|t
OG
id|m
)paren
id|t
op_assign
id|m
suffix:semicolon
multiline_comment|/* update check information */
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
id|s-&gt;check
comma
id|q
comma
id|t
)paren
suffix:semicolon
id|zmemcpy
c_func
(paren
id|q
comma
id|p
comma
id|t
)paren
suffix:semicolon
id|q
op_add_assign
id|t
suffix:semicolon
id|p
op_add_assign
id|t
suffix:semicolon
id|n
op_sub_assign
id|t
suffix:semicolon
id|z-&gt;total_out
op_add_assign
id|t
suffix:semicolon
id|s-&gt;read
op_assign
id|q
suffix:semicolon
multiline_comment|/* drag read pointer forward */
multiline_comment|/*      WRAP  */
multiline_comment|/* expand WRAP macro by hand to handle s-&gt;read */
r_if
c_cond
(paren
id|q
op_eq
id|s-&gt;end
)paren
(brace
id|s-&gt;read
op_assign
id|q
op_assign
id|s-&gt;window
suffix:semicolon
id|m
op_assign
id|WAVAIL
suffix:semicolon
)brace
)brace
id|UPDATE
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * At the end of a Deflate-compressed PPP packet, we expect to have seen&n; * a `stored&squot; block type value but not the (zero) length bytes.&n; */
DECL|function|inflate_packet_flush
id|local
r_int
id|inflate_packet_flush
c_func
(paren
id|s
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
(brace
r_if
c_cond
(paren
id|s-&gt;mode
op_ne
id|LENS
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|s-&gt;mode
op_assign
id|TYPE
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*+++++*/
multiline_comment|/* inftrees.c -- generate Huffman trees for efficient decoding&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* simplify the use of the inflate_huft type with some defines */
DECL|macro|base
mdefine_line|#define base more.Base
DECL|macro|next
mdefine_line|#define next more.Next
DECL|macro|exop
mdefine_line|#define exop word.what.Exop
DECL|macro|bits
mdefine_line|#define bits word.what.Bits
id|local
r_int
id|huft_build
id|OF
c_func
(paren
(paren
id|uIntf
op_star
comma
multiline_comment|/* code lengths in bits */
id|uInt
comma
multiline_comment|/* number of codes */
id|uInt
comma
multiline_comment|/* number of &quot;simple&quot; codes */
id|uIntf
op_star
comma
multiline_comment|/* list of base values for non-simple codes */
id|uIntf
op_star
comma
multiline_comment|/* list of extra bits for non-simple codes */
id|inflate_huft
op_star
id|FAR
op_star
comma
multiline_comment|/* result: starting table */
id|uIntf
op_star
comma
multiline_comment|/* maximum lookup bits (returns actual) */
id|z_stream
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/* for zalloc function */
id|local
id|voidpf
id|falloc
id|OF
c_func
(paren
(paren
id|voidpf
comma
multiline_comment|/* opaque pointer (not used) */
id|uInt
comma
multiline_comment|/* number of items */
id|uInt
)paren
)paren
suffix:semicolon
multiline_comment|/* size of item */
id|local
r_void
id|ffree
id|OF
c_func
(paren
(paren
id|voidpf
id|q
comma
multiline_comment|/* opaque pointer (not used) */
id|voidpf
id|p
comma
multiline_comment|/* what to free (not used) */
id|uInt
id|n
)paren
)paren
suffix:semicolon
multiline_comment|/* number of bytes (not used) */
multiline_comment|/* Tables for deflate from PKZIP&squot;s appnote.txt. */
DECL|variable|cplens
id|local
id|uInt
id|cplens
(braket
)braket
op_assign
(brace
multiline_comment|/* Copy lengths for literal codes 257..285 */
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|13
comma
l_int|15
comma
l_int|17
comma
l_int|19
comma
l_int|23
comma
l_int|27
comma
l_int|31
comma
l_int|35
comma
l_int|43
comma
l_int|51
comma
l_int|59
comma
l_int|67
comma
l_int|83
comma
l_int|99
comma
l_int|115
comma
l_int|131
comma
l_int|163
comma
l_int|195
comma
l_int|227
comma
l_int|258
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* actually lengths - 2; also see note #13 above about 258 */
DECL|variable|cplext
id|local
id|uInt
id|cplext
(braket
)braket
op_assign
(brace
multiline_comment|/* Extra bits for literal codes 257..285 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|0
comma
l_int|192
comma
l_int|192
)brace
suffix:semicolon
multiline_comment|/* 192==invalid */
DECL|variable|cpdist
id|local
id|uInt
id|cpdist
(braket
)braket
op_assign
(brace
multiline_comment|/* Copy offsets for distance codes 0..29 */
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|9
comma
l_int|13
comma
l_int|17
comma
l_int|25
comma
l_int|33
comma
l_int|49
comma
l_int|65
comma
l_int|97
comma
l_int|129
comma
l_int|193
comma
l_int|257
comma
l_int|385
comma
l_int|513
comma
l_int|769
comma
l_int|1025
comma
l_int|1537
comma
l_int|2049
comma
l_int|3073
comma
l_int|4097
comma
l_int|6145
comma
l_int|8193
comma
l_int|12289
comma
l_int|16385
comma
l_int|24577
)brace
suffix:semicolon
DECL|variable|cpdext
id|local
id|uInt
id|cpdext
(braket
)braket
op_assign
(brace
multiline_comment|/* Extra bits for distance codes */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|4
comma
l_int|4
comma
l_int|5
comma
l_int|5
comma
l_int|6
comma
l_int|6
comma
l_int|7
comma
l_int|7
comma
l_int|8
comma
l_int|8
comma
l_int|9
comma
l_int|9
comma
l_int|10
comma
l_int|10
comma
l_int|11
comma
l_int|11
comma
l_int|12
comma
l_int|12
comma
l_int|13
comma
l_int|13
)brace
suffix:semicolon
multiline_comment|/*&n;   Huffman code decoding is performed using a multi-level table lookup.&n;   The fastest way to decode is to simply build a lookup table whose&n;   size is determined by the longest code.  However, the time it takes&n;   to build this table can also be a factor if the data being decoded&n;   is not very long.  The most common codes are necessarily the&n;   shortest codes, so those codes dominate the decoding time, and hence&n;   the speed.  The idea is you can have a shorter table that decodes the&n;   shorter, more probable codes, and then point to subsidiary tables for&n;   the longer codes.  The time it costs to decode the longer codes is&n;   then traded against the time it takes to make longer tables.&n;&n;   This results of this trade are in the variables lbits and dbits&n;   below.  lbits is the number of bits the first level table for literal/&n;   length codes can decode in one step, and dbits is the same thing for&n;   the distance codes.  Subsequent tables are also less than or equal to&n;   those sizes.  These values may be adjusted either when all of the&n;   codes are shorter than that, in which case the longest code length in&n;   bits is used, or when the shortest code is *longer* than the requested&n;   table size, in which case the length of the shortest code in bits is&n;   used.&n;&n;   There are two different values for the two tables, since they code a&n;   different number of possibilities each.  The literal/length table&n;   codes 286 possible values, or in a flat code, a little over eight&n;   bits.  The distance table codes 30 possible values, or a little less&n;   than five bits, flat.  The optimum values for speed end up being&n;   about one bit more than those, so lbits is 8+1 and dbits is 5+1.&n;   The optimum values may differ though from machine to machine, and&n;   possibly even between compilers.  Your mileage may vary.&n; */
multiline_comment|/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
DECL|macro|BMAX
mdefine_line|#define BMAX 15         /* maximum bit length of any code */
DECL|macro|N_MAX
mdefine_line|#define N_MAX 288       /* maximum number of codes in any set */
macro_line|#ifdef DEBUG_ZLIB
DECL|variable|inflate_hufts
id|uInt
id|inflate_hufts
suffix:semicolon
macro_line|#endif
DECL|function|huft_build
id|local
r_int
id|huft_build
c_func
(paren
id|b
comma
id|n
comma
id|s
comma
id|d
comma
id|e
comma
id|t
comma
id|m
comma
id|zs
)paren
id|uIntf
op_star
id|b
suffix:semicolon
multiline_comment|/* code lengths in bits (all assumed &lt;= BMAX) */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of codes (assumed &lt;= N_MAX) */
id|uInt
id|s
suffix:semicolon
multiline_comment|/* number of simple-valued codes (0..s-1) */
id|uIntf
op_star
id|d
suffix:semicolon
multiline_comment|/* list of base values for non-simple codes */
id|uIntf
op_star
id|e
suffix:semicolon
multiline_comment|/* list of extra bits for non-simple codes */
id|inflate_huft
op_star
id|FAR
op_star
id|t
suffix:semicolon
multiline_comment|/* result: starting table */
id|uIntf
op_star
id|m
suffix:semicolon
multiline_comment|/* maximum lookup bits, returns actual */
id|z_stream
op_star
id|zs
suffix:semicolon
multiline_comment|/* for zalloc function */
multiline_comment|/* Given a list of code lengths and a maximum table size, make a set of&n;   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR&n;   if the given code set is incomplete (the tables are still built in this&n;   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an&n;   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
(brace
id|uInt
id|a
suffix:semicolon
multiline_comment|/* counter for codes of length k */
id|uInt
id|c
(braket
id|BMAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bit length count table */
id|uInt
id|f
suffix:semicolon
multiline_comment|/* i repeats in table every f entries */
r_int
id|g
suffix:semicolon
multiline_comment|/* maximum code length */
r_int
id|h
suffix:semicolon
multiline_comment|/* table level */
r_register
id|uInt
id|i
suffix:semicolon
multiline_comment|/* counter, current code */
r_register
id|uInt
id|j
suffix:semicolon
multiline_comment|/* counter */
r_register
r_int
id|k
suffix:semicolon
multiline_comment|/* number of bits in current code */
r_int
id|l
suffix:semicolon
multiline_comment|/* bits per table (returned in m) */
r_register
id|uIntf
op_star
id|p
suffix:semicolon
multiline_comment|/* pointer into c[], b[], or v[] */
id|inflate_huft
op_star
id|q
suffix:semicolon
multiline_comment|/* points to current table */
r_struct
id|inflate_huft_s
id|r
suffix:semicolon
multiline_comment|/* table entry for structure assignment */
id|inflate_huft
op_star
id|u
(braket
id|BMAX
)braket
suffix:semicolon
multiline_comment|/* table stack */
id|uInt
id|v
(braket
id|N_MAX
)braket
suffix:semicolon
multiline_comment|/* values in order of bit length */
r_register
r_int
id|w
suffix:semicolon
multiline_comment|/* bits before this table == (l * h) */
id|uInt
id|x
(braket
id|BMAX
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bit offsets, then code stack */
id|uIntf
op_star
id|xp
suffix:semicolon
multiline_comment|/* pointer into x */
r_int
id|y
suffix:semicolon
multiline_comment|/* number of dummy codes added */
id|uInt
id|z
suffix:semicolon
multiline_comment|/* number of entries in current table */
multiline_comment|/* Generate counts for each bit length */
id|p
op_assign
id|c
suffix:semicolon
DECL|macro|C0
mdefine_line|#define C0 *p++ = 0;
DECL|macro|C2
mdefine_line|#define C2 C0 C0 C0 C0
DECL|macro|C4
mdefine_line|#define C4 C2 C2 C2 C2
id|C4
multiline_comment|/* clear c[]--assume BMAX+1 is 16 */
id|p
op_assign
id|b
suffix:semicolon
id|i
op_assign
id|n
suffix:semicolon
r_do
(brace
id|c
(braket
op_star
id|p
op_increment
)braket
op_increment
suffix:semicolon
multiline_comment|/* assume all entries &lt;= BMAX */
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
(braket
l_int|0
)braket
op_eq
id|n
)paren
multiline_comment|/* null input--all zero length codes */
(brace
op_star
id|t
op_assign
(paren
id|inflate_huft
op_star
)paren
id|Z_NULL
suffix:semicolon
op_star
id|m
op_assign
l_int|0
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* Find minimum and maximum length, bound *m by those */
id|l
op_assign
op_star
id|m
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|BMAX
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|c
(braket
id|j
)braket
)paren
r_break
suffix:semicolon
id|k
op_assign
id|j
suffix:semicolon
multiline_comment|/* minimum code length */
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|l
OL
id|j
)paren
id|l
op_assign
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|BMAX
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|c
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
id|g
op_assign
id|i
suffix:semicolon
multiline_comment|/* maximum code length */
r_if
c_cond
(paren
(paren
id|uInt
)paren
id|l
OG
id|i
)paren
id|l
op_assign
id|i
suffix:semicolon
op_star
id|m
op_assign
id|l
suffix:semicolon
multiline_comment|/* Adjust last length count to fill out codes, if needed */
r_for
c_loop
(paren
id|y
op_assign
l_int|1
op_lshift
id|j
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
comma
id|y
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|y
op_sub_assign
id|c
(braket
id|j
)braket
)paren
OL
l_int|0
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|y
op_sub_assign
id|c
(braket
id|i
)braket
)paren
OL
l_int|0
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|c
(braket
id|i
)braket
op_add_assign
id|y
suffix:semicolon
multiline_comment|/* Generate starting offsets into the value table for each length */
id|x
(braket
l_int|1
)braket
op_assign
id|j
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|c
op_plus
l_int|1
suffix:semicolon
id|xp
op_assign
id|x
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
)paren
(brace
multiline_comment|/* note that i == g from above */
op_star
id|xp
op_increment
op_assign
(paren
id|j
op_add_assign
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/* Make a table of values in order of bit lengths */
id|p
op_assign
id|b
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|j
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
id|v
(braket
id|x
(braket
id|j
)braket
op_increment
)braket
op_assign
id|i
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
OL
id|n
)paren
suffix:semicolon
multiline_comment|/* Generate the Huffman codes and for each, make the table entries */
id|x
(braket
l_int|0
)braket
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first Huffman code is zero */
id|p
op_assign
id|v
suffix:semicolon
multiline_comment|/* grab values in bit order */
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no tables yet--level -1 */
id|w
op_assign
op_minus
id|l
suffix:semicolon
multiline_comment|/* bits decoded == (l * h) */
id|u
(braket
l_int|0
)braket
op_assign
(paren
id|inflate_huft
op_star
)paren
id|Z_NULL
suffix:semicolon
multiline_comment|/* just to keep compilers happy */
id|q
op_assign
(paren
id|inflate_huft
op_star
)paren
id|Z_NULL
suffix:semicolon
multiline_comment|/* ditto */
id|z
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ditto */
multiline_comment|/* go through the bit lengths (k already is bits in shortest code) */
r_for
c_loop
(paren
suffix:semicolon
id|k
op_le
id|g
suffix:semicolon
id|k
op_increment
)paren
(brace
id|a
op_assign
id|c
(braket
id|k
)braket
suffix:semicolon
r_while
c_loop
(paren
id|a
op_decrement
)paren
(brace
multiline_comment|/* here i is the Huffman code of length k bits for value *p */
multiline_comment|/* make tables up to required level */
r_while
c_loop
(paren
id|k
OG
id|w
op_plus
id|l
)paren
(brace
id|h
op_increment
suffix:semicolon
id|w
op_add_assign
id|l
suffix:semicolon
multiline_comment|/* previous table always l bits */
multiline_comment|/* compute minimum size table less than or equal to l bits */
id|z
op_assign
(paren
id|z
op_assign
id|g
op_minus
id|w
)paren
OG
(paren
id|uInt
)paren
id|l
ques
c_cond
id|l
suffix:colon
id|z
suffix:semicolon
multiline_comment|/* table size upper limit */
r_if
c_cond
(paren
(paren
id|f
op_assign
l_int|1
op_lshift
(paren
id|j
op_assign
id|k
op_minus
id|w
)paren
)paren
OG
id|a
op_plus
l_int|1
)paren
multiline_comment|/* try a k-w bit table */
(brace
multiline_comment|/* too few codes for k-w bit table */
id|f
op_sub_assign
id|a
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* deduct codes from patterns left */
id|xp
op_assign
id|c
op_plus
id|k
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
id|z
)paren
r_while
c_loop
(paren
op_increment
id|j
OL
id|z
)paren
multiline_comment|/* try smaller tables up to z bits */
(brace
r_if
c_cond
(paren
(paren
id|f
op_lshift_assign
l_int|1
)paren
op_le
op_star
op_increment
id|xp
)paren
r_break
suffix:semicolon
multiline_comment|/* enough codes to use up j bits */
id|f
op_sub_assign
op_star
id|xp
suffix:semicolon
multiline_comment|/* else deduct codes from patterns */
)brace
)brace
id|z
op_assign
l_int|1
op_lshift
id|j
suffix:semicolon
multiline_comment|/* table entries for j-bit table */
multiline_comment|/* allocate and link in new table */
r_if
c_cond
(paren
(paren
id|q
op_assign
(paren
id|inflate_huft
op_star
)paren
id|ZALLOC
(paren
id|zs
comma
id|z
op_plus
l_int|1
comma
r_sizeof
(paren
id|inflate_huft
)paren
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
r_if
c_cond
(paren
id|h
)paren
id|inflate_trees_free
c_func
(paren
id|u
(braket
l_int|0
)braket
comma
id|zs
)paren
suffix:semicolon
r_return
id|Z_MEM_ERROR
suffix:semicolon
multiline_comment|/* not enough memory */
)brace
id|q-&gt;word.Nalloc
op_assign
id|z
op_plus
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG_ZLIB
id|inflate_hufts
op_add_assign
id|z
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
op_star
id|t
op_assign
id|q
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* link to list for huft_free() */
op_star
(paren
id|t
op_assign
op_amp
(paren
id|q-&gt;next
)paren
)paren
op_assign
id|Z_NULL
suffix:semicolon
id|u
(braket
id|h
)braket
op_assign
op_increment
id|q
suffix:semicolon
multiline_comment|/* table starts after link */
multiline_comment|/* connect to last table, if there is one */
r_if
c_cond
(paren
id|h
)paren
(brace
id|x
(braket
id|h
)braket
op_assign
id|i
suffix:semicolon
multiline_comment|/* save pattern for backing up */
id|r.bits
op_assign
(paren
id|Byte
)paren
id|l
suffix:semicolon
multiline_comment|/* bits to dump before this table */
id|r.exop
op_assign
(paren
id|Byte
)paren
id|j
suffix:semicolon
multiline_comment|/* bits in this table */
id|r.next
op_assign
id|q
suffix:semicolon
multiline_comment|/* pointer to this table */
id|j
op_assign
id|i
op_rshift
(paren
id|w
op_minus
id|l
)paren
suffix:semicolon
multiline_comment|/* (get around Turbo C bug) */
id|u
(braket
id|h
op_minus
l_int|1
)braket
(braket
id|j
)braket
op_assign
id|r
suffix:semicolon
multiline_comment|/* connect to last table */
)brace
)brace
multiline_comment|/* set up table entry in r */
id|r.bits
op_assign
(paren
id|Byte
)paren
(paren
id|k
op_minus
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|v
op_plus
id|n
)paren
id|r.exop
op_assign
l_int|128
op_plus
l_int|64
suffix:semicolon
multiline_comment|/* out of values--invalid code */
r_else
r_if
c_cond
(paren
op_star
id|p
OL
id|s
)paren
(brace
id|r.exop
op_assign
(paren
id|Byte
)paren
(paren
op_star
id|p
OL
l_int|256
ques
c_cond
l_int|0
suffix:colon
l_int|32
op_plus
l_int|64
)paren
suffix:semicolon
multiline_comment|/* 256 is end-of-block */
id|r.base
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* simple code is just the value */
)brace
r_else
(brace
id|r.exop
op_assign
(paren
id|Byte
)paren
id|e
(braket
op_star
id|p
op_minus
id|s
)braket
op_plus
l_int|16
op_plus
l_int|64
suffix:semicolon
multiline_comment|/* non-simple--look up in lists */
id|r.base
op_assign
id|d
(braket
op_star
id|p
op_increment
op_minus
id|s
)braket
suffix:semicolon
)brace
multiline_comment|/* fill code-like entries with r */
id|f
op_assign
l_int|1
op_lshift
(paren
id|k
op_minus
id|w
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_rshift
id|w
suffix:semicolon
id|j
OL
id|z
suffix:semicolon
id|j
op_add_assign
id|f
)paren
id|q
(braket
id|j
)braket
op_assign
id|r
suffix:semicolon
multiline_comment|/* backwards increment the k-bit code i */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
op_lshift
(paren
id|k
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_amp
id|j
suffix:semicolon
id|j
op_rshift_assign
l_int|1
)paren
id|i
op_xor_assign
id|j
suffix:semicolon
id|i
op_xor_assign
id|j
suffix:semicolon
multiline_comment|/* backup over finished tables */
r_while
c_loop
(paren
(paren
id|i
op_amp
(paren
(paren
l_int|1
op_lshift
id|w
)paren
op_minus
l_int|1
)paren
)paren
op_ne
id|x
(braket
id|h
)braket
)paren
(brace
id|h
op_decrement
suffix:semicolon
multiline_comment|/* don&squot;t need to update q */
id|w
op_sub_assign
id|l
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Return Z_BUF_ERROR if we were given an incomplete table */
r_return
id|y
op_ne
l_int|0
op_logical_and
id|g
op_ne
l_int|1
ques
c_cond
id|Z_BUF_ERROR
suffix:colon
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflate_trees_bits
id|local
r_int
id|inflate_trees_bits
c_func
(paren
id|c
comma
id|bb
comma
id|tb
comma
id|z
)paren
id|uIntf
op_star
id|c
suffix:semicolon
multiline_comment|/* 19 code lengths */
id|uIntf
op_star
id|bb
suffix:semicolon
multiline_comment|/* bits tree desired/actual depth */
id|inflate_huft
op_star
id|FAR
op_star
id|tb
suffix:semicolon
multiline_comment|/* bits tree result */
id|z_stream
op_star
id|z
suffix:semicolon
multiline_comment|/* for zfree function */
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|huft_build
c_func
(paren
id|c
comma
l_int|19
comma
l_int|19
comma
(paren
id|uIntf
op_star
)paren
id|Z_NULL
comma
(paren
id|uIntf
op_star
)paren
id|Z_NULL
comma
id|tb
comma
id|bb
comma
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|z-&gt;msg
op_assign
l_string|&quot;oversubscribed dynamic bit lengths tree&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
op_eq
id|Z_BUF_ERROR
)paren
(brace
id|inflate_trees_free
c_func
(paren
op_star
id|tb
comma
id|z
)paren
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;incomplete dynamic bit lengths tree&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|inflate_trees_dynamic
id|local
r_int
id|inflate_trees_dynamic
c_func
(paren
id|nl
comma
id|nd
comma
id|c
comma
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
id|uInt
id|nl
suffix:semicolon
multiline_comment|/* number of literal/length codes */
id|uInt
id|nd
suffix:semicolon
multiline_comment|/* number of distance codes */
id|uIntf
op_star
id|c
suffix:semicolon
multiline_comment|/* that many (total) code lengths */
id|uIntf
op_star
id|bl
suffix:semicolon
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
id|bd
suffix:semicolon
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
id|tl
suffix:semicolon
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
id|td
suffix:semicolon
multiline_comment|/* distance tree result */
id|z_stream
op_star
id|z
suffix:semicolon
multiline_comment|/* for zfree function */
(brace
r_int
id|r
suffix:semicolon
multiline_comment|/* build literal/length tree */
r_if
c_cond
(paren
(paren
id|r
op_assign
id|huft_build
c_func
(paren
id|c
comma
id|nl
comma
l_int|257
comma
id|cplens
comma
id|cplext
comma
id|tl
comma
id|bl
comma
id|z
)paren
)paren
op_ne
id|Z_OK
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|z-&gt;msg
op_assign
l_string|&quot;oversubscribed literal/length tree&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
op_eq
id|Z_BUF_ERROR
)paren
(brace
id|inflate_trees_free
c_func
(paren
op_star
id|tl
comma
id|z
)paren
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;incomplete literal/length tree&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* build distance tree */
r_if
c_cond
(paren
(paren
id|r
op_assign
id|huft_build
c_func
(paren
id|c
op_plus
id|nl
comma
id|nd
comma
l_int|0
comma
id|cpdist
comma
id|cpdext
comma
id|td
comma
id|bd
comma
id|z
)paren
)paren
op_ne
id|Z_OK
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
id|z-&gt;msg
op_assign
l_string|&quot;oversubscribed literal/length tree&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|r
op_eq
id|Z_BUF_ERROR
)paren
(brace
macro_line|#ifdef PKZIP_BUG_WORKAROUND
id|r
op_assign
id|Z_OK
suffix:semicolon
)brace
macro_line|#else
id|inflate_trees_free
c_func
(paren
op_star
id|td
comma
id|z
)paren
suffix:semicolon
id|z-&gt;msg
op_assign
l_string|&quot;incomplete literal/length tree&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
)brace
id|inflate_trees_free
c_func
(paren
op_star
id|tl
comma
id|z
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* done */
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* build fixed tables only once--keep them here */
DECL|variable|fixed_lock
id|local
r_int
id|fixed_lock
op_assign
l_int|0
suffix:semicolon
DECL|variable|fixed_built
id|local
r_int
id|fixed_built
op_assign
l_int|0
suffix:semicolon
DECL|macro|FIXEDH
mdefine_line|#define FIXEDH 530      /* number of hufts used by fixed tables */
DECL|variable|fixed_left
id|local
id|uInt
id|fixed_left
op_assign
id|FIXEDH
suffix:semicolon
DECL|variable|fixed_mem
id|local
id|inflate_huft
id|fixed_mem
(braket
id|FIXEDH
)braket
suffix:semicolon
DECL|variable|fixed_bl
id|local
id|uInt
id|fixed_bl
suffix:semicolon
DECL|variable|fixed_bd
id|local
id|uInt
id|fixed_bd
suffix:semicolon
DECL|variable|fixed_tl
id|local
id|inflate_huft
op_star
id|fixed_tl
suffix:semicolon
DECL|variable|fixed_td
id|local
id|inflate_huft
op_star
id|fixed_td
suffix:semicolon
DECL|function|falloc
id|local
id|voidpf
id|falloc
c_func
(paren
id|q
comma
id|n
comma
id|s
)paren
id|voidpf
id|q
suffix:semicolon
multiline_comment|/* opaque pointer (not used) */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of items */
id|uInt
id|s
suffix:semicolon
multiline_comment|/* size of item */
(brace
id|Assert
c_func
(paren
id|s
op_eq
r_sizeof
(paren
id|inflate_huft
)paren
op_logical_and
id|n
op_le
id|fixed_left
comma
l_string|&quot;inflate_trees falloc overflow&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
id|s
op_increment
suffix:semicolon
multiline_comment|/* to make some compilers happy */
id|fixed_left
op_sub_assign
id|n
suffix:semicolon
r_return
(paren
id|voidpf
)paren
(paren
id|fixed_mem
op_plus
id|fixed_left
)paren
suffix:semicolon
)brace
DECL|function|ffree
id|local
r_void
id|ffree
c_func
(paren
id|q
comma
id|p
comma
id|n
)paren
id|voidpf
id|q
suffix:semicolon
id|voidpf
id|p
suffix:semicolon
id|uInt
id|n
suffix:semicolon
(brace
id|Assert
c_func
(paren
l_int|0
comma
l_string|&quot;inflate_trees ffree called!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
id|q
op_assign
id|p
suffix:semicolon
multiline_comment|/* to make some compilers happy */
)brace
DECL|function|inflate_trees_fixed
id|local
r_int
id|inflate_trees_fixed
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
)paren
id|uIntf
op_star
id|bl
suffix:semicolon
multiline_comment|/* literal desired/actual bit depth */
id|uIntf
op_star
id|bd
suffix:semicolon
multiline_comment|/* distance desired/actual bit depth */
id|inflate_huft
op_star
id|FAR
op_star
id|tl
suffix:semicolon
multiline_comment|/* literal/length tree result */
id|inflate_huft
op_star
id|FAR
op_star
id|td
suffix:semicolon
multiline_comment|/* distance tree result */
(brace
multiline_comment|/* build fixed tables if not built already--lock out other instances */
r_while
c_loop
(paren
op_increment
id|fixed_lock
OG
l_int|1
)paren
id|fixed_lock
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fixed_built
)paren
(brace
r_int
id|k
suffix:semicolon
multiline_comment|/* temporary variable */
r_int
id|c
(braket
l_int|288
)braket
suffix:semicolon
multiline_comment|/* length list for huft_build */
id|z_stream
id|z
suffix:semicolon
multiline_comment|/* for falloc function */
multiline_comment|/* set up fake z_stream for memory routines */
id|z.zalloc
op_assign
id|falloc
suffix:semicolon
id|z.zfree
op_assign
id|ffree
suffix:semicolon
id|z.opaque
op_assign
id|Z_NULL
suffix:semicolon
multiline_comment|/* literal table */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|144
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|8
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
l_int|256
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|9
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
l_int|280
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|7
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
l_int|288
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|8
suffix:semicolon
id|fixed_bl
op_assign
l_int|7
suffix:semicolon
id|huft_build
c_func
(paren
id|c
comma
l_int|288
comma
l_int|257
comma
id|cplens
comma
id|cplext
comma
op_amp
id|fixed_tl
comma
op_amp
id|fixed_bl
comma
op_amp
id|z
)paren
suffix:semicolon
multiline_comment|/* distance table */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|30
suffix:semicolon
id|k
op_increment
)paren
id|c
(braket
id|k
)braket
op_assign
l_int|5
suffix:semicolon
id|fixed_bd
op_assign
l_int|5
suffix:semicolon
id|huft_build
c_func
(paren
id|c
comma
l_int|30
comma
l_int|0
comma
id|cpdist
comma
id|cpdext
comma
op_amp
id|fixed_td
comma
op_amp
id|fixed_bd
comma
op_amp
id|z
)paren
suffix:semicolon
multiline_comment|/* done */
id|fixed_built
op_assign
l_int|1
suffix:semicolon
)brace
id|fixed_lock
op_decrement
suffix:semicolon
op_star
id|bl
op_assign
id|fixed_bl
suffix:semicolon
op_star
id|bd
op_assign
id|fixed_bd
suffix:semicolon
op_star
id|tl
op_assign
id|fixed_tl
suffix:semicolon
op_star
id|td
op_assign
id|fixed_td
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|inflate_trees_free
id|local
r_int
id|inflate_trees_free
c_func
(paren
id|t
comma
id|z
)paren
id|inflate_huft
op_star
id|t
suffix:semicolon
multiline_comment|/* table to free */
id|z_stream
op_star
id|z
suffix:semicolon
multiline_comment|/* for zfree function */
multiline_comment|/* Free the malloc&squot;ed tables built by huft_build(), which makes a linked&n;   list of the tables it made, with the links in a dummy first entry of&n;   each table. */
(brace
r_register
id|inflate_huft
op_star
id|p
comma
op_star
id|q
suffix:semicolon
multiline_comment|/* Go through linked list, freeing from the malloced (t[-1]) address. */
id|p
op_assign
id|t
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
id|Z_NULL
)paren
(brace
id|q
op_assign
(paren
op_decrement
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|ZFREE
c_func
(paren
id|z
comma
id|p
comma
id|p-&gt;word.Nalloc
op_star
r_sizeof
(paren
id|inflate_huft
)paren
)paren
suffix:semicolon
id|p
op_assign
id|q
suffix:semicolon
)brace
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*+++++*/
multiline_comment|/* infcodes.c -- process literals and length/distance pairs&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* simplify the use of the inflate_huft type with some defines */
DECL|macro|base
mdefine_line|#define base more.Base
DECL|macro|next
mdefine_line|#define next more.Next
DECL|macro|exop
mdefine_line|#define exop word.what.Exop
DECL|macro|bits
mdefine_line|#define bits word.what.Bits
multiline_comment|/* inflate codes private state */
DECL|struct|inflate_codes_state
r_struct
id|inflate_codes_state
(brace
multiline_comment|/* mode */
r_enum
(brace
multiline_comment|/* waiting for &quot;i:&quot;=input, &quot;o:&quot;=output, &quot;x:&quot;=nothing */
DECL|enumerator|START
id|START
comma
multiline_comment|/* x: set up for LEN */
DECL|enumerator|LEN
id|LEN
comma
multiline_comment|/* i: get length/literal/eob next */
DECL|enumerator|LENEXT
id|LENEXT
comma
multiline_comment|/* i: getting length extra (have base) */
DECL|enumerator|DIST
id|DIST
comma
multiline_comment|/* i: get distance next */
DECL|enumerator|DISTEXT
id|DISTEXT
comma
multiline_comment|/* i: getting distance extra */
DECL|enumerator|COPY
id|COPY
comma
multiline_comment|/* o: copying bytes in window, waiting for space */
DECL|enumerator|LIT
id|LIT
comma
multiline_comment|/* o: got literal, waiting for output space */
DECL|enumerator|WASH
id|WASH
comma
multiline_comment|/* o: got eob, possibly still output waiting */
DECL|enumerator|END
id|END
comma
multiline_comment|/* x: got eob and all data flushed */
DECL|enumerator|BADCODE
id|BADCODE
)brace
multiline_comment|/* x: got error */
DECL|member|mode
id|mode
suffix:semicolon
multiline_comment|/* current inflate_codes mode */
multiline_comment|/* mode dependent information */
DECL|member|len
id|uInt
id|len
suffix:semicolon
r_union
(brace
r_struct
(brace
DECL|member|tree
id|inflate_huft
op_star
id|tree
suffix:semicolon
multiline_comment|/* pointer into tree */
DECL|member|need
id|uInt
id|need
suffix:semicolon
multiline_comment|/* bits needed */
DECL|member|code
)brace
id|code
suffix:semicolon
multiline_comment|/* if LEN or DIST, where in tree */
DECL|member|lit
id|uInt
id|lit
suffix:semicolon
multiline_comment|/* if LIT, literal */
r_struct
(brace
DECL|member|get
id|uInt
id|get
suffix:semicolon
multiline_comment|/* bits to get for extra */
DECL|member|dist
id|uInt
id|dist
suffix:semicolon
multiline_comment|/* distance back to copy from */
DECL|member|copy
)brace
id|copy
suffix:semicolon
multiline_comment|/* if EXT or COPY, where and how much */
DECL|member|sub
)brace
id|sub
suffix:semicolon
multiline_comment|/* submode */
multiline_comment|/* mode independent information */
DECL|member|lbits
id|Byte
id|lbits
suffix:semicolon
multiline_comment|/* ltree bits decoded per branch */
DECL|member|dbits
id|Byte
id|dbits
suffix:semicolon
multiline_comment|/* dtree bits decoder per branch */
DECL|member|ltree
id|inflate_huft
op_star
id|ltree
suffix:semicolon
multiline_comment|/* literal/length/eob tree */
DECL|member|dtree
id|inflate_huft
op_star
id|dtree
suffix:semicolon
multiline_comment|/* distance tree */
)brace
suffix:semicolon
DECL|function|inflate_codes_new
id|local
id|inflate_codes_statef
op_star
id|inflate_codes_new
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|z
)paren
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|inflate_codes_statef
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
(paren
id|inflate_codes_statef
op_star
)paren
id|ZALLOC
c_func
(paren
id|z
comma
l_int|1
comma
r_sizeof
(paren
r_struct
id|inflate_codes_state
)paren
)paren
)paren
op_ne
id|Z_NULL
)paren
(brace
id|c-&gt;mode
op_assign
id|START
suffix:semicolon
id|c-&gt;lbits
op_assign
(paren
id|Byte
)paren
id|bl
suffix:semicolon
id|c-&gt;dbits
op_assign
(paren
id|Byte
)paren
id|bd
suffix:semicolon
id|c-&gt;ltree
op_assign
id|tl
suffix:semicolon
id|c-&gt;dtree
op_assign
id|td
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       codes new&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
DECL|function|inflate_codes
id|local
r_int
id|inflate_codes
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
r_int
id|r
suffix:semicolon
(brace
id|uInt
id|j
suffix:semicolon
multiline_comment|/* temporary storage */
id|inflate_huft
op_star
id|t
suffix:semicolon
multiline_comment|/* temporary pointer */
id|uInt
id|e
suffix:semicolon
multiline_comment|/* extra bits or operation */
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
id|Bytef
op_star
id|f
suffix:semicolon
multiline_comment|/* pointer to copy strings from */
id|inflate_codes_statef
op_star
id|c
op_assign
id|s-&gt;sub.decode.codes
suffix:semicolon
multiline_comment|/* codes state */
multiline_comment|/* copy input/output information to locals (UPDATE macro restores) */
id|LOAD
multiline_comment|/* process input and output based on current state */
r_while
c_loop
(paren
l_int|1
)paren
r_switch
c_cond
(paren
id|c-&gt;mode
)paren
(brace
multiline_comment|/* waiting for &quot;i:&quot;=input, &quot;o:&quot;=output, &quot;x:&quot;=nothing */
r_case
id|START
suffix:colon
multiline_comment|/* x: set up for LEN */
macro_line|#ifndef SLOW
r_if
c_cond
(paren
id|m
op_ge
l_int|258
op_logical_and
id|n
op_ge
l_int|10
)paren
(brace
id|UPDATE
id|r
op_assign
id|inflate_fast
c_func
(paren
id|c-&gt;lbits
comma
id|c-&gt;dbits
comma
id|c-&gt;ltree
comma
id|c-&gt;dtree
comma
id|s
comma
id|z
)paren
suffix:semicolon
id|LOAD
r_if
c_cond
(paren
id|r
op_ne
id|Z_OK
)paren
(brace
id|c-&gt;mode
op_assign
id|r
op_eq
id|Z_STREAM_END
ques
c_cond
id|WASH
suffix:colon
id|BADCODE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif /* !SLOW */
id|c-&gt;sub.code.need
op_assign
id|c-&gt;lbits
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|c-&gt;ltree
suffix:semicolon
id|c-&gt;mode
op_assign
id|LEN
suffix:semicolon
r_case
id|LEN
suffix:colon
multiline_comment|/* i: get length/literal/eob next */
id|j
op_assign
id|c-&gt;sub.code.need
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|t
op_assign
id|c-&gt;sub.code.tree
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|e
op_assign
(paren
id|uInt
)paren
(paren
id|t-&gt;exop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_eq
l_int|0
)paren
multiline_comment|/* literal */
(brace
id|c-&gt;sub.lit
op_assign
id|t-&gt;base
suffix:semicolon
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
id|t-&gt;base
op_ge
l_int|0x20
op_logical_and
id|t-&gt;base
OL
l_int|0x7f
ques
c_cond
l_string|&quot;inflate:         literal &squot;%c&squot;&bslash;n&quot;
suffix:colon
l_string|&quot;inflate:         literal 0x%02x&bslash;n&quot;
comma
id|t-&gt;base
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|LIT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
multiline_comment|/* length */
(brace
id|c-&gt;sub.copy.get
op_assign
id|e
op_amp
l_int|15
suffix:semicolon
id|c-&gt;len
op_assign
id|t-&gt;base
suffix:semicolon
id|c-&gt;mode
op_assign
id|LENEXT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
multiline_comment|/* next table */
(brace
id|c-&gt;sub.code.need
op_assign
id|e
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|t-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e
op_amp
l_int|32
)paren
multiline_comment|/* end of block */
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         end of block&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|WASH
suffix:semicolon
r_break
suffix:semicolon
)brace
id|c-&gt;mode
op_assign
id|BADCODE
suffix:semicolon
multiline_comment|/* invalid code */
id|z-&gt;msg
op_assign
l_string|&quot;invalid literal/length code&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_case
id|LENEXT
suffix:colon
multiline_comment|/* i: getting length extra (have base) */
id|j
op_assign
id|c-&gt;sub.copy.get
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|c-&gt;len
op_add_assign
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|j
)paren
id|c-&gt;sub.code.need
op_assign
id|c-&gt;dbits
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|c-&gt;dtree
suffix:semicolon
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         length %u&bslash;n&quot;
comma
id|c-&gt;len
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|DIST
suffix:semicolon
r_case
id|DIST
suffix:colon
multiline_comment|/* i: get distance next */
id|j
op_assign
id|c-&gt;sub.code.need
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|t
op_assign
id|c-&gt;sub.code.tree
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|e
op_assign
(paren
id|uInt
)paren
(paren
id|t-&gt;exop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
multiline_comment|/* distance */
(brace
id|c-&gt;sub.copy.get
op_assign
id|e
op_amp
l_int|15
suffix:semicolon
id|c-&gt;sub.copy.dist
op_assign
id|t-&gt;base
suffix:semicolon
id|c-&gt;mode
op_assign
id|DISTEXT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
multiline_comment|/* next table */
(brace
id|c-&gt;sub.code.need
op_assign
id|e
suffix:semicolon
id|c-&gt;sub.code.tree
op_assign
id|t-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|c-&gt;mode
op_assign
id|BADCODE
suffix:semicolon
multiline_comment|/* invalid code */
id|z-&gt;msg
op_assign
l_string|&quot;invalid distance code&quot;
suffix:semicolon
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_case
id|DISTEXT
suffix:colon
multiline_comment|/* i: getting distance extra */
id|j
op_assign
id|c-&gt;sub.copy.get
suffix:semicolon
id|NEEDBITS
c_func
(paren
id|j
)paren
id|c-&gt;sub.copy.dist
op_add_assign
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|j
)braket
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|j
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         distance %u&bslash;n&quot;
comma
id|c-&gt;sub.copy.dist
)paren
)paren
suffix:semicolon
id|c-&gt;mode
op_assign
id|COPY
suffix:semicolon
r_case
id|COPY
suffix:colon
multiline_comment|/* o: copying bytes in window, waiting for space */
macro_line|#ifndef __TURBOC__ /* Turbo C bug for following expression */
id|f
op_assign
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
OL
id|c-&gt;sub.copy.dist
ques
c_cond
id|s-&gt;end
op_minus
(paren
id|c-&gt;sub.copy.dist
op_minus
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
suffix:colon
id|q
op_minus
id|c-&gt;sub.copy.dist
suffix:semicolon
macro_line|#else
id|f
op_assign
id|q
op_minus
id|c-&gt;sub.copy.dist
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
OL
id|c-&gt;sub.copy.dist
)paren
id|f
op_assign
id|s-&gt;end
op_minus
(paren
id|c-&gt;sub.copy.dist
op_minus
(paren
id|q
op_minus
id|s-&gt;window
)paren
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|c-&gt;len
)paren
(brace
id|NEEDOUT
id|OUTBYTE
c_func
(paren
op_star
id|f
op_increment
)paren
r_if
c_cond
(paren
id|f
op_eq
id|s-&gt;end
)paren
id|f
op_assign
id|s-&gt;window
suffix:semicolon
id|c-&gt;len
op_decrement
suffix:semicolon
)brace
id|c-&gt;mode
op_assign
id|START
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LIT
suffix:colon
multiline_comment|/* o: got literal, waiting for output space */
id|NEEDOUT
id|OUTBYTE
c_func
(paren
id|c-&gt;sub.lit
)paren
id|c-&gt;mode
op_assign
id|START
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WASH
suffix:colon
multiline_comment|/* o: got eob, possibly more output */
id|FLUSH
r_if
c_cond
(paren
id|s-&gt;read
op_ne
id|s-&gt;write
)paren
id|LEAVE
id|c-&gt;mode
op_assign
id|END
suffix:semicolon
r_case
id|END
suffix:colon
id|r
op_assign
id|Z_STREAM_END
suffix:semicolon
id|LEAVE
r_case
id|BADCODE
suffix:colon
multiline_comment|/* x: got error */
id|r
op_assign
id|Z_DATA_ERROR
suffix:semicolon
id|LEAVE
r_default
suffix:colon
id|r
op_assign
id|Z_STREAM_ERROR
suffix:semicolon
id|LEAVE
)brace
)brace
DECL|function|inflate_codes_free
id|local
r_void
id|inflate_codes_free
c_func
(paren
id|c
comma
id|z
)paren
id|inflate_codes_statef
op_star
id|c
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|ZFREE
c_func
(paren
id|z
comma
id|c
comma
r_sizeof
(paren
r_struct
id|inflate_codes_state
)paren
)paren
suffix:semicolon
id|Tracev
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:       codes free&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*+++++*/
multiline_comment|/* inflate_util.c -- data and routines common to blocks and codes&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* copy as much as possible from the sliding window to the output area */
DECL|function|inflate_flush
id|local
r_int
id|inflate_flush
c_func
(paren
id|s
comma
id|z
comma
id|r
)paren
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
r_int
id|r
suffix:semicolon
(brace
id|uInt
id|n
suffix:semicolon
id|Bytef
op_star
id|p
comma
op_star
id|q
suffix:semicolon
multiline_comment|/* local copies of source and destination pointers */
id|p
op_assign
id|z-&gt;next_out
suffix:semicolon
id|q
op_assign
id|s-&gt;read
suffix:semicolon
multiline_comment|/* compute number of bytes to copy as far as end of window */
id|n
op_assign
(paren
id|uInt
)paren
(paren
(paren
id|q
op_le
id|s-&gt;write
ques
c_cond
id|s-&gt;write
suffix:colon
id|s-&gt;end
)paren
op_minus
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|z-&gt;avail_out
)paren
id|n
op_assign
id|z-&gt;avail_out
suffix:semicolon
r_if
c_cond
(paren
id|n
op_logical_and
id|r
op_eq
id|Z_BUF_ERROR
)paren
id|r
op_assign
id|Z_OK
suffix:semicolon
multiline_comment|/* update counters */
id|z-&gt;avail_out
op_sub_assign
id|n
suffix:semicolon
id|z-&gt;total_out
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* update check information */
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
id|s-&gt;check
comma
id|q
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* copy as far as end of window */
id|zmemcpy
c_func
(paren
id|p
comma
id|q
comma
id|n
)paren
suffix:semicolon
id|p
op_add_assign
id|n
suffix:semicolon
id|q
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* see if more to copy at beginning of window */
r_if
c_cond
(paren
id|q
op_eq
id|s-&gt;end
)paren
(brace
multiline_comment|/* wrap pointers */
id|q
op_assign
id|s-&gt;window
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;write
op_eq
id|s-&gt;end
)paren
id|s-&gt;write
op_assign
id|s-&gt;window
suffix:semicolon
multiline_comment|/* compute bytes to copy */
id|n
op_assign
(paren
id|uInt
)paren
(paren
id|s-&gt;write
op_minus
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|z-&gt;avail_out
)paren
id|n
op_assign
id|z-&gt;avail_out
suffix:semicolon
r_if
c_cond
(paren
id|n
op_logical_and
id|r
op_eq
id|Z_BUF_ERROR
)paren
id|r
op_assign
id|Z_OK
suffix:semicolon
multiline_comment|/* update counters */
id|z-&gt;avail_out
op_sub_assign
id|n
suffix:semicolon
id|z-&gt;total_out
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* update check information */
r_if
c_cond
(paren
id|s-&gt;checkfn
op_ne
id|Z_NULL
)paren
id|s-&gt;check
op_assign
(paren
op_star
id|s-&gt;checkfn
)paren
(paren
id|s-&gt;check
comma
id|q
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* copy */
id|zmemcpy
c_func
(paren
id|p
comma
id|q
comma
id|n
)paren
suffix:semicolon
id|p
op_add_assign
id|n
suffix:semicolon
id|q
op_add_assign
id|n
suffix:semicolon
)brace
multiline_comment|/* update pointers */
id|z-&gt;next_out
op_assign
id|p
suffix:semicolon
id|s-&gt;read
op_assign
id|q
suffix:semicolon
multiline_comment|/* done */
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*+++++*/
multiline_comment|/* inffast.c -- process literals and length/distance pairs fast&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* simplify the use of the inflate_huft type with some defines */
DECL|macro|base
mdefine_line|#define base more.Base
DECL|macro|next
mdefine_line|#define next more.Next
DECL|macro|exop
mdefine_line|#define exop word.what.Exop
DECL|macro|bits
mdefine_line|#define bits word.what.Bits
multiline_comment|/* macros for bit input with no checking and for returning unused bytes */
DECL|macro|GRABBITS
mdefine_line|#define GRABBITS(j) {while(k&lt;(j)){b|=((uLong)NEXTBYTE)&lt;&lt;k;k+=8;}}
DECL|macro|UNGRAB
mdefine_line|#define UNGRAB {n+=(c=k&gt;&gt;3);p-=c;k&amp;=7;}
multiline_comment|/* Called with number of bytes left to write in window at least 258&n;   (the maximum string length) and number of input bytes available&n;   at least ten.  The ten bytes are six bytes for the longest length/&n;   distance pair plus four bytes for overloading the bit buffer. */
DECL|function|inflate_fast
id|local
r_int
id|inflate_fast
c_func
(paren
id|bl
comma
id|bd
comma
id|tl
comma
id|td
comma
id|s
comma
id|z
)paren
id|uInt
id|bl
comma
id|bd
suffix:semicolon
id|inflate_huft
op_star
id|tl
comma
op_star
id|td
suffix:semicolon
id|inflate_blocks_statef
op_star
id|s
suffix:semicolon
id|z_stream
op_star
id|z
suffix:semicolon
(brace
id|inflate_huft
op_star
id|t
suffix:semicolon
multiline_comment|/* temporary pointer */
id|uInt
id|e
suffix:semicolon
multiline_comment|/* extra bits or operation */
id|uLong
id|b
suffix:semicolon
multiline_comment|/* bit buffer */
id|uInt
id|k
suffix:semicolon
multiline_comment|/* bits in bit buffer */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* input data pointer */
id|uInt
id|n
suffix:semicolon
multiline_comment|/* bytes available there */
id|Bytef
op_star
id|q
suffix:semicolon
multiline_comment|/* output window write pointer */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* bytes to end of window or read pointer */
id|uInt
id|ml
suffix:semicolon
multiline_comment|/* mask for literal/length tree */
id|uInt
id|md
suffix:semicolon
multiline_comment|/* mask for distance tree */
id|uInt
id|c
suffix:semicolon
multiline_comment|/* bytes to copy */
id|uInt
id|d
suffix:semicolon
multiline_comment|/* distance back to copy from */
id|Bytef
op_star
id|r
suffix:semicolon
multiline_comment|/* copy source pointer */
multiline_comment|/* load input, output, bit values */
id|LOAD
multiline_comment|/* initialize masks */
id|ml
op_assign
id|inflate_mask
(braket
id|bl
)braket
suffix:semicolon
id|md
op_assign
id|inflate_mask
(braket
id|bd
)braket
suffix:semicolon
multiline_comment|/* do until not enough input or output space for fast loop */
r_do
(brace
multiline_comment|/* assume called with m &gt;= 258 &amp;&amp; n &gt;= 10 */
multiline_comment|/* get literal/length code */
id|GRABBITS
c_func
(paren
l_int|20
)paren
multiline_comment|/* max bits for literal/length code */
r_if
c_cond
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|tl
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|ml
)paren
)paren
op_member_access_from_pointer
id|exop
)paren
op_eq
l_int|0
)paren
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
id|t-&gt;base
op_ge
l_int|0x20
op_logical_and
id|t-&gt;base
OL
l_int|0x7f
ques
c_cond
l_string|&quot;inflate:         * literal &squot;%c&squot;&bslash;n&quot;
suffix:colon
l_string|&quot;inflate:         * literal 0x%02x&bslash;n&quot;
comma
id|t-&gt;base
)paren
)paren
suffix:semicolon
op_star
id|q
op_increment
op_assign
(paren
id|Byte
)paren
id|t-&gt;base
suffix:semicolon
id|m
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_do
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
(brace
multiline_comment|/* get extra bits for length */
id|e
op_and_assign
l_int|15
suffix:semicolon
id|c
op_assign
id|t-&gt;base
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|e
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         * length %u&bslash;n&quot;
comma
id|c
)paren
)paren
suffix:semicolon
multiline_comment|/* decode distance base of block to copy */
id|GRABBITS
c_func
(paren
l_int|15
)paren
suffix:semicolon
multiline_comment|/* max bits for distance code */
id|e
op_assign
(paren
id|t
op_assign
id|td
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|md
)paren
)paren
op_member_access_from_pointer
id|exop
suffix:semicolon
r_do
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
r_if
c_cond
(paren
id|e
op_amp
l_int|16
)paren
(brace
multiline_comment|/* get extra bits to add to distance base */
id|e
op_and_assign
l_int|15
suffix:semicolon
id|GRABBITS
c_func
(paren
id|e
)paren
multiline_comment|/* get extra bits (up to 13) */
id|d
op_assign
id|t-&gt;base
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
suffix:semicolon
id|DUMPBITS
c_func
(paren
id|e
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         * distance %u&bslash;n&quot;
comma
id|d
)paren
)paren
suffix:semicolon
multiline_comment|/* do the copy */
id|m
op_sub_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uInt
)paren
(paren
id|q
op_minus
id|s-&gt;window
)paren
op_ge
id|d
)paren
multiline_comment|/* offset before dest */
(brace
multiline_comment|/*  just copy */
id|r
op_assign
id|q
op_minus
id|d
suffix:semicolon
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
id|c
op_decrement
suffix:semicolon
multiline_comment|/* minimum count is three, */
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
id|c
op_decrement
suffix:semicolon
multiline_comment|/*  so unroll loop a little */
)brace
r_else
multiline_comment|/* else offset after destination */
(brace
id|e
op_assign
id|d
op_minus
(paren
id|q
op_minus
id|s-&gt;window
)paren
suffix:semicolon
multiline_comment|/* bytes from offset to end */
id|r
op_assign
id|s-&gt;end
op_minus
id|e
suffix:semicolon
multiline_comment|/* pointer to offset */
r_if
c_cond
(paren
id|c
OG
id|e
)paren
multiline_comment|/* if source crosses, */
(brace
id|c
op_sub_assign
id|e
suffix:semicolon
multiline_comment|/* copy to end of window */
r_do
(brace
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|e
)paren
suffix:semicolon
id|r
op_assign
id|s-&gt;window
suffix:semicolon
multiline_comment|/* copy rest from start of window */
)brace
)brace
r_do
(brace
multiline_comment|/* copy all or what&squot;s left */
op_star
id|q
op_increment
op_assign
op_star
id|r
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
id|e
op_assign
(paren
id|t
op_assign
id|t-&gt;next
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
)paren
op_member_access_from_pointer
id|exop
suffix:semicolon
r_else
(brace
id|z-&gt;msg
op_assign
l_string|&quot;invalid distance code&quot;
suffix:semicolon
id|UNGRAB
id|UPDATE
r_return
id|Z_DATA_ERROR
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|e
op_amp
l_int|64
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|e
op_assign
(paren
id|t
op_assign
id|t-&gt;next
op_plus
(paren
(paren
id|uInt
)paren
id|b
op_amp
id|inflate_mask
(braket
id|e
)braket
)paren
)paren
op_member_access_from_pointer
id|exop
)paren
op_eq
l_int|0
)paren
(brace
id|DUMPBITS
c_func
(paren
id|t-&gt;bits
)paren
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
id|t-&gt;base
op_ge
l_int|0x20
op_logical_and
id|t-&gt;base
OL
l_int|0x7f
ques
c_cond
l_string|&quot;inflate:         * literal &squot;%c&squot;&bslash;n&quot;
suffix:colon
l_string|&quot;inflate:         * literal 0x%02x&bslash;n&quot;
comma
id|t-&gt;base
)paren
)paren
suffix:semicolon
op_star
id|q
op_increment
op_assign
(paren
id|Byte
)paren
id|t-&gt;base
suffix:semicolon
id|m
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|e
op_amp
l_int|32
)paren
(brace
id|Tracevv
c_func
(paren
(paren
id|stderr
comma
l_string|&quot;inflate:         * end of block&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|UNGRAB
id|UPDATE
r_return
id|Z_STREAM_END
suffix:semicolon
)brace
r_else
(brace
id|z-&gt;msg
op_assign
l_string|&quot;invalid literal/length code&quot;
suffix:semicolon
id|UNGRAB
id|UPDATE
r_return
id|Z_DATA_ERROR
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|m
op_ge
l_int|258
op_logical_and
id|n
op_ge
l_int|10
)paren
suffix:semicolon
multiline_comment|/* not enough input or output--restore pointers and return */
id|UNGRAB
id|UPDATE
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/*+++++*/
multiline_comment|/* zutil.c -- target dependent utility functions for the compression library&n; * Copyright (C) 1995 Jean-loup Gailly.&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */
DECL|variable|zlib_version
r_char
op_star
id|zlib_version
op_assign
id|ZLIB_VERSION
suffix:semicolon
DECL|variable|z_errmsg
r_char
op_star
id|z_errmsg
(braket
)braket
op_assign
(brace
l_string|&quot;stream end&quot;
comma
multiline_comment|/* Z_STREAM_END    1 */
l_string|&quot;&quot;
comma
multiline_comment|/* Z_OK            0 */
l_string|&quot;file error&quot;
comma
multiline_comment|/* Z_ERRNO        (-1) */
l_string|&quot;stream error&quot;
comma
multiline_comment|/* Z_STREAM_ERROR (-2) */
l_string|&quot;data error&quot;
comma
multiline_comment|/* Z_DATA_ERROR   (-3) */
l_string|&quot;insufficient memory&quot;
comma
multiline_comment|/* Z_MEM_ERROR    (-4) */
l_string|&quot;buffer error&quot;
comma
multiline_comment|/* Z_BUF_ERROR    (-5) */
l_string|&quot;&quot;
)brace
suffix:semicolon
multiline_comment|/*+++++*/
multiline_comment|/* adler32.c -- compute the Adler-32 checksum of a data stream&n; * Copyright (C) 1995 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
multiline_comment|/* From: adler32.c,v 1.6 1995/05/03 17:27:08 jloup Exp */
DECL|macro|BASE
mdefine_line|#define BASE 65521L /* largest prime smaller than 65536 */
DECL|macro|NMAX
mdefine_line|#define NMAX 5552
multiline_comment|/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) &lt;= 2^32-1 */
DECL|macro|DO1
mdefine_line|#define DO1(buf)  {s1 += *buf++; s2 += s1;}
DECL|macro|DO2
mdefine_line|#define DO2(buf)  DO1(buf); DO1(buf);
DECL|macro|DO4
mdefine_line|#define DO4(buf)  DO2(buf); DO2(buf);
DECL|macro|DO8
mdefine_line|#define DO8(buf)  DO4(buf); DO4(buf);
DECL|macro|DO16
mdefine_line|#define DO16(buf) DO8(buf); DO8(buf);
multiline_comment|/* ========================================================================= */
DECL|function|adler32
id|uLong
id|adler32
c_func
(paren
id|adler
comma
id|buf
comma
id|len
)paren
id|uLong
id|adler
suffix:semicolon
id|Bytef
op_star
id|buf
suffix:semicolon
id|uInt
id|len
suffix:semicolon
(brace
r_int
r_int
id|s1
op_assign
id|adler
op_amp
l_int|0xffff
suffix:semicolon
r_int
r_int
id|s2
op_assign
(paren
id|adler
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
id|Z_NULL
)paren
r_return
l_int|1L
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|k
op_assign
id|len
OL
id|NMAX
ques
c_cond
id|len
suffix:colon
id|NMAX
suffix:semicolon
id|len
op_sub_assign
id|k
suffix:semicolon
r_while
c_loop
(paren
id|k
op_ge
l_int|16
)paren
(brace
id|DO16
c_func
(paren
id|buf
)paren
suffix:semicolon
id|k
op_sub_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_ne
l_int|0
)paren
r_do
(brace
id|DO1
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|k
)paren
suffix:semicolon
id|s1
op_mod_assign
id|BASE
suffix:semicolon
id|s2
op_mod_assign
id|BASE
suffix:semicolon
)brace
r_return
(paren
id|s2
op_lshift
l_int|16
)paren
op_or
id|s1
suffix:semicolon
)brace
eof
