multiline_comment|/* Stand alone funtions for QSpan Tundra support.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/mpc8xx.h&gt;
multiline_comment|/* To map PCI devices, you first write 0xffffffff into the device&n; * base address registers.  When the register is read back, the&n; * number of most significant &squot;1&squot; bits describes the amount of address&n; * space needed for mapping.  If the most significant bit is not set,&n; * either the device does not use that address register, or it has&n; * a fixed address that we can&squot;t change.  After the address is assigned,&n; * the command register has to be written to enable the card.&n; */
r_typedef
r_struct
(brace
DECL|member|pci_bus
id|u_char
id|pci_bus
suffix:semicolon
DECL|member|pci_devfn
id|u_char
id|pci_devfn
suffix:semicolon
DECL|member|pci_command
id|ushort
id|pci_command
suffix:semicolon
DECL|member|pci_addrs
id|uint
id|pci_addrs
(braket
l_int|6
)braket
suffix:semicolon
DECL|typedef|pci_map_t
)brace
id|pci_map_t
suffix:semicolon
multiline_comment|/* We should probably dynamically allocate these structures.&n;*/
DECL|macro|MAX_PCI_DEVS
mdefine_line|#define MAX_PCI_DEVS&t;32
DECL|variable|pci_dev_cnt
r_int
id|pci_dev_cnt
suffix:semicolon
DECL|variable|pci_map
id|pci_map_t
id|pci_map
(braket
id|MAX_PCI_DEVS
)braket
suffix:semicolon
r_void
id|pci_conf_write
c_func
(paren
r_int
id|bus
comma
r_int
id|device
comma
r_int
id|func
comma
r_int
id|reg
comma
id|uint
id|writeval
)paren
suffix:semicolon
r_void
id|pci_conf_read
c_func
(paren
r_int
id|bus
comma
r_int
id|device
comma
r_int
id|func
comma
r_int
id|reg
comma
r_void
op_star
id|readval
)paren
suffix:semicolon
r_void
id|probe_addresses
c_func
(paren
r_int
id|bus
comma
r_int
id|devfn
)paren
suffix:semicolon
r_void
id|map_pci_addrs
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* This is a really stripped version of PCI bus scan.  All we are&n; * looking for are devices that exist.&n; */
DECL|function|pci_scanner
id|pci_scanner
c_func
(paren
r_int
id|addr_probe
)paren
(brace
r_int
r_int
id|devfn
comma
id|l
comma
id|max
comma
r_class
comma
id|bus_number
suffix:semicolon
r_int
r_char
id|cmd
comma
id|irq
comma
id|tmp
comma
id|hdr_type
comma
id|is_multi
suffix:semicolon
r_int
id|reg
suffix:semicolon
id|is_multi
op_assign
l_int|0
suffix:semicolon
id|bus_number
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|devfn
op_assign
l_int|0
suffix:semicolon
id|devfn
OL
l_int|0xff
suffix:semicolon
op_increment
id|devfn
)paren
(brace
multiline_comment|/* The device numbers are comprised of upper 5 bits of&n;&t;&t; * device number and lower 3 bits of multi-function number.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|devfn
op_amp
l_int|7
)paren
op_logical_and
op_logical_neg
id|is_multi
)paren
(brace
multiline_comment|/* Don&squot;t scan multifunction addresses if this is&n;&t;&t;&t; * not a multifunction device.&n;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Read the header to determine card type.&n;&t;&t;*/
id|qs_pci_read_config_byte
c_func
(paren
id|bus_number
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|hdr_type
)paren
suffix:semicolon
multiline_comment|/* If this is a base device number, check the header to&n;&t;&t; * determine if it is mulifunction.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|devfn
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
id|is_multi
op_assign
id|hdr_type
op_amp
l_int|0x80
suffix:semicolon
multiline_comment|/* Check to see if the board is really in the slot.&n;&t;&t;*/
id|qs_pci_read_config_dword
c_func
(paren
id|bus_number
comma
id|devfn
comma
id|PCI_VENDOR_ID
comma
op_amp
id|l
)paren
suffix:semicolon
multiline_comment|/* some broken boards return 0 if a slot is empty: */
r_if
c_cond
(paren
id|l
op_eq
l_int|0xffffffff
op_logical_or
id|l
op_eq
l_int|0x00000000
op_logical_or
id|l
op_eq
l_int|0x0000ffff
op_logical_or
id|l
op_eq
l_int|0xffff0000
)paren
(brace
multiline_comment|/* Nothing there.&n;&t;&t;&t;*/
id|is_multi
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If we are not performing an address probe,&n;&t;&t; * just simply print out some information.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|addr_probe
)paren
(brace
id|qs_pci_read_config_dword
c_func
(paren
id|bus_number
comma
id|devfn
comma
id|PCI_CLASS_REVISION
comma
op_amp
r_class
)paren
suffix:semicolon
r_class
op_rshift_assign
l_int|8
suffix:semicolon
multiline_comment|/* upper 3 bytes */
macro_line|#if 0
id|printf
c_func
(paren
l_string|&quot;Found (%3d:%d): vendor 0x%04x, device 0x%04x, class 0x%06x&bslash;n&quot;
comma
(paren
id|devfn
op_rshift
l_int|3
)paren
comma
(paren
id|devfn
op_amp
l_int|7
)paren
comma
(paren
id|l
op_amp
l_int|0xffff
)paren
comma
(paren
id|l
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
comma
r_class
)paren
suffix:semicolon
macro_line|#else
id|puts
c_func
(paren
l_string|&quot;Found (&quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|devfn
op_rshift
l_int|3
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|devfn
op_amp
l_int|7
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;): vendor &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|l
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;, device &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
id|l
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;, class &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
r_class
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* If this is a &quot;normal&quot; device, build address list.&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|hdr_type
op_amp
l_int|0x7f
)paren
op_eq
id|PCI_HEADER_TYPE_NORMAL
)paren
id|probe_addresses
c_func
(paren
id|bus_number
comma
id|devfn
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now map the boards.&n;&t;*/
r_if
c_cond
(paren
id|addr_probe
)paren
id|map_pci_addrs
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Probe addresses for the specified device.  This is a destructive&n; * operation because it writes the registers.&n; */
r_void
DECL|function|probe_addresses
id|probe_addresses
c_func
(paren
id|bus
comma
id|devfn
)paren
(brace
r_int
id|i
suffix:semicolon
id|uint
id|pciaddr
suffix:semicolon
id|ushort
id|pcicmd
suffix:semicolon
id|pci_map_t
op_star
id|pm
suffix:semicolon
r_if
c_cond
(paren
id|pci_dev_cnt
op_ge
id|MAX_PCI_DEVS
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Too many PCI devices&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pm
op_assign
op_amp
id|pci_map
(braket
id|pci_dev_cnt
op_increment
)braket
suffix:semicolon
id|pm-&gt;pci_bus
op_assign
id|bus
suffix:semicolon
id|pm-&gt;pci_devfn
op_assign
id|devfn
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|qs_pci_write_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|i
op_star
l_int|4
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|qs_pci_read_config_dword
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|i
op_star
l_int|4
)paren
comma
op_amp
id|pciaddr
)paren
suffix:semicolon
id|pm-&gt;pci_addrs
(braket
id|i
)braket
op_assign
id|pciaddr
suffix:semicolon
id|qs_pci_read_config_word
c_func
(paren
id|bus
comma
id|devfn
comma
id|PCI_COMMAND
comma
op_amp
id|pcicmd
)paren
suffix:semicolon
id|pm-&gt;pci_command
op_assign
id|pcicmd
suffix:semicolon
)brace
)brace
multiline_comment|/* Map the cards into the PCI space.  The PCI has separate memory&n; * and I/O spaces.  In addition, some memory devices require mapping&n; * below 1M.  The least significant 4 bits of the address register&n; * provide information.  If this is an I/O device, only the LS bit&n; * is used to indicate that, so I/O devices can be mapped to a two byte&n; * boundard.  Memory addresses can be mapped to a 32 byte boundary.&n; * The QSpan implementations usually have a 1Gbyte space for each&n; * memory and I/O spaces.&n; *&n; * This isn&squot;t a terribly fancy algorithm.  I just map the spaces from&n; * the top starting with the largest address space.  When finished,&n; * the registers are written and the card enabled.&n; *&n; * While the Tundra can map a large address space on most boards, we&n; * need to be careful because it may overlap other devices (like IMMR).&n; */
DECL|macro|MEMORY_SPACE_SIZE
mdefine_line|#define MEMORY_SPACE_SIZE&t;0x20000000
DECL|macro|IO_SPACE_SIZE
mdefine_line|#define IO_SPACE_SIZE&t;&t;0x20000000
r_void
DECL|function|map_pci_addrs
id|map_pci_addrs
c_func
(paren
)paren
(brace
id|uint
id|pci_mem_top
comma
id|pci_mem_low
suffix:semicolon
id|uint
id|pci_io_top
suffix:semicolon
id|uint
id|addr_mask
comma
id|reg_addr
comma
id|space
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|pci_map_t
op_star
id|pm
suffix:semicolon
id|pci_mem_top
op_assign
id|MEMORY_SPACE_SIZE
suffix:semicolon
id|pci_io_top
op_assign
id|IO_SPACE_SIZE
suffix:semicolon
id|pci_mem_low
op_assign
(paren
l_int|1
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* Below one meg addresses */
multiline_comment|/* We can&squot;t map anything more than the maximum space, but test&n;&t; * for it anyway to catch devices out of range.&n;&t; */
id|addr_mask
op_assign
l_int|0x80000000
suffix:semicolon
r_do
(brace
id|space
op_assign
(paren
op_complement
id|addr_mask
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Size of the space */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pci_dev_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pm
op_assign
op_amp
id|pci_map
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* If the MS bit is not set, this has either&n;&t;&t;&t;&t; * already been mapped, or is not used.&n;&t;&t;&t;&t; */
id|reg_addr
op_assign
id|pm-&gt;pci_addrs
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg_addr
op_amp
l_int|0x80000000
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|reg_addr
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
(brace
r_if
c_cond
(paren
(paren
id|reg_addr
op_amp
id|PCI_BASE_ADDRESS_IO_MASK
)paren
op_ne
id|addr_mask
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pci_io_top
OL
id|space
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Out of PCI I/O space&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_io_top
op_sub_assign
id|space
suffix:semicolon
id|pm-&gt;pci_addrs
(braket
id|j
)braket
op_assign
id|pci_io_top
suffix:semicolon
id|pm-&gt;pci_command
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|reg_addr
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
op_ne
id|addr_mask
)paren
r_continue
suffix:semicolon
multiline_comment|/* Memory space.  Test if below 1M.&n;&t;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|reg_addr
op_amp
id|PCI_BASE_ADDRESS_MEM_TYPE_1M
)paren
(brace
r_if
c_cond
(paren
id|pci_mem_low
OL
id|space
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Out of PCI 1M space&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_mem_low
op_sub_assign
id|space
suffix:semicolon
id|pm-&gt;pci_addrs
(braket
id|j
)braket
op_assign
id|pci_mem_low
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|pci_mem_top
OL
id|space
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;Out of PCI Mem space&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_mem_top
op_sub_assign
id|space
suffix:semicolon
id|pm-&gt;pci_addrs
(braket
id|j
)braket
op_assign
id|pci_mem_top
suffix:semicolon
)brace
)brace
id|pm-&gt;pci_command
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
)brace
)brace
id|addr_mask
op_rshift_assign
l_int|1
suffix:semicolon
id|addr_mask
op_or_assign
l_int|0x80000000
suffix:semicolon
)brace
r_while
c_loop
(paren
id|addr_mask
op_ne
l_int|0xfffffffe
)paren
suffix:semicolon
multiline_comment|/* Now, run the list one more time and map everything.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pci_dev_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pm
op_assign
op_amp
id|pci_map
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
(brace
id|qs_pci_write_config_dword
c_func
(paren
id|pm-&gt;pci_bus
comma
id|pm-&gt;pci_devfn
comma
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|j
op_star
l_int|4
)paren
comma
id|pm-&gt;pci_addrs
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable memory or address mapping.&n;&t;&t;*/
id|qs_pci_write_config_word
c_func
(paren
id|pm-&gt;pci_bus
comma
id|pm-&gt;pci_devfn
comma
id|PCI_COMMAND
comma
id|pm-&gt;pci_command
)paren
suffix:semicolon
)brace
)brace
eof
