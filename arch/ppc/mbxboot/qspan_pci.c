multiline_comment|/*&n; * LinuxPPC arch/ppc/kernel/qspan_pci.c   Dan Malek (dmalek@jlc.net)&n; *&n; * QSpan Motorola bus to PCI bridge.  The config address register&n; * is located 0x500 from the base of the bridge control/status registers.&n; * The data register is located at 0x504.&n; * This is a two step operation.  First, the address register is written,&n; * then the data register is read/written as required.&n; * I don&squot;t know what to do about interrupts (yet).&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/mpc8xx.h&gt;
multiline_comment|/*&n; * When reading the configuration space, if something does not respond&n; * the bus times out and we get a machine check interrupt.  So, the&n; * good ol&squot; exception tables come to mind to trap it and return some&n; * value.&n; *&n; * On an error we just return a -1, since that is what the caller wants&n; * returned if nothing is present.  I copied this from __get_user_asm,&n; * with the only difference of returning -1 instead of EFAULT.&n; * There is an associated hack in the machine check trap code.&n; *&n; * The QSPAN is also a big endian device, that is it makes the PCI&n; * look big endian to us.  This presents a problem for the Linux PCI&n; * functions, which assume little endian.  For example, we see the&n; * first 32-bit word like this:&n; *&t;------------------------&n; *&t;| Device ID | Vendor ID |&n; *&t;------------------------&n; * If we read/write as a double word, that&squot;s OK.  But in our world,&n; * when read as a word, device ID is at location 0, not location 2 as&n; * the little endian PCI would believe.  We have to switch bits in&n; * the PCI addresses given to us to get the data to/from the correct&n; * byte lanes.&n; *&n; * The QSPAN only supports 4 bits of &quot;slot&quot; in the dev_fn instead of 5.&n; * It always forces the MS bit to zero.  Therefore, dev_fn values&n; * greater than 128 are returned as &quot;no device found&quot; errors.&n; *&n; * The QSPAN can only perform long word (32-bit) configuration cycles.&n; * The &quot;offset&quot; must have the two LS bits set to zero.  Read operations&n; * require we read the entire word and then sort out what should be&n; * returned.  Write operations other than long word require that we&n; * read the long word, update the proper word or byte, then write the&n; * entire long word back.&n; *&n; * PCI Bridge hack.  We assume (correctly) that bus 0 is the primary&n; * PCI bus from the QSPAN.  If we are called with a bus number other&n; * than zero, we create a Type 1 configuration access that a downstream&n; * PCI bridge will interpret.&n; */
DECL|macro|__get_pci_config
mdefine_line|#define __get_pci_config(x, addr, op)&t;&t;&bslash;&n;&t;__asm__ __volatile__(&t;&t;&t;&t;&bslash;&n;&t;&t;&quot;1:&t;&quot;op&quot; %0,0(%1)&bslash;n&quot;&t;&t;&bslash;&n;&t;&t;&quot;&t;eieio&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;&t;&quot;2:&bslash;n&quot;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&quot;.section .fixup,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;&t;&t;&bslash;&n;&t;&t;&quot;3:&t;li %0,-1&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;&t;&quot;&t;b 2b&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;&t;&t;&bslash;&n;&t;&t;&quot;&t;.align 2&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;&t;&quot;&t;.long 1b,3b&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;&t;&quot;.text&quot;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;: &quot;=r&quot;(x) : &quot;r&quot;(addr))
DECL|macro|QS_CONFIG_ADDR
mdefine_line|#define QS_CONFIG_ADDR&t;((volatile uint *)(PCI_CSR_ADDR + 0x500))
DECL|macro|QS_CONFIG_DATA
mdefine_line|#define QS_CONFIG_DATA&t;((volatile uint *)(PCI_CSR_ADDR + 0x504))
DECL|macro|mk_config_addr
mdefine_line|#define mk_config_addr(bus, dev, offset) &bslash;&n;&t;(((bus)&lt;&lt;16) | ((dev)&lt;&lt;8) | (offset &amp; 0xfc))
DECL|macro|mk_config_type1
mdefine_line|#define mk_config_type1(bus, dev, offset) &bslash;&n;&t;mk_config_addr(bus, dev, offset) | 1;
multiline_comment|/* Initialize the QSpan device registers after power up.&n;*/
DECL|function|qspan_init
id|qspan_init
c_func
(paren
)paren
(brace
id|uint
op_star
id|qptr
suffix:semicolon
id|qptr
op_assign
(paren
id|uint
op_star
)paren
id|PCI_CSR_ADDR
suffix:semicolon
multiline_comment|/* PCI Configuration/status.  Upper bits written to clear&n;&t; * pending interrupt or status.  Lower bits enable QSPAN as&n;&t; * PCI master, enable memory and I/O cycles, and enable PCI&n;&t; * parity error checking.&n;&t; * IMPORTANT:  The last two bits of this word enable PCI&n;&t; * master cycles into the QBus.  The QSpan is broken and can&squot;t&n;&t; * meet the timing specs of the PQ bus for this to work.  Therefore,&n;&t; * if you don&squot;t have external bus arbitration, you can&squot;t use&n;&t; * this function.&n;&t; */
macro_line|#ifdef EXTERNAL_PQ_ARB
id|qptr
(braket
l_int|1
)braket
op_assign
l_int|0xf9000147
suffix:semicolon
macro_line|#else
id|qptr
(braket
l_int|1
)braket
op_assign
l_int|0xf9000144
suffix:semicolon
macro_line|#endif
multiline_comment|/* PCI Misc configuration.  Set PCI latency timer resolution&n;&t; * of 8 cycles, set cache size to 4 x 32.&n;&t; */
id|qptr
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set up PCI Target address mapping.  Enable, Posted writes,&n;&t; * 2Gbyte space (processor memory controller determines actual size).&n;&t; */
id|qptr
(braket
l_int|64
)braket
op_assign
l_int|0x8f000080
suffix:semicolon
multiline_comment|/* Map processor 0x80000000 to PCI 0x00000000.&n;&t; * Processor address bit 1 determines I/O type access (0x80000000)&n;&t; * or memory type access (0xc0000000).&n;&t; */
id|qptr
(braket
l_int|65
)braket
op_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* Enable error logging and clear any pending error status.&n;&t;*/
id|qptr
(braket
l_int|80
)braket
op_assign
l_int|0x90000000
suffix:semicolon
id|qptr
(braket
l_int|512
)braket
op_assign
l_int|0x000c0003
suffix:semicolon
multiline_comment|/* Set up Qbus slave image.&n;&t;*/
id|qptr
(braket
l_int|960
)braket
op_assign
l_int|0x01000000
suffix:semicolon
id|qptr
(braket
l_int|961
)braket
op_assign
l_int|0x000000d1
suffix:semicolon
id|qptr
(braket
l_int|964
)braket
op_assign
l_int|0x00000000
suffix:semicolon
id|qptr
(braket
l_int|965
)braket
op_assign
l_int|0x000000d1
suffix:semicolon
)brace
multiline_comment|/* Functions to support PCI bios-like features to read/write configuration&n; * space.  If the function fails for any reason, a -1 (0xffffffff) value&n; * must be returned.&n; */
DECL|macro|DEVICE_NOT_FOUND
mdefine_line|#define DEVICE_NOT_FOUND&t;(-1)
DECL|macro|SUCCESSFUL
mdefine_line|#define SUCCESSFUL&t;&t;0
DECL|function|qs_pci_read_config_byte
r_int
id|qs_pci_read_config_byte
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_char
id|offset
comma
r_int
r_char
op_star
id|val
)paren
(brace
id|uint
id|temp
suffix:semicolon
id|u_char
op_star
id|cp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
OG
l_int|7
)paren
op_logical_or
(paren
id|dev_fn
OG
l_int|127
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xff
suffix:semicolon
r_return
id|DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_addr
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
r_else
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_type1
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
id|__get_pci_config
c_func
(paren
id|temp
comma
id|QS_CONFIG_DATA
comma
l_string|&quot;lwz&quot;
)paren
suffix:semicolon
id|offset
op_xor_assign
l_int|0x03
suffix:semicolon
id|cp
op_assign
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|temp
)paren
op_plus
(paren
id|offset
op_amp
l_int|0x03
)paren
suffix:semicolon
op_star
id|val
op_assign
op_star
id|cp
suffix:semicolon
r_return
id|SUCCESSFUL
suffix:semicolon
)brace
DECL|function|qs_pci_read_config_word
r_int
id|qs_pci_read_config_word
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_char
id|offset
comma
r_int
r_int
op_star
id|val
)paren
(brace
id|uint
id|temp
suffix:semicolon
id|ushort
op_star
id|sp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
OG
l_int|7
)paren
op_logical_or
(paren
id|dev_fn
OG
l_int|127
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xffff
suffix:semicolon
r_return
id|DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_addr
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
r_else
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_type1
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
id|__get_pci_config
c_func
(paren
id|temp
comma
id|QS_CONFIG_DATA
comma
l_string|&quot;lwz&quot;
)paren
suffix:semicolon
id|offset
op_xor_assign
l_int|0x02
suffix:semicolon
id|sp
op_assign
(paren
(paren
id|ushort
op_star
)paren
op_amp
id|temp
)paren
op_plus
(paren
(paren
id|offset
op_rshift
l_int|1
)paren
op_amp
l_int|1
)paren
suffix:semicolon
op_star
id|val
op_assign
op_star
id|sp
suffix:semicolon
r_return
id|SUCCESSFUL
suffix:semicolon
)brace
DECL|function|qs_pci_read_config_dword
r_int
id|qs_pci_read_config_dword
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_char
id|offset
comma
r_int
r_int
op_star
id|val
)paren
(brace
r_if
c_cond
(paren
(paren
id|bus
OG
l_int|7
)paren
op_logical_or
(paren
id|dev_fn
OG
l_int|127
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xffffffff
suffix:semicolon
r_return
id|DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_addr
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
r_else
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_type1
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
id|__get_pci_config
c_func
(paren
op_star
id|val
comma
id|QS_CONFIG_DATA
comma
l_string|&quot;lwz&quot;
)paren
suffix:semicolon
r_return
id|SUCCESSFUL
suffix:semicolon
)brace
DECL|function|qs_pci_write_config_byte
r_int
id|qs_pci_write_config_byte
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_char
id|offset
comma
r_int
r_char
id|val
)paren
(brace
id|uint
id|temp
suffix:semicolon
id|u_char
op_star
id|cp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
OG
l_int|7
)paren
op_logical_or
(paren
id|dev_fn
OG
l_int|127
)paren
)paren
r_return
id|DEVICE_NOT_FOUND
suffix:semicolon
id|qs_pci_read_config_dword
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
comma
op_amp
id|temp
)paren
suffix:semicolon
id|offset
op_xor_assign
l_int|0x03
suffix:semicolon
id|cp
op_assign
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|temp
)paren
op_plus
(paren
id|offset
op_amp
l_int|0x03
)paren
suffix:semicolon
op_star
id|cp
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_addr
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
r_else
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_type1
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
op_star
id|QS_CONFIG_DATA
op_assign
id|temp
suffix:semicolon
r_return
id|SUCCESSFUL
suffix:semicolon
)brace
DECL|function|qs_pci_write_config_word
r_int
id|qs_pci_write_config_word
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_char
id|offset
comma
r_int
r_int
id|val
)paren
(brace
id|uint
id|temp
suffix:semicolon
id|ushort
op_star
id|sp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
OG
l_int|7
)paren
op_logical_or
(paren
id|dev_fn
OG
l_int|127
)paren
)paren
r_return
id|DEVICE_NOT_FOUND
suffix:semicolon
id|qs_pci_read_config_dword
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
comma
op_amp
id|temp
)paren
suffix:semicolon
id|offset
op_xor_assign
l_int|0x02
suffix:semicolon
id|sp
op_assign
(paren
(paren
id|ushort
op_star
)paren
op_amp
id|temp
)paren
op_plus
(paren
(paren
id|offset
op_rshift
l_int|1
)paren
op_amp
l_int|1
)paren
suffix:semicolon
op_star
id|sp
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_addr
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
r_else
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_type1
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
op_star
id|QS_CONFIG_DATA
op_assign
id|temp
suffix:semicolon
r_return
id|SUCCESSFUL
suffix:semicolon
)brace
DECL|function|qs_pci_write_config_dword
r_int
id|qs_pci_write_config_dword
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_char
id|offset
comma
r_int
r_int
id|val
)paren
(brace
r_if
c_cond
(paren
(paren
id|bus
OG
l_int|7
)paren
op_logical_or
(paren
id|dev_fn
OG
l_int|127
)paren
)paren
r_return
id|DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_addr
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
r_else
op_star
id|QS_CONFIG_ADDR
op_assign
id|mk_config_type1
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|offset
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|QS_CONFIG_DATA
op_assign
id|val
suffix:semicolon
r_return
id|SUCCESSFUL
suffix:semicolon
)brace
eof
