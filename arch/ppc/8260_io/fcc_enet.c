multiline_comment|/*&n; * Fast Ethernet Controller (FCC) driver for Motorola MPC8260.&n; * Copyright (c) 2000 MontaVista Software, Inc.   Dan Malek (dmalek@jlc.net)&n; *&n; * This version of the driver is a combination of the 8xx fec and&n; * 8260 SCC Ethernet drivers.  People seem to be choosing common I/O&n; * configurations, so this driver will work on the EST8260 boards and&n; * others yet to be announced.&n; *&n; * Right now, I am very watseful with the buffers.  I allocate memory&n; * pages and then divide them into 2K frame buffers.  This way I know I&n; * have buffers large enough to hold one frame within one buffer descriptor.&n; * Once I get this working, I will use 64 or 128 byte CPM buffers, which&n; * will be much more memory efficient and will easily handle lots of&n; * small packets.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/immap_8260.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mpc8260.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/cpm_8260.h&gt;
multiline_comment|/* The transmitter timeout&n; */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT&t;(2*HZ)
multiline_comment|/* The number of Tx and Rx buffers.  These are allocated from the page&n; * pool.  The code may assume these are power of two, so it it best&n; * to keep them that size.&n; * We don&squot;t need to allocate pages for the transmitter.  We just use&n; * the skbuffer directly.&n; */
DECL|macro|FCC_ENET_RX_PAGES
mdefine_line|#define FCC_ENET_RX_PAGES&t;16
DECL|macro|FCC_ENET_RX_FRSIZE
mdefine_line|#define FCC_ENET_RX_FRSIZE&t;2048
DECL|macro|FCC_ENET_RX_FRPPG
mdefine_line|#define FCC_ENET_RX_FRPPG&t;(PAGE_SIZE / FCC_ENET_RX_FRSIZE)
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;&t;(FCC_ENET_RX_FRPPG * FCC_ENET_RX_PAGES)
DECL|macro|TX_RING_SIZE
mdefine_line|#define TX_RING_SIZE&t;&t;16&t;/* Must be power of two */
DECL|macro|TX_RING_MOD_MASK
mdefine_line|#define TX_RING_MOD_MASK&t;15&t;/*   for this to work */
multiline_comment|/* The FCC stores dest/src/type, data, and checksum for receive packets.&n; */
DECL|macro|PKT_MAXBUF_SIZE
mdefine_line|#define PKT_MAXBUF_SIZE&t;&t;1518
DECL|macro|PKT_MINBUF_SIZE
mdefine_line|#define PKT_MINBUF_SIZE&t;&t;64
multiline_comment|/* Maximum input DMA size.  Must be a should(?) be a multiple of 4.&n;*/
DECL|macro|PKT_MAXDMA_SIZE
mdefine_line|#define PKT_MAXDMA_SIZE&t;&t;1520
multiline_comment|/* Maximum input buffer size.  Must be a multiple of 32.&n;*/
DECL|macro|PKT_MAXBLR_SIZE
mdefine_line|#define PKT_MAXBLR_SIZE&t;&t;1536
r_static
r_int
id|fcc_enet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|fcc_enet_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|fcc_enet_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|fcc_enet_mii
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|fcc_enet_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|fcc_enet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|fcc_enet_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|restart_fcc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* These will be configurable for the FCC choice.&n; * Multiple ports can be configured.  There is little choice among the&n; * I/O pins to the PHY, except the clocks.  We will need some board&n; * dependent clock selection.&n; * Why in the hell did I put these inside #ifdef&squot;s?  I dunno, maybe to&n; * help show what pins are used for each device.&n; */
multiline_comment|/* I/O Pin assignment for FCC1.  I don&squot;t yet know the best way to do this,&n; * but there is little variation among the choices.&n; */
DECL|macro|PA1_COL
mdefine_line|#define PA1_COL&t;&t;((uint)0x00000001)
DECL|macro|PA1_CRS
mdefine_line|#define PA1_CRS&t;&t;((uint)0x00000002)
DECL|macro|PA1_TXER
mdefine_line|#define PA1_TXER&t;((uint)0x00000004)
DECL|macro|PA1_TXEN
mdefine_line|#define PA1_TXEN&t;((uint)0x00000008)
DECL|macro|PA1_RXDV
mdefine_line|#define PA1_RXDV&t;((uint)0x00000010)
DECL|macro|PA1_RXER
mdefine_line|#define PA1_RXER&t;((uint)0x00000020)
DECL|macro|PA1_TXDAT
mdefine_line|#define PA1_TXDAT&t;((uint)0x00003c00)
DECL|macro|PA1_RXDAT
mdefine_line|#define PA1_RXDAT&t;((uint)0x0003c000)
DECL|macro|PA1_PSORA0
mdefine_line|#define PA1_PSORA0&t;(PA1_RXDAT | PA1_TXDAT)
DECL|macro|PA1_PSORA1
mdefine_line|#define PA1_PSORA1&t;(PA1_COL | PA1_CRS | PA1_TXER | PA1_TXEN | &bslash;&n;&t;&t;&t;&t;PA1_RXDV | PA1_RXER)
DECL|macro|PA1_DIRA0
mdefine_line|#define PA1_DIRA0&t;(PA1_RXDAT | PA1_CRS | PA1_COL | PA1_RXER | PA1_RXDV)
DECL|macro|PA1_DIRA1
mdefine_line|#define PA1_DIRA1&t;(PA1_TXDAT | PA1_TXEN | PA1_TXER)
multiline_comment|/* CLK12 is receive, CLK11 is transmit.  These are board specific.&n;*/
DECL|macro|PC_F1RXCLK
mdefine_line|#define PC_F1RXCLK&t;((uint)0x00000800)
DECL|macro|PC_F1TXCLK
mdefine_line|#define PC_F1TXCLK&t;((uint)0x00000400)
DECL|macro|CMX1_CLK_ROUTE
mdefine_line|#define CMX1_CLK_ROUTE&t;((uint)0x3e000000)
DECL|macro|CMX1_CLK_MASK
mdefine_line|#define CMX1_CLK_MASK&t;((uint)0xff000000)
multiline_comment|/* I/O Pin assignment for FCC2.  I don&squot;t yet know the best way to do this,&n; * but there is little variation among the choices.&n; */
DECL|macro|PB2_TXER
mdefine_line|#define PB2_TXER&t;((uint)0x00000001)
DECL|macro|PB2_RXDV
mdefine_line|#define PB2_RXDV&t;((uint)0x00000002)
DECL|macro|PB2_TXEN
mdefine_line|#define PB2_TXEN&t;((uint)0x00000004)
DECL|macro|PB2_RXER
mdefine_line|#define PB2_RXER&t;((uint)0x00000008)
DECL|macro|PB2_COL
mdefine_line|#define PB2_COL&t;&t;((uint)0x00000010)
DECL|macro|PB2_CRS
mdefine_line|#define PB2_CRS&t;&t;((uint)0x00000020)
DECL|macro|PB2_TXDAT
mdefine_line|#define PB2_TXDAT&t;((uint)0x000003c0)
DECL|macro|PB2_RXDAT
mdefine_line|#define PB2_RXDAT&t;((uint)0x00003c00)
DECL|macro|PB2_PSORB0
mdefine_line|#define PB2_PSORB0&t;(PB2_RXDAT | PB2_TXDAT | PB2_CRS | PB2_COL | &bslash;&n;&t;&t;&t;&t;PB2_RXER | PB2_RXDV | PB2_TXER)
DECL|macro|PB2_PSORB1
mdefine_line|#define PB2_PSORB1&t;(PB2_TXEN)
DECL|macro|PB2_DIRB0
mdefine_line|#define PB2_DIRB0&t;(PB2_RXDAT | PB2_CRS | PB2_COL | PB2_RXER | PB2_RXDV)
DECL|macro|PB2_DIRB1
mdefine_line|#define PB2_DIRB1&t;(PB2_TXDAT | PB2_TXEN | PB2_TXER)
multiline_comment|/* CLK13 is receive, CLK14 is transmit.  These are board dependent.&n;*/
DECL|macro|PC_F2RXCLK
mdefine_line|#define PC_F2RXCLK&t;((uint)0x00001000)
DECL|macro|PC_F2TXCLK
mdefine_line|#define PC_F2TXCLK&t;((uint)0x00002000)
DECL|macro|CMX2_CLK_ROUTE
mdefine_line|#define CMX2_CLK_ROUTE&t;((uint)0x00250000)
DECL|macro|CMX2_CLK_MASK
mdefine_line|#define CMX2_CLK_MASK&t;((uint)0x00ff0000)
multiline_comment|/* I/O Pin assignment for FCC3.  I don&squot;t yet know the best way to do this,&n; * but there is little variation among the choices.&n; */
DECL|macro|PB3_RXDV
mdefine_line|#define PB3_RXDV&t;((uint)0x00004000)
DECL|macro|PB3_RXER
mdefine_line|#define PB3_RXER&t;((uint)0x00008000)
DECL|macro|PB3_TXER
mdefine_line|#define PB3_TXER&t;((uint)0x00010000)
DECL|macro|PB3_TXEN
mdefine_line|#define PB3_TXEN&t;((uint)0x00020000)
DECL|macro|PB3_COL
mdefine_line|#define PB3_COL&t;&t;((uint)0x00040000)
DECL|macro|PB3_CRS
mdefine_line|#define PB3_CRS&t;&t;((uint)0x00080000)
DECL|macro|PB3_TXDAT
mdefine_line|#define PB3_TXDAT&t;((uint)0x0f000000)
DECL|macro|PB3_RXDAT
mdefine_line|#define PB3_RXDAT&t;((uint)0x00f00000)
DECL|macro|PB3_PSORB0
mdefine_line|#define PB3_PSORB0&t;(PB3_RXDAT | PB3_TXDAT | PB3_CRS | PB3_COL | &bslash;&n;&t;&t;&t;&t;PB3_RXER | PB3_RXDV | PB3_TXER | PB3_TXEN)
DECL|macro|PB3_PSORB1
mdefine_line|#define PB3_PSORB1&t;(0)
DECL|macro|PB3_DIRB0
mdefine_line|#define PB3_DIRB0&t;(PB3_RXDAT | PB3_CRS | PB3_COL | PB3_RXER | PB3_RXDV)
DECL|macro|PB3_DIRB1
mdefine_line|#define PB3_DIRB1&t;(PB3_TXDAT | PB3_TXEN | PB3_TXER)
multiline_comment|/* CLK15 is receive, CLK16 is transmit.  These are board dependent.&n;*/
DECL|macro|PC_F3RXCLK
mdefine_line|#define PC_F3RXCLK&t;((uint)0x00004000)
DECL|macro|PC_F3TXCLK
mdefine_line|#define PC_F3TXCLK&t;((uint)0x00008000)
DECL|macro|CMX3_CLK_ROUTE
mdefine_line|#define CMX3_CLK_ROUTE&t;((uint)0x00003700)
DECL|macro|CMX3_CLK_MASK
mdefine_line|#define CMX3_CLK_MASK&t;((uint)0x0000ff00)
multiline_comment|/* MII status/control serial interface.&n;*/
DECL|macro|PC_MDIO
mdefine_line|#define PC_MDIO&t;&t;((uint)0x00400000)
DECL|macro|PC_MDCK
mdefine_line|#define PC_MDCK&t;&t;((uint)0x00200000)
multiline_comment|/* A table of information for supporting FCCs.  This does two things.&n; * First, we know how many FCCs we have and they are always externally&n; * numbered from zero.  Second, it holds control register and I/O&n; * information that could be different among board designs.&n; */
DECL|struct|fcc_info
r_typedef
r_struct
id|fcc_info
(brace
DECL|member|fc_fccnum
id|uint
id|fc_fccnum
suffix:semicolon
DECL|member|fc_cpmblock
id|uint
id|fc_cpmblock
suffix:semicolon
DECL|member|fc_cpmpage
id|uint
id|fc_cpmpage
suffix:semicolon
DECL|member|fc_proff
id|uint
id|fc_proff
suffix:semicolon
DECL|member|fc_interrupt
id|uint
id|fc_interrupt
suffix:semicolon
DECL|member|fc_trxclocks
id|uint
id|fc_trxclocks
suffix:semicolon
DECL|member|fc_clockroute
id|uint
id|fc_clockroute
suffix:semicolon
DECL|member|fc_clockmask
id|uint
id|fc_clockmask
suffix:semicolon
DECL|member|fc_mdio
id|uint
id|fc_mdio
suffix:semicolon
DECL|member|fc_mdck
id|uint
id|fc_mdck
suffix:semicolon
DECL|typedef|fcc_info_t
)brace
id|fcc_info_t
suffix:semicolon
DECL|variable|fcc_ports
r_static
id|fcc_info_t
id|fcc_ports
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_FCC1_ENET
(brace
l_int|0
comma
id|CPM_CR_FCC1_SBLOCK
comma
id|CPM_CR_FCC1_PAGE
comma
id|PROFF_FCC1
comma
id|SIU_INT_FCC1
comma
(paren
id|PC_F1RXCLK
op_or
id|PC_F1TXCLK
)paren
comma
id|CMX1_CLK_ROUTE
comma
id|CMX1_CLK_MASK
comma
id|PC_MDIO
comma
id|PC_MDCK
)brace
comma
macro_line|#endif
macro_line|#ifdef CONFIG_FCC2_ENET
(brace
l_int|1
comma
id|CPM_CR_FCC2_SBLOCK
comma
id|CPM_CR_FCC2_PAGE
comma
id|PROFF_FCC2
comma
id|SIU_INT_FCC2
comma
(paren
id|PC_F2RXCLK
op_or
id|PC_F2TXCLK
)paren
comma
id|CMX2_CLK_ROUTE
comma
id|CMX2_CLK_MASK
comma
id|PC_MDIO
comma
id|PC_MDCK
)brace
comma
macro_line|#endif
macro_line|#ifdef CONFIG_FCC3_ENET
(brace
l_int|2
comma
id|CPM_CR_FCC3_SBLOCK
comma
id|CPM_CR_FCC3_PAGE
comma
id|PROFF_FCC3
comma
id|SIU_INT_FCC3
comma
(paren
id|PC_F3RXCLK
op_or
id|PC_F3TXCLK
)paren
comma
id|CMX3_CLK_ROUTE
comma
id|CMX3_CLK_MASK
comma
id|PC_MDIO
comma
id|PC_MDCK
)brace
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* The FCC buffer descriptors track the ring buffers.  The rx_bd_base and&n; * tx_bd_base always point to the base of the buffer descriptors.  The&n; * cur_rx and cur_tx point to the currently available buffer.&n; * The dirty_tx tracks the current buffer that is being sent by the&n; * controller.  The cur_tx and dirty_tx are equal under both completely&n; * empty and completely full conditions.  The empty/ready indicator in&n; * the buffer descriptor determines the actual condition.&n; */
DECL|struct|fcc_enet_private
r_struct
id|fcc_enet_private
(brace
multiline_comment|/* The saved address of a sent-in-place packet/buffer, for skfree(). */
DECL|member|tx_skbuff
r_struct
id|sk_buff
op_star
id|tx_skbuff
(braket
id|TX_RING_SIZE
)braket
suffix:semicolon
DECL|member|skb_cur
id|ushort
id|skb_cur
suffix:semicolon
DECL|member|skb_dirty
id|ushort
id|skb_dirty
suffix:semicolon
multiline_comment|/* CPM dual port RAM relative addresses.&n;&t;*/
DECL|member|rx_bd_base
id|cbd_t
op_star
id|rx_bd_base
suffix:semicolon
multiline_comment|/* Address of Rx and Tx buffers. */
DECL|member|tx_bd_base
id|cbd_t
op_star
id|tx_bd_base
suffix:semicolon
DECL|member|cur_rx
DECL|member|cur_tx
id|cbd_t
op_star
id|cur_rx
comma
op_star
id|cur_tx
suffix:semicolon
multiline_comment|/* The next free ring entry */
DECL|member|dirty_tx
id|cbd_t
op_star
id|dirty_tx
suffix:semicolon
multiline_comment|/* The ring entries to be free()ed. */
DECL|member|fccp
r_volatile
id|fcc_t
op_star
id|fccp
suffix:semicolon
DECL|member|ep
r_volatile
id|fcc_enet_t
op_star
id|ep
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|tx_full
id|uint
id|tx_full
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|phy_address
id|uint
id|phy_address
suffix:semicolon
DECL|member|phy_type
id|uint
id|phy_type
suffix:semicolon
DECL|member|phy_duplex
id|uint
id|phy_duplex
suffix:semicolon
DECL|member|fip
id|fcc_info_t
op_star
id|fip
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|init_fcc_shutdown
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_struct
id|fcc_enet_private
op_star
id|cep
comma
r_volatile
id|immap_t
op_star
id|immap
)paren
suffix:semicolon
r_static
r_void
id|init_fcc_startup
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|init_fcc_ioports
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_volatile
id|iop8260_t
op_star
id|io
comma
r_volatile
id|immap_t
op_star
id|immap
)paren
suffix:semicolon
r_static
r_void
id|init_fcc_param
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_struct
id|net_device
op_star
id|dev
comma
r_volatile
id|immap_t
op_star
id|immap
)paren
suffix:semicolon
multiline_comment|/* MII processing.  We keep this as simple as possible.  Requests are&n; * placed on the list (if there is room).  When the request is finished&n; * by the MII, an optional function may be called.&n; */
DECL|struct|mii_list
r_typedef
r_struct
id|mii_list
(brace
DECL|member|mii_regval
id|uint
id|mii_regval
suffix:semicolon
DECL|member|mii_func
r_void
(paren
op_star
id|mii_func
)paren
(paren
id|uint
id|val
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
DECL|member|mii_next
r_struct
id|mii_list
op_star
id|mii_next
suffix:semicolon
DECL|typedef|mii_list_t
)brace
id|mii_list_t
suffix:semicolon
DECL|macro|NMII
mdefine_line|#define&t;&t;NMII&t;20
DECL|variable|mii_cmds
id|mii_list_t
id|mii_cmds
(braket
id|NMII
)braket
suffix:semicolon
DECL|variable|mii_free
id|mii_list_t
op_star
id|mii_free
suffix:semicolon
DECL|variable|mii_head
id|mii_list_t
op_star
id|mii_head
suffix:semicolon
DECL|variable|mii_tail
id|mii_list_t
op_star
id|mii_tail
suffix:semicolon
DECL|variable|phyaddr
r_static
r_int
id|phyaddr
suffix:semicolon
DECL|variable|phytype
r_static
id|uint
id|phytype
suffix:semicolon
r_static
r_int
id|mii_queue
c_func
(paren
r_int
id|request
comma
r_void
(paren
op_star
id|func
)paren
(paren
id|uint
comma
r_struct
id|net_device
op_star
)paren
)paren
suffix:semicolon
r_static
r_void
id|mii_startup_cmds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|uint
id|mii_send_receive
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
id|uint
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Make MII read/write commands for the FCC.&n;*/
DECL|macro|mk_mii_phyaddr
mdefine_line|#define mk_mii_phyaddr(ADDR)&t;(0x60020000 | ((ADDR) &lt;&lt; 23) | (2 &lt;&lt; 18))
DECL|macro|mk_mii_read
mdefine_line|#define mk_mii_read(REG)&t;(0x60020000 | ((phyaddr &lt;&lt; 23) | &bslash;&n;&t;&t;&t;&t;&t;&t;(REG &amp; 0x1f) &lt;&lt; 18))
DECL|macro|mk_mii_write
mdefine_line|#define mk_mii_write(REG, VAL)&t;(0x50020000 | ((phyaddr &lt;&lt; 23) | &bslash;&n;&t;&t;&t;&t;&t;&t;(REG &amp; 0x1f) &lt;&lt; 18) | &bslash;&n;&t;&t;&t;&t;&t;&t;(VAL &amp; 0xffff))
r_static
r_int
DECL|function|fcc_enet_open
id|fcc_enet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Always succeed */
)brace
r_static
r_int
DECL|function|fcc_enet_start_xmit
id|fcc_enet_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fcc_enet_private
op_star
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
multiline_comment|/* Fill in a Tx ring entry */
id|bdp
op_assign
id|cep-&gt;cur_tx
suffix:semicolon
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
(brace
multiline_comment|/* Ooops.  All transmit buffers are full.  Bail out.&n;&t;&t; * This should not happen, since cep-&gt;tx_full should be set.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: tx queue full!.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Clear all of the status flags.&n;&t; */
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_TX_STATS
suffix:semicolon
multiline_comment|/* If the frame is short, tell CPM to pad it.&n;&t;*/
r_if
c_cond
(paren
id|skb-&gt;len
op_le
id|ETH_ZLEN
)paren
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_ENET_TX_PAD
suffix:semicolon
r_else
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_TX_PAD
suffix:semicolon
multiline_comment|/* Set buffer length and buffer pointer.&n;&t;*/
id|bdp-&gt;cbd_datlen
op_assign
id|skb-&gt;len
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
id|__pa
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* Save skb pointer.&n;&t;*/
id|cep-&gt;tx_skbuff
(braket
id|cep-&gt;skb_cur
)braket
op_assign
id|skb
suffix:semicolon
id|cep-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|cep-&gt;skb_cur
op_assign
(paren
id|cep-&gt;skb_cur
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Send it on its way.  Tell CPM its ready, interrupt when done,&n;&t; * its the last BD of the frame, and to put the CRC on the end.&n;&t; */
id|bdp-&gt;cbd_sc
op_or_assign
(paren
id|BD_ENET_TX_READY
op_or
id|BD_ENET_TX_INTR
op_or
id|BD_ENET_TX_LAST
op_or
id|BD_ENET_TX_TC
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Errata says don&squot;t do this.&n;&t;*/
id|cep-&gt;fccp-&gt;fcc_ftodr
op_assign
l_int|0x8000
suffix:semicolon
macro_line|#endif
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* If this was the last BD in the ring, start at the beginning again.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_WRAP
)paren
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|cep-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
)brace
id|cep-&gt;cur_tx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|fcc_enet_timeout
id|fcc_enet_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fcc_enet_private
op_star
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cep-&gt;stats.tx_errors
op_increment
suffix:semicolon
macro_line|#ifndef final_version
(brace
r_int
id|i
suffix:semicolon
id|cbd_t
op_star
id|bdp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Ring data dump: cur_tx %p%s cur_rx %p.&bslash;n&quot;
comma
id|cep-&gt;cur_tx
comma
id|cep-&gt;tx_full
ques
c_cond
l_string|&quot; (full)&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|cep-&gt;cur_rx
)paren
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Tx @base %p :&bslash;n&quot;
comma
id|bdp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
comma
id|bdp
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%04x %04x %08x&bslash;n&quot;
comma
id|bdp-&gt;cbd_sc
comma
id|bdp-&gt;cbd_datlen
comma
id|bdp-&gt;cbd_bufaddr
)paren
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Rx @base %p :&bslash;n&quot;
comma
id|bdp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
comma
id|bdp
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%04x %04x %08x&bslash;n&quot;
comma
id|bdp-&gt;cbd_sc
comma
id|bdp-&gt;cbd_datlen
comma
id|bdp-&gt;cbd_bufaddr
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|cep-&gt;tx_full
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* The interrupt handler.&n; */
r_static
r_void
DECL|function|fcc_enet_interrupt
id|fcc_enet_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_volatile
r_struct
id|fcc_enet_private
op_star
id|cep
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
id|ushort
id|int_events
suffix:semicolon
r_int
id|must_restart
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Get the interrupt events that caused us to be here.&n;&t;*/
id|int_events
op_assign
id|cep-&gt;fccp-&gt;fcc_fcce
suffix:semicolon
id|cep-&gt;fccp-&gt;fcc_fcce
op_assign
id|int_events
suffix:semicolon
id|must_restart
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Handle receive event in its own function.&n;&t;*/
r_if
c_cond
(paren
id|int_events
op_amp
id|FCC_ENET_RXF
)paren
id|fcc_enet_rx
c_func
(paren
id|dev_id
)paren
suffix:semicolon
multiline_comment|/* Check for a transmit error.  The manual is a little unclear&n;&t; * about this, so the debug code until I get it figured out.  It&n;&t; * appears that if TXE is set, then TXB is not set.  However,&n;&t; * if carrier sense is lost during frame transmission, the TXE&n;&t; * bit is set, &quot;and continues the buffer transmission normally.&quot;&n;&t; * I don&squot;t know if &quot;normally&quot; implies TXB is set when the buffer&n;&t; * descriptor is closed.....trial and error :-).&n;&t; */
multiline_comment|/* Transmit OK, or non-fatal error.  Update the buffer descriptors.&n;&t;*/
r_if
c_cond
(paren
id|int_events
op_amp
(paren
id|FCC_ENET_TXE
op_or
id|FCC_ENET_TXB
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;dirty_tx
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|bdp
op_eq
id|cep-&gt;cur_tx
)paren
op_logical_and
(paren
id|cep-&gt;tx_full
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_HB
)paren
multiline_comment|/* No heartbeat */
id|cep-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_LC
)paren
multiline_comment|/* Late collision */
id|cep-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_RL
)paren
multiline_comment|/* Retrans limit */
id|cep-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_UN
)paren
multiline_comment|/* Underrun */
id|cep-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_CSL
)paren
multiline_comment|/* Carrier lost */
id|cep-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
multiline_comment|/* No heartbeat or Lost carrier are not really bad errors.&n;&t;&t; * The others require a restart transmit command.&n;&t;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
(paren
id|BD_ENET_TX_LC
op_or
id|BD_ENET_TX_RL
op_or
id|BD_ENET_TX_UN
)paren
)paren
(brace
id|must_restart
op_assign
l_int|1
suffix:semicolon
id|cep-&gt;stats.tx_errors
op_increment
suffix:semicolon
)brace
id|cep-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Deferred means some collisions occurred during transmit,&n;&t;&t; * but we eventually sent the packet OK.&n;&t;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_DEF
)paren
id|cep-&gt;stats.collisions
op_increment
suffix:semicolon
multiline_comment|/* Free the sk buffer associated with this last transmit.&n;&t;&t;*/
id|dev_kfree_skb_irq
c_func
(paren
id|cep-&gt;tx_skbuff
(braket
id|cep-&gt;skb_dirty
)braket
)paren
suffix:semicolon
id|cep-&gt;skb_dirty
op_assign
(paren
id|cep-&gt;skb_dirty
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
suffix:semicolon
multiline_comment|/* Update pointer to next buffer descriptor to be transmitted.&n;&t;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_WRAP
)paren
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
multiline_comment|/* I don&squot;t know if we can be held off from processing these&n;&t;&t; * interrupts for more than one frame time.  I really hope&n;&t;&t; * not.  In such a case, we would now want to check the&n;&t;&t; * currently available BD (cur_tx) and determine if any&n;&t;&t; * buffers between the dirty_tx and cur_tx have also been&n;&t;&t; * sent.  We would want to process anything in between that&n;&t;&t; * does not have BD_ENET_TX_READY set.&n;&t;&t; */
multiline_comment|/* Since we have freed up a buffer, the ring is no longer&n;&t;&t; * full.&n;&t;&t; */
r_if
c_cond
(paren
id|cep-&gt;tx_full
)paren
(brace
id|cep-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|cep-&gt;dirty_tx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|must_restart
)paren
(brace
r_volatile
id|cpm8260_t
op_star
id|cp
suffix:semicolon
multiline_comment|/* Some transmit errors cause the transmitter to shut&n;&t;&t; * down.  We now issue a restart transmit.  Since the&n;&t;&t; * errors close the BD and update the pointers, the restart&n;&t;&t; * _should_ pick up without having to reset any of our&n;&t;&t; * pointers either.&n;&t;&t; */
id|cp
op_assign
id|cpmp
suffix:semicolon
id|cp-&gt;cp_cpcr
op_assign
id|mk_cr_cmd
c_func
(paren
id|cep-&gt;fip-&gt;fc_cpmpage
comma
id|cep-&gt;fip-&gt;fc_cpmblock
comma
l_int|0x0c
comma
id|CPM_CR_RESTART_TX
)paren
op_or
id|CPM_CR_FLG
suffix:semicolon
r_while
c_loop
(paren
id|cp-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for receive busy, i.e. packets coming but no place to&n;&t; * put them.&n;&t; */
r_if
c_cond
(paren
id|int_events
op_amp
id|FCC_ENET_BSY
)paren
(brace
id|cep-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* During a receive, the cur_rx points to the current incoming buffer.&n; * When we update through the ring, if the next incoming buffer has&n; * not been given to the system, we just set the empty indicator,&n; * effectively tossing the packet.&n; */
r_static
r_int
DECL|function|fcc_enet_rx
id|fcc_enet_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fcc_enet_private
op_star
id|cep
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ushort
id|pkt_len
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* First, grab all of the stats for the incoming packet.&n;&t; * These get messed up if we get called due to a busy condition.&n;&t; */
id|bdp
op_assign
id|cep-&gt;cur_rx
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_EMPTY
)paren
r_break
suffix:semicolon
macro_line|#ifndef final_version
multiline_comment|/* Since we have allocated space to hold a complete frame, both&n;&t; * the first and last indicators should be set.&n;&t; */
r_if
c_cond
(paren
(paren
id|bdp-&gt;cbd_sc
op_amp
(paren
id|BD_ENET_RX_FIRST
op_or
id|BD_ENET_RX_LAST
)paren
)paren
op_ne
(paren
id|BD_ENET_RX_FIRST
op_or
id|BD_ENET_RX_LAST
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;CPM ENET: rcv is not first+last&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Frame too long or too short.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
(paren
id|BD_ENET_RX_LG
op_or
id|BD_ENET_RX_SH
)paren
)paren
id|cep-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_NO
)paren
multiline_comment|/* Frame alignment */
id|cep-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_CR
)paren
multiline_comment|/* CRC Error */
id|cep-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_OV
)paren
multiline_comment|/* FIFO overrun */
id|cep-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
multiline_comment|/* Report late collisions as a frame error.&n;&t; * On this error, the BD is closed, but we don&squot;t know what we&n;&t; * have in the buffer.  So, just drop this frame on the floor.&n;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_CL
)paren
(brace
id|cep-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Process the incoming frame.&n;&t;&t;*/
id|cep-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|pkt_len
op_assign
id|bdp-&gt;cbd_datlen
suffix:semicolon
id|cep-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
multiline_comment|/* This does 16 byte alignment, much more than we need.&n;&t;&t; * The packet length includes FCS, but we don&squot;t want to&n;&t;&t; * include that when passing upstream as it messes up&n;&t;&t; * bridging applications.&n;&t;&t; */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_minus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cep-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Make room */
id|eth_copy_and_sum
c_func
(paren
id|skb
comma
(paren
r_int
r_char
op_star
)paren
id|__va
c_func
(paren
id|bdp-&gt;cbd_bufaddr
)paren
comma
id|pkt_len
op_minus
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear the status flags for this buffer.&n;&t;*/
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_RX_STATS
suffix:semicolon
multiline_comment|/* Mark the buffer empty.&n;&t;*/
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_ENET_RX_EMPTY
suffix:semicolon
multiline_comment|/* Update BD pointer to next entry.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_WRAP
)paren
id|bdp
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
)brace
id|cep-&gt;cur_rx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|fcc_enet_close
id|fcc_enet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Don&squot;t know what to do yet.&n;&t;*/
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fcc_enet_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|fcc_enet_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fcc_enet_private
op_star
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|cep-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* The MII is simulated from the 8xx FEC implementation.  The FCC&n; * is not responsible for the MII control/status interface.&n; */
r_static
r_void
DECL|function|fcc_enet_mii
id|fcc_enet_mii
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fcc_enet_private
op_star
id|fep
suffix:semicolon
id|mii_list_t
op_star
id|mip
suffix:semicolon
id|uint
id|mii_reg
suffix:semicolon
id|fep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#if 0
id|ep
op_assign
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
suffix:semicolon
id|mii_reg
op_assign
id|ep-&gt;fec_mii_data
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|mip
op_assign
id|mii_head
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MII and no head!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mip-&gt;mii_func
op_ne
l_int|NULL
)paren
(paren
op_star
(paren
id|mip-&gt;mii_func
)paren
)paren
(paren
id|mii_reg
comma
id|dev
)paren
suffix:semicolon
id|mii_head
op_assign
id|mip-&gt;mii_next
suffix:semicolon
id|mip-&gt;mii_next
op_assign
id|mii_free
suffix:semicolon
id|mii_free
op_assign
id|mip
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|mip
op_assign
id|mii_head
)paren
op_ne
l_int|NULL
)paren
id|ep-&gt;fec_mii_data
op_assign
id|mip-&gt;mii_regval
suffix:semicolon
macro_line|#endif
)brace
r_static
r_int
DECL|function|mii_queue
id|mii_queue
c_func
(paren
r_int
id|regval
comma
r_void
(paren
op_star
id|func
)paren
(paren
id|uint
comma
r_struct
id|net_device
op_star
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mii_list_t
op_star
id|mip
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mip
op_assign
id|mii_free
)paren
op_ne
l_int|NULL
)paren
(brace
id|mii_free
op_assign
id|mip-&gt;mii_next
suffix:semicolon
id|mip-&gt;mii_regval
op_assign
id|regval
suffix:semicolon
id|mip-&gt;mii_func
op_assign
id|func
suffix:semicolon
id|mip-&gt;mii_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mii_head
)paren
(brace
id|mii_tail-&gt;mii_next
op_assign
id|mip
suffix:semicolon
id|mii_tail
op_assign
id|mip
suffix:semicolon
)brace
r_else
(brace
id|mii_head
op_assign
id|mii_tail
op_assign
id|mip
suffix:semicolon
macro_line|#if 0
(paren
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
)paren
op_member_access_from_pointer
id|fec_mii_data
op_assign
id|regval
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|full_duplex
r_static
r_volatile
id|uint
id|full_duplex
suffix:semicolon
r_static
r_void
DECL|function|mii_status
id|mii_status
c_func
(paren
id|uint
id|mii_reg
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_volatile
id|uint
id|prev_duplex
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* status register.&n;&t;&t;*/
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0004
)paren
id|printk
c_func
(paren
l_string|&quot;link up&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;link down&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0010
)paren
id|printk
c_func
(paren
l_string|&quot;,remote fault&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0020
)paren
id|printk
c_func
(paren
l_string|&quot;,auto complete&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|0x14
)paren
(brace
multiline_comment|/* Extended chip status register.&n;&t;&t;*/
id|prev_duplex
op_assign
id|full_duplex
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0800
)paren
id|printk
c_func
(paren
l_string|&quot;100 Mbps&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;10 Mbps&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, Full-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, Half-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|prev_duplex
op_ne
id|full_duplex
)paren
id|restart_fec
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|31
)paren
(brace
multiline_comment|/* QS6612 PHY Control/Status.&n;&t;&t; * OK, now we have it all, so figure out what is going on.&n;&t;&t; */
id|prev_duplex
op_assign
id|full_duplex
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
id|mii_reg
op_assign
(paren
id|mii_reg
op_rshift
l_int|2
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;10 Mbps&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;100 Mbps&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, Full-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, Half-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|prev_duplex
op_ne
id|full_duplex
)paren
id|restart_fec
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
DECL|variable|phyno
r_static
id|uint
id|phyno
suffix:semicolon
r_static
r_void
DECL|function|mii_discover_phy3
id|mii_discover_phy3
c_func
(paren
id|uint
id|mii_reg
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|phytype
op_lshift_assign
l_int|16
suffix:semicolon
id|phytype
op_or_assign
(paren
id|mii_reg
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fec: Phy @ 0x%x, type 0x%08x&bslash;n&quot;
comma
id|phyno
comma
id|phytype
)paren
suffix:semicolon
id|mii_startup_cmds
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|mii_discover_phy
id|mii_discover_phy
c_func
(paren
id|uint
id|mii_reg
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|phyno
OL
l_int|32
)paren
(brace
r_if
c_cond
(paren
(paren
id|phytype
op_assign
(paren
id|mii_reg
op_amp
l_int|0xffff
)paren
)paren
op_ne
l_int|0xffff
)paren
(brace
id|phyaddr
op_assign
id|phyno
suffix:semicolon
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|3
)paren
comma
id|mii_discover_phy3
)paren
suffix:semicolon
)brace
r_else
(brace
id|phyno
op_increment
suffix:semicolon
id|mii_queue
c_func
(paren
id|mk_mii_phyaddr
c_func
(paren
id|phyno
)paren
comma
id|mii_discover_phy
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;FEC: No PHY device found.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|mii_discover_phy_poll
id|mii_discover_phy_poll
c_func
(paren
id|fcc_info_t
op_star
id|fip
)paren
(brace
id|uint
id|rv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rv
op_assign
id|mii_send_receive
c_func
(paren
id|fip
comma
id|mk_mii_phyaddr
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|phytype
op_assign
(paren
id|rv
op_amp
l_int|0xffff
)paren
)paren
op_ne
l_int|0xffff
)paren
(brace
id|phyaddr
op_assign
id|i
suffix:semicolon
id|rv
op_assign
id|mii_send_receive
c_func
(paren
id|fip
comma
id|mk_mii_read
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
id|phytype
op_lshift_assign
l_int|16
suffix:semicolon
id|phytype
op_or_assign
(paren
id|rv
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fec: Phy @ 0x%x, type 0x%08x&bslash;n&quot;
comma
id|phyaddr
comma
id|phytype
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|mii_startup_cmds
id|mii_startup_cmds
c_func
(paren
r_void
)paren
(brace
macro_line|#if 1
multiline_comment|/* Level One PHY.&n;&t;*/
multiline_comment|/* Read status registers to clear any pending interrupt.&n;&t;*/
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|1
)paren
comma
id|mii_status
)paren
suffix:semicolon
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|18
)paren
comma
id|mii_status
)paren
suffix:semicolon
multiline_comment|/* Read extended chip status register.&n;&t;*/
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|0x14
)paren
comma
id|mii_status
)paren
suffix:semicolon
multiline_comment|/* Set default operation of 100-TX....for some reason&n;&t; * some of these bits are set on power up, which is wrong.&n;&t; */
id|mii_queue
c_func
(paren
id|mk_mii_write
c_func
(paren
l_int|0x13
comma
l_int|0
)paren
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Enable Link status change interrupts.&n;&t;*/
id|mii_queue
c_func
(paren
id|mk_mii_write
c_func
(paren
l_int|0x11
comma
l_int|0x0002
)paren
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t advertize Full duplex.&n;&t;mii_queue(mk_mii_write(0x04, 0x0021), NULL);&n;&t;*/
macro_line|#endif
)brace
multiline_comment|/* This supports the mii_link interrupt below.&n; * We should get called three times.  Once for register 1, once for&n; * register 18, and once for register 20.&n; */
DECL|variable|mii_saved_reg1
r_static
id|uint
id|mii_saved_reg1
suffix:semicolon
r_static
r_void
DECL|function|mii_relink
id|mii_relink
c_func
(paren
id|uint
id|mii_reg
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_volatile
id|uint
id|prev_duplex
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Just save the status register and get out.&n;&t;&t;*/
id|mii_saved_reg1
op_assign
id|mii_reg
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|18
)paren
(brace
multiline_comment|/* Not much here, but has to be read to clear the&n;&t;&t; * interrupt condition.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mii_reg
op_amp
l_int|0x8000
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;fec: re-link and no IRQ?&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mii_reg
op_amp
l_int|0x4000
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;fec: no PHY power?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|20
)paren
(brace
multiline_comment|/* Extended chip status register.&n;&t;&t; * OK, now we have it all, so figure out what is going on.&n;&t;&t; */
id|prev_duplex
op_assign
id|full_duplex
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0004
)paren
id|printk
c_func
(paren
l_string|&quot;link up&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;link down&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0010
)paren
id|printk
c_func
(paren
l_string|&quot;, remote fault&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0020
)paren
id|printk
c_func
(paren
l_string|&quot;, auto complete&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0800
)paren
id|printk
c_func
(paren
l_string|&quot;, 100 Mbps&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, 10 Mbps&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, Full-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, Half-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_duplex
op_ne
id|full_duplex
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|restart_fec
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|31
)paren
(brace
multiline_comment|/* QS6612 PHY Control/Status.&n;&t;&t; * OK, now we have it all, so figure out what is going on.&n;&t;&t; */
id|prev_duplex
op_assign
id|full_duplex
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0004
)paren
id|printk
c_func
(paren
l_string|&quot;link up&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;link down&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0010
)paren
id|printk
c_func
(paren
l_string|&quot;, remote fault&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0020
)paren
id|printk
c_func
(paren
l_string|&quot;, auto complete&quot;
)paren
suffix:semicolon
id|mii_reg
op_assign
(paren
id|mii_reg
op_rshift
l_int|2
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;, 10 Mbps&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, 100 Mbps&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, Full-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, Half-Duplex&bslash;n&quot;
)paren
suffix:semicolon
id|full_duplex
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|prev_duplex
op_ne
id|full_duplex
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|restart_fec
c_func
(paren
id|dev
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n; * Skeleton taken from sunlance driver.&n; * The CPM Ethernet implementation allows Multicast as well as individual&n; * MAC address filtering.  Some of the drivers check to make sure it is&n; * a group multicast address, and discard those that are not.  I guess I&n; * will do the same for now, but just remove the test if you want&n; * individual filtering as well (do the upper net layers want or support&n; * this kind of feature?).&n; */
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|fcc_enet_private
op_star
id|cep
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|u_char
op_star
id|mcptr
comma
op_star
id|tdptr
suffix:semicolon
r_volatile
id|fcc_enet_t
op_star
id|ep
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* Get pointer to FCC area in parameter RAM.&n;&t;*/
id|ep
op_assign
(paren
id|fcc_enet_t
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Log any net taps. */
id|printk
c_func
(paren
l_string|&quot;%s: Promiscuous mode enabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cep-&gt;fccp-&gt;fcc_fpsmr
op_or_assign
id|FCC_PSMR_PRO
suffix:semicolon
)brace
r_else
(brace
id|cep-&gt;fccp-&gt;fcc_fpsmr
op_and_assign
op_complement
id|FCC_PSMR_PRO
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
multiline_comment|/* Catch all multicast addresses, so set the&n;&t;&t;&t; * filter to all 1&squot;s.&n;&t;&t;&t; */
id|ep-&gt;fen_gaddrh
op_assign
l_int|0xffffffff
suffix:semicolon
id|ep-&gt;fen_gaddrl
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clear filter and add the addresses in the list.&n;&t;&t;&t;*/
id|ep-&gt;fen_gaddrh
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_gaddrl
op_assign
l_int|0
suffix:semicolon
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Only support group multicast for now.&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* The address in dmi_addr is LSB first,&n;&t;&t;&t;&t; * and taddr is MSB first.  We have to&n;&t;&t;&t;&t; * copy bytes MSB first from dmi_addr.&n;&t;&t;&t;&t; */
id|mcptr
op_assign
(paren
id|u_char
op_star
)paren
id|dmi-&gt;dmi_addr
op_plus
l_int|5
suffix:semicolon
id|tdptr
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|ep-&gt;fen_taddrh
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
op_star
id|tdptr
op_increment
op_assign
op_star
id|mcptr
op_decrement
suffix:semicolon
multiline_comment|/* Ask CPM to run CRC and set bit in&n;&t;&t;&t;&t; * filter mask.&n;&t;&t;&t;&t; */
id|cpmp-&gt;cp_cpcr
op_assign
id|mk_cr_cmd
c_func
(paren
id|cep-&gt;fip-&gt;fc_cpmpage
comma
id|cep-&gt;fip-&gt;fc_cpmblock
comma
l_int|0x0c
comma
id|CPM_CR_SET_GADDR
)paren
op_or
id|CPM_CR_FLG
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cpmp-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Initialize the CPM Ethernet on FCC.&n; */
DECL|function|fec_enet_init
r_int
id|__init
id|fec_enet_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|fcc_enet_private
op_star
id|cep
suffix:semicolon
id|fcc_info_t
op_star
id|fip
suffix:semicolon
r_int
id|i
comma
id|np
suffix:semicolon
r_volatile
id|immap_t
op_star
id|immap
suffix:semicolon
r_volatile
id|iop8260_t
op_star
id|io
suffix:semicolon
id|immap
op_assign
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
suffix:semicolon
multiline_comment|/* and to internal registers */
id|io
op_assign
op_amp
id|immap-&gt;im_ioport
suffix:semicolon
id|np
op_assign
r_sizeof
(paren
id|fcc_ports
)paren
op_div
r_sizeof
(paren
id|fcc_info_t
)paren
suffix:semicolon
id|fip
op_assign
id|fcc_ports
suffix:semicolon
r_while
c_loop
(paren
id|np
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* Allocate some private information.&n;&t;&t;*/
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cep
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|__clear_user
c_func
(paren
id|cep
comma
r_sizeof
(paren
op_star
id|cep
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
id|cep-&gt;fip
op_assign
id|fip
suffix:semicolon
multiline_comment|/* Create an Ethernet device instance.&n;&t;&t;*/
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
id|cep
suffix:semicolon
id|init_fcc_shutdown
c_func
(paren
id|fip
comma
id|cep
comma
id|immap
)paren
suffix:semicolon
id|init_fcc_ioports
c_func
(paren
id|fip
comma
id|io
comma
id|immap
)paren
suffix:semicolon
id|init_fcc_param
c_func
(paren
id|fip
comma
id|dev
comma
id|immap
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
(paren
r_int
r_int
)paren
(paren
id|cep-&gt;ep
)paren
suffix:semicolon
multiline_comment|/* The CPM Ethernet specific entries in the device&n;&t;&t; * structure.&n;&t;&t; */
id|dev-&gt;open
op_assign
id|fcc_enet_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|fcc_enet_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|fcc_enet_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
id|dev-&gt;stop
op_assign
id|fcc_enet_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|fcc_enet_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|init_fcc_startup
c_func
(paren
id|fip
comma
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: FCC ENET Version 0.2, &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* This is just a hack for now that works only on the EST&n;&t;&t; * board, or anything else that has MDIO/CK configured.&n;&t;&t; * It is mainly to test the MII software clocking.&n;&t;&t; */
id|mii_discover_phy_poll
c_func
(paren
id|fip
)paren
suffix:semicolon
id|fip
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Make sure the device is shut down during initialization.&n;*/
r_static
r_void
id|__init
DECL|function|init_fcc_shutdown
id|init_fcc_shutdown
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_struct
id|fcc_enet_private
op_star
id|cep
comma
r_volatile
id|immap_t
op_star
id|immap
)paren
(brace
r_volatile
id|fcc_enet_t
op_star
id|ep
suffix:semicolon
r_volatile
id|fcc_t
op_star
id|fccp
suffix:semicolon
multiline_comment|/* Get pointer to FCC area in parameter RAM.&n;&t;*/
id|ep
op_assign
(paren
id|fcc_enet_t
op_star
)paren
(paren
op_amp
id|immap-&gt;im_dprambase
(braket
id|fip-&gt;fc_proff
)braket
)paren
suffix:semicolon
multiline_comment|/* And another to the FCC register area.&n;&t;*/
id|fccp
op_assign
(paren
r_volatile
id|fcc_t
op_star
)paren
(paren
op_amp
id|immap-&gt;im_fcc
(braket
id|fip-&gt;fc_fccnum
)braket
)paren
suffix:semicolon
id|cep-&gt;fccp
op_assign
id|fccp
suffix:semicolon
multiline_comment|/* Keep the pointers handy */
id|cep-&gt;ep
op_assign
id|ep
suffix:semicolon
multiline_comment|/* Disable receive and transmit in case someone left it running.&n;&t;*/
id|fccp-&gt;fcc_gfmr
op_and_assign
op_complement
(paren
id|FCC_GFMR_ENR
op_or
id|FCC_GFMR_ENT
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the I/O pins for the FCC Ethernet.&n;*/
r_static
r_void
id|__init
DECL|function|init_fcc_ioports
id|init_fcc_ioports
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_volatile
id|iop8260_t
op_star
id|io
comma
r_volatile
id|immap_t
op_star
id|immap
)paren
(brace
multiline_comment|/* FCC1 pins are on port A/C.  FCC2/3 are port B/C.&n;&t;*/
r_if
c_cond
(paren
id|fip-&gt;fc_proff
op_eq
id|PROFF_FCC1
)paren
(brace
multiline_comment|/* Configure port A and C pins for FCC1 Ethernet.&n;&t;&t; */
id|io-&gt;iop_pdira
op_and_assign
op_complement
id|PA1_DIRA0
suffix:semicolon
id|io-&gt;iop_pdira
op_or_assign
id|PA1_DIRA1
suffix:semicolon
id|io-&gt;iop_psora
op_and_assign
op_complement
id|PA1_PSORA0
suffix:semicolon
id|io-&gt;iop_psora
op_or_assign
id|PA1_PSORA1
suffix:semicolon
id|io-&gt;iop_ppara
op_or_assign
(paren
id|PA1_DIRA0
op_or
id|PA1_DIRA1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fip-&gt;fc_proff
op_eq
id|PROFF_FCC2
)paren
(brace
multiline_comment|/* Configure port B and C pins for FCC Ethernet.&n;&t;&t; */
id|io-&gt;iop_pdirb
op_and_assign
op_complement
id|PB2_DIRB0
suffix:semicolon
id|io-&gt;iop_pdirb
op_or_assign
id|PB2_DIRB1
suffix:semicolon
id|io-&gt;iop_psorb
op_and_assign
op_complement
id|PB2_PSORB0
suffix:semicolon
id|io-&gt;iop_psorb
op_or_assign
id|PB2_PSORB1
suffix:semicolon
id|io-&gt;iop_pparb
op_or_assign
(paren
id|PB2_DIRB0
op_or
id|PB2_DIRB1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fip-&gt;fc_proff
op_eq
id|PROFF_FCC3
)paren
(brace
multiline_comment|/* Configure port B and C pins for FCC Ethernet.&n;&t;&t; */
id|io-&gt;iop_pdirb
op_and_assign
op_complement
id|PB3_DIRB0
suffix:semicolon
id|io-&gt;iop_pdirb
op_or_assign
id|PB3_DIRB1
suffix:semicolon
id|io-&gt;iop_psorb
op_and_assign
op_complement
id|PB3_PSORB0
suffix:semicolon
id|io-&gt;iop_psorb
op_or_assign
id|PB3_PSORB1
suffix:semicolon
id|io-&gt;iop_pparb
op_or_assign
(paren
id|PB3_DIRB0
op_or
id|PB3_DIRB1
)paren
suffix:semicolon
)brace
multiline_comment|/* Port C has clocks......&n;&t;*/
id|io-&gt;iop_psorc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_trxclocks
)paren
suffix:semicolon
id|io-&gt;iop_pdirc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_trxclocks
)paren
suffix:semicolon
id|io-&gt;iop_pparc
op_or_assign
id|fip-&gt;fc_trxclocks
suffix:semicolon
multiline_comment|/* ....and the MII serial clock/data.&n;&t;*/
id|io-&gt;iop_pdatc
op_or_assign
(paren
id|fip-&gt;fc_mdio
op_or
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
id|io-&gt;iop_podrc
op_or_assign
id|fip-&gt;fc_mdio
suffix:semicolon
id|io-&gt;iop_pdirc
op_or_assign
(paren
id|fip-&gt;fc_mdio
op_or
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
id|io-&gt;iop_pparc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdio
op_or
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
multiline_comment|/* Configure Serial Interface clock routing.&n;&t; * First, clear all FCC bits to zero,&n;&t; * then set the ones we want.&n;&t; */
id|immap-&gt;im_cpmux.cmx_fcr
op_and_assign
op_complement
(paren
id|fip-&gt;fc_clockmask
)paren
suffix:semicolon
id|immap-&gt;im_cpmux.cmx_fcr
op_or_assign
id|fip-&gt;fc_clockroute
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|init_fcc_param
id|init_fcc_param
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_struct
id|net_device
op_star
id|dev
comma
r_volatile
id|immap_t
op_star
id|immap
)paren
(brace
r_int
r_char
op_star
id|eap
suffix:semicolon
r_int
r_int
id|mem_addr
suffix:semicolon
id|bd_t
op_star
id|bd
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|fcc_enet_private
op_star
id|cep
suffix:semicolon
r_volatile
id|fcc_enet_t
op_star
id|ep
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
r_volatile
id|cpm8260_t
op_star
id|cp
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|ep
op_assign
id|cep-&gt;ep
suffix:semicolon
id|cp
op_assign
id|cpmp
suffix:semicolon
id|bd
op_assign
(paren
id|bd_t
op_star
)paren
id|__res
suffix:semicolon
multiline_comment|/* Zero the whole thing.....I must have missed some individually.&n;&t; * It works when I do this.&n;&t; */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|ep
comma
l_int|0
comma
r_sizeof
(paren
id|fcc_enet_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Allocate space for the buffer descriptors in the DP ram.&n;&t; * These are relative offsets in the DP ram address space.&n;&t; * Initialize base addresses for the buffer descriptors.&n;&t; */
macro_line|#if 0
multiline_comment|/* I really want to do this, but for some reason it doesn&squot;t&n;&t; * work with the data cache enabled, so I allocate from the&n;&t; * main memory instead.&n;&t; */
id|i
op_assign
id|m8260_cpm_dpalloc
c_func
(paren
r_sizeof
(paren
id|cbd_t
)paren
op_star
id|RX_RING_SIZE
comma
l_int|8
)paren
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_rbase
op_assign
(paren
id|uint
)paren
op_amp
id|immap-&gt;im_dprambase
(braket
id|i
)braket
suffix:semicolon
id|cep-&gt;rx_bd_base
op_assign
(paren
id|cbd_t
op_star
)paren
op_amp
id|immap-&gt;im_dprambase
(braket
id|i
)braket
suffix:semicolon
id|i
op_assign
id|m8260_cpm_dpalloc
c_func
(paren
r_sizeof
(paren
id|cbd_t
)paren
op_star
id|TX_RING_SIZE
comma
l_int|8
)paren
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_tbase
op_assign
(paren
id|uint
)paren
op_amp
id|immap-&gt;im_dprambase
(braket
id|i
)braket
suffix:semicolon
id|cep-&gt;tx_bd_base
op_assign
(paren
id|cbd_t
op_star
)paren
op_amp
id|immap-&gt;im_dprambase
(braket
id|i
)braket
suffix:semicolon
macro_line|#else
id|cep-&gt;rx_bd_base
op_assign
(paren
id|cbd_t
op_star
)paren
id|m8260_cpm_hostalloc
c_func
(paren
r_sizeof
(paren
id|cbd_t
)paren
op_star
id|RX_RING_SIZE
comma
l_int|8
)paren
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_rbase
op_assign
id|__pa
c_func
(paren
id|cep-&gt;rx_bd_base
)paren
suffix:semicolon
id|cep-&gt;tx_bd_base
op_assign
(paren
id|cbd_t
op_star
)paren
id|m8260_cpm_hostalloc
c_func
(paren
r_sizeof
(paren
id|cbd_t
)paren
op_star
id|TX_RING_SIZE
comma
l_int|8
)paren
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_tbase
op_assign
id|__pa
c_func
(paren
id|cep-&gt;tx_bd_base
)paren
suffix:semicolon
macro_line|#endif
id|cep-&gt;dirty_tx
op_assign
id|cep-&gt;cur_tx
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
id|cep-&gt;cur_rx
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_rstate
op_assign
(paren
id|CPMFCR_GBL
op_or
id|CPMFCR_EB
)paren
op_lshift
l_int|24
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_tstate
op_assign
(paren
id|CPMFCR_GBL
op_or
id|CPMFCR_EB
)paren
op_lshift
l_int|24
suffix:semicolon
multiline_comment|/* Set maximum bytes per receive buffer.&n;&t; * It must be a multiple of 32.&n;&t; */
id|ep-&gt;fen_genfcc.fcc_mrblr
op_assign
id|PKT_MAXBLR_SIZE
suffix:semicolon
multiline_comment|/* Allocate space in the reserved FCC area of DPRAM for the&n;&t; * internal buffers.  No one uses this space (yet), so we&n;&t; * can do this.  Later, we will add resource management for&n;&t; * this area.&n;&t; */
id|mem_addr
op_assign
id|CPM_FCC_SPECIAL_BASE
op_plus
(paren
id|fip-&gt;fc_fccnum
op_star
l_int|128
)paren
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_riptr
op_assign
id|mem_addr
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_tiptr
op_assign
id|mem_addr
op_plus
l_int|32
suffix:semicolon
id|ep-&gt;fen_padptr
op_assign
id|mem_addr
op_plus
l_int|64
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
(paren
id|immap-&gt;im_dprambase
(braket
(paren
id|mem_addr
op_plus
l_int|64
)paren
)braket
)paren
)paren
comma
l_int|0x88
comma
l_int|32
)paren
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_rbptr
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_tbptr
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_rcrc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_tcrc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_res1
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_genfcc.fcc_res2
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_camptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CAM isn&squot;t used in this driver */
multiline_comment|/* Set CRC preset and mask.&n;&t;*/
id|ep-&gt;fen_cmask
op_assign
l_int|0xdebb20e3
suffix:semicolon
id|ep-&gt;fen_cpres
op_assign
l_int|0xffffffff
suffix:semicolon
id|ep-&gt;fen_crcec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CRC Error counter */
id|ep-&gt;fen_alec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* alignment error counter */
id|ep-&gt;fen_disfc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* discard frame counter */
id|ep-&gt;fen_retlim
op_assign
l_int|15
suffix:semicolon
multiline_comment|/* Retry limit threshold */
id|ep-&gt;fen_pper
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Normal persistence */
multiline_comment|/* Clear hash filter tables.&n;&t;*/
id|ep-&gt;fen_gaddrh
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_gaddrl
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_iaddrh
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_iaddrl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear the Out-of-sequence TxBD.&n;&t;*/
id|ep-&gt;fen_tfcstat
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_tfclen
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_tfcptr
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_mflr
op_assign
id|PKT_MAXBUF_SIZE
suffix:semicolon
multiline_comment|/* maximum frame length register */
id|ep-&gt;fen_minflr
op_assign
id|PKT_MINBUF_SIZE
suffix:semicolon
multiline_comment|/* minimum frame length register */
multiline_comment|/* Set Ethernet station address.&n;&t; *&n;&t; * This is supplied in the board information structure, so we&n;&t; * copy that into the controller.&n;&t; * So, far we have only been given one Ethernet address. We make&n;&t; * it unique by setting a few bits in the upper byte of the&n;&t; * non-static part of the address.&n;&t; */
id|eap
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
(paren
id|ep-&gt;fen_paddrh
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|3
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|bd-&gt;bi_enetaddr
(braket
id|i
)braket
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_or_assign
(paren
l_int|1
op_lshift
(paren
l_int|7
op_minus
id|fip-&gt;fc_fccnum
)paren
)paren
suffix:semicolon
op_star
id|eap
op_increment
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
(brace
op_star
id|eap
op_increment
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|bd-&gt;bi_enetaddr
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|ep-&gt;fen_taddrh
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_taddrm
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_taddrl
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_maxd1
op_assign
id|PKT_MAXDMA_SIZE
suffix:semicolon
multiline_comment|/* maximum DMA1 length */
id|ep-&gt;fen_maxd2
op_assign
id|PKT_MAXDMA_SIZE
suffix:semicolon
multiline_comment|/* maximum DMA2 length */
multiline_comment|/* Clear stat counters, in case we ever enable RMON.&n;&t;*/
id|ep-&gt;fen_octc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_colc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_broc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_mulc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_uspc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_frgc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_ospc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_jbrc
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_p64c
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_p65c
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_p128c
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_p256c
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_p512c
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_p1024c
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_rfthr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Suggested by manual */
id|ep-&gt;fen_rfcnt
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;fen_cftype
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now allocate the host memory pages and initialize the&n;&t; * buffer descriptors.&n;&t; */
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Initialize the BD for every fragment in the page.&n;&t;&t;*/
id|bdp-&gt;cbd_sc
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;cbd_datlen
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
l_int|0
suffix:semicolon
id|bdp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Set the last buffer to wrap.&n;&t;*/
id|bdp
op_decrement
suffix:semicolon
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_SC_WRAP
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FCC_ENET_RX_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Allocate a page.&n;&t;&t;*/
id|mem_addr
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Initialize the BD for every fragment in the page.&n;&t;&t;*/
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|FCC_ENET_RX_FRPPG
suffix:semicolon
id|j
op_increment
)paren
(brace
id|bdp-&gt;cbd_sc
op_assign
id|BD_ENET_RX_EMPTY
op_or
id|BD_ENET_RX_INTR
suffix:semicolon
id|bdp-&gt;cbd_datlen
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
id|__pa
c_func
(paren
id|mem_addr
)paren
suffix:semicolon
id|mem_addr
op_add_assign
id|FCC_ENET_RX_FRSIZE
suffix:semicolon
id|bdp
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the last buffer to wrap.&n;&t;*/
id|bdp
op_decrement
suffix:semicolon
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_SC_WRAP
suffix:semicolon
multiline_comment|/* Let&squot;s re-initialize the channel now.  We have to do it later&n;&t; * than the manual describes because we have just now finished&n;&t; * the BD initialization.&n;&t; */
id|cp-&gt;cp_cpcr
op_assign
id|mk_cr_cmd
c_func
(paren
id|fip-&gt;fc_cpmpage
comma
id|fip-&gt;fc_cpmblock
comma
l_int|0x0c
comma
id|CPM_CR_INIT_TRX
)paren
op_or
id|CPM_CR_FLG
suffix:semicolon
r_while
c_loop
(paren
id|cp-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
id|cep-&gt;skb_cur
op_assign
id|cep-&gt;skb_dirty
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Let &squot;er rip.&n;*/
r_static
r_void
id|__init
DECL|function|init_fcc_startup
id|init_fcc_startup
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_volatile
id|fcc_t
op_star
id|fccp
suffix:semicolon
r_struct
id|fcc_enet_private
op_star
id|cep
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|fcc_enet_private
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|fccp
op_assign
id|cep-&gt;fccp
suffix:semicolon
id|fccp-&gt;fcc_fcce
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Clear any pending events */
multiline_comment|/* Enable interrupts for transmit error, complete frame&n;&t; * received, and any transmit buffer we have also set the&n;&t; * interrupt flag.&n;&t; */
id|fccp-&gt;fcc_fccm
op_assign
(paren
id|FCC_ENET_TXE
op_or
id|FCC_ENET_RXF
op_or
id|FCC_ENET_TXB
)paren
suffix:semicolon
multiline_comment|/* Install our interrupt handler.&n;&t;*/
r_if
c_cond
(paren
id|request_8xxirq
c_func
(paren
id|fip-&gt;fc_interrupt
comma
id|fcc_enet_interrupt
comma
l_int|0
comma
l_string|&quot;fenet&quot;
comma
id|dev
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Can&squot;t get FCC IRQ %d&bslash;n&quot;
comma
id|fip-&gt;fc_interrupt
)paren
suffix:semicolon
multiline_comment|/* Set GFMR to enable Ethernet operating mode.&n;&t; */
id|fccp-&gt;fcc_gfmr
op_assign
(paren
id|FCC_GFMR_TCI
op_or
id|FCC_GFMR_MODE_ENET
)paren
suffix:semicolon
multiline_comment|/* Set sync/delimiters.&n;&t;*/
id|fccp-&gt;fcc_fdsr
op_assign
l_int|0xd555
suffix:semicolon
multiline_comment|/* Set protocol specific processing mode for Ethernet.&n;&t; * This has to be adjusted for Full Duplex operation after we can&n;&t; * determine how to detect that.&n;&t; */
id|fccp-&gt;fcc_fpsmr
op_assign
id|FCC_PSMR_ENCRC
suffix:semicolon
multiline_comment|/* And last, enable the transmit and receive processing.&n;&t;*/
id|fccp-&gt;fcc_gfmr
op_or_assign
(paren
id|FCC_GFMR_ENR
op_or
id|FCC_GFMR_ENT
)paren
suffix:semicolon
)brace
multiline_comment|/* MII command/status interface.&n; * I&squot;m not going to describe all of the details.  You can find the&n; * protocol definition in many other places, including the data sheet&n; * of most PHY parts.&n; * I wonder what &quot;they&quot; were thinking (maybe weren&squot;t) when they leave&n; * the I2C in the CPM but I have to toggle these bits......&n; */
r_static
id|uint
DECL|function|mii_send_receive
id|mii_send_receive
c_func
(paren
id|fcc_info_t
op_star
id|fip
comma
id|uint
id|cmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|uint
id|retval
suffix:semicolon
r_int
id|read_op
comma
id|i
suffix:semicolon
r_volatile
id|immap_t
op_star
id|immap
suffix:semicolon
r_volatile
id|iop8260_t
op_star
id|io
suffix:semicolon
id|immap
op_assign
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
suffix:semicolon
id|io
op_assign
op_amp
id|immap-&gt;im_ioport
suffix:semicolon
multiline_comment|/* When we get here, both clock and data are high, outputs.&n;&t; * Output is open drain.&n;&t; * Data transitions on high-&gt;low clock, is valid on low-&gt;high clock.&n;&t; * Spec says edge transitions no closer than 160 nSec, minimum clock&n;&t; * cycle 400 nSec.  I could only manage about 500 nSec edges with&n;&t; * an XOR loop, so I won&squot;t worry about delays yet.&n;&t; * I disable interrupts during bit flipping to ensure atomic&n;&t; * updates of the registers.  I do lots of interrupt disable/enable&n;&t; * to ensure we don&squot;t hang out too long with interrupts disabled.&n;&t; */
multiline_comment|/* First, crank out 32 1-bits as preamble.&n;&t; * This is 64 transitions to clock the bits, with clock/data&n;&t; * left high.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|io-&gt;iop_pdatc
op_xor_assign
id|fip-&gt;fc_mdck
suffix:semicolon
id|udelay
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|read_op
op_assign
(paren
(paren
id|cmd
op_amp
l_int|0xf0000000
)paren
op_eq
l_int|0x60000000
)paren
suffix:semicolon
multiline_comment|/* We return the command word on a write op, or the command portion&n;&t; * plus the new data on a read op.  This is what the 8xx FEC does,&n;&t; * and it allows the functions to simply look at the returned value&n;&t; * and know the PHY/register as well.&n;&t; */
r_if
c_cond
(paren
id|read_op
)paren
id|retval
op_assign
id|cmd
suffix:semicolon
r_else
id|retval
op_assign
(paren
id|cmd
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Clock out the first 16 MS bits of the command.&n;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x80000000
)paren
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdio
suffix:semicolon
r_else
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdio
)paren
suffix:semicolon
id|cmd
op_lshift_assign
l_int|1
suffix:semicolon
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdck
suffix:semicolon
id|udelay
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Do the turn-around.  If read op, we make the IO and input.&n;&t; * If write op, do the 1/0 thing.&n;&t; */
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_op
)paren
id|io-&gt;iop_pdirc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdio
)paren
suffix:semicolon
r_else
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdio
suffix:semicolon
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdck
suffix:semicolon
multiline_comment|/* I do this mainly to get just a little delay.&n;&t;*/
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
id|io-&gt;iop_pdirc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdio
)paren
suffix:semicolon
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdck
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* For read, clock in 16 bits.  For write, clock out&n;&t; * rest of command.&n;&t; */
r_if
c_cond
(paren
id|read_op
)paren
(brace
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdck
suffix:semicolon
id|udelay
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|retval
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;iop_pdatc
op_amp
id|fip-&gt;fc_mdio
)paren
id|retval
op_or_assign
l_int|1
suffix:semicolon
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x80000000
)paren
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdio
suffix:semicolon
r_else
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdio
)paren
suffix:semicolon
id|cmd
op_lshift_assign
l_int|1
suffix:semicolon
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdck
suffix:semicolon
id|udelay
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|io-&gt;iop_pdatc
op_and_assign
op_complement
(paren
id|fip-&gt;fc_mdck
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Some diagrams show two 1 bits for &quot;idle&quot;.  I don&squot;t know if&n;&t; * this is really necessary or if it was just to indicate nothing&n;&t; * is going to happen for a while.&n;&t; * Make the data pin an output, set the data high, and clock it.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|io-&gt;iop_pdatc
op_or_assign
id|fip-&gt;fc_mdio
suffix:semicolon
id|io-&gt;iop_pdirc
op_or_assign
id|fip-&gt;fc_mdio
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|io-&gt;iop_pdatc
op_xor_assign
id|fip-&gt;fc_mdck
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* We exit with the same conditions as entry.&n;&t;*/
r_return
id|retval
suffix:semicolon
)brace
eof
