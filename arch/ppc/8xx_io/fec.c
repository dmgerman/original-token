multiline_comment|/*&n; * Fast Ethernet Controller (FECC) driver for Motorola MPC8xx.&n; * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)&n; *&n; * This version of the driver is specific to the FADS implementation,&n; * since the board contains control registers external to the processor&n; * for the control of the LevelOne LXT970 transceiver.  The MPC860T manual&n; * describes connections using the internal parallel port I/O, which&n; * is basically all of Port D.&n; *&n; * Right now, I am very watseful with the buffers.  I allocate memory&n; * pages and then divide them into 2K frame buffers.  This way I know I&n; * have buffers large enough to hold one frame within one buffer descriptor.&n; * Once I get this working, I will use 64 or 128 byte CPM buffers, which&n; * will be much more memory efficient and will easily handle lots of&n; * small packets.&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;asm/8xx_immap.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/fads.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;commproc.h&quot;
multiline_comment|/* The number of Tx and Rx buffers.  These are allocated from the page&n; * pool.  The code may assume these are power of two, so it it best&n; * to keep them that size.&n; * We don&squot;t need to allocate pages for the transmitter.  We just use&n; * the skbuffer directly.&n; */
macro_line|#if 1
DECL|macro|FEC_ENET_RX_PAGES
mdefine_line|#define FEC_ENET_RX_PAGES&t;4
DECL|macro|FEC_ENET_RX_FRSIZE
mdefine_line|#define FEC_ENET_RX_FRSIZE&t;2048
DECL|macro|FEC_ENET_RX_FRPPG
mdefine_line|#define FEC_ENET_RX_FRPPG&t;(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;&t;(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
DECL|macro|TX_RING_SIZE
mdefine_line|#define TX_RING_SIZE&t;&t;8&t;/* Must be power of two */
DECL|macro|TX_RING_MOD_MASK
mdefine_line|#define TX_RING_MOD_MASK&t;7&t;/*   for this to work */
macro_line|#else
DECL|macro|FEC_ENET_RX_PAGES
mdefine_line|#define FEC_ENET_RX_PAGES&t;16
DECL|macro|FEC_ENET_RX_FRSIZE
mdefine_line|#define FEC_ENET_RX_FRSIZE&t;2048
DECL|macro|FEC_ENET_RX_FRPPG
mdefine_line|#define FEC_ENET_RX_FRPPG&t;(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;&t;(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
DECL|macro|TX_RING_SIZE
mdefine_line|#define TX_RING_SIZE&t;&t;16&t;/* Must be power of two */
DECL|macro|TX_RING_MOD_MASK
mdefine_line|#define TX_RING_MOD_MASK&t;15&t;/*   for this to work */
macro_line|#endif
multiline_comment|/* Interrupt events/masks.&n;*/
DECL|macro|FEC_ENET_HBERR
mdefine_line|#define FEC_ENET_HBERR&t;((uint)0x80000000)&t;/* Heartbeat error */
DECL|macro|FEC_ENET_BABR
mdefine_line|#define FEC_ENET_BABR&t;((uint)0x40000000)&t;/* Babbling receiver */
DECL|macro|FEC_ENET_BABT
mdefine_line|#define FEC_ENET_BABT&t;((uint)0x20000000)&t;/* Babbling transmitter */
DECL|macro|FEC_ENET_GRA
mdefine_line|#define FEC_ENET_GRA&t;((uint)0x10000000)&t;/* Graceful stop complete */
DECL|macro|FEC_ENET_TXF
mdefine_line|#define FEC_ENET_TXF&t;((uint)0x08000000)&t;/* Full frame transmitted */
DECL|macro|FEC_ENET_TXB
mdefine_line|#define FEC_ENET_TXB&t;((uint)0x04000000)&t;/* A buffer was transmitted */
DECL|macro|FEC_ENET_RXF
mdefine_line|#define FEC_ENET_RXF&t;((uint)0x02000000)&t;/* Full frame received */
DECL|macro|FEC_ENET_RXB
mdefine_line|#define FEC_ENET_RXB&t;((uint)0x01000000)&t;/* A buffer was received */
DECL|macro|FEC_ENET_MII
mdefine_line|#define FEC_ENET_MII&t;((uint)0x00800000)&t;/* MII interrupt */
DECL|macro|FEC_ENET_EBERR
mdefine_line|#define FEC_ENET_EBERR&t;((uint)0x00400000)&t;/* SDMA bus error */
multiline_comment|/* The FEC stores dest/src/type, data, and checksum for receive packets.&n; */
DECL|macro|PKT_MAXBUF_SIZE
mdefine_line|#define PKT_MAXBUF_SIZE&t;&t;1518
DECL|macro|PKT_MINBUF_SIZE
mdefine_line|#define PKT_MINBUF_SIZE&t;&t;64
DECL|macro|PKT_MAXBLR_SIZE
mdefine_line|#define PKT_MAXBLR_SIZE&t;&t;1520
multiline_comment|/* The FEC buffer descriptors track the ring buffers.  The rx_bd_base and&n; * tx_bd_base always point to the base of the buffer descriptors.  The&n; * cur_rx and cur_tx point to the currently available buffer.&n; * The dirty_tx tracks the current buffer that is being sent by the&n; * controller.  The cur_tx and dirty_tx are equal under both completely&n; * empty and completely full conditions.  The empty/ready indicator in&n; * the buffer descriptor determines the actual condition.&n; */
DECL|struct|fec_enet_private
r_struct
id|fec_enet_private
(brace
multiline_comment|/* The saved address of a sent-in-place packet/buffer, for skfree(). */
DECL|member|tx_skbuff
r_struct
id|sk_buff
op_star
id|tx_skbuff
(braket
id|TX_RING_SIZE
)braket
suffix:semicolon
DECL|member|skb_cur
id|ushort
id|skb_cur
suffix:semicolon
DECL|member|skb_dirty
id|ushort
id|skb_dirty
suffix:semicolon
multiline_comment|/* CPM dual port RAM relative addresses.&n;&t;*/
DECL|member|rx_bd_base
id|cbd_t
op_star
id|rx_bd_base
suffix:semicolon
multiline_comment|/* Address of Rx and Tx buffers. */
DECL|member|tx_bd_base
id|cbd_t
op_star
id|tx_bd_base
suffix:semicolon
DECL|member|cur_rx
DECL|member|cur_tx
id|cbd_t
op_star
id|cur_rx
comma
op_star
id|cur_tx
suffix:semicolon
multiline_comment|/* The next free ring entry */
DECL|member|dirty_tx
id|cbd_t
op_star
id|dirty_tx
suffix:semicolon
multiline_comment|/* The ring entries to be free()ed. */
DECL|member|sccp
id|scc_t
op_star
id|sccp
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|tx_full
r_char
id|tx_full
suffix:semicolon
DECL|member|lock
r_int
r_int
id|lock
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|fec_enet_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|fec_enet_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|fec_enet_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|fec_enet_mii
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|fec_enet_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|fec_enet_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|fec_enet_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
DECL|variable|my_enet_addr
r_static
id|ushort
id|my_enet_addr
(braket
)braket
op_assign
(brace
l_int|0x0800
comma
l_int|0x3e26
comma
l_int|0x1559
)brace
suffix:semicolon
multiline_comment|/* MII processing.  We keep this as simple as possible.  Requests are&n; * placed on the list (if there is room).  When the request is finished&n; * by the MII, an optional function may be called.&n; */
DECL|struct|mii_list
r_typedef
r_struct
id|mii_list
(brace
DECL|member|mii_regval
id|uint
id|mii_regval
suffix:semicolon
DECL|member|mii_func
r_void
(paren
op_star
id|mii_func
)paren
(paren
id|uint
id|val
)paren
suffix:semicolon
DECL|member|mii_next
r_struct
id|mii_list
op_star
id|mii_next
suffix:semicolon
DECL|typedef|mii_list_t
)brace
id|mii_list_t
suffix:semicolon
DECL|macro|NMII
mdefine_line|#define&t;&t;NMII&t;10
DECL|variable|mii_cmds
id|mii_list_t
id|mii_cmds
(braket
id|NMII
)braket
suffix:semicolon
DECL|variable|mii_free
id|mii_list_t
op_star
id|mii_free
suffix:semicolon
DECL|variable|mii_head
id|mii_list_t
op_star
id|mii_head
suffix:semicolon
DECL|variable|mii_tail
id|mii_list_t
op_star
id|mii_tail
suffix:semicolon
r_static
r_int
id|mii_queue
c_func
(paren
r_int
id|request
comma
r_void
(paren
op_star
id|func
)paren
(paren
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* Make MII read/write commands for the FEC.&n;*/
DECL|macro|mk_mii_read
mdefine_line|#define mk_mii_read(REG)&t;(0x60020000 | ((REG &amp; 0x1f) &lt;&lt; 18))
DECL|macro|mk_mii_write
mdefine_line|#define mk_mii_write(REG, VAL)&t;(0x50020000 | ((REG &amp; 0x1f) &lt;&lt; 18) | &bslash;&n;&t;&t;&t;&t;&t;&t;(VAL &amp; 0xffff))
r_static
r_int
DECL|function|fec_enet_open
id|fec_enet_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* I should reset the ring buffers here, but I don&squot;t yet know&n;&t; * a simple way to do that.&n;&t; */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Always succeed */
)brace
r_static
r_int
DECL|function|fec_enet_start_xmit
id|fec_enet_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|fec_enet_private
op_star
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Transmitter timeout, serious problems. */
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|20
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fep-&gt;stats.tx_errors
op_increment
suffix:semicolon
macro_line|#ifndef final_version
(brace
r_int
id|i
suffix:semicolon
id|cbd_t
op_star
id|bdp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Ring data dump: cur_tx %x%s cur_rx %x.&bslash;n&quot;
comma
id|fep-&gt;cur_tx
comma
id|fep-&gt;tx_full
ques
c_cond
l_string|&quot; (full)&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|fep-&gt;cur_rx
)paren
suffix:semicolon
id|bdp
op_assign
id|fep-&gt;tx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%04x %04x %08x&bslash;n&quot;
comma
id|bdp-&gt;cbd_sc
comma
id|bdp-&gt;cbd_datlen
comma
id|bdp-&gt;cbd_bufaddr
)paren
suffix:semicolon
id|bdp
op_assign
id|fep-&gt;rx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%04x %04x %08x&bslash;n&quot;
comma
id|bdp-&gt;cbd_sc
comma
id|bdp-&gt;cbd_datlen
comma
id|bdp-&gt;cbd_bufaddr
)paren
suffix:semicolon
)brace
macro_line|#endif
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Block a timer-based transmit from overlapping.  This could better be&n;&t;   done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well. */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|fep-&gt;lock
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: tx queue lock!.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* don&squot;t clear dev-&gt;tbusy flag. */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Fill in a Tx ring entry */
id|bdp
op_assign
id|fep-&gt;cur_tx
suffix:semicolon
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
(brace
multiline_comment|/* Ooops.  All transmit buffers are full.  Bail out.&n;&t;&t; * This should not happen, since dev-&gt;tbusy should be set.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: tx queue full!.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fep-&gt;lock
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Clear all of the status flags.&n;&t; */
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_TX_STATS
suffix:semicolon
multiline_comment|/* Set buffer length and buffer pointer.&n;&t;*/
id|bdp-&gt;cbd_bufaddr
op_assign
id|__pa
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
id|bdp-&gt;cbd_datlen
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* Save skb pointer.&n;&t;*/
id|fep-&gt;tx_skbuff
(braket
id|fep-&gt;skb_cur
)braket
op_assign
id|skb
suffix:semicolon
id|fep-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|fep-&gt;skb_cur
op_assign
(paren
id|fep-&gt;skb_cur
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
suffix:semicolon
multiline_comment|/* Push the data cache so the CPM does not get stale memory&n;&t; * data.&n;&t; */
multiline_comment|/*flush_dcache_range(skb-&gt;data, skb-&gt;data + skb-&gt;len);*/
multiline_comment|/* Send it on its way.  Tell CPM its ready, interrupt when done,&n;&t; * its the last BD of the frame, and to put the CRC on the end.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bdp-&gt;cbd_sc
op_or_assign
(paren
id|BD_ENET_TX_READY
op_or
id|BD_ENET_TX_INTR
op_or
id|BD_ENET_TX_LAST
op_or
id|BD_ENET_TX_TC
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
(paren
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
)paren
op_member_access_from_pointer
id|fec_x_des_active
op_assign
l_int|0x01000000
suffix:semicolon
multiline_comment|/* If this was the last BD in the ring, start at the beginning again.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_WRAP
)paren
id|bdp
op_assign
id|fep-&gt;tx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
id|fep-&gt;lock
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
id|fep-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
r_else
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|fep-&gt;cur_tx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The interrupt handler.&n; * This is called from the MPC core interrupt.&n; */
r_static
r_void
DECL|function|fec_enet_interrupt
id|fec_enet_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|fec_enet_private
op_star
id|fep
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
r_volatile
id|fec_t
op_star
id|ep
suffix:semicolon
id|uint
id|int_events
suffix:semicolon
r_int
id|c
op_assign
l_int|0
suffix:semicolon
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ep
op_assign
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Re-entering the interrupt handler.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Get the interrupt events that caused us to be here.&n;&t;*/
r_while
c_loop
(paren
(paren
id|int_events
op_assign
id|ep-&gt;fec_ievent
)paren
op_ne
l_int|0
)paren
(brace
id|ep-&gt;fec_ievent
op_assign
id|int_events
suffix:semicolon
r_if
c_cond
(paren
(paren
id|int_events
op_amp
(paren
id|FEC_ENET_HBERR
op_or
id|FEC_ENET_BABR
op_or
id|FEC_ENET_BABT
op_or
id|FEC_ENET_EBERR
)paren
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;FEC ERROR %x&bslash;n&quot;
comma
id|int_events
)paren
suffix:semicolon
multiline_comment|/* Handle receive event in its own function.&n;&t;*/
r_if
c_cond
(paren
id|int_events
op_amp
(paren
id|FEC_ENET_RXF
op_or
id|FEC_ENET_RXB
)paren
)paren
id|fec_enet_rx
c_func
(paren
id|dev_id
)paren
suffix:semicolon
multiline_comment|/* Transmit OK, or non-fatal error.  Update the buffer descriptors.&n;&t; * FEC handles all errors, we just discover them as part of the&n;&t; * transmit process.&n;&t; */
r_if
c_cond
(paren
id|int_events
op_amp
(paren
id|FEC_ENET_TXF
op_or
id|FEC_ENET_TXB
)paren
)paren
(brace
id|bdp
op_assign
id|fep-&gt;dirty_tx
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if 1
r_if
c_cond
(paren
id|bdp
op_eq
id|fep-&gt;cur_tx
)paren
r_break
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_increment
id|c
OG
l_int|1
)paren
(brace
multiline_comment|/*we go here when an it has been lost*/
)brace
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_HB
)paren
multiline_comment|/* No heartbeat */
id|fep-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_LC
)paren
multiline_comment|/* Late collision */
id|fep-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_RL
)paren
multiline_comment|/* Retrans limit */
id|fep-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_UN
)paren
multiline_comment|/* Underrun */
id|fep-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_CSL
)paren
multiline_comment|/* Carrier lost */
id|fep-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
id|fep-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|fep-&gt;stats.tx_packets
op_increment
suffix:semicolon
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
id|printk
c_func
(paren
l_string|&quot;HEY! Enet xmit interrupt and TX_READY.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Deferred means some collisions occurred during transmit,&n;&t;&t; * but we eventually sent the packet OK.&n;&t;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_DEF
)paren
id|fep-&gt;stats.collisions
op_increment
suffix:semicolon
multiline_comment|/* Free the sk buffer associated with this last transmit.&n;&t;&t; */
id|dev_kfree_skb
c_func
(paren
id|fep-&gt;tx_skbuff
(braket
id|fep-&gt;skb_dirty
)braket
multiline_comment|/*, FREE_WRITE*/
)paren
suffix:semicolon
id|fep-&gt;skb_dirty
op_assign
(paren
id|fep-&gt;skb_dirty
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
suffix:semicolon
multiline_comment|/* Update pointer to next buffer descriptor to be transmitted.&n;&t;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_WRAP
)paren
id|bdp
op_assign
id|fep-&gt;tx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
multiline_comment|/* Since we have freed up a buffer, the ring is no longer&n;&t;&t; * full.&n;&t;&t; */
r_if
c_cond
(paren
id|fep-&gt;tx_full
op_logical_and
id|dev-&gt;tbusy
)paren
(brace
id|fep-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
id|fep-&gt;dirty_tx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|bdp
op_eq
id|fep-&gt;cur_tx
)paren
r_break
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*while (bdp-&gt;cbd_sc&amp;BD_ENET_TX_READY)==0*/
)brace
multiline_comment|/* if tx events */
r_if
c_cond
(paren
id|int_events
op_amp
id|FEC_ENET_MII
)paren
id|fec_enet_mii
c_func
(paren
id|dev_id
)paren
suffix:semicolon
)brace
multiline_comment|/* while any events */
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* During a receive, the cur_rx points to the current incoming buffer.&n; * When we update through the ring, if the next incoming buffer has&n; * not been given to the system, we just set the empty indicator,&n; * effectively tossing the packet.&n; */
r_static
r_int
DECL|function|fec_enet_rx
id|fec_enet_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|fec_enet_private
op_star
id|fep
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ushort
id|pkt_len
suffix:semicolon
r_volatile
id|fec_t
op_star
id|ep
suffix:semicolon
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ep
op_assign
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
suffix:semicolon
multiline_comment|/* First, grab all of the stats for the incoming packet.&n;&t; * These get messed up if we get called due to a busy condition.&n;&t; */
id|bdp
op_assign
id|fep-&gt;cur_rx
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_EMPTY
)paren
r_break
suffix:semicolon
macro_line|#ifndef final_version
multiline_comment|/* Since we have allocated space to hold a complete frame,&n;&t; * the last indicator should be set.&n;&t; */
r_if
c_cond
(paren
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_LAST
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;FEC ENET: rcv is not +last&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Frame too long or too short.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
(paren
id|BD_ENET_RX_LG
op_or
id|BD_ENET_RX_SH
)paren
)paren
id|fep-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_NO
)paren
multiline_comment|/* Frame alignment */
id|fep-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_CR
)paren
multiline_comment|/* CRC Error */
id|fep-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_OV
)paren
multiline_comment|/* FIFO overrun */
id|fep-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
multiline_comment|/* Report late collisions as a frame error.&n;&t; * On this error, the BD is closed, but we don&squot;t know what we&n;&t; * have in the buffer.  So, just drop this frame on the floor.&n;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_CL
)paren
(brace
id|fep-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Process the incoming frame.&n;&t;&t;*/
id|fep-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|pkt_len
op_assign
id|bdp-&gt;cbd_datlen
suffix:semicolon
id|fep-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
multiline_comment|/* This does 16 byte alignment, exactly what we need.&n;&t;&t;*/
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fep-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Make room */
id|eth_copy_and_sum
c_func
(paren
id|skb
comma
(paren
r_int
r_char
op_star
)paren
id|__va
c_func
(paren
id|bdp-&gt;cbd_bufaddr
)paren
comma
id|pkt_len
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear the status flags for this buffer.&n;&t;*/
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_RX_STATS
suffix:semicolon
multiline_comment|/* Mark the buffer empty.&n;&t;*/
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_ENET_RX_EMPTY
suffix:semicolon
multiline_comment|/* Update BD pointer to next entry.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_WRAP
)paren
id|bdp
op_assign
id|fep-&gt;rx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
macro_line|#if 1
multiline_comment|/* Doing this here will keep the FEC running while we process&n;&t; * incoming frames.  On a heavily loaded network, we should be&n;&t; * able to keep up at the expense of system resources.&n;&t; */
id|ep-&gt;fec_r_des_active
op_assign
l_int|0x01000000
suffix:semicolon
macro_line|#endif
)brace
id|fep-&gt;cur_rx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Doing this here will allow us to process all frames in the&n;&t; * ring before the FEC is allowed to put more there.  On a heavily&n;&t; * loaded network, some frames may be lost.  Unfortunately, this&n;&t; * increases the interrupt overhead since we can potentially work&n;&t; * our way back to the interrupt return only to come right back&n;&t; * here.&n;&t; */
id|ep-&gt;fec_r_des_active
op_assign
l_int|0x01000000
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|fec_enet_mii
id|fec_enet_mii
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|fec_enet_private
op_star
id|fep
suffix:semicolon
r_volatile
id|fec_t
op_star
id|ep
suffix:semicolon
id|mii_list_t
op_star
id|mip
suffix:semicolon
id|uint
id|mii_reg
suffix:semicolon
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ep
op_assign
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
suffix:semicolon
id|mii_reg
op_assign
id|ep-&gt;fec_mii_data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mip
op_assign
id|mii_head
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MII and no head!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mip-&gt;mii_func
op_ne
l_int|NULL
)paren
(paren
op_star
(paren
id|mip-&gt;mii_func
)paren
)paren
(paren
id|mii_reg
)paren
suffix:semicolon
id|mii_head
op_assign
id|mip-&gt;mii_next
suffix:semicolon
id|mip-&gt;mii_next
op_assign
id|mii_free
suffix:semicolon
id|mii_free
op_assign
id|mip
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mip
op_assign
id|mii_head
)paren
op_ne
l_int|NULL
)paren
id|ep-&gt;fec_mii_data
op_assign
id|mip-&gt;mii_regval
suffix:semicolon
)brace
r_static
r_int
DECL|function|mii_queue
id|mii_queue
c_func
(paren
r_int
id|regval
comma
r_void
(paren
op_star
id|func
)paren
(paren
r_int
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|mii_list_t
op_star
id|mip
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mip
op_assign
id|mii_free
)paren
op_ne
l_int|NULL
)paren
(brace
id|mii_free
op_assign
id|mip-&gt;mii_next
suffix:semicolon
id|mip-&gt;mii_regval
op_assign
id|regval
suffix:semicolon
id|mip-&gt;mii_func
op_assign
id|func
suffix:semicolon
id|mip-&gt;mii_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mii_head
)paren
(brace
id|mii_tail-&gt;mii_next
op_assign
id|mip
suffix:semicolon
id|mii_tail
op_assign
id|mip
suffix:semicolon
)brace
r_else
(brace
id|mii_head
op_assign
id|mii_tail
op_assign
id|mip
suffix:semicolon
(paren
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
)paren
op_member_access_from_pointer
id|fec_mii_data
op_assign
id|regval
suffix:semicolon
)brace
)brace
r_else
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|mii_status
id|mii_status
c_func
(paren
id|uint
id|mii_reg
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* status register.&n;&t;&t;*/
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0004
)paren
id|printk
c_func
(paren
l_string|&quot;link up&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;link down&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0010
)paren
id|printk
c_func
(paren
l_string|&quot;,remote fault&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0020
)paren
id|printk
c_func
(paren
l_string|&quot;,auto complete&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|0x14
)paren
(brace
multiline_comment|/* Extended chip status register.&n;&t;&t;*/
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0800
)paren
id|printk
c_func
(paren
l_string|&quot;100 Mbps&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;10 Mbps&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x1000
)paren
id|printk
c_func
(paren
l_string|&quot;, Full-Duplex&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, Half-Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|mii_startup_cmds
id|mii_startup_cmds
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Read status registers to clear any pending interrupt.&n;&t;*/
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|1
)paren
comma
id|mii_status
)paren
suffix:semicolon
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|18
)paren
comma
id|mii_status
)paren
suffix:semicolon
multiline_comment|/* Read extended chip status register.&n;&t;*/
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|0x14
)paren
comma
id|mii_status
)paren
suffix:semicolon
multiline_comment|/* Enable Link status change interrupts.&n;&t;mii_queue(mk_mii_write(0x11, 0x0002), NULL);&n;&t;*/
)brace
multiline_comment|/* This supports the mii_link interrupt below.&n; * We should get called three times.  Once for register 1, once for&n; * register 18, and once for register 20.&n; */
DECL|variable|mii_saved_reg1
r_static
id|uint
id|mii_saved_reg1
suffix:semicolon
r_static
r_void
DECL|function|mii_relink
id|mii_relink
c_func
(paren
id|uint
id|mii_reg
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Just save the status register and get out.&n;&t;&t;*/
id|mii_saved_reg1
op_assign
id|mii_reg
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|18
)paren
(brace
multiline_comment|/* Not much here, but has to be read to clear the&n;&t;&t; * interrupt condition.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mii_reg
op_amp
l_int|0x8000
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;fec: re-link and no IRQ?&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mii_reg
op_amp
l_int|0x4000
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;fec: no PHY power?&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|mii_reg
op_rshift
l_int|18
)paren
op_amp
l_int|0x1f
)paren
op_eq
l_int|20
)paren
(brace
multiline_comment|/* Extended chip status register.&n;&t;&t; * OK, now we have it all, so figure out what is going on.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;fec: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0004
)paren
id|printk
c_func
(paren
l_string|&quot;link up&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;link down&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0010
)paren
id|printk
c_func
(paren
l_string|&quot;, remote fault&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_saved_reg1
op_amp
l_int|0x0020
)paren
id|printk
c_func
(paren
l_string|&quot;, auto complete&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x0800
)paren
id|printk
c_func
(paren
l_string|&quot;, 100 Mbps&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, 10 Mbps&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mii_reg
op_amp
l_int|0x1000
)paren
id|printk
c_func
(paren
l_string|&quot;, Full-Duplex&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, Half-Duplex&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This interrupt occurs when the LTX970 detects a link change.&n;*/
r_static
r_void
DECL|function|mii_link_interrupt
id|mii_link_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|fec_enet_private
op_star
id|fep
suffix:semicolon
r_volatile
id|fec_t
op_star
id|ep
suffix:semicolon
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ep
op_assign
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
suffix:semicolon
multiline_comment|/* We need to sequentially read registers 1 and 18 to clear&n;&t; * the interrupt.  We don&squot;t need to do that here because this&n;&t; * is an edge triggered interrupt that has already been acknowledged&n;&t; * by the top level handler.  We also read the extended status&n;&t; * register 20.  We just queue the commands and let them happen&n;&t; * as part of the &quot;normal&quot; processing.&n;&t; */
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|1
)paren
comma
id|mii_relink
)paren
suffix:semicolon
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|18
)paren
comma
id|mii_relink
)paren
suffix:semicolon
id|mii_queue
c_func
(paren
id|mk_mii_read
c_func
(paren
l_int|20
)paren
comma
id|mii_relink
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|fec_enet_close
id|fec_enet_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* Don&squot;t know what to do yet.&n;&t;*/
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fec_enet_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|fec_enet_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|fec_enet_private
op_star
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|fep-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n; * Skeleton taken from sunlance driver.&n; * The CPM Ethernet implementation allows Multicast as well as individual&n; * MAC address filtering.  Some of the drivers check to make sure it is&n; * a group multicast address, and discard those that are not.  I guess I&n; * will do the same for now, but just remove the test if you want&n; * individual filtering as well (do the upper net layers want or support&n; * this kind of feature?).&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|fec_enet_private
op_star
id|fep
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|u_char
op_star
id|mcptr
comma
op_star
id|tdptr
suffix:semicolon
r_volatile
id|fec_t
op_star
id|ep
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ep
op_assign
op_amp
(paren
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_fec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Log any net taps. */
id|printk
c_func
(paren
l_string|&quot;%s: Promiscuous mode enabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ep-&gt;fec_r_cntrl
op_or_assign
l_int|0x0008
suffix:semicolon
)brace
r_else
(brace
id|ep-&gt;fec_r_cntrl
op_and_assign
op_complement
l_int|0x0008
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
multiline_comment|/* Catch all multicast addresses, so set the&n;&t;&t;&t; * filter to all 1&squot;s.&n;&t;&t;&t; */
id|ep-&gt;fec_hash_table_high
op_assign
l_int|0xffffffff
suffix:semicolon
id|ep-&gt;fec_hash_table_low
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
macro_line|#if 0
r_else
(brace
multiline_comment|/* Clear filter and add the addresses in the list.&n;&t;&t;&t;*/
id|ep-&gt;sen_gaddr1
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr2
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr3
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr4
op_assign
l_int|0
suffix:semicolon
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Only support group multicast for now.&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* The address in dmi_addr is LSB first,&n;&t;&t;&t;&t; * and taddr is MSB first.  We have to&n;&t;&t;&t;&t; * copy bytes MSB first from dmi_addr.&n;&t;&t;&t;&t; */
id|mcptr
op_assign
(paren
id|u_char
op_star
)paren
id|dmi-&gt;dmi_addr
op_plus
l_int|5
suffix:semicolon
id|tdptr
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|ep-&gt;sen_taddrh
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
op_star
id|tdptr
op_increment
op_assign
op_star
id|mcptr
op_decrement
suffix:semicolon
multiline_comment|/* Ask CPM to run CRC and set bit in&n;&t;&t;&t;&t; * filter mask.&n;&t;&t;&t;&t; */
id|cpmp-&gt;cp_cpcr
op_assign
id|mk_cr_cmd
c_func
(paren
id|CPM_CR_CH_SCC1
comma
id|CPM_CR_SET_GADDR
)paren
op_or
id|CPM_CR_FLG
suffix:semicolon
multiline_comment|/* this delay is necessary here -- Cort */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cpmp-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
)brace
multiline_comment|/* Initialize the FECC Ethernet on 860T.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|m8xx_enet_init
c_func
(paren
r_void
)paren
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|fec_enet_private
op_star
id|fep
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_char
op_star
id|eap
suffix:semicolon
r_int
r_int
id|mem_addr
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
id|cbd_t
op_star
id|cbd_base
suffix:semicolon
r_volatile
id|immap_t
op_star
id|immap
suffix:semicolon
r_volatile
id|fec_t
op_star
id|fecp
suffix:semicolon
r_int
r_char
id|rtc_save_cfg
comma
id|rtc_val
suffix:semicolon
id|immap
op_assign
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
suffix:semicolon
multiline_comment|/* pointer to internal registers */
multiline_comment|/* Allocate some private information.&n;&t;*/
id|fep
op_assign
(paren
r_struct
id|fec_enet_private
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|fep
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|__clear_user
c_func
(paren
id|fep
comma
r_sizeof
(paren
op_star
id|fep
)paren
)paren
suffix:semicolon
multiline_comment|/* Create an Ethernet device instance.&n;&t;*/
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|fecp
op_assign
op_amp
(paren
id|immap-&gt;im_cpm.cp_fec
)paren
suffix:semicolon
multiline_comment|/* Whack a reset.  We should wait for this.&n;&t;*/
id|fecp-&gt;fec_ecntrl
op_assign
l_int|1
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Enable interrupts we wish to service.&n;&t;*/
id|fecp-&gt;fec_imask
op_assign
(paren
id|FEC_ENET_TXF
op_or
id|FEC_ENET_TXB
op_or
id|FEC_ENET_RXF
op_or
id|FEC_ENET_RXB
op_or
id|FEC_ENET_MII
)paren
suffix:semicolon
multiline_comment|/* Clear any outstanding interrupt.&n;&t;*/
id|fecp-&gt;fec_ievent
op_assign
l_int|0xffc0
suffix:semicolon
id|fecp-&gt;fec_ivec
op_assign
(paren
id|FEC_INTERRUPT
op_div
l_int|2
)paren
op_lshift
l_int|29
suffix:semicolon
multiline_comment|/* Set station address.&n;&t;*/
id|fecp-&gt;fec_addr_low
op_assign
(paren
id|my_enet_addr
(braket
l_int|0
)braket
op_lshift
l_int|16
)paren
op_or
id|my_enet_addr
(braket
l_int|1
)braket
suffix:semicolon
id|fecp-&gt;fec_addr_high
op_assign
id|my_enet_addr
(braket
l_int|2
)braket
suffix:semicolon
id|eap
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|my_enet_addr
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
op_star
id|eap
op_increment
suffix:semicolon
multiline_comment|/* Reset all multicast.&n;&t;*/
id|fecp-&gt;fec_hash_table_high
op_assign
l_int|0
suffix:semicolon
id|fecp-&gt;fec_hash_table_low
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set maximum receive buffer size.&n;&t;*/
id|fecp-&gt;fec_r_buff_size
op_assign
id|PKT_MAXBLR_SIZE
suffix:semicolon
id|fecp-&gt;fec_r_hash
op_assign
id|PKT_MAXBUF_SIZE
suffix:semicolon
multiline_comment|/* Allocate memory for buffer descriptors.&n;&t;*/
r_if
c_cond
(paren
(paren
(paren
id|RX_RING_SIZE
op_plus
id|TX_RING_SIZE
)paren
op_star
r_sizeof
(paren
id|cbd_t
)paren
)paren
OG
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FECC init error.  Need more space.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;FECC initialization failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|mem_addr
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|cbd_base
op_assign
(paren
id|cbd_t
op_star
)paren
id|mem_addr
suffix:semicolon
multiline_comment|/* Make it uncached.&n;&t;*/
id|pte
op_assign
id|va_to_pte
c_func
(paren
op_amp
id|init_task
comma
(paren
r_int
)paren
id|mem_addr
)paren
suffix:semicolon
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_or_assign
id|_PAGE_NO_CACHE
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|current-&gt;mm-&gt;mmap
comma
id|mem_addr
)paren
suffix:semicolon
multiline_comment|/* Set receive and transmit descriptor base.&n;&t;*/
id|fecp-&gt;fec_r_des_start
op_assign
id|__pa
c_func
(paren
id|mem_addr
)paren
suffix:semicolon
id|fep-&gt;rx_bd_base
op_assign
id|cbd_base
suffix:semicolon
id|fecp-&gt;fec_x_des_start
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|cbd_base
op_plus
id|RX_RING_SIZE
)paren
)paren
suffix:semicolon
id|fep-&gt;tx_bd_base
op_assign
id|cbd_base
op_plus
id|RX_RING_SIZE
suffix:semicolon
id|fep-&gt;dirty_tx
op_assign
id|fep-&gt;cur_tx
op_assign
id|fep-&gt;tx_bd_base
suffix:semicolon
id|fep-&gt;cur_rx
op_assign
id|fep-&gt;rx_bd_base
suffix:semicolon
id|fep-&gt;skb_cur
op_assign
id|fep-&gt;skb_dirty
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the receive buffer descriptors.&n;&t;*/
id|bdp
op_assign
id|fep-&gt;rx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FEC_ENET_RX_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Allocate a page.&n;&t;&t;*/
id|mem_addr
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Make it uncached.&n;&t;&t;*/
id|pte
op_assign
id|va_to_pte
c_func
(paren
op_amp
id|init_task
comma
id|mem_addr
)paren
suffix:semicolon
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_or_assign
id|_PAGE_NO_CACHE
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|current-&gt;mm-&gt;mmap
comma
id|mem_addr
)paren
suffix:semicolon
multiline_comment|/* Initialize the BD for every fragment in the page.&n;&t;&t;*/
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|FEC_ENET_RX_FRPPG
suffix:semicolon
id|j
op_increment
)paren
(brace
id|bdp-&gt;cbd_sc
op_assign
id|BD_ENET_RX_EMPTY
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
id|__pa
c_func
(paren
id|mem_addr
)paren
suffix:semicolon
id|mem_addr
op_add_assign
id|FEC_ENET_RX_FRSIZE
suffix:semicolon
id|bdp
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the last buffer to wrap.&n;&t;*/
id|bdp
op_decrement
suffix:semicolon
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_SC_WRAP
suffix:semicolon
multiline_comment|/* ...and the same for transmmit.&n;&t;*/
id|bdp
op_assign
id|fep-&gt;tx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Initialize the BD for every fragment in the page.&n;&t;&t;*/
id|bdp-&gt;cbd_sc
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
l_int|0
suffix:semicolon
id|bdp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Set the last buffer to wrap.&n;&t;*/
id|bdp
op_decrement
suffix:semicolon
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_SC_WRAP
suffix:semicolon
multiline_comment|/* Enable MII mode, half-duplex until we know better..&n;&t;*/
id|fecp-&gt;fec_r_cntrl
op_assign
l_int|0x0c
suffix:semicolon
id|fecp-&gt;fec_x_cntrl
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Enable big endian and don&squot;t care about SDMA FC.&n;&t;*/
id|fecp-&gt;fec_fun_code
op_assign
l_int|0x78000000
suffix:semicolon
multiline_comment|/* Set MII speed (50 MHz core).&n;&t;*/
id|fecp-&gt;fec_mii_speed
op_assign
l_int|0x14
suffix:semicolon
multiline_comment|/* Configure all of port D for MII.&n;&t;*/
id|immap-&gt;im_ioport.iop_pdpar
op_assign
l_int|0x1fff
suffix:semicolon
id|immap-&gt;im_ioport.iop_pddir
op_assign
l_int|0x1c58
suffix:semicolon
multiline_comment|/* Install our interrupt handlers.  The 860T FADS board uses&n;&t; * IRQ2 for the MII interrupt.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|FEC_INTERRUPT
comma
id|fec_enet_interrupt
comma
l_int|0
comma
l_string|&quot;fec&quot;
comma
id|dev
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate FEC IRQ!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|SIU_IRQ2
comma
id|mii_link_interrupt
comma
l_int|0
comma
l_string|&quot;mii&quot;
comma
id|dev
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate MII IRQ!&quot;
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
(paren
r_int
r_int
)paren
id|fecp
suffix:semicolon
id|dev-&gt;priv
op_assign
id|fep
suffix:semicolon
id|dev-&gt;name
op_assign
l_string|&quot;fec&quot;
suffix:semicolon
multiline_comment|/* The FEC Ethernet specific entries in the device structure. */
id|dev-&gt;open
op_assign
id|fec_enet_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|fec_enet_start_xmit
suffix:semicolon
id|dev-&gt;stop
op_assign
id|fec_enet_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|fec_enet_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
multiline_comment|/* And last, enable the transmit and receive processing.&n;&t;*/
id|fecp-&gt;fec_ecntrl
op_assign
l_int|2
suffix:semicolon
id|fecp-&gt;fec_r_des_active
op_assign
l_int|0x01000000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;FEC ENET Version 0.1, &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NMII
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|mii_cmds
(braket
id|i
)braket
dot
id|mii_next
op_assign
op_amp
id|mii_cmds
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|mii_free
op_assign
id|mii_cmds
suffix:semicolon
id|mii_startup_cmds
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
