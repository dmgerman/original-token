multiline_comment|/*&n; * Ethernet driver for Motorola MPC8xx.&n; * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)&n; *&n; * I copied the basic skeleton from the lance driver, because I did not&n; * know how to write the Linux driver, but I did know how the LANCE worked.&n; *&n; * This version of the driver is somewhat selectable for the different&n; * processor/board combinations.  It works for the boards I know about&n; * now, and should be easily modified to include others.  Some of the&n; * configuration information is contained in &quot;commproc.h&quot; and the&n; * remainder is here.&n; *&n; * Buffer descriptors are kept in the CPM dual port RAM, and the frame&n; * buffers are in the host memory.&n; *&n; * Right now, I am very watseful with the buffers.  I allocate memory&n; * pages and then divide them into 2K frame buffers.  This way I know I&n; * have buffers large enough to hold one frame within one buffer descriptor.&n; * Once I get this working, I will use 64 or 128 byte CPM buffers, which&n; * will be much more memory efficient and will easily handle lots of&n; * small packets.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/8xx_immap.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mpc8xx.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;commproc.h&quot;
multiline_comment|/*&n; *&t;&t;&t;&t;Theory of Operation&n; *&n; * The MPC8xx CPM performs the Ethernet processing on SCC1.  It can use&n; * an aribtrary number of buffers on byte boundaries, but must have at&n; * least two receive buffers to prevent constant overrun conditions.&n; *&n; * The buffer descriptors are allocated from the CPM dual port memory&n; * with the data buffers allocated from host memory, just like all other&n; * serial communication protocols.  The host memory buffers are allocated&n; * from the free page pool, and then divided into smaller receive and&n; * transmit buffers.  The size of the buffers should be a power of two,&n; * since that nicely divides the page.  This creates a ring buffer&n; * structure similar to the LANCE and other controllers.&n; *&n; * Like the LANCE driver:&n; * The driver runs as two independent, single-threaded flows of control.  One&n; * is the send-packet routine, which enforces single-threaded use by the&n; * cep-&gt;tx_busy flag.  The other thread is the interrupt handler, which is&n; * single threaded by the hardware and other software.&n; *&n; * The send packet thread has partial control over the Tx ring and the&n; * &squot;cep-&gt;tx_busy&squot; flag.  It sets the tx_busy flag whenever it&squot;s queuing a Tx&n; * packet. If the next queue slot is empty, it clears the tx_busy flag when&n; * finished otherwise it sets the &squot;lp-&gt;tx_full&squot; flag.&n; *&n; * The MBX has a control register external to the MPC8xx that has some&n; * control of the Ethernet interface.  Information is in the manual for&n; * your board.&n; *&n; * The RPX boards have an external control/status register.  Consult the&n; * programming documents for details unique to your board.&n; *&n; * For the TQM8xx(L) modules, there is no control register interface.&n; * All functions are directly controlled using I/O pins.  See commproc.h.&n; */
multiline_comment|/* The transmitter timeout&n; */
DECL|macro|TX_TIMEOUT
mdefine_line|#define TX_TIMEOUT&t;(2*HZ)
multiline_comment|/* The number of Tx and Rx buffers.  These are allocated from the page&n; * pool.  The code may assume these are power of two, so it is best&n; * to keep them that size.&n; * We don&squot;t need to allocate pages for the transmitter.  We just use&n; * the skbuffer directly.&n; */
macro_line|#ifdef CONFIG_ENET_BIG_BUFFERS
DECL|macro|CPM_ENET_RX_PAGES
mdefine_line|#define CPM_ENET_RX_PAGES&t;32
DECL|macro|CPM_ENET_RX_FRSIZE
mdefine_line|#define CPM_ENET_RX_FRSIZE&t;2048
DECL|macro|CPM_ENET_RX_FRPPG
mdefine_line|#define CPM_ENET_RX_FRPPG&t;(PAGE_SIZE / CPM_ENET_RX_FRSIZE)
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;&t;(CPM_ENET_RX_FRPPG * CPM_ENET_RX_PAGES)
DECL|macro|TX_RING_SIZE
mdefine_line|#define TX_RING_SIZE&t;&t;64&t;/* Must be power of two */
DECL|macro|TX_RING_MOD_MASK
mdefine_line|#define TX_RING_MOD_MASK&t;63&t;/*   for this to work */
macro_line|#else
DECL|macro|CPM_ENET_RX_PAGES
mdefine_line|#define CPM_ENET_RX_PAGES&t;4
DECL|macro|CPM_ENET_RX_FRSIZE
mdefine_line|#define CPM_ENET_RX_FRSIZE&t;2048
DECL|macro|CPM_ENET_RX_FRPPG
mdefine_line|#define CPM_ENET_RX_FRPPG&t;(PAGE_SIZE / CPM_ENET_RX_FRSIZE)
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE&t;&t;(CPM_ENET_RX_FRPPG * CPM_ENET_RX_PAGES)
DECL|macro|TX_RING_SIZE
mdefine_line|#define TX_RING_SIZE&t;&t;8&t;/* Must be power of two */
DECL|macro|TX_RING_MOD_MASK
mdefine_line|#define TX_RING_MOD_MASK&t;7&t;/*   for this to work */
macro_line|#endif
multiline_comment|/* The CPM stores dest/src/type, data, and checksum for receive packets.&n; */
DECL|macro|PKT_MAXBUF_SIZE
mdefine_line|#define PKT_MAXBUF_SIZE&t;&t;1518
DECL|macro|PKT_MINBUF_SIZE
mdefine_line|#define PKT_MINBUF_SIZE&t;&t;64
DECL|macro|PKT_MAXBLR_SIZE
mdefine_line|#define PKT_MAXBLR_SIZE&t;&t;1520
multiline_comment|/* The CPM buffer descriptors track the ring buffers.  The rx_bd_base and&n; * tx_bd_base always point to the base of the buffer descriptors.  The&n; * cur_rx and cur_tx point to the currently available buffer.&n; * The dirty_tx tracks the current buffer that is being sent by the&n; * controller.  The cur_tx and dirty_tx are equal under both completely&n; * empty and completely full conditions.  The empty/ready indicator in&n; * the buffer descriptor determines the actual condition.&n; */
DECL|struct|scc_enet_private
r_struct
id|scc_enet_private
(brace
multiline_comment|/* The saved address of a sent-in-place packet/buffer, for skfree(). */
DECL|member|tx_skbuff
r_struct
id|sk_buff
op_star
id|tx_skbuff
(braket
id|TX_RING_SIZE
)braket
suffix:semicolon
DECL|member|skb_cur
id|ushort
id|skb_cur
suffix:semicolon
DECL|member|skb_dirty
id|ushort
id|skb_dirty
suffix:semicolon
multiline_comment|/* CPM dual port RAM relative addresses.&n;&t;*/
DECL|member|rx_bd_base
id|cbd_t
op_star
id|rx_bd_base
suffix:semicolon
multiline_comment|/* Address of Rx and Tx buffers. */
DECL|member|tx_bd_base
id|cbd_t
op_star
id|tx_bd_base
suffix:semicolon
DECL|member|cur_rx
DECL|member|cur_tx
id|cbd_t
op_star
id|cur_rx
comma
op_star
id|cur_tx
suffix:semicolon
multiline_comment|/* The next free ring entry */
DECL|member|dirty_tx
id|cbd_t
op_star
id|dirty_tx
suffix:semicolon
multiline_comment|/* The ring entries to be free()ed. */
DECL|member|sccp
id|scc_t
op_star
id|sccp
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|tx_full
id|uint
id|tx_full
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|scc_enet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|scc_enet_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|scc_enet_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|scc_enet_interrupt
c_func
(paren
r_void
op_star
id|dev_id
)paren
suffix:semicolon
r_static
r_int
id|scc_enet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|scc_enet_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Get this from various configuration locations (depends on board).&n;*/
multiline_comment|/*static&t;ushort&t;my_enet_addr[] = { 0x0800, 0x3e26, 0x1559 };*/
multiline_comment|/* Typically, 860(T) boards use SCC1 for Ethernet, and other 8xx boards&n; * use SCC2.  This is easily extended if necessary.&n; */
macro_line|#ifdef CONFIG_SCC2_ENET
DECL|macro|CPM_CR_ENET
mdefine_line|#define CPM_CR_ENET&t;CPM_CR_CH_SCC2
DECL|macro|PROFF_ENET
mdefine_line|#define PROFF_ENET&t;PROFF_SCC2
DECL|macro|SCC_ENET
mdefine_line|#define SCC_ENET&t;1&t;&t;/* Index, not number! */
DECL|macro|CPMVEC_ENET
mdefine_line|#define CPMVEC_ENET&t;CPMVEC_SCC2
macro_line|#endif
macro_line|#ifdef CONFIG_SCC1_ENET
DECL|macro|CPM_CR_ENET
mdefine_line|#define CPM_CR_ENET CPM_CR_CH_SCC1
DECL|macro|PROFF_ENET
mdefine_line|#define PROFF_ENET&t;PROFF_SCC1
DECL|macro|SCC_ENET
mdefine_line|#define SCC_ENET&t;0
DECL|macro|CPMVEC_ENET
mdefine_line|#define CPMVEC_ENET&t;CPMVEC_SCC1
macro_line|#endif
r_static
r_int
DECL|function|scc_enet_open
id|scc_enet_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* I should reset the ring buffers here, but I don&squot;t yet know&n;&t; * a simple way to do that.&n;&t; */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Always succeed */
)brace
r_static
r_int
DECL|function|scc_enet_start_xmit
id|scc_enet_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_enet_private
op_star
id|cep
op_assign
(paren
r_struct
id|scc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
multiline_comment|/* Fill in a Tx ring entry */
id|bdp
op_assign
id|cep-&gt;cur_tx
suffix:semicolon
macro_line|#ifndef final_version
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
(brace
multiline_comment|/* Ooops.  All transmit buffers are full.  Bail out.&n;&t;&t; * This should not happen, since cep-&gt;tx_busy should be set.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: tx queue full!.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Clear all of the status flags.&n;&t; */
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_TX_STATS
suffix:semicolon
multiline_comment|/* If the frame is short, tell CPM to pad it.&n;&t;*/
r_if
c_cond
(paren
id|skb-&gt;len
op_le
id|ETH_ZLEN
)paren
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_ENET_TX_PAD
suffix:semicolon
r_else
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_TX_PAD
suffix:semicolon
multiline_comment|/* Set buffer length and buffer pointer.&n;&t;*/
id|bdp-&gt;cbd_datlen
op_assign
id|skb-&gt;len
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
id|__pa
c_func
(paren
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* Save skb pointer.&n;&t;*/
id|cep-&gt;tx_skbuff
(braket
id|cep-&gt;skb_cur
)braket
op_assign
id|skb
suffix:semicolon
id|cep-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|cep-&gt;skb_cur
op_assign
(paren
id|cep-&gt;skb_cur
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
suffix:semicolon
multiline_comment|/* Push the data cache so the CPM does not get stale memory&n;&t; * data.&n;&t; */
id|flush_dcache_range
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|skb-&gt;data
)paren
comma
(paren
r_int
r_int
)paren
(paren
id|skb-&gt;data
op_plus
id|skb-&gt;len
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Send it on its way.  Tell CPM its ready, interrupt when done,&n;&t; * its the last BD of the frame, and to put the CRC on the end.&n;&t; */
id|bdp-&gt;cbd_sc
op_or_assign
(paren
id|BD_ENET_TX_READY
op_or
id|BD_ENET_TX_INTR
op_or
id|BD_ENET_TX_LAST
op_or
id|BD_ENET_TX_TC
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* If this was the last BD in the ring, start at the beginning again.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_WRAP
)paren
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|cep-&gt;tx_full
op_assign
l_int|1
suffix:semicolon
)brace
id|cep-&gt;cur_tx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|scc_enet_timeout
id|scc_enet_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_enet_private
op_star
id|cep
op_assign
(paren
r_struct
id|scc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cep-&gt;stats.tx_errors
op_increment
suffix:semicolon
macro_line|#ifndef final_version
(brace
r_int
id|i
suffix:semicolon
id|cbd_t
op_star
id|bdp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; Ring data dump: cur_tx %p%s cur_rx %p.&bslash;n&quot;
comma
id|cep-&gt;cur_tx
comma
id|cep-&gt;tx_full
ques
c_cond
l_string|&quot; (full)&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|cep-&gt;cur_rx
)paren
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
comma
id|bdp
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%04x %04x %08x&bslash;n&quot;
comma
id|bdp-&gt;cbd_sc
comma
id|bdp-&gt;cbd_datlen
comma
id|bdp-&gt;cbd_bufaddr
)paren
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
comma
id|bdp
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%04x %04x %08x&bslash;n&quot;
comma
id|bdp-&gt;cbd_sc
comma
id|bdp-&gt;cbd_datlen
comma
id|bdp-&gt;cbd_bufaddr
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|cep-&gt;tx_full
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* The interrupt handler.&n; * This is called from the CPM handler, not the MPC core interrupt.&n; */
r_static
r_void
DECL|function|scc_enet_interrupt
id|scc_enet_interrupt
c_func
(paren
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_volatile
r_struct
id|scc_enet_private
op_star
id|cep
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
id|ushort
id|int_events
suffix:semicolon
r_int
id|must_restart
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|scc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Get the interrupt events that caused us to be here.&n;&t;*/
id|int_events
op_assign
id|cep-&gt;sccp-&gt;scc_scce
suffix:semicolon
id|cep-&gt;sccp-&gt;scc_scce
op_assign
id|int_events
suffix:semicolon
id|must_restart
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Handle receive event in its own function.&n;&t;*/
r_if
c_cond
(paren
id|int_events
op_amp
id|SCCE_ENET_RXF
)paren
id|scc_enet_rx
c_func
(paren
id|dev_id
)paren
suffix:semicolon
multiline_comment|/* Check for a transmit error.  The manual is a little unclear&n;&t; * about this, so the debug code until I get it figured out.  It&n;&t; * appears that if TXE is set, then TXB is not set.  However,&n;&t; * if carrier sense is lost during frame transmission, the TXE&n;&t; * bit is set, &quot;and continues the buffer transmission normally.&quot;&n;&t; * I don&squot;t know if &quot;normally&quot; implies TXB is set when the buffer&n;&t; * descriptor is closed.....trial and error :-).&n;&t; */
multiline_comment|/* Transmit OK, or non-fatal error.  Update the buffer descriptors.&n;&t;*/
r_if
c_cond
(paren
id|int_events
op_amp
(paren
id|SCCE_ENET_TXE
op_or
id|SCCE_ENET_TXB
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;dirty_tx
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_READY
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|bdp
op_eq
id|cep-&gt;cur_tx
)paren
op_logical_and
(paren
id|cep-&gt;tx_full
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_HB
)paren
multiline_comment|/* No heartbeat */
id|cep-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_LC
)paren
multiline_comment|/* Late collision */
id|cep-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_RL
)paren
multiline_comment|/* Retrans limit */
id|cep-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_UN
)paren
multiline_comment|/* Underrun */
id|cep-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_CSL
)paren
multiline_comment|/* Carrier lost */
id|cep-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
multiline_comment|/* No heartbeat or Lost carrier are not really bad errors.&n;&t;&t; * The others require a restart transmit command.&n;&t;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
(paren
id|BD_ENET_TX_LC
op_or
id|BD_ENET_TX_RL
op_or
id|BD_ENET_TX_UN
)paren
)paren
(brace
id|must_restart
op_assign
l_int|1
suffix:semicolon
id|cep-&gt;stats.tx_errors
op_increment
suffix:semicolon
)brace
id|cep-&gt;stats.tx_packets
op_increment
suffix:semicolon
multiline_comment|/* Deferred means some collisions occurred during transmit,&n;&t;&t; * but we eventually sent the packet OK.&n;&t;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_DEF
)paren
id|cep-&gt;stats.collisions
op_increment
suffix:semicolon
multiline_comment|/* Free the sk buffer associated with this last transmit.&n;&t;&t;*/
id|dev_kfree_skb_irq
c_func
(paren
id|cep-&gt;tx_skbuff
(braket
id|cep-&gt;skb_dirty
)braket
)paren
suffix:semicolon
id|cep-&gt;skb_dirty
op_assign
(paren
id|cep-&gt;skb_dirty
op_plus
l_int|1
)paren
op_amp
id|TX_RING_MOD_MASK
suffix:semicolon
multiline_comment|/* Update pointer to next buffer descriptor to be transmitted.&n;&t;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_TX_WRAP
)paren
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
multiline_comment|/* I don&squot;t know if we can be held off from processing these&n;&t;&t; * interrupts for more than one frame time.  I really hope&n;&t;&t; * not.  In such a case, we would now want to check the&n;&t;&t; * currently available BD (cur_tx) and determine if any&n;&t;&t; * buffers between the dirty_tx and cur_tx have also been&n;&t;&t; * sent.  We would want to process anything in between that&n;&t;&t; * does not have BD_ENET_TX_READY set.&n;&t;&t; */
multiline_comment|/* Since we have freed up a buffer, the ring is no longer&n;&t;&t; * full.&n;&t;&t; */
r_if
c_cond
(paren
id|cep-&gt;tx_full
)paren
(brace
id|cep-&gt;tx_full
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|cep-&gt;dirty_tx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|must_restart
)paren
(brace
r_volatile
id|cpm8xx_t
op_star
id|cp
suffix:semicolon
multiline_comment|/* Some transmit errors cause the transmitter to shut&n;&t;&t; * down.  We now issue a restart transmit.  Since the&n;&t;&t; * errors close the BD and update the pointers, the restart&n;&t;&t; * _should_ pick up without having to reset any of our&n;&t;&t; * pointers either.&n;&t;&t; */
id|cp
op_assign
id|cpmp
suffix:semicolon
id|cp-&gt;cp_cpcr
op_assign
id|mk_cr_cmd
c_func
(paren
id|CPM_CR_ENET
comma
id|CPM_CR_RESTART_TX
)paren
op_or
id|CPM_CR_FLG
suffix:semicolon
r_while
c_loop
(paren
id|cp-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for receive busy, i.e. packets coming but no place to&n;&t; * put them.  This &quot;can&squot;t happen&quot; because the receive interrupt&n;&t; * is tossing previous frames.&n;&t; */
r_if
c_cond
(paren
id|int_events
op_amp
id|SCCE_ENET_BSY
)paren
(brace
id|cep-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPM ENET: BSY can&squot;t happen.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* During a receive, the cur_rx points to the current incoming buffer.&n; * When we update through the ring, if the next incoming buffer has&n; * not been given to the system, we just set the empty indicator,&n; * effectively tossing the packet.&n; */
r_static
r_int
DECL|function|scc_enet_rx
id|scc_enet_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_enet_private
op_star
id|cep
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ushort
id|pkt_len
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|scc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* First, grab all of the stats for the incoming packet.&n;&t; * These get messed up if we get called due to a busy condition.&n;&t; */
id|bdp
op_assign
id|cep-&gt;cur_rx
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_EMPTY
)paren
r_break
suffix:semicolon
macro_line|#ifndef final_version
multiline_comment|/* Since we have allocated space to hold a complete frame, both&n;&t; * the first and last indicators should be set.&n;&t; */
r_if
c_cond
(paren
(paren
id|bdp-&gt;cbd_sc
op_amp
(paren
id|BD_ENET_RX_FIRST
op_or
id|BD_ENET_RX_LAST
)paren
)paren
op_ne
(paren
id|BD_ENET_RX_FIRST
op_or
id|BD_ENET_RX_LAST
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;CPM ENET: rcv is not first+last&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Frame too long or too short.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
(paren
id|BD_ENET_RX_LG
op_or
id|BD_ENET_RX_SH
)paren
)paren
id|cep-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_NO
)paren
multiline_comment|/* Frame alignment */
id|cep-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_CR
)paren
multiline_comment|/* CRC Error */
id|cep-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_OV
)paren
multiline_comment|/* FIFO overrun */
id|cep-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
multiline_comment|/* Report late collisions as a frame error.&n;&t; * On this error, the BD is closed, but we don&squot;t know what we&n;&t; * have in the buffer.  So, just drop this frame on the floor.&n;&t; */
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_CL
)paren
(brace
id|cep-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Process the incoming frame.&n;&t;&t;*/
id|cep-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|pkt_len
op_assign
id|bdp-&gt;cbd_datlen
suffix:semicolon
id|cep-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
multiline_comment|/* This does 16 byte alignment, much more than we need.&n;&t;&t; * The packet length includes FCS, but we don&squot;t want to&n;&t;&t; * include that when passing upstream as it messes up&n;&t;&t; * bridging applications.&n;&t;&t; */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_minus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cep-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Make room */
id|eth_copy_and_sum
c_func
(paren
id|skb
comma
(paren
r_int
r_char
op_star
)paren
id|__va
c_func
(paren
id|bdp-&gt;cbd_bufaddr
)paren
comma
id|pkt_len
op_minus
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear the status flags for this buffer.&n;&t;*/
id|bdp-&gt;cbd_sc
op_and_assign
op_complement
id|BD_ENET_RX_STATS
suffix:semicolon
multiline_comment|/* Mark the buffer empty.&n;&t;*/
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_ENET_RX_EMPTY
suffix:semicolon
multiline_comment|/* Update BD pointer to next entry.&n;&t;*/
r_if
c_cond
(paren
id|bdp-&gt;cbd_sc
op_amp
id|BD_ENET_RX_WRAP
)paren
id|bdp
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
r_else
id|bdp
op_increment
suffix:semicolon
)brace
id|cep-&gt;cur_rx
op_assign
(paren
id|cbd_t
op_star
)paren
id|bdp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|scc_enet_close
id|scc_enet_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Don&squot;t know what to do yet.&n;&t;*/
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scc_enet_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|scc_enet_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_enet_private
op_star
id|cep
op_assign
(paren
r_struct
id|scc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|cep-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Set or clear the multicast filter for this adaptor.&n; * Skeleton taken from sunlance driver.&n; * The CPM Ethernet implementation allows Multicast as well as individual&n; * MAC address filtering.  Some of the drivers check to make sure it is&n; * a group multicast address, and discard those that are not.  I guess I&n; * will do the same for now, but just remove the test if you want&n; * individual filtering as well (do the upper net layers want or support&n; * this kind of feature?).&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_enet_private
op_star
id|cep
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
suffix:semicolon
id|u_char
op_star
id|mcptr
comma
op_star
id|tdptr
suffix:semicolon
r_volatile
id|scc_enet_t
op_star
id|ep
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|cep
op_assign
(paren
r_struct
id|scc_enet_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Get pointer to SCC area in parameter RAM.&n;&t;*/
id|ep
op_assign
(paren
id|scc_enet_t
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* Log any net taps. */
id|printk
c_func
(paren
l_string|&quot;%s: Promiscuous mode enabled.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cep-&gt;sccp-&gt;scc_pmsr
op_or_assign
id|SCC_PMSR_PRO
suffix:semicolon
)brace
r_else
(brace
id|cep-&gt;sccp-&gt;scc_pmsr
op_and_assign
op_complement
id|SCC_PMSR_PRO
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
multiline_comment|/* Catch all multicast addresses, so set the&n;&t;&t;&t; * filter to all 1&squot;s.&n;&t;&t;&t; */
id|ep-&gt;sen_gaddr1
op_assign
l_int|0xffff
suffix:semicolon
id|ep-&gt;sen_gaddr2
op_assign
l_int|0xffff
suffix:semicolon
id|ep-&gt;sen_gaddr3
op_assign
l_int|0xffff
suffix:semicolon
id|ep-&gt;sen_gaddr4
op_assign
l_int|0xffff
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clear filter and add the addresses in the list.&n;&t;&t;&t;*/
id|ep-&gt;sen_gaddr1
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr2
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr3
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr4
op_assign
l_int|0
suffix:semicolon
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Only support group multicast for now.&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmi-&gt;dmi_addr
(braket
l_int|0
)braket
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* The address in dmi_addr is LSB first,&n;&t;&t;&t;&t; * and taddr is MSB first.  We have to&n;&t;&t;&t;&t; * copy bytes MSB first from dmi_addr.&n;&t;&t;&t;&t; */
id|mcptr
op_assign
(paren
id|u_char
op_star
)paren
id|dmi-&gt;dmi_addr
op_plus
l_int|5
suffix:semicolon
id|tdptr
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|ep-&gt;sen_taddrh
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
op_star
id|tdptr
op_increment
op_assign
op_star
id|mcptr
op_decrement
suffix:semicolon
multiline_comment|/* Ask CPM to run CRC and set bit in&n;&t;&t;&t;&t; * filter mask.&n;&t;&t;&t;&t; */
id|cpmp-&gt;cp_cpcr
op_assign
id|mk_cr_cmd
c_func
(paren
id|CPM_CR_ENET
comma
id|CPM_CR_SET_GADDR
)paren
op_or
id|CPM_CR_FLG
suffix:semicolon
multiline_comment|/* this delay is necessary here -- Cort */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cpmp-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Initialize the CPM Ethernet on SCC.  If EPPC-Bug loaded us, or performed&n; * some other network I/O, a whole bunch of this has already been set up.&n; * It is no big deal if we do it again, we just have to disable the&n; * transmit and receive to make sure we don&squot;t catch the CPM with some&n; * inconsistent control information.&n; */
DECL|function|scc_enet_init
r_int
id|__init
id|scc_enet_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_struct
id|scc_enet_private
op_star
id|cep
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_char
op_star
id|eap
suffix:semicolon
r_int
r_int
id|mem_addr
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|bd_t
op_star
id|bd
suffix:semicolon
r_volatile
id|cbd_t
op_star
id|bdp
suffix:semicolon
r_volatile
id|cpm8xx_t
op_star
id|cp
suffix:semicolon
r_volatile
id|scc_t
op_star
id|sccp
suffix:semicolon
r_volatile
id|scc_enet_t
op_star
id|ep
suffix:semicolon
r_volatile
id|immap_t
op_star
id|immap
suffix:semicolon
id|cp
op_assign
id|cpmp
suffix:semicolon
multiline_comment|/* Get pointer to Communication Processor */
id|immap
op_assign
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
suffix:semicolon
multiline_comment|/* and to internal registers */
id|bd
op_assign
(paren
id|bd_t
op_star
)paren
id|__res
suffix:semicolon
multiline_comment|/* Allocate some private information.&n;&t;*/
id|cep
op_assign
(paren
r_struct
id|scc_enet_private
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cep
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*memset(cep, 0, sizeof(*cep));*/
id|__clear_user
c_func
(paren
id|cep
comma
r_sizeof
(paren
op_star
id|cep
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cep-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Create an Ethernet device instance.&n;&t;*/
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Get pointer to SCC area in parameter RAM.&n;&t;*/
id|ep
op_assign
(paren
id|scc_enet_t
op_star
)paren
(paren
op_amp
id|cp-&gt;cp_dparam
(braket
id|PROFF_ENET
)braket
)paren
suffix:semicolon
multiline_comment|/* And another to the SCC register area.&n;&t;*/
id|sccp
op_assign
(paren
r_volatile
id|scc_t
op_star
)paren
(paren
op_amp
id|cp-&gt;cp_scc
(braket
id|SCC_ENET
)braket
)paren
suffix:semicolon
id|cep-&gt;sccp
op_assign
(paren
id|scc_t
op_star
)paren
id|sccp
suffix:semicolon
multiline_comment|/* Keep the pointer handy */
multiline_comment|/* Disable receive and transmit in case EPPC-Bug started it.&n;&t;*/
id|sccp-&gt;scc_gsmrl
op_and_assign
op_complement
(paren
id|SCC_GSMRL_ENR
op_or
id|SCC_GSMRL_ENT
)paren
suffix:semicolon
multiline_comment|/* Cookbook style from the MPC860 manual.....&n;&t; * Not all of this is necessary if EPPC-Bug has initialized&n;&t; * the network.&n;&t; * So far we are lucky, all board configurations use the same&n;&t; * pins, or at least the same I/O Port for these functions.....&n;&t; * It can&squot;t last though......&n;&t; */
multiline_comment|/* Configure port A pins for Txd and Rxd.&n;&t;*/
id|immap-&gt;im_ioport.iop_papar
op_or_assign
(paren
id|PA_ENET_RXD
op_or
id|PA_ENET_TXD
)paren
suffix:semicolon
id|immap-&gt;im_ioport.iop_padir
op_and_assign
op_complement
(paren
id|PA_ENET_RXD
op_or
id|PA_ENET_TXD
)paren
suffix:semicolon
id|immap-&gt;im_ioport.iop_paodr
op_and_assign
op_complement
id|PA_ENET_TXD
suffix:semicolon
multiline_comment|/* Configure port C pins to enable CLSN and RENA.&n;&t;*/
id|immap-&gt;im_ioport.iop_pcpar
op_and_assign
op_complement
(paren
id|PC_ENET_CLSN
op_or
id|PC_ENET_RENA
)paren
suffix:semicolon
id|immap-&gt;im_ioport.iop_pcdir
op_and_assign
op_complement
(paren
id|PC_ENET_CLSN
op_or
id|PC_ENET_RENA
)paren
suffix:semicolon
id|immap-&gt;im_ioport.iop_pcso
op_or_assign
(paren
id|PC_ENET_CLSN
op_or
id|PC_ENET_RENA
)paren
suffix:semicolon
multiline_comment|/* Configure port A for TCLK and RCLK.&n;&t;*/
id|immap-&gt;im_ioport.iop_papar
op_or_assign
(paren
id|PA_ENET_TCLK
op_or
id|PA_ENET_RCLK
)paren
suffix:semicolon
id|immap-&gt;im_ioport.iop_padir
op_and_assign
op_complement
(paren
id|PA_ENET_TCLK
op_or
id|PA_ENET_RCLK
)paren
suffix:semicolon
multiline_comment|/* Configure Serial Interface clock routing.&n;&t; * First, clear all SCC bits to zero, then set the ones we want.&n;&t; */
id|cp-&gt;cp_sicr
op_and_assign
op_complement
id|SICR_ENET_MASK
suffix:semicolon
id|cp-&gt;cp_sicr
op_or_assign
id|SICR_ENET_CLKRT
suffix:semicolon
multiline_comment|/* Manual says set SDDR, but I can&squot;t find anything with that&n;&t; * name.  I think it is a misprint, and should be SDCR.  This&n;&t; * has already been set by the communication processor initialization.&n;&t; */
multiline_comment|/* Allocate space for the buffer descriptors in the DP ram.&n;&t; * These are relative offsets in the DP ram address space.&n;&t; * Initialize base addresses for the buffer descriptors.&n;&t; */
id|i
op_assign
id|m8xx_cpm_dpalloc
c_func
(paren
r_sizeof
(paren
id|cbd_t
)paren
op_star
id|RX_RING_SIZE
)paren
suffix:semicolon
id|ep-&gt;sen_genscc.scc_rbase
op_assign
id|i
suffix:semicolon
id|cep-&gt;rx_bd_base
op_assign
(paren
id|cbd_t
op_star
)paren
op_amp
id|cp-&gt;cp_dpmem
(braket
id|i
)braket
suffix:semicolon
id|i
op_assign
id|m8xx_cpm_dpalloc
c_func
(paren
r_sizeof
(paren
id|cbd_t
)paren
op_star
id|TX_RING_SIZE
)paren
suffix:semicolon
id|ep-&gt;sen_genscc.scc_tbase
op_assign
id|i
suffix:semicolon
id|cep-&gt;tx_bd_base
op_assign
(paren
id|cbd_t
op_star
)paren
op_amp
id|cp-&gt;cp_dpmem
(braket
id|i
)braket
suffix:semicolon
id|cep-&gt;dirty_tx
op_assign
id|cep-&gt;cur_tx
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
id|cep-&gt;cur_rx
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
multiline_comment|/* Issue init Rx BD command for SCC.&n;&t; * Manual says to perform an Init Rx parameters here.  We have&n;&t; * to perform both Rx and Tx because the SCC may have been&n;&t; * already running.&n;&t; * In addition, we have to do it later because we don&squot;t yet have&n;&t; * all of the BD control/status set properly.&n;&t;cp-&gt;cp_cpcr = mk_cr_cmd(CPM_CR_ENET, CPM_CR_INIT_RX) | CPM_CR_FLG;&n;&t;while (cp-&gt;cp_cpcr &amp; CPM_CR_FLG);&n;&t; */
multiline_comment|/* Initialize function code registers for big-endian.&n;&t;*/
id|ep-&gt;sen_genscc.scc_rfcr
op_assign
id|SCC_EB
suffix:semicolon
id|ep-&gt;sen_genscc.scc_tfcr
op_assign
id|SCC_EB
suffix:semicolon
multiline_comment|/* Set maximum bytes per receive buffer.&n;&t; * This appears to be an Ethernet frame size, not the buffer&n;&t; * fragment size.  It must be a multiple of four.&n;&t; */
id|ep-&gt;sen_genscc.scc_mrblr
op_assign
id|PKT_MAXBLR_SIZE
suffix:semicolon
multiline_comment|/* Set CRC preset and mask.&n;&t;*/
id|ep-&gt;sen_cpres
op_assign
l_int|0xffffffff
suffix:semicolon
id|ep-&gt;sen_cmask
op_assign
l_int|0xdebb20e3
suffix:semicolon
id|ep-&gt;sen_crcec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CRC Error counter */
id|ep-&gt;sen_alec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* alignment error counter */
id|ep-&gt;sen_disfc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* discard frame counter */
id|ep-&gt;sen_pads
op_assign
l_int|0x8888
suffix:semicolon
multiline_comment|/* Tx short frame pad character */
id|ep-&gt;sen_retlim
op_assign
l_int|15
suffix:semicolon
multiline_comment|/* Retry limit threshold */
id|ep-&gt;sen_maxflr
op_assign
id|PKT_MAXBUF_SIZE
suffix:semicolon
multiline_comment|/* maximum frame length register */
id|ep-&gt;sen_minflr
op_assign
id|PKT_MINBUF_SIZE
suffix:semicolon
multiline_comment|/* minimum frame length register */
id|ep-&gt;sen_maxd1
op_assign
id|PKT_MAXBLR_SIZE
suffix:semicolon
multiline_comment|/* maximum DMA1 length */
id|ep-&gt;sen_maxd2
op_assign
id|PKT_MAXBLR_SIZE
suffix:semicolon
multiline_comment|/* maximum DMA2 length */
multiline_comment|/* Clear hash tables.&n;&t;*/
id|ep-&gt;sen_gaddr1
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr2
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr3
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_gaddr4
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_iaddr1
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_iaddr2
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_iaddr3
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_iaddr4
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set Ethernet station address.&n;&t; *&n;&t; * If we performed a MBX diskless boot, the Ethernet controller&n;&t; * has been initialized and we copy the address out into our&n;&t; * own structure.&n;&t; *&n;&t; * All other types of boards supply the address in the board&n;&t; * information structure, so we copy that into the controller.&n;&t; */
id|eap
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
(paren
id|ep-&gt;sen_paddrh
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_MBX
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
op_star
id|eap
op_increment
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|bd-&gt;bi_enetaddr
(braket
id|i
)braket
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|5
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
op_star
id|eap
op_increment
suffix:semicolon
macro_line|#endif
id|ep-&gt;sen_pper
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &squot;cause the book says so */
id|ep-&gt;sen_taddrl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* temp address (LSB) */
id|ep-&gt;sen_taddrm
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;sen_taddrh
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* temp address (MSB) */
multiline_comment|/* Now allocate the host memory pages and initialize the&n;&t; * buffer descriptors.&n;&t; */
id|bdp
op_assign
id|cep-&gt;tx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Initialize the BD for every fragment in the page.&n;&t;&t;*/
id|bdp-&gt;cbd_sc
op_assign
l_int|0
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
l_int|0
suffix:semicolon
id|bdp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Set the last buffer to wrap.&n;&t;*/
id|bdp
op_decrement
suffix:semicolon
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_SC_WRAP
suffix:semicolon
id|bdp
op_assign
id|cep-&gt;rx_bd_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CPM_ENET_RX_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Allocate a page.&n;&t;&t;*/
id|mem_addr
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Make it uncached.&n;&t;&t;*/
id|pte
op_assign
id|va_to_pte
c_func
(paren
id|mem_addr
)paren
suffix:semicolon
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_or_assign
id|_PAGE_NO_CACHE
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|init_mm.mmap
comma
id|mem_addr
)paren
suffix:semicolon
multiline_comment|/* Initialize the BD for every fragment in the page.&n;&t;&t;*/
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|CPM_ENET_RX_FRPPG
suffix:semicolon
id|j
op_increment
)paren
(brace
id|bdp-&gt;cbd_sc
op_assign
id|BD_ENET_RX_EMPTY
op_or
id|BD_ENET_RX_INTR
suffix:semicolon
id|bdp-&gt;cbd_bufaddr
op_assign
id|__pa
c_func
(paren
id|mem_addr
)paren
suffix:semicolon
id|mem_addr
op_add_assign
id|CPM_ENET_RX_FRSIZE
suffix:semicolon
id|bdp
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the last buffer to wrap.&n;&t;*/
id|bdp
op_decrement
suffix:semicolon
id|bdp-&gt;cbd_sc
op_or_assign
id|BD_SC_WRAP
suffix:semicolon
multiline_comment|/* Let&squot;s re-initialize the channel now.  We have to do it later&n;&t; * than the manual describes because we have just now finished&n;&t; * the BD initialization.&n;&t; */
id|cp-&gt;cp_cpcr
op_assign
id|mk_cr_cmd
c_func
(paren
id|CPM_CR_ENET
comma
id|CPM_CR_INIT_TRX
)paren
op_or
id|CPM_CR_FLG
suffix:semicolon
r_while
c_loop
(paren
id|cp-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
id|cep-&gt;skb_cur
op_assign
id|cep-&gt;skb_dirty
op_assign
l_int|0
suffix:semicolon
id|sccp-&gt;scc_scce
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Clear any pending events */
multiline_comment|/* Enable interrupts for transmit error, complete frame&n;&t; * received, and any transmit buffer we have also set the&n;&t; * interrupt flag.&n;&t; */
id|sccp-&gt;scc_sccm
op_assign
(paren
id|SCCE_ENET_TXE
op_or
id|SCCE_ENET_RXF
op_or
id|SCCE_ENET_TXB
)paren
suffix:semicolon
multiline_comment|/* Install our interrupt handler.&n;&t;*/
id|cpm_install_handler
c_func
(paren
id|CPMVEC_ENET
comma
id|scc_enet_interrupt
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set GSMR_H to enable all normal operating modes.&n;&t; * Set GSMR_L to enable Ethernet to MC68160.&n;&t; */
id|sccp-&gt;scc_gsmrh
op_assign
l_int|0
suffix:semicolon
id|sccp-&gt;scc_gsmrl
op_assign
(paren
id|SCC_GSMRL_TCI
op_or
id|SCC_GSMRL_TPL_48
op_or
id|SCC_GSMRL_TPP_10
op_or
id|SCC_GSMRL_MODE_ENET
)paren
suffix:semicolon
multiline_comment|/* Set sync/delimiters.&n;&t;*/
id|sccp-&gt;scc_dsr
op_assign
l_int|0xd555
suffix:semicolon
multiline_comment|/* Set processing mode.  Use Ethernet CRC, catch broadcast, and&n;&t; * start frame search 22 bit times after RENA.&n;&t; */
id|sccp-&gt;scc_pmsr
op_assign
(paren
id|SCC_PMSR_ENCRC
op_or
id|SCC_PMSR_NIB22
)paren
suffix:semicolon
multiline_comment|/* It is now OK to enable the Ethernet transmitter.&n;&t; * Unfortunately, there are board implementation differences here.&n;&t; */
macro_line|#if (defined(CONFIG_MBX) || defined(CONFIG_TQM860) || defined(CONFIG_TQM860L) || defined(CONFIG_FPS850))
id|immap-&gt;im_ioport.iop_pcpar
op_or_assign
id|PC_ENET_TENA
suffix:semicolon
id|immap-&gt;im_ioport.iop_pcdir
op_and_assign
op_complement
id|PC_ENET_TENA
suffix:semicolon
macro_line|#endif
macro_line|#if (defined(CONFIG_TQM8xxL) &amp;&amp; !defined(CONFIG_FPS850))
id|cp-&gt;cp_pbpar
op_or_assign
id|PB_ENET_TENA
suffix:semicolon
id|cp-&gt;cp_pbdir
op_or_assign
id|PB_ENET_TENA
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_RPXLITE) || defined(CONFIG_RPXCLASSIC)
id|cp-&gt;cp_pbpar
op_or_assign
id|PB_ENET_TENA
suffix:semicolon
id|cp-&gt;cp_pbdir
op_or_assign
id|PB_ENET_TENA
suffix:semicolon
multiline_comment|/* And while we are here, set the configuration to enable ethernet.&n;&t;*/
op_star
(paren
(paren
r_volatile
id|uint
op_star
)paren
id|RPX_CSR_ADDR
)paren
op_and_assign
op_complement
id|BCSR0_ETHLPBK
suffix:semicolon
op_star
(paren
(paren
r_volatile
id|uint
op_star
)paren
id|RPX_CSR_ADDR
)paren
op_or_assign
(paren
id|BCSR0_ETHEN
op_or
id|BCSR0_COLTESTDIS
op_or
id|BCSR0_FULLDPLXDIS
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BSEIP
id|cp-&gt;cp_pbpar
op_or_assign
id|PB_ENET_TENA
suffix:semicolon
id|cp-&gt;cp_pbdir
op_or_assign
id|PB_ENET_TENA
suffix:semicolon
multiline_comment|/* BSE uses port B and C for PHY control.&n;&t;*/
id|cp-&gt;cp_pbpar
op_and_assign
op_complement
(paren
id|PB_BSE_POWERUP
op_or
id|PB_BSE_FDXDIS
)paren
suffix:semicolon
id|cp-&gt;cp_pbdir
op_or_assign
(paren
id|PB_BSE_POWERUP
op_or
id|PB_BSE_FDXDIS
)paren
suffix:semicolon
id|cp-&gt;cp_pbdat
op_or_assign
(paren
id|PB_BSE_POWERUP
op_or
id|PB_BSE_FDXDIS
)paren
suffix:semicolon
id|immap-&gt;im_ioport.iop_pcpar
op_and_assign
op_complement
id|PC_BSE_LOOPBACK
suffix:semicolon
id|immap-&gt;im_ioport.iop_pcdir
op_or_assign
id|PC_BSE_LOOPBACK
suffix:semicolon
id|immap-&gt;im_ioport.iop_pcso
op_and_assign
op_complement
id|PC_BSE_LOOPBACK
suffix:semicolon
id|immap-&gt;im_ioport.iop_pcdat
op_and_assign
op_complement
id|PC_BSE_LOOPBACK
suffix:semicolon
macro_line|#endif
id|dev-&gt;base_addr
op_assign
(paren
r_int
r_int
)paren
id|ep
suffix:semicolon
id|dev-&gt;priv
op_assign
id|cep
suffix:semicolon
macro_line|#if 0
id|dev-&gt;name
op_assign
l_string|&quot;CPM_ENET&quot;
suffix:semicolon
macro_line|#endif
multiline_comment|/* The CPM Ethernet specific entries in the device structure. */
id|dev-&gt;open
op_assign
id|scc_enet_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|scc_enet_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|scc_enet_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|TX_TIMEOUT
suffix:semicolon
id|dev-&gt;stop
op_assign
id|scc_enet_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|scc_enet_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
multiline_comment|/* And last, enable the transmit and receive processing.&n;&t;*/
id|sccp-&gt;scc_gsmrl
op_or_assign
(paren
id|SCC_GSMRL_ENR
op_or
id|SCC_GSMRL_ENT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: CPM ENET Version 0.2, &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
