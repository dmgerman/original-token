multiline_comment|/*&n; * $Id: smp.c,v 1.22 1998/04/10 01:53:34 cort Exp $&n; *&n; * Smp support for ppc.&n; *&n; * Written by Cort Dougan (cort@cs.nmt.edu) borrowing a great&n; * deal of code from the sparc and intel versions.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tasks.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#include &lt;asm/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;time.h&quot;
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
op_assign
l_int|0
suffix:semicolon
DECL|variable|smp_commenced
r_volatile
r_int
id|smp_commenced
op_assign
l_int|0
suffix:semicolon
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
DECL|variable|cpu_present_map
r_int
r_int
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
DECL|variable|cpu_number_map
r_volatile
r_int
id|cpu_number_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|cpu_callin_map
r_volatile
r_int
r_int
id|cpu_callin_map
(braket
id|NR_CPUS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|__cpu_logical_map
r_volatile
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|boot_cpu_id
r_static
r_int
r_char
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|cpu_data
r_struct
id|cpuinfo_PPC
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|klock_info
r_struct
id|klock_info_struct
id|klock_info
op_assign
(brace
id|KLOCK_CLEAR
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|active_kernel_processor
r_volatile
r_int
r_char
id|active_kernel_processor
op_assign
id|NO_PROC_ID
suffix:semicolon
multiline_comment|/* Processor holding kernel spinlock&t;&t;*/
DECL|variable|ipi_count
r_volatile
r_int
r_int
id|ipi_count
suffix:semicolon
DECL|variable|prof_multiplier
r_int
r_int
id|prof_multiplier
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|prof_counter
r_int
r_int
id|prof_counter
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_int
id|start_secondary
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_extern
r_int
id|cpu_idle
c_func
(paren
r_void
op_star
id|unused
)paren
suffix:semicolon
DECL|function|smp_boot_cpus
r_void
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
r_int
id|secondary_entry
(braket
)braket
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|current_set
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_int
id|i
comma
id|timeout
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Entering SMP Mode...&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|prof_counter
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|prof_multiplier
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__cpu_logical_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
id|active_kernel_processor
op_assign
id|boot_cpu_id
suffix:semicolon
id|current-&gt;processor
op_assign
id|boot_cpu_id
suffix:semicolon
id|cpu_present_map
op_or_assign
l_int|1
suffix:semicolon
id|cpu_number_map
(braket
id|boot_cpu_id
)braket
op_assign
l_int|0
suffix:semicolon
id|__cpu_logical_map
(braket
l_int|0
)braket
op_assign
id|boot_cpu_id
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP not supported on this machine.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* assume a 2nd processor for now */
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
id|smp_num_cpus
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* create a process for second processor */
id|kernel_thread
c_func
(paren
id|start_secondary
comma
l_int|NULL
comma
id|CLONE_PID
)paren
suffix:semicolon
id|p
op_assign
id|task
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
id|panic
c_func
(paren
l_string|&quot;No idle task for secondary processor&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;processor
op_assign
l_int|1
suffix:semicolon
id|current_set
(braket
l_int|1
)braket
op_assign
id|p
suffix:semicolon
multiline_comment|/* need to flush here since secondary bat&squot;s aren&squot;t setup */
id|dcbf
c_func
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
op_amp
id|current_set
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* setup entry point of secondary processor */
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
l_int|0xf2800000
)paren
op_assign
(paren
r_int
r_int
)paren
id|secondary_entry
op_minus
id|KERNELBASE
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* interrupt secondary to begin executing code */
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
l_int|0xf80000c0
)paren
op_assign
l_int|0L
suffix:semicolon
id|eieio
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait to see if the secondary made a callin (is actually up) */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|15000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|1
)braket
)paren
(brace
r_break
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|1
)braket
)paren
(brace
id|cpu_number_map
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|__cpu_logical_map
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor 1 found.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0 /* this sync&squot;s the decr&squot;s */
id|set_dec
c_func
(paren
id|decrementer_count
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* interrupt secondary to sync the time bases */
id|smp_message_pass
c_func
(paren
l_int|1
comma
l_int|0xf0f0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* interrupt secondary to begin executing code */
multiline_comment|/**(volatile unsigned long *)(0xf80000c0) = 0L;&n;&t;&t;eieio();*/
)brace
r_else
(brace
id|smp_num_cpus
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor %d is stuck.&bslash;n&quot;
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_commence
r_void
id|smp_commence
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP %d: smp_commence()&bslash;n&quot;
comma
id|current-&gt;processor
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Lets the callin&squot;s below out of their loop.&n;&t; */
id|local_flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
id|smp_commenced
op_assign
l_int|1
suffix:semicolon
id|local_flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* intel needs this */
DECL|function|initialize_secondary
r_void
id|initialize_secondary
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/* Activate a secondary processor. */
DECL|function|start_secondary
r_int
id|start_secondary
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP %d: start_secondary()&bslash;n&quot;
comma
id|current-&gt;processor
)paren
suffix:semicolon
id|smp_callin
c_func
(paren
)paren
suffix:semicolon
r_return
id|cpu_idle
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|smp_callin
r_void
id|smp_callin
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP %d: smp_callin()&bslash;n&quot;
comma
id|current-&gt;processor
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|set_dec
c_func
(paren
id|decrementer_count
)paren
suffix:semicolon
id|current-&gt;mm-&gt;mmap-&gt;vm_page_prot
op_assign
id|PAGE_SHARED
suffix:semicolon
id|current-&gt;mm-&gt;mmap-&gt;vm_start
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|current-&gt;mm-&gt;mmap-&gt;vm_end
op_assign
id|init_task.mm-&gt;mmap-&gt;vm_end
suffix:semicolon
multiline_comment|/* assume we&squot;re just the secondary processor for now */
id|cpu_callin_map
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|smp_commenced
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|smp_setup
r_void
id|smp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP %d: smp_setup()&bslash;n&quot;
comma
id|current-&gt;processor
)paren
suffix:semicolon
)brace
DECL|function|smp_local_timer_interrupt
r_void
id|smp_local_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_extern
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|prof_counter
(braket
id|cpu
)braket
)paren
(brace
r_int
id|user
op_assign
l_int|0
comma
id|system
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t;&t; * After doing the above, we need to make like&n;&t;&t; * a normal interrupt - otherwise timer interrupts&n;&t;&t; * ignore the global interrupt lock, which is the&n;&t;&t; * WrongThing (tm) to do.&n;&t;&t; */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|user
op_assign
l_int|1
suffix:semicolon
r_else
id|system
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pid
)paren
(brace
id|update_one_process
c_func
(paren
id|p
comma
l_int|1
comma
id|user
comma
id|system
comma
id|cpu
)paren
suffix:semicolon
id|p-&gt;counter
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OL
l_int|0
)paren
(brace
id|p-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;priority
OL
id|DEF_PRIORITY
)paren
(brace
id|kstat.cpu_nice
op_add_assign
id|user
suffix:semicolon
id|kstat.per_cpu_nice
(braket
id|cpu
)braket
op_add_assign
id|user
suffix:semicolon
)brace
r_else
(brace
id|kstat.cpu_user
op_add_assign
id|user
suffix:semicolon
id|kstat.per_cpu_user
(braket
id|cpu
)braket
op_add_assign
id|user
suffix:semicolon
)brace
id|kstat.cpu_system
op_add_assign
id|system
suffix:semicolon
id|kstat.per_cpu_system
(braket
id|cpu
)braket
op_add_assign
id|system
suffix:semicolon
)brace
id|prof_counter
(braket
id|cpu
)braket
op_assign
id|prof_multiplier
(braket
id|cpu
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Dirty hack to get smp message passing working.&n; * Right now it only works for stop cpu&squot;s but will be setup&n; * later for more general message passing.&n; *&n; * As it is now, if we&squot;re sending two message as the same time&n; * we have race conditions.  I avoided doing locks here since&n; * all that works right now is the stop cpu message.&n; *&n; *  -- Cort&n; */
DECL|variable|smp_message
r_int
id|smp_message
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|function|smp_message_recv
r_void
id|smp_message_recv
c_func
(paren
r_void
)paren
(brace
r_int
id|msg
op_assign
id|smp_message
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMP %d: smp_message_recv() msg %x&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/* make sure msg is for us */
r_if
c_cond
(paren
id|msg
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;recv after msg check&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|msg
)paren
(brace
r_case
id|MSG_STOP_CPU
suffix:colon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf0f0
suffix:colon
multiline_comment|/* syncing time bases - just return */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SMP %d: smp_message_recv(): unknown msg %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|msg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* reset message */
id|smp_message
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
DECL|variable|mesg_pass_lock
id|spinlock_t
id|mesg_pass_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|smp_message_pass
r_void
id|smp_message_pass
c_func
(paren
r_int
id|target
comma
r_int
id|msg
comma
r_int
r_int
id|data
comma
r_int
id|wait
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SMP %d: sending smp message&bslash;n&quot;
comma
id|current-&gt;processor
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mesg_pass_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
r_return
suffix:semicolon
DECL|macro|OTHER
mdefine_line|#define OTHER (~smp_processor_id() &amp; 1)
r_switch
c_cond
(paren
id|target
)paren
(brace
r_case
id|MSG_ALL
suffix:colon
id|smp_message
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|msg
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MSG_ALL_BUT_SELF
suffix:colon
id|smp_message
(braket
id|OTHER
)braket
op_assign
id|msg
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|smp_message
(braket
id|target
)braket
op_assign
id|msg
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* interrupt secondary processor */
multiline_comment|/**(volatile unsigned long *)(0xf80000c0) = 0xffffffff;&n;&t;eieio();*/
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
l_int|0xf80000c0
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* interrupt primary */
multiline_comment|/**(volatile unsigned long *)(0xf3019000);*/
id|spin_unlock
c_func
(paren
op_amp
id|mesg_pass_lock
)paren
suffix:semicolon
)brace
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
)paren
(brace
r_struct
id|cpuinfo_PPC
op_star
id|c
op_assign
op_amp
id|cpu_data
(braket
id|id
)braket
suffix:semicolon
id|c-&gt;loops_per_sec
op_assign
id|loops_per_sec
suffix:semicolon
id|c-&gt;pvr
op_assign
id|_get_PVR
c_func
(paren
)paren
suffix:semicolon
)brace
eof
