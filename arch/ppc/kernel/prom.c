multiline_comment|/*&n; * $Id: prom.c,v 1.32 1998/07/28 20:28:46 geert Exp $&n; *&n; * Procedures for interfacing to the Open Firmware PROM on&n; * Power Macintosh computers.&n; *&n; * In particular, we are interested in the device tree&n; * and in using some of its services (exit, write to stdout).&n; *&n; * Paul Mackerras&t;August 1996.&n; * Copyright (C) 1996 Paul Mackerras.&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; * Properties whose value is longer than this get excluded from our&n; * copy of the device tree.  This way we don&squot;t waste space storing&n; * things like &quot;driver,AAPL,MacOS,PowerPC&quot; properties.&n; */
DECL|macro|MAX_PROPERTY_LENGTH
mdefine_line|#define MAX_PROPERTY_LENGTH&t;1024
DECL|struct|prom_args
r_struct
id|prom_args
(brace
DECL|member|service
r_const
r_char
op_star
id|service
suffix:semicolon
DECL|member|nargs
r_int
id|nargs
suffix:semicolon
DECL|member|nret
r_int
id|nret
suffix:semicolon
DECL|member|args
r_void
op_star
id|args
(braket
l_int|10
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_address
r_struct
id|pci_address
(brace
DECL|member|a_hi
r_int
id|a_hi
suffix:semicolon
DECL|member|a_mid
r_int
id|a_mid
suffix:semicolon
DECL|member|a_lo
r_int
id|a_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_reg_property
r_struct
id|pci_reg_property
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|size_hi
r_int
id|size_hi
suffix:semicolon
DECL|member|size_lo
r_int
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_range
r_struct
id|pci_range
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|phys
r_int
id|phys
suffix:semicolon
DECL|member|size_hi
r_int
id|size_hi
suffix:semicolon
DECL|member|size_lo
r_int
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|isa_reg_property
r_struct
id|isa_reg_property
(brace
DECL|member|space
r_int
id|space
suffix:semicolon
DECL|member|address
r_int
id|address
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|interpret_func
r_typedef
r_int
r_int
id|interpret_func
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|variable|interpret_pci_props
r_static
id|interpret_func
id|interpret_pci_props
suffix:semicolon
DECL|variable|interpret_dbdma_props
r_static
id|interpret_func
id|interpret_dbdma_props
suffix:semicolon
DECL|variable|interpret_isa_props
r_static
id|interpret_func
id|interpret_isa_props
suffix:semicolon
DECL|variable|interpret_macio_props
r_static
id|interpret_func
id|interpret_macio_props
suffix:semicolon
DECL|variable|interpret_root_props
r_static
id|interpret_func
id|interpret_root_props
suffix:semicolon
DECL|variable|__initdata
r_char
op_star
id|prom_display_paths
(braket
id|FB_MAX
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|prom_num_displays
r_int
r_int
id|prom_num_displays
op_assign
l_int|0
suffix:semicolon
DECL|variable|prom
id|prom_entry
id|prom
op_assign
l_int|0
suffix:semicolon
DECL|variable|prom_chosen
DECL|variable|prom_stdout
id|ihandle
id|prom_chosen
op_assign
l_int|0
comma
id|prom_stdout
op_assign
l_int|0
suffix:semicolon
r_extern
r_char
op_star
id|klimit
suffix:semicolon
DECL|variable|bootpath
r_char
op_star
id|bootpath
op_assign
l_int|0
suffix:semicolon
DECL|variable|bootdevice
r_char
op_star
id|bootdevice
op_assign
l_int|0
suffix:semicolon
DECL|variable|rtas_data
r_int
r_int
id|rtas_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* virtual pointer */
DECL|variable|rtas_entry
r_int
r_int
id|rtas_entry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* physical pointer */
DECL|variable|rtas_size
r_int
r_int
id|rtas_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|old_rtas
r_int
r_int
id|old_rtas
op_assign
l_int|0
suffix:semicolon
DECL|variable|allnodes
r_static
r_struct
id|device_node
op_star
id|allnodes
op_assign
l_int|0
suffix:semicolon
r_static
r_void
op_star
id|call_prom
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
suffix:semicolon
r_void
id|prom_print
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
suffix:semicolon
r_static
r_void
id|prom_exit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|copy_device_tree
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|inspect_node
c_func
(paren
id|phandle
comma
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|device_node
op_star
op_star
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|finish_node
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
id|interpret_func
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|check_display
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|prom_next_node
c_func
(paren
id|phandle
op_star
)paren
suffix:semicolon
r_extern
r_void
id|enter_rtas
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_extern
r_int
r_int
id|reloc_offset
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * prom_init() is called very early on, before the kernel text&n; * and data have been mapped to KERNELBASE.  At this point the code&n; * is running at whatever address it has been loaded at, so&n; * references to extern and static variables must be relocated&n; * explicitly.  The procedure reloc_offset() returns the address&n; * we&squot;re currently running at minus the address we were linked at.&n; * (Note that strings count as static variables.)&n; *&n; * Because OF may have mapped I/O devices into the area starting at&n; * KERNELBASE, particularly on CHRP machines, we can&squot;t safely call&n; * OF once the kernel has been mapped to KERNELBASE.  Therefore all&n; * OF calls should be done within prom_init(), and prom_init()&n; * and all routines called within it must be careful to relocate&n; * references as necessary.&n; *&n; * Note that the bss is cleared *after* prom_init runs, so we have&n; * to make sure that any static or extern variables it accesses&n; * are put in the data segment.&n; */
DECL|macro|PTRRELOC
mdefine_line|#define PTRRELOC(x)&t;((typeof(x))((unsigned long)(x) + offset))
DECL|macro|PTRUNRELOC
mdefine_line|#define PTRUNRELOC(x)&t;((typeof(x))((unsigned long)(x) - offset))
DECL|macro|RELOC
mdefine_line|#define RELOC(x)&t;(*PTRRELOC(&amp;(x)))
DECL|macro|ALIGN
mdefine_line|#define ALIGN(x) (((x) + sizeof(unsigned long)-1) &amp; -sizeof(unsigned long))
id|__openfirmware
r_static
r_void
DECL|function|prom_exit
id|prom_exit
c_func
(paren
)paren
(brace
r_struct
id|prom_args
id|args
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|args.service
op_assign
l_string|&quot;exit&quot;
suffix:semicolon
id|args.nargs
op_assign
l_int|0
suffix:semicolon
id|args.nret
op_assign
l_int|0
suffix:semicolon
id|RELOC
c_func
(paren
id|prom
)paren
(paren
op_amp
id|args
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
multiline_comment|/* should never get here */
suffix:semicolon
)brace
id|__openfirmware
r_void
DECL|function|prom_enter
id|prom_enter
c_func
(paren
r_void
)paren
(brace
r_struct
id|prom_args
id|args
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|args.service
op_assign
id|RELOC
c_func
(paren
l_string|&quot;enter&quot;
)paren
suffix:semicolon
id|args.nargs
op_assign
l_int|0
suffix:semicolon
id|args.nret
op_assign
l_int|0
suffix:semicolon
id|RELOC
c_func
(paren
id|prom
)paren
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
id|__openfirmware
r_static
r_void
op_star
DECL|function|call_prom
id|call_prom
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_struct
id|prom_args
id|prom_args
suffix:semicolon
id|prom_args.service
op_assign
id|service
suffix:semicolon
id|prom_args.nargs
op_assign
id|nargs
suffix:semicolon
id|prom_args.nret
op_assign
id|nret
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|nret
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
op_increment
id|i
)paren
id|prom_args.args
(braket
id|i
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_void
op_star
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nret
suffix:semicolon
op_increment
id|i
)paren
id|prom_args.args
(braket
id|i
op_plus
id|nargs
)braket
op_assign
l_int|0
suffix:semicolon
id|RELOC
c_func
(paren
id|prom
)paren
(paren
op_amp
id|prom_args
)paren
suffix:semicolon
r_return
id|prom_args.args
(braket
id|nargs
)braket
suffix:semicolon
)brace
id|__openfirmware
r_void
DECL|function|prom_print
id|prom_print
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_const
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|msg
suffix:semicolon
op_star
id|p
op_ne
l_int|0
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|p
suffix:semicolon
op_star
id|q
op_ne
l_int|0
op_logical_and
op_star
id|q
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_increment
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
OG
id|p
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;write&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|RELOC
c_func
(paren
id|prom_stdout
)paren
comma
id|p
comma
id|q
op_minus
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_ne
l_int|0
)paren
(brace
op_increment
id|q
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;write&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|RELOC
c_func
(paren
id|prom_stdout
)paren
comma
id|RELOC
c_func
(paren
l_string|&quot;&bslash;r&bslash;n&quot;
)paren
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * We enter here early on, when the Open Firmware prom is still&n; * handling exceptions and the MMU hash table for us.&n; */
id|__openfirmware
r_void
DECL|function|prom_init
id|prom_init
c_func
(paren
r_int
id|r3
comma
r_int
id|r4
comma
id|prom_entry
id|pp
)paren
(brace
r_int
r_int
id|mem
suffix:semicolon
id|ihandle
id|prom_rtas
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
id|l
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|d
suffix:semicolon
multiline_comment|/* check if we&squot;re prep, return if we are */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
l_int|0
)paren
op_eq
l_int|0xdeadc0de
)paren
r_return
suffix:semicolon
multiline_comment|/* check if we&squot;re apus, return if we are */
r_if
c_cond
(paren
id|r3
op_eq
l_int|0x61707573
)paren
r_return
suffix:semicolon
multiline_comment|/* First get a handle for the stdout device */
id|RELOC
c_func
(paren
id|prom
)paren
op_assign
id|pp
suffix:semicolon
id|RELOC
c_func
(paren
id|prom_chosen
)paren
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;finddevice&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/chosen&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|prom_chosen
)paren
op_eq
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
id|prom_exit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|RELOC
c_func
(paren
id|prom_chosen
)paren
comma
id|RELOC
c_func
(paren
l_string|&quot;stdout&quot;
)paren
comma
op_amp
id|RELOC
c_func
(paren
id|prom_stdout
)paren
comma
r_sizeof
(paren
id|prom_stdout
)paren
)paren
op_le
l_int|0
)paren
id|prom_exit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get the boot device and translate it to a full OF pathname. */
id|mem
op_assign
(paren
r_int
r_int
)paren
id|RELOC
c_func
(paren
id|klimit
)paren
op_plus
id|offset
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|l
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|RELOC
c_func
(paren
id|prom_chosen
)paren
comma
id|RELOC
c_func
(paren
l_string|&quot;bootpath&quot;
)paren
comma
id|p
comma
l_int|1
op_lshift
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|0
)paren
(brace
id|p
(braket
id|l
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* should already be null-terminated */
id|RELOC
c_func
(paren
id|bootpath
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
id|p
)paren
suffix:semicolon
id|mem
op_add_assign
id|l
op_plus
l_int|1
suffix:semicolon
id|d
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
op_star
id|d
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;canon&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|p
comma
id|d
comma
l_int|1
op_lshift
l_int|20
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|bootdevice
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
id|d
)paren
suffix:semicolon
id|mem
op_assign
id|ALIGN
c_func
(paren
id|mem
op_plus
id|strlen
c_func
(paren
id|d
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|mem
op_assign
id|check_display
c_func
(paren
id|mem
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;copying OF device tree...&quot;
)paren
)paren
suffix:semicolon
id|mem
op_assign
id|copy_device_tree
c_func
(paren
id|mem
comma
id|mem
op_plus
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|prom_rtas
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;finddevice&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_rtas
op_ne
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
(brace
id|RELOC
c_func
(paren
id|rtas_size
)paren
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|prom_rtas
comma
id|RELOC
c_func
(paren
l_string|&quot;rtas-size&quot;
)paren
comma
op_amp
id|RELOC
c_func
(paren
id|rtas_size
)paren
comma
r_sizeof
(paren
id|rtas_size
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;instantiating rtas...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|rtas_size
)paren
op_eq
l_int|0
)paren
(brace
id|RELOC
c_func
(paren
id|rtas_data
)paren
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|mem
op_assign
(paren
id|mem
op_plus
l_int|4095
)paren
op_amp
op_minus
l_int|4096
suffix:semicolon
multiline_comment|/* round to page bdry */
id|RELOC
c_func
(paren
id|rtas_data
)paren
op_assign
id|mem
op_plus
id|KERNELBASE
suffix:semicolon
id|mem
op_add_assign
id|RELOC
c_func
(paren
id|rtas_size
)paren
suffix:semicolon
)brace
id|prom_rtas
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;open&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|RELOC
c_func
(paren
l_string|&quot;/rtas&quot;
)paren
)paren
suffix:semicolon
(brace
r_int
id|i
comma
id|nargs
suffix:semicolon
r_struct
id|prom_args
id|prom_args
suffix:semicolon
id|nargs
op_assign
l_int|3
suffix:semicolon
id|prom_args.service
op_assign
id|RELOC
c_func
(paren
l_string|&quot;call-method&quot;
)paren
suffix:semicolon
id|prom_args.nargs
op_assign
id|nargs
suffix:semicolon
id|prom_args.nret
op_assign
l_int|2
suffix:semicolon
id|prom_args.args
(braket
l_int|0
)braket
op_assign
id|RELOC
c_func
(paren
l_string|&quot;instantiate-rtas&quot;
)paren
suffix:semicolon
id|prom_args.args
(braket
l_int|1
)braket
op_assign
id|prom_rtas
suffix:semicolon
id|prom_args.args
(braket
l_int|2
)braket
op_assign
(paren
(paren
r_void
op_star
)paren
id|RELOC
c_func
(paren
id|rtas_data
)paren
op_minus
id|KERNELBASE
op_minus
id|offset
)paren
suffix:semicolon
id|RELOC
c_func
(paren
id|prom
)paren
(paren
op_amp
id|prom_args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_args.args
(braket
id|nargs
)braket
op_ne
l_int|0
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_else
id|i
op_assign
(paren
r_int
)paren
id|prom_args.args
(braket
id|nargs
op_plus
l_int|1
)braket
suffix:semicolon
id|RELOC
c_func
(paren
id|rtas_entry
)paren
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|RELOC
c_func
(paren
id|rtas_entry
)paren
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|RELOC
c_func
(paren
id|rtas_entry
)paren
op_eq
l_int|0
)paren
)paren
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_else
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|RELOC
c_func
(paren
id|klimit
)paren
op_assign
(paren
r_char
op_star
)paren
(paren
id|mem
op_minus
id|offset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If we have a display that we don&squot;t know how to drive,&n; * we will want to try to execute OF&squot;s open method for it&n; * later.  However, OF will probably fall over if we do that&n; * we&squot;ve taken over the MMU.&n; * So we check whether we will need to open the display,&n; * and if so, open it now.&n; */
id|__openfirmware
r_static
r_int
r_int
DECL|function|check_display
id|check_display
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
id|phandle
id|node
suffix:semicolon
id|ihandle
id|ih
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_char
id|type
(braket
l_int|16
)braket
comma
id|name
(braket
l_int|16
)braket
comma
op_star
id|path
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;device_type&quot;
)paren
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
id|RELOC
c_func
(paren
l_string|&quot;display&quot;
)paren
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* It seems OF doesn&squot;t null-terminate the path :-( */
id|path
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;package-to-path&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
l_int|255
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;opening display &quot;
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;open&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ih
op_eq
l_int|0
op_logical_or
id|ih
op_eq
(paren
id|ihandle
)paren
op_minus
l_int|1
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;... failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* platinum kludge. platinum is a valid display,&n;&t;&t;&t; * but not handled by OF. Make sure prom_num_display&n;&t;&t;&t; * is incremented anyway&n;&t;&t;&t; */
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|RELOC
c_func
(paren
l_string|&quot;name&quot;
)paren
comma
id|name
comma
r_sizeof
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
id|RELOC
c_func
(paren
l_string|&quot;platinum&quot;
)paren
comma
l_int|8
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;... ok&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|mem
op_add_assign
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
suffix:semicolon
id|RELOC
c_func
(paren
id|prom_display_paths
(braket
id|RELOC
c_func
(paren
id|prom_num_displays
)paren
op_increment
)braket
)paren
op_assign
id|PTRUNRELOC
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RELOC
c_func
(paren
id|prom_num_displays
)paren
op_ge
id|FB_MAX
)paren
r_break
suffix:semicolon
)brace
r_return
id|ALIGN
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
DECL|function|prom_next_node
id|prom_next_node
c_func
(paren
id|phandle
op_star
id|nodep
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node
op_assign
op_star
id|nodep
)paren
op_ne
l_int|0
op_logical_and
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;child&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|node
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;parent&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Make a copy of the device tree from the PROM.&n; */
id|__openfirmware
r_static
r_int
r_int
DECL|function|copy_device_tree
id|copy_device_tree
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
id|phandle
id|root
suffix:semicolon
r_int
r_int
id|new_start
suffix:semicolon
r_struct
id|device_node
op_star
op_star
id|allnextp
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|root
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
(paren
id|phandle
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
(paren
id|phandle
)paren
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;couldn&squot;t get device tree root&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|prom_exit
c_func
(paren
)paren
suffix:semicolon
)brace
id|allnextp
op_assign
op_amp
id|RELOC
c_func
(paren
id|allnodes
)paren
suffix:semicolon
id|mem_start
op_assign
id|ALIGN
c_func
(paren
id|mem_start
)paren
suffix:semicolon
id|new_start
op_assign
id|inspect_node
c_func
(paren
id|root
comma
l_int|0
comma
id|mem_start
comma
id|mem_end
comma
op_amp
id|allnextp
)paren
suffix:semicolon
op_star
id|allnextp
op_assign
l_int|0
suffix:semicolon
r_return
id|new_start
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
r_int
DECL|function|inspect_node
id|inspect_node
c_func
(paren
id|phandle
id|node
comma
r_struct
id|device_node
op_star
id|dad
comma
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
comma
r_struct
id|device_node
op_star
op_star
op_star
id|allnextpp
)paren
(brace
r_int
id|l
suffix:semicolon
id|phandle
id|child
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_struct
id|property
op_star
id|pp
comma
op_star
op_star
id|prev_propp
suffix:semicolon
r_char
op_star
id|prev_name
comma
op_star
id|namep
suffix:semicolon
r_int
r_char
op_star
id|valp
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
id|np
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
r_sizeof
(paren
r_struct
id|device_node
)paren
suffix:semicolon
id|memset
c_func
(paren
id|np
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;node
op_assign
id|node
suffix:semicolon
op_star
op_star
id|allnextpp
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
op_star
id|allnextpp
op_assign
op_amp
id|np-&gt;allnext
suffix:semicolon
r_if
c_cond
(paren
id|dad
op_ne
l_int|0
)paren
(brace
id|np-&gt;parent
op_assign
id|PTRUNRELOC
c_func
(paren
id|dad
)paren
suffix:semicolon
multiline_comment|/* we temporarily use the `next&squot; field as `last_child&squot;. */
r_if
c_cond
(paren
id|dad-&gt;next
op_eq
l_int|0
)paren
id|dad-&gt;child
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
r_else
id|dad-&gt;next-&gt;sibling
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
id|dad-&gt;next
op_assign
id|np
suffix:semicolon
)brace
multiline_comment|/* get and store all properties */
id|prev_propp
op_assign
op_amp
id|np-&gt;properties
suffix:semicolon
id|prev_name
op_assign
id|RELOC
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pp
op_assign
(paren
r_struct
id|property
op_star
)paren
id|mem_start
suffix:semicolon
id|namep
op_assign
(paren
r_char
op_star
)paren
(paren
id|pp
op_plus
l_int|1
)paren
suffix:semicolon
id|pp-&gt;name
op_assign
id|PTRUNRELOC
c_func
(paren
id|namep
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;nextprop&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|prev_name
comma
id|namep
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|mem_start
op_assign
id|ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|namep
op_plus
id|strlen
c_func
(paren
id|namep
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|prev_name
op_assign
id|namep
suffix:semicolon
id|valp
op_assign
(paren
r_int
r_char
op_star
)paren
id|mem_start
suffix:semicolon
id|pp-&gt;value
op_assign
id|PTRUNRELOC
c_func
(paren
id|valp
)paren
suffix:semicolon
id|pp-&gt;length
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;getprop&quot;
)paren
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|namep
comma
id|valp
comma
id|mem_end
op_minus
id|mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
OL
l_int|0
)paren
r_continue
suffix:semicolon
macro_line|#ifdef MAX_PROPERTY_LENGTH
r_if
c_cond
(paren
id|pp-&gt;length
OG
id|MAX_PROPERTY_LENGTH
)paren
r_continue
suffix:semicolon
multiline_comment|/* ignore this property */
macro_line|#endif
id|mem_start
op_assign
id|ALIGN
c_func
(paren
id|mem_start
op_plus
id|pp-&gt;length
)paren
suffix:semicolon
op_star
id|prev_propp
op_assign
id|PTRUNRELOC
c_func
(paren
id|pp
)paren
suffix:semicolon
id|prev_propp
op_assign
op_amp
id|pp-&gt;next
suffix:semicolon
)brace
op_star
id|prev_propp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get the node&squot;s full name */
id|l
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;package-to-path&quot;
)paren
comma
l_int|3
comma
l_int|1
comma
id|node
comma
(paren
r_char
op_star
)paren
id|mem_start
comma
id|mem_end
op_minus
id|mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ge
l_int|0
)paren
(brace
id|np-&gt;full_name
op_assign
id|PTRUNRELOC
c_func
(paren
(paren
r_char
op_star
)paren
id|mem_start
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
(paren
id|mem_start
op_plus
id|l
)paren
op_assign
l_int|0
suffix:semicolon
id|mem_start
op_assign
id|ALIGN
c_func
(paren
id|mem_start
op_plus
id|l
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* do all our children */
id|child
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;child&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
suffix:semicolon
r_while
c_loop
(paren
id|child
op_ne
(paren
r_void
op_star
)paren
l_int|0
)paren
(brace
id|mem_start
op_assign
id|inspect_node
c_func
(paren
id|child
comma
id|np
comma
id|mem_start
comma
id|mem_end
comma
id|allnextpp
)paren
suffix:semicolon
id|child
op_assign
id|call_prom
c_func
(paren
id|RELOC
c_func
(paren
l_string|&quot;peer&quot;
)paren
comma
l_int|1
comma
l_int|1
comma
id|child
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * finish_device_tree is called once things are running normally&n; * (i.e. with text and data mapped to the address they were linked at).&n; * It traverses the device tree and fills in the name, type,&n; * {n_}addrs and {n_}intrs fields of each node.&n; */
id|__openfirmware
r_void
DECL|function|finish_device_tree
id|finish_device_tree
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mem
op_assign
(paren
r_int
r_int
)paren
id|klimit
suffix:semicolon
id|mem
op_assign
id|finish_node
c_func
(paren
id|allnodes
comma
id|mem
comma
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;device tree used %lu bytes&bslash;n&quot;
comma
id|mem
op_minus
(paren
r_int
r_int
)paren
id|allnodes
)paren
suffix:semicolon
id|klimit
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
r_int
DECL|function|finish_node
id|finish_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
id|interpret_func
op_star
id|ifunc
)paren
(brace
r_struct
id|device_node
op_star
id|child
suffix:semicolon
id|np-&gt;name
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;name&quot;
comma
l_int|0
)paren
suffix:semicolon
id|np-&gt;type
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;device_type&quot;
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* get the device addresses and interrupts */
r_if
c_cond
(paren
id|ifunc
op_ne
l_int|NULL
)paren
(brace
id|mem_start
op_assign
id|ifunc
c_func
(paren
id|np
comma
id|mem_start
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;device-tree&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_root_props
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;type
op_eq
l_int|0
)paren
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;pci&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;vci&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_pci_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
op_logical_or
(paren
id|ifunc
op_eq
id|interpret_dbdma_props
op_logical_and
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;escc&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;media-bay&quot;
)paren
)paren
)paren
)paren
id|ifunc
op_assign
id|interpret_dbdma_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_macio_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;isa&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_isa_props
suffix:semicolon
r_else
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|child
op_assign
id|np-&gt;child
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|child-&gt;sibling
)paren
id|mem_start
op_assign
id|finish_node
c_func
(paren
id|child
comma
id|mem_start
comma
id|ifunc
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
r_int
DECL|function|interpret_pci_props
id|interpret_pci_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_struct
id|pci_reg_property
op_star
id|pci_addrs
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
id|pci_addrs
op_assign
(paren
r_struct
id|pci_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;assigned-addresses&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_addrs
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* XXX assumes PCI addresses mapped 1-1 to physical */
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_hi
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_lo
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|size_lo
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
r_int
DECL|function|interpret_dbdma_props
id|interpret_dbdma_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|0
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
r_int
DECL|function|interpret_macio_props
id|interpret_macio_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|0
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
id|openpic_to_irq
c_func
(paren
op_star
id|ip
op_increment
)paren
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
op_star
id|ip
op_increment
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
r_int
DECL|function|interpret_isa_props
id|interpret_isa_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
)paren
(brace
r_struct
id|isa_reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|isa_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|isa_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|rp
(braket
id|i
)braket
dot
id|space
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
(paren
id|adr
(braket
id|i
)braket
dot
id|space
ques
c_cond
l_int|0
suffix:colon
id|_ISA_MEM_BASE
)paren
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
op_star
id|ip
op_increment
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
id|__openfirmware
r_static
r_int
r_int
DECL|function|interpret_root_props
id|interpret_root_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|0
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given name.&n; */
id|__openfirmware
r_struct
id|device_node
op_star
DECL|function|find_devices
id|find_devices
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|0
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given type.&n; */
id|__openfirmware
r_struct
id|device_node
op_star
DECL|function|find_type_devices
id|find_type_devices
c_func
(paren
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|0
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given type&n; * and compatible property.&n; */
id|__openfirmware
r_struct
id|device_node
op_star
DECL|function|find_compatible_devices
id|find_compatible_devices
c_func
(paren
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|compat
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
r_const
r_char
op_star
id|cp
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;compatible&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_ne
l_int|NULL
op_logical_and
id|strcasecmp
c_func
(paren
id|cp
comma
id|compat
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|0
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the device_node with a given full_name.&n; */
id|__openfirmware
r_struct
id|device_node
op_star
DECL|function|find_path_device
id|find_path_device
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;full_name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
op_eq
l_int|0
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the device_node with a given phandle.&n; */
id|__openfirmware
r_struct
id|device_node
op_star
DECL|function|find_phandle
id|find_phandle
c_func
(paren
id|phandle
id|ph
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;node
op_eq
id|ph
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a property with a given name for a given node&n; * and return the value.&n; */
id|__openfirmware
r_int
r_char
op_star
DECL|function|get_property
id|get_property
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|lenp
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pp-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lenp
op_ne
l_int|0
)paren
op_star
id|lenp
op_assign
id|pp-&gt;length
suffix:semicolon
r_return
id|pp-&gt;value
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|__openfirmware
r_void
DECL|function|print_properties
id|print_properties
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|pp-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|strlen
c_func
(paren
id|pp-&gt;name
)paren
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pp-&gt;length
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|cp
)paren
r_if
c_cond
(paren
(paren
id|i
OG
l_int|1
op_logical_and
(paren
op_star
id|cp
template_param
l_int|0x7e
)paren
)paren
op_logical_or
(paren
id|i
op_eq
l_int|1
op_logical_and
op_star
id|cp
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|pp-&gt;length
OG
l_int|1
)paren
(brace
multiline_comment|/* looks like a string */
id|printk
c_func
(paren
l_string|&quot; %s&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|pp-&gt;value
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* dump it in hex */
id|n
op_assign
id|pp-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|64
)paren
id|n
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
op_mod
l_int|4
op_eq
l_int|0
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|pp-&gt;value
suffix:semicolon
id|n
op_div_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %08x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_char
op_star
id|bp
op_assign
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|bp
op_increment
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
OG
l_int|64
)paren
id|printk
c_func
(paren
l_string|&quot;                 ... (length = %d)&bslash;n&quot;
comma
id|pp-&gt;length
)paren
suffix:semicolon
)brace
)brace
)brace
id|__openfirmware
r_int
DECL|function|call_rtas
id|call_rtas
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
r_int
r_int
op_star
id|outputs
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|device_node
op_star
id|rtas
suffix:semicolon
r_int
op_star
id|tokp
suffix:semicolon
r_union
(brace
r_int
r_int
id|words
(braket
l_int|16
)braket
suffix:semicolon
r_float
id|align
suffix:semicolon
)brace
id|u
suffix:semicolon
id|rtas
op_assign
id|find_devices
c_func
(paren
l_string|&quot;rtas&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtas
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tokp
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|rtas
comma
id|service
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tokp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No RTAS service called %s&bslash;n&quot;
comma
id|service
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|u.words
(braket
l_int|0
)braket
op_assign
id|__pa
c_func
(paren
op_star
id|tokp
)paren
suffix:semicolon
id|u.words
(braket
l_int|1
)braket
op_assign
id|nargs
suffix:semicolon
id|u.words
(braket
l_int|2
)braket
op_assign
id|nret
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|outputs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
op_increment
id|i
)paren
id|u.words
(braket
id|i
op_plus
l_int|3
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_int
r_int
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
id|enter_rtas
c_func
(paren
(paren
r_void
op_star
)paren
id|__pa
c_func
(paren
op_amp
id|u
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nret
OG
l_int|1
op_logical_and
id|outputs
op_ne
l_int|NULL
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nret
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
id|outputs
(braket
id|i
)braket
op_assign
id|u.words
(braket
id|i
op_plus
id|nargs
op_plus
l_int|4
)braket
suffix:semicolon
r_return
id|u.words
(braket
id|nargs
op_plus
l_int|3
)braket
suffix:semicolon
)brace
id|__openfirmware
r_void
DECL|function|abort
m_abort
(paren
)paren
(brace
macro_line|#ifdef CONFIG_XMON
r_extern
r_void
id|xmon
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
id|xmon
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|prom_exit
c_func
(paren
)paren
suffix:semicolon
)brace
eof
