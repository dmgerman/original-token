multiline_comment|/*&n; * $Id: process.c,v 1.97 1999/09/14 19:07:42 cort Exp $&n; *&n; *  linux/arch/ppc/kernel/process.c&n; *&n; *  Derived from &quot;arch/i386/kernel/process.c&quot;&n; *    Copyright (C) 1995  Linus Torvalds&n; *&n; *  Updated and modified by Cort Dougan (cort@cs.nmt.edu) and&n; *  Paul Mackerras (paulus@cs.anu.edu.au)&n; *&n; *  PowerPC version &n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
r_int
id|dump_fpu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|elf_fpregset_t
op_star
id|fpregs
)paren
suffix:semicolon
r_extern
r_int
r_int
id|_get_SP
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|last_task_used_math
r_struct
id|task_struct
op_star
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|last_task_used_altivec
r_struct
id|task_struct
op_star
id|last_task_used_altivec
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|init_mmap
r_static
r_struct
id|vm_area_struct
id|init_mmap
op_assign
id|INIT_MMAP
suffix:semicolon
DECL|variable|init_fs
r_static
r_struct
id|fs_struct
id|init_fs
op_assign
id|INIT_FS
suffix:semicolon
DECL|variable|init_files
r_static
r_struct
id|files_struct
id|init_files
op_assign
id|INIT_FILES
suffix:semicolon
DECL|variable|init_signals
r_static
r_struct
id|signal_struct
id|init_signals
op_assign
id|INIT_SIGNALS
suffix:semicolon
DECL|variable|init_mm
r_struct
id|mm_struct
id|init_mm
op_assign
id|INIT_MM
c_func
(paren
id|init_mm
)paren
suffix:semicolon
multiline_comment|/* this is 16-byte aligned because it has a stack in it */
r_union
id|task_union
id|__attribute
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|16
)paren
)paren
)paren
id|init_task_union
op_assign
(brace
id|INIT_TASK
c_func
(paren
id|init_task_union.task
)paren
)brace
suffix:semicolon
multiline_comment|/* only used to get secondary processor up */
DECL|variable|current_set
r_struct
id|task_struct
op_star
id|current_set
(braket
id|NR_CPUS
)braket
op_assign
(brace
op_amp
id|init_task
comma
)brace
suffix:semicolon
DECL|variable|sysmap
r_char
op_star
id|sysmap
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sysmap_size
r_int
r_int
id|sysmap_size
op_assign
l_int|0
suffix:semicolon
DECL|macro|SHOW_TASK_SWITCHES
macro_line|#undef SHOW_TASK_SWITCHES 1
DECL|macro|CHECK_STACK
macro_line|#undef CHECK_STACK 1
macro_line|#if defined(CHECK_STACK)
r_int
r_int
DECL|function|kernel_stack_top
id|kernel_stack_top
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|tsk
)paren
op_plus
r_sizeof
(paren
r_union
id|task_union
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|task_top
id|task_top
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|tsk
)paren
op_plus
r_sizeof
(paren
r_struct
id|task_struct
)paren
suffix:semicolon
)brace
multiline_comment|/* check to make sure the kernel stack is healthy */
DECL|function|check_stack
r_int
id|check_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
r_int
id|stack_top
op_assign
id|kernel_stack_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_int
r_int
id|tsk_top
op_assign
id|task_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0&t;
multiline_comment|/* check thread magic */
r_if
c_cond
(paren
id|tsk-&gt;thread.magic
op_ne
id|THREAD_MAGIC
)paren
(brace
id|ret
op_or_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;thread.magic bad: %08x&bslash;n&quot;
comma
id|tsk-&gt;thread.magic
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|tsk
)paren
id|printk
c_func
(paren
l_string|&quot;check_stack(): tsk bad tsk %p&bslash;n&quot;
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* check if stored ksp is bad */
r_if
c_cond
(paren
(paren
id|tsk-&gt;thread.ksp
OG
id|stack_top
)paren
op_logical_or
(paren
id|tsk-&gt;thread.ksp
OL
id|tsk_top
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;stack out of bounds: %s/%d&bslash;n&quot;
l_string|&quot; tsk_top %08lx ksp %08lx stack_top %08lx&bslash;n&quot;
comma
id|tsk-&gt;comm
comma
id|tsk-&gt;pid
comma
id|tsk_top
comma
id|tsk-&gt;thread.ksp
comma
id|stack_top
)paren
suffix:semicolon
id|ret
op_or_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* check if stack ptr RIGHT NOW is bad */
r_if
c_cond
(paren
(paren
id|tsk
op_eq
id|current
)paren
op_logical_and
(paren
(paren
id|_get_SP
c_func
(paren
)paren
OG
id|stack_top
)paren
op_logical_or
(paren
id|_get_SP
c_func
(paren
)paren
OL
id|tsk_top
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;current stack ptr out of bounds: %s/%d&bslash;n&quot;
l_string|&quot; tsk_top %08lx sp %08lx stack_top %08lx&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|tsk_top
comma
id|_get_SP
c_func
(paren
)paren
comma
id|stack_top
)paren
suffix:semicolon
id|ret
op_or_assign
l_int|4
suffix:semicolon
)brace
macro_line|#if 0&t;
multiline_comment|/* check amount of free stack */
r_for
c_loop
(paren
id|i
op_assign
(paren
r_int
r_int
op_star
)paren
id|task_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|i
OL
id|kernel_stack_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;check_stack(): i = %p&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|i
op_ne
l_int|0
)paren
(brace
multiline_comment|/* only notify if it&squot;s less than 900 bytes */
r_if
c_cond
(paren
(paren
id|i
op_minus
(paren
r_int
r_int
op_star
)paren
id|task_top
c_func
(paren
id|tsk
)paren
)paren
OL
l_int|900
)paren
id|printk
c_func
(paren
l_string|&quot;%d bytes free on stack&bslash;n&quot;
comma
id|i
op_minus
id|task_top
c_func
(paren
id|tsk
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ret
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;bad kernel stack&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* defined(CHECK_STACK) */
macro_line|#ifdef CONFIG_ALTIVEC
r_int
DECL|function|dump_altivec
id|dump_altivec
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|elf_vrregset_t
op_star
id|vrregs
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;msr
op_amp
id|MSR_VEC
)paren
id|giveup_altivec
c_func
(paren
id|current
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|vrregs
comma
op_amp
id|current-&gt;thread.vr
(braket
l_int|0
)braket
comma
r_sizeof
(paren
op_star
id|vrregs
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|enable_kernel_altivec
id|enable_kernel_altivec
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|current-&gt;thread.regs
op_logical_and
(paren
id|current-&gt;thread.regs-&gt;msr
op_amp
id|MSR_VEC
)paren
)paren
id|giveup_altivec
c_func
(paren
id|current
)paren
suffix:semicolon
r_else
id|giveup_altivec
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* just enable AltiVec for kernel - force */
macro_line|#else
id|giveup_altivec
c_func
(paren
id|last_task_used_altivec
)paren
suffix:semicolon
macro_line|#endif /* __SMP __ */
id|printk
c_func
(paren
l_string|&quot;MSR_VEC in enable_altivec_kernel&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ALTIVEC */
r_void
DECL|function|enable_kernel_fp
id|enable_kernel_fp
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|current-&gt;thread.regs
op_logical_and
(paren
id|current-&gt;thread.regs-&gt;msr
op_amp
id|MSR_FP
)paren
)paren
id|giveup_fpu
c_func
(paren
id|current
)paren
suffix:semicolon
r_else
id|giveup_fpu
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* just enables FP for kernel */
macro_line|#else
id|giveup_fpu
c_func
(paren
id|last_task_used_math
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
)brace
r_int
DECL|function|dump_fpu
id|dump_fpu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|elf_fpregset_t
op_star
id|fpregs
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;msr
op_amp
id|MSR_FP
)paren
id|giveup_fpu
c_func
(paren
id|current
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|fpregs
comma
op_amp
id|current-&gt;thread.fpr
(braket
l_int|0
)braket
comma
r_sizeof
(paren
op_star
id|fpregs
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|_switch_to
id|_switch_to
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
comma
r_struct
id|task_struct
op_star
r_new
comma
r_struct
id|task_struct
op_star
op_star
id|last
)paren
(brace
r_struct
id|thread_struct
op_star
id|new_thread
comma
op_star
id|old_thread
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|__save_flags
c_func
(paren
id|s
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if CHECK_STACK
id|check_stack
c_func
(paren
id|prev
)paren
suffix:semicolon
id|check_stack
c_func
(paren
r_new
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SHOW_TASK_SWITCHES
id|printk
c_func
(paren
l_string|&quot;%s/%d -&gt; %s/%d NIP %08lx cpu %d root %x/%x&bslash;n&quot;
comma
id|prev-&gt;comm
comma
id|prev-&gt;pid
comma
r_new
op_member_access_from_pointer
id|comm
comma
r_new
op_member_access_from_pointer
id|pid
comma
r_new
op_member_access_from_pointer
id|thread.regs-&gt;nip
comma
r_new
op_member_access_from_pointer
id|processor
comma
r_new
op_member_access_from_pointer
id|fs-&gt;root
comma
id|prev-&gt;fs-&gt;root
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* avoid complexity of lazy save/restore of fpu&n;&t; * by just saving it every time we switch out if&n;&t; * this task used the fpu during the last quantum.&n;&t; * &n;&t; * If it tries to use the fpu again, it&squot;ll trap and&n;&t; * reload its fp regs.  So we don&squot;t have to do a restore&n;&t; * every switch, just a save.&n;&t; *  -- Cort&n;&t; */
r_if
c_cond
(paren
id|prev-&gt;thread.regs
op_logical_and
(paren
id|prev-&gt;thread.regs-&gt;msr
op_amp
id|MSR_FP
)paren
)paren
id|giveup_fpu
c_func
(paren
id|prev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ALTIVEC&t;
multiline_comment|/*&n;&t; * If the previous thread 1) has some altivec regs it wants saved&n;&t; * (has bits in vrsave set) and 2) used altivec in the last quantum&n;&t; * (thus changing altivec regs) then save them.&n;&t; *&n;&t; * On SMP we always save/restore altivec regs just to avoid the&n;&t; * complexity of changing processors.&n;&t; *  -- Cort&n;&t; */
r_if
c_cond
(paren
(paren
id|prev-&gt;thread.regs
op_logical_and
(paren
id|prev-&gt;thread.regs-&gt;msr
op_amp
id|MSR_VEC
)paren
)paren
op_logical_and
id|prev-&gt;thread.vrsave
)paren
id|giveup_altivec
c_func
(paren
id|prev
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_ALTIVEC */&t;
id|current_set
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
r_new
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/* Avoid the trap.  On smp this this never happens since&n;&t; * we don&squot;t set last_task_used_altivec -- Cort&n;&t; */
r_if
c_cond
(paren
id|last_task_used_altivec
op_eq
r_new
)paren
r_new
op_member_access_from_pointer
id|thread.regs-&gt;msr
op_or_assign
id|MSR_VEC
suffix:semicolon
id|new_thread
op_assign
op_amp
r_new
op_member_access_from_pointer
id|thread
suffix:semicolon
id|old_thread
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
op_star
id|last
op_assign
id|_switch
c_func
(paren
id|old_thread
comma
id|new_thread
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NIP: %08lX XER: %08lX LR: %08lX REGS: %p TRAP: %04lx&bslash;n&quot;
comma
id|regs-&gt;nip
comma
id|regs-&gt;xer
comma
id|regs-&gt;link
comma
id|regs
comma
id|regs-&gt;trap
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSR: %08lx EE: %01x PR: %01x FP: %01x ME: %01x IR/DR: %01x%01x&bslash;n&quot;
comma
id|regs-&gt;msr
comma
id|regs-&gt;msr
op_amp
id|MSR_EE
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_PR
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_FP
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_ME
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_IR
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_DR
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TASK = %p[%d] &squot;%s&squot; &quot;
comma
id|current
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Last syscall: %ld &quot;
comma
id|current-&gt;thread.last_syscall
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nlast math %p last altivec %p&quot;
comma
id|last_task_used_math
comma
id|last_task_used_altivec
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printk
c_func
(paren
l_string|&quot; CPU: %d&quot;
comma
id|current-&gt;processor
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;GPR%02d: &quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|r
comma
op_amp
(paren
id|regs-&gt;gpr
(braket
id|i
)braket
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lX &quot;
comma
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|7
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
)brace
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_altivec
op_eq
id|current
)paren
id|last_task_used_altivec
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_altivec
op_eq
id|current
)paren
id|last_task_used_altivec
op_assign
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|release_thread
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|t
)paren
(brace
)brace
multiline_comment|/*&n; * Copy a thread..&n; */
r_int
DECL|function|copy_thread
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|usp
comma
r_int
r_int
id|unused
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|msr
suffix:semicolon
r_struct
id|pt_regs
op_star
id|childregs
comma
op_star
id|kregs
suffix:semicolon
r_extern
r_void
id|ret_from_fork
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Copy registers */
id|childregs
op_assign
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|p
op_plus
r_sizeof
(paren
r_union
id|task_union
)paren
op_minus
id|STACK_FRAME_OVERHEAD
)paren
)paren
op_minus
l_int|2
suffix:semicolon
op_star
id|childregs
op_assign
op_star
id|regs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|childregs-&gt;msr
op_amp
id|MSR_PR
)paren
op_eq
l_int|0
)paren
id|childregs-&gt;gpr
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
multiline_comment|/* `current&squot; in new task */
id|childregs-&gt;gpr
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Result from fork() */
id|p-&gt;thread.regs
op_assign
id|childregs
suffix:semicolon
id|p-&gt;thread.ksp
op_assign
(paren
r_int
r_int
)paren
id|childregs
op_minus
id|STACK_FRAME_OVERHEAD
suffix:semicolon
id|p-&gt;thread.ksp
op_sub_assign
r_sizeof
(paren
r_struct
id|pt_regs
)paren
op_plus
id|STACK_FRAME_OVERHEAD
suffix:semicolon
id|kregs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|p-&gt;thread.ksp
op_plus
id|STACK_FRAME_OVERHEAD
)paren
suffix:semicolon
id|kregs-&gt;nip
op_assign
(paren
r_int
r_int
)paren
id|ret_from_fork
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;mfmsr %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|msr
)paren
suffix:colon
)paren
suffix:semicolon
id|kregs-&gt;msr
op_assign
id|msr
suffix:semicolon
id|kregs-&gt;gpr
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_int
)paren
id|childregs
op_minus
id|STACK_FRAME_OVERHEAD
suffix:semicolon
id|kregs-&gt;gpr
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_if
c_cond
(paren
id|usp
op_ge
(paren
r_int
r_int
)paren
id|regs
)paren
(brace
multiline_comment|/* Stack is in kernel space - must adjust */
id|childregs-&gt;gpr
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_int
)paren
(paren
id|childregs
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Provided stack is in user space */
id|childregs-&gt;gpr
(braket
l_int|1
)braket
op_assign
id|usp
suffix:semicolon
)brace
id|p-&gt;thread.last_syscall
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * copy fpu info - assume lazy fpu switch now always&n;&t; *  -- Cort&n;&t; */
r_if
c_cond
(paren
id|regs-&gt;msr
op_amp
id|MSR_FP
)paren
id|giveup_fpu
c_func
(paren
id|current
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|p-&gt;thread.fpr
comma
op_amp
id|current-&gt;thread.fpr
comma
r_sizeof
(paren
id|p-&gt;thread.fpr
)paren
)paren
suffix:semicolon
id|p-&gt;thread.fpscr
op_assign
id|current-&gt;thread.fpscr
suffix:semicolon
id|childregs-&gt;msr
op_and_assign
op_complement
id|MSR_FP
suffix:semicolon
macro_line|#ifdef CONFIG_ALTIVEC
multiline_comment|/*&n;&t; * copy altiVec info - assume lazy altiVec switch&n;&t; * - kumar&n;&t; */
r_if
c_cond
(paren
id|regs-&gt;msr
op_amp
id|MSR_VEC
)paren
id|giveup_altivec
c_func
(paren
id|current
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|p-&gt;thread.vr
comma
op_amp
id|current-&gt;thread.vr
comma
r_sizeof
(paren
id|p-&gt;thread.vr
)paren
)paren
suffix:semicolon
id|p-&gt;thread.vscr
op_assign
id|current-&gt;thread.vscr
suffix:semicolon
id|childregs-&gt;msr
op_and_assign
op_complement
id|MSR_VEC
suffix:semicolon
macro_line|#endif /* CONFIG_ALTIVEC */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX ld.so expects the auxiliary table to start on&n; * a 16-byte boundary, so we have to find it and&n; * move it up. :-(&n; */
DECL|function|shove_aux_table
r_static
r_inline
r_void
id|shove_aux_table
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_int
id|argc
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|e
suffix:semicolon
r_int
r_int
id|aux_start
comma
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|argc
comma
(paren
r_int
op_star
)paren
id|sp
)paren
)paren
r_return
suffix:semicolon
id|sp
op_add_assign
r_sizeof
(paren
r_int
)paren
op_plus
(paren
id|argc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* skip over the environment pointers */
r_do
(brace
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|p
comma
(paren
r_char
op_star
op_star
)paren
id|sp
)paren
)paren
r_return
suffix:semicolon
id|sp
op_add_assign
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
op_ne
l_int|NULL
)paren
suffix:semicolon
id|aux_start
op_assign
id|sp
suffix:semicolon
multiline_comment|/* skip to the end of the auxiliary table */
r_do
(brace
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|e
comma
(paren
r_int
r_int
op_star
)paren
id|sp
)paren
)paren
r_return
suffix:semicolon
id|sp
op_add_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|e
op_ne
id|AT_NULL
)paren
suffix:semicolon
id|offset
op_assign
(paren
(paren
id|aux_start
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
)paren
op_minus
id|aux_start
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ne
l_int|0
)paren
(brace
r_do
(brace
id|sp
op_sub_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|e
comma
(paren
r_int
r_int
op_star
)paren
id|sp
)paren
op_logical_or
id|__put_user
c_func
(paren
id|e
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|sp
op_plus
id|offset
)paren
)paren
)paren
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sp
OG
id|aux_start
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Set up a thread for executing a new program&n; */
DECL|function|start_thread
r_void
id|start_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|nip
comma
r_int
r_int
id|sp
)paren
(brace
id|set_fs
c_func
(paren
id|USER_DS
)paren
suffix:semicolon
id|regs-&gt;nip
op_assign
id|nip
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|1
)braket
op_assign
id|sp
suffix:semicolon
id|regs-&gt;msr
op_assign
id|MSR_USER
suffix:semicolon
id|shove_aux_table
c_func
(paren
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
id|last_task_used_math
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_altivec
op_eq
id|current
)paren
id|last_task_used_altivec
op_assign
l_int|0
suffix:semicolon
id|current-&gt;thread.fpscr
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|sys_clone
r_int
id|sys_clone
c_func
(paren
r_int
id|p1
comma
r_int
id|p2
comma
r_int
id|p3
comma
r_int
id|p4
comma
r_int
id|p5
comma
r_int
id|p6
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|clone_flags
op_assign
id|p1
suffix:semicolon
r_int
id|res
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|do_fork
c_func
(paren
id|clone_flags
comma
id|regs-&gt;gpr
(braket
l_int|1
)braket
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* When we clone the idle task we keep the same pid but&n;&t; * the return value of 0 for both causes problems.&n;&t; * -- Cort&n;&t; */
r_if
c_cond
(paren
(paren
id|current-&gt;pid
op_eq
l_int|0
)paren
op_logical_and
(paren
id|current
op_eq
op_amp
id|init_task
)paren
)paren
id|res
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|sys_fork
r_int
id|sys_fork
c_func
(paren
r_int
id|p1
comma
r_int
id|p2
comma
r_int
id|p3
comma
r_int
id|p4
comma
r_int
id|p5
comma
r_int
id|p6
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|res
suffix:semicolon
id|res
op_assign
id|do_fork
c_func
(paren
id|SIGCHLD
comma
id|regs-&gt;gpr
(braket
l_int|1
)braket
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* When we clone the idle task we keep the same pid but&n;&t; * the return value of 0 for both causes problems.&n;&t; * -- Cort&n;&t; */
r_if
c_cond
(paren
(paren
id|current-&gt;pid
op_eq
l_int|0
)paren
op_logical_and
(paren
id|current
op_eq
op_amp
id|init_task
)paren
)paren
id|res
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
r_return
id|res
suffix:semicolon
)brace
DECL|function|sys_vfork
r_int
id|sys_vfork
c_func
(paren
r_int
id|p1
comma
r_int
id|p2
comma
r_int
id|p3
comma
r_int
id|p4
comma
r_int
id|p5
comma
r_int
id|p6
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|CLONE_VFORK
op_or
id|CLONE_VM
op_or
id|SIGCHLD
comma
id|regs-&gt;gpr
(braket
l_int|1
)braket
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|sys_execve
r_int
id|sys_execve
c_func
(paren
r_int
r_int
id|a0
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
(paren
r_char
op_star
)paren
id|a0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;msr
op_amp
id|MSR_FP
)paren
id|giveup_fpu
c_func
(paren
id|current
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ALTIVEC
r_if
c_cond
(paren
id|regs-&gt;msr
op_amp
id|MSR_VEC
)paren
id|giveup_altivec
c_func
(paren
id|current
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_ALTIVEC */ 
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
(paren
r_char
op_star
op_star
)paren
id|a1
comma
(paren
r_char
op_star
op_star
)paren
id|a2
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|current-&gt;ptrace
op_and_assign
op_complement
id|PT_DTRACE
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
r_void
DECL|function|print_backtrace
id|print_backtrace
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Call backtrace: &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sp
)paren
(brace
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|i
comma
op_amp
id|sp
(braket
l_int|1
)braket
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_increment
op_mod
l_int|7
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lX &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|32
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|sp
comma
(paren
r_int
r_int
op_star
op_star
)paren
id|sp
)paren
)paren
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Low level print for debugging - Cort&n; */
r_int
id|__init
id|ll_printk
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|i
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|ll_puts
c_func
(paren
id|buf
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_int
id|lines
op_assign
l_int|24
comma
id|cols
op_assign
l_int|80
suffix:semicolon
r_int
id|orig_x
op_assign
l_int|0
comma
id|orig_y
op_assign
l_int|0
suffix:semicolon
r_void
id|puthex
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
(braket
id|val
op_amp
l_int|0x0F
)braket
suffix:semicolon
id|val
op_rshift_assign
l_int|4
suffix:semicolon
)brace
id|buf
(braket
l_int|8
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|prom_print
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_void
id|__init
id|ll_puts
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|x
comma
id|y
suffix:semicolon
r_char
op_star
id|vidmem
op_assign
(paren
r_char
op_star
)paren
multiline_comment|/*(_ISA_MEM_BASE + 0xB8000) */
l_int|0xD00B8000
suffix:semicolon
r_char
id|c
suffix:semicolon
r_extern
r_int
id|mem_init_done
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
multiline_comment|/* assume this means we can printk */
(brace
id|printk
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 0&t;
r_if
c_cond
(paren
id|have_of
)paren
(brace
id|prom_print
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * can&squot;t ll_puts on chrp without openfirmware yet.&n;&t; * vidmem just needs to be setup for it.&n;&t; * -- Cort&n;&t; */
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_prep
)paren
r_return
suffix:semicolon
id|x
op_assign
id|orig_x
suffix:semicolon
id|y
op_assign
id|orig_y
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|s
op_increment
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
multiline_comment|/*scroll();*/
multiline_comment|/*y--;*/
id|y
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|vidmem
(braket
(paren
id|x
op_plus
id|cols
op_star
id|y
)paren
op_star
l_int|2
)braket
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|x
op_ge
id|cols
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
multiline_comment|/*scroll();*/
multiline_comment|/*y--;*/
id|y
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
id|orig_x
op_assign
id|x
suffix:semicolon
id|orig_y
op_assign
id|y
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * These bracket the sleeping functions..&n; */
r_extern
r_void
id|scheduling_functions_start_here
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|scheduling_functions_end_here
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|first_sched
mdefine_line|#define first_sched    ((unsigned long) scheduling_functions_start_here)
DECL|macro|last_sched
mdefine_line|#define last_sched     ((unsigned long) scheduling_functions_end_here)
DECL|function|get_wchan
r_int
r_int
id|get_wchan
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|ip
comma
id|sp
suffix:semicolon
r_int
r_int
id|stack_page
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
op_logical_or
id|p
op_eq
id|current
op_logical_or
id|p-&gt;state
op_eq
id|TASK_RUNNING
)paren
r_return
l_int|0
suffix:semicolon
id|sp
op_assign
id|p-&gt;thread.ksp
suffix:semicolon
r_do
(brace
id|sp
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|sp
OL
id|stack_page
op_logical_or
id|sp
op_ge
id|stack_page
op_plus
l_int|8188
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|ip
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|sp
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
OL
id|first_sched
op_logical_or
id|ip
op_ge
id|last_sched
)paren
r_return
id|ip
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count
op_increment
OL
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
