multiline_comment|/*&n; *  linux/arch/ppc/kernel/process.c&n; *&n; *  PowerPC version &n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Derived from &quot;arch/i386/kernel/process.c&quot;&n; *    Copyright (C) 1995  Linus Torvalds&n; *&n; *  Modified by Cort Dougan (cort@cs.nmt.edu) and&n; *  Paul Mackerras (paulus@cs.anu.edu.au)&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp_lock.h&gt;
r_int
id|dump_fpu
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|switch_to
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_void
id|print_backtrace
c_func
(paren
r_int
r_int
op_star
)paren
suffix:semicolon
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_void
r_inline
id|zero_paged
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|_get_SP
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|SHOW_TASK_SWITCHES
macro_line|#undef SHOW_TASK_SWITCHES 1
DECL|macro|CHECK_STACK
macro_line|#undef CHECK_STACK 1
DECL|macro|IDLE_ZERO
macro_line|#undef IDLE_ZERO 1
r_int
r_int
DECL|function|kernel_stack_top
id|kernel_stack_top
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|tsk
)paren
op_plus
r_sizeof
(paren
r_union
id|task_union
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|task_top
id|task_top
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|tsk
)paren
op_plus
r_sizeof
(paren
r_struct
id|task_struct
)paren
suffix:semicolon
)brace
DECL|variable|init_mmap
r_static
r_struct
id|vm_area_struct
id|init_mmap
op_assign
id|INIT_MMAP
suffix:semicolon
DECL|variable|init_fs
r_static
r_struct
id|fs_struct
id|init_fs
op_assign
id|INIT_FS
suffix:semicolon
DECL|variable|init_files
r_static
r_struct
id|files_struct
id|init_files
op_assign
id|INIT_FILES
suffix:semicolon
DECL|variable|init_signals
r_static
r_struct
id|signal_struct
id|init_signals
op_assign
id|INIT_SIGNALS
suffix:semicolon
DECL|variable|init_mm
r_struct
id|mm_struct
id|init_mm
op_assign
id|INIT_MM
suffix:semicolon
DECL|variable|init_task_union
r_union
id|task_union
id|init_task_union
op_assign
(brace
id|INIT_TASK
)brace
suffix:semicolon
r_int
DECL|function|dump_fpu
id|dump_fpu
c_func
(paren
r_void
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* check to make sure the kernel stack is healthy */
DECL|function|check_stack
r_int
id|check_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
r_int
id|stack_top
op_assign
id|kernel_stack_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_int
r_int
id|tsk_top
op_assign
id|task_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
op_star
id|i
suffix:semicolon
macro_line|#if 0&t;
multiline_comment|/* check tss magic */
r_if
c_cond
(paren
id|tsk-&gt;tss.magic
op_ne
id|TSS_MAGIC
)paren
(brace
id|ret
op_or_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;tss.magic bad: %08x&bslash;n&quot;
comma
id|tsk-&gt;tss.magic
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|tsk
)paren
id|printk
c_func
(paren
l_string|&quot;check_stack(): tsk bad tsk %p&bslash;n&quot;
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* check if stored ksp is bad */
r_if
c_cond
(paren
(paren
id|tsk-&gt;tss.ksp
OG
id|stack_top
)paren
op_logical_or
(paren
id|tsk-&gt;tss.ksp
OL
id|tsk_top
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;stack out of bounds: %s/%d&bslash;n&quot;
l_string|&quot; tsk_top %08x ksp %08x stack_top %08x&bslash;n&quot;
comma
id|tsk-&gt;comm
comma
id|tsk-&gt;pid
comma
id|tsk_top
comma
id|tsk-&gt;tss.ksp
comma
id|stack_top
)paren
suffix:semicolon
id|ret
op_or_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* check if stack ptr RIGHT NOW is bad */
r_if
c_cond
(paren
(paren
id|tsk
op_eq
id|current
)paren
op_logical_and
(paren
(paren
id|_get_SP
c_func
(paren
)paren
OG
id|stack_top
)paren
op_logical_or
(paren
id|_get_SP
c_func
(paren
)paren
OL
id|tsk_top
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;current stack ptr out of bounds: %s/%d&bslash;n&quot;
l_string|&quot; tsk_top %08x sp %08x stack_top %08x&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|tsk_top
comma
id|_get_SP
c_func
(paren
)paren
comma
id|stack_top
)paren
suffix:semicolon
id|ret
op_or_assign
l_int|4
suffix:semicolon
)brace
macro_line|#if 0&t;
multiline_comment|/* check amount of free stack */
r_for
c_loop
(paren
id|i
op_assign
(paren
r_int
r_int
op_star
)paren
id|task_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|i
OL
id|kernel_stack_top
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;check_stack(): i = %p&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|i
op_ne
l_int|0
)paren
(brace
multiline_comment|/* only notify if it&squot;s less than 900 bytes */
r_if
c_cond
(paren
(paren
id|i
op_minus
(paren
r_int
r_int
op_star
)paren
id|task_top
c_func
(paren
id|tsk
)paren
)paren
OL
l_int|900
)paren
id|printk
c_func
(paren
l_string|&quot;%d bytes free on stack&bslash;n&quot;
comma
id|i
op_minus
id|task_top
c_func
(paren
id|tsk
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ret
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;bad kernel stack&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|switch_to
id|switch_to
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
comma
r_struct
id|task_struct
op_star
r_new
)paren
(brace
r_struct
id|thread_struct
op_star
id|new_tss
comma
op_star
id|old_tss
suffix:semicolon
r_int
id|s
op_assign
id|_disable_interrupts
c_func
(paren
)paren
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
r_new
op_member_access_from_pointer
id|tss.ksp
op_plus
id|STACK_FRAME_OVERHEAD
)paren
suffix:semicolon
macro_line|#if CHECK_STACK
id|check_stack
c_func
(paren
id|prev
)paren
suffix:semicolon
id|check_stack
c_func
(paren
r_new
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* turn off fpu for task last to run */
multiline_comment|/*prev-&gt;tss.regs-&gt;msr &amp;= ~MSR_FP;*/
macro_line|#ifdef SHOW_TASK_SWITCHES
id|printk
c_func
(paren
l_string|&quot;%s/%d (%x) -&gt; %s/%d (%x) ctx %x&bslash;n&quot;
comma
id|prev-&gt;comm
comma
id|prev-&gt;pid
comma
id|prev-&gt;tss.regs-&gt;nip
comma
r_new
op_member_access_from_pointer
id|comm
comma
r_new
op_member_access_from_pointer
id|pid
comma
r_new
op_member_access_from_pointer
id|tss.regs-&gt;nip
comma
r_new
op_member_access_from_pointer
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|new_tss
op_assign
op_amp
r_new
op_member_access_from_pointer
id|tss
suffix:semicolon
id|old_tss
op_assign
op_amp
id|current-&gt;tss
suffix:semicolon
id|_switch
c_func
(paren
id|old_tss
comma
id|new_tss
comma
r_new
op_member_access_from_pointer
id|mm-&gt;context
)paren
suffix:semicolon
multiline_comment|/* turn off fpu for task last to run */
id|_enable_interrupts
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
macro_line|#include &lt;linux/mc146818rtc.h&gt;
DECL|function|sys_debug
id|asmlinkage
r_int
id|sys_debug
c_func
(paren
r_int
id|a
comma
r_int
id|b
comma
r_int
id|c
comma
r_int
id|d
comma
r_int
id|e
comma
r_int
id|f
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#if 1
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sys_debug(): r3 %x r4 %x r5 %x r6 %x&bslash;n&quot;
comma
id|a
comma
id|b
comma
id|c
comma
id|d
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last %x&bslash;n&quot;
comma
id|last_task_used_math
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cur %x regs %x/%x tss %x/%x&bslash;n&quot;
comma
id|current
comma
id|current-&gt;tss.regs
comma
id|regs
comma
op_amp
id|current-&gt;tss
comma
id|current-&gt;tss
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|p
OL
id|KERNELBASE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nip %x lr %x r3 %x&bslash;n&quot;
comma
id|regs-&gt;nip
comma
id|regs-&gt;link
comma
id|a
)paren
suffix:semicolon
id|print_mm_info
c_func
(paren
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
)brace
r_return
id|regs-&gt;gpr
(braket
l_int|3
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if 0
multiline_comment|/* set the time in the cmos clock */
r_int
r_int
id|hwtime
comma
id|nowtime
suffix:semicolon
r_struct
id|rtc_time
id|tm
suffix:semicolon
id|hwtime
op_assign
id|get_cmos_time
c_func
(paren
)paren
suffix:semicolon
id|to_tm
c_func
(paren
id|hwtime
comma
op_amp
id|tm
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hw: H:M:S M/D/Y %02d:%02d:%02d %d/%d/%d&bslash;n&quot;
comma
id|tm.tm_hour
comma
id|tm.tm_min
comma
id|tm.tm_sec
comma
id|tm.tm_mon
comma
id|tm.tm_mday
comma
id|tm.tm_year
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * vars for idle task zero&squot;ing out pages&n; */
DECL|variable|zero_list
r_int
r_int
id|zero_list
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* head linked list of pre-zero&squot;d pages */
DECL|variable|bytecount
r_int
r_int
id|bytecount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pointer into the currently being zero&squot;d page */
DECL|variable|zerocount
r_int
r_int
id|zerocount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # currently pre-zero&squot;d pages */
DECL|variable|zerototal
r_int
r_int
id|zerototal
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # pages zero&squot;d over time -- for ooh&squot;s and ahhh&squot;s */
DECL|variable|pageptr
r_int
r_int
id|pageptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* current page being zero&squot;d */
DECL|variable|zeropage_hits
r_int
r_int
id|zeropage_hits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # zero&squot;d pages request that we&squot;ve done */
multiline_comment|/*&n; * Returns a pre-zero&squot;d page from the list otherwise returns&n; * NULL.&n; */
DECL|function|get_prezerod_page
r_int
r_int
id|get_prezerod_page
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|zero_list
)paren
(brace
multiline_comment|/* atomically remove this page from the list */
id|asm
(paren
l_string|&quot;101:lwarx  %1,0,%2&bslash;n&quot;
multiline_comment|/* reserve zero_list */
l_string|&quot;    lwz    %0,0(%1)&bslash;n&quot;
multiline_comment|/* get next -- new zero_list */
l_string|&quot;    stwcx. %0,0,%2&bslash;n&quot;
multiline_comment|/* update zero_list */
l_string|&quot;    bne-   101b&bslash;n&quot;
multiline_comment|/* if lost reservation try again */
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|zero_list
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|page
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|zero_list
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
multiline_comment|/* we can update zerocount after the fact since it is not&n;&t;&t; * used for anything but control of a loop which doesn&squot;t&n;&t;&t; * matter since it won&squot;t effect anything if it zero&squot;s one&n;&t;&t; * less page -- Cort&n;&t;&t; */
id|atomic_inc
c_func
(paren
(paren
id|atomic_t
op_star
)paren
op_amp
id|zeropage_hits
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
(paren
id|atomic_t
op_star
)paren
op_amp
id|zerocount
)paren
suffix:semicolon
multiline_comment|/* zero out the pointer to next in the page */
op_star
(paren
r_int
r_int
op_star
)paren
id|page
op_assign
l_int|0
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Experimental stuff to zero out pages in the idle task&n; * to speed up get_free_pages() -- Cort&n; * Zero&squot;s out pages until we need to resched or&n; * we&squot;ve reached the limit of zero&squot;d pages.&n; */
DECL|function|zero_paged
r_void
r_inline
id|zero_paged
c_func
(paren
r_void
)paren
(brace
r_extern
id|pte_t
op_star
id|get_pte
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
)paren
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|pte_t
id|ptep
suffix:semicolon
id|pgd_t
op_star
id|dir
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;zero_paged&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Started zero_paged&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* want priority over idle task and powerd */
id|current-&gt;priority
op_assign
op_minus
l_int|98
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|98
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|zerocount
OL
l_int|128
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mark a page as reserved so we can mess with it&n;&t;&t; * If we&squot;re interrupted we keep this page and our place in it&n;&t;&t; * since we validly hold it and it&squot;s reserved for us.&n;&t;&t; */
id|pageptr
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pageptr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;!pageptr in zero_paged&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make the page no cache so we don&squot;t blow our cache with 0&squot;s&n;&t;&t; */
id|dir
op_assign
id|pgd_offset
c_func
(paren
id|init_task.mm
comma
id|pageptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|pageptr
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd
op_logical_and
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|pageptr
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte
op_logical_and
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
(brace
id|pte_uncache
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|find_vma
c_func
(paren
id|init_task.mm
comma
id|pageptr
)paren
comma
id|pageptr
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Important here to not take time away from real processes.&n;&t;&t; */
r_for
c_loop
(paren
id|bytecount
op_assign
l_int|0
suffix:semicolon
id|bytecount
OL
id|PAGE_SIZE
suffix:semicolon
id|bytecount
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|bytecount
op_plus
id|pageptr
)paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we finished zero-ing out a page add this page to&n;&t;&t; * the zero_list atomically -- we can&squot;t use&n;&t;&t; * down/up since we can&squot;t sleep in idle.&n;&t;&t; * Disabling interrupts is also a bad idea since we would&n;&t;&t; * steal time away from real processes.&n;&t;&t; * We can also have several zero_paged&squot;s running&n;&t;&t; * on different processors so we can&squot;t interfere with them.&n;&t;&t; * So we update the list atomically without locking it.&n;&t;&t; * -- Cort&n;&t;&t; */
multiline_comment|/* turn cache on for this page */
id|pte_cache
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|find_vma
c_func
(paren
id|init_task.mm
comma
id|pageptr
)paren
comma
id|pageptr
)paren
suffix:semicolon
multiline_comment|/* atomically add this page to the list */
id|asm
(paren
l_string|&quot;101:lwarx  %0,0,%1&bslash;n&quot;
multiline_comment|/* reserve zero_list */
l_string|&quot;    stw    %0,0(%2)&bslash;n&quot;
multiline_comment|/* update *pageptr */
macro_line|#ifdef __SMP__
l_string|&quot;    sync&bslash;n&quot;
multiline_comment|/* let store settle */
macro_line|#endif&t;&t;&t;
l_string|&quot;    mr     %0,%2&bslash;n&quot;
multiline_comment|/* update zero_list in reg */
l_string|&quot;    stwcx. %2,0,%1&bslash;n&quot;
multiline_comment|/* update zero_list in mem */
l_string|&quot;    bne-   101b&bslash;n&quot;
multiline_comment|/* if lost reservation try again */
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|zero_list
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|zero_list
)paren
comma
l_string|&quot;r&quot;
(paren
id|pageptr
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This variable is used in the above loop and nowhere&n;&t;&t; * else so the worst that could happen is we would&n;&t;&t; * zero out one more or one less page than we want&n;&t;&t; * per processor on the machine.  This is because&n;&t;&t; * we could add our page to the list but not have&n;&t;&t; * zerocount updated yet when another processor&n;&t;&t; * reads it.  -- Cort&n;&t;&t; */
id|atomic_inc
c_func
(paren
(paren
id|atomic_t
op_star
)paren
op_amp
id|zerocount
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
(paren
id|atomic_t
op_star
)paren
op_amp
id|zerototal
)paren
suffix:semicolon
id|retry
suffix:colon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|powerd
r_void
id|powerd
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|msr
comma
id|hid0
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;powerd&quot;
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* want priority over idle task &squot;swapper&squot; -- Cort */
id|current-&gt;priority
op_assign
op_minus
l_int|99
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|99
suffix:semicolon
id|asm
r_volatile
(paren
multiline_comment|/* clear powersaving modes and set nap mode */
l_string|&quot;mfspr %3,1008 &bslash;n&bslash;t&quot;
l_string|&quot;andc  %3,%3,%4 &bslash;n&bslash;t&quot;
l_string|&quot;or    %3,%3,%5 &bslash;n&bslash;t&quot;
l_string|&quot;mtspr 1008,%3 &bslash;n&bslash;t&quot;
multiline_comment|/* enter the mode */
l_string|&quot;mfmsr %0 &bslash;n&bslash;t&quot;
l_string|&quot;oris  %0,%0,%2 &bslash;n&bslash;t&quot;
l_string|&quot;sync &bslash;n&bslash;t&quot;
l_string|&quot;mtmsr %0 &bslash;n&bslash;t&quot;
l_string|&quot;isync &bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|msr
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|msr
)paren
comma
l_string|&quot;i&quot;
(paren
id|MSR_POW
op_rshift
l_int|16
)paren
comma
l_string|&quot;r&quot;
(paren
id|hid0
)paren
comma
l_string|&quot;r&quot;
(paren
id|HID0_DOZE
op_or
id|HID0_NAP
op_or
id|HID0_SLEEP
)paren
comma
l_string|&quot;r&quot;
(paren
id|HID0_NAP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The ibm carolina spec says that the eagle memory&n;&t;&t; * controller will detect the need for a snoop&n;&t;&t; * and wake up the processor so we don&squot;t need to&n;&t;&t; * check for cache operations that need to be&n;&t;&t; * snooped.  The ppc book says the run signal&n;&t;&t; * must be asserted while napping for this though.&n;&t;&t; * -- Cort&n;&t;&t; */
)brace
)brace
DECL|function|sys_idle
id|asmlinkage
r_int
id|sys_idle
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;pid
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef IDLE_ZERO
multiline_comment|/*&n;&t; * want one per cpu since it would be nice to have all&n;&t; * processors who aren&squot;t doing anything&n;&t; * zero-ing pages since this daemon is lock-free&n;&t; * -- Cort&n;&t; */
id|kernel_thread
c_func
(paren
id|zero_paged
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* IDLE_ZERO */
macro_line|#ifdef CONFIG_POWERSAVING
multiline_comment|/* no powersaving modes on 601 - one per processor */
r_if
c_cond
(paren
(paren
id|_get_PVR
c_func
(paren
)paren
op_rshift
l_int|16
)paren
op_ne
l_int|1
)paren
(brace
id|kernel_thread
c_func
(paren
id|powerd
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_POWERSAVING */
multiline_comment|/* endless loop with no priority at all */
id|current-&gt;priority
op_assign
op_minus
l_int|100
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NIP: %08X XER: %08X LR: %08X REGS: %08X TRAP: %04x&bslash;n&quot;
comma
id|regs-&gt;nip
comma
id|regs-&gt;xer
comma
id|regs-&gt;link
comma
id|regs
comma
id|regs-&gt;trap
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MSR: %08x EE: %01x PR: %01x FP: %01x ME: %01x IR/DR: %01x%01x&bslash;n&quot;
comma
id|regs-&gt;msr
comma
id|regs-&gt;msr
op_amp
id|MSR_EE
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_PR
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_FP
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_ME
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_IR
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|regs-&gt;msr
op_amp
id|MSR_DR
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TASK = %x[%d] &squot;%s&squot; mm-&gt;pgd %08X &quot;
comma
id|current
comma
id|current-&gt;pid
comma
id|current-&gt;comm
comma
id|current-&gt;mm-&gt;pgd
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Last syscall: %d &quot;
comma
id|current-&gt;tss.last_syscall
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nlast math %08X&bslash;n&quot;
comma
id|last_task_used_math
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;GPR%02d: &quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|r
comma
op_amp
(paren
id|regs-&gt;gpr
(braket
id|i
)braket
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08X &quot;
comma
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|7
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
)brace
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|release_thread
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|t
)paren
(brace
)brace
multiline_comment|/*&n;  * Copy a thread..&n;  */
r_int
DECL|function|copy_thread
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|usp
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|pt_regs
op_star
id|childregs
suffix:semicolon
multiline_comment|/* Copy registers */
id|childregs
op_assign
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|p
op_plus
r_sizeof
(paren
r_union
id|task_union
)paren
op_minus
id|STACK_FRAME_OVERHEAD
)paren
)paren
op_minus
l_int|2
suffix:semicolon
op_star
id|childregs
op_assign
op_star
id|regs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|childregs-&gt;msr
op_amp
id|MSR_PR
)paren
op_eq
l_int|0
)paren
id|childregs-&gt;gpr
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
multiline_comment|/* `current&squot; in new task */
id|childregs-&gt;gpr
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Result from fork() */
id|p-&gt;tss.ksp
op_assign
(paren
r_int
r_int
)paren
(paren
id|childregs
)paren
op_minus
id|STACK_FRAME_OVERHEAD
suffix:semicolon
id|p-&gt;tss.regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|childregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usp
op_ge
(paren
r_int
r_int
)paren
id|regs
)paren
(brace
multiline_comment|/* Stack is in kernel space - must adjust */
id|childregs-&gt;gpr
(braket
l_int|1
)braket
op_assign
(paren
r_int
)paren
(paren
id|childregs
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Provided stack is in user space */
id|childregs-&gt;gpr
(braket
l_int|1
)braket
op_assign
id|usp
suffix:semicolon
)brace
id|p-&gt;tss.last_syscall
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * copy fpu info - assume lazy fpu switch now always&n;&t; * this should really be conditional on whether or&n;&t; * not the process has used the fpu&n;&t; *  -- Cort&n;&t; */
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
id|giveup_fpu
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|p-&gt;tss.fpr
comma
op_amp
id|current-&gt;tss.fpr
comma
r_sizeof
(paren
id|p-&gt;tss.fpr
)paren
)paren
suffix:semicolon
id|p-&gt;tss.fpscr
op_assign
id|current-&gt;tss.fpscr
suffix:semicolon
id|childregs-&gt;msr
op_and_assign
op_complement
id|MSR_FP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_fork
id|asmlinkage
r_int
id|sys_fork
c_func
(paren
r_int
id|p1
comma
r_int
id|p2
comma
r_int
id|p3
comma
r_int
id|p4
comma
r_int
id|p5
comma
r_int
id|p6
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ret
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|do_fork
c_func
(paren
id|SIGCHLD
comma
id|regs-&gt;gpr
(braket
l_int|1
)braket
comma
id|regs
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_execve
id|asmlinkage
r_int
id|sys_execve
c_func
(paren
r_int
r_int
id|a0
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|filename
op_assign
(paren
r_int
)paren
id|getname
c_func
(paren
(paren
r_char
op_star
)paren
id|a0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
(paren
r_char
op_star
op_star
)paren
id|a1
comma
(paren
r_char
op_star
op_star
)paren
id|a2
comma
id|regs
)paren
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_clone
id|asmlinkage
r_int
id|sys_clone
c_func
(paren
r_int
id|p1
comma
r_int
id|p2
comma
r_int
id|p3
comma
r_int
id|p4
comma
r_int
id|p5
comma
r_int
id|p6
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|clone_flags
op_assign
id|p1
suffix:semicolon
r_int
id|res
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|do_fork
c_func
(paren
id|clone_flags
comma
id|regs-&gt;gpr
(braket
l_int|1
)braket
comma
id|regs
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_void
DECL|function|print_backtrace
id|print_backtrace
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Call backtrace: &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|get_user
c_func
(paren
id|i
comma
id|sp
)paren
op_logical_and
id|i
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|i
comma
op_amp
id|sp
(braket
l_int|1
)braket
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08X &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
(paren
id|ulong
)paren
id|sp
comma
id|sp
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|6
)paren
id|cnt
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* wraparound early -- Cort */
r_if
c_cond
(paren
op_increment
id|cnt
op_eq
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
OG
l_int|32
)paren
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|start_thread
r_inline
r_void
id|start_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|eip
comma
r_int
r_int
id|esp
)paren
(brace
id|set_fs
c_func
(paren
id|USER_DS
)paren
suffix:semicolon
id|regs-&gt;nip
op_assign
id|eip
suffix:semicolon
id|regs-&gt;gpr
(braket
l_int|1
)braket
op_assign
id|esp
suffix:semicolon
id|regs-&gt;msr
op_assign
id|MSR_USER
suffix:semicolon
)brace
multiline_comment|/*&n; * Low level print for debugging - Cort&n; */
DECL|function|ll_printk
r_int
id|ll_printk
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|i
op_assign
id|sprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|ll_puts
c_func
(paren
id|buf
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|variable|vidmem
r_char
op_star
id|vidmem
op_assign
(paren
r_char
op_star
)paren
l_int|0xC00B8000
suffix:semicolon
DECL|variable|lines
DECL|variable|cols
r_int
id|lines
op_assign
l_int|24
comma
id|cols
op_assign
l_int|80
suffix:semicolon
DECL|variable|orig_x
DECL|variable|orig_y
r_int
id|orig_x
op_assign
l_int|0
comma
id|orig_y
op_assign
l_int|0
suffix:semicolon
DECL|function|ll_puts
r_void
id|ll_puts
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|x
comma
id|y
suffix:semicolon
r_char
id|c
suffix:semicolon
id|x
op_assign
id|orig_x
suffix:semicolon
id|y
op_assign
id|orig_y
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|s
op_increment
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
multiline_comment|/*scroll();*/
multiline_comment|/*y--;*/
id|y
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|vidmem
(braket
(paren
id|x
op_plus
id|cols
op_star
id|y
)paren
op_star
l_int|2
)braket
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|x
op_ge
id|cols
)paren
(brace
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|y
op_ge
id|lines
)paren
(brace
multiline_comment|/*scroll();*/
multiline_comment|/*y--;*/
id|y
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
id|orig_x
op_assign
id|x
suffix:semicolon
id|orig_y
op_assign
id|y
suffix:semicolon
)brace
eof
