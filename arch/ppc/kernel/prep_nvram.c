multiline_comment|/*&n; *  linux/arch/ppc/kernel/prep_nvram.c&n; *&n; *  Copyright (C) 1998  Corey Minyard&n; *&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/init.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/prep_nvram.h&gt;
multiline_comment|/*&n; * Allow for a maximum of 32K of PReP NvRAM data&n; */
DECL|macro|MAX_PREP_NVRAM
mdefine_line|#define MAX_PREP_NVRAM 0x8000
DECL|variable|nvramData
r_static
r_char
id|nvramData
(braket
id|MAX_PREP_NVRAM
)braket
suffix:semicolon
DECL|variable|nvram
r_static
id|NVRAM_MAP
op_star
id|nvram
op_assign
(paren
id|NVRAM_MAP
op_star
)paren
op_amp
id|nvramData
(braket
l_int|0
)braket
suffix:semicolon
DECL|macro|PREP_NVRAM_AS0
mdefine_line|#define PREP_NVRAM_AS0&t;0x74
DECL|macro|PREP_NVRAM_AS1
mdefine_line|#define PREP_NVRAM_AS1&t;0x75
DECL|macro|PREP_NVRAM_DATA
mdefine_line|#define PREP_NVRAM_DATA&t;0x77
DECL|variable|rs_pcNvRAM
r_int
r_char
op_star
id|rs_pcNvRAM
suffix:semicolon
DECL|function|prep_nvram_read_val
r_int
r_char
id|__prep
id|prep_nvram_read_val
c_func
(paren
r_int
id|addr
)paren
(brace
id|outb
c_func
(paren
id|addr
comma
id|PREP_NVRAM_AS0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|8
comma
id|PREP_NVRAM_AS1
)paren
suffix:semicolon
r_return
id|inb
c_func
(paren
id|PREP_NVRAM_DATA
)paren
suffix:semicolon
)brace
DECL|function|prep_nvram_write_val
r_void
id|__prep
id|prep_nvram_write_val
c_func
(paren
r_int
id|addr
comma
r_int
r_char
id|val
)paren
(brace
id|outb
c_func
(paren
id|addr
comma
id|PREP_NVRAM_AS0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
l_int|8
comma
id|PREP_NVRAM_AS1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|val
comma
id|PREP_NVRAM_DATA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Most Radstone boards have NvRAM memory mapped at offset 8M in ISA space&n; */
DECL|function|rs_nvram_read_val
r_int
r_char
id|__prep
id|rs_nvram_read_val
c_func
(paren
r_int
id|addr
)paren
(brace
r_return
id|rs_pcNvRAM
(braket
id|addr
)braket
suffix:semicolon
)brace
DECL|function|rs_nvram_write_val
r_void
id|__prep
id|rs_nvram_write_val
c_func
(paren
r_int
id|addr
comma
r_int
r_char
id|val
)paren
(brace
id|rs_pcNvRAM
(braket
id|addr
)braket
op_assign
id|val
suffix:semicolon
)brace
DECL|function|init_prep_nvram
r_void
id|__init
id|init_prep_nvram
c_func
(paren
r_void
)paren
(brace
r_int
r_char
op_star
id|nvp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nvramSize
suffix:semicolon
multiline_comment|/*&n;&t; * I&squot;m making the assumption that 32k will always cover the&n;&t; * nvramsize.  If this isn&squot;t the case please let me know and we can&n;&t; * map the header, then get the size from the header, then map&n;&t; * the whole size. -- Cort&n;&t; */
r_if
c_cond
(paren
id|_prep_type
op_eq
id|_PREP_Radstone
)paren
id|rs_pcNvRAM
op_assign
(paren
r_int
r_char
op_star
)paren
id|ioremap
c_func
(paren
id|_ISA_MEM_BASE
op_plus
l_int|0x00800000
comma
l_int|32
op_lshift
l_int|10
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|PREP_NVRAM_AS0
comma
l_int|0x8
comma
l_string|&quot;PReP NVRAM&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The following could fail if the NvRAM were corrupt but&n;&t; * we expect the boot firmware to have checked its checksum&n;&t; * before boot&n;&t; */
id|nvp
op_assign
(paren
r_char
op_star
)paren
op_amp
id|nvram-&gt;Header
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|HEADER
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|nvp
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|i
)paren
suffix:semicolon
id|nvp
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The PReP NvRAM may be any size so read in the header to&n;&t; * determine how much we must read in order to get the complete&n;&t; * GE area&n;&t; */
id|nvramSize
op_assign
(paren
r_int
)paren
id|nvram-&gt;Header.GEAddress
op_plus
id|nvram-&gt;Header.GELength
suffix:semicolon
r_if
c_cond
(paren
id|nvramSize
OG
id|MAX_PREP_NVRAM
)paren
(brace
multiline_comment|/*&n;&t;&t; * NvRAM is too large&n;&t;&t; */
id|nvram-&gt;Header.GELength
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the remainder of the PReP NvRAM&n;&t; */
id|nvp
op_assign
(paren
r_char
op_star
)paren
op_amp
id|nvram-&gt;GEArea
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
r_sizeof
(paren
id|HEADER
)paren
suffix:semicolon
id|i
OL
id|nvramSize
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|nvp
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|i
)paren
suffix:semicolon
id|nvp
op_increment
suffix:semicolon
)brace
)brace
id|__prep
DECL|function|prep_nvram_get_var
r_char
id|__prep
op_star
id|prep_nvram_get_var
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|cp
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|cp
op_assign
id|prep_nvram_first_var
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|strncmp
c_func
(paren
id|name
comma
id|cp
comma
id|namelen
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|cp
(braket
id|namelen
)braket
op_eq
l_char|&squot;=&squot;
)paren
)paren
(brace
r_return
id|cp
op_plus
id|namelen
op_plus
l_int|1
suffix:semicolon
)brace
id|cp
op_assign
id|prep_nvram_next_var
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|__prep
DECL|function|prep_nvram_first_var
r_char
id|__prep
op_star
id|prep_nvram_first_var
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|nvram-&gt;Header.GELength
op_eq
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
(paren
(paren
r_char
op_star
)paren
id|nvram
)paren
op_plus
(paren
(paren
r_int
r_int
)paren
id|nvram-&gt;Header.GEAddress
)paren
)paren
suffix:semicolon
)brace
)brace
id|__prep
DECL|function|prep_nvram_next_var
r_char
id|__prep
op_star
id|prep_nvram_next_var
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|cp
suffix:semicolon
id|cp
op_assign
id|name
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|cp
op_minus
(paren
(paren
r_char
op_star
)paren
id|nvram-&gt;GEArea
)paren
)paren
OL
id|nvram-&gt;Header.GELength
)paren
op_logical_and
(paren
op_star
id|cp
op_ne
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
id|cp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Skip over any null characters. */
r_while
c_loop
(paren
(paren
(paren
id|cp
op_minus
(paren
(paren
r_char
op_star
)paren
id|nvram-&gt;GEArea
)paren
)paren
OL
id|nvram-&gt;Header.GELength
)paren
op_logical_and
(paren
op_star
id|cp
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
id|cp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cp
op_minus
(paren
(paren
r_char
op_star
)paren
id|nvram-&gt;GEArea
)paren
)paren
OL
id|nvram-&gt;Header.GELength
)paren
(brace
r_return
id|cp
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
eof
