DECL|macro|_FP_DECL
mdefine_line|#define _FP_DECL(wc, X)&t;&t;&t;&bslash;&n;  _FP_I_TYPE X##_c, X##_s, X##_e;&t;&bslash;&n;  _FP_FRAC_DECL_##wc(X)
multiline_comment|/*&n; * Finish truely unpacking a native fp value by classifying the kind&n; * of fp value and normalizing both the exponent and the fraction.&n; */
DECL|macro|_FP_UNPACK_CANONICAL
mdefine_line|#define _FP_UNPACK_CANONICAL(fs, wc, X)&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  switch (X##_e)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  default:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_HIGH_##wc(X) |= _FP_IMPLBIT_##fs;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SLL_##wc(X, _FP_WORKBITS);&t;&t;&t;&t;&t;&bslash;&n;    X##_e -= _FP_EXPBIAS_##fs;&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case 0:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (_FP_FRAC_ZEROP_##wc(X))&t;&t;&t;&t;&t;&t;&bslash;&n;      X##_c = FP_CLS_ZERO;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* a denormalized number */&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_I_TYPE _shift;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_CLZ_##wc(_shift, X);&t;&t;&t;&t;&t;&bslash;&n;&t;_shift -= _FP_FRACXBITS_##fs;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_SLL_##wc(X, (_shift+_FP_WORKBITS));&t;&t;&t;&bslash;&n;&t;X##_e -= _FP_EXPBIAS_##fs - 1 + _shift;&t;&t;&t;&t;&bslash;&n;&t;X##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_EXPMAX_##fs:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (_FP_FRAC_ZEROP_##wc(X))&t;&t;&t;&t;&t;&t;&bslash;&n;      X##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      /* we don&squot;t differentiate between signaling and quiet nans */&t;&bslash;&n;      X##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * Before packing the bits back into the native fp result, take care&n; * of such mundane things as rounding and overflow.  Also, for some&n; * kinds of fp values, the original parts may not have been fully&n; * extracted -- but that is ok, we can regenerate them now.&n; */
DECL|macro|_FP_PACK_CANONICAL
mdefine_line|#define _FP_PACK_CANONICAL(fs, wc, X)&t;&t;&t;&t;&bslash;&n;({int __ret = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;  switch (X##_c)&t;&t;&t;&t;&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_NORMAL:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e += _FP_EXPBIAS_##fs;&t;&t;&t;&t;&t;&bslash;&n;    if (X##_e &gt; 0)&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__ret |= _FP_ROUND(wc, X);&t;&t;&t;&t;&bslash;&n;&t;if (_FP_FRAC_OVERP_##wc(fs, X))&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SRL_##wc(X, (_FP_WORKBITS+1));&t;&t;&bslash;&n;&t;    X##_e++;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);&t;&t;&t;&bslash;&n;&t;if (X##_e &gt;= _FP_EXPMAX_##fs)&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    /* overflow to infinity */&t;&t;&t;&t;&bslash;&n;&t;    X##_e = _FP_EXPMAX_##fs;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&bslash;&n;            __ret |= EFLAG_OVERFLOW;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* we&squot;ve got a denormalized number */&t;&t;&t;&bslash;&n;&t;X##_e = -X##_e + 1;&t;&t;&t;&t;&t;&bslash;&n;&t;if (X##_e &lt;= _FP_WFRACBITS_##fs)&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SRS_##wc(X, X##_e, _FP_WFRACBITS_##fs);&t;&bslash;&n;&t;    __ret |= _FP_ROUND(wc, X);&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SLL_##wc(X, 1);&t;&t;&t;&t;&bslash;&n;&t;    if (_FP_FRAC_OVERP_##wc(fs, X))&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;        X##_e = 1;&t;&t;&t;&t;&t;&bslash;&n;&t;        _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;X##_e = 0;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;_FP_FRAC_SRL_##wc(X, _FP_WORKBITS+1);&t;&t;&bslash;&n;                __ret |= EFLAG_UNDERFLOW;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    /* underflow to zero */&t;&t;&t;&t;&bslash;&n;&t;    X##_e = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&bslash;&n;            __ret |= EFLAG_UNDERFLOW;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_ZERO:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_INF:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e = _FP_EXPMAX_##fs;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_NAN:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e = _FP_EXPMAX_##fs;&t;&t;&t;&t;&t;&bslash;&n;    if (!_FP_KEEPNANFRACP)&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);&t;&t;&t;&bslash;&n;&t;X##_s = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      _FP_FRAC_HIGH_##wc(X) |= _FP_QNANBIT_##fs;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  __ret;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
multiline_comment|/*&n; * Main addition routine.  The input values should be cooked.&n; */
DECL|macro|_FP_ADD
mdefine_line|#define _FP_ADD(fs, wc, R, X, Y)&t;&t;&t;&t;&t;     &bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  switch (_FP_CLS_COMBINE(X##_c, Y##_c))&t;&t;&t;&t;     &bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      /* shift the smaller number so that its exponent matches the larger */ &bslash;&n;      _FP_I_TYPE diff = X##_e - Y##_e;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      if (diff &lt; 0)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  diff = -diff;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (diff &lt;= _FP_WFRACBITS_##fs)&t;&t;&t;&t;     &bslash;&n;&t;    _FP_FRAC_SRS_##wc(X, diff, _FP_WFRACBITS_##fs);&t;&t;     &bslash;&n;&t;  else if (!_FP_FRAC_ZEROP_##wc(X))&t;&t;&t;&t;     &bslash;&n;&t;    _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);&t;&t;&t;     &bslash;&n;&t;  else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&t;     &bslash;&n;&t;  R##_e = Y##_e;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (diff &gt; 0)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      if (diff &lt;= _FP_WFRACBITS_##fs)&t;&t;&t;&t;     &bslash;&n;&t;        _FP_FRAC_SRS_##wc(Y, diff, _FP_WFRACBITS_##fs);&t;&t;     &bslash;&n;&t;      else if (!_FP_FRAC_ZEROP_##wc(Y))&t;&t;&t;&t;     &bslash;&n;&t;        _FP_FRAC_SET_##wc(Y, _FP_MINFRAC_##wc);&t;&t;&t;     &bslash;&n;&t;      else&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;        _FP_FRAC_SET_##wc(Y, _FP_ZEROFRAC_##wc);&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  R##_e = X##_e;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      if (X##_s == Y##_s)&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  R##_s = X##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  _FP_FRAC_ADD_##wc(R, X, Y);&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (_FP_FRAC_OVERP_##wc(fs, R))&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);&t;&t;     &bslash;&n;&t;      R##_e++;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  R##_s = X##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  _FP_FRAC_SUB_##wc(R, X, Y);&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (_FP_FRAC_ZEROP_##wc(R))&t;&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      /* return an exact zero */&t;&t;&t;&t;     &bslash;&n;&t;      if (FP_ROUNDMODE == FP_RND_MINF)&t;&t;&t;&t;     &bslash;&n;&t;&t;R##_s |= Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      else&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;R##_s &amp;= Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      R##_c = FP_CLS_ZERO;&t;&t;&t;&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      if (_FP_FRAC_NEGP_##wc(R))&t;&t;&t;&t;     &bslash;&n;&t;&t;{&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;  _FP_FRAC_SUB_##wc(R, Y, X);&t;&t;&t;&t;     &bslash;&n;&t;&t;  R##_s = Y##_s;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      /* renormalize after subtraction */&t;&t;&t;     &bslash;&n;&t;      _FP_FRAC_CLZ_##wc(diff, R);&t;&t;&t;&t;     &bslash;&n;&t;      diff -= _FP_WFRACXBITS_##fs;&t;&t;&t;&t;     &bslash;&n;&t;      if (diff)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;{&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;  R##_e -= diff;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;  _FP_FRAC_SLL_##wc(R, diff);&t;&t;&t;&t;     &bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):&t;&t;&t;&t;     &bslash;&n;    _FP_CHOOSENAN(fs, wc, R, X, Y);&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):&t;&t;&t;     &bslash;&n;    R##_e = X##_e;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):&t;&t;&t;&t;     &bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = X##_c;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;    R##_e = Y##_e;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):&t;&t;&t;&t;     &bslash;&n;    _FP_FRAC_COPY_##wc(R, Y);&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = Y##_c;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):&t;&t;&t;&t;     &bslash;&n;    if (X##_s != Y##_s)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;/* +INF + -INF =&gt; NAN */&t;&t;&t;&t;&t;     &bslash;&n;&t;_FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&t;&t;     &bslash;&n;&t;R##_s = X##_s ^ Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    /* FALLTHRU */&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):&t;&t;&t;&t;     &bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):&t;&t;&t;&t;     &bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):&t;&t;&t;     &bslash;&n;    /* make sure the sign is correct */&t;&t;&t;&t;&t;     &bslash;&n;    if (FP_ROUNDMODE == FP_RND_MINF)&t;&t;&t;&t;&t;     &bslash;&n;      R##_s = X##_s | Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      R##_s = X##_s &amp; Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = FP_CLS_ZERO;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  default:&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    abort();&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;} while (0)
multiline_comment|/*&n; * Main negation routine.  FIXME -- when we care about setting exception&n; * bits reliably, this will not do.  We should examine all of the fp classes.&n; */
DECL|macro|_FP_NEG
mdefine_line|#define _FP_NEG(fs, wc, R, X)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&bslash;&n;    R##_c = X##_c;&t;&t;&t;&bslash;&n;    R##_e = X##_e;&t;&t;&t;&bslash;&n;    R##_s = 1 ^ X##_s;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/*&n; * Main multiplication routine.  The input values should be cooked.&n; */
DECL|macro|_FP_MUL
mdefine_line|#define _FP_MUL(fs, wc, R, X, Y)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  R##_s = X##_s ^ Y##_s;&t;&t;&t;&t;&bslash;&n;  switch (_FP_CLS_COMBINE(X##_c, Y##_c))&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&bslash;&n;    R##_e = X##_e + Y##_e + 1;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_MUL_MEAT_##fs(R,X,Y);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (_FP_FRAC_OVERP_##wc(fs, R))&t;&t;&t;&bslash;&n;      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&bslash;&n;      R##_e--;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):&t;&t;&bslash;&n;    _FP_CHOOSENAN(fs, wc, R, X, Y);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):&t;&t;&bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&t;&t;&bslash;&n;    R##_c = X##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):&t;&t;&bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, Y);&t;&t;&t;&t;&bslash;&n;    R##_c = Y##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):&t;&t;&bslash;&n;    R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  default:&t;&t;&t;&t;&t;&t;&bslash;&n;    abort();&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * Main division routine.  The input values should be cooked.&n; */
DECL|macro|_FP_DIV
mdefine_line|#define _FP_DIV(fs, wc, R, X, Y)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  R##_s = X##_s ^ Y##_s;&t;&t;&t;&t;&bslash;&n;  switch (_FP_CLS_COMBINE(X##_c, Y##_c))&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&bslash;&n;    R##_e = X##_e - Y##_e;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_DIV_MEAT_##fs(R,X,Y);&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):&t;&t;&bslash;&n;    _FP_CHOOSENAN(fs, wc, R, X, Y);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):&t;&t;&bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&t;&t;&bslash;&n;    R##_c = X##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):&t;&t;&bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, Y);&t;&t;&t;&t;&bslash;&n;    R##_c = Y##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_ZERO;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):&t;&bslash;&n;    R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  default:&t;&t;&t;&t;&t;&t;&bslash;&n;    abort();&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * Main differential comparison routine.  The inputs should be raw not&n; * cooked.  The return is -1,0,1 for normal values, 2 otherwise.&n; */
DECL|macro|_FP_CMP
mdefine_line|#define _FP_CMP(fs, wc, ret, X, Y, un)&t;&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    /* NANs are unordered */&t;&t;&t;&t;&t;&t;&bslash;&n;    if ((X##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(X))&t;&t;&bslash;&n;&t;|| (Y##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(Y)))&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = un;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        int __x_zero = (!X##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(X)) ? 1 : 0;&t;&bslash;&n;        int __y_zero = (!Y##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(Y)) ? 1 : 0;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (__x_zero &amp;&amp; __y_zero)&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (__x_zero)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = Y##_s ? 1 : -1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (__y_zero)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_s != Y##_s)&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_e &gt; Y##_e)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_e &lt; Y##_e)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? 1 : -1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (_FP_FRAC_GT_##wc(X, Y))&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (_FP_FRAC_GT_##wc(Y, X))&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? 1 : -1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Simplification for strict equality.  */
DECL|macro|_FP_CMP_EQ
mdefine_line|#define _FP_CMP_EQ(fs, wc, ret, X, Y)&t;&t;&t;&t;&t;  &bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;    /* NANs are unordered */&t;&t;&t;&t;&t;&t;  &bslash;&n;    if ((X##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(X))&t;&t;  &bslash;&n;&t;|| (Y##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(Y)))&t;  &bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;ret = 1;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;ret = !(X##_e == Y##_e&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;&t;&amp;&amp; _FP_FRAC_EQ_##wc(X, Y)&t;&t;&t;&t;  &bslash;&n;&t;&t;&amp;&amp; (X##_s == Y##_s || !X##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(X))); &bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;  } while (0)
multiline_comment|/*&n; * Main square root routine.  The input value should be cooked.&n; */
DECL|macro|_FP_SQRT
mdefine_line|#define _FP_SQRT(fs, wc, R, X)&t;&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_DECL_##wc(T); _FP_FRAC_DECL_##wc(S);&t;&t;&t;&bslash;&n;    _FP_W_TYPE q;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    switch (X##_c)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_NAN:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_s = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;_FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;    &t;break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_INF:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;if (X##_s)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;    R##_s = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    R##_c = FP_CLS_NAN; /* sNAN */&t;&t;&t;&t;&bslash;&n;    &t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;    R##_s = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;    R##_c = FP_CLS_INF; /* sqrt(+inf) = +inf */&t;&t;&t;&bslash;&n;    &t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_ZERO:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;R##_s = X##_s;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_c = FP_CLS_ZERO; /* sqrt(+-0) = +-0 */&t;&t;&t;&bslash;&n;&t;break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_NORMAL:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_s = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        if (X##_s)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;          {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    R##_c = FP_CLS_NAN; /* sNAN */&t;&t;&t;&t;&bslash;&n;&t;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;          }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;        if (X##_e &amp; 1)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;          _FP_FRAC_SLL_##wc(X, 1);&t;&t;&t;&t;&t;&bslash;&n;        R##_e = X##_e &gt;&gt; 1;&t;&t;&t;&t;&t;&t;&bslash;&n;        _FP_FRAC_SET_##wc(S, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;        _FP_FRAC_SET_##wc(R, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;        q = _FP_OVERFLOW_##fs;&t;&t;&t;&t;&t;&t;&bslash;&n;        _FP_FRAC_SLL_##wc(X, 1);&t;&t;&t;&t;&t;&bslash;&n;        _FP_SQRT_MEAT_##wc(R, S, T, X, q);&t;&t;&t;&t;&bslash;&n;        _FP_FRAC_SRL_##wc(R, 1);&t;&t;&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/*&n; * Convert from FP to integer&n; */
multiline_comment|/* &quot;When a NaN, infinity, large positive argument &gt;= 2147483648.0, or &n; * large negative argument &lt;= -2147483649.0 is converted to an integer,&n; * the invalid_current bit...should be set and fp_exception_IEEE_754 should&n; * be raised. If the floating point invalid trap is disabled, no trap occurs&n; * and a numerical result is generated: if the sign bit of the operand&n; * is 0, the result is 2147483647; if the sign bit of the operand is 1,&n; * the result is -2147483648.&quot;&n; * Similarly for conversion to extended ints, except that the boundaries&n; * are &gt;= 2^63, &lt;= -(2^63 + 1), and the results are 2^63 + 1 for s=0 and&n; * -2^63 for s=1.&n; * -- SPARC Architecture Manual V9, Appendix B, which specifies how&n; * SPARCs resolve implementation dependencies in the IEEE-754 spec.&n; * I don&squot;t believe that the code below follows this. I&squot;m not even sure&n; * it&squot;s right! &n; * It doesn&squot;t cope with needing to convert to an n bit integer when there&n; * is no n bit integer type. Fortunately gcc provides long long so this&n; * isn&squot;t a problem for sparc32.&n; * I have, however, fixed its NaN handling to conform as above.&n; *         -- PMM 02/1998&n; * NB: rsigned is not &squot;is r declared signed?&squot; but &squot;should the value stored&n; * in r be signed or unsigned?&squot;. r is always(?) declared unsigned.&n; * Comments below are mine, BTW -- PMM &n; */
DECL|macro|_FP_TO_INT
mdefine_line|#define _FP_TO_INT(fs, wc, r, X, rsize, rsigned)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    switch (X##_c)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      case FP_CLS_NORMAL:&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (X##_e &lt; 0)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  /* case FP_CLS_NAN: see above! */&t;&t;&t;&t;&bslash;&n;&t;  case FP_CLS_ZERO:&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    r = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_e &gt;= rsize - (rsigned != 0))&t;&t;&t;&bslash;&n;&t;  {&t;/* overflow */&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  case FP_CLS_NAN:                                              &bslash;&n;          case FP_CLS_INF:&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (rsigned)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r = 1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r &lt;&lt;= rsize - 1;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r -= 1 - X##_s;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!X##_s)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;  r = ~r;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (_FP_W_TYPE_SIZE*wc &lt; rsize)&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;_FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&bslash;&n;&t;&t;r &lt;&lt;= X##_e - _FP_WFRACBITS_##fs;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (X##_e &gt;= _FP_WFRACBITS_##fs)&t;&t;&t;&bslash;&n;&t;&t;  _FP_FRAC_SLL_##wc(X, (X##_e - _FP_WFRACBITS_##fs + 1));&bslash;&n;&t;&t;else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;  _FP_FRAC_SRL_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 1));&bslash;&n;&t;&t;_FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (rsigned &amp;&amp; X##_s)&t;&t;&t;&t;&t;&bslash;&n;&t;      r = -r;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|_FP_FROM_INT
mdefine_line|#define _FP_FROM_INT(fs, wc, X, r, rsize, rtype)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (r)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;X##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((X##_s = (r &lt; 0)))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  r = -r;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* Note that `r&squot; is now considered unsigned, so we don&squot;t have&t;&bslash;&n;&t;   to worry about the single signed overflow case.  */&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (rsize &lt;= _FP_W_TYPE_SIZE)&t;&t;&t;&t;&t;&bslash;&n;&t;  __FP_CLZ(X##_e, r);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  __FP_CLZ_2(X##_e, (_FP_W_TYPE)(r &gt;&gt; _FP_W_TYPE_SIZE), &t;&bslash;&n;&t;&t;     (_FP_W_TYPE)r);&t;&t;&t;&t;&t;&bslash;&n;&t;if (rsize &lt; _FP_W_TYPE_SIZE)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;X##_e -= (_FP_W_TYPE_SIZE - rsize);&t;&t;&t;&bslash;&n;&t;X##_e = rsize - X##_e - 1;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (_FP_FRACBITS_##fs &lt; rsize &amp;&amp; _FP_WFRACBITS_##fs &lt; X##_e)&t;&bslash;&n;&t;  __FP_FRAC_SRS_1(r, (X##_e - _FP_WFRACBITS_##fs), rsize);&t;&bslash;&n;&t;r &amp;= ~((_FP_W_TYPE)1 &lt;&lt; X##_e);&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_DISASSEMBLE_##wc(X, ((unsigned rtype)r), rsize);&t;&bslash;&n;&t;_FP_FRAC_SLL_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 1));&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;X##_c = FP_CLS_ZERO, X##_s = 0;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|FP_CONV
mdefine_line|#define FP_CONV(dfs,sfs,dwc,swc,D,S)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_CONV_##dwc##_##swc(dfs, sfs, D, S);&t;&bslash;&n;    D##_e = S##_e;&t;&t;&t;&t;&t;&bslash;&n;    D##_c = S##_c;&t;&t;&t;&t;&t;&bslash;&n;    D##_s = S##_s;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/*&n; * Helper primitives.&n; */
multiline_comment|/* Count leading zeros in a word.  */
macro_line|#ifndef __FP_CLZ
macro_line|#if _FP_W_TYPE_SIZE &lt; 64
multiline_comment|/* this is just to shut the compiler up about shifts &gt; word length -- PMM 02/1998 */
DECL|macro|__FP_CLZ
mdefine_line|#define __FP_CLZ(r, x)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_W_TYPE _t = (x);&t;&t;&t;&bslash;&n;    r = _FP_W_TYPE_SIZE - 1;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) r -= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) _t &gt;&gt;= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) r -= 8;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) _t &gt;&gt;= 8;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) r -= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) _t &gt;&gt;= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) r -= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) _t &gt;&gt;= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0x2) r -= 1;&t;&t;&t;&bslash;&n;  } while (0)
macro_line|#else /* not _FP_W_TYPE_SIZE &lt; 64 */
DECL|macro|__FP_CLZ
mdefine_line|#define __FP_CLZ(r, x)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_W_TYPE _t = (x);&t;&t;&t;&bslash;&n;    r = _FP_W_TYPE_SIZE - 1;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffffffff) r -= 32;&t;&t;&bslash;&n;    if (_t &gt; 0xffffffff) _t &gt;&gt;= 32;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) r -= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) _t &gt;&gt;= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) r -= 8;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) _t &gt;&gt;= 8;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) r -= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) _t &gt;&gt;= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) r -= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) _t &gt;&gt;= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0x2) r -= 1;&t;&t;&t;&bslash;&n;  } while (0)
macro_line|#endif /* not _FP_W_TYPE_SIZE &lt; 64 */
macro_line|#endif /* ndef __FP_CLZ */
DECL|macro|_FP_DIV_HELP_imm
mdefine_line|#define _FP_DIV_HELP_imm(q, r, n, d)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&bslash;&n;    q = n / d, r = n % d;&t;&t;&t;&bslash;&n;  } while (0)
eof
