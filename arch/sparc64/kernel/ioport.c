multiline_comment|/* $Id: ioport.c,v 1.7 1997/04/10 05:13:01 davem Exp $&n; * ioport.c:  Simple io mapping allocator.&n; *&n; * Copyright (C) 1995,1996 David S. Miller (davem@caip.rutgers.edu)&n; * Copyright (C) 1995 Miguel de Icaza (miguel@nuclecu.unam.mx)&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/vaddrs.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/* This points to the next to use virtual memory for io mappings */
DECL|variable|dvma_next_free
r_static
r_int
r_int
id|dvma_next_free
op_assign
id|DVMA_VADDR
suffix:semicolon
DECL|variable|sparc_iobase_vaddr
r_int
r_int
id|sparc_iobase_vaddr
op_assign
id|IOBASE_VADDR
suffix:semicolon
r_extern
r_void
id|mmu_map_dma_area
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
comma
id|__u32
op_star
id|dvma_addr
)paren
suffix:semicolon
multiline_comment|/*&n; * sparc_alloc_io:&n; * Map and allocates an obio device.&n; * Implements a simple linear allocator, you can force the function&n; * to use your own mapping, but in practice this should not be used.&n; *&n; * Input:&n; *  address: Physical address to map&n; *  virtual: if non zero, specifies a fixed virtual address where&n; *           the mapping should take place.&n; *  len:     the length of the mapping&n; *  bus_type: Optional high word of physical address.&n; *&n; * Returns:&n; *  The virtual address where the mapping actually took place.&n; */
DECL|function|sparc_alloc_io
r_void
op_star
id|sparc_alloc_io
(paren
id|u32
id|address
comma
r_void
op_star
r_virtual
comma
r_int
id|len
comma
r_char
op_star
id|name
comma
id|u32
id|bus_type
comma
r_int
id|rdonly
)paren
(brace
r_int
r_int
id|vaddr
comma
id|base_address
suffix:semicolon
r_int
r_int
id|addr
op_assign
(paren
(paren
r_int
r_int
)paren
id|address
)paren
op_plus
(paren
(paren
(paren
r_int
r_int
)paren
id|bus_type
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
r_int
r_int
id|offset
op_assign
(paren
id|addr
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
r_virtual
)paren
(brace
id|vaddr
op_assign
(paren
r_int
r_int
)paren
r_virtual
suffix:semicolon
id|len
op_add_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
r_virtual
op_plus
id|len
)paren
OG
(paren
id|IOBASE_VADDR
op_plus
id|IOBASE_LEN
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_io: Mapping outside IOBASE area&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
(paren
(paren
id|vaddr
op_or
id|offset
)paren
comma
id|len
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_io: 0x%lx is already in use&bslash;n&quot;
comma
id|vaddr
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Tell Linux resource manager about the mapping */
id|request_region
(paren
(paren
id|vaddr
op_or
id|offset
)paren
comma
id|len
comma
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|vaddr
op_assign
id|occupy_region
c_func
(paren
id|sparc_iobase_vaddr
comma
id|IOBASE_END
comma
(paren
id|offset
op_plus
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
comma
id|PAGE_SIZE
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Usually we cannot see printks in this case. */
id|prom_printf
c_func
(paren
l_string|&quot;alloc_io: cannot occupy %d region&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|base_address
op_assign
id|vaddr
suffix:semicolon
multiline_comment|/* Do the actual mapping */
r_for
c_loop
(paren
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
)paren
(brace
id|mapioaddr
c_func
(paren
id|addr
comma
id|vaddr
comma
id|bus_type
comma
id|rdonly
)paren
suffix:semicolon
id|vaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
(paren
id|base_address
op_or
id|offset
)paren
suffix:semicolon
)brace
DECL|function|sparc_free_io
r_void
id|sparc_free_io
(paren
r_void
op_star
r_virtual
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
r_int
r_int
)paren
r_virtual
op_amp
id|PAGE_MASK
suffix:semicolon
r_int
r_int
id|plen
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
r_virtual
op_amp
op_complement
id|PAGE_MASK
)paren
op_plus
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|release_region
c_func
(paren
id|vaddr
comma
id|plen
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|plen
op_ne
l_int|0
suffix:semicolon
)paren
(brace
id|plen
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|unmapioaddr
c_func
(paren
id|vaddr
op_plus
id|plen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Does DVMA allocations with PAGE_SIZE granularity.  How this basically&n; * works is that the ESP chip can do DVMA transfers at ANY address with&n; * certain size and boundary restrictions.  But other devices that are&n; * attached to it and would like to do DVMA have to set things up in&n; * a special way, if the DVMA sees a device attached to it transfer data&n; * at addresses above DVMA_VADDR it will grab them, this way it does not&n; * now have to know the peculiarities of where to read the Lance data&n; * from. (for example)&n; *&n; * Returns CPU visible address for the buffer returned, dvma_addr is&n; * set to the DVMA visible address.&n; */
DECL|function|sparc_dvma_malloc
r_void
op_star
id|sparc_dvma_malloc
(paren
r_int
id|len
comma
r_char
op_star
id|name
comma
id|__u32
op_star
id|dvma_addr
)paren
(brace
r_int
r_int
id|vaddr
comma
id|base_address
suffix:semicolon
id|vaddr
op_assign
id|dvma_next_free
suffix:semicolon
r_if
c_cond
(paren
id|check_region
(paren
id|vaddr
comma
id|len
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_dma: 0x%lx is already in use&bslash;n&quot;
comma
id|vaddr
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vaddr
op_plus
id|len
OG
(paren
id|DVMA_VADDR
op_plus
id|DVMA_LEN
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;alloc_dvma: out of dvma memory&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Basically these can be mapped just like any old&n;&t; * IO pages, cacheable bit off, etc.  The physical&n;&t; * pages are now mapped dynamically to save space.&n;&t; */
id|base_address
op_assign
id|vaddr
suffix:semicolon
id|mmu_map_dma_area
c_func
(paren
id|base_address
comma
id|len
comma
id|dvma_addr
)paren
suffix:semicolon
multiline_comment|/* Assign the memory area. */
id|dvma_next_free
op_assign
id|PAGE_ALIGN
c_func
(paren
id|dvma_next_free
op_plus
id|len
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|base_address
comma
id|len
comma
id|name
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|base_address
suffix:semicolon
)brace
eof
