multiline_comment|/* smp.c: Sparc64 SMP support.&n; *&n; * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/head.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/starfire.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
r_extern
r_int
id|linux_num_cpus
suffix:semicolon
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|prom_cpu_nodes
(braket
)braket
suffix:semicolon
DECL|variable|cpu_data
r_struct
id|cpuinfo_sparc
id|cpu_data
(braket
id|NR_CPUS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
DECL|variable|__cpu_number_map
r_volatile
r_int
id|__cpu_number_map
(braket
id|NR_CPUS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
DECL|variable|__cpu_logical_map
r_volatile
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Please don&squot;t make this stuff initdata!!!  --DaveM */
DECL|variable|boot_cpu_id
r_static
r_int
r_char
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|smp_activated
r_static
r_int
id|smp_activated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Kernel spinlock */
DECL|variable|kernel_flag
id|spinlock_t
id|kernel_flag
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|smp_processors_ready
r_volatile
r_int
id|smp_processors_ready
op_assign
l_int|0
suffix:semicolon
DECL|variable|cpu_present_map
r_int
r_int
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
op_assign
l_int|0
suffix:semicolon
DECL|function|smp_setup
r_void
id|__init
id|smp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/* XXX implement me XXX */
)brace
DECL|function|smp_info
r_int
id|smp_info
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
op_assign
l_int|7
comma
id|i
suffix:semicolon
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;State:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;CPU%d:&bslash;t&bslash;tonline&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|smp_bogo
r_int
id|smp_bogo
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Cpu%dBogo&bslash;t: %lu.%02lu&bslash;n&quot;
comma
id|i
comma
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|smp_store_cpu_info
r_void
id|__init
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* multiplier and counter set by&n;&t;   smp_setup_percpu_timer()  */
id|cpu_data
(braket
id|id
)braket
dot
id|udelay_val
op_assign
id|loops_per_jiffy
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pgcache_size
op_assign
l_int|0
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pte_cache
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pte_cache
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pgdcache_size
op_assign
l_int|0
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|pgd_cache
op_assign
l_int|NULL
suffix:semicolon
id|cpu_data
(braket
id|id
)braket
dot
id|idle_volume
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu_data
(braket
id|id
)braket
dot
id|irq_worklists
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|smp_commence
r_void
id|__init
id|smp_commence
c_func
(paren
r_void
)paren
(brace
)brace
r_static
r_void
id|smp_setup_percpu_timer
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|smp_tune_scheduling
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|callin_flag
r_static
r_volatile
r_int
r_int
id|callin_flag
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|inherit_locked_prom_mappings
c_func
(paren
r_int
id|save_p
)paren
suffix:semicolon
r_extern
r_void
id|cpu_probe
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|smp_callin
r_void
id|__init
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|pstate
suffix:semicolon
id|inherit_locked_prom_mappings
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__flush_cache_all
c_func
(paren
)paren
suffix:semicolon
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
id|cpu_probe
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Guarentee that the following sequences execute&n;&t; * uninterrupted.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Set things up so user can access tick register for profiling&n;&t; * purposes.  Also workaround BB_ERRATA_1 by doing a dummy&n;&t; * read back of %tick after writing it.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|sethi
op_mod
op_mod
id|hi
c_func
(paren
l_int|0x80000000
)paren
comma
op_mod
op_mod
id|g1
id|ba
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|sllx
op_mod
op_mod
id|g1
comma
l_int|32
comma
op_mod
op_mod
id|g1
dot
id|align
l_int|64
l_int|1
suffix:colon
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g2
id|add
op_mod
op_mod
id|g2
comma
l_int|6
comma
op_mod
op_mod
id|g2
id|andn
op_mod
op_mod
id|g2
comma
op_mod
op_mod
id|g1
comma
op_mod
op_mod
id|g2
id|wrpr
op_mod
op_mod
id|g2
comma
l_int|0
comma
op_mod
op_mod
id|tick
id|rdpr
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g0
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|smp_setup_percpu_timer
c_func
(paren
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
id|callin_flag
op_assign
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;membar #Sync&bslash;n&bslash;t&quot;
l_string|&quot;flush  %%g6&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear this or we will die instantly when we&n;&t; * schedule back to this idler...&n;&t; */
id|current-&gt;thread.flags
op_and_assign
op_complement
(paren
id|SPARC_FLAG_NEWCHILD
)paren
suffix:semicolon
multiline_comment|/* Attach to the address space of init_task. */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|smp_processors_ready
)paren
(brace
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
)brace
r_extern
r_int
id|cpu_idle
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|initialize_secondary
r_void
id|initialize_secondary
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|start_secondary
r_int
id|start_secondary
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|trap_init
c_func
(paren
)paren
suffix:semicolon
id|init_IRQ
c_func
(paren
)paren
suffix:semicolon
id|smp_callin
c_func
(paren
)paren
suffix:semicolon
r_return
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cpu_panic
r_void
id|cpu_panic
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Returns from cpu_idle!&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;SMP bolixed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|prom_cpuinfo
id|linux_cpus
(braket
l_int|64
)braket
suffix:semicolon
r_extern
r_int
r_int
id|sparc64_cpu_startup
suffix:semicolon
multiline_comment|/* The OBP cpu startup callback truncates the 3rd arg cookie to&n; * 32-bits (I think) so to be safe we have it read the pointer&n; * contained here so we work on &gt;4GB machines. -DaveM&n; */
DECL|variable|cpu_new_task
r_static
r_struct
id|task_struct
op_star
id|cpu_new_task
op_assign
l_int|NULL
suffix:semicolon
DECL|function|smp_boot_cpus
r_void
id|__init
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|cpucount
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Entering UltraSMPenguin Mode...&bslash;n&quot;
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
id|init_idle
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linux_num_cpus
op_eq
l_int|1
)paren
(brace
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|boot_cpu_id
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
r_int
r_int
id|entry
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|sparc64_cpu_startup
)paren
suffix:semicolon
r_int
r_int
id|cookie
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|cpu_new_task
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|no
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Starting CPU %d... &quot;
comma
id|i
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|start_secondary
comma
l_int|NULL
comma
id|CLONE_PID
)paren
suffix:semicolon
id|cpucount
op_increment
suffix:semicolon
id|p
op_assign
id|init_task.prev_task
suffix:semicolon
id|init_tasks
(braket
id|cpucount
)braket
op_assign
id|p
suffix:semicolon
id|p-&gt;processor
op_assign
id|i
suffix:semicolon
id|p-&gt;has_cpu
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we schedule the first task manually */
id|del_from_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|unhash_process
c_func
(paren
id|p
)paren
suffix:semicolon
id|callin_flag
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|no
op_assign
l_int|0
suffix:semicolon
id|no
OL
id|linux_num_cpus
suffix:semicolon
id|no
op_increment
)paren
r_if
c_cond
(paren
id|linux_cpus
(braket
id|no
)braket
dot
id|mid
op_eq
id|i
)paren
r_break
suffix:semicolon
id|cpu_new_task
op_assign
id|p
suffix:semicolon
id|prom_startcpu
c_func
(paren
id|linux_cpus
(braket
id|no
)braket
dot
id|prom_node
comma
id|entry
comma
id|cookie
)paren
suffix:semicolon
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|5000000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|callin_flag
)paren
(brace
r_break
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|callin_flag
)paren
(brace
id|__cpu_number_map
(braket
id|i
)braket
op_assign
id|cpucount
suffix:semicolon
id|__cpu_logical_map
(braket
id|cpucount
)braket
op_assign
id|i
suffix:semicolon
id|prom_cpu_nodes
(braket
id|i
)braket
op_assign
id|linux_cpus
(braket
id|no
)braket
dot
id|prom_node
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;OK&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpucount
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor %d is stuck.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;FAILED&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|callin_flag
)paren
(brace
id|cpu_present_map
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|i
)paren
suffix:semicolon
id|__cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|cpu_new_task
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cpucount
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error: only one processor found.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_present_map
op_assign
(paren
l_int|1UL
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|bogosum
op_add_assign
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpucount
op_plus
l_int|1
comma
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|500000
comma
(paren
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|smp_activated
op_assign
l_int|1
suffix:semicolon
id|smp_num_cpus
op_assign
id|cpucount
op_plus
l_int|1
suffix:semicolon
)brace
id|smp_processors_ready
op_assign
l_int|1
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #StoreLoad&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* #define XCALL_DEBUG */
DECL|function|xcall_deliver
r_static
r_inline
r_void
id|xcall_deliver
c_func
(paren
id|u64
id|data0
comma
id|u64
id|data1
comma
id|u64
id|data2
comma
id|u64
id|pstate
comma
r_int
r_int
id|cpu
)paren
(brace
id|u64
id|result
comma
id|target
suffix:semicolon
r_int
id|stuck
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
)paren
(brace
multiline_comment|/* map to real upaid */
id|cpu
op_assign
(paren
(paren
(paren
id|cpu
op_amp
l_int|0x3c
)paren
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|cpu
op_amp
l_int|0x40
)paren
op_rshift
l_int|4
)paren
op_or
(paren
id|cpu
op_amp
l_int|0x3
)paren
)paren
suffix:semicolon
)brace
id|target
op_assign
(paren
id|cpu
op_lshift
l_int|14
)paren
op_or
l_int|0x70
suffix:semicolon
macro_line|#ifdef XCALL_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: xcall(data[%016lx:%016lx:%016lx],tgt[%016lx])&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|data0
comma
id|data1
comma
id|data2
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
id|again
suffix:colon
multiline_comment|/* Ok, this is the real Spitfire Errata #54.&n;&t; * One must read back from a UDB internal register&n;&t; * after writes to the UDB interrupt dispatch, but&n;&t; * before the membar Sync for that write.&n;&t; * So we use the high UDB control register (ASI 0x7f,&n;&t; * ADDR 0x20) for the dummy read. -DaveM&n;&t; */
id|tmp
op_assign
l_int|0x40
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|wrpr
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
op_mod
id|pstate
id|stxa
op_mod
l_int|4
comma
(braket
op_mod
l_int|0
)braket
op_mod
l_int|3
id|stxa
op_mod
l_int|5
comma
(braket
op_mod
l_int|0
op_plus
op_mod
l_int|8
)braket
op_mod
l_int|3
id|add
op_mod
l_int|0
comma
op_mod
l_int|8
comma
op_mod
l_int|0
id|stxa
op_mod
l_int|6
comma
(braket
op_mod
l_int|0
op_plus
op_mod
l_int|8
)braket
op_mod
l_int|3
id|membar
macro_line|#Sync
id|stxa
op_mod
op_mod
id|g0
comma
(braket
op_mod
l_int|7
)braket
op_mod
l_int|3
id|membar
macro_line|#Sync
id|mov
l_int|0x20
comma
op_mod
op_mod
id|g1
id|ldxa
(braket
op_mod
op_mod
id|g1
)braket
l_int|0x7f
comma
op_mod
op_mod
id|g0
id|membar
macro_line|#Sync&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_UDB_INTR_W
)paren
comma
l_string|&quot;r&quot;
(paren
id|data0
)paren
comma
l_string|&quot;r&quot;
(paren
id|data1
)paren
comma
l_string|&quot;r&quot;
(paren
id|data2
)paren
comma
l_string|&quot;r&quot;
(paren
id|target
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x10
)paren
comma
l_string|&quot;0&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTE: PSTATE_IE is still clear. */
id|stuck
op_assign
l_int|100000
suffix:semicolon
r_do
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_DISPATCH_STAT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|stuck
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|stuck
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|result
op_amp
l_int|0x1
)paren
(brace
suffix:semicolon
)brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuck
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef XCALL_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: mondo stuckage result[%016lx]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
macro_line|#ifdef XCALL_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Penguin %d NACK&squot;s master.&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu
)paren
suffix:semicolon
macro_line|#endif
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
DECL|function|smp_cross_call
r_void
id|smp_cross_call
c_func
(paren
r_int
r_int
op_star
id|func
comma
id|u32
id|ctx
comma
id|u64
id|data1
comma
id|u64
id|data2
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_int
r_int
id|mask
op_assign
(paren
id|cpu_present_map
op_amp
op_complement
(paren
l_int|1UL
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|u64
id|pstate
comma
id|data0
op_assign
(paren
(paren
(paren
id|u64
)paren
id|ctx
)paren
op_lshift
l_int|32
op_or
(paren
(paren
(paren
id|u64
)paren
id|func
)paren
op_amp
l_int|0xffffffff
)paren
)paren
suffix:semicolon
r_int
id|i
comma
id|ncpus
op_assign
id|smp_num_cpus
op_minus
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|xcall_deliver
c_func
(paren
id|data0
comma
id|data1
comma
id|data2
comma
id|pstate
comma
id|i
)paren
suffix:semicolon
id|ncpus
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ncpus
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* NOTE: Caller runs local copy on master. */
)brace
)brace
DECL|struct|call_data_struct
r_struct
id|call_data_struct
(brace
DECL|member|func
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
suffix:semicolon
DECL|member|info
r_void
op_star
id|info
suffix:semicolon
DECL|member|finished
id|atomic_t
id|finished
suffix:semicolon
DECL|member|wait
r_int
id|wait
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_int
r_int
id|xcall_call_function
suffix:semicolon
DECL|function|smp_call_function
r_int
id|smp_call_function
c_func
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|nonatomic
comma
r_int
id|wait
)paren
(brace
r_struct
id|call_data_struct
id|data
suffix:semicolon
r_int
id|cpus
op_assign
id|smp_num_cpus
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus
)paren
r_return
l_int|0
suffix:semicolon
id|data.func
op_assign
id|func
suffix:semicolon
id|data.info
op_assign
id|info
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|data.finished
comma
l_int|0
)paren
suffix:semicolon
id|data.wait
op_assign
id|wait
suffix:semicolon
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_call_function
comma
l_int|0
comma
(paren
id|u64
)paren
op_amp
id|data
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|data.finished
)paren
op_ne
id|cpus
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_call_function_client
r_void
id|smp_call_function_client
c_func
(paren
r_struct
id|call_data_struct
op_star
id|call_data
)paren
(brace
id|call_data
op_member_access_from_pointer
id|func
c_func
(paren
id|call_data-&gt;info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|call_data-&gt;wait
)paren
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;finished
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|xcall_flush_tlb_page
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_mm
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_range
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_tlb_all
suffix:semicolon
r_extern
r_int
r_int
id|xcall_tlbcachesync
suffix:semicolon
r_extern
r_int
r_int
id|xcall_flush_cache_all
suffix:semicolon
r_extern
r_int
r_int
id|xcall_report_regs
suffix:semicolon
r_extern
r_int
r_int
id|xcall_receive_signal
suffix:semicolon
DECL|function|smp_receive_signal
r_void
id|smp_receive_signal
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
op_logical_and
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|cpu
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|u64
id|pstate
comma
id|data0
op_assign
(paren
(paren
(paren
id|u64
)paren
op_amp
id|xcall_receive_signal
)paren
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|xcall_deliver
c_func
(paren
id|data0
comma
l_int|0
comma
l_int|0
comma
id|pstate
comma
id|cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_report_regs
r_void
id|smp_report_regs
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_report_regs
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|smp_flush_cache_all
r_void
id|smp_flush_cache_all
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_cache_all
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|__flush_cache_all
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|smp_flush_tlb_all
r_void
id|smp_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_all
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We know that the window frames of the user have been flushed&n; * to the stack before we get here because all callers of us&n; * are flush_tlb_*() routines, and these run after flush_cache_*()&n; * which performs the flushw.&n; *&n; * XXX I diked out the fancy flush avoidance code for the&n; * XXX swapping cases for now until the new MM code stabilizes. -DaveM&n; *&n; * The SMP TLB coherency scheme we use works as follows:&n; *&n; * 1) mm-&gt;cpu_vm_mask is a bit mask of which cpus an address&n; *    space has (potentially) executed on, this is the heuristic&n; *    we use to avoid doing cross calls.&n; *&n; * 2) TLB context numbers are shared globally across all processors&n; *    in the system, this allows us to play several games to avoid&n; *    cross calls.&n; *&n; *    One invariant is that when a cpu switches to a process, and&n; *    that processes tsk-&gt;active_mm-&gt;cpu_vm_mask does not have the&n; *    current cpu&squot;s bit set, that tlb context is flushed locally.&n; *&n; *    If the address space is non-shared (ie. mm-&gt;count == 1) we avoid&n; *    cross calls when we want to flush the currently running process&squot;s&n; *    tlb state.  This is done by clearing all cpu bits except the current&n; *    processor&squot;s in current-&gt;active_mm-&gt;cpu_vm_mask and performing the&n; *    flush locally only.  This will force any subsequent cpus which run&n; *    this task to flush the context from the local tlb if the process&n; *    migrates to another cpu (again).&n; *&n; * 3) For shared address spaces (threads) and swapping we bite the&n; *    bullet for most cases and perform the cross call.&n; *&n; *    The performance gain from &quot;optimizing&quot; away the cross call for threads is&n; *    questionable (in theory the big win for threads is the massive sharing of&n; *    address space state across processors).&n; *&n; *    For the swapping case the locking is difficult to get right, we&squot;d have to&n; *    enforce strict ordered access to mm-&gt;cpu_vm_mask via a spinlock for example.&n; *    Then again one could argue that when you are swapping, the cost of a cross&n; *    call won&squot;t even show up on the performance radar.  But in any case we do get&n; *    rid of the cross-call when the task has a dead context or the task has only&n; *    ever run on the local cpu.&n; */
DECL|function|smp_flush_tlb_mm
r_void
id|smp_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|CTX_VALID
c_func
(paren
id|mm-&gt;context
)paren
)paren
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* See smp_flush_tlb_page for info about this. */
id|mm-&gt;cpu_vm_mask
op_assign
(paren
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_mm
comma
id|ctx
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_mm
c_func
(paren
id|ctx
comma
id|SECONDARY_CONTEXT
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_flush_tlb_range
r_void
id|smp_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_if
c_cond
(paren
id|CTX_VALID
c_func
(paren
id|mm-&gt;context
)paren
)paren
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|end
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
id|mm-&gt;cpu_vm_mask
op_assign
(paren
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_range
comma
id|ctx
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_range
c_func
(paren
id|ctx
comma
id|start
comma
id|SECONDARY_CONTEXT
comma
id|end
comma
id|PAGE_SIZE
comma
(paren
id|end
op_minus
id|start
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|smp_flush_tlb_page
r_void
id|smp_flush_tlb_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|page
)paren
(brace
r_if
c_cond
(paren
id|CTX_VALID
c_func
(paren
id|mm-&gt;context
)paren
)paren
(brace
id|u32
id|ctx
op_assign
id|CTX_HWBITS
c_func
(paren
id|mm-&gt;context
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;active_mm
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* By virtue of being the current address space, and&n;&t;&t;&t; * having the only reference to it, the following operation&n;&t;&t;&t; * is safe.&n;&t;&t;&t; *&n;&t;&t;&t; * It would not be a win to perform the xcall tlb flush in&n;&t;&t;&t; * this case, because even if we switch back to one of the&n;&t;&t;&t; * other processors in cpu_vm_mask it is almost certain that&n;&t;&t;&t; * all TLB entries for this context will be replaced by the&n;&t;&t;&t; * time that happens.&n;&t;&t;&t; */
id|mm-&gt;cpu_vm_mask
op_assign
(paren
l_int|1UL
op_lshift
id|cpu
)paren
suffix:semicolon
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* By virtue of running under the mm-&gt;page_table_lock,&n;&t;&t;&t; * and mmu_context.h:switch_mm doing the same, the following&n;&t;&t;&t; * operation is safe.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mm-&gt;cpu_vm_mask
op_eq
(paren
l_int|1UL
op_lshift
id|cpu
)paren
)paren
r_goto
id|local_flush_and_out
suffix:semicolon
)brace
multiline_comment|/* OK, we have to actually perform the cross call.  Most likely&n;&t;&t; * this is a cloned mm or kswapd is kicking out pages for a task&n;&t;&t; * which has run recently on another cpu.&n;&t;&t; */
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_flush_tlb_page
comma
id|ctx
comma
id|page
comma
l_int|0
)paren
suffix:semicolon
id|local_flush_and_out
suffix:colon
id|__flush_tlb_page
c_func
(paren
id|ctx
comma
id|page
comma
id|SECONDARY_CONTEXT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* CPU capture. */
multiline_comment|/* #define CAPTURE_DEBUG */
r_extern
r_int
r_int
id|xcall_capture
suffix:semicolon
DECL|variable|smp_capture_depth
r_static
id|atomic_t
id|smp_capture_depth
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|smp_capture_registry
r_static
id|atomic_t
id|smp_capture_registry
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|penguins_are_doing_time
r_static
r_int
r_int
id|penguins_are_doing_time
op_assign
l_int|0
suffix:semicolon
DECL|function|smp_capture
r_void
id|smp_capture
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_int
id|result
op_assign
id|__atomic_add
c_func
(paren
l_int|1
comma
op_amp
id|smp_capture_depth
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #LoadStore&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|1
)paren
(brace
r_int
id|ncpus
op_assign
id|smp_num_cpus
suffix:semicolon
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Sending penguins to jail...&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|penguins_are_doing_time
op_assign
l_int|1
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #LoadStore&quot;
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_capture
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|smp_capture_registry
)paren
op_ne
id|ncpus
)paren
(brace
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
DECL|function|smp_release
r_void
id|smp_release
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|smp_capture_depth
)paren
)paren
(brace
macro_line|#ifdef CAPTURE_DEBUG
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: Giving pardon to imprisoned penguins&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|penguins_are_doing_time
op_assign
l_int|0
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #StoreLoad&quot;
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Imprisoned penguins run with %pil == 15, but PSTATE_IE set, so they&n; * can service tlb flush xcalls...&n; */
r_extern
r_void
id|prom_world
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|save_alternate_globals
c_func
(paren
r_int
r_int
op_star
)paren
suffix:semicolon
r_extern
r_void
id|restore_alternate_globals
c_func
(paren
r_int
r_int
op_star
)paren
suffix:semicolon
DECL|function|smp_penguin_jailcell
r_void
id|smp_penguin_jailcell
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|global_save
(braket
l_int|24
)braket
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;flushw&quot;
)paren
suffix:semicolon
id|save_alternate_globals
c_func
(paren
id|global_save
)paren
suffix:semicolon
id|prom_world
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad | #StoreStore&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|penguins_are_doing_time
)paren
(brace
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
id|restore_alternate_globals
c_func
(paren
id|global_save
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|smp_capture_registry
)paren
suffix:semicolon
id|prom_world
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|xcall_promstop
suffix:semicolon
DECL|function|smp_promstop_others
r_void
id|smp_promstop_others
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|smp_processors_ready
)paren
id|smp_cross_call
c_func
(paren
op_amp
id|xcall_promstop
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_void
id|sparc64_do_profile
c_func
(paren
r_int
r_int
id|pc
comma
r_int
r_int
id|o7
)paren
suffix:semicolon
DECL|variable|current_tick_offset
r_static
r_int
r_int
id|current_tick_offset
suffix:semicolon
DECL|macro|prof_multiplier
mdefine_line|#define prof_multiplier(__cpu)&t;&t;cpu_data[(__cpu)].multiplier
DECL|macro|prof_counter
mdefine_line|#define prof_counter(__cpu)&t;&t;cpu_data[(__cpu)].counter
DECL|function|smp_percpu_timer_interrupt
r_void
id|smp_percpu_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|compare
comma
id|tick
comma
id|pstate
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|user
op_assign
id|user_mode
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for level 14 softint.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|get_softint
c_func
(paren
)paren
op_amp
(paren
l_int|1UL
op_lshift
l_int|0
)paren
)paren
)paren
(brace
r_extern
r_void
id|handler_irq
c_func
(paren
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
id|handler_irq
c_func
(paren
l_int|14
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_softint
c_func
(paren
(paren
l_int|1UL
op_lshift
l_int|0
)paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
id|sparc64_do_profile
c_func
(paren
id|regs-&gt;tpc
comma
id|regs-&gt;u_regs
(braket
id|UREG_RETPC
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|prof_counter
c_func
(paren
id|cpu
)paren
)paren
(brace
r_if
c_cond
(paren
id|cpu
op_eq
id|boot_cpu_id
)paren
(brace
id|irq_enter
c_func
(paren
id|cpu
comma
l_int|0
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|timer_tick_interrupt
c_func
(paren
id|regs
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
l_int|0
)paren
suffix:semicolon
)brace
id|update_process_times
c_func
(paren
id|user
)paren
suffix:semicolon
id|prof_counter
c_func
(paren
id|cpu
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
multiline_comment|/* Guarentee that the following sequences execute&n;&t;&t; * uninterrupted.&n;&t;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Workaround for Spitfire Errata (#54 I think??), I discovered&n;&t;&t; * this via Sun BugID 4008234, mentioned in Solaris-2.5.1 patch&n;&t;&t; * number 103640.&n;&t;&t; *&n;&t;&t; * On Blackbird writes to %tick_cmpr can fail, the&n;&t;&t; * workaround seems to be to execute the wr instruction&n;&t;&t; * at the start of an I-cache line, and perform a dummy&n;&t;&t; * read back from %tick_cmpr right after writing to it. -DaveM&n;&t;&t; *&n;&t;&t; * Just to be anal we add a workaround for Spitfire&n;&t;&t; * Errata 50 by preventing pipeline bypasses on the&n;&t;&t; * final read of the %tick register into a compare&n;&t;&t; * instruction.  The Errata 50 description states&n;&t;&t; * that %tick is not prone to this bug, but I am not&n;&t;&t; * taking any chances.&n;&t;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rd&t;%%tick_cmpr, %0&bslash;n&bslash;t&quot;
l_string|&quot;ba,pt&t;%%xcc, 1f&bslash;n&bslash;t&quot;
l_string|&quot; add&t;%0, %2, %0&bslash;n&bslash;t&quot;
l_string|&quot;.align&t;64&bslash;n&quot;
l_string|&quot;1: wr&t;%0, 0x0, %%tick_cmpr&bslash;n&bslash;t&quot;
l_string|&quot;rd&t;%%tick_cmpr, %%g0&bslash;n&bslash;t&quot;
l_string|&quot;rd&t;%%tick, %1&bslash;n&bslash;t&quot;
l_string|&quot;mov&t;%1, %1&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|compare
)paren
comma
l_string|&quot;=r&quot;
(paren
id|tick
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|current_tick_offset
)paren
)paren
suffix:semicolon
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tick
op_ge
id|compare
)paren
suffix:semicolon
)brace
DECL|function|smp_setup_percpu_timer
r_static
r_void
id|__init
id|smp_setup_percpu_timer
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|pstate
suffix:semicolon
id|prof_counter
c_func
(paren
id|cpu
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|cpu
)paren
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Guarentee that the following sequences execute&n;&t; * uninterrupted.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Workaround for Spitfire Errata (#54 I think??), I discovered&n;&t; * this via Sun BugID 4008234, mentioned in Solaris-2.5.1 patch&n;&t; * number 103640.&n;&t; *&n;&t; * On Blackbird writes to %tick_cmpr can fail, the&n;&t; * workaround seems to be to execute the wr instruction&n;&t; * at the start of an I-cache line, and perform a dummy&n;&t; * read back from %tick_cmpr right after writing to it. -DaveM&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g1
id|ba
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|add
op_mod
op_mod
id|g1
comma
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
dot
id|align
l_int|64
l_int|1
suffix:colon
id|wr
op_mod
op_mod
id|g1
comma
l_int|0x0
comma
op_mod
op_mod
id|tick_cmpr
id|rd
op_mod
op_mod
id|tick_cmpr
comma
op_mod
op_mod
id|g0
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|current_tick_offset
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
DECL|function|smp_tick_init
r_void
id|__init
id|smp_tick_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|boot_cpu_id
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|current_tick_offset
op_assign
id|timer_tick_offset
suffix:semicolon
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linux_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu_present_map
op_or_assign
(paren
l_int|1UL
op_lshift
id|linux_cpus
(braket
id|i
)braket
dot
id|mid
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|__cpu_logical_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|__cpu_number_map
(braket
id|boot_cpu_id
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_cpu_nodes
(braket
id|boot_cpu_id
)braket
op_assign
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
suffix:semicolon
id|__cpu_logical_map
(braket
l_int|0
)braket
op_assign
id|boot_cpu_id
suffix:semicolon
id|current-&gt;processor
op_assign
id|boot_cpu_id
suffix:semicolon
id|prof_counter
c_func
(paren
id|boot_cpu_id
)paren
op_assign
id|prof_multiplier
c_func
(paren
id|boot_cpu_id
)paren
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|find_flush_base
r_static
r_inline
r_int
r_int
id|find_flush_base
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_struct
id|page
op_star
id|p
op_assign
id|mem_map
suffix:semicolon
r_int
r_int
id|found
comma
id|base
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|found
op_assign
id|size
suffix:semicolon
id|base
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|p
)paren
suffix:semicolon
r_while
c_loop
(paren
id|found
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Failure. */
r_if
c_cond
(paren
id|p
op_ge
(paren
id|mem_map
op_plus
id|max_mapnr
)paren
)paren
(brace
r_return
l_int|0UL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|p
)paren
)paren
(brace
id|found
op_assign
id|size
suffix:semicolon
id|base
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|found
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
)brace
r_return
id|base
suffix:semicolon
)brace
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
DECL|function|smp_tune_scheduling
r_static
r_void
id|__init
id|smp_tune_scheduling
(paren
r_void
)paren
(brace
r_int
r_int
id|orig_flush_base
comma
id|flush_base
comma
id|flags
comma
op_star
id|p
suffix:semicolon
r_int
r_int
id|ecache_size
comma
id|order
suffix:semicolon
id|cycles_t
id|tick1
comma
id|tick2
comma
id|raw
suffix:semicolon
multiline_comment|/* Approximate heuristic for SMP scheduling.  It is an&n;&t; * estimation of the time it takes to flush the L2 cache&n;&t; * on the local processor.&n;&t; *&n;&t; * The ia32 chooses to use the L1 cache flush time instead,&n;&t; * and I consider this complete nonsense.  The Ultra can service&n;&t; * a miss to the L1 with a hit to the L2 in 7 or 8 cycles, and&n;&t; * L2 misses are what create extra bus traffic (ie. the &quot;cost&quot;&n;&t; * of moving a process from one cpu to another).&n;&t; */
id|printk
c_func
(paren
l_string|&quot;SMP: Calibrating ecache flush... &quot;
)paren
suffix:semicolon
id|ecache_size
op_assign
id|prom_getintdefault
c_func
(paren
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
comma
l_string|&quot;ecache-size&quot;
comma
(paren
l_int|512
op_star
l_int|1024
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecache_size
OG
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
id|ecache_size
op_assign
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
id|orig_flush_base
op_assign
id|flush_base
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|order
op_assign
id|get_order
c_func
(paren
id|ecache_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush_base
op_ne
l_int|0UL
)paren
(brace
id|__save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Scan twice the size once just to get the TLB entries&n;&t;&t; * loaded and make sure the second scan measures pure misses.&n;&t;&t; */
r_for
c_loop
(paren
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|flush_base
suffix:semicolon
(paren
(paren
r_int
r_int
)paren
id|p
)paren
OL
(paren
id|flush_base
op_plus
(paren
id|ecache_size
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
id|p
op_add_assign
(paren
l_int|64
op_div
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Now the real measurement. */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|b
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|rd
op_mod
op_mod
id|tick
comma
op_mod
l_int|0
dot
id|align
l_int|64
l_int|1
suffix:colon
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x000
)braket
comma
op_mod
op_mod
id|g1
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x040
)braket
comma
op_mod
op_mod
id|g2
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x080
)braket
comma
op_mod
op_mod
id|g3
id|ldx
(braket
op_mod
l_int|2
op_plus
l_int|0x0c0
)braket
comma
op_mod
op_mod
id|g5
id|add
op_mod
l_int|2
comma
l_int|0x100
comma
op_mod
l_int|2
id|cmp
op_mod
l_int|2
comma
op_mod
l_int|4
id|bne
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_int|1
id|b
id|nop
id|rd
op_mod
op_mod
id|tick
comma
op_mod
l_int|1
"&quot;"
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tick1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tick2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|flush_base
)paren
suffix:colon
l_string|&quot;2&quot;
(paren
id|flush_base
)paren
comma
l_string|&quot;r&quot;
(paren
id|flush_base
op_plus
id|ecache_size
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;g5&quot;
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|raw
op_assign
(paren
id|tick2
op_minus
id|tick1
)paren
suffix:semicolon
multiline_comment|/* Dampen it a little, considering two processes&n;&t;&t; * sharing the cache and fitting.&n;&t;&t; */
id|cacheflush_time
op_assign
(paren
id|raw
op_minus
(paren
id|raw
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
id|orig_flush_base
comma
id|order
)paren
suffix:semicolon
)brace
r_else
(brace
id|cacheflush_time
op_assign
(paren
(paren
id|ecache_size
op_lshift
l_int|2
)paren
op_plus
(paren
id|ecache_size
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Using heuristic of %d cycles.&bslash;n&quot;
comma
(paren
r_int
)paren
id|cacheflush_time
)paren
suffix:semicolon
)brace
multiline_comment|/* /proc/profile writes can call this, don&squot;t __init it please. */
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|multiplier
)paren
op_logical_or
(paren
id|timer_tick_offset
op_div
id|multiplier
)paren
OL
l_int|1000
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1UL
op_lshift
id|i
)paren
)paren
(brace
id|prof_multiplier
c_func
(paren
id|i
)paren
op_assign
id|multiplier
suffix:semicolon
)brace
)brace
id|current_tick_offset
op_assign
(paren
id|timer_tick_offset
op_div
id|multiplier
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
