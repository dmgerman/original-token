multiline_comment|/* $Id: semaphore.c,v 1.5 2000/11/10 04:02:03 davem Exp $&n; *  Generic semaphore code. Buyer beware. Do your own&n; * specific changes in &lt;asm/semaphore-helper.h&gt;&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/semaphore-helper.h&gt;
multiline_comment|/*&n; * Semaphores are implemented using a two-way counter:&n; * The &quot;count&quot; variable is decremented for each process&n; * that tries to sleep, while the &quot;waking&quot; variable is&n; * incremented when the &quot;up()&quot; code goes to wake up waiting&n; * processes.&n; *&n; * Notably, the inline &quot;up()&quot; and &quot;down()&quot; functions can&n; * efficiently test if they need to do any extra work (up&n; * needs to do something only if count was negative before&n; * the increment operation.&n; *&n; * waking_non_zero() (from asm/semaphore.h) must execute&n; * atomically.&n; *&n; * When __up() is called, the count was negative before&n; * incrementing it, and we need to wake up somebody.&n; *&n; * This routine adds one to the count of processes that need to&n; * wake up and exit.  ALL waiting processes actually wake up but&n; * only the one that gets to the &quot;waking&quot; field first will gate&n; * through and acquire the semaphore.  The others will go back&n; * to sleep.&n; *&n; * Note that these functions are only called when there is&n; * contention on the lock, and as such all this is the&n; * &quot;non-critical&quot; part of the whole semaphore business. The&n; * critical part is the inline stuff in &lt;asm/semaphore.h&gt;&n; * where we want to avoid any extra jumps and calls.&n; */
DECL|function|__up
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|wake_one_more
c_func
(paren
id|sem
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform the &quot;down&quot; function.  Return zero for semaphore acquired,&n; * return negative for signalled out of the function.&n; *&n; * If called from __down, the return is ignored and the wait loop is&n; * not interruptible.  This means that a task waiting on a semaphore&n; * using &quot;down()&quot; cannot be killed until someone does an &quot;up()&quot; on&n; * the semaphore.&n; *&n; * If called from __down_interruptible, the return value gets checked&n; * upon return.  If the return value is negative then the task continues&n; * with the negative value in the return register (it can be tested by&n; * the caller).&n; *&n; * Either form may be used in conjunction with &quot;up()&quot;.&n; *&n; */
DECL|macro|DOWN_VAR
mdefine_line|#define DOWN_VAR&t;&t;&t;&t;&bslash;&n;&t;struct task_struct *tsk = current;&t;&bslash;&n;&t;DECLARE_WAITQUEUE(wait, tsk);
DECL|macro|DOWN_HEAD
mdefine_line|#define DOWN_HEAD(task_state)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;tsk-&gt;state = (task_state);&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;sem-&gt;wait, &amp;wait);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Ok, we&squot;re set up.  sem-&gt;count is known to be less than zero&t;&bslash;&n;&t; * so we must wait.&t;&t;&t;&t;&t;&t;&bslash;&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * We can let go the lock for purposes of waiting.&t;&t;&bslash;&n;&t; * We re-acquire it after awaking so as to protect&t;&t;&bslash;&n;&t; * all semaphore operations.&t;&t;&t;&t;&t;&bslash;&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * If &quot;up()&quot; is called before we call waking_non_zero() then&t;&bslash;&n;&t; * we will catch it right away.  If it is called later then&t;&bslash;&n;&t; * we will have to go through a wakeup cycle to catch it.&t;&bslash;&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Multiple waiters contend for the semaphore lock to see&t;&bslash;&n;&t; * who gets to gate through and who has to wait some more.&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {
DECL|macro|DOWN_TAIL
mdefine_line|#define DOWN_TAIL(task_state)&t;&t;&t;&bslash;&n;&t;&t;tsk-&gt;state = (task_state);&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&bslash;&n;&t;tsk-&gt;state = TASK_RUNNING;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;sem-&gt;wait, &amp;wait);
DECL|function|__down
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|DOWN_VAR
id|DOWN_HEAD
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
r_if
c_cond
(paren
id|waking_non_zero
c_func
(paren
id|sem
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|DOWN_TAIL
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
)brace
DECL|function|__down_interruptible
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DOWN_VAR
id|DOWN_HEAD
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
id|ret
op_assign
id|waking_non_zero_interruptible
c_func
(paren
id|sem
comma
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
multiline_comment|/* ret != 0 only if we get interrupted -arca */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|DOWN_TAIL
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__down_trylock
r_int
id|__down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_return
id|waking_non_zero_trylock
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
multiline_comment|/* rw mutexes&n; * Implemented by Jakub Jelinek (jakub@redhat.com) based on&n; * i386 implementation by Ben LaHaise (bcrl@redhat.com).&n; */
id|asm
c_func
(paren
"&quot;"
dot
id|text
dot
id|align
l_int|32
dot
id|globl
id|__down_read_failed
id|__down_read_failed
suffix:colon
id|save
op_mod
id|sp
comma
op_minus
l_int|160
comma
op_mod
id|sp
id|membar
macro_line|#StoreStore
id|brz
comma
id|pt
op_mod
id|g5
comma
l_float|3f
id|mov
op_mod
id|g7
comma
op_mod
id|l0
l_int|1
suffix:colon
id|call
id|down_read_failed
id|mov
op_mod
id|l0
comma
op_mod
id|o0
l_int|2
suffix:colon
id|lduw
(braket
op_mod
id|l0
)braket
comma
op_mod
id|l1
id|sub
op_mod
id|l1
comma
l_int|1
comma
op_mod
id|l2
id|cas
(braket
op_mod
id|l0
)braket
comma
op_mod
id|l1
comma
op_mod
id|l2
id|cmp
op_mod
id|l1
comma
op_mod
id|l2
id|bne
comma
id|pn
op_mod
id|icc
comma
l_int|2
id|b
id|membar
macro_line|#StoreStore
id|subcc
op_mod
id|l1
comma
l_int|1
comma
op_mod
id|g0
id|bpos
comma
id|pt
op_mod
id|icc
comma
l_float|4f
id|nop
id|bcc
comma
id|pn
op_mod
id|icc
comma
l_int|1
id|b
id|nop
l_int|3
suffix:colon
id|call
id|down_read_failed_biased
id|mov
op_mod
id|l0
comma
op_mod
id|o0
l_int|4
suffix:colon
id|ret
id|restore
dot
id|previous
"&quot;"
)paren
suffix:semicolon
id|asm
c_func
(paren
"&quot;"
dot
id|text
dot
id|align
l_int|32
dot
id|globl
id|__down_write_failed
id|__down_write_failed
suffix:colon
id|save
op_mod
id|sp
comma
op_minus
l_int|160
comma
op_mod
id|sp
id|membar
macro_line|#StoreStore
id|tst
op_mod
id|g5
id|bge
comma
id|pt
op_mod
id|icc
comma
l_float|3f
id|mov
op_mod
id|g7
comma
op_mod
id|l0
l_int|1
suffix:colon
id|call
id|down_write_failed
id|mov
op_mod
id|l0
comma
op_mod
id|o0
l_int|2
suffix:colon
id|lduw
(braket
op_mod
id|l0
)braket
comma
op_mod
id|l1
id|sethi
op_mod
id|hi
(paren
l_string|&quot; RW_LOCK_BIAS_STR &quot;
)paren
comma
op_mod
id|l3
id|sub
op_mod
id|l1
comma
op_mod
id|l3
comma
op_mod
id|l2
id|cas
(braket
op_mod
id|l0
)braket
comma
op_mod
id|l1
comma
op_mod
id|l2
id|cmp
op_mod
id|l1
comma
op_mod
id|l2
id|bne
comma
id|pn
op_mod
id|icc
comma
l_int|2
id|b
id|membar
macro_line|#StoreStore
id|subcc
op_mod
id|l1
comma
op_mod
id|l3
comma
op_mod
id|g0
id|be
comma
id|pt
op_mod
id|icc
comma
l_float|4f
id|nop
id|bcc
comma
id|pn
op_mod
id|icc
comma
l_int|1
id|b
id|nop
l_int|3
suffix:colon
id|call
id|down_write_failed_biased
id|mov
op_mod
id|l0
comma
op_mod
id|o0
l_int|4
suffix:colon
id|ret
id|restore
dot
id|previous
"&quot;"
)paren
suffix:semicolon
DECL|function|down_read_failed_biased
r_void
id|down_read_failed_biased
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|DOWN_VAR
id|add_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* put ourselves at the head of the list */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_le_bit
c_func
(paren
l_int|0
comma
op_amp
id|sem-&gt;granted
)paren
)paren
r_break
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_le_bit
c_func
(paren
l_int|0
comma
op_amp
id|sem-&gt;granted
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
DECL|function|down_write_failed_biased
r_void
id|down_write_failed_biased
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|DOWN_VAR
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* put ourselves at the end of the list */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_le_bit
c_func
(paren
l_int|1
comma
op_amp
id|sem-&gt;granted
)paren
)paren
r_break
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_le_bit
c_func
(paren
l_int|1
comma
op_amp
id|sem-&gt;granted
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* if the lock is currently unbiased, awaken the sleepers&n;&t; * FIXME: this wakes up the readers early in a bit of a&n;&t; * stampede -&gt; bad!&n;&t; */
r_if
c_cond
(paren
id|sem-&gt;count
op_ge
l_int|0
)paren
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for the lock to become unbiased.  Readers&n; * are non-exclusive. =)&n; */
DECL|function|down_read_failed
r_void
id|down_read_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|DOWN_VAR
id|__up_read
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/* this takes care of granting the lock */
id|add_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sem-&gt;count
OL
l_int|0
)paren
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;count
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/* Wait for the lock to become unbiased. Since we&squot;re&n; * a writer, we&squot;ll make ourselves exclusive.&n; */
DECL|function|down_write_failed
r_void
id|down_write_failed
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|DOWN_VAR
id|__up_write
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/* this takes care of granting the lock */
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sem-&gt;count
OL
l_int|0
)paren
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;count
op_ge
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* we must attempt to acquire or bias the lock */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
DECL|function|__rwsem_wake
r_void
id|__rwsem_wake
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
r_int
id|readers
)paren
(brace
r_if
c_cond
(paren
id|readers
)paren
(brace
r_if
c_cond
(paren
id|test_and_set_le_bit
c_func
(paren
l_int|0
comma
op_amp
id|sem-&gt;granted
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|test_and_set_le_bit
c_func
(paren
l_int|1
comma
op_amp
id|sem-&gt;granted
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
)paren
suffix:semicolon
)brace
)brace
eof
