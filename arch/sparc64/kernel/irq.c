multiline_comment|/* $Id: irq.c,v 1.94 2000/09/21 06:27:10 anton Exp $&n; * irq.c: UltraSparc IRQ handling/init/registry.&n; *&n; * Copyright (C) 1997  David S. Miller  (davem@caip.rutgers.edu)&n; * Copyright (C) 1998  Eddie C. Dost    (ecd@skynet.be)&n; * Copyright (C) 1998  Jakub Jelinek    (jj@ultra.linux.cz)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/random.h&gt; /* XXX ADD add_foo_randomness() calls... -DaveM */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/sbus.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/upa.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#include &lt;asm/starfire.h&gt;
multiline_comment|/* Internal flag, should not be visible elsewhere at all. */
DECL|macro|SA_IMAP_MASKED
mdefine_line|#define SA_IMAP_MASKED&t;&t;0x100
DECL|macro|SA_DMA_SYNC
mdefine_line|#define SA_DMA_SYNC&t;&t;0x200
macro_line|#ifdef CONFIG_SMP
r_static
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* UPA nodes send interrupt packet to UltraSparc with first data reg&n; * value low 5 (7 on Starfire) bits holding the IRQ identifier being&n; * delivered.  We must translate this into a non-vector IRQ so we can&n; * set the softint on this cpu.&n; *&n; * To make processing these packets efficient and race free we use&n; * an array of irq buckets below.  The interrupt vector handler in&n; * entry.S feeds incoming packets into per-cpu pil-indexed lists.&n; * The IVEC handler does not need to act atomically, the PIL dispatch&n; * code uses CAS to get an atomic snapshot of the list and clear it&n; * at the same time.&n; */
DECL|variable|ivector_table
r_struct
id|ino_bucket
id|ivector_table
(braket
id|NUM_IVECS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
DECL|variable|__up_workvec
r_int
r_int
id|__up_workvec
(braket
l_int|16
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
DECL|macro|irq_work
mdefine_line|#define irq_work(__cpu, __pil)&t;&amp;(__up_workvec[(void)(__cpu), (__pil)])
macro_line|#else
DECL|macro|irq_work
mdefine_line|#define irq_work(__cpu, __pil)&t;&amp;(cpu_data[(__cpu)].irq_worklists[(__pil)])
macro_line|#endif
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* This is a table of physical addresses used to deal with SA_DMA_SYNC.&n; * It is used for PCI only to synchronize DMA transfers with IRQ delivery&n; * for devices behind busses other than APB on Sabre systems.&n; *&n; * Currently these physical addresses are just config space accesses&n; * to the command register for that device.&n; */
DECL|variable|pci_dma_wsync
r_int
r_int
id|pci_dma_wsync
suffix:semicolon
DECL|variable|dma_sync_reg_table
r_int
r_int
id|dma_sync_reg_table
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|dma_sync_reg_table_entry
r_int
r_char
id|dma_sync_reg_table_entry
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* This is based upon code in the 32-bit Sparc kernel written mostly by&n; * David Redman (djhr@tadpole.co.uk).&n; */
DECL|macro|MAX_STATIC_ALLOC
mdefine_line|#define MAX_STATIC_ALLOC&t;4
DECL|variable|static_irqaction
r_static
r_struct
id|irqaction
id|static_irqaction
(braket
id|MAX_STATIC_ALLOC
)braket
suffix:semicolon
DECL|variable|static_irq_count
r_static
r_int
id|static_irq_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is exported so that fast IRQ handlers can get at it... -DaveM */
DECL|variable|irq_action
r_struct
id|irqaction
op_star
id|irq_action
(braket
id|NR_IRQS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|get_irq_list
r_int
id|get_irq_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|j
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NR_IRQS
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|action
op_assign
op_star
(paren
id|i
op_plus
id|irq_action
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%3d: &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%10u &quot;
comma
id|kstat_irqs
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|smp_num_cpus
suffix:semicolon
id|j
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%10u &quot;
comma
id|kstat.irqs
(braket
id|cpu_logical_map
c_func
(paren
id|j
)paren
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%c %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;,%s %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_string|&quot; +&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* Now these are always passed a true fully specified sun4u INO. */
DECL|function|enable_irq
r_void
id|enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|imap
suffix:semicolon
r_int
r_int
id|tid
suffix:semicolon
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|0UL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We set it to our UPA MID. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tid
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_UPA_CONFIG
)paren
)paren
suffix:semicolon
id|tid
op_assign
(paren
(paren
id|tid
op_amp
id|UPA_CONFIG_MID
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
)brace
r_else
(brace
id|tid
op_assign
(paren
id|starfire_translate
c_func
(paren
id|imap
comma
id|current-&gt;processor
)paren
op_lshift
l_int|26
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE NOTE NOTE, IGN and INO are read-only, IGN is a product&n;&t; * of this SYSIO&squot;s preconfigured IGN in the SYSIO Control&n;&t; * Register, the hardware just mirrors that value here.&n;&t; * However for Graphics and UPA Slave devices the full&n;&t; * IMAP_INR field can be set by the programmer here.&n;&t; *&n;&t; * Things like FFB can now be handled via the new IRQ mechanism.&n;&t; */
id|upa_writel
c_func
(paren
id|IMAP_VALID
op_or
(paren
id|tid
op_amp
id|IMAP_TID
)paren
comma
id|imap
)paren
suffix:semicolon
)brace
multiline_comment|/* This now gets passed true ino&squot;s as well. */
DECL|function|disable_irq
r_void
id|disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|imap
suffix:semicolon
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_ne
l_int|0UL
)paren
(brace
id|u32
id|tmp
suffix:semicolon
multiline_comment|/* NOTE: We do not want to futz with the IRQ clear registers&n;&t;&t; *       and move the state to IDLE, the SCSI code does call&n;&t;&t; *       disable_irq() to assure atomicity in the queue cmd&n;&t;&t; *       SCSI adapter driver code.  Thus we&squot;d lose interrupts.&n;&t;&t; */
id|tmp
op_assign
id|upa_readl
c_func
(paren
id|imap
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|IMAP_VALID
suffix:semicolon
id|upa_writel
c_func
(paren
id|tmp
comma
id|imap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The timer is the one &quot;weird&quot; interrupt which is generated by&n; * the CPU %tick register and not by some normal vectored interrupt&n; * source.  To handle this special case, we use this dummy INO bucket.&n; */
DECL|variable|pil0_dummy_bucket
r_static
r_struct
id|ino_bucket
id|pil0_dummy_bucket
op_assign
(brace
l_int|0
comma
multiline_comment|/* irq_chain */
l_int|0
comma
multiline_comment|/* pil */
l_int|0
comma
multiline_comment|/* pending */
l_int|0
comma
multiline_comment|/* flags */
l_int|0
comma
multiline_comment|/* __unused */
l_int|NULL
comma
multiline_comment|/* irq_info */
l_int|0UL
comma
multiline_comment|/* iclr */
l_int|0UL
comma
multiline_comment|/* imap */
)brace
suffix:semicolon
DECL|function|build_irq
r_int
r_int
id|build_irq
c_func
(paren
r_int
id|pil
comma
r_int
id|inofixup
comma
r_int
r_int
id|iclr
comma
r_int
r_int
id|imap
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|ino
suffix:semicolon
r_if
c_cond
(paren
id|pil
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|iclr
op_ne
l_int|0UL
op_logical_or
id|imap
op_ne
l_int|0UL
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid dummy bucket for PIL0 (%lx:%lx)&bslash;n&quot;
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|__irq
c_func
(paren
op_amp
id|pil0_dummy_bucket
)paren
suffix:semicolon
)brace
multiline_comment|/* RULE: Both must be specified in all other cases. */
r_if
c_cond
(paren
id|iclr
op_eq
l_int|0UL
op_logical_or
id|imap
op_eq
l_int|0UL
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid build_irq %d %d %016lx %016lx&bslash;n&quot;
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|ino
op_assign
(paren
id|upa_readl
c_func
(paren
id|imap
)paren
op_amp
(paren
id|IMAP_IGN
op_or
id|IMAP_INO
)paren
)paren
op_plus
id|inofixup
suffix:semicolon
r_if
c_cond
(paren
id|ino
OG
id|NUM_IVECS
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid INO %04x (%d:%d:%016lx:%016lx)&bslash;n&quot;
comma
id|ino
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok, looks good, set it up.  Don&squot;t touch the irq_chain or&n;&t; * the pending flag.&n;&t; */
id|bucket
op_assign
op_amp
id|ivector_table
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_logical_or
(paren
id|bucket-&gt;irq_info
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* This is a gross fatal error if it happens here. */
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Trying to reinit INO bucket, fatal error.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Request INO %04x (%d:%d:%016lx:%016lx)&bslash;n&quot;
comma
id|ino
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Existing (%d:%016lx:%016lx)&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|bucket-&gt;iclr
comma
id|bucket-&gt;imap
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Cannot continue, halting...&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|bucket-&gt;imap
op_assign
id|imap
suffix:semicolon
id|bucket-&gt;iclr
op_assign
id|iclr
suffix:semicolon
id|bucket-&gt;pil
op_assign
id|pil
suffix:semicolon
id|bucket-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
l_int|NULL
suffix:semicolon
r_return
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
)brace
DECL|function|atomic_bucket_insert
r_static
r_void
id|atomic_bucket_insert
c_func
(paren
r_struct
id|ino_bucket
op_star
id|bucket
)paren
(brace
r_int
r_int
id|pstate
suffix:semicolon
r_int
r_int
op_star
id|ent
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, %1, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
id|ent
op_assign
id|irq_work
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
id|bucket-&gt;irq_chain
op_assign
op_star
id|ent
suffix:semicolon
op_star
id|ent
op_assign
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pending
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;request_irq: Old style IRQ registry attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bucket-&gt;pil
)paren
id|irqflags
op_and_assign
op_complement
id|SA_IMAP_MASKED
suffix:semicolon
r_else
(brace
id|irqflags
op_or_assign
id|SA_IMAP_MASKED
suffix:semicolon
r_if
c_cond
(paren
id|bucket-&gt;flags
op_amp
id|IBF_PCI
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * PCI IRQs should never use SA_INTERRUPT.&n;&t;&t;&t; */
id|irqflags
op_and_assign
op_complement
(paren
id|SA_INTERRUPT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check wether we _should_ use DMA Write Sync&n;&t;&t;&t; * (for devices behind bridges behind APB). &n;&t;&t;&t; */
r_if
c_cond
(paren
id|bucket-&gt;flags
op_amp
id|IBF_DMA_SYNC
)paren
id|irqflags
op_or_assign
id|SA_DMA_SYNC
suffix:semicolon
)brace
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
op_logical_and
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
)paren
r_for
c_loop
(paren
id|tmp
op_assign
id|action
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
suffix:semicolon
r_else
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
op_xor
(paren
id|irqflags
op_amp
id|SA_INTERRUPT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to mix fast and slow interrupts on IRQ%d &quot;
l_string|&quot;denied&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Or else! */
)brace
multiline_comment|/* If this is flagged as statically allocated then we use our&n;&t; * private struct which is never freed.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
(brace
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|irq
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|irqflags
op_amp
id|SA_IMAP_MASKED
)paren
op_eq
l_int|0
)paren
(brace
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
r_void
op_star
id|orig
op_assign
id|bucket-&gt;irq_info
suffix:semicolon
r_void
op_star
op_star
id|vector
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_PCI
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRQ: Trying to share non-PCI bucket.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_eq
l_int|0
)paren
(brace
id|vector
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
op_eq
l_int|NULL
)paren
(brace
r_goto
id|free_and_enomem
suffix:semicolon
)brace
multiline_comment|/* We might have slept. */
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|ent
suffix:semicolon
id|kfree
c_func
(paren
id|vector
)paren
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|bucket-&gt;irq_info
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
l_int|NULL
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
id|action
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ent
op_eq
l_int|4
)paren
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
r_else
(brace
id|vector
(braket
l_int|0
)braket
op_assign
id|orig
suffix:semicolon
id|vector
(braket
l_int|1
)braket
op_assign
id|action
suffix:semicolon
id|vector
(braket
l_int|2
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vector
(braket
l_int|3
)braket
op_assign
l_int|NULL
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
id|vector
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_MULTI
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|ent
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|orig
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
l_int|NULL
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
id|action
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ent
op_eq
l_int|4
)paren
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
)brace
r_else
(brace
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
)brace
id|pending
op_assign
id|bucket-&gt;pending
suffix:semicolon
r_if
c_cond
(paren
id|pending
)paren
(brace
id|bucket-&gt;pending
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|action-&gt;mask
op_assign
(paren
r_int
r_int
)paren
id|bucket
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action
suffix:semicolon
)brace
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* We ate the IVEC already, this makes sure it does not get lost. */
r_if
c_cond
(paren
id|pending
)paren
(brace
id|atomic_bucket_insert
c_func
(paren
id|bucket
)paren
suffix:semicolon
id|set_softint
c_func
(paren
l_int|1
op_lshift
id|bucket-&gt;pil
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|free_and_ebusy
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
id|free_and_enomem
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|irqaction
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
comma
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;free_irq: Old style IRQ removal attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing free IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_id
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_eq
id|dev_id
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|action
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free shared IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free shared IRQ %d with NULL device ID&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to free statically allocated IRQ %d (%s)&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|action-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_logical_and
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
r_int
r_int
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_void
op_star
op_star
id|vector
comma
op_star
id|orig
suffix:semicolon
r_int
id|ent
suffix:semicolon
id|orig
op_assign
id|bucket-&gt;irq_info
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|orig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|other
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|orphan
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
id|action
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_ne
l_int|NULL
)paren
(brace
id|orphan
op_assign
id|vector
(braket
id|ent
)braket
suffix:semicolon
id|other
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Only free when no other shared irq&n;&t;&t;&t; * uses this bucket.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|other
)paren
(brace
r_if
c_cond
(paren
id|other
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Convert back to non-shared bucket. */
id|bucket-&gt;irq_info
op_assign
id|orphan
suffix:semicolon
id|bucket-&gt;flags
op_and_assign
op_complement
(paren
id|IBF_MULTI
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vector
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|bucket-&gt;irq_info
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This unique interrupt source is now inactive. */
id|bucket-&gt;flags
op_and_assign
op_complement
id|IBF_ACTIVE
suffix:semicolon
multiline_comment|/* See if any other buckets share this bucket&squot;s IMAP&n;&t;&t; * and are still active.&n;&t;&t; */
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
id|NUM_IVECS
suffix:semicolon
id|ent
op_increment
)paren
(brace
id|bp
op_assign
op_amp
id|ivector_table
(braket
id|ent
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
id|bucket
op_logical_and
id|bp-&gt;imap
op_eq
id|imap
op_logical_and
(paren
id|bp-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Only disable when no other sub-irq levels of&n;&t;&t; * the same IMAP are active.&n;&t;&t; */
r_if
c_cond
(paren
id|ent
op_eq
id|NUM_IVECS
)paren
id|disable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Who has the global irq brlock */
DECL|variable|global_irq_holder
r_int
r_char
id|global_irq_holder
op_assign
id|NO_PROC_ID
suffix:semicolon
DECL|function|show
r_static
r_void
id|show
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s, CPU %d:&bslash;n&quot;
comma
id|str
comma
id|cpu
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq:  %d [ &quot;
comma
id|irqs_running
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%u &quot;
comma
id|__brlock_array
(braket
id|i
)braket
(braket
id|BR_GLOBALIRQ_LOCK
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;]&bslash;nbh:   %d [ &quot;
comma
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%u &quot;
comma
id|local_bh_count
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|macro|MAXCOUNT
mdefine_line|#define MAXCOUNT 100000000
macro_line|#if 0
mdefine_line|#define SYNC_OTHER_ULTRAS(x)&t;udelay(x+1)
macro_line|#else
DECL|macro|SYNC_OTHER_ULTRAS
mdefine_line|#define SYNC_OTHER_ULTRAS(x)&t;membar(&quot;#Sync&quot;);
macro_line|#endif
DECL|function|synchronize_irq
r_void
id|synchronize_irq
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|irqs_running
c_func
(paren
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_irqlock
r_static
r_inline
r_void
id|get_irqlock
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|cpu
op_eq
id|global_irq_holder
)paren
r_return
suffix:semicolon
id|count
op_assign
id|MAXCOUNT
suffix:semicolon
id|again
suffix:colon
id|br_write_lock
c_func
(paren
id|BR_GLOBALIRQ_LOCK
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spinlock_t
op_star
id|lock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irqs_running
c_func
(paren
)paren
op_logical_and
(paren
id|local_bh_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_logical_or
op_logical_neg
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
)paren
)paren
r_break
suffix:semicolon
id|br_write_unlock
c_func
(paren
id|BR_GLOBALIRQ_LOCK
)paren
suffix:semicolon
id|lock
op_assign
op_amp
id|__br_write_locks
(braket
id|BR_GLOBALIRQ_LOCK
)braket
dot
id|lock
suffix:semicolon
r_while
c_loop
(paren
id|irqs_running
c_func
(paren
)paren
op_logical_or
id|spin_is_locked
c_func
(paren
id|lock
)paren
op_logical_or
(paren
op_logical_neg
id|local_bh_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_logical_and
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
(brace
id|show
c_func
(paren
l_string|&quot;get_irqlock&quot;
)paren
suffix:semicolon
id|count
op_assign
(paren
op_complement
l_int|0
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|SYNC_OTHER_ULTRAS
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
)brace
r_goto
id|again
suffix:semicolon
)brace
id|global_irq_holder
op_assign
id|cpu
suffix:semicolon
)brace
DECL|function|__global_cli
r_void
id|__global_cli
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
id|get_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|__global_sti
r_void
id|__global_sti
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
id|release_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|__global_save_flags
r_int
r_int
id|__global_save_flags
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
comma
id|local_enabled
comma
id|retval
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_enabled
op_assign
(paren
(paren
id|flags
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
l_int|2
op_plus
id|local_enabled
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|local_enabled
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|global_irq_holder
op_eq
(paren
r_int
r_char
)paren
id|smp_processor_id
c_func
(paren
)paren
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|__global_restore_flags
r_void
id|__global_restore_flags
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
l_int|0
suffix:colon
id|__global_cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|__global_sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|__sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
(brace
r_int
r_int
id|pc
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pc
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;global_restore_flags: Bogon flags(%016lx) caller %016lx&bslash;n&quot;
comma
id|flags
comma
id|pc
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_SMP */
DECL|function|catch_disabled_ivec
r_void
id|catch_disabled_ivec
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
op_star
id|irq_work
c_func
(paren
id|cpu
comma
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* We can actually see this on Ultra/PCI PCI cards, which are bridges&n;&t; * to other devices.  Here a single IMAP enabled potentially multiple&n;&t; * unique interrupt sources (which each do have a unique ICLR register.&n;&t; *&n;&t; * So what we do is just register that the IVEC arrived, when registered&n;&t; * for real the request_irq() code will check the bit and signal&n;&t; * a local CPU interrupt for it.&n;&t; */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;IVEC: Spurious interrupt vector (%x) received at (%016lx)&bslash;n&quot;
comma
id|bucket
op_minus
op_amp
id|ivector_table
(braket
l_int|0
)braket
comma
id|regs-&gt;tpc
)paren
suffix:semicolon
macro_line|#endif
op_star
id|irq_work
c_func
(paren
id|cpu
comma
l_int|0
)paren
op_assign
l_int|0
suffix:semicolon
id|bucket-&gt;pending
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Tune this... */
DECL|macro|FORWARD_VOLUME
mdefine_line|#define FORWARD_VOLUME&t;&t;12
DECL|function|handler_irq
r_void
id|handler_irq
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bp
comma
op_star
id|nbp
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|should_forward
op_assign
(paren
id|this_is_starfire
op_eq
l_int|0
op_logical_and
id|irq
OL
l_int|10
op_logical_and
id|current-&gt;pid
op_ne
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|buddy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &squot;cpu&squot; is the MID (ie. UPAID), calculate the MID&n;&t; * of our buddy.&n;&t; */
r_if
c_cond
(paren
id|should_forward
op_ne
l_int|0
)paren
(brace
id|buddy
op_assign
id|cpu_number_map
c_func
(paren
id|cpu
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|buddy
op_ge
id|NR_CPUS
op_logical_or
(paren
id|buddy
op_assign
id|cpu_logical_map
c_func
(paren
id|buddy
)paren
)paren
op_eq
op_minus
l_int|1
)paren
id|buddy
op_assign
id|cpu_logical_map
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Voo-doo programming. */
r_if
c_cond
(paren
id|cpu_data
(braket
id|buddy
)braket
dot
id|idle_volume
OL
id|FORWARD_VOLUME
)paren
id|should_forward
op_assign
l_int|0
suffix:semicolon
id|buddy
op_lshift_assign
l_int|26
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef CONFIG_SMP
multiline_comment|/*&n;&t; * Check for TICK_INT on level 14 softint.&n;&t; */
r_if
c_cond
(paren
(paren
id|irq
op_eq
l_int|14
)paren
op_logical_and
(paren
id|get_softint
c_func
(paren
)paren
op_amp
(paren
l_int|1UL
op_lshift
l_int|0
)paren
)paren
)paren
id|irq
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
multiline_comment|/* Sliiiick... */
macro_line|#ifndef CONFIG_SMP
id|bp
op_assign
(paren
(paren
id|irq
op_ne
l_int|0
)paren
ques
c_cond
id|__bucket
c_func
(paren
id|xchg32
c_func
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
comma
l_int|0
)paren
)paren
suffix:colon
op_amp
id|pil0_dummy_bucket
)paren
suffix:semicolon
macro_line|#else
id|bp
op_assign
id|__bucket
c_func
(paren
id|xchg32
c_func
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
comma
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|bp
op_ne
l_int|NULL
suffix:semicolon
id|bp
op_assign
id|nbp
)paren
(brace
r_int
r_char
id|flags
op_assign
id|bp-&gt;flags
suffix:semicolon
id|nbp
op_assign
id|__bucket
c_func
(paren
id|bp-&gt;irq_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_DMA_SYNC
)paren
op_ne
l_int|0
)paren
(brace
id|upa_readl
c_func
(paren
id|dma_sync_reg_table
(braket
id|bp-&gt;synctab_ent
)braket
)paren
suffix:semicolon
id|upa_readq
c_func
(paren
id|pci_dma_wsync
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_MULTI
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|irqaction
op_star
id|ap
op_assign
id|bp-&gt;irq_info
suffix:semicolon
id|ap
op_member_access_from_pointer
id|handler
c_func
(paren
id|__irq
c_func
(paren
id|bp
)paren
comma
id|ap-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
r_void
op_star
op_star
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|bp-&gt;irq_info
suffix:semicolon
r_int
id|ent
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|ap
op_assign
id|vector
(braket
id|ent
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_ne
l_int|NULL
)paren
id|ap
op_member_access_from_pointer
id|handler
c_func
(paren
id|__irq
c_func
(paren
id|bp
)paren
comma
id|ap-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Only the dummy bucket lacks IMAP/ICLR. */
r_if
c_cond
(paren
id|bp-&gt;pil
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Ok, here is what is going on:&n;&t;&t;&t;&t; * 1) Retargeting IRQs on Starfire is very&n;&t;&t;&t;&t; *    expensive so just forget about it on them.&n;&t;&t;&t;&t; * 2) Moving around very high priority interrupts&n;&t;&t;&t;&t; *    is a losing game.&n;&t;&t;&t;&t; * 3) If the current cpu is idle, interrupts are&n;&t;&t;&t;&t; *    useful work, so keep them here.  But do not&n;&t;&t;&t;&t; *    pass to our neighbour if he is not very idle.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|should_forward
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Push it to our buddy. */
id|should_forward
op_assign
l_int|0
suffix:semicolon
id|upa_writel
c_func
(paren
id|buddy
op_or
id|IMAP_VALID
comma
id|bp-&gt;imap
)paren
suffix:semicolon
)brace
macro_line|#endif
id|upa_writel
c_func
(paren
id|ICLR_IDLE
comma
id|bp-&gt;iclr
)paren
suffix:semicolon
)brace
)brace
r_else
id|bp-&gt;pending
op_assign
l_int|1
suffix:semicolon
)brace
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_FD
r_extern
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|sparc_floppy_irq
r_void
id|sparc_floppy_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
op_star
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|bucket
op_assign
(paren
r_struct
id|ino_bucket
op_star
)paren
id|action-&gt;mask
suffix:semicolon
id|floppy_interrupt
c_func
(paren
id|irq
comma
id|dev_cookie
comma
id|regs
)paren
suffix:semicolon
id|upa_writel
c_func
(paren
id|ICLR_IDLE
comma
id|bucket-&gt;iclr
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* The following assumes that the branch lies before the place we&n; * are branching to.  This is the case for a trap vector...&n; * You have been warned.&n; */
DECL|macro|SPARC_BRANCH
mdefine_line|#define SPARC_BRANCH(dest_addr, inst_addr) &bslash;&n;          (0x10800000 | ((((dest_addr)-(inst_addr))&gt;&gt;2)&amp;0x3fffff))
DECL|macro|SPARC_NOP
mdefine_line|#define SPARC_NOP (0x01000000)
DECL|function|install_fast_irq
r_static
r_void
id|install_fast_irq
c_func
(paren
r_int
r_int
id|cpu_irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_extern
r_int
r_int
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
id|ttent
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
op_star
id|insns
suffix:semicolon
id|ttent
op_add_assign
l_int|0x820
suffix:semicolon
id|ttent
op_add_assign
(paren
id|cpu_irq
op_minus
l_int|1
)paren
op_lshift
l_int|5
suffix:semicolon
id|insns
op_assign
(paren
r_int
r_int
op_star
)paren
id|ttent
suffix:semicolon
id|insns
(braket
l_int|0
)braket
op_assign
id|SPARC_BRANCH
c_func
(paren
(paren
(paren
r_int
r_int
)paren
id|handler
)paren
comma
(paren
(paren
r_int
r_int
)paren
op_amp
id|insns
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|insns
(braket
l_int|1
)braket
op_assign
id|SPARC_NOP
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;membar #StoreStore; flush %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|ttent
)paren
)paren
suffix:semicolon
)brace
DECL|function|request_fast_irq
r_int
id|request_fast_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* No pil0 dummy buckets allowed here. */
r_if
c_cond
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;request_fast_irq: Old style IRQ registry attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Only IMAP style interrupts can be registered as fast. */
r_if
c_cond
(paren
id|bucket-&gt;pil
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;pil
op_eq
l_int|0
)paren
op_logical_or
(paren
id|bucket-&gt;pil
op_eq
l_int|14
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register shared IRQ 0 or 14.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq when already shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq as shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register yet already owned.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
(brace
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|install_fast_irq
c_func
(paren
id|bucket-&gt;pil
comma
id|handler
)paren
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
id|action-&gt;mask
op_assign
(paren
r_int
r_int
)paren
id|bucket
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
op_or
id|SA_IMAP_MASKED
suffix:semicolon
id|action-&gt;dev_id
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We really don&squot;t need these at all on the Sparc.  We only have&n; * stubs here because they are exported to modules.&n; */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|probe_irq_off
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is gets the master TICK_INT timer going. */
DECL|function|init_timers
r_void
id|init_timers
c_func
(paren
r_void
(paren
op_star
id|cfunc
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
op_star
id|clock
)paren
(brace
r_int
r_int
id|pstate
suffix:semicolon
r_extern
r_int
r_int
id|timer_tick_offset
suffix:semicolon
r_int
id|node
comma
id|err
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_extern
r_void
id|smp_tick_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
id|node
op_assign
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
suffix:semicolon
op_star
id|clock
op_assign
id|prom_getint
c_func
(paren
id|node
comma
l_string|&quot;clock-frequency&quot;
)paren
suffix:semicolon
id|timer_tick_offset
op_assign
op_star
id|clock
op_div
id|HZ
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_tick_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Register IRQ handler. */
id|err
op_assign
id|request_irq
c_func
(paren
id|build_irq
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0UL
comma
l_int|0UL
)paren
comma
id|cfunc
comma
(paren
id|SA_INTERRUPT
op_or
id|SA_STATIC_ALLOC
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Serious problem, cannot register TICK_INT&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Guarentee that the following sequences execute&n;&t; * uninterrupted.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %0&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%0, %1, %%pstate&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
multiline_comment|/* Set things up so user can access tick register for profiling&n;&t; * purposes.  Also workaround BB_ERRATA_1 by doing a dummy&n;&t; * read back of %tick after writing it.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|sethi
op_mod
op_mod
id|hi
c_func
(paren
l_int|0x80000000
)paren
comma
op_mod
op_mod
id|g1
id|ba
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|sllx
op_mod
op_mod
id|g1
comma
l_int|32
comma
op_mod
op_mod
id|g1
dot
id|align
l_int|64
l_int|1
suffix:colon
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g2
id|add
op_mod
op_mod
id|g2
comma
l_int|6
comma
op_mod
op_mod
id|g2
id|andn
op_mod
op_mod
id|g2
comma
op_mod
op_mod
id|g1
comma
op_mod
op_mod
id|g2
id|wrpr
op_mod
op_mod
id|g2
comma
l_int|0
comma
op_mod
op_mod
id|tick
id|rdpr
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g0
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
multiline_comment|/* Workaround for Spitfire Errata (#54 I think??), I discovered&n;&t; * this via Sun BugID 4008234, mentioned in Solaris-2.5.1 patch&n;&t; * number 103640.&n;&t; *&n;&t; * On Blackbird writes to %tick_cmpr can fail, the&n;&t; * workaround seems to be to execute the wr instruction&n;&t; * at the start of an I-cache line, and perform a dummy&n;&t; * read back from %tick_cmpr right after writing to it. -DaveM&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g1
id|ba
comma
id|pt
op_mod
op_mod
id|xcc
comma
l_float|1f
id|add
op_mod
op_mod
id|g1
comma
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
dot
id|align
l_int|64
l_int|1
suffix:colon
id|wr
op_mod
op_mod
id|g1
comma
l_int|0x0
comma
op_mod
op_mod
id|tick_cmpr
id|rd
op_mod
op_mod
id|tick_cmpr
comma
op_mod
op_mod
id|g0
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|timer_tick_offset
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
multiline_comment|/* Restore PSTATE_IE. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr&t;%0, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|retarget_one_irq
r_static
r_int
id|retarget_one_irq
c_func
(paren
r_struct
id|irqaction
op_star
id|p
comma
r_int
id|goal_cpu
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|p-&gt;mask
)paren
suffix:semicolon
r_int
r_int
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_int
r_int
id|tid
suffix:semicolon
multiline_comment|/* Never change this, it causes problems on Ex000 systems. */
r_if
c_cond
(paren
id|bucket-&gt;pil
op_eq
l_int|12
)paren
r_return
id|goal_cpu
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
op_eq
l_int|0
)paren
(brace
id|tid
op_assign
id|__cpu_logical_map
(braket
id|goal_cpu
)braket
op_lshift
l_int|26
suffix:semicolon
)brace
r_else
(brace
id|tid
op_assign
(paren
id|starfire_translate
c_func
(paren
id|imap
comma
id|__cpu_logical_map
(braket
id|goal_cpu
)braket
)paren
op_lshift
l_int|26
)paren
suffix:semicolon
)brace
id|upa_writel
c_func
(paren
id|IMAP_VALID
op_or
(paren
id|tid
op_amp
id|IMAP_TID
)paren
comma
id|imap
)paren
suffix:semicolon
id|goal_cpu
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|goal_cpu
op_ge
id|NR_CPUS
op_logical_or
id|__cpu_logical_map
(braket
id|goal_cpu
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|goal_cpu
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|goal_cpu
suffix:semicolon
)brace
multiline_comment|/* Called from request_irq. */
DECL|function|distribute_irqs
r_static
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
comma
id|level
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cpu
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|NR_IRQS
suffix:semicolon
id|level
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|p
op_assign
id|irq_action
(braket
id|level
)braket
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
id|cpu
op_assign
id|retarget_one_irq
c_func
(paren
id|p
comma
id|cpu
)paren
suffix:semicolon
)brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|prom_timers
r_struct
id|sun5_timer
op_star
id|prom_timers
suffix:semicolon
DECL|variable|prom_limit0
DECL|variable|prom_limit1
r_static
id|u64
id|prom_limit0
comma
id|prom_limit1
suffix:semicolon
DECL|function|map_prom_timers
r_static
r_void
id|map_prom_timers
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|tnode
comma
id|err
suffix:semicolon
multiline_comment|/* PROM timer node hangs out in the top level of device siblings... */
id|tnode
op_assign
id|prom_finddevice
c_func
(paren
l_string|&quot;/counter-timer&quot;
)paren
suffix:semicolon
multiline_comment|/* Assume if node is not present, PROM uses different tick mechanism&n;&t; * which we should not care about.&n;&t; */
r_if
c_cond
(paren
id|tnode
op_eq
l_int|0
op_logical_or
id|tnode
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If PROM is really using this, it must be mapped by him. */
id|err
op_assign
id|prom_getproperty
c_func
(paren
id|tnode
comma
l_string|&quot;address&quot;
comma
(paren
r_char
op_star
)paren
id|addr
comma
r_sizeof
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PROM does not have timer mapped, trying to continue.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|kill_prom_timer
r_static
r_void
id|kill_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Save them away for later. */
id|prom_limit0
op_assign
id|prom_timers-&gt;limit0
suffix:semicolon
id|prom_limit1
op_assign
id|prom_timers-&gt;limit1
suffix:semicolon
multiline_comment|/* Just as in sun4c/sun4m PROM uses timer which ticks at IRQ 14.&n;&t; * We turn both off here just to be paranoid.&n;&t; */
id|prom_timers-&gt;limit0
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wheee, eat the interrupt packet too... */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|mov
l_int|0x40
comma
op_mod
op_mod
id|g2
id|ldxa
(braket
op_mod
op_mod
id|g0
)braket
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
id|ldxa
(braket
op_mod
op_mod
id|g2
)braket
op_mod
l_int|1
comma
op_mod
op_mod
id|g1
id|stxa
op_mod
op_mod
id|g0
comma
(braket
op_mod
op_mod
id|g0
)braket
op_mod
l_int|0
id|membar
macro_line|#Sync
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_RECEIVE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_UDB_INTR_R
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
)brace
DECL|function|enable_prom_timer
r_void
id|enable_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Set it to whatever was there before. */
id|prom_timers-&gt;limit1
op_assign
id|prom_limit1
suffix:semicolon
id|prom_timers-&gt;count1
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit0
op_assign
id|prom_limit0
suffix:semicolon
id|prom_timers-&gt;count0
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|called
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|called
op_eq
l_int|0
)paren
(brace
id|called
op_assign
l_int|1
suffix:semicolon
id|map_prom_timers
c_func
(paren
)paren
suffix:semicolon
id|kill_prom_timer
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ivector_table
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ivector_table
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
id|memset
c_func
(paren
op_amp
id|__up_workvec
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|__up_workvec
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* We need to clear any IRQ&squot;s pending in the soft interrupt&n;&t; * registers, a spurious one could be left around from the&n;&t; * PROM timer which we just disabled.&n;&t; */
id|clear_softint
c_func
(paren
id|get_softint
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Now that ivector table is initialized, it is safe&n;&t; * to receive IRQ vector traps.  We will normally take&n;&t; * one or two right now, in case some device PROM used&n;&t; * to boot us wants to speak to us.  We just ignore them.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;or&t;%%g1, %0, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%%g1, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* No outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
)brace
DECL|function|init_irq_proc
r_void
id|init_irq_proc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* For now, nothing... */
)brace
eof
