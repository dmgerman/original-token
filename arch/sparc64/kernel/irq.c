multiline_comment|/* $Id: irq.c,v 1.76 1999/04/02 14:54:30 davem Exp $&n; * irq.c: UltraSparc IRQ handling/init/registry.&n; *&n; * Copyright (C) 1997  David S. Miller  (davem@caip.rutgers.edu)&n; * Copyright (C) 1998  Eddie C. Dost    (ecd@skynet.be)&n; * Copyright (C) 1998  Jakub Jelinek    (jj@ultra.linux.cz)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/random.h&gt; /* XXX ADD add_foo_randomness() calls... -DaveM */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/sbus.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/upa.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#ifdef CONFIG_PCI
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/pbm.h&gt;
macro_line|#endif
multiline_comment|/* Internal flag, should not be visible elsewhere at all. */
DECL|macro|SA_IMAP_MASKED
mdefine_line|#define SA_IMAP_MASKED&t;&t;0x100
DECL|macro|SA_DMA_SYNC
mdefine_line|#define SA_DMA_SYNC&t;&t;0x200
macro_line|#ifdef __SMP__
r_static
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* UPA nodes send interrupt packet to UltraSparc with first data reg&n; * value low 5 (7 on Starfire) bits holding the IRQ identifier being&n; * delivered.  We must translate this into a non-vector IRQ so we can&n; * set the softint on this cpu.&n; *&n; * To make processing these packets efficient and race free we use&n; * an array of irq buckets below.  The interrupt vector handler in&n; * entry.S feeds incoming packets into per-cpu pil-indexed lists.&n; * The IVEC handler does not need to act atomically, the PIL dispatch&n; * code uses CAS to get an atomic snapshot of the list and clear it&n; * at the same time.&n; */
DECL|variable|ivector_table
r_struct
id|ino_bucket
id|ivector_table
(braket
id|NUM_IVECS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifndef __SMP__
DECL|variable|__up_workvec
r_int
r_int
id|__up_workvec
(braket
l_int|16
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|64
)paren
)paren
)paren
suffix:semicolon
DECL|macro|irq_work
mdefine_line|#define irq_work(__cpu, __pil)&t;&amp;(__up_workvec[(__pil)])
macro_line|#else
DECL|macro|irq_work
mdefine_line|#define irq_work(__cpu, __pil)&t;&amp;(cpu_data[(__cpu)].irq_worklists[(__pil)])
macro_line|#endif
multiline_comment|/* This is based upon code in the 32-bit Sparc kernel written mostly by&n; * David Redman (djhr@tadpole.co.uk).&n; */
DECL|macro|MAX_STATIC_ALLOC
mdefine_line|#define MAX_STATIC_ALLOC&t;4
DECL|variable|static_irqaction
r_static
r_struct
id|irqaction
id|static_irqaction
(braket
id|MAX_STATIC_ALLOC
)braket
suffix:semicolon
DECL|variable|static_irq_count
r_static
r_int
id|static_irq_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is exported so that fast IRQ handlers can get at it... -DaveM */
DECL|variable|irq_action
r_struct
id|irqaction
op_star
id|irq_action
(braket
id|NR_IRQS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* Only 8-bits are available, be careful.  -DaveM */
DECL|macro|IBF_DMA_SYNC
mdefine_line|#define IBF_DMA_SYNC&t;0x01&t;/* DMA synchronization behind PCI bridge needed. */
DECL|macro|IBF_PCI
mdefine_line|#define IBF_PCI&t;&t;0x02&t;/* Indicates PSYCHO/SCHIZO PCI interrupt.&t; */
DECL|macro|IBF_ACTIVE
mdefine_line|#define IBF_ACTIVE&t;0x04&t;/* This interrupt is active and has a handler.&t; */
DECL|macro|IBF_MULTI
mdefine_line|#define IBF_MULTI&t;0x08&t;/* On PCI, indicates shared bucket.&t;&t; */
DECL|macro|__bucket
mdefine_line|#define __bucket(irq) ((struct ino_bucket *)(unsigned long)(irq))
DECL|macro|__irq
mdefine_line|#define __irq(bucket) ((unsigned int)(unsigned long)(bucket))
DECL|function|get_irq_list
r_int
id|get_irq_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
macro_line|#ifdef __SMP__
r_int
id|j
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NR_IRQS
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|action
op_assign
op_star
(paren
id|i
op_plus
id|irq_action
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%3d: &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#ifndef __SMP__
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%10u &quot;
comma
id|kstat_irqs
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|smp_num_cpus
suffix:semicolon
id|j
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%10u &quot;
comma
id|kstat.irqs
(braket
id|cpu_logical_map
c_func
(paren
id|j
)paren
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%c %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;,%s %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_string|&quot; +&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* SBUS SYSIO INO number to Sparc PIL level. */
DECL|variable|sysio_ino_to_pil
r_int
r_char
id|sysio_ino_to_pil
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 0 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 1 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 2 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 3 */
l_int|3
comma
multiline_comment|/* Onboard SCSI */
l_int|5
comma
multiline_comment|/* Onboard Ethernet */
multiline_comment|/*XXX*/
l_int|8
comma
multiline_comment|/* Onboard BPP */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|13
comma
multiline_comment|/* Audio */
multiline_comment|/*XXX*/
l_int|15
comma
multiline_comment|/* PowerFail */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|12
comma
multiline_comment|/* Zilog Serial Channels (incl. Keyboard/Mouse lines) */
l_int|11
comma
multiline_comment|/* Floppy */
l_int|0
comma
multiline_comment|/* Spare Hardware (bogon for now) */
l_int|0
comma
multiline_comment|/* Keyboard (bogon for now) */
l_int|0
comma
multiline_comment|/* Mouse (bogon for now) */
l_int|0
comma
multiline_comment|/* Serial (bogon for now) */
l_int|0
comma
l_int|0
comma
multiline_comment|/* Bogon, Bogon */
l_int|10
comma
multiline_comment|/* Timer 0 */
l_int|11
comma
multiline_comment|/* Timer 1 */
l_int|0
comma
l_int|0
comma
multiline_comment|/* Bogon, Bogon */
l_int|15
comma
multiline_comment|/* Uncorrectable SBUS Error */
l_int|15
comma
multiline_comment|/* Correctable SBUS Error */
l_int|15
comma
multiline_comment|/* SBUS Error */
multiline_comment|/*XXX*/
l_int|0
comma
multiline_comment|/* Power Management (bogon for now) */
)brace
suffix:semicolon
multiline_comment|/* INO number to IMAP register offset for SYSIO external IRQ&squot;s.&n; * This should conform to both Sunfire/Wildfire server and Fusion&n; * desktop designs.&n; */
DECL|macro|offset
mdefine_line|#define offset(x) ((unsigned long)(&amp;(((struct sysio_regs *)0)-&gt;x)))
DECL|macro|bogon
mdefine_line|#define bogon     ((unsigned long) -1)
DECL|variable|sysio_irq_offsets
r_static
r_int
r_int
id|sysio_irq_offsets
(braket
)braket
op_assign
(brace
multiline_comment|/* SBUS Slot 0 --&gt; 3, level 1 --&gt; 7 */
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
multiline_comment|/* Onboard devices (not relevant/used on SunFire). */
id|offset
c_func
(paren
id|imap_scsi
)paren
comma
id|offset
c_func
(paren
id|imap_eth
)paren
comma
id|offset
c_func
(paren
id|imap_bpp
)paren
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_audio
)paren
comma
id|offset
c_func
(paren
id|imap_pfail
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_kms
)paren
comma
id|offset
c_func
(paren
id|imap_flpy
)paren
comma
id|offset
c_func
(paren
id|imap_shw
)paren
comma
id|offset
c_func
(paren
id|imap_kbd
)paren
comma
id|offset
c_func
(paren
id|imap_ms
)paren
comma
id|offset
c_func
(paren
id|imap_ser
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_tim0
)paren
comma
id|offset
c_func
(paren
id|imap_tim1
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_ue
)paren
comma
id|offset
c_func
(paren
id|imap_ce
)paren
comma
id|offset
c_func
(paren
id|imap_sberr
)paren
comma
id|offset
c_func
(paren
id|imap_pmgmt
)paren
comma
)brace
suffix:semicolon
DECL|macro|bogon
macro_line|#undef bogon
DECL|macro|NUM_SYSIO_OFFSETS
mdefine_line|#define NUM_SYSIO_OFFSETS (sizeof(sysio_irq_offsets) / sizeof(sysio_irq_offsets[0]))
multiline_comment|/* Convert Interrupt Mapping register pointer to assosciated&n; * Interrupt Clear register pointer, SYSIO specific version.&n; */
DECL|function|sysio_imap_to_iclr
r_static
r_int
r_int
op_star
id|sysio_imap_to_iclr
c_func
(paren
r_int
r_int
op_star
id|imap
)paren
(brace
r_int
r_int
id|diff
suffix:semicolon
id|diff
op_assign
id|offset
c_func
(paren
id|iclr_unused0
)paren
op_minus
id|offset
c_func
(paren
id|imap_slot0
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|imap
)paren
op_plus
id|diff
)paren
suffix:semicolon
)brace
DECL|macro|offset
macro_line|#undef offset
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* PCI PSYCHO INO number to Sparc PIL level. */
DECL|variable|psycho_ino_to_pil
r_int
r_char
id|psycho_ino_to_pil
(braket
)braket
op_assign
(brace
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 0  Int A, B, C, D */
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 1  Int A, B, C, D */
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 2  Int A, B, C, D */
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 3  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 0  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 1  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 2  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 3  Int A, B, C, D */
l_int|3
comma
multiline_comment|/* SCSI */
l_int|5
comma
multiline_comment|/* Ethernet */
l_int|8
comma
multiline_comment|/* Parallel Port */
l_int|13
comma
multiline_comment|/* Audio Record */
l_int|14
comma
multiline_comment|/* Audio Playback */
l_int|15
comma
multiline_comment|/* PowerFail */
l_int|3
comma
multiline_comment|/* second SCSI */
l_int|11
comma
multiline_comment|/* Floppy */
l_int|2
comma
multiline_comment|/* Spare Hardware */
l_int|9
comma
multiline_comment|/* Keyboard */
l_int|4
comma
multiline_comment|/* Mouse */
l_int|12
comma
multiline_comment|/* Serial */
l_int|10
comma
multiline_comment|/* Timer 0 */
l_int|11
comma
multiline_comment|/* Timer 1 */
l_int|15
comma
multiline_comment|/* Uncorrectable ECC */
l_int|15
comma
multiline_comment|/* Correctable ECC */
l_int|15
comma
multiline_comment|/* PCI Bus A Error */
l_int|15
comma
multiline_comment|/* PCI Bus B Error */
l_int|1
comma
multiline_comment|/* Power Management */
)brace
suffix:semicolon
multiline_comment|/* INO number to IMAP register offset for PSYCHO external IRQ&squot;s. */
DECL|macro|psycho_offset
mdefine_line|#define psycho_offset(x) ((unsigned long)(&amp;(((struct psycho_regs *)0)-&gt;x)))
DECL|macro|psycho_imap_offset
mdefine_line|#define psycho_imap_offset(ino)&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;((ino &amp; 0x20) ? (psycho_offset(imap_scsi) + (((ino) &amp; 0x1f) &lt;&lt; 3)) :  &bslash;&n;&t;&t;&t;(psycho_offset(imap_a_slot0) + (((ino) &amp; 0x3c) &lt;&lt; 1)))
DECL|macro|psycho_iclr_offset
mdefine_line|#define psycho_iclr_offset(ino)&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;((ino &amp; 0x20) ? (psycho_offset(iclr_scsi) + (((ino) &amp; 0x1f) &lt;&lt; 3)) :  &bslash;&n;&t;&t;&t;(psycho_offset(iclr_a_slot0[0]) + (((ino) &amp; 0x1f)&lt;&lt;3)))
macro_line|#endif
multiline_comment|/* Now these are always passed a true fully specified sun4u INO. */
DECL|function|enable_irq
r_void
id|enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_extern
r_int
id|this_is_starfire
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
op_star
id|imap
suffix:semicolon
r_int
r_int
id|tid
suffix:semicolon
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|imap
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We set it to our UPA MID. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tid
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_UPA_CONFIG
)paren
)paren
suffix:semicolon
id|tid
op_assign
(paren
(paren
id|tid
op_amp
id|UPA_CONFIG_MID
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
)brace
r_else
(brace
r_extern
r_int
r_int
id|starfire_translate
c_func
(paren
r_int
r_int
op_star
id|imap
comma
r_int
r_int
id|upaid
)paren
suffix:semicolon
id|tid
op_assign
(paren
id|starfire_translate
c_func
(paren
id|imap
comma
id|current-&gt;processor
)paren
op_lshift
l_int|26
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE NOTE NOTE, IGN and INO are read-only, IGN is a product&n;&t; * of this SYSIO&squot;s preconfigured IGN in the SYSIO Control&n;&t; * Register, the hardware just mirrors that value here.&n;&t; * However for Graphics and UPA Slave devices the full&n;&t; * SYSIO_IMAP_INR field can be set by the programmer here.&n;&t; *&n;&t; * Things like FFB can now be handled via the new IRQ mechanism.&n;&t; */
op_star
id|imap
op_assign
id|SYSIO_IMAP_VALID
op_or
(paren
id|tid
op_amp
id|SYSIO_IMAP_TID
)paren
suffix:semicolon
)brace
multiline_comment|/* This now gets passed true ino&squot;s as well. */
DECL|function|disable_irq
r_void
id|disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
op_star
id|imap
suffix:semicolon
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* NOTE: We do not want to futz with the IRQ clear registers&n;&t;&t; *       and move the state to IDLE, the SCSI code does call&n;&t;&t; *       disable_irq() to assure atomicity in the queue cmd&n;&t;&t; *       SCSI adapter driver code.  Thus we&squot;d lose interrupts.&n;&t;&t; */
op_star
id|imap
op_and_assign
op_complement
(paren
id|SYSIO_IMAP_VALID
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The timer is the one &quot;weird&quot; interrupt which is generated by&n; * the CPU %tick register and not by some normal vectored interrupt&n; * source.  To handle this special case, we use this dummy INO bucket.&n; */
DECL|variable|pil0_dummy_bucket
r_static
r_struct
id|ino_bucket
id|pil0_dummy_bucket
op_assign
(brace
l_int|0
comma
multiline_comment|/* irq_chain */
l_int|0
comma
multiline_comment|/* pil */
l_int|0
comma
multiline_comment|/* pending */
l_int|0
comma
multiline_comment|/* flags */
l_int|0
comma
multiline_comment|/* __unused */
l_int|NULL
comma
multiline_comment|/* irq_info */
l_int|NULL
comma
multiline_comment|/* iclr */
l_int|NULL
comma
multiline_comment|/* imap */
)brace
suffix:semicolon
DECL|function|build_irq
r_int
r_int
id|build_irq
c_func
(paren
r_int
id|pil
comma
r_int
id|inofixup
comma
r_int
r_int
op_star
id|iclr
comma
r_int
r_int
op_star
id|imap
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|ino
suffix:semicolon
r_if
c_cond
(paren
id|pil
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|iclr
op_ne
l_int|NULL
op_logical_or
id|imap
op_ne
l_int|NULL
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid dummy bucket for PIL0 (%p:%p)&bslash;n&quot;
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|__irq
c_func
(paren
op_amp
id|pil0_dummy_bucket
)paren
suffix:semicolon
)brace
multiline_comment|/* RULE: Both must be specified in all other cases. */
r_if
c_cond
(paren
id|iclr
op_eq
l_int|NULL
op_logical_or
id|imap
op_eq
l_int|NULL
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid build_irq %d %d %016lx %016lx&bslash;n&quot;
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|ino
op_assign
(paren
op_star
id|imap
op_amp
(paren
id|SYSIO_IMAP_IGN
op_or
id|SYSIO_IMAP_INO
)paren
)paren
op_plus
id|inofixup
suffix:semicolon
r_if
c_cond
(paren
id|ino
OG
id|NUM_IVECS
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid INO %04x (%d:%d:%016lx:%016lx)&bslash;n&quot;
comma
id|ino
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Ok, looks good, set it up.  Don&squot;t touch the irq_chain or&n;&t; * the pending flag.&n;&t; */
id|bucket
op_assign
op_amp
id|ivector_table
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_logical_or
(paren
id|bucket-&gt;irq_info
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* This is a gross fatal error if it happens here. */
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Trying to reinit INO bucket, fatal error.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Request INO %04x (%d:%d:%016lx:%016lx)&bslash;n&quot;
comma
id|ino
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Existing (%d:%016lx:%016lx)&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|bucket-&gt;iclr
comma
id|bucket-&gt;imap
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;IRQ: Cannot continue, halting...&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|bucket-&gt;imap
op_assign
id|imap
suffix:semicolon
id|bucket-&gt;iclr
op_assign
id|iclr
suffix:semicolon
id|bucket-&gt;pil
op_assign
id|pil
suffix:semicolon
id|bucket-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
l_int|NULL
suffix:semicolon
r_return
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
)brace
DECL|function|sbus_build_irq
r_int
r_int
id|sbus_build_irq
c_func
(paren
r_void
op_star
id|buscookie
comma
r_int
r_int
id|ino
)paren
(brace
r_struct
id|linux_sbus
op_star
id|sbus
op_assign
(paren
r_struct
id|linux_sbus
op_star
)paren
id|buscookie
suffix:semicolon
r_struct
id|sysio_regs
op_star
id|sregs
op_assign
id|sbus-&gt;iommu-&gt;sysio_regs
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|pil
suffix:semicolon
r_int
r_int
op_star
id|imap
comma
op_star
id|iclr
suffix:semicolon
r_int
id|sbus_level
op_assign
l_int|0
suffix:semicolon
id|pil
op_assign
id|sysio_ino_to_pil
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pil
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_irq_build: Bad SYSIO INO[%x]&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Bad SYSIO IRQ translations...&quot;
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|sysio_irq_offsets
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
(paren
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;get_irq_translations: Bad SYSIO INO[%x] cpu[%d]&bslash;n&quot;
comma
id|ino
comma
id|pil
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;BAD SYSIO IRQ offset...&quot;
)paren
suffix:semicolon
)brace
id|offset
op_add_assign
(paren
(paren
r_int
r_int
)paren
id|sregs
)paren
suffix:semicolon
id|imap
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|offset
)paren
suffix:semicolon
multiline_comment|/* SYSIO inconsistancy.  For external SLOTS, we have to select&n;&t; * the right ICLR register based upon the lower SBUS irq level&n;&t; * bits.&n;&t; */
r_if
c_cond
(paren
id|ino
op_ge
l_int|0x20
)paren
(brace
id|iclr
op_assign
id|sysio_imap_to_iclr
c_func
(paren
id|imap
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|iclraddr
suffix:semicolon
r_int
id|sbus_slot
op_assign
(paren
id|ino
op_amp
l_int|0x18
)paren
op_rshift
l_int|3
suffix:semicolon
id|sbus_level
op_assign
id|ino
op_amp
l_int|0x7
suffix:semicolon
r_switch
c_cond
(paren
id|sbus_slot
)paren
(brace
r_case
l_int|0
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|3
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot3
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|iclraddr
op_assign
(paren
r_int
r_int
)paren
id|iclr
suffix:semicolon
id|iclraddr
op_add_assign
(paren
(paren
id|sbus_level
op_minus
l_int|1
)paren
op_star
l_int|8
)paren
suffix:semicolon
id|iclr
op_assign
(paren
r_int
r_int
op_star
)paren
id|iclraddr
suffix:semicolon
)brace
r_return
id|build_irq
c_func
(paren
id|pil
comma
id|sbus_level
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
DECL|function|psycho_build_irq
r_int
r_int
id|psycho_build_irq
c_func
(paren
r_void
op_star
id|buscookie
comma
r_int
id|imap_off
comma
r_int
id|ino
comma
r_int
id|need_dma_sync
)paren
(brace
r_struct
id|linux_psycho
op_star
id|psycho
op_assign
(paren
r_struct
id|linux_psycho
op_star
)paren
id|buscookie
suffix:semicolon
r_struct
id|psycho_regs
op_star
id|pregs
op_assign
id|psycho-&gt;psycho_regs
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|pil
suffix:semicolon
r_int
r_int
op_star
id|imap
comma
op_star
id|iclr
suffix:semicolon
r_int
id|inofixup
op_assign
l_int|0
suffix:semicolon
id|pil
op_assign
id|psycho_ino_to_pil
(braket
id|ino
op_amp
id|PCI_IRQ_INO
)braket
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
op_amp
id|pregs-&gt;imap_a_slot0
suffix:semicolon
id|addr
op_assign
id|addr
op_plus
id|imap_off
suffix:semicolon
id|imap
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
op_plus
l_int|1
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|pregs
suffix:semicolon
id|addr
op_add_assign
id|psycho_iclr_offset
c_func
(paren
id|ino
op_amp
(paren
id|PCI_IRQ_INO
)paren
)paren
suffix:semicolon
id|iclr
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ino
op_amp
l_int|0x20
)paren
)paren
(brace
id|inofixup
op_assign
id|ino
op_amp
l_int|0x03
suffix:semicolon
)brace
multiline_comment|/* First check for sharing. */
id|ino
op_assign
(paren
op_star
id|imap
op_amp
(paren
id|SYSIO_IMAP_IGN
op_or
id|SYSIO_IMAP_INO
)paren
)paren
op_plus
id|inofixup
suffix:semicolon
r_if
c_cond
(paren
id|ino
OG
id|NUM_IVECS
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PSYCHO: Invalid INO %04x (%d:%d:%016lx:%016lx)&bslash;n&quot;
comma
id|ino
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|bucket
op_assign
op_amp
id|ivector_table
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bucket-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
(brace
r_void
op_star
id|old_handler
op_assign
id|bucket-&gt;irq_info
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|old_handler
op_eq
l_int|NULL
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PSYCHO: Active bucket, but no handler.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_eq
l_int|0
)paren
(brace
r_void
op_star
op_star
id|vector
suffix:semicolon
id|vector
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* We might have slept. */
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|vector
)paren
suffix:semicolon
)brace
r_else
(brace
id|vector
(braket
l_int|0
)braket
op_assign
id|old_handler
suffix:semicolon
id|vector
(braket
l_int|1
)braket
op_assign
id|vector
(braket
l_int|2
)braket
op_assign
id|vector
(braket
l_int|3
)braket
op_assign
l_int|NULL
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
id|vector
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_MULTI
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Just init the bucket */
id|bucket
op_assign
id|__bucket
c_func
(paren
id|build_irq
c_func
(paren
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_dma_sync
)paren
id|bucket-&gt;flags
op_or_assign
id|IBF_DMA_SYNC
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_PCI
suffix:semicolon
r_return
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|atomic_bucket_insert
r_static
r_void
id|atomic_bucket_insert
c_func
(paren
r_struct
id|ino_bucket
op_star
id|bucket
)paren
(brace
r_int
r_int
id|pstate
suffix:semicolon
r_int
r_int
op_star
id|ent
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr %%pstate, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, %1, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
)paren
suffix:semicolon
id|ent
op_assign
id|irq_work
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
id|bucket-&gt;irq_chain
op_assign
op_star
id|ent
suffix:semicolon
op_star
id|ent
op_assign
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wrpr %0, 0x0, %%pstate&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|pstate
)paren
)paren
suffix:semicolon
)brace
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pending
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;request_irq: Old style IRQ registry attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bucket-&gt;pil
)paren
id|irqflags
op_and_assign
op_complement
id|SA_IMAP_MASKED
suffix:semicolon
r_else
(brace
id|irqflags
op_or_assign
id|SA_IMAP_MASKED
suffix:semicolon
r_if
c_cond
(paren
id|bucket-&gt;flags
op_amp
id|IBF_PCI
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * PCI IRQs should never use SA_INTERRUPT.&n;&t;&t;&t; */
id|irqflags
op_and_assign
op_complement
(paren
id|SA_INTERRUPT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check wether we _should_ use DMA Write Sync&n;&t;&t;&t; * (for devices behind bridges behind APB). &n;&t;&t;&t; *&n;&t;&t;&t; * XXX: Not implemented, yet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bucket-&gt;flags
op_amp
id|IBF_DMA_SYNC
)paren
id|irqflags
op_or_assign
id|SA_DMA_SYNC
suffix:semicolon
)brace
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
op_logical_and
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
)paren
r_for
c_loop
(paren
id|tmp
op_assign
id|action
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
suffix:semicolon
r_else
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
op_xor
(paren
id|irqflags
op_amp
id|SA_INTERRUPT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to mix fast and slow interrupts on IRQ%d &quot;
l_string|&quot;denied&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Or else! */
)brace
multiline_comment|/* If this is flagged as statically allocated then we use our&n;&t; * private struct which is never freed.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
(brace
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|irq
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|irqflags
op_amp
id|SA_IMAP_MASKED
)paren
op_eq
l_int|0
)paren
(brace
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
r_void
op_star
id|orig
op_assign
id|bucket-&gt;irq_info
suffix:semicolon
r_void
op_star
op_star
id|vector
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_PCI
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRQ: Trying to share non-PCI bucket.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_eq
l_int|0
)paren
(brace
id|vector
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
op_eq
l_int|NULL
)paren
(brace
r_goto
id|free_and_enomem
suffix:semicolon
)brace
multiline_comment|/* We might have slept. */
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|ent
suffix:semicolon
id|kfree
c_func
(paren
id|vector
)paren
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|bucket-&gt;irq_info
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
l_int|NULL
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
id|action
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ent
op_eq
l_int|4
)paren
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
r_else
(brace
id|vector
(braket
l_int|0
)braket
op_assign
id|orig
suffix:semicolon
id|vector
(braket
l_int|1
)braket
op_assign
id|action
suffix:semicolon
id|vector
(braket
l_int|2
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vector
(braket
l_int|3
)braket
op_assign
l_int|NULL
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
id|vector
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_MULTI
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|ent
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|orig
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
l_int|NULL
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
id|action
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ent
op_eq
l_int|4
)paren
r_goto
id|free_and_ebusy
suffix:semicolon
)brace
)brace
r_else
(brace
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
)brace
id|pending
op_assign
id|bucket-&gt;pending
suffix:semicolon
r_if
c_cond
(paren
id|pending
)paren
(brace
id|bucket-&gt;pending
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|action-&gt;mask
op_assign
(paren
r_int
r_int
)paren
id|bucket
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action
suffix:semicolon
)brace
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* We ate the IVEC already, this makes sure it does not get lost. */
r_if
c_cond
(paren
id|pending
)paren
(brace
id|atomic_bucket_insert
c_func
(paren
id|bucket
)paren
suffix:semicolon
id|set_softint
c_func
(paren
l_int|1
op_lshift
id|bucket-&gt;pil
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|free_and_ebusy
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
id|free_and_enomem
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|irqaction
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
comma
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket
op_ne
op_amp
id|pil0_dummy_bucket
)paren
op_logical_and
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;free_irq: Old style IRQ removal attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing free IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_id
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_eq
id|dev_id
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|action
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free shared IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free shared IRQ %d with NULL device ID&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to free statically allocated IRQ %d (%s)&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|action-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_logical_and
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
r_int
r_int
op_star
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_void
op_star
op_star
id|vector
comma
op_star
id|orig
suffix:semicolon
r_int
id|ent
suffix:semicolon
id|orig
op_assign
id|bucket-&gt;irq_info
suffix:semicolon
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|orig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bucket-&gt;flags
op_amp
id|IBF_MULTI
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|other
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|orphan
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_eq
id|action
)paren
(brace
id|vector
(braket
id|ent
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vector
(braket
id|ent
)braket
op_ne
l_int|NULL
)paren
(brace
id|orphan
op_assign
id|vector
(braket
id|ent
)braket
suffix:semicolon
id|other
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Only free when no other shared irq&n;&t;&t;&t; * uses this bucket.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|other
)paren
(brace
r_if
c_cond
(paren
id|other
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Convert back to non-shared bucket. */
id|bucket-&gt;irq_info
op_assign
id|orphan
suffix:semicolon
id|bucket-&gt;flags
op_and_assign
op_complement
(paren
id|IBF_MULTI
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vector
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|bucket-&gt;irq_info
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This unique interrupt source is now inactive. */
id|bucket-&gt;flags
op_and_assign
op_complement
id|IBF_ACTIVE
suffix:semicolon
multiline_comment|/* See if any other buckets share this bucket&squot;s IMAP&n;&t;&t; * and are still active.&n;&t;&t; */
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
id|NUM_IVECS
suffix:semicolon
id|ent
op_increment
)paren
(brace
id|bp
op_assign
op_amp
id|ivector_table
(braket
id|ent
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
id|bucket
op_logical_and
id|bp-&gt;imap
op_eq
id|imap
op_logical_and
(paren
id|bp-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Only disable when no other sub-irq levels of&n;&t;&t; * the same IMAP are active.&n;&t;&t; */
r_if
c_cond
(paren
id|ent
op_eq
id|NUM_IVECS
)paren
id|disable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Only uniprocessor needs this IRQ/BH locking depth, on SMP it&n; * lives in the per-cpu structure for cache reasons.&n; */
macro_line|#ifndef __SMP__
DECL|variable|local_irq_count
r_int
r_int
id|local_irq_count
suffix:semicolon
DECL|variable|local_bh_count
r_int
r_int
id|local_bh_count
suffix:semicolon
DECL|macro|irq_enter
mdefine_line|#define irq_enter(cpu, irq)&t;(local_irq_count++)
DECL|macro|irq_exit
mdefine_line|#define irq_exit(cpu, irq)&t;(local_irq_count--)
macro_line|#else
DECL|variable|global_bh_lock
id|atomic_t
id|global_bh_lock
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|global_bh_count
id|spinlock_t
id|global_bh_count
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Who has global_irq_lock. */
DECL|variable|global_irq_holder
r_int
r_char
id|global_irq_holder
op_assign
id|NO_PROC_ID
suffix:semicolon
multiline_comment|/* This protects IRQ&squot;s. */
DECL|variable|global_irq_lock
id|spinlock_t
id|global_irq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Global IRQ locking depth. */
DECL|variable|global_irq_count
id|atomic_t
id|global_irq_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|macro|irq_enter
mdefine_line|#define irq_enter(cpu, irq)&t;&t;&t;&bslash;&n;do {&t;hardirq_enter(cpu);&t;&t;&t;&bslash;&n;&t;spin_unlock_wait(&amp;global_irq_lock);&t;&bslash;&n;} while(0)
DECL|macro|irq_exit
mdefine_line|#define irq_exit(cpu, irq)&t;hardirq_exit(cpu)
DECL|function|show
r_static
r_void
id|show
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s, CPU %d:&bslash;n&quot;
comma
id|str
comma
id|cpu
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq:  %d [%ld %ld]&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|global_irq_count
)paren
comma
id|cpu_data
(braket
l_int|0
)braket
dot
id|irq_count
comma
id|cpu_data
(braket
l_int|1
)braket
dot
id|irq_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bh:   %d [%ld %ld]&bslash;n&quot;
comma
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_count
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
id|cpu_data
(braket
l_int|0
)braket
dot
id|bh_count
comma
id|cpu_data
(braket
l_int|1
)braket
dot
id|bh_count
)paren
suffix:semicolon
)brace
DECL|macro|MAXCOUNT
mdefine_line|#define MAXCOUNT 100000000
DECL|function|wait_on_bh
r_static
r_inline
r_void
id|wait_on_bh
c_func
(paren
r_void
)paren
(brace
r_int
id|count
op_assign
id|MAXCOUNT
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
(brace
id|show
c_func
(paren
l_string|&quot;wait_on_bh&quot;
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
)brace
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_count
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|macro|SYNC_OTHER_ULTRAS
mdefine_line|#define SYNC_OTHER_ULTRAS(x)&t;udelay(x+1)
DECL|function|wait_on_irq
r_static
r_inline
r_void
id|wait_on_irq
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|count
op_assign
id|MAXCOUNT
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
(paren
op_amp
id|global_irq_count
)paren
)paren
(brace
r_if
c_cond
(paren
id|local_bh_count
op_logical_or
op_logical_neg
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_count
)paren
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|global_irq_lock
)paren
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad | #StoreStore&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
(brace
id|show
c_func
(paren
l_string|&quot;wait_on_irq&quot;
)paren
suffix:semicolon
id|count
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|SYNC_OTHER_ULTRAS
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|global_irq_count
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|spin_is_locked
(paren
op_amp
id|global_irq_lock
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_bh_count
op_logical_and
id|spin_is_locked
(paren
op_amp
id|global_bh_count
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|synchronize_bh
r_void
id|synchronize_bh
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|spin_is_locked
(paren
op_amp
id|global_bh_count
)paren
op_logical_and
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
id|wait_on_bh
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|synchronize_irq
r_void
id|synchronize_irq
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|global_irq_count
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_irqlock
r_static
r_inline
r_void
id|get_irqlock
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|cpu
op_eq
id|global_irq_holder
)paren
r_return
suffix:semicolon
r_do
(brace
r_while
c_loop
(paren
id|spin_is_locked
(paren
op_amp
id|global_irq_lock
)paren
)paren
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
id|wait_on_irq
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|global_irq_holder
op_assign
id|cpu
suffix:semicolon
)brace
DECL|function|__global_cli
r_void
id|__global_cli
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
)paren
id|get_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|__global_sti
r_void
id|__global_sti
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
)paren
id|release_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|__global_save_flags
r_int
r_int
id|__global_save_flags
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
comma
id|local_enabled
comma
id|retval
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_enabled
op_assign
(paren
(paren
id|flags
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
l_int|2
op_plus
id|local_enabled
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
)paren
(brace
r_if
c_cond
(paren
id|local_enabled
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|global_irq_holder
op_eq
(paren
r_int
r_char
)paren
id|smp_processor_id
c_func
(paren
)paren
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|__global_restore_flags
r_void
id|__global_restore_flags
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
l_int|0
suffix:colon
id|__global_cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|__global_sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|__sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
(brace
r_int
r_int
id|pc
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pc
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;global_restore_flags: Bogon flags(%016lx) caller %016lx&bslash;n&quot;
comma
id|flags
comma
id|pc
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* __SMP__ */
DECL|function|catch_disabled_ivec
r_void
id|catch_disabled_ivec
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
op_star
id|irq_work
c_func
(paren
id|cpu
comma
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* We can actually see this on Ultra/PCI PCI cards, which are bridges&n;&t; * to other devices.  Here a single IMAP enabled potentially multiple&n;&t; * unique interrupt sources (which each do have a unique ICLR register.&n;&t; *&n;&t; * So what we do is just register that the IVEC arrived, when registered&n;&t; * for real the request_irq() code will check the bit and signal&n;&t; * a local CPU interrupt for it.&n;&t; */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;IVEC: Spurious interrupt vector (%x) received at (%016lx)&bslash;n&quot;
comma
id|bucket
op_minus
op_amp
id|ivector_table
(braket
l_int|0
)braket
comma
id|regs-&gt;tpc
)paren
suffix:semicolon
macro_line|#endif
op_star
id|irq_work
c_func
(paren
id|cpu
comma
l_int|0
)paren
op_assign
l_int|0
suffix:semicolon
id|bucket-&gt;pending
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Tune this... */
DECL|macro|FORWARD_VOLUME
mdefine_line|#define FORWARD_VOLUME&t;&t;12
DECL|function|handler_irq
r_void
id|handler_irq
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bp
comma
op_star
id|nbp
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
r_extern
r_int
id|this_is_starfire
suffix:semicolon
r_int
id|should_forward
op_assign
(paren
id|this_is_starfire
op_eq
l_int|0
op_logical_and
id|irq
OL
l_int|10
op_logical_and
id|current-&gt;pid
op_ne
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|buddy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &squot;cpu&squot; is the MID (ie. UPAID), calculate the MID&n;&t; * of our buddy.&n;&t; */
r_if
c_cond
(paren
id|should_forward
op_ne
l_int|0
)paren
(brace
id|buddy
op_assign
id|cpu_number_map
(braket
id|cpu
)braket
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|buddy
op_ge
id|NR_CPUS
op_logical_or
(paren
id|buddy
op_assign
id|cpu_logical_map
c_func
(paren
id|buddy
)paren
)paren
op_eq
op_minus
l_int|1
)paren
id|buddy
op_assign
id|cpu_logical_map
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Voo-doo programming. */
r_if
c_cond
(paren
id|cpu_data
(braket
id|buddy
)braket
dot
id|idle_volume
OL
id|FORWARD_VOLUME
)paren
(brace
id|should_forward
op_assign
l_int|0
suffix:semicolon
)brace
id|buddy
op_lshift_assign
l_int|26
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef __SMP__
multiline_comment|/*&n;&t; * Check for TICK_INT on level 14 softint.&n;&t; */
r_if
c_cond
(paren
(paren
id|irq
op_eq
l_int|14
)paren
op_logical_and
(paren
id|get_softint
c_func
(paren
)paren
op_amp
(paren
l_int|1UL
op_lshift
l_int|0
)paren
)paren
)paren
id|irq
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
multiline_comment|/* Sliiiick... */
macro_line|#ifndef __SMP__
id|bp
op_assign
(paren
(paren
id|irq
op_ne
l_int|0
)paren
ques
c_cond
id|__bucket
c_func
(paren
id|xchg32
c_func
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
comma
l_int|0
)paren
)paren
suffix:colon
op_amp
id|pil0_dummy_bucket
)paren
suffix:semicolon
macro_line|#else
id|bp
op_assign
id|__bucket
c_func
(paren
id|xchg32
c_func
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
comma
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
id|bp
op_ne
l_int|NULL
suffix:semicolon
id|bp
op_assign
id|nbp
)paren
(brace
r_int
r_char
id|flags
op_assign
id|bp-&gt;flags
suffix:semicolon
id|nbp
op_assign
id|__bucket
c_func
(paren
id|bp-&gt;irq_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IBF_MULTI
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|irqaction
op_star
id|ap
op_assign
id|bp-&gt;irq_info
suffix:semicolon
id|ap
op_member_access_from_pointer
id|handler
c_func
(paren
id|__irq
c_func
(paren
id|bp
)paren
comma
id|ap-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
r_void
op_star
op_star
id|vector
op_assign
(paren
r_void
op_star
op_star
)paren
id|bp-&gt;irq_info
suffix:semicolon
r_int
id|ent
suffix:semicolon
r_for
c_loop
(paren
id|ent
op_assign
l_int|0
suffix:semicolon
id|ent
OL
l_int|4
suffix:semicolon
id|ent
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|ap
op_assign
id|vector
(braket
id|ent
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_ne
l_int|NULL
)paren
(brace
id|ap
op_member_access_from_pointer
id|handler
c_func
(paren
id|__irq
c_func
(paren
id|bp
)paren
comma
id|ap-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Only the dummy bucket lacks IMAP/ICLR. */
r_if
c_cond
(paren
id|bp-&gt;pil
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef __SMP__
multiline_comment|/* Ok, here is what is going on:&n;&t;&t;&t;&t; * 1) Retargeting IRQs on Starfire is very&n;&t;&t;&t;&t; *    expensive so just forget about it on them.&n;&t;&t;&t;&t; * 2) Moving around very high priority interrupts&n;&t;&t;&t;&t; *    is a losing game.&n;&t;&t;&t;&t; * 3) If the current cpu is idle, interrupts are&n;&t;&t;&t;&t; *    useful work, so keep them here.  But do not&n;&t;&t;&t;&t; *    pass to our neighbour if he is not very idle.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|should_forward
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Push it to our buddy. */
id|should_forward
op_assign
l_int|0
suffix:semicolon
op_star
(paren
id|bp-&gt;imap
)paren
op_assign
(paren
id|buddy
op_or
id|SYSIO_IMAP_VALID
)paren
suffix:semicolon
)brace
macro_line|#endif
op_star
(paren
id|bp-&gt;iclr
)paren
op_assign
id|SYSIO_ICLR_IDLE
suffix:semicolon
)brace
)brace
r_else
id|bp-&gt;pending
op_assign
l_int|1
suffix:semicolon
)brace
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_FD
r_extern
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|sparc_floppy_irq
r_void
id|sparc_floppy_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
op_star
(paren
id|irq_work
c_func
(paren
id|cpu
comma
id|irq
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|bucket
op_assign
(paren
r_struct
id|ino_bucket
op_star
)paren
id|action-&gt;mask
suffix:semicolon
id|floppy_interrupt
c_func
(paren
id|irq
comma
id|dev_cookie
comma
id|regs
)paren
suffix:semicolon
op_star
(paren
id|bucket-&gt;iclr
)paren
op_assign
id|SYSIO_ICLR_IDLE
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* The following assumes that the branch lies before the place we&n; * are branching to.  This is the case for a trap vector...&n; * You have been warned.&n; */
DECL|macro|SPARC_BRANCH
mdefine_line|#define SPARC_BRANCH(dest_addr, inst_addr) &bslash;&n;          (0x10800000 | ((((dest_addr)-(inst_addr))&gt;&gt;2)&amp;0x3fffff))
DECL|macro|SPARC_NOP
mdefine_line|#define SPARC_NOP (0x01000000)
DECL|function|install_fast_irq
r_static
r_void
id|install_fast_irq
c_func
(paren
r_int
r_int
id|cpu_irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_extern
r_int
r_int
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
id|ttent
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
op_star
id|insns
suffix:semicolon
id|ttent
op_add_assign
l_int|0x820
suffix:semicolon
id|ttent
op_add_assign
(paren
id|cpu_irq
op_minus
l_int|1
)paren
op_lshift
l_int|5
suffix:semicolon
id|insns
op_assign
(paren
r_int
r_int
op_star
)paren
id|ttent
suffix:semicolon
id|insns
(braket
l_int|0
)braket
op_assign
id|SPARC_BRANCH
c_func
(paren
(paren
(paren
r_int
r_int
)paren
id|handler
)paren
comma
(paren
(paren
r_int
r_int
)paren
op_amp
id|insns
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|insns
(braket
l_int|1
)braket
op_assign
id|SPARC_NOP
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;membar #StoreStore; flush %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|ttent
)paren
)paren
suffix:semicolon
)brace
DECL|function|request_fast_irq
r_int
id|request_fast_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* No pil0 dummy buckets allowed here. */
r_if
c_cond
(paren
id|bucket
OL
op_amp
id|ivector_table
(braket
l_int|0
)braket
op_logical_or
id|bucket
op_ge
op_amp
id|ivector_table
(braket
id|NUM_IVECS
)braket
)paren
(brace
r_int
r_int
op_star
id|caller
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|caller
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;request_fast_irq: Old style IRQ registry attempt &quot;
l_string|&quot;from %p, irq %08x.&bslash;n&quot;
comma
id|caller
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Only IMAP style interrupts can be registered as fast. */
r_if
c_cond
(paren
id|bucket-&gt;pil
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;pil
op_eq
l_int|0
)paren
op_logical_or
(paren
id|bucket-&gt;pil
op_eq
l_int|14
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register shared IRQ 0 or 14.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq when already shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq as shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register yet already owned.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
(brace
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|install_fast_irq
c_func
(paren
id|bucket-&gt;pil
comma
id|handler
)paren
suffix:semicolon
id|bucket-&gt;irq_info
op_assign
id|action
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
id|action-&gt;mask
op_assign
(paren
r_int
r_int
)paren
id|bucket
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
op_or
id|SA_IMAP_MASKED
suffix:semicolon
id|action-&gt;dev_id
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We really don&squot;t need these at all on the Sparc.  We only have&n; * stubs here because they are exported to modules.&n; */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|probe_irq_off
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is gets the master TICK_INT timer going. */
DECL|function|init_timers
r_void
id|init_timers
c_func
(paren
r_void
(paren
op_star
id|cfunc
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
op_star
id|clock
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_extern
r_int
r_int
id|timer_tick_offset
suffix:semicolon
r_int
id|node
comma
id|err
suffix:semicolon
macro_line|#ifdef __SMP__
r_extern
r_void
id|smp_tick_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
id|node
op_assign
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
suffix:semicolon
op_star
id|clock
op_assign
id|prom_getint
c_func
(paren
id|node
comma
l_string|&quot;clock-frequency&quot;
)paren
suffix:semicolon
id|timer_tick_offset
op_assign
op_star
id|clock
op_div
id|HZ
suffix:semicolon
macro_line|#ifdef __SMP__
id|smp_tick_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Register IRQ handler. */
id|err
op_assign
id|request_irq
c_func
(paren
id|build_irq
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
comma
id|cfunc
comma
(paren
id|SA_INTERRUPT
op_or
id|SA_STATIC_ALLOC
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Serious problem, cannot register TICK_INT&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Set things up so user can access tick register for profiling&n;&t; * purposes.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|sethi
op_mod
op_mod
id|hi
c_func
(paren
l_int|0x80000000
)paren
comma
op_mod
op_mod
id|g1
id|sllx
op_mod
op_mod
id|g1
comma
l_int|32
comma
op_mod
op_mod
id|g1
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g2
id|add
op_mod
op_mod
id|g2
comma
l_int|6
comma
op_mod
op_mod
id|g2
id|andn
op_mod
op_mod
id|g2
comma
op_mod
op_mod
id|g1
comma
op_mod
op_mod
id|g2
id|wrpr
op_mod
op_mod
id|g2
comma
l_int|0
comma
op_mod
op_mod
id|tick
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g1
id|add
op_mod
op_mod
id|g1
comma
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
id|wr
op_mod
op_mod
id|g1
comma
l_int|0x0
comma
op_mod
op_mod
id|tick_cmpr
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|timer_tick_offset
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef __SMP__
DECL|function|retarget_one_irq
r_static
r_int
id|retarget_one_irq
c_func
(paren
r_struct
id|irqaction
op_star
id|p
comma
r_int
id|goal_cpu
)paren
(brace
r_extern
r_int
id|this_is_starfire
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|p-&gt;mask
)paren
suffix:semicolon
r_int
r_int
op_star
id|imap
op_assign
id|bucket-&gt;imap
suffix:semicolon
r_int
r_int
id|tid
suffix:semicolon
multiline_comment|/* Never change this, it causes problems on Ex000 systems. */
r_if
c_cond
(paren
id|bucket-&gt;pil
op_eq
l_int|12
)paren
r_return
id|goal_cpu
suffix:semicolon
r_if
c_cond
(paren
id|this_is_starfire
op_eq
l_int|0
)paren
(brace
id|tid
op_assign
id|__cpu_logical_map
(braket
id|goal_cpu
)braket
op_lshift
l_int|26
suffix:semicolon
)brace
r_else
(brace
r_extern
r_int
r_int
id|starfire_translate
c_func
(paren
r_int
r_int
op_star
id|imap
comma
r_int
r_int
id|upaid
)paren
suffix:semicolon
id|tid
op_assign
(paren
id|starfire_translate
c_func
(paren
id|imap
comma
id|__cpu_logical_map
(braket
id|goal_cpu
)braket
)paren
op_lshift
l_int|26
)paren
suffix:semicolon
)brace
op_star
id|imap
op_assign
id|SYSIO_IMAP_VALID
op_or
(paren
id|tid
op_amp
id|SYSIO_IMAP_TID
)paren
suffix:semicolon
id|goal_cpu
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|goal_cpu
op_ge
id|NR_CPUS
op_logical_or
id|__cpu_logical_map
(braket
id|goal_cpu
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|goal_cpu
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|goal_cpu
suffix:semicolon
)brace
multiline_comment|/* Called from request_irq. */
DECL|function|distribute_irqs
r_static
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
comma
id|level
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cpu
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|NR_IRQS
suffix:semicolon
id|level
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|p
op_assign
id|irq_action
(braket
id|level
)braket
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
id|cpu
op_assign
id|retarget_one_irq
c_func
(paren
id|p
comma
id|cpu
)paren
suffix:semicolon
)brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|prom_timers
r_struct
id|sun5_timer
op_star
id|prom_timers
suffix:semicolon
DECL|variable|prom_limit0
DECL|variable|prom_limit1
r_static
id|u64
id|prom_limit0
comma
id|prom_limit1
suffix:semicolon
DECL|function|map_prom_timers
r_static
r_void
id|map_prom_timers
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|tnode
comma
id|err
suffix:semicolon
multiline_comment|/* PROM timer node hangs out in the top level of device siblings... */
id|tnode
op_assign
id|prom_finddevice
c_func
(paren
l_string|&quot;/counter-timer&quot;
)paren
suffix:semicolon
multiline_comment|/* Assume if node is not present, PROM uses different tick mechanism&n;&t; * which we should not care about.&n;&t; */
r_if
c_cond
(paren
id|tnode
op_eq
l_int|0
op_logical_or
id|tnode
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If PROM is really using this, it must be mapped by him. */
id|err
op_assign
id|prom_getproperty
c_func
(paren
id|tnode
comma
l_string|&quot;address&quot;
comma
(paren
r_char
op_star
)paren
id|addr
comma
r_sizeof
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PROM does not have timer mapped, trying to continue.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|kill_prom_timer
r_static
r_void
id|kill_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Save them away for later. */
id|prom_limit0
op_assign
id|prom_timers-&gt;limit0
suffix:semicolon
id|prom_limit1
op_assign
id|prom_timers-&gt;limit1
suffix:semicolon
multiline_comment|/* Just as in sun4c/sun4m PROM uses timer which ticks at IRQ 14.&n;&t; * We turn both off here just to be paranoid.&n;&t; */
id|prom_timers-&gt;limit0
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wheee, eat the interrupt packet too... */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|mov
l_int|0x40
comma
op_mod
op_mod
id|g2
id|ldxa
(braket
op_mod
op_mod
id|g0
)braket
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
id|ldxa
(braket
op_mod
op_mod
id|g2
)braket
op_mod
l_int|1
comma
op_mod
op_mod
id|g1
id|stxa
op_mod
op_mod
id|g0
comma
(braket
op_mod
op_mod
id|g0
)braket
op_mod
l_int|0
id|membar
macro_line|#Sync
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_RECEIVE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_UDB_INTR_R
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
)brace
DECL|function|enable_prom_timer
r_void
id|enable_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Set it to whatever was there before. */
id|prom_timers-&gt;limit1
op_assign
id|prom_limit1
suffix:semicolon
id|prom_timers-&gt;count1
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit0
op_assign
id|prom_limit0
suffix:semicolon
id|prom_timers-&gt;count0
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|init_IRQ
c_func
(paren
r_void
)paren
)paren
(brace
r_static
r_int
id|called
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|called
op_eq
l_int|0
)paren
(brace
id|called
op_assign
l_int|1
suffix:semicolon
id|map_prom_timers
c_func
(paren
)paren
suffix:semicolon
id|kill_prom_timer
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ivector_table
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ivector_table
)paren
)paren
suffix:semicolon
macro_line|#ifndef __SMP__
id|memset
c_func
(paren
op_amp
id|__up_workvec
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|__up_workvec
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* We need to clear any IRQ&squot;s pending in the soft interrupt&n;&t; * registers, a spurious one could be left around from the&n;&t; * PROM timer which we just disabled.&n;&t; */
id|clear_softint
c_func
(paren
id|get_softint
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Now that ivector table is initialized, it is safe&n;&t; * to receive IRQ vector traps.  We will normally take&n;&t; * one or two right now, in case some device PROM used&n;&t; * to boot us wants to speak to us.  We just ignore them.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;or&t;%%g1, %0, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%%g1, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* No outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
)brace
eof
