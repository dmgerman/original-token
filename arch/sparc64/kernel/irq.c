multiline_comment|/* $Id: irq.c,v 1.61 1998/08/02 14:51:38 ecd Exp $&n; * irq.c: UltraSparc IRQ handling/init/registry.&n; *&n; * Copyright (C) 1997  David S. Miller  (davem@caip.rutgers.edu)&n; * Copyright (C) 1998  Eddie C. Dost    (ecd@skynet.be)&n; * Copyright (C) 1998  Jakub Jelinek    (jj@ultra.linux.cz)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/random.h&gt; /* XXX ADD add_foo_randomness() calls... -DaveM */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/sbus.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/upa.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#ifdef CONFIG_PCI
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/pbm.h&gt;
macro_line|#endif
multiline_comment|/* Internal flag, should not be visible elsewhere at all. */
DECL|macro|SA_IMAP_MASKED
mdefine_line|#define SA_IMAP_MASKED&t;&t;0x100
DECL|macro|SA_DMA_SYNC
mdefine_line|#define SA_DMA_SYNC&t;&t;0x200
macro_line|#ifdef __SMP__
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|irqs_have_been_distributed
r_static
r_int
id|irqs_have_been_distributed
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* UPA nodes send interrupt packet to UltraSparc with first data reg value&n; * low 5 bits holding the IRQ identifier being delivered.  We must translate&n; * this into a non-vector IRQ so we can set the softint on this cpu.  To&n; * make things even more swift we store the complete mask here.&n; */
DECL|macro|NUM_HARD_IVECS
mdefine_line|#define NUM_HARD_IVECS&t;2048
DECL|macro|NUM_IVECS
mdefine_line|#define NUM_IVECS&t;(NUM_HARD_IVECS + 64)&t;/* For SMP IRQ distribution alg. */
DECL|variable|ivector_to_mask
r_int
r_int
id|ivector_to_mask
(braket
id|NUM_IVECS
)braket
suffix:semicolon
multiline_comment|/* This is based upon code in the 32-bit Sparc kernel written mostly by&n; * David Redman (djhr@tadpole.co.uk).&n; */
DECL|macro|MAX_STATIC_ALLOC
mdefine_line|#define MAX_STATIC_ALLOC&t;4
DECL|variable|static_irqaction
r_static
r_struct
id|irqaction
id|static_irqaction
(braket
id|MAX_STATIC_ALLOC
)braket
suffix:semicolon
DECL|variable|static_irq_count
r_static
r_int
id|static_irq_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX Must be exported so that fast IRQ handlers can get at it... -DaveM */
DECL|variable|irq_action
r_struct
id|irqaction
op_star
id|irq_action
(braket
id|NR_IRQS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|IBF_DMA_SYNC
mdefine_line|#define IBF_DMA_SYNC&t;0x01
DECL|macro|IBF_PCI
mdefine_line|#define IBF_PCI&t;&t;0x02
DECL|macro|IBF_ACTIVE
mdefine_line|#define IBF_ACTIVE&t;0x04
DECL|macro|__imap
mdefine_line|#define __imap(bucket) ((bucket)-&gt;iclr + (bucket)-&gt;imap_off)
DECL|macro|__bucket
mdefine_line|#define __bucket(irq) ((struct ino_bucket *)(unsigned long)(irq))
DECL|macro|__irq
mdefine_line|#define __irq(bucket) ((unsigned int)(unsigned long)(bucket))
DECL|variable|bucket_base
DECL|variable|buckets
DECL|variable|endbuckets
r_static
r_struct
id|ino_bucket
op_star
id|bucket_base
comma
op_star
id|buckets
comma
op_star
id|endbuckets
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
r_int
id|irq_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
)paren
(brace
id|start_mem
op_assign
(paren
id|start_mem
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
id|bucket_base
op_assign
id|buckets
op_assign
(paren
r_struct
id|ino_bucket
op_star
)paren
id|start_mem
suffix:semicolon
id|endbuckets
op_assign
id|buckets
op_plus
l_int|2048
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|endbuckets
suffix:semicolon
)brace
DECL|function|get_irq_list
r_int
id|get_irq_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
macro_line|#ifdef __SMP__
r_int
id|j
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NR_IRQS
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|action
op_assign
op_star
(paren
id|i
op_plus
id|irq_action
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%3d: &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#ifndef __SMP__
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%10u &quot;
comma
id|kstat_irqs
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|smp_num_cpus
suffix:semicolon
id|j
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%10u &quot;
comma
id|kstat.irqs
(braket
id|cpu_logical_map
c_func
(paren
id|j
)paren
)braket
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%c %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;,%s %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_string|&quot; +&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* SBUS SYSIO INO number to Sparc PIL level. */
DECL|variable|sysio_ino_to_pil
r_int
r_char
id|sysio_ino_to_pil
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 0 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 1 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 2 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|7
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 3 */
l_int|3
comma
multiline_comment|/* Onboard SCSI */
l_int|5
comma
multiline_comment|/* Onboard Ethernet */
multiline_comment|/*XXX*/
l_int|8
comma
multiline_comment|/* Onboard BPP */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|13
comma
multiline_comment|/* Audio */
multiline_comment|/*XXX*/
l_int|15
comma
multiline_comment|/* PowerFail */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|12
comma
multiline_comment|/* Zilog Serial Channels (incl. Keyboard/Mouse lines) */
l_int|11
comma
multiline_comment|/* Floppy */
l_int|0
comma
multiline_comment|/* Spare Hardware (bogon for now) */
l_int|0
comma
multiline_comment|/* Keyboard (bogon for now) */
l_int|0
comma
multiline_comment|/* Mouse (bogon for now) */
l_int|0
comma
multiline_comment|/* Serial (bogon for now) */
l_int|0
comma
l_int|0
comma
multiline_comment|/* Bogon, Bogon */
l_int|10
comma
multiline_comment|/* Timer 0 */
l_int|11
comma
multiline_comment|/* Timer 1 */
l_int|0
comma
l_int|0
comma
multiline_comment|/* Bogon, Bogon */
l_int|15
comma
multiline_comment|/* Uncorrectable SBUS Error */
l_int|15
comma
multiline_comment|/* Correctable SBUS Error */
l_int|15
comma
multiline_comment|/* SBUS Error */
multiline_comment|/*XXX*/
l_int|0
comma
multiline_comment|/* Power Management (bogon for now) */
)brace
suffix:semicolon
multiline_comment|/* INO number to IMAP register offset for SYSIO external IRQ&squot;s.&n; * This should conform to both Sunfire/Wildfire server and Fusion&n; * desktop designs.&n; */
DECL|macro|offset
mdefine_line|#define offset(x) ((unsigned long)(&amp;(((struct sysio_regs *)0)-&gt;x)))
DECL|macro|bogon
mdefine_line|#define bogon     ((unsigned long) -1)
DECL|variable|sysio_irq_offsets
r_static
r_int
r_int
id|sysio_irq_offsets
(braket
)braket
op_assign
(brace
multiline_comment|/* SBUS Slot 0 --&gt; 3, level 1 --&gt; 7 */
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
multiline_comment|/* Onboard devices (not relevant/used on SunFire). */
id|offset
c_func
(paren
id|imap_scsi
)paren
comma
id|offset
c_func
(paren
id|imap_eth
)paren
comma
id|offset
c_func
(paren
id|imap_bpp
)paren
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_audio
)paren
comma
id|offset
c_func
(paren
id|imap_pfail
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_kms
)paren
comma
id|offset
c_func
(paren
id|imap_flpy
)paren
comma
id|offset
c_func
(paren
id|imap_shw
)paren
comma
id|offset
c_func
(paren
id|imap_kbd
)paren
comma
id|offset
c_func
(paren
id|imap_ms
)paren
comma
id|offset
c_func
(paren
id|imap_ser
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_tim0
)paren
comma
id|offset
c_func
(paren
id|imap_tim1
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_ue
)paren
comma
id|offset
c_func
(paren
id|imap_ce
)paren
comma
id|offset
c_func
(paren
id|imap_sberr
)paren
comma
id|offset
c_func
(paren
id|imap_pmgmt
)paren
comma
)brace
suffix:semicolon
DECL|macro|bogon
macro_line|#undef bogon
DECL|macro|NUM_SYSIO_OFFSETS
mdefine_line|#define NUM_SYSIO_OFFSETS (sizeof(sysio_irq_offsets) / sizeof(sysio_irq_offsets[0]))
multiline_comment|/* Convert Interrupt Mapping register pointer to assosciated&n; * Interrupt Clear register pointer, SYSIO specific version.&n; */
DECL|function|sysio_imap_to_iclr
r_static
r_int
r_int
op_star
id|sysio_imap_to_iclr
c_func
(paren
r_int
r_int
op_star
id|imap
)paren
(brace
r_int
r_int
id|diff
suffix:semicolon
id|diff
op_assign
id|offset
c_func
(paren
id|iclr_unused0
)paren
op_minus
id|offset
c_func
(paren
id|imap_slot0
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|imap
)paren
op_plus
id|diff
)paren
suffix:semicolon
)brace
DECL|macro|offset
macro_line|#undef offset
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* PCI PSYCHO INO number to Sparc PIL level. */
DECL|variable|psycho_ino_to_pil
r_int
r_char
id|psycho_ino_to_pil
(braket
)braket
op_assign
(brace
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 0  Int A, B, C, D */
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 1  Int A, B, C, D */
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 2  Int A, B, C, D */
l_int|7
comma
l_int|5
comma
l_int|4
comma
l_int|2
comma
multiline_comment|/* PCI A slot 3  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 0  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 1  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 2  Int A, B, C, D */
l_int|6
comma
l_int|4
comma
l_int|3
comma
l_int|1
comma
multiline_comment|/* PCI B slot 3  Int A, B, C, D */
l_int|3
comma
multiline_comment|/* SCSI */
l_int|5
comma
multiline_comment|/* Ethernet */
l_int|8
comma
multiline_comment|/* Parallel Port */
l_int|13
comma
multiline_comment|/* Audio Record */
l_int|14
comma
multiline_comment|/* Audio Playback */
l_int|15
comma
multiline_comment|/* PowerFail */
l_int|9
comma
multiline_comment|/* Keyboard/Mouse/Serial */
l_int|11
comma
multiline_comment|/* Floppy */
l_int|2
comma
multiline_comment|/* Spare Hardware */
l_int|9
comma
multiline_comment|/* Keyboard */
l_int|4
comma
multiline_comment|/* Mouse */
l_int|12
comma
multiline_comment|/* Serial */
l_int|10
comma
multiline_comment|/* Timer 0 */
l_int|11
comma
multiline_comment|/* Timer 1 */
l_int|15
comma
multiline_comment|/* Uncorrectable ECC */
l_int|15
comma
multiline_comment|/* Correctable ECC */
l_int|15
comma
multiline_comment|/* PCI Bus A Error */
l_int|15
comma
multiline_comment|/* PCI Bus B Error */
l_int|1
comma
multiline_comment|/* Power Management */
)brace
suffix:semicolon
multiline_comment|/* INO number to IMAP register offset for PSYCHO external IRQ&squot;s.&n; */
DECL|macro|psycho_offset
mdefine_line|#define psycho_offset(x) ((unsigned long)(&amp;(((struct psycho_regs *)0)-&gt;x)))
DECL|macro|psycho_imap_offset
mdefine_line|#define psycho_imap_offset(ino)&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;((ino &amp; 0x20) ? (psycho_offset(imap_scsi) + (((ino) &amp; 0x1f) &lt;&lt; 3)) :  &bslash;&n;&t;&t;&t;(psycho_offset(imap_a_slot0) + (((ino) &amp; 0x3c) &lt;&lt; 1)))
DECL|macro|psycho_iclr_offset
mdefine_line|#define psycho_iclr_offset(ino)&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;((ino &amp; 0x20) ? (psycho_offset(iclr_scsi) + (((ino) &amp; 0x1f) &lt;&lt; 3)) :  &bslash;&n;&t;&t;&t;(psycho_offset(iclr_a_slot0[0]) + (((ino) &amp; 0x1f)&lt;&lt;3)))
macro_line|#endif
multiline_comment|/* Now these are always passed a true fully specified sun4u INO. */
DECL|function|enable_irq
r_void
id|enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|tid
suffix:semicolon
r_int
r_int
op_star
id|imap
suffix:semicolon
id|imap
op_assign
id|__imap
c_func
(paren
id|bucket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|imap
)paren
r_return
suffix:semicolon
multiline_comment|/* We send it to our UPA MID, for SMP this will be different. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tid
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_UPA_CONFIG
)paren
)paren
suffix:semicolon
id|tid
op_assign
(paren
(paren
id|tid
op_amp
id|UPA_CONFIG_MID
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* NOTE NOTE NOTE, IGN and INO are read-only, IGN is a product&n;&t; * of this SYSIO&squot;s preconfigured IGN in the SYSIO Control&n;&t; * Register, the hardware just mirrors that value here.&n;&t; * However for Graphics and UPA Slave devices the full&n;&t; * SYSIO_IMAP_INR field can be set by the programmer here.&n;&t; *&n;&t; * Things like FFB can now be handled via the new IRQ mechanism.&n;&t; */
op_star
id|imap
op_assign
id|SYSIO_IMAP_VALID
op_or
(paren
id|tid
op_amp
id|SYSIO_IMAP_TID
)paren
suffix:semicolon
)brace
multiline_comment|/* This now gets passed true ino&squot;s as well. */
DECL|function|disable_irq
r_void
id|disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
op_star
id|imap
suffix:semicolon
id|imap
op_assign
id|__imap
c_func
(paren
id|bucket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|imap
)paren
r_return
suffix:semicolon
multiline_comment|/* NOTE: We do not want to futz with the IRQ clear registers&n;&t; *       and move the state to IDLE, the SCSI code does call&n;&t; *       disable_irq() to assure atomicity in the queue cmd&n;&t; *       SCSI adapter driver code.  Thus we&squot;d lose interrupts.&n;&t; */
op_star
id|imap
op_and_assign
op_complement
(paren
id|SYSIO_IMAP_VALID
)paren
suffix:semicolon
)brace
DECL|function|build_irq
r_int
r_int
id|build_irq
c_func
(paren
r_int
id|pil
comma
r_int
id|inofixup
comma
r_int
r_int
op_star
id|iclr
comma
r_int
r_int
op_star
id|imap
)paren
(brace
r_if
c_cond
(paren
id|buckets
op_eq
id|endbuckets
)paren
id|panic
c_func
(paren
l_string|&quot;Out of IRQ buckets. Should not happen.&bslash;n&quot;
)paren
suffix:semicolon
id|buckets-&gt;pil
op_assign
id|pil
suffix:semicolon
r_if
c_cond
(paren
id|pil
op_logical_and
(paren
op_logical_neg
id|iclr
op_logical_or
op_logical_neg
id|imap
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Invalid build_irq %d %d %016lx %016lx&bslash;n&quot;
comma
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imap
)paren
id|buckets-&gt;ino
op_assign
(paren
op_star
id|imap
op_amp
(paren
id|SYSIO_IMAP_IGN
op_or
id|SYSIO_IMAP_INO
)paren
)paren
op_plus
id|inofixup
suffix:semicolon
r_else
id|buckets-&gt;ino
op_assign
l_int|0
suffix:semicolon
id|buckets-&gt;iclr
op_assign
id|iclr
suffix:semicolon
id|buckets-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|buckets-&gt;imap_off
op_assign
id|imap
op_minus
id|iclr
suffix:semicolon
r_return
id|__irq
c_func
(paren
id|buckets
op_increment
)paren
suffix:semicolon
)brace
DECL|function|sbus_build_irq
r_int
r_int
id|sbus_build_irq
c_func
(paren
r_void
op_star
id|buscookie
comma
r_int
r_int
id|ino
)paren
(brace
r_struct
id|linux_sbus
op_star
id|sbus
op_assign
(paren
r_struct
id|linux_sbus
op_star
)paren
id|buscookie
suffix:semicolon
r_struct
id|sysio_regs
op_star
id|sregs
op_assign
id|sbus-&gt;iommu-&gt;sysio_regs
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|pil
suffix:semicolon
r_int
r_int
op_star
id|imap
comma
op_star
id|iclr
suffix:semicolon
r_int
id|sbus_level
op_assign
l_int|0
suffix:semicolon
id|pil
op_assign
id|sysio_ino_to_pil
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pil
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sbus_irq_build: Bad SYSIO INO[%x]&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Bad SYSIO IRQ translations...&quot;
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|sysio_irq_offsets
(braket
id|ino
)braket
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
(paren
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;get_irq_translations: Bad SYSIO INO[%x] cpu[%d]&bslash;n&quot;
comma
id|ino
comma
id|pil
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;BAD SYSIO IRQ offset...&quot;
)paren
suffix:semicolon
)brace
id|offset
op_add_assign
(paren
(paren
r_int
r_int
)paren
id|sregs
)paren
suffix:semicolon
id|imap
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|offset
)paren
suffix:semicolon
multiline_comment|/* SYSIO inconsistancy.  For external SLOTS, we have to select&n;&t; * the right ICLR register based upon the lower SBUS irq level&n;&t; * bits.&n;&t; */
r_if
c_cond
(paren
id|ino
op_ge
l_int|0x20
)paren
(brace
id|iclr
op_assign
id|sysio_imap_to_iclr
c_func
(paren
id|imap
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|iclraddr
suffix:semicolon
r_int
id|sbus_slot
op_assign
(paren
id|ino
op_amp
l_int|0x18
)paren
op_rshift
l_int|3
suffix:semicolon
id|sbus_level
op_assign
id|ino
op_amp
l_int|0x7
suffix:semicolon
r_switch
c_cond
(paren
id|sbus_slot
)paren
(brace
r_case
l_int|0
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|3
suffix:colon
id|iclr
op_assign
op_amp
id|sregs-&gt;iclr_slot3
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|iclraddr
op_assign
(paren
r_int
r_int
)paren
id|iclr
suffix:semicolon
id|iclraddr
op_add_assign
(paren
(paren
id|sbus_level
op_minus
l_int|1
)paren
op_star
l_int|8
)paren
suffix:semicolon
id|iclr
op_assign
(paren
r_int
r_int
op_star
)paren
id|iclraddr
suffix:semicolon
)brace
r_return
id|build_irq
c_func
(paren
id|pil
comma
id|sbus_level
comma
id|iclr
comma
id|imap
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
DECL|function|psycho_build_irq
r_int
r_int
id|psycho_build_irq
c_func
(paren
r_void
op_star
id|buscookie
comma
r_int
id|imap_off
comma
r_int
id|ino
comma
r_int
id|need_dma_sync
)paren
(brace
r_struct
id|linux_psycho
op_star
id|psycho
op_assign
(paren
r_struct
id|linux_psycho
op_star
)paren
id|buscookie
suffix:semicolon
r_struct
id|psycho_regs
op_star
id|pregs
op_assign
id|psycho-&gt;psycho_regs
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|pil
suffix:semicolon
r_int
r_int
op_star
id|imap
comma
op_star
id|iclr
suffix:semicolon
r_int
id|inofixup
op_assign
l_int|0
suffix:semicolon
id|pil
op_assign
id|psycho_ino_to_pil
(braket
id|ino
op_amp
id|PCI_IRQ_INO
)braket
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
op_amp
id|pregs-&gt;imap_a_slot0
suffix:semicolon
id|addr
op_assign
id|addr
op_plus
id|imap_off
suffix:semicolon
id|imap
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
op_plus
l_int|1
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|pregs
suffix:semicolon
id|addr
op_add_assign
id|psycho_iclr_offset
c_func
(paren
id|ino
op_amp
(paren
id|PCI_IRQ_INO
)paren
)paren
suffix:semicolon
id|iclr
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ino
op_amp
l_int|0x20
)paren
)paren
(brace
id|inofixup
op_assign
id|ino
op_amp
l_int|0x03
suffix:semicolon
)brace
id|bucket
op_assign
id|__bucket
c_func
(paren
id|build_irq
c_func
(paren
id|pil
comma
id|inofixup
comma
id|iclr
comma
id|imap
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_dma_sync
)paren
id|bucket-&gt;flags
op_or_assign
id|IBF_DMA_SYNC
suffix:semicolon
id|bucket-&gt;flags
op_or_assign
id|IBF_PCI
suffix:semicolon
r_return
id|__irq
c_func
(paren
id|bucket
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|pending
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0x400000
op_logical_or
(paren
id|irq
op_amp
l_int|0x80000000
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;request_irq with old style irq %08x %016lx&bslash;n&quot;
comma
id|irq
comma
id|handler
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bucket-&gt;pil
)paren
id|irqflags
op_and_assign
op_complement
id|SA_IMAP_MASKED
suffix:semicolon
r_else
(brace
id|irqflags
op_or_assign
id|SA_IMAP_MASKED
suffix:semicolon
r_if
c_cond
(paren
id|bucket-&gt;flags
op_amp
id|IBF_PCI
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * PCI IRQs should never use SA_INTERRUPT.&n;&t;&t;&t; */
id|irqflags
op_and_assign
op_complement
(paren
id|SA_INTERRUPT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check wether we _should_ use DMA Write Sync&n;&t;&t;&t; * (for devices behind bridges behind APB). &n;&t;&t;&t; *&n;&t;&t;&t; * XXX: Not implemented, yet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bucket-&gt;flags
op_amp
id|IBF_DMA_SYNC
)paren
id|irqflags
op_or_assign
id|SA_DMA_SYNC
suffix:semicolon
)brace
)brace
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
op_logical_and
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
)paren
r_for
c_loop
(paren
id|tmp
op_assign
id|action
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
op_xor
(paren
id|irqflags
op_amp
id|SA_INTERRUPT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to mix fast and slow interrupts on IRQ%d &quot;
l_string|&quot;denied&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Or else! */
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* If this is flagged as statically allocated then we use our&n;&t; * private struct which is never freed.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
(brace
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|irq
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
id|pending
op_assign
(paren
(paren
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_amp
l_int|0x80000000
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_assign
(paren
l_int|1
op_lshift
id|bucket-&gt;pil
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pending
)paren
(brace
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_or_assign
l_int|0x80000000
suffix:semicolon
)brace
id|bucket-&gt;flags
op_or_assign
id|IBF_ACTIVE
suffix:semicolon
)brace
id|action-&gt;mask
op_assign
(paren
r_int
r_int
)paren
id|bucket
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action
suffix:semicolon
)brace
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* We ate the IVEC already, this makes sure it does not get lost. */
r_if
c_cond
(paren
id|pending
)paren
(brace
id|set_softint
c_func
(paren
l_int|1
op_lshift
id|bucket-&gt;pil
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
r_if
c_cond
(paren
id|irqs_have_been_distributed
)paren
(brace
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|irqaction
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
comma
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0x400000
op_logical_or
(paren
id|irq
op_amp
l_int|0x80000000
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;free_irq with old style irq %08x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing free IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_id
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_eq
id|dev_id
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|action
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free shared IRQ %d&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free shared IRQ %d with NULL device ID&bslash;n&quot;
comma
id|bucket-&gt;pil
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to free statically allocated IRQ %d (%s)&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|action-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_logical_and
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_else
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
r_int
r_int
op_star
id|imap
op_assign
id|__imap
c_func
(paren
id|bucket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only free when no other shared irq uses this bucket.&n;&t;&t; */
id|tmp
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
(paren
r_struct
id|ino_bucket
op_star
)paren
id|tmp-&gt;mask
op_eq
id|bucket
)paren
r_goto
id|out
suffix:semicolon
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_assign
l_int|0
suffix:semicolon
id|bucket-&gt;flags
op_and_assign
op_complement
id|IBF_ACTIVE
suffix:semicolon
r_for
c_loop
(paren
id|bp
op_assign
id|bucket_base
suffix:semicolon
id|bp
OL
id|endbuckets
suffix:semicolon
id|bp
op_increment
)paren
r_if
c_cond
(paren
id|__imap
c_func
(paren
id|bp
)paren
op_eq
id|imap
op_logical_and
(paren
id|bp-&gt;flags
op_amp
id|IBF_ACTIVE
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only disable when no other sub-irq levels of&n;&t;&t; * the same imap are active.&n;&t;&t; */
r_if
c_cond
(paren
id|bp
op_eq
id|endbuckets
)paren
id|disable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Only uniprocessor needs this IRQ locking depth, on SMP it lives in the per-cpu&n; * structure for cache reasons.&n; */
macro_line|#ifndef __SMP__
DECL|variable|local_irq_count
r_int
r_int
id|local_irq_count
suffix:semicolon
macro_line|#endif
macro_line|#ifndef __SMP__
DECL|variable|__sparc64_bh_counter
r_int
id|__sparc64_bh_counter
op_assign
l_int|0
suffix:semicolon
DECL|macro|irq_enter
mdefine_line|#define irq_enter(cpu, irq)&t;(local_irq_count++)
DECL|macro|irq_exit
mdefine_line|#define irq_exit(cpu, irq)&t;(local_irq_count--)
macro_line|#else
DECL|variable|__sparc64_bh_counter
id|atomic_t
id|__sparc64_bh_counter
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Who has global_irq_lock. */
DECL|variable|global_irq_holder
r_int
r_char
id|global_irq_holder
op_assign
id|NO_PROC_ID
suffix:semicolon
multiline_comment|/* This protects IRQ&squot;s. */
DECL|variable|global_irq_lock
id|spinlock_t
id|global_irq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* This protects BH software state (masks, things like that). */
DECL|variable|global_bh_lock
id|spinlock_t
id|global_bh_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Global IRQ locking depth. */
DECL|variable|global_irq_count
id|atomic_t
id|global_irq_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|previous_irqholder
r_static
r_int
r_int
id|previous_irqholder
suffix:semicolon
DECL|macro|INIT_STUCK
macro_line|#undef INIT_STUCK
DECL|macro|INIT_STUCK
mdefine_line|#define INIT_STUCK 100000000
DECL|macro|STUCK
macro_line|#undef STUCK
DECL|macro|STUCK
mdefine_line|#define STUCK &bslash;&n;if (!--stuck) {printk(&quot;wait_on_irq CPU#%d stuck at %08lx, waiting for %08lx (local=%d, global=%d)&bslash;n&quot;, cpu, where, previous_irqholder, local_count, atomic_read(&amp;global_irq_count)); stuck = INIT_STUCK; }
DECL|function|wait_on_irq
r_static
r_inline
r_void
id|wait_on_irq
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|where
)paren
(brace
r_int
id|stuck
op_assign
id|INIT_STUCK
suffix:semicolon
r_int
id|local_count
op_assign
id|local_irq_count
suffix:semicolon
r_while
c_loop
(paren
id|local_count
op_ne
id|atomic_read
c_func
(paren
op_amp
id|global_irq_count
)paren
)paren
(brace
id|atomic_sub
c_func
(paren
id|local_count
comma
op_amp
id|global_irq_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|global_irq_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|STUCK
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#StoreLoad | #LoadLoad&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|global_irq_count
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
op_amp
id|global_irq_lock
)paren
)paren
r_continue
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#LoadLoad | #LoadStore&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
r_break
suffix:semicolon
)brace
id|atomic_add
c_func
(paren
id|local_count
comma
op_amp
id|global_irq_count
)paren
suffix:semicolon
)brace
)brace
DECL|macro|INIT_STUCK
macro_line|#undef INIT_STUCK
DECL|macro|INIT_STUCK
mdefine_line|#define INIT_STUCK 10000000
DECL|macro|STUCK
macro_line|#undef STUCK
DECL|macro|STUCK
mdefine_line|#define STUCK &bslash;&n;if (!--stuck) {printk(&quot;get_irqlock stuck at %08lx, waiting for %08lx&bslash;n&quot;, where, previous_irqholder); stuck = INIT_STUCK;}
DECL|function|get_irqlock
r_static
r_inline
r_void
id|get_irqlock
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|where
)paren
(brace
r_int
id|stuck
op_assign
id|INIT_STUCK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
(brace
id|membar
c_func
(paren
l_string|&quot;#StoreLoad | #LoadLoad&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|cpu
op_eq
id|global_irq_holder
)paren
r_return
suffix:semicolon
r_do
(brace
r_do
(brace
id|STUCK
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
op_amp
id|global_irq_lock
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
suffix:semicolon
)brace
id|wait_on_irq
c_func
(paren
id|cpu
comma
id|where
)paren
suffix:semicolon
id|global_irq_holder
op_assign
id|cpu
suffix:semicolon
id|previous_irqholder
op_assign
id|where
suffix:semicolon
)brace
DECL|function|__global_cli
r_void
id|__global_cli
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|where
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;mov %%i7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|where
)paren
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|get_irqlock
c_func
(paren
id|cpu
comma
id|where
)paren
suffix:semicolon
)brace
DECL|function|__global_sti
r_void
id|__global_sti
c_func
(paren
r_void
)paren
(brace
id|release_irqlock
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|__global_restore_flags
r_void
id|__global_restore_flags
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
l_int|1
)paren
(brace
id|__global_cli
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|global_irq_holder
op_eq
(paren
r_int
r_char
)paren
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
id|global_irq_holder
op_assign
id|NO_PROC_ID
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|global_irq_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
l_int|2
)paren
)paren
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|macro|INIT_STUCK
macro_line|#undef INIT_STUCK
DECL|macro|INIT_STUCK
mdefine_line|#define INIT_STUCK 200000000
DECL|macro|STUCK
macro_line|#undef STUCK
DECL|macro|STUCK
mdefine_line|#define STUCK &bslash;&n;if (!--stuck) {printk(&quot;irq_enter stuck (irq=%d, cpu=%d, global=%d)&bslash;n&quot;,irq,cpu,global_irq_holder); stuck = INIT_STUCK;}
DECL|function|irq_enter
r_void
id|irq_enter
c_func
(paren
r_int
id|cpu
comma
r_int
id|irq
)paren
(brace
r_int
id|stuck
op_assign
id|INIT_STUCK
suffix:semicolon
id|hardirq_enter
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
op_amp
id|global_irq_lock
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|cpu
op_eq
id|global_irq_holder
)paren
id|printk
c_func
(paren
l_string|&quot;irq_enter: Frosted Lucky Charms, &quot;
l_string|&quot;they&squot;re magically delicious!&bslash;n&quot;
)paren
suffix:semicolon
id|STUCK
suffix:semicolon
id|membar
c_func
(paren
l_string|&quot;#LoadLoad&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|irq_exit
r_void
id|irq_exit
c_func
(paren
r_int
id|cpu
comma
r_int
id|irq
)paren
(brace
id|hardirq_exit
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|release_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
DECL|function|synchronize_irq
r_void
id|synchronize_irq
c_func
(paren
r_void
)paren
(brace
r_int
id|local_count
op_assign
id|local_irq_count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|local_count
op_ne
id|atomic_read
c_func
(paren
op_amp
id|global_irq_count
)paren
)paren
(brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* __SMP__ */
DECL|function|report_spurious_ivec
r_void
id|report_spurious_ivec
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_extern
r_int
r_int
id|ivec_spurious_cookie
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;IVEC: Spurious interrupt vector (%016lx) received at (%016lx)&bslash;n&quot;
comma
id|ivec_spurious_cookie
comma
id|regs-&gt;tpc
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We can actually see this on Ultra/PCI PCI cards, which are bridges&n;&t; * to other devices.  Here a single IMAP enabled potentially multiple&n;&t; * unique interrupt sources (which each do have a unique ICLR register.&n;&t; *&n;&t; * So what we do is just register that the IVEC arrived, when registered&n;&t; * for real the request_irq() code will check the high bit and signal&n;&t; * a local CPU interrupt for it.&n;&t; */
id|ivector_to_mask
(braket
id|ivec_spurious_cookie
)braket
op_or_assign
(paren
l_int|0x80000000
)paren
suffix:semicolon
)brace
DECL|function|unexpected_irq
r_void
id|unexpected_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
id|cpu_irq
op_assign
id|irq
op_amp
id|NR_IRQS
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Unexpected IRQ[%d]: &quot;
comma
id|irq
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;PC[%016lx] NPC[%016lx] FP[%016lx]&bslash;n&quot;
comma
id|regs-&gt;tpc
comma
id|regs-&gt;tnpc
comma
id|regs-&gt;u_regs
(braket
l_int|14
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Expecting: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;handler
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;[%s:%d:0x%016lx] &quot;
comma
id|action-&gt;name
comma
id|i
comma
(paren
r_int
r_int
)paren
id|action-&gt;handler
)paren
suffix:semicolon
)brace
)brace
)brace
id|prom_printf
c_func
(paren
l_string|&quot;AIEEE&bslash;n&quot;
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;bogus interrupt received&bslash;n&quot;
)paren
suffix:semicolon
id|prom_cmdline
(paren
)paren
suffix:semicolon
)brace
DECL|function|handler_irq
r_void
id|handler_irq
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
comma
op_star
id|act
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef __SMP__
multiline_comment|/*&n;&t; * Check for TICK_INT on level 14 softint.&n;&t; */
r_if
c_cond
(paren
(paren
id|irq
op_eq
l_int|14
)paren
op_logical_and
id|get_softint
c_func
(paren
)paren
op_amp
(paren
l_int|1UL
op_lshift
l_int|0
)paren
)paren
id|irq
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|unexpected_irq
c_func
(paren
id|irq
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
id|act
op_assign
id|action
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|act-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
id|bucket
op_assign
(paren
r_struct
id|ino_bucket
op_star
)paren
id|act-&gt;mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_amp
l_int|0x80000000
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
id|act
op_member_access_from_pointer
id|handler
c_func
(paren
id|__irq
c_func
(paren
id|bucket
)paren
comma
id|act-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|act
op_assign
id|act-&gt;next
)paren
op_ne
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
id|act
op_assign
id|action
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|act-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
id|bucket
op_assign
(paren
r_struct
id|ino_bucket
op_star
)paren
id|act-&gt;mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_amp
l_int|0x80000000
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_and_assign
op_complement
(paren
l_int|0x80000000
)paren
suffix:semicolon
op_star
(paren
id|bucket-&gt;iclr
)paren
op_assign
id|SYSIO_ICLR_IDLE
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|act
op_assign
id|act-&gt;next
)paren
op_ne
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
)brace
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_FD
r_extern
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|sparc_floppy_irq
r_void
id|sparc_floppy_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
id|bucket
op_assign
(paren
r_struct
id|ino_bucket
op_star
)paren
id|action-&gt;mask
suffix:semicolon
id|floppy_interrupt
c_func
(paren
id|irq
comma
id|dev_cookie
comma
id|regs
)paren
suffix:semicolon
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_and_assign
op_complement
(paren
l_int|0x80000000
)paren
suffix:semicolon
op_star
(paren
id|bucket-&gt;iclr
)paren
op_assign
id|SYSIO_ICLR_IDLE
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* The following assumes that the branch lies before the place we&n; * are branching to.  This is the case for a trap vector...&n; * You have been warned.&n; */
DECL|macro|SPARC_BRANCH
mdefine_line|#define SPARC_BRANCH(dest_addr, inst_addr) &bslash;&n;          (0x10800000 | ((((dest_addr)-(inst_addr))&gt;&gt;2)&amp;0x3fffff))
DECL|macro|SPARC_NOP
mdefine_line|#define SPARC_NOP (0x01000000)
DECL|function|install_fast_irq
r_static
r_void
id|install_fast_irq
c_func
(paren
r_int
r_int
id|cpu_irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_extern
r_int
r_int
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
id|ttent
op_assign
(paren
r_int
r_int
)paren
op_amp
id|sparc64_ttable_tl0
suffix:semicolon
r_int
r_int
op_star
id|insns
suffix:semicolon
id|ttent
op_add_assign
l_int|0x820
suffix:semicolon
id|ttent
op_add_assign
(paren
id|cpu_irq
op_minus
l_int|1
)paren
op_lshift
l_int|5
suffix:semicolon
id|insns
op_assign
(paren
r_int
r_int
op_star
)paren
id|ttent
suffix:semicolon
id|insns
(braket
l_int|0
)braket
op_assign
id|SPARC_BRANCH
c_func
(paren
(paren
(paren
r_int
r_int
)paren
id|handler
)paren
comma
(paren
(paren
r_int
r_int
)paren
op_amp
id|insns
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|insns
(braket
l_int|1
)braket
op_assign
id|SPARC_NOP
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;membar #StoreStore; flush %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|ttent
)paren
)paren
suffix:semicolon
)brace
DECL|function|request_fast_irq
r_int
id|request_fast_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
id|__bucket
c_func
(paren
id|irq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0x400000
op_logical_or
(paren
id|irq
op_amp
l_int|0x80000000
)paren
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;request_irq with old style irq %08x %016lx&bslash;n&quot;
comma
id|irq
comma
id|handler
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bucket-&gt;pil
op_eq
l_int|0
)paren
op_logical_or
(paren
id|bucket-&gt;pil
op_eq
l_int|14
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register shared IRQ 0 or 14.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq when already shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to register fast irq as shared.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;request_fast_irq: Trying to register yet already owned.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
(brace
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|bucket-&gt;pil
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|install_fast_irq
c_func
(paren
id|bucket-&gt;pil
comma
id|handler
)paren
suffix:semicolon
id|ivector_to_mask
(braket
id|bucket-&gt;ino
)braket
op_assign
(paren
l_int|1
op_lshift
id|bucket-&gt;pil
)paren
suffix:semicolon
id|action-&gt;mask
op_assign
(paren
r_int
r_int
)paren
id|bucket
suffix:semicolon
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
op_or
id|SA_IMAP_MASKED
suffix:semicolon
id|action-&gt;dev_id
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
op_star
(paren
id|bucket-&gt;pil
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
r_if
c_cond
(paren
id|irqs_have_been_distributed
)paren
(brace
id|distribute_irqs
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We really don&squot;t need these at all on the Sparc.  We only have&n; * stubs here because they are exported to modules.&n; */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|probe_irq_off
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is gets the master TICK_INT timer going. */
DECL|function|init_timers
r_void
id|init_timers
c_func
(paren
r_void
(paren
op_star
id|cfunc
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
op_star
id|clock
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_extern
r_int
r_int
id|timer_tick_offset
suffix:semicolon
r_int
id|node
comma
id|err
suffix:semicolon
macro_line|#ifdef __SMP__
r_extern
r_void
id|smp_tick_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
id|node
op_assign
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
suffix:semicolon
op_star
id|clock
op_assign
id|prom_getint
c_func
(paren
id|node
comma
l_string|&quot;clock-frequency&quot;
)paren
suffix:semicolon
id|timer_tick_offset
op_assign
op_star
id|clock
op_div
id|HZ
suffix:semicolon
macro_line|#ifdef __SMP__
id|smp_tick_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Register IRQ handler. */
id|err
op_assign
id|request_irq
c_func
(paren
id|build_irq
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
comma
id|cfunc
comma
(paren
id|SA_INTERRUPT
op_or
id|SA_STATIC_ALLOC
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Serious problem, cannot register TICK_INT&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Set things up so user can access tick register for profiling&n;&t; * purposes.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|sethi
op_mod
op_mod
id|hi
c_func
(paren
l_int|0x80000000
)paren
comma
op_mod
op_mod
id|g1
id|sllx
op_mod
op_mod
id|g1
comma
l_int|32
comma
op_mod
op_mod
id|g1
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g2
id|add
op_mod
op_mod
id|g2
comma
l_int|6
comma
op_mod
op_mod
id|g2
id|andn
op_mod
op_mod
id|g2
comma
op_mod
op_mod
id|g1
comma
op_mod
op_mod
id|g2
id|wrpr
op_mod
op_mod
id|g2
comma
l_int|0
comma
op_mod
op_mod
id|tick
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
multiline_comment|/* no inputs */
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|tick
comma
op_mod
op_mod
id|g1
id|add
op_mod
op_mod
id|g1
comma
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
id|wr
op_mod
op_mod
id|g1
comma
l_int|0x0
comma
op_mod
op_mod
id|tick_cmpr
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|timer_tick_offset
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef __SMP__
multiline_comment|/* Called from smp_commence, when we know how many cpus are in the system&n; * and can have device IRQ&squot;s directed at them.&n; */
DECL|function|distribute_irqs
r_void
id|distribute_irqs
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
comma
id|level
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMP: redistributing interrupts...&bslash;n&quot;
)paren
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cpu
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|NR_IRQS
suffix:semicolon
id|level
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|p
op_assign
id|irq_action
(braket
id|level
)braket
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|SA_IMAP_MASKED
)paren
(brace
r_struct
id|ino_bucket
op_star
id|bucket
op_assign
(paren
r_struct
id|ino_bucket
op_star
)paren
id|p-&gt;mask
suffix:semicolon
r_int
r_int
op_star
id|imap
op_assign
id|__imap
c_func
(paren
id|bucket
)paren
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|tid
op_assign
id|__cpu_logical_map
(braket
id|cpu
)braket
op_lshift
l_int|9
suffix:semicolon
id|val
op_assign
op_star
id|imap
suffix:semicolon
op_star
id|imap
op_assign
id|SYSIO_IMAP_VALID
op_or
(paren
id|tid
op_amp
id|SYSIO_IMAP_TID
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMP: Redirecting IGN[%x] INO[%x] &quot;
l_string|&quot;to cpu %d [%s]&bslash;n&quot;
comma
(paren
id|val
op_amp
id|SYSIO_IMAP_IGN
)paren
op_rshift
l_int|6
comma
(paren
id|val
op_amp
id|SYSIO_IMAP_INO
)paren
comma
id|cpu
comma
id|p-&gt;name
)paren
suffix:semicolon
id|cpu
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_ge
id|NR_CPUS
op_logical_or
id|__cpu_logical_map
(braket
id|cpu
)braket
op_eq
op_minus
l_int|1
)paren
id|cpu
op_assign
l_int|0
suffix:semicolon
)brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|irqs_have_been_distributed
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|prom_timers
r_struct
id|sun5_timer
op_star
id|prom_timers
suffix:semicolon
DECL|variable|prom_limit0
DECL|variable|prom_limit1
r_static
id|u64
id|prom_limit0
comma
id|prom_limit1
suffix:semicolon
DECL|function|map_prom_timers
r_static
r_void
id|map_prom_timers
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|tnode
comma
id|err
suffix:semicolon
multiline_comment|/* PROM timer node hangs out in the top level of device siblings... */
id|tnode
op_assign
id|prom_finddevice
c_func
(paren
l_string|&quot;/counter-timer&quot;
)paren
suffix:semicolon
multiline_comment|/* Assume if node is not present, PROM uses different tick mechanism&n;&t; * which we should not care about.&n;&t; */
r_if
c_cond
(paren
id|tnode
op_eq
l_int|0
op_logical_or
id|tnode
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If PROM is really using this, it must be mapped by him. */
id|err
op_assign
id|prom_getproperty
c_func
(paren
id|tnode
comma
l_string|&quot;address&quot;
comma
(paren
r_char
op_star
)paren
id|addr
comma
r_sizeof
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PROM does not have timer mapped, trying to continue.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|kill_prom_timer
r_static
r_void
id|kill_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Save them away for later. */
id|prom_limit0
op_assign
id|prom_timers-&gt;limit0
suffix:semicolon
id|prom_limit1
op_assign
id|prom_timers-&gt;limit1
suffix:semicolon
multiline_comment|/* Just as in sun4c/sun4m PROM uses timer which ticks at IRQ 14.&n;&t; * We turn both off here just to be paranoid.&n;&t; */
id|prom_timers-&gt;limit0
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wheee, eat the interrupt packet too... */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|mov
l_int|0x40
comma
op_mod
op_mod
id|g2
id|ldxa
(braket
op_mod
op_mod
id|g0
)braket
op_mod
l_int|0
comma
op_mod
op_mod
id|g1
id|ldxa
(braket
op_mod
op_mod
id|g2
)braket
op_mod
l_int|1
comma
op_mod
op_mod
id|g1
id|stxa
op_mod
op_mod
id|g0
comma
(braket
op_mod
op_mod
id|g0
)braket
op_mod
l_int|0
id|membar
macro_line|#Sync
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_INTR_RECEIVE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_UDB_INTR_R
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
)paren
suffix:semicolon
)brace
DECL|function|enable_prom_timer
r_void
id|enable_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Set it to whatever was there before. */
id|prom_timers-&gt;limit1
op_assign
id|prom_limit1
suffix:semicolon
id|prom_timers-&gt;count1
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit0
op_assign
id|prom_limit0
suffix:semicolon
id|prom_timers-&gt;count0
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|init_IRQ
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|map_prom_timers
c_func
(paren
)paren
suffix:semicolon
id|kill_prom_timer
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_IVECS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ivector_to_mask
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need to clear any IRQ&squot;s pending in the soft interrupt&n;&t; * registers, a spurious one could be left around from the&n;&t; * PROM timer which we just disabled.&n;&t; */
id|clear_softint
c_func
(paren
id|get_softint
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Now that ivector table is initialized, it is safe&n;&t; * to receive IRQ vector traps.  We will normally take&n;&t; * one or two right now, in case some device PROM used&n;&t; * to boot us wants to speak to us.  We just ignore them.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;or&t;%%g1, %0, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%%g1, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* No outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
)brace
eof
