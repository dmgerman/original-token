multiline_comment|/* $Id: irq.c,v 1.13 1997/05/27 07:54:28 davem Exp $&n; * irq.c: UltraSparc IRQ handling/init/registry.&n; *&n; * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/random.h&gt; /* XXX ADD add_foo_randomness() calls... -DaveM */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/sbus.h&gt;
macro_line|#include &lt;asm/iommu.h&gt;
macro_line|#include &lt;asm/upa.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
multiline_comment|/* Internal flag, should not be visible elsewhere at all. */
DECL|macro|SA_SYSIO_MASKED
mdefine_line|#define SA_SYSIO_MASKED&t;&t;0x100
multiline_comment|/* UPA nodes send interrupt packet to UltraSparc with first data reg value&n; * low 5 bits holding the IRQ identifier being delivered.  We must translate&n; * this into a non-vector IRQ so we can set the softint on this cpu.  To&n; * make things even more swift we store the complete mask here.&n; */
DECL|macro|NUM_IVECS
mdefine_line|#define NUM_IVECS&t;2048&t;/* XXX may need more on sunfire/wildfire */
DECL|variable|ivector_to_mask
r_int
r_int
id|ivector_to_mask
(braket
id|NUM_IVECS
)braket
suffix:semicolon
multiline_comment|/* This is based upon code in the 32-bit Sparc kernel written mostly by&n; * David Redman (djhr@tadpole.co.uk).&n; */
DECL|macro|MAX_STATIC_ALLOC
mdefine_line|#define MAX_STATIC_ALLOC&t;4
DECL|variable|static_irqaction
r_static
r_struct
id|irqaction
id|static_irqaction
(braket
id|MAX_STATIC_ALLOC
)braket
suffix:semicolon
DECL|variable|static_irq_count
r_static
r_int
id|static_irq_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq_action
r_static
r_struct
id|irqaction
op_star
id|irq_action
(braket
id|NR_IRQS
op_plus
l_int|1
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|get_irq_list
r_int
id|get_irq_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NR_IRQS
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|action
op_assign
op_star
(paren
id|i
op_plus
id|irq_action
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%2d: %8d %c %s&quot;
comma
id|i
comma
id|kstat.interrupts
(braket
id|i
)braket
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_char|&squot;+&squot;
suffix:colon
l_char|&squot; &squot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;,%s %s&quot;
comma
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
ques
c_cond
l_string|&quot; +&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* INO number to Sparc PIL level. */
DECL|variable|ino_to_pil
r_static
r_int
r_char
id|ino_to_pil
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 0 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 1 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 2 */
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|5
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
multiline_comment|/* SBUS slot 3 */
l_int|3
comma
multiline_comment|/* Onboard SCSI */
l_int|5
comma
multiline_comment|/* Onboard Ethernet */
multiline_comment|/*XXX*/
l_int|8
comma
multiline_comment|/* Onboard BPP */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|13
comma
multiline_comment|/* Audio */
multiline_comment|/*XXX*/
l_int|15
comma
multiline_comment|/* PowerFail */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|0
comma
multiline_comment|/* Bogon */
l_int|12
comma
multiline_comment|/* Zilog Serial Channels (incl. Keyboard/Mouse lines) */
l_int|11
comma
multiline_comment|/* Floppy */
l_int|0
comma
multiline_comment|/* Spare Hardware (bogon for now) */
l_int|0
comma
multiline_comment|/* Keyboard (bogon for now) */
l_int|0
comma
multiline_comment|/* Mouse (bogon for now) */
l_int|0
comma
multiline_comment|/* Serial (bogon for now) */
l_int|0
comma
l_int|0
comma
multiline_comment|/* Bogon, Bogon */
l_int|10
comma
multiline_comment|/* Timer 0 */
l_int|11
comma
multiline_comment|/* Timer 1 */
l_int|0
comma
l_int|0
comma
multiline_comment|/* Bogon, Bogon */
l_int|15
comma
multiline_comment|/* Uncorrectable SBUS Error */
l_int|15
comma
multiline_comment|/* Correctable SBUS Error */
l_int|15
comma
multiline_comment|/* SBUS Error */
multiline_comment|/*XXX*/
l_int|0
comma
multiline_comment|/* Power Management (bogon for now) */
)brace
suffix:semicolon
multiline_comment|/* INO number to IMAP register offset for SYSIO external IRQ&squot;s.&n; * This should conform to both Sunfire/Wildfire server and Fusion&n; * desktop designs.&n; */
DECL|macro|offset
mdefine_line|#define offset(x) ((unsigned long)(&amp;(((struct sysio_regs *)0)-&gt;x)))
DECL|macro|bogon
mdefine_line|#define bogon     ((unsigned long) -1)
DECL|variable|irq_offsets
r_static
r_int
r_int
id|irq_offsets
(braket
)braket
op_assign
(brace
multiline_comment|/* SBUS Slot 0 --&gt; 3, level 1 --&gt; 7 */
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot0
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot1
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot2
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
id|offset
c_func
(paren
id|imap_slot3
)paren
comma
multiline_comment|/* Onboard devices (not relevant/used on SunFire). */
id|offset
c_func
(paren
id|imap_scsi
)paren
comma
id|offset
c_func
(paren
id|imap_eth
)paren
comma
id|offset
c_func
(paren
id|imap_bpp
)paren
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_audio
)paren
comma
id|offset
c_func
(paren
id|imap_pfail
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_kms
)paren
comma
id|offset
c_func
(paren
id|imap_flpy
)paren
comma
id|offset
c_func
(paren
id|imap_shw
)paren
comma
id|offset
c_func
(paren
id|imap_kbd
)paren
comma
id|offset
c_func
(paren
id|imap_ms
)paren
comma
id|offset
c_func
(paren
id|imap_ser
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_tim0
)paren
comma
id|offset
c_func
(paren
id|imap_tim1
)paren
comma
id|bogon
comma
id|bogon
comma
id|offset
c_func
(paren
id|imap_ue
)paren
comma
id|offset
c_func
(paren
id|imap_ce
)paren
comma
id|offset
c_func
(paren
id|imap_sberr
)paren
comma
id|offset
c_func
(paren
id|imap_pmgmt
)paren
comma
)brace
suffix:semicolon
DECL|macro|bogon
macro_line|#undef bogon
DECL|macro|NUM_IRQ_ENTRIES
mdefine_line|#define NUM_IRQ_ENTRIES (sizeof(irq_offsets) / sizeof(irq_offsets[0]))
multiline_comment|/* Convert an &quot;interrupts&quot; property IRQ level to an SBUS/SYSIO&n; * Interrupt Mapping register pointer, or NULL if none exists.&n; */
DECL|function|irq_to_imap
r_static
r_int
r_int
op_star
id|irq_to_imap
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|sysio_regs
op_star
id|sregs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
op_eq
l_int|14
)paren
op_logical_or
(paren
id|irq
op_ge
id|NUM_IRQ_ENTRIES
)paren
op_logical_or
(paren
(paren
id|offset
op_assign
id|irq_offsets
(braket
id|irq
)braket
)paren
op_eq
(paren
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|sregs
op_assign
id|SBus_chain-&gt;iommu-&gt;sysio_regs
suffix:semicolon
id|offset
op_add_assign
(paren
(paren
r_int
r_int
)paren
id|sregs
)paren
suffix:semicolon
r_return
(paren
(paren
r_int
r_int
op_star
)paren
id|offset
)paren
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Convert Interrupt Mapping register pointer to assosciated&n; * Interrupt Clear register pointer.&n; */
DECL|function|imap_to_iclr
r_static
r_int
r_int
op_star
id|imap_to_iclr
c_func
(paren
r_int
r_int
op_star
id|imap
)paren
(brace
r_int
r_int
id|diff
suffix:semicolon
id|diff
op_assign
id|offset
c_func
(paren
id|iclr_unused0
)paren
op_minus
id|offset
c_func
(paren
id|imap_slot0
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|imap
)paren
op_plus
id|diff
)paren
suffix:semicolon
)brace
DECL|macro|offset
macro_line|#undef offset
multiline_comment|/* For non-SBUS IRQ&squot;s we do nothing, else we must enable them in the&n; * appropriate SYSIO interrupt map registers.&n; */
DECL|function|enable_irq
r_void
id|enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|tid
suffix:semicolon
r_int
r_int
op_star
id|imap
suffix:semicolon
multiline_comment|/* If this is for the tick interrupt, just ignore, note&n;&t; * that this is the one and only locally generated interrupt&n;&t; * source, all others come from external sources (essentially&n;&t; * any UPA device which is an interruptor).  (actually, on&n;&t; * second thought Ultra can generate local interrupts for&n;&t; * async memory errors and we may setup handlers for those&n;&t; * at some point as well)&n;&t; *&n;&t; * XXX See commentary below in request_irq() this assumption&n;&t; * XXX is broken and needs to be fixed.&n;&t; */
r_if
c_cond
(paren
id|irq
op_eq
l_int|14
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Check for bogons. */
id|imap
op_assign
id|irq_to_imap
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|NULL
)paren
(brace
r_goto
id|do_the_stb_watoosi
suffix:semicolon
)brace
multiline_comment|/* We send it to our UPA MID, for SMP this will be different. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldxa [%%g0] %1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tid
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|ASI_UPA_CONFIG
)paren
)paren
suffix:semicolon
id|tid
op_assign
(paren
(paren
id|tid
op_amp
id|UPA_CONFIG_MID
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* NOTE NOTE NOTE, IGN and INO are read-only, IGN is a product&n;&t; * of this SYSIO&squot;s preconfigured IGN in the SYSIO Control&n;&t; * Register, the hardware just mirrors that value here.&n;&t; * However for Graphics and UPA Slave devices the full&n;&t; * SYSIO_IMAP_INR field can be set by the programmer here.&n;&t; * (XXX we will have to handle those for FFB etc. XXX)&n;&t; */
op_star
id|imap
op_assign
id|SYSIO_IMAP_VALID
op_or
(paren
id|tid
op_amp
id|SYSIO_IMAP_TID
)paren
suffix:semicolon
r_return
suffix:semicolon
id|do_the_stb_watoosi
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Cannot enable irq(%d), doing the &bslash;&quot;STB Watoosi&bslash;&quot; instead.&quot;
comma
id|irq
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Trying to enable bogon IRQ&quot;
)paren
suffix:semicolon
)brace
DECL|function|disable_irq
r_void
id|disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
op_star
id|imap
suffix:semicolon
multiline_comment|/* XXX Grrr, I know this is broken... */
r_if
c_cond
(paren
id|irq
op_eq
l_int|14
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Check for bogons. */
id|imap
op_assign
id|irq_to_imap
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|NULL
)paren
(brace
r_goto
id|do_the_stb_watoosi
suffix:semicolon
)brace
multiline_comment|/* NOTE: We do not want to futz with the IRQ clear registers&n;&t; *       and move the state to IDLE, the SCSI code does call&n;&t; *       disable_irq() to assure atomicity in the queue cmd&n;&t; *       SCSI adapter driver code.  Thus we&squot;d lose interrupts.&n;&t; */
op_star
id|imap
op_and_assign
op_complement
(paren
id|SYSIO_IMAP_VALID
)paren
suffix:semicolon
r_return
suffix:semicolon
id|do_the_stb_watoosi
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Cannot disable irq(%d), doing the &bslash;&quot;STB Watoosi&bslash;&quot; instead.&quot;
comma
id|irq
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Trying to enable bogon IRQ&quot;
)paren
suffix:semicolon
)brace
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev_cookie
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cpu_irq
comma
op_star
id|imap
comma
op_star
id|iclr
suffix:semicolon
multiline_comment|/* XXX This really is not the way to do it, the &quot;right way&quot;&n;&t; * XXX is to have drivers set SA_SBUS or something like that&n;&t; * XXX in irqflags and we base our decision here on whether&n;&t; * XXX that flag bit is set or not.&n;&t; */
r_if
c_cond
(paren
id|irq
op_eq
l_int|14
)paren
(brace
id|cpu_irq
op_assign
id|irq
suffix:semicolon
)brace
r_else
id|cpu_irq
op_assign
id|ino_to_pil
(braket
id|irq
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|imap
op_assign
id|irq_to_imap
c_func
(paren
id|irq
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
op_logical_and
(paren
id|irqflags
op_amp
id|SA_SHIRQ
)paren
)paren
r_for
c_loop
(paren
id|tmp
op_assign
id|action
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
op_xor
(paren
id|irqflags
op_amp
id|SA_INTERRUPT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to mix fast and slow interrupts on IRQ%d &quot;
l_string|&quot;denied&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Or else! */
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* If this is flagged as statically allocated then we use our&n;&t; * private struct which is never freed.&n;&t; */
r_if
c_cond
(paren
id|irqflags
op_amp
id|SA_STATIC_ALLOC
)paren
r_if
c_cond
(paren
id|static_irq_count
OL
id|MAX_STATIC_ALLOC
)paren
(brace
id|action
op_assign
op_amp
id|static_irqaction
(braket
id|static_irq_count
op_increment
)braket
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Request for IRQ%d (%s) SA_STATIC_ALLOC failed &quot;
l_string|&quot;using kmalloc&bslash;n&quot;
comma
id|irq
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imap
)paren
(brace
r_int
id|ivindex
op_assign
(paren
op_star
id|imap
op_amp
(paren
id|SYSIO_IMAP_IGN
op_or
id|SYSIO_IMAP_INO
)paren
)paren
suffix:semicolon
id|ivector_to_mask
(braket
id|ivindex
)braket
op_assign
(paren
l_int|1
op_lshift
id|cpu_irq
)paren
suffix:semicolon
id|iclr
op_assign
id|imap_to_iclr
c_func
(paren
id|imap
)paren
suffix:semicolon
id|action-&gt;mask
op_assign
(paren
r_int
r_int
)paren
id|iclr
suffix:semicolon
id|irqflags
op_or_assign
id|SA_SYSIO_MASKED
suffix:semicolon
)brace
r_else
(brace
id|action-&gt;mask
op_assign
l_int|0
suffix:semicolon
)brace
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;name
op_assign
id|name
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_cookie
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action
suffix:semicolon
)brace
r_else
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
op_assign
id|action
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|irqaction
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
l_int|14
)paren
(brace
id|cpu_irq
op_assign
id|irq
suffix:semicolon
)brace
r_else
id|cpu_irq
op_assign
id|ino_to_pil
(braket
id|irq
)braket
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing free IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_cookie
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_eq
id|dev_cookie
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|action
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free shared IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SHIRQ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free shared IRQ %d with NULL device cookie&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_STATIC_ALLOC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to free statically allocated IRQ %d (%s)&bslash;n&quot;
comma
id|irq
comma
id|action-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_logical_and
id|tmp
)paren
(brace
id|tmp-&gt;next
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_else
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
op_assign
id|action-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SYSIO_MASKED
)paren
(brace
r_int
r_int
op_star
id|imap
op_assign
id|irq_to_imap
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_ne
l_int|NULL
)paren
(brace
id|ivector_to_mask
(braket
op_star
id|imap
op_amp
(paren
id|SYSIO_IMAP_IGN
op_or
id|SYSIO_IMAP_INO
)paren
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;free_irq: WHeee, SYSIO_MASKED yet no imap reg.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
)paren
(brace
id|disable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Per-processor IRQ locking depth, both SMP and non-SMP code use this. */
DECL|variable|local_irq_count
r_int
r_int
id|local_irq_count
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#ifndef __SMP__
DECL|variable|__sparc64_bh_counter
r_int
id|__sparc64_bh_counter
op_assign
l_int|0
suffix:semicolon
DECL|macro|irq_enter
mdefine_line|#define irq_enter(cpu, irq)&t;(local_irq_count[cpu]++)
DECL|macro|irq_exit
mdefine_line|#define irq_exit(cpu, irq)&t;(local_irq_count[cpu]--)
macro_line|#else
macro_line|#error SMP not supported on sparc64 just yet
macro_line|#endif /* __SMP__ */
DECL|function|report_spurious_ivec
r_void
id|report_spurious_ivec
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IVEC: Spurious interrupt vector received at (%016lx)&bslash;n&quot;
comma
id|regs-&gt;tpc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|unexpected_irq
r_void
id|unexpected_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|cpu_irq
suffix:semicolon
id|cpu_irq
op_assign
id|irq
op_amp
id|NR_IRQS
suffix:semicolon
id|action
op_assign
op_star
(paren
id|cpu_irq
op_plus
id|irq_action
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;Unexpected IRQ[%d]: &quot;
comma
id|irq
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;PC[%016lx] NPC[%016lx] FP[%016lx]&bslash;n&quot;
comma
id|regs-&gt;tpc
comma
id|regs-&gt;tnpc
comma
id|regs-&gt;u_regs
(braket
l_int|14
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Expecting: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;handler
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;[%s:%d:0x%016lx] &quot;
comma
id|action-&gt;name
comma
id|i
comma
(paren
r_int
r_int
)paren
id|action-&gt;handler
)paren
suffix:semicolon
)brace
)brace
)brace
id|prom_printf
c_func
(paren
l_string|&quot;AIEEE&bslash;n&quot;
)paren
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;bogus interrupt received&bslash;n&quot;
)paren
suffix:semicolon
id|prom_cmdline
(paren
)paren
suffix:semicolon
)brace
DECL|function|handler_irq
r_void
id|handler_irq
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* XXX */
r_if
c_cond
(paren
id|irq
op_ne
l_int|14
)paren
(brace
id|clear_softint
c_func
(paren
l_int|1
op_lshift
id|irq
)paren
suffix:semicolon
)brace
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
id|kstat.interrupts
(braket
id|irq
)braket
op_increment
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|action
op_logical_or
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|unexpected_irq
c_func
(paren
id|irq
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
)brace
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SYSIO_MASKED
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|action-&gt;mask
)paren
op_assign
id|SYSIO_ICLR_IDLE
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|action
op_assign
id|action-&gt;next
)paren
op_ne
l_int|NULL
)paren
(brace
suffix:semicolon
)brace
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_FD
r_extern
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|sparc_floppy_irq
r_void
id|sparc_floppy_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_cookie
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|irqaction
op_star
id|action
op_assign
op_star
(paren
id|irq
op_plus
id|irq_action
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|floppy_interrupt
c_func
(paren
id|irq
comma
id|dev_cookie
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action-&gt;flags
op_amp
id|SA_SYSIO_MASKED
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|action-&gt;mask
)paren
op_assign
id|SYSIO_ICLR_IDLE
suffix:semicolon
)brace
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* XXX This needs to be written for floppy driver, and soon will be necessary&n; * XXX for serial driver as well.&n; */
DECL|function|request_fast_irq
r_int
id|request_fast_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We really don&squot;t need these at all on the Sparc.  We only have&n; * stubs here because they are exported to modules.&n; */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|probe_irq_off
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* XXX This is a hack, make it per-cpu so that SMP port will work correctly&n; * XXX with mixed MHZ Ultras in the machine. -DaveM&n; */
DECL|variable|cpu_cfreq
r_static
r_int
r_int
id|cpu_cfreq
suffix:semicolon
DECL|variable|tick_offset
r_static
r_int
r_int
id|tick_offset
suffix:semicolon
multiline_comment|/* XXX This doesn&squot;t belong here, just do this cruft in the timer.c handler code. */
DECL|function|timer_handler
r_static
r_void
id|timer_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_extern
r_void
id|timer_interrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_int
r_int
id|compare
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|get_softint
(paren
)paren
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* Just to be sure... */
id|clear_softint
c_func
(paren
l_int|1
op_lshift
l_int|14
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Spurious level14 at %016lx&bslash;n&quot;
comma
id|regs-&gt;tpc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|timer_interrupt
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* Acknowledge INT_TIMER */
id|clear_softint
c_func
(paren
l_int|1
op_lshift
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set up for next timer tick. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rd&t;%%tick_cmpr, %0&bslash;n&bslash;t&quot;
l_string|&quot;add&t;%0, %1, %0&bslash;n&bslash;t&quot;
l_string|&quot;wr&t;%0, 0x0, %%tick_cmpr&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|compare
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|tick_offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This is called from time_init() to get the jiffies timer going. */
DECL|function|init_timers
r_void
id|init_timers
c_func
(paren
r_void
(paren
op_star
id|cfunc
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_int
id|node
comma
id|err
suffix:semicolon
multiline_comment|/* XXX FIX this for SMP -JJ */
id|node
op_assign
id|linux_cpus
(braket
l_int|0
)braket
dot
id|prom_node
suffix:semicolon
id|cpu_cfreq
op_assign
id|prom_getint
c_func
(paren
id|node
comma
l_string|&quot;clock-frequency&quot;
)paren
suffix:semicolon
id|tick_offset
op_assign
id|cpu_cfreq
op_div
id|HZ
suffix:semicolon
id|err
op_assign
id|request_irq
c_func
(paren
l_int|14
comma
id|timer_handler
comma
(paren
id|SA_INTERRUPT
op_or
id|SA_STATIC_ALLOC
)paren
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;Serious problem, cannot register timer interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;wr&t;%0, 0x0, %%tick_cmpr&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%%g0, 0x0, %%tick&quot;
suffix:colon
multiline_comment|/* No outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|tick_offset
)paren
)paren
suffix:semicolon
id|clear_softint
(paren
id|get_softint
(paren
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* We use this nowhere else, so only define it&squot;s layout here. */
DECL|struct|sun5_timer
r_struct
id|sun5_timer
(brace
DECL|member|count0
DECL|member|_unused0
r_volatile
id|u32
id|count0
comma
id|_unused0
suffix:semicolon
DECL|member|limit0
DECL|member|_unused1
r_volatile
id|u32
id|limit0
comma
id|_unused1
suffix:semicolon
DECL|member|count1
DECL|member|_unused2
r_volatile
id|u32
id|count1
comma
id|_unused2
suffix:semicolon
DECL|member|limit1
DECL|member|_unused3
r_volatile
id|u32
id|limit1
comma
id|_unused3
suffix:semicolon
DECL|variable|prom_timers
)brace
op_star
id|prom_timers
suffix:semicolon
DECL|function|map_prom_timers
r_static
r_void
id|map_prom_timers
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|tnode
comma
id|err
suffix:semicolon
multiline_comment|/* PROM timer node hangs out in the top level of device siblings... */
id|tnode
op_assign
id|prom_finddevice
c_func
(paren
l_string|&quot;/counter-timer&quot;
)paren
suffix:semicolon
multiline_comment|/* Assume if node is not present, PROM uses different tick mechanism&n;&t; * which we should not care about.&n;&t; */
r_if
c_cond
(paren
id|tnode
op_eq
l_int|0
)paren
(brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
id|prom_printf
c_func
(paren
l_string|&quot;AIEEE, no timers&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If PROM is really using this, it must be mapped by him. */
id|err
op_assign
id|prom_getproperty
c_func
(paren
id|tnode
comma
l_string|&quot;address&quot;
comma
(paren
r_char
op_star
)paren
id|addr
comma
r_sizeof
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
l_int|1
)paren
(brace
id|prom_printf
c_func
(paren
l_string|&quot;PROM does not have timer mapped, trying to continue.&bslash;n&quot;
)paren
suffix:semicolon
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prom_timers
op_assign
(paren
r_struct
id|sun5_timer
op_star
)paren
id|addr
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|kill_prom_timer
r_static
r_void
id|kill_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Just as in sun4c/sun4m PROM uses timer which ticks at IRQ 14.&n;&t; * We turn both off here just to be paranoid.&n;&t; */
id|prom_timers-&gt;limit0
op_assign
l_int|0
suffix:semicolon
id|prom_timers-&gt;limit1
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0 /* Unused at this time. -DaveM */
r_static
r_void
id|enable_prom_timer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prom_timers
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Set it to fire off every 10ms. */
id|prom_timers-&gt;limit1
op_assign
l_int|0xa000270f
suffix:semicolon
id|prom_timers-&gt;count1
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|init_IRQ
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|map_prom_timers
c_func
(paren
)paren
suffix:semicolon
id|kill_prom_timer
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_IVECS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ivector_to_mask
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need to clear any IRQ&squot;s pending in the soft interrupt&n;&t; * registers, a spurious one could be left around from the&n;&t; * PROM timer which we just disabled.&n;&t; */
id|clear_softint
c_func
(paren
id|get_softint
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Now that ivector table is initialized, it is safe&n;&t; * to receive IRQ vector traps.  We will normally take&n;&t; * one or two right now, in case some device PROM used&n;&t; * to boot us wants to speak to us.  We just ignore them.&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rdpr&t;%%pstate, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;or&t;%%g1, %0, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;wrpr&t;%%g1, 0x0, %%pstate&quot;
suffix:colon
multiline_comment|/* No outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
suffix:colon
l_string|&quot;g1&quot;
)paren
suffix:semicolon
)brace
eof
