multiline_comment|/*  $Id: process.c,v 1.113 2000/11/08 08:14:58 davem Exp $&n; *  arch/sparc64/kernel/process.c&n; *&n; *  Copyright (C) 1995, 1996 David S. Miller (davem@caip.rutgers.edu)&n; *  Copyright (C) 1996       Eddie C. Dost   (ecd@skynet.be)&n; *  Copyright (C) 1997, 1998 Jakub Jelinek   (jj@sunsite.mff.cuni.cz)&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of process handling..&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pstate.h&gt;
macro_line|#include &lt;asm/elf.h&gt;
macro_line|#include &lt;asm/fpumacro.h&gt;
multiline_comment|/* #define VERBOSE_SHOWREGS */
macro_line|#ifndef CONFIG_SMP
multiline_comment|/*&n; * the idle loop on a Sparc... ;)&n; */
DECL|function|cpu_idle
r_int
id|cpu_idle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;pid
op_ne
l_int|0
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* endless idle loop with no priority at all */
id|current-&gt;nice
op_assign
l_int|20
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
id|init_idle
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* If current-&gt;need_resched is zero we should really&n;&t;&t; * setup for a system wakup event and execute a shutdown&n;&t;&t; * instruction.&n;&t;&t; *&n;&t;&t; * But this requires writing back the contents of the&n;&t;&t; * L2 cache etc. so implement this later. -DaveM&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
id|current-&gt;need_resched
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|check_pgt_cache
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; * the idle loop on a UltraMultiPenguin...&n; */
DECL|macro|idle_me_harder
mdefine_line|#define idle_me_harder()&t;(cpu_data[current-&gt;processor].idle_volume += 1)
DECL|macro|unidle_me
mdefine_line|#define unidle_me()&t;&t;(cpu_data[current-&gt;processor].idle_volume = 0)
DECL|function|cpu_idle
r_int
id|cpu_idle
c_func
(paren
r_void
)paren
(brace
id|current-&gt;nice
op_assign
l_int|20
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
id|init_idle
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;need_resched
op_ne
l_int|0
)paren
(brace
id|unidle_me
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|check_pgt_cache
c_func
(paren
)paren
suffix:semicolon
)brace
id|idle_me_harder
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The store ordering is so that IRQ handlers on&n;&t;&t; * other cpus see our increasing idleness for the buddy&n;&t;&t; * redistribution algorithm.  -DaveM&n;&t;&t; */
id|membar
c_func
(paren
l_string|&quot;#StoreStore | #StoreLoad&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_extern
r_char
id|reboot_command
(braket
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_SUN_CONSOLE
r_extern
r_void
(paren
op_star
id|prom_palette
)paren
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|serial_console
suffix:semicolon
macro_line|#endif
DECL|function|machine_halt
r_void
id|machine_halt
c_func
(paren
r_void
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SUN_CONSOLE
r_if
c_cond
(paren
op_logical_neg
id|serial_console
op_logical_and
id|prom_palette
)paren
id|prom_palette
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|prom_halt
c_func
(paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Halt failed!&quot;
)paren
suffix:semicolon
)brace
DECL|function|machine_restart
r_void
id|machine_restart
c_func
(paren
r_char
op_star
id|cmd
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
id|strchr
(paren
id|reboot_command
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
op_star
id|p
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SUN_CONSOLE
r_if
c_cond
(paren
op_logical_neg
id|serial_console
op_logical_and
id|prom_palette
)paren
id|prom_palette
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cmd
)paren
id|prom_reboot
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|reboot_command
)paren
id|prom_reboot
c_func
(paren
id|reboot_command
)paren
suffix:semicolon
id|prom_reboot
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Reboot failed!&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_regwindow32
r_static
r_void
id|show_regwindow32
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|reg_window32
op_star
id|rw
suffix:semicolon
r_struct
id|reg_window32
id|r_w
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;flushw&quot;
)paren
suffix:semicolon
id|rw
op_assign
(paren
r_struct
id|reg_window32
op_star
)paren
(paren
(paren
r_int
)paren
(paren
r_int
)paren
id|regs-&gt;u_regs
(braket
l_int|14
)braket
)paren
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|USER_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|r_w
comma
id|rw
comma
r_sizeof
(paren
id|r_w
)paren
)paren
)paren
(brace
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rw
op_assign
op_amp
id|r_w
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;l0: %08x l1: %08x l2: %08x l3: %08x &quot;
l_string|&quot;l4: %08x l5: %08x l6: %08x l7: %08x&bslash;n&quot;
comma
id|rw-&gt;locals
(braket
l_int|0
)braket
comma
id|rw-&gt;locals
(braket
l_int|1
)braket
comma
id|rw-&gt;locals
(braket
l_int|2
)braket
comma
id|rw-&gt;locals
(braket
l_int|3
)braket
comma
id|rw-&gt;locals
(braket
l_int|4
)braket
comma
id|rw-&gt;locals
(braket
l_int|5
)braket
comma
id|rw-&gt;locals
(braket
l_int|6
)braket
comma
id|rw-&gt;locals
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i0: %08x i1: %08x i2: %08x i3: %08x &quot;
l_string|&quot;i4: %08x i5: %08x i6: %08x i7: %08x&bslash;n&quot;
comma
id|rw-&gt;ins
(braket
l_int|0
)braket
comma
id|rw-&gt;ins
(braket
l_int|1
)braket
comma
id|rw-&gt;ins
(braket
l_int|2
)braket
comma
id|rw-&gt;ins
(braket
l_int|3
)braket
comma
id|rw-&gt;ins
(braket
l_int|4
)braket
comma
id|rw-&gt;ins
(braket
l_int|5
)braket
comma
id|rw-&gt;ins
(braket
l_int|6
)braket
comma
id|rw-&gt;ins
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
DECL|function|show_regwindow
r_static
r_void
id|show_regwindow
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|reg_window
op_star
id|rw
suffix:semicolon
r_struct
id|reg_window
id|r_w
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;tstate
op_amp
id|TSTATE_PRIV
)paren
op_logical_or
op_logical_neg
(paren
id|current-&gt;thread.flags
op_amp
id|SPARC_FLAG_32BIT
)paren
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;flushw&quot;
)paren
suffix:semicolon
id|rw
op_assign
(paren
r_struct
id|reg_window
op_star
)paren
(paren
id|regs-&gt;u_regs
(braket
l_int|14
)braket
op_plus
id|STACK_BIAS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;tstate
op_amp
id|TSTATE_PRIV
)paren
)paren
(brace
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|USER_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|r_w
comma
id|rw
comma
r_sizeof
(paren
id|r_w
)paren
)paren
)paren
(brace
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rw
op_assign
op_amp
id|r_w
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|show_regwindow32
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;l0: %016lx l1: %016lx l2: %016lx l3: %016lx&bslash;n&quot;
comma
id|rw-&gt;locals
(braket
l_int|0
)braket
comma
id|rw-&gt;locals
(braket
l_int|1
)braket
comma
id|rw-&gt;locals
(braket
l_int|2
)braket
comma
id|rw-&gt;locals
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;l4: %016lx l5: %016lx l6: %016lx l7: %016lx&bslash;n&quot;
comma
id|rw-&gt;locals
(braket
l_int|4
)braket
comma
id|rw-&gt;locals
(braket
l_int|5
)braket
comma
id|rw-&gt;locals
(braket
l_int|6
)braket
comma
id|rw-&gt;locals
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i0: %016lx i1: %016lx i2: %016lx i3: %016lx&bslash;n&quot;
comma
id|rw-&gt;ins
(braket
l_int|0
)braket
comma
id|rw-&gt;ins
(braket
l_int|1
)braket
comma
id|rw-&gt;ins
(braket
l_int|2
)braket
comma
id|rw-&gt;ins
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i4: %016lx i5: %016lx i6: %016lx i7: %016lx&bslash;n&quot;
comma
id|rw-&gt;ins
(braket
l_int|4
)braket
comma
id|rw-&gt;ins
(braket
l_int|5
)braket
comma
id|rw-&gt;ins
(braket
l_int|6
)braket
comma
id|rw-&gt;ins
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
DECL|function|show_stackframe
r_void
id|show_stackframe
c_func
(paren
r_struct
id|sparc_stackf
op_star
id|sf
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
op_star
id|stk
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;l0: %016lx l1: %016lx l2: %016lx l3: %016lx&bslash;n&quot;
l_string|&quot;l4: %016lx l5: %016lx l6: %016lx l7: %016lx&bslash;n&quot;
comma
id|sf-&gt;locals
(braket
l_int|0
)braket
comma
id|sf-&gt;locals
(braket
l_int|1
)braket
comma
id|sf-&gt;locals
(braket
l_int|2
)braket
comma
id|sf-&gt;locals
(braket
l_int|3
)braket
comma
id|sf-&gt;locals
(braket
l_int|4
)braket
comma
id|sf-&gt;locals
(braket
l_int|5
)braket
comma
id|sf-&gt;locals
(braket
l_int|6
)braket
comma
id|sf-&gt;locals
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i0: %016lx i1: %016lx i2: %016lx i3: %016lx&bslash;n&quot;
l_string|&quot;i4: %016lx i5: %016lx fp: %016lx ret_pc: %016lx&bslash;n&quot;
comma
id|sf-&gt;ins
(braket
l_int|0
)braket
comma
id|sf-&gt;ins
(braket
l_int|1
)braket
comma
id|sf-&gt;ins
(braket
l_int|2
)braket
comma
id|sf-&gt;ins
(braket
l_int|3
)braket
comma
id|sf-&gt;ins
(braket
l_int|4
)braket
comma
id|sf-&gt;ins
(braket
l_int|5
)braket
comma
(paren
r_int
r_int
)paren
id|sf-&gt;fp
comma
id|sf-&gt;callers_pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sp: %016lx x0: %016lx x1: %016lx x2: %016lx&bslash;n&quot;
l_string|&quot;x3: %016lx x4: %016lx x5: %016lx xx: %016lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|sf-&gt;structptr
comma
id|sf-&gt;xargs
(braket
l_int|0
)braket
comma
id|sf-&gt;xargs
(braket
l_int|1
)braket
comma
id|sf-&gt;xargs
(braket
l_int|2
)braket
comma
id|sf-&gt;xargs
(braket
l_int|3
)braket
comma
id|sf-&gt;xargs
(braket
l_int|4
)braket
comma
id|sf-&gt;xargs
(braket
l_int|5
)braket
comma
id|sf-&gt;xxargs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
r_int
r_int
)paren
id|sf-&gt;fp
)paren
op_minus
(paren
(paren
r_int
r_int
)paren
id|sf
)paren
suffix:semicolon
id|size
op_sub_assign
id|STACKFRAME_SZ
suffix:semicolon
id|stk
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|sf
op_plus
id|STACKFRAME_SZ
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|printk
c_func
(paren
l_string|&quot;s%d: %016lx&bslash;n&quot;
comma
id|i
op_increment
comma
op_star
id|stk
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|size
op_sub_assign
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_stackframe32
r_void
id|show_stackframe32
c_func
(paren
r_struct
id|sparc_stackf32
op_star
id|sf
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_int
op_star
id|stk
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;l0: %08x l1: %08x l2: %08x l3: %08x&bslash;n&quot;
comma
id|sf-&gt;locals
(braket
l_int|0
)braket
comma
id|sf-&gt;locals
(braket
l_int|1
)braket
comma
id|sf-&gt;locals
(braket
l_int|2
)braket
comma
id|sf-&gt;locals
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;l4: %08x l5: %08x l6: %08x l7: %08x&bslash;n&quot;
comma
id|sf-&gt;locals
(braket
l_int|4
)braket
comma
id|sf-&gt;locals
(braket
l_int|5
)braket
comma
id|sf-&gt;locals
(braket
l_int|6
)braket
comma
id|sf-&gt;locals
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i0: %08x i1: %08x i2: %08x i3: %08x&bslash;n&quot;
comma
id|sf-&gt;ins
(braket
l_int|0
)braket
comma
id|sf-&gt;ins
(braket
l_int|1
)braket
comma
id|sf-&gt;ins
(braket
l_int|2
)braket
comma
id|sf-&gt;ins
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i4: %08x i5: %08x fp: %08x ret_pc: %08x&bslash;n&quot;
comma
id|sf-&gt;ins
(braket
l_int|4
)braket
comma
id|sf-&gt;ins
(braket
l_int|5
)braket
comma
id|sf-&gt;fp
comma
id|sf-&gt;callers_pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sp: %08x x0: %08x x1: %08x x2: %08x&bslash;n&quot;
l_string|&quot;x3: %08x x4: %08x x5: %08x xx: %08x&bslash;n&quot;
comma
id|sf-&gt;structptr
comma
id|sf-&gt;xargs
(braket
l_int|0
)braket
comma
id|sf-&gt;xargs
(braket
l_int|1
)braket
comma
id|sf-&gt;xargs
(braket
l_int|2
)braket
comma
id|sf-&gt;xargs
(braket
l_int|3
)braket
comma
id|sf-&gt;xargs
(braket
l_int|4
)braket
comma
id|sf-&gt;xargs
(braket
l_int|5
)braket
comma
id|sf-&gt;xxargs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
r_int
r_int
)paren
id|sf-&gt;fp
)paren
op_minus
(paren
(paren
r_int
r_int
)paren
id|sf
)paren
suffix:semicolon
id|size
op_sub_assign
id|STACKFRAME32_SZ
suffix:semicolon
id|stk
op_assign
(paren
r_int
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|sf
op_plus
id|STACKFRAME32_SZ
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|printk
c_func
(paren
l_string|&quot;s%d: %08x&bslash;n&quot;
comma
id|i
op_increment
comma
op_star
id|stk
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|size
op_sub_assign
r_sizeof
(paren
r_int
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|variable|regdump_lock
r_static
id|spinlock_t
id|regdump_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#endif
DECL|function|__show_regs
r_void
id|__show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|regdump_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU[%d]: local_irq_count[%u] irqs_running[%d]&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|local_irq_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
comma
id|irqs_running
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;TSTATE: %016lx TPC: %016lx TNPC: %016lx Y: %08x&bslash;n&quot;
comma
id|regs-&gt;tstate
comma
id|regs-&gt;tpc
comma
id|regs-&gt;tnpc
comma
id|regs-&gt;y
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;g0: %016lx g1: %016lx g2: %016lx g3: %016lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|0
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|1
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|2
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;g4: %016lx g5: %016lx g6: %016lx g7: %016lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|4
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|5
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|6
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;o0: %016lx o1: %016lx o2: %016lx o3: %016lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|8
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|9
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|10
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;o4: %016lx o5: %016lx sp: %016lx ret_pc: %016lx&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|12
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|13
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|14
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|show_regwindow
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|regdump_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef VERBOSE_SHOWREGS
DECL|function|idump_from_user
r_static
r_void
id|idump_from_user
(paren
r_int
r_int
op_star
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|code
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|pc
)paren
op_amp
l_int|3
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|pc
op_sub_assign
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|get_user
c_func
(paren
id|code
comma
id|pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c%08x%c&quot;
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&lt;&squot;
comma
id|code
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
id|pc
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef VERBOSE_SHOWREGS
r_extern
r_int
id|etrap
comma
id|etraptl1
suffix:semicolon
macro_line|#endif
id|__show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
(brace
r_extern
r_void
id|smp_report_regs
c_func
(paren
r_void
)paren
suffix:semicolon
id|smp_report_regs
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef VERBOSE_SHOWREGS&t;
r_if
c_cond
(paren
id|regs-&gt;tpc
op_ge
op_amp
id|etrap
op_logical_and
id|regs-&gt;tpc
OL
op_amp
id|etraptl1
op_logical_and
id|regs-&gt;u_regs
(braket
l_int|14
)braket
op_ge
(paren
r_int
)paren
id|current
op_minus
id|PAGE_SIZE
op_logical_and
id|regs-&gt;u_regs
(braket
l_int|14
)braket
OL
(paren
r_int
)paren
id|current
op_plus
l_int|6
op_star
id|PAGE_SIZE
)paren
(brace
id|printk
(paren
l_string|&quot;*********parent**********&bslash;n&quot;
)paren
suffix:semicolon
id|__show_regs
c_func
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|regs-&gt;u_regs
(braket
l_int|14
)braket
op_plus
id|STACK_BIAS
op_plus
id|REGWIN_SZ
)paren
)paren
suffix:semicolon
id|idump_from_user
c_func
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|regs-&gt;u_regs
(braket
l_int|14
)braket
op_plus
id|STACK_BIAS
op_plus
id|REGWIN_SZ
)paren
)paren
op_member_access_from_pointer
id|tpc
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;*********endpar**********&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|show_regs32
r_void
id|show_regs32
c_func
(paren
r_struct
id|pt_regs32
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PSR: %08x PC: %08x NPC: %08x Y: %08x&bslash;n&quot;
comma
id|regs-&gt;psr
comma
id|regs-&gt;pc
comma
id|regs-&gt;npc
comma
id|regs-&gt;y
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;g0: %08x g1: %08x g2: %08x g3: %08x &quot;
comma
id|regs-&gt;u_regs
(braket
l_int|0
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|1
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|2
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;g4: %08x g5: %08x g6: %08x g7: %08x&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|4
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|5
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|6
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;o0: %08x o1: %08x o2: %08x o3: %08x &quot;
comma
id|regs-&gt;u_regs
(braket
l_int|8
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|9
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|10
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;o4: %08x o5: %08x sp: %08x ret_pc: %08x&bslash;n&quot;
comma
id|regs-&gt;u_regs
(braket
l_int|12
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|13
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|14
)braket
comma
id|regs-&gt;u_regs
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
DECL|function|show_thread
r_void
id|show_thread
c_func
(paren
r_struct
id|thread_struct
op_star
id|thread
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;kregs:             0x%016lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|thread-&gt;kregs
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|thread-&gt;kregs
)paren
suffix:semicolon
macro_line|#endif&t;
id|printk
c_func
(paren
l_string|&quot;ksp:               0x%016lx&bslash;n&quot;
comma
id|thread-&gt;ksp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread-&gt;w_saved
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSWINS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|thread-&gt;rwbuf_stkptrs
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reg_window[%d]:&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;stack ptr:         0x%016lx&bslash;n&quot;
comma
id|thread-&gt;rwbuf_stkptrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;w_saved:           0x%04x&bslash;n&quot;
comma
id|thread-&gt;w_saved
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;flags:             0x%08x&bslash;n&quot;
comma
id|thread-&gt;flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_ds:        0x%x&bslash;n&quot;
comma
id|thread-&gt;current_ds.seg
)paren
suffix:semicolon
)brace
multiline_comment|/* Free current thread data structures etc.. */
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;utraps
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;utraps
(braket
l_int|0
)braket
OL
l_int|2
)paren
id|kfree
(paren
id|t-&gt;utraps
)paren
suffix:semicolon
r_else
id|t-&gt;utraps
(braket
l_int|0
)braket
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Turn off performance counters if on. */
r_if
c_cond
(paren
id|t-&gt;flags
op_amp
id|SPARC_FLAG_PERFCTR
)paren
(brace
id|t-&gt;user_cntd0
op_assign
id|t-&gt;user_cntd1
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;pcr_reg
op_assign
l_int|0
suffix:semicolon
id|t-&gt;flags
op_and_assign
op_complement
(paren
id|SPARC_FLAG_PERFCTR
)paren
suffix:semicolon
id|write_pcr
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;mm
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;flags
op_amp
id|SPARC_FLAG_32BIT
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|pgd_t
op_star
id|pgd0
op_assign
op_amp
id|mm-&gt;pgd
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_int
id|pgd_cache
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd0
)paren
)paren
(brace
id|pmd_t
op_star
id|page
op_assign
id|get_pmd_fast
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(paren
r_void
)paren
id|get_pmd_slow
c_func
(paren
id|pgd0
comma
l_int|0
)paren
suffix:semicolon
r_else
id|pgd_set
c_func
(paren
id|pgd0
comma
id|page
)paren
suffix:semicolon
)brace
id|pgd_cache
op_assign
id|pgd_val
c_func
(paren
op_star
id|pgd0
)paren
op_lshift
l_int|11UL
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;stxa %0, [%1] %2&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|pgd_cache
)paren
comma
l_string|&quot;r&quot;
(paren
id|TSB_REG
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_DMMU
)paren
)paren
suffix:semicolon
)brace
)brace
id|t-&gt;w_saved
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn off performance counters if on. */
r_if
c_cond
(paren
id|t-&gt;flags
op_amp
id|SPARC_FLAG_PERFCTR
)paren
(brace
id|t-&gt;user_cntd0
op_assign
id|t-&gt;user_cntd1
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;pcr_reg
op_assign
l_int|0
suffix:semicolon
id|t-&gt;flags
op_and_assign
op_complement
(paren
id|SPARC_FLAG_PERFCTR
)paren
suffix:semicolon
id|write_pcr
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear FPU register state. */
id|t-&gt;fpsaved
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;current_ds.seg
op_ne
id|ASI_AIUS
)paren
id|set_fs
c_func
(paren
id|USER_DS
)paren
suffix:semicolon
multiline_comment|/* Init new signal delivery disposition. */
id|t-&gt;flags
op_and_assign
op_complement
id|SPARC_FLAG_NEWSIGNALS
suffix:semicolon
)brace
multiline_comment|/* It&squot;s a bit more tricky when 64-bit tasks are involved... */
DECL|function|clone_stackframe
r_static
r_int
r_int
id|clone_stackframe
c_func
(paren
r_int
r_int
id|csp
comma
r_int
r_int
id|psp
)paren
(brace
r_int
r_int
id|fp
comma
id|distance
comma
id|rval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|current-&gt;thread.flags
op_amp
id|SPARC_FLAG_32BIT
)paren
)paren
(brace
id|csp
op_add_assign
id|STACK_BIAS
suffix:semicolon
id|psp
op_add_assign
id|STACK_BIAS
suffix:semicolon
id|__get_user
c_func
(paren
id|fp
comma
op_amp
(paren
(paren
(paren
r_struct
id|reg_window
op_star
)paren
id|psp
)paren
op_member_access_from_pointer
id|ins
(braket
l_int|6
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
id|__get_user
c_func
(paren
id|fp
comma
op_amp
(paren
(paren
(paren
r_struct
id|reg_window32
op_star
)paren
id|psp
)paren
op_member_access_from_pointer
id|ins
(braket
l_int|6
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Now 8-byte align the stack as this is mandatory in the&n;&t; * Sparc ABI due to how register windows work.  This hides&n;&t; * the restriction from thread libraries etc.  -DaveM&n;&t; */
id|csp
op_and_assign
op_complement
l_int|7UL
suffix:semicolon
id|distance
op_assign
id|fp
op_minus
id|psp
suffix:semicolon
id|rval
op_assign
(paren
id|csp
op_minus
id|distance
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_in_user
c_func
(paren
id|rval
comma
id|psp
comma
id|distance
)paren
)paren
id|rval
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|SPARC_FLAG_32BIT
)paren
(brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
(paren
id|u32
)paren
id|csp
)paren
comma
op_amp
(paren
(paren
(paren
r_struct
id|reg_window32
op_star
)paren
id|rval
)paren
op_member_access_from_pointer
id|ins
(braket
l_int|6
)braket
)paren
)paren
)paren
id|rval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
(paren
(paren
id|u64
)paren
id|csp
op_minus
id|STACK_BIAS
)paren
comma
op_amp
(paren
(paren
(paren
r_struct
id|reg_window
op_star
)paren
id|rval
)paren
op_member_access_from_pointer
id|ins
(braket
l_int|6
)braket
)paren
)paren
)paren
id|rval
op_assign
l_int|0
suffix:semicolon
r_else
id|rval
op_assign
id|rval
op_minus
id|STACK_BIAS
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/* Standard stuff. */
DECL|function|shift_window_buffer
r_static
r_inline
r_void
id|shift_window_buffer
c_func
(paren
r_int
id|first_win
comma
r_int
id|last_win
comma
r_struct
id|thread_struct
op_star
id|t
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|first_win
suffix:semicolon
id|i
OL
id|last_win
suffix:semicolon
id|i
op_increment
)paren
(brace
id|t-&gt;rwbuf_stkptrs
(braket
id|i
)braket
op_assign
id|t-&gt;rwbuf_stkptrs
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|t-&gt;reg_window
(braket
id|i
)braket
comma
op_amp
id|t-&gt;reg_window
(braket
id|i
op_plus
l_int|1
)braket
comma
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|synchronize_user_stack
r_void
id|synchronize_user_stack
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_int
r_int
id|window
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|window
op_assign
id|t-&gt;w_saved
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|winsize
op_assign
id|REGWIN_SZ
suffix:semicolon
r_int
id|bias
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;flags
op_amp
id|SPARC_FLAG_32BIT
)paren
id|winsize
op_assign
id|REGWIN32_SZ
suffix:semicolon
r_else
id|bias
op_assign
id|STACK_BIAS
suffix:semicolon
id|window
op_sub_assign
l_int|1
suffix:semicolon
r_do
(brace
r_int
r_int
id|sp
op_assign
(paren
id|t-&gt;rwbuf_stkptrs
(braket
id|window
)braket
op_plus
id|bias
)paren
suffix:semicolon
r_struct
id|reg_window
op_star
id|rwin
op_assign
op_amp
id|t-&gt;reg_window
(braket
id|window
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|sp
comma
id|rwin
comma
id|winsize
)paren
)paren
(brace
id|shift_window_buffer
c_func
(paren
id|window
comma
id|t-&gt;w_saved
op_minus
l_int|1
comma
id|t
)paren
suffix:semicolon
id|t-&gt;w_saved
op_decrement
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|window
op_decrement
)paren
suffix:semicolon
)brace
)brace
DECL|function|fault_in_user_windows
r_void
id|fault_in_user_windows
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_int
r_int
id|window
suffix:semicolon
r_int
id|winsize
op_assign
id|REGWIN_SZ
suffix:semicolon
r_int
id|bias
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;flags
op_amp
id|SPARC_FLAG_32BIT
)paren
id|winsize
op_assign
id|REGWIN32_SZ
suffix:semicolon
r_else
id|bias
op_assign
id|STACK_BIAS
suffix:semicolon
id|flush_user_windows
c_func
(paren
)paren
suffix:semicolon
id|window
op_assign
id|t-&gt;w_saved
suffix:semicolon
r_if
c_cond
(paren
id|window
op_ne
l_int|0
)paren
(brace
id|window
op_sub_assign
l_int|1
suffix:semicolon
r_do
(brace
r_int
r_int
id|sp
op_assign
(paren
id|t-&gt;rwbuf_stkptrs
(braket
id|window
)braket
op_plus
id|bias
)paren
suffix:semicolon
r_struct
id|reg_window
op_star
id|rwin
op_assign
op_amp
id|t-&gt;reg_window
(braket
id|window
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|sp
comma
id|rwin
comma
id|winsize
)paren
)paren
r_goto
id|barf
suffix:semicolon
)brace
r_while
c_loop
(paren
id|window
op_decrement
)paren
suffix:semicolon
)brace
id|t-&gt;w_saved
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
id|barf
suffix:colon
id|t-&gt;w_saved
op_assign
id|window
op_plus
l_int|1
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGILL
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy a Sparc thread.  The fork() return value conventions&n; * under SunOS are nothing short of bletcherous:&n; * Parent --&gt;  %o0 == childs  pid, %o1 == 0&n; * Child  --&gt;  %o0 == parents pid, %o1 == 1&n; *&n; * NOTE: We have a separate fork kpsr/kwim because&n; *       the parent could change these values between&n; *       sys_fork invocation and when we reach here&n; *       if the parent should sleep while trying to&n; *       allocate the task_struct and kernel stack in&n; *       do_fork().&n; */
DECL|function|copy_thread
r_int
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|sp
comma
r_int
r_int
id|unused
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|p-&gt;thread
suffix:semicolon
r_char
op_star
id|child_trap_frame
suffix:semicolon
multiline_comment|/* Calculate offset to stack_frame &amp; pt_regs */
id|child_trap_frame
op_assign
(paren
(paren
r_char
op_star
)paren
id|p
)paren
op_plus
(paren
(paren
id|PAGE_SIZE
op_lshift
l_int|1
)paren
op_minus
(paren
id|TRACEREG_SZ
op_plus
id|REGWIN_SZ
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|child_trap_frame
comma
(paren
(paren
(paren
r_struct
id|reg_window
op_star
)paren
id|regs
)paren
op_minus
l_int|1
)paren
comma
(paren
id|TRACEREG_SZ
op_plus
id|REGWIN_SZ
)paren
)paren
suffix:semicolon
id|t-&gt;ksp
op_assign
(paren
(paren
r_int
r_int
)paren
id|child_trap_frame
)paren
op_minus
id|STACK_BIAS
suffix:semicolon
id|t-&gt;flags
op_or_assign
id|SPARC_FLAG_NEWCHILD
suffix:semicolon
id|t-&gt;kregs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|child_trap_frame
op_plus
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
suffix:semicolon
id|t-&gt;cwp
op_assign
(paren
id|regs-&gt;tstate
op_plus
l_int|1
)paren
op_amp
id|TSTATE_CWP
suffix:semicolon
id|t-&gt;fpsaved
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;tstate
op_amp
id|TSTATE_PRIV
)paren
(brace
multiline_comment|/* Special case, if we are spawning a kernel thread from&n;&t;&t; * a userspace task (via KMOD, NFS, or similar) we must&n;&t;&t; * disable performance counters in the child because the&n;&t;&t; * address space and protection realm are changing.&n;&t;&t; */
r_if
c_cond
(paren
id|t-&gt;flags
op_amp
id|SPARC_FLAG_PERFCTR
)paren
(brace
id|t-&gt;user_cntd0
op_assign
id|t-&gt;user_cntd1
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;pcr_reg
op_assign
l_int|0
suffix:semicolon
id|t-&gt;flags
op_and_assign
op_complement
(paren
id|SPARC_FLAG_PERFCTR
)paren
suffix:semicolon
)brace
id|t-&gt;kregs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_assign
id|p-&gt;thread.ksp
suffix:semicolon
id|t-&gt;current_ds
op_assign
id|KERNEL_DS
suffix:semicolon
id|flush_register_windows
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|t-&gt;ksp
op_plus
id|STACK_BIAS
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|regs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_plus
id|STACK_BIAS
)paren
comma
r_sizeof
(paren
r_struct
id|reg_window
)paren
)paren
suffix:semicolon
id|t-&gt;kregs-&gt;u_regs
(braket
id|UREG_G6
)braket
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|t-&gt;flags
op_amp
id|SPARC_FLAG_32BIT
)paren
(brace
id|sp
op_and_assign
l_int|0x00000000ffffffffUL
suffix:semicolon
id|regs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_and_assign
l_int|0x00000000ffffffffUL
suffix:semicolon
)brace
id|t-&gt;kregs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_assign
id|sp
suffix:semicolon
id|t-&gt;current_ds
op_assign
id|USER_DS
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_ne
id|regs-&gt;u_regs
(braket
id|UREG_FP
)braket
)paren
(brace
r_int
r_int
id|csp
suffix:semicolon
id|csp
op_assign
id|clone_stackframe
c_func
(paren
id|sp
comma
id|regs-&gt;u_regs
(braket
id|UREG_FP
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csp
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|t-&gt;kregs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_assign
id|csp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;utraps
)paren
id|t-&gt;utraps
(braket
l_int|0
)braket
op_increment
suffix:semicolon
)brace
multiline_comment|/* Set the return value for the child. */
id|t-&gt;kregs-&gt;u_regs
(braket
id|UREG_I0
)braket
op_assign
id|current-&gt;pid
suffix:semicolon
id|t-&gt;kregs-&gt;u_regs
(braket
id|UREG_I1
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set the second return value for the parent. */
id|regs-&gt;u_regs
(braket
id|UREG_I1
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the mechanism for creating a new kernel thread.&n; *&n; * NOTE! Only a kernel-only process(ie the swapper or direct descendants&n; * who haven&squot;t done an &quot;execve()&quot;) should use this: it will work within&n; * a system call from a &quot;real&quot; process, but the process memory space will&n; * not be free&squot;d until both the parent and the child have exited.&n; */
DECL|function|kernel_thread
id|pid_t
id|kernel_thread
c_func
(paren
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
comma
r_int
r_int
id|flags
)paren
(brace
r_int
id|retval
suffix:semicolon
multiline_comment|/* If the parent runs before fn(arg) is called by the child,&n;&t; * the input registers of this function can be clobbered.&n;&t; * So we stash &squot;fn&squot; and &squot;arg&squot; into global registers which&n;&t; * will not be modified by the parent.&n;&t; */
id|__asm__
id|__volatile
c_func
(paren
l_string|&quot;mov %4, %%g2&bslash;n&bslash;t&quot;
multiline_comment|/* Save FN into global */
l_string|&quot;mov %5, %%g3&bslash;n&bslash;t&quot;
multiline_comment|/* Save ARG into global */
l_string|&quot;mov %1, %%g1&bslash;n&bslash;t&quot;
multiline_comment|/* Clone syscall nr. */
l_string|&quot;mov %2, %%o0&bslash;n&bslash;t&quot;
multiline_comment|/* Clone flags. */
l_string|&quot;mov 0, %%o1&bslash;n&bslash;t&quot;
multiline_comment|/* usp arg == 0 */
l_string|&quot;t 0x6d&bslash;n&bslash;t&quot;
multiline_comment|/* Linux/Sparc clone(). */
l_string|&quot;brz,a,pn %%o1, 1f&bslash;n&bslash;t&quot;
multiline_comment|/* Parent, just return. */
l_string|&quot; mov %%o0, %0&bslash;n&bslash;t&quot;
l_string|&quot;jmpl %%g2, %%o7&bslash;n&bslash;t&quot;
multiline_comment|/* Call the function. */
l_string|&quot; mov %%g3, %%o0&bslash;n&bslash;t&quot;
multiline_comment|/* Set arg in delay. */
l_string|&quot;mov %3, %%g1&bslash;n&bslash;t&quot;
l_string|&quot;t 0x6d&bslash;n&bslash;t&quot;
multiline_comment|/* Linux/Sparc exit(). */
multiline_comment|/* Notreached by child. */
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|retval
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|__NR_clone
)paren
comma
l_string|&quot;r&quot;
(paren
id|flags
op_or
id|CLONE_VM
)paren
comma
l_string|&quot;i&quot;
(paren
id|__NR_exit
)paren
comma
l_string|&quot;r&quot;
(paren
id|fn
)paren
comma
l_string|&quot;r&quot;
(paren
id|arg
)paren
suffix:colon
l_string|&quot;g1&quot;
comma
l_string|&quot;g2&quot;
comma
l_string|&quot;g3&quot;
comma
l_string|&quot;o0&quot;
comma
l_string|&quot;o1&quot;
comma
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * fill in the user structure for a core dump..&n; */
DECL|function|dump_thread
r_void
id|dump_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|user
op_star
id|dump
)paren
(brace
macro_line|#if 1
multiline_comment|/* Only should be used for SunOS and ancient a.out&n;&t; * SparcLinux binaries...  Fixme some day when bored.&n;&t; * But for now at least plug the security hole :-)&n;&t; */
id|memset
c_func
(paren
id|dump
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|user
)paren
)paren
suffix:semicolon
macro_line|#else
r_int
r_int
id|first_stack_page
suffix:semicolon
id|dump-&gt;magic
op_assign
id|SUNOS_CORE_MAGIC
suffix:semicolon
id|dump-&gt;len
op_assign
r_sizeof
(paren
r_struct
id|user
)paren
suffix:semicolon
id|dump-&gt;regs.psr
op_assign
id|regs-&gt;psr
suffix:semicolon
id|dump-&gt;regs.pc
op_assign
id|regs-&gt;pc
suffix:semicolon
id|dump-&gt;regs.npc
op_assign
id|regs-&gt;npc
suffix:semicolon
id|dump-&gt;regs.y
op_assign
id|regs-&gt;y
suffix:semicolon
multiline_comment|/* fuck me plenty */
id|memcpy
c_func
(paren
op_amp
id|dump-&gt;regs.regs
(braket
l_int|0
)braket
comma
op_amp
id|regs-&gt;u_regs
(braket
l_int|1
)braket
comma
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|15
)paren
)paren
suffix:semicolon
id|dump-&gt;u_tsize
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|current-&gt;mm-&gt;end_code
)paren
op_minus
(paren
(paren
r_int
r_int
)paren
id|current-&gt;mm-&gt;start_code
)paren
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|dump-&gt;u_dsize
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|current-&gt;mm-&gt;brk
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|dump-&gt;u_dsize
op_sub_assign
id|dump-&gt;u_tsize
suffix:semicolon
id|dump-&gt;u_dsize
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|first_stack_page
op_assign
(paren
id|regs-&gt;u_regs
(braket
id|UREG_FP
)braket
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|dump-&gt;u_ssize
op_assign
(paren
id|TASK_SIZE
op_minus
id|first_stack_page
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dump-&gt;fpu.fpstatus.fregs.regs
(braket
l_int|0
)braket
comma
op_amp
id|current-&gt;thread.float_regs
(braket
l_int|0
)braket
comma
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|32
)paren
)paren
suffix:semicolon
id|dump-&gt;fpu.fpstatus.fsr
op_assign
id|current-&gt;thread.fsr
suffix:semicolon
id|dump-&gt;fpu.fpstatus.flags
op_assign
id|dump-&gt;fpu.fpstatus.extra
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;
)brace
r_typedef
r_struct
(brace
r_union
(brace
DECL|member|pr_regs
r_int
r_int
id|pr_regs
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|pr_dregs
r_int
r_int
id|pr_dregs
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|pr_fr
)brace
id|pr_fr
suffix:semicolon
DECL|member|__unused
r_int
r_int
id|__unused
suffix:semicolon
DECL|member|pr_fsr
r_int
r_int
id|pr_fsr
suffix:semicolon
DECL|member|pr_qcnt
r_int
r_char
id|pr_qcnt
suffix:semicolon
DECL|member|pr_q_entrysize
r_int
r_char
id|pr_q_entrysize
suffix:semicolon
DECL|member|pr_en
r_int
r_char
id|pr_en
suffix:semicolon
DECL|member|pr_q
r_int
r_int
id|pr_q
(braket
l_int|64
)braket
suffix:semicolon
DECL|typedef|elf_fpregset_t32
)brace
id|elf_fpregset_t32
suffix:semicolon
multiline_comment|/*&n; * fill in the fpu structure for a core dump.&n; */
DECL|function|dump_fpu
r_int
id|dump_fpu
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|elf_fpregset_t
op_star
id|fpregs
)paren
(brace
r_int
r_int
op_star
id|kfpregs
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|current
)paren
op_plus
id|AOFF_task_fpregs
)paren
suffix:semicolon
r_int
r_int
id|fprs
op_assign
id|current-&gt;thread.fpsaved
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;thread.flags
op_amp
id|SPARC_FLAG_32BIT
)paren
op_ne
l_int|0
)paren
(brace
id|elf_fpregset_t32
op_star
id|fpregs32
op_assign
(paren
id|elf_fpregset_t32
op_star
)paren
id|fpregs
suffix:semicolon
r_if
c_cond
(paren
id|fprs
op_amp
id|FPRS_DL
)paren
id|memcpy
c_func
(paren
op_amp
id|fpregs32-&gt;pr_fr.pr_regs
(braket
l_int|0
)braket
comma
id|kfpregs
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|32
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
op_amp
id|fpregs32-&gt;pr_fr.pr_regs
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|32
)paren
suffix:semicolon
id|fpregs32-&gt;pr_qcnt
op_assign
l_int|0
suffix:semicolon
id|fpregs32-&gt;pr_q_entrysize
op_assign
l_int|8
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|fpregs32-&gt;pr_q
(braket
l_int|0
)braket
comma
l_int|0
comma
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|64
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fprs
op_amp
id|FPRS_FEF
)paren
(brace
id|fpregs32-&gt;pr_fsr
op_assign
(paren
r_int
r_int
)paren
id|current-&gt;thread.xfsr
(braket
l_int|0
)braket
suffix:semicolon
id|fpregs32-&gt;pr_en
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|fpregs32-&gt;pr_fsr
op_assign
l_int|0
suffix:semicolon
id|fpregs32-&gt;pr_en
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|fprs
op_amp
id|FPRS_DL
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|fpregs-&gt;pr_regs
(braket
l_int|0
)braket
comma
id|kfpregs
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|32
)paren
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
op_amp
id|fpregs-&gt;pr_regs
(braket
l_int|0
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fprs
op_amp
id|FPRS_DU
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|fpregs-&gt;pr_regs
(braket
l_int|16
)braket
comma
id|kfpregs
op_plus
l_int|16
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|32
)paren
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
op_amp
id|fpregs-&gt;pr_regs
(braket
l_int|16
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fprs
op_amp
id|FPRS_FEF
)paren
(brace
id|fpregs-&gt;pr_fsr
op_assign
id|current-&gt;thread.xfsr
(braket
l_int|0
)braket
suffix:semicolon
id|fpregs-&gt;pr_gsr
op_assign
id|current-&gt;thread.gsr
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|fpregs-&gt;pr_fsr
op_assign
id|fpregs-&gt;pr_gsr
op_assign
l_int|0
suffix:semicolon
)brace
id|fpregs-&gt;pr_fprs
op_assign
id|fprs
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * sparc_execve() executes a new program after the asm stub has set&n; * things up for us.  This should basically do what I want it to.&n; */
DECL|function|sparc_execve
id|asmlinkage
r_int
id|sparc_execve
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|error
comma
id|base
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
multiline_comment|/* User register window flush is done by entry.S */
multiline_comment|/* Check for indirect call. */
r_if
c_cond
(paren
id|regs-&gt;u_regs
(braket
id|UREG_G1
)braket
op_eq
l_int|0
)paren
id|base
op_assign
l_int|1
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
(paren
r_char
op_star
)paren
id|regs-&gt;u_regs
(braket
id|base
op_plus
id|UREG_I0
)braket
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
(paren
r_char
op_star
op_star
)paren
id|regs-&gt;u_regs
(braket
id|base
op_plus
id|UREG_I1
)braket
comma
(paren
r_char
op_star
op_star
)paren
id|regs-&gt;u_regs
(braket
id|base
op_plus
id|UREG_I2
)braket
comma
id|regs
)paren
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|fprs_write
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|current-&gt;thread.xfsr
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|current-&gt;thread.fpsaved
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;tstate
op_and_assign
op_complement
id|TSTATE_PEF
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
eof
