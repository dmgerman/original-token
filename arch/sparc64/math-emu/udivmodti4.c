multiline_comment|/* This has so very few changes over libgcc2&squot;s __udivmoddi4 it isn&squot;t funny.  */
macro_line|#include &quot;soft-fp.h&quot;
DECL|macro|count_leading_zeros
macro_line|#undef count_leading_zeros
DECL|macro|count_leading_zeros
mdefine_line|#define count_leading_zeros  __FP_CLZ
r_void
DECL|function|_fp_udivmodti4
id|_fp_udivmodti4
c_func
(paren
id|_FP_W_TYPE
id|q
(braket
l_int|2
)braket
comma
id|_FP_W_TYPE
id|r
(braket
l_int|2
)braket
comma
id|_FP_W_TYPE
id|n1
comma
id|_FP_W_TYPE
id|n0
comma
id|_FP_W_TYPE
id|d1
comma
id|_FP_W_TYPE
id|d0
)paren
(brace
id|_FP_W_TYPE
id|q0
comma
id|q1
comma
id|r0
comma
id|r1
suffix:semicolon
id|_FP_I_TYPE
id|b
comma
id|bm
suffix:semicolon
r_if
c_cond
(paren
id|d1
op_eq
l_int|0
)paren
(brace
macro_line|#if !UDIV_NEEDS_NORMALIZATION
r_if
c_cond
(paren
id|d0
OG
id|n1
)paren
(brace
multiline_comment|/* 0q = nn / 0D */
id|udiv_qrnnd
(paren
id|q0
comma
id|n0
comma
id|n1
comma
id|n0
comma
id|d0
)paren
suffix:semicolon
id|q1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remainder in n0.  */
)brace
r_else
(brace
multiline_comment|/* qq = NN / 0d */
r_if
c_cond
(paren
id|d0
op_eq
l_int|0
)paren
id|d0
op_assign
l_int|1
op_div
id|d0
suffix:semicolon
multiline_comment|/* Divide intentionally by zero.  */
id|udiv_qrnnd
(paren
id|q1
comma
id|n1
comma
l_int|0
comma
id|n1
comma
id|d0
)paren
suffix:semicolon
id|udiv_qrnnd
(paren
id|q0
comma
id|n0
comma
id|n1
comma
id|n0
comma
id|d0
)paren
suffix:semicolon
multiline_comment|/* Remainder in n0.  */
)brace
id|r0
op_assign
id|n0
suffix:semicolon
id|r1
op_assign
l_int|0
suffix:semicolon
macro_line|#else /* UDIV_NEEDS_NORMALIZATION */
r_if
c_cond
(paren
id|d0
OG
id|n1
)paren
(brace
multiline_comment|/* 0q = nn / 0D */
id|count_leading_zeros
(paren
id|bm
comma
id|d0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bm
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Normalize, i.e. make the most significant bit of the&n;&t;&t; denominator set.  */
id|d0
op_assign
id|d0
op_lshift
id|bm
suffix:semicolon
id|n1
op_assign
(paren
id|n1
op_lshift
id|bm
)paren
op_or
(paren
id|n0
op_rshift
(paren
id|_FP_W_TYPE_SIZE
op_minus
id|bm
)paren
)paren
suffix:semicolon
id|n0
op_assign
id|n0
op_lshift
id|bm
suffix:semicolon
)brace
id|udiv_qrnnd
(paren
id|q0
comma
id|n0
comma
id|n1
comma
id|n0
comma
id|d0
)paren
suffix:semicolon
id|q1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remainder in n0 &gt;&gt; bm.  */
)brace
r_else
(brace
multiline_comment|/* qq = NN / 0d */
r_if
c_cond
(paren
id|d0
op_eq
l_int|0
)paren
id|d0
op_assign
l_int|1
op_div
id|d0
suffix:semicolon
multiline_comment|/* Divide intentionally by zero.  */
id|count_leading_zeros
(paren
id|bm
comma
id|d0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bm
op_eq
l_int|0
)paren
(brace
multiline_comment|/* From (n1 &gt;= d0) /&bslash; (the most significant bit of d0 is set),&n;&t;&t; conclude (the most significant bit of n1 is set) /&bslash; (the&n;&t;&t; leading quotient digit q1 = 1).&n;&n;&t;&t; This special case is necessary, not an optimization.&n;&t;&t; (Shifts counts of SI_TYPE_SIZE are undefined.)  */
id|n1
op_sub_assign
id|d0
suffix:semicolon
id|q1
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|_FP_W_TYPE
id|n2
suffix:semicolon
multiline_comment|/* Normalize.  */
id|b
op_assign
id|_FP_W_TYPE_SIZE
op_minus
id|bm
suffix:semicolon
id|d0
op_assign
id|d0
op_lshift
id|bm
suffix:semicolon
id|n2
op_assign
id|n1
op_rshift
id|b
suffix:semicolon
id|n1
op_assign
(paren
id|n1
op_lshift
id|bm
)paren
op_or
(paren
id|n0
op_rshift
id|b
)paren
suffix:semicolon
id|n0
op_assign
id|n0
op_lshift
id|bm
suffix:semicolon
id|udiv_qrnnd
(paren
id|q1
comma
id|n1
comma
id|n2
comma
id|n1
comma
id|d0
)paren
suffix:semicolon
)brace
multiline_comment|/* n1 != d0...  */
id|udiv_qrnnd
(paren
id|q0
comma
id|n0
comma
id|n1
comma
id|n0
comma
id|d0
)paren
suffix:semicolon
multiline_comment|/* Remainder in n0 &gt;&gt; bm.  */
)brace
id|r0
op_assign
id|n0
op_rshift
id|bm
suffix:semicolon
id|r1
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* UDIV_NEEDS_NORMALIZATION */
)brace
r_else
(brace
r_if
c_cond
(paren
id|d1
OG
id|n1
)paren
(brace
multiline_comment|/* 00 = nn / DD */
id|q0
op_assign
l_int|0
suffix:semicolon
id|q1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remainder in n1n0.  */
id|r0
op_assign
id|n0
suffix:semicolon
id|r1
op_assign
id|n1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 0q = NN / dd */
id|count_leading_zeros
(paren
id|bm
comma
id|d1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bm
op_eq
l_int|0
)paren
(brace
multiline_comment|/* From (n1 &gt;= d1) /&bslash; (the most significant bit of d1 is set),&n;&t;&t; conclude (the most significant bit of n1 is set) /&bslash; (the&n;&t;&t; quotient digit q0 = 0 or 1).&n;&n;&t;&t; This special case is necessary, not an optimization.  */
multiline_comment|/* The condition on the next line takes advantage of that&n;&t;&t; n1 &gt;= d1 (true due to program flow).  */
r_if
c_cond
(paren
id|n1
OG
id|d1
op_logical_or
id|n0
op_ge
id|d0
)paren
(brace
id|q0
op_assign
l_int|1
suffix:semicolon
id|sub_ddmmss
(paren
id|n1
comma
id|n0
comma
id|n1
comma
id|n0
comma
id|d1
comma
id|d0
)paren
suffix:semicolon
)brace
r_else
id|q0
op_assign
l_int|0
suffix:semicolon
id|q1
op_assign
l_int|0
suffix:semicolon
id|r0
op_assign
id|n0
suffix:semicolon
id|r1
op_assign
id|n1
suffix:semicolon
)brace
r_else
(brace
id|_FP_W_TYPE
id|m1
comma
id|m0
comma
id|n2
suffix:semicolon
multiline_comment|/* Normalize.  */
id|b
op_assign
id|_FP_W_TYPE_SIZE
op_minus
id|bm
suffix:semicolon
id|d1
op_assign
(paren
id|d1
op_lshift
id|bm
)paren
op_or
(paren
id|d0
op_rshift
id|b
)paren
suffix:semicolon
id|d0
op_assign
id|d0
op_lshift
id|bm
suffix:semicolon
id|n2
op_assign
id|n1
op_rshift
id|b
suffix:semicolon
id|n1
op_assign
(paren
id|n1
op_lshift
id|bm
)paren
op_or
(paren
id|n0
op_rshift
id|b
)paren
suffix:semicolon
id|n0
op_assign
id|n0
op_lshift
id|bm
suffix:semicolon
id|udiv_qrnnd
(paren
id|q0
comma
id|n1
comma
id|n2
comma
id|n1
comma
id|d1
)paren
suffix:semicolon
id|umul_ppmm
(paren
id|m1
comma
id|m0
comma
id|q0
comma
id|d0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m1
OG
id|n1
op_logical_or
(paren
id|m1
op_eq
id|n1
op_logical_and
id|m0
OG
id|n0
)paren
)paren
(brace
id|q0
op_decrement
suffix:semicolon
id|sub_ddmmss
(paren
id|m1
comma
id|m0
comma
id|m1
comma
id|m0
comma
id|d1
comma
id|d0
)paren
suffix:semicolon
)brace
id|q1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remainder in (n1n0 - m1m0) &gt;&gt; bm.  */
id|sub_ddmmss
(paren
id|n1
comma
id|n0
comma
id|n1
comma
id|n0
comma
id|m1
comma
id|m0
)paren
suffix:semicolon
id|r0
op_assign
(paren
id|n1
op_lshift
id|b
)paren
op_or
(paren
id|n0
op_rshift
id|bm
)paren
suffix:semicolon
id|r1
op_assign
id|n1
op_rshift
id|bm
suffix:semicolon
)brace
)brace
)brace
id|q
(braket
l_int|0
)braket
op_assign
id|q0
suffix:semicolon
id|q
(braket
l_int|1
)braket
op_assign
id|q1
suffix:semicolon
id|r
(braket
l_int|0
)braket
op_assign
id|r0
comma
id|r
(braket
l_int|1
)braket
op_assign
id|r1
suffix:semicolon
)brace
eof
