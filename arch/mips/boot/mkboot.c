multiline_comment|/*&n; * Make a bootable image from a Linux/MIPS kernel.&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1996 by Ralf Baechle&n; *&n; * This file is written in plain Kernighan &amp; Ritchie C as it has to run&n; * on all crosscompile hosts no matter how braindead.  This code might&n; * also become part of Milo.  It&squot;s therefore important that we don&squot;t use&n; * seek because the Seek() call of the Magnum 4000 ARC BIOS is broken.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;fcntl.h&gt;
multiline_comment|/*&n; * Define this for verbose debugging output.&n; */
DECL|macro|VERBOSE
macro_line|#undef VERBOSE
multiline_comment|/*&n; * Don&squot;t use the host&squot;s elf.h - it might be using incompatible defines&n; */
DECL|macro|EI_NIDENT
mdefine_line|#define EI_NIDENT 16
multiline_comment|/*&n; * Basic ELF types.&n; */
DECL|typedef|Elf32_Half
r_typedef
r_int
r_int
id|Elf32_Half
suffix:semicolon
DECL|typedef|Elf32_Section
r_typedef
r_int
r_int
id|Elf32_Section
suffix:semicolon
DECL|typedef|Elf32_Word
r_typedef
r_int
r_int
id|Elf32_Word
suffix:semicolon
DECL|typedef|Elf32_Addr
r_typedef
r_int
r_int
id|Elf32_Addr
suffix:semicolon
DECL|typedef|Elf32_Off
r_typedef
r_int
r_int
id|Elf32_Off
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|e_ident
r_int
r_char
id|e_ident
(braket
id|EI_NIDENT
)braket
suffix:semicolon
multiline_comment|/* Magic number and other info */
DECL|member|e_type
id|Elf32_Half
id|e_type
suffix:semicolon
multiline_comment|/* Object file type */
DECL|member|e_machine
id|Elf32_Half
id|e_machine
suffix:semicolon
multiline_comment|/* Architecture */
DECL|member|e_version
id|Elf32_Word
id|e_version
suffix:semicolon
multiline_comment|/* Object file version */
DECL|member|e_entry
id|Elf32_Addr
id|e_entry
suffix:semicolon
multiline_comment|/* Entry point virtual address */
DECL|member|e_phoff
id|Elf32_Off
id|e_phoff
suffix:semicolon
multiline_comment|/* Program header table file offset */
DECL|member|e_shoff
id|Elf32_Off
id|e_shoff
suffix:semicolon
multiline_comment|/* Section header table file offset */
DECL|member|e_flags
id|Elf32_Word
id|e_flags
suffix:semicolon
multiline_comment|/* Processor-specific flags */
DECL|member|e_ehsize
id|Elf32_Half
id|e_ehsize
suffix:semicolon
multiline_comment|/* ELF header size in bytes */
DECL|member|e_phentsize
id|Elf32_Half
id|e_phentsize
suffix:semicolon
multiline_comment|/* Program header table entry size */
DECL|member|e_phnum
id|Elf32_Half
id|e_phnum
suffix:semicolon
multiline_comment|/* Program header table entry count */
DECL|member|e_shentsize
id|Elf32_Half
id|e_shentsize
suffix:semicolon
multiline_comment|/* Section header table entry size */
DECL|member|e_shnum
id|Elf32_Half
id|e_shnum
suffix:semicolon
multiline_comment|/* Section header table entry count */
DECL|member|e_shstrndx
id|Elf32_Half
id|e_shstrndx
suffix:semicolon
multiline_comment|/* Section header string table index */
DECL|typedef|Elf32_Ehdr
)brace
id|Elf32_Ehdr
suffix:semicolon
multiline_comment|/*&n; * ELF magic number&n; */
DECL|macro|ELFMAG
mdefine_line|#define ELFMAG          &quot;&bslash;177ELF&quot;
DECL|macro|SELFMAG
mdefine_line|#define SELFMAG         4
DECL|macro|EI_CLASS
mdefine_line|#define EI_CLASS        4               /* File class byte index */
DECL|macro|ELFCLASSNONE
mdefine_line|#define ELFCLASSNONE    0               /* Invalid class */
DECL|macro|ELFCLASS32
mdefine_line|#define ELFCLASS32      1               /* 32-bit objects */
DECL|macro|ELFCLASS64
mdefine_line|#define ELFCLASS64      2               /* 64-bit objects */
DECL|macro|EI_DATA
mdefine_line|#define EI_DATA         5               /* Data encoding byte index */
DECL|macro|ELFDATA2LSB
mdefine_line|#define ELFDATA2LSB     1               /* 2&squot;s complement, little endian */
DECL|macro|ELFDATA2MSB
mdefine_line|#define ELFDATA2MSB     2               /* 2&squot;s complement, big endian */
DECL|macro|EI_VERSION
mdefine_line|#define EI_VERSION      6               /* File version byte index */
DECL|macro|EV_CURRENT
mdefine_line|#define EV_CURRENT      1               /* Current version */
multiline_comment|/*&n; * Acceptable machine type in e_machine.&n; */
DECL|macro|EM_MIPS
mdefine_line|#define EM_MIPS         8               /* MIPS R3000 big-endian */
DECL|macro|EM_MIPS_RS4_BE
mdefine_line|#define EM_MIPS_RS4_BE 10               /* MIPS R4000 big-endian */
multiline_comment|/*&n; * The type of ELF file we accept.&n; */
DECL|macro|ET_EXEC
mdefine_line|#define ET_EXEC         2               /* Executable file */
multiline_comment|/*&n; * Definition of a single program header structure&n; */
r_typedef
r_struct
(brace
DECL|member|p_type
id|Elf32_Word
id|p_type
suffix:semicolon
multiline_comment|/* Segment type */
DECL|member|p_offset
id|Elf32_Off
id|p_offset
suffix:semicolon
multiline_comment|/* Segment file offset */
DECL|member|p_vaddr
id|Elf32_Addr
id|p_vaddr
suffix:semicolon
multiline_comment|/* Segment virtual address */
DECL|member|p_paddr
id|Elf32_Addr
id|p_paddr
suffix:semicolon
multiline_comment|/* Segment physical address */
DECL|member|p_filesz
id|Elf32_Word
id|p_filesz
suffix:semicolon
multiline_comment|/* Segment size in file */
DECL|member|p_memsz
id|Elf32_Word
id|p_memsz
suffix:semicolon
multiline_comment|/* Segment size in memory */
DECL|member|p_flags
id|Elf32_Word
id|p_flags
suffix:semicolon
multiline_comment|/* Segment flags */
DECL|member|p_align
id|Elf32_Word
id|p_align
suffix:semicolon
multiline_comment|/* Segment alignment */
DECL|typedef|Elf32_Phdr
)brace
id|Elf32_Phdr
suffix:semicolon
multiline_comment|/*&n; * Legal values for p_type&n; */
DECL|macro|PT_NULL
mdefine_line|#define PT_NULL         0               /* Program header table entry unused */
DECL|macro|PT_LOAD
mdefine_line|#define PT_LOAD         1               /* Loadable program segment */
DECL|macro|PT_DYNAMIC
mdefine_line|#define PT_DYNAMIC      2               /* Dynamic linking information */
DECL|macro|PT_INTERP
mdefine_line|#define PT_INTERP       3               /* Program interpreter */
DECL|macro|PT_NOTE
mdefine_line|#define PT_NOTE         4               /* Auxiliary information */
DECL|macro|PT_SHLIB
mdefine_line|#define PT_SHLIB        5               /* Reserved */
DECL|macro|PT_PHDR
mdefine_line|#define PT_PHDR         6               /* Entry for header table itself */
DECL|macro|PT_NUM
mdefine_line|#define PT_NUM          7               /* Number of defined types.  */
DECL|macro|PT_LOPROC
mdefine_line|#define PT_LOPROC       0x70000000      /* Start of processor-specific */
DECL|macro|PT_HIPROC
mdefine_line|#define PT_HIPROC       0x7fffffff      /* End of processor-specific */
r_typedef
r_struct
(brace
DECL|member|sh_name
id|Elf32_Word
id|sh_name
suffix:semicolon
multiline_comment|/* Section name (string tbl index) */
DECL|member|sh_type
id|Elf32_Word
id|sh_type
suffix:semicolon
multiline_comment|/* Section type */
DECL|member|sh_flags
id|Elf32_Word
id|sh_flags
suffix:semicolon
multiline_comment|/* Section flags */
DECL|member|sh_addr
id|Elf32_Addr
id|sh_addr
suffix:semicolon
multiline_comment|/* Section virtual addr at execution */
DECL|member|sh_offset
id|Elf32_Off
id|sh_offset
suffix:semicolon
multiline_comment|/* Section file offset */
DECL|member|sh_size
id|Elf32_Word
id|sh_size
suffix:semicolon
multiline_comment|/* Section size in bytes */
DECL|member|sh_link
id|Elf32_Word
id|sh_link
suffix:semicolon
multiline_comment|/* Link to another section */
DECL|member|sh_info
id|Elf32_Word
id|sh_info
suffix:semicolon
multiline_comment|/* Additional section information */
DECL|member|sh_addralign
id|Elf32_Word
id|sh_addralign
suffix:semicolon
multiline_comment|/* Section alignment */
DECL|member|sh_entsize
id|Elf32_Word
id|sh_entsize
suffix:semicolon
multiline_comment|/* Entry size if section holds table */
DECL|typedef|Elf32_Shdr
)brace
id|Elf32_Shdr
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|st_name
id|Elf32_Word
id|st_name
suffix:semicolon
multiline_comment|/* Symbol name (string tbl index) */
DECL|member|st_value
id|Elf32_Addr
id|st_value
suffix:semicolon
multiline_comment|/* Symbol value */
DECL|member|st_size
id|Elf32_Word
id|st_size
suffix:semicolon
multiline_comment|/* Symbol size */
DECL|member|st_info
r_int
r_char
id|st_info
suffix:semicolon
multiline_comment|/* Symbol type and binding */
DECL|member|st_other
r_int
r_char
id|st_other
suffix:semicolon
multiline_comment|/* No defined meaning, 0 */
DECL|member|st_shndx
id|Elf32_Section
id|st_shndx
suffix:semicolon
multiline_comment|/* Section index */
DECL|typedef|Elf32_Sym
)brace
id|Elf32_Sym
suffix:semicolon
multiline_comment|/* How to extract and insert information held in the st_info field.  */
DECL|macro|ELF32_ST_BIND
mdefine_line|#define ELF32_ST_BIND(val)              (((unsigned char) (val)) &gt;&gt; 4)
DECL|macro|ELF32_ST_TYPE
mdefine_line|#define ELF32_ST_TYPE(val)              ((val) &amp; 0xf)
multiline_comment|/* Legal values for ST_BIND subfield of st_info (symbol binding).  */
DECL|macro|STB_GLOBAL
mdefine_line|#define STB_GLOBAL      1               /* Global symbol */
multiline_comment|/* Legal values for ST_TYPE subfield of st_info (symbol type).  */
DECL|macro|STT_NOTYPE
mdefine_line|#define STT_NOTYPE      0               /* Symbol type is unspecified */
DECL|macro|STT_OBJECT
mdefine_line|#define STT_OBJECT      1               /* Symbol is a data object */
DECL|macro|STT_FUNC
mdefine_line|#define STT_FUNC        2               /* Symbol is a code object */
r_static
r_int
r_int
DECL|function|get_Elf32_Half
id|get_Elf32_Half
c_func
(paren
r_int
r_char
op_star
id|p
)paren
(brace
r_return
id|p
(braket
l_int|0
)braket
op_or
(paren
id|p
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|macro|get_Elf32_Section
mdefine_line|#define get_Elf32_Section(p) get_Elf32_Half(p)
r_static
r_int
r_int
DECL|function|get_Elf32_Word
id|get_Elf32_Word
c_func
(paren
r_int
r_char
op_star
id|p
)paren
(brace
r_return
id|p
(braket
l_int|0
)braket
op_or
(paren
id|p
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|p
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|p
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
DECL|macro|get_Elf32_Addr
mdefine_line|#define get_Elf32_Addr(p) get_Elf32_Word(p)
DECL|macro|get_Elf32_Off
mdefine_line|#define get_Elf32_Off(p) get_Elf32_Word(p)
r_static
r_void
DECL|function|put_byte
id|put_byte
c_func
(paren
id|p
comma
id|x
)paren
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_char
id|x
suffix:semicolon
(brace
id|p
(braket
l_int|0
)braket
op_assign
id|x
suffix:semicolon
)brace
r_static
r_void
DECL|function|put_half
id|put_half
c_func
(paren
id|p
comma
id|x
)paren
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|x
suffix:semicolon
(brace
id|p
(braket
l_int|0
)braket
op_assign
id|x
op_amp
l_int|0xff
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
(paren
id|x
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
r_static
r_void
DECL|function|put_word
id|put_word
c_func
(paren
id|p
comma
id|x
)paren
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|x
suffix:semicolon
(brace
id|p
(braket
l_int|0
)braket
op_assign
id|x
op_amp
l_int|0xff
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
(paren
id|x
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|p
(braket
l_int|2
)braket
op_assign
(paren
id|x
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|p
(braket
l_int|3
)braket
op_assign
(paren
id|x
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/*&n; * Swap a program header in.&n; */
r_static
r_void
DECL|function|get_elfph
id|get_elfph
c_func
(paren
id|p
comma
id|ph
)paren
r_int
r_char
op_star
id|p
suffix:semicolon
id|Elf32_Phdr
op_star
id|ph
suffix:semicolon
(brace
id|ph-&gt;p_type
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
)paren
suffix:semicolon
id|ph-&gt;p_offset
op_assign
id|get_Elf32_Off
c_func
(paren
id|p
op_plus
l_int|4
)paren
suffix:semicolon
id|ph-&gt;p_vaddr
op_assign
id|get_Elf32_Addr
c_func
(paren
id|p
op_plus
l_int|8
)paren
suffix:semicolon
id|ph-&gt;p_paddr
op_assign
id|get_Elf32_Addr
c_func
(paren
id|p
op_plus
l_int|12
)paren
suffix:semicolon
id|ph-&gt;p_filesz
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|16
)paren
suffix:semicolon
id|ph-&gt;p_memsz
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|20
)paren
suffix:semicolon
id|ph-&gt;p_flags
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|24
)paren
suffix:semicolon
id|ph-&gt;p_align
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|28
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Swap a section header in.&n; */
r_static
r_void
DECL|function|get_elfsh
id|get_elfsh
c_func
(paren
id|p
comma
id|sh
)paren
r_int
r_char
op_star
id|p
suffix:semicolon
id|Elf32_Shdr
op_star
id|sh
suffix:semicolon
(brace
id|sh-&gt;sh_name
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
)paren
suffix:semicolon
id|sh-&gt;sh_type
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|4
)paren
suffix:semicolon
id|sh-&gt;sh_flags
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|8
)paren
suffix:semicolon
id|sh-&gt;sh_addr
op_assign
id|get_Elf32_Addr
c_func
(paren
id|p
op_plus
l_int|12
)paren
suffix:semicolon
id|sh-&gt;sh_offset
op_assign
id|get_Elf32_Off
c_func
(paren
id|p
op_plus
l_int|16
)paren
suffix:semicolon
id|sh-&gt;sh_size
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|20
)paren
suffix:semicolon
id|sh-&gt;sh_link
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|24
)paren
suffix:semicolon
id|sh-&gt;sh_info
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|28
)paren
suffix:semicolon
id|sh-&gt;sh_addralign
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|32
)paren
suffix:semicolon
id|sh-&gt;sh_entsize
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|36
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Swap a section header in.&n; */
r_static
r_void
DECL|function|get_elfsym
id|get_elfsym
c_func
(paren
id|p
comma
id|sym
)paren
r_int
r_char
op_star
id|p
suffix:semicolon
id|Elf32_Sym
op_star
id|sym
suffix:semicolon
(brace
id|sym-&gt;st_name
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
)paren
suffix:semicolon
id|sym-&gt;st_value
op_assign
id|get_Elf32_Addr
c_func
(paren
id|p
op_plus
l_int|4
)paren
suffix:semicolon
id|sym-&gt;st_size
op_assign
id|get_Elf32_Word
c_func
(paren
id|p
op_plus
l_int|8
)paren
suffix:semicolon
id|sym-&gt;st_info
op_assign
op_star
(paren
id|p
op_plus
l_int|12
)paren
suffix:semicolon
id|sym-&gt;st_other
op_assign
op_star
(paren
id|p
op_plus
l_int|13
)paren
suffix:semicolon
id|sym-&gt;st_shndx
op_assign
id|get_Elf32_Section
c_func
(paren
id|p
op_plus
l_int|14
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The a.out magic number&n; */
DECL|macro|OMAGIC
mdefine_line|#define OMAGIC 0407&t;/* Code indicating object file or impure executable. */
DECL|macro|M_MIPS1
mdefine_line|#define M_MIPS1 151&t;/* MIPS R3000/R3000 binary */
DECL|macro|M_MIPS2
mdefine_line|#define M_MIPS2 152&t;/* MIPS R6000/R4000 binary */
multiline_comment|/*&n; * Compute and return an a.out magic number.&n; */
DECL|macro|AOUT_INFO
mdefine_line|#define AOUT_INFO(magic, type, flags) &bslash;&n;        (((magic) &amp; 0xffff) | &bslash;&n;         (((int)(type) &amp; 0xff) &lt;&lt; 16) | &bslash;&n;         (((flags) &amp; 0xff) &lt;&lt; 24))
multiline_comment|/*&n; * a.out symbols&n; */
DECL|macro|N_UNDF
mdefine_line|#define N_UNDF 0
DECL|macro|N_ABS
mdefine_line|#define N_ABS 2
DECL|macro|N_TEXT
mdefine_line|#define N_TEXT 4
DECL|macro|N_DATA
mdefine_line|#define N_DATA 6
DECL|macro|N_BSS
mdefine_line|#define N_BSS 8
DECL|macro|N_FN
mdefine_line|#define N_FN 15
DECL|macro|N_EXT
mdefine_line|#define N_EXT 1
DECL|macro|min
mdefine_line|#define min(x,y) (((x)&lt;(y))?(x):(y))
r_static
r_void
DECL|function|do_read
id|do_read
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
r_int
id|fd
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
(brace
id|ssize_t
id|rd
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ne
l_int|0
)paren
(brace
id|rd
op_assign
id|read
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rd
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Can&squot;t read from file.&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|size
op_sub_assign
id|rd
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|writepad
id|writepad
c_func
(paren
id|fd
comma
id|size
)paren
r_int
id|fd
suffix:semicolon
r_int
id|size
suffix:semicolon
(brace
r_static
r_void
op_star
id|zeropage
op_assign
l_int|NULL
suffix:semicolon
id|ssize_t
id|written
suffix:semicolon
r_if
c_cond
(paren
id|zeropage
op_eq
l_int|NULL
)paren
(brace
id|zeropage
op_assign
id|malloc
c_func
(paren
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zeropage
op_eq
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Couldn&squot;t allocate zero buffer.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|zeropage
comma
l_char|&squot;&bslash;0&squot;
comma
l_int|4096
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
op_ne
l_int|0
)paren
(brace
id|written
op_assign
id|write
c_func
(paren
id|fd
comma
id|zeropage
comma
id|min
c_func
(paren
l_int|4096
comma
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Can&squot;t write to boot image&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|size
op_sub_assign
id|written
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|do_write
id|do_write
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
r_int
id|fd
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
(brace
id|ssize_t
id|written
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ne
l_int|0
)paren
(brace
id|written
op_assign
id|write
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Can&squot;t write to boot image&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|size
op_sub_assign
id|written
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|usage
id|usage
c_func
(paren
id|program_name
)paren
r_char
op_star
id|program_name
suffix:semicolon
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: %s infile outfile&bslash;n&quot;
comma
id|program_name
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|main
id|main
c_func
(paren
id|argc
comma
id|argv
)paren
r_int
id|argc
suffix:semicolon
r_char
op_star
id|argv
(braket
)braket
suffix:semicolon
(brace
r_char
op_star
id|infile
comma
op_star
id|outfile
suffix:semicolon
r_struct
id|stat
id|ifstat
suffix:semicolon
id|off_t
id|ifsize
suffix:semicolon
r_char
op_star
id|image
suffix:semicolon
r_int
id|ifd
comma
id|ofd
comma
id|i
comma
id|symtabix
comma
id|strtabix
suffix:semicolon
id|Elf32_Ehdr
id|eh
suffix:semicolon
id|Elf32_Phdr
op_star
id|ph
suffix:semicolon
id|Elf32_Shdr
op_star
id|sh
suffix:semicolon
r_int
r_int
id|vaddr
comma
id|entry
comma
id|bss
comma
id|kernel_entry
comma
id|kernel_end
suffix:semicolon
r_int
r_char
id|ahdr
(braket
l_int|32
)braket
suffix:semicolon
id|Elf32_Sym
id|sym
suffix:semicolon
r_int
id|symnum
suffix:semicolon
r_char
op_star
id|symname
suffix:semicolon
multiline_comment|/*&n;&t; * Verify some basic assuptions about type sizes made in this code&n;&t; */
r_if
c_cond
(paren
r_sizeof
(paren
id|Elf32_Half
)paren
op_ne
l_int|2
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Fix mkboot: sizeof(Elf32_Half) != 2&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_sizeof
(paren
id|Elf32_Word
)paren
op_ne
l_int|4
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Fix mkboot: sizeof(Elf32_Word) != 4&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_sizeof
(paren
id|Elf32_Addr
)paren
op_ne
l_int|4
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Fix mkboot: sizeof(Elf32_Addr) != 4&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
id|usage
c_func
(paren
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|infile
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
id|outfile
op_assign
id|argv
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|infile
comma
op_amp
id|ifstat
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Can&squot;t stat kernel image.&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|ifstat.st_mode
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input file isn&squot;t a regular file.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|ifsize
op_assign
id|ifstat.st_size
suffix:semicolon
id|image
op_assign
id|malloc
c_func
(paren
(paren
r_int
)paren
id|ifsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|image
op_eq
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t allocate memory to read file&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the entire input file in.&n;&t; */
id|ifd
op_assign
id|open
c_func
(paren
id|infile
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ifd
op_eq
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Can&squot;t open input file&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|do_read
c_func
(paren
id|ifd
comma
id|image
comma
id|ifsize
)paren
suffix:semicolon
id|close
c_func
(paren
id|ifd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now swap the ELF header in.  This is ugly but we the file&n;&t; * we&squot;re reading might have different type sizes, byteorder&n;&t; * or alignment than the host.&n;&t; */
id|memcpy
c_func
(paren
id|eh.e_ident
comma
(paren
r_void
op_star
)paren
id|image
comma
r_sizeof
(paren
id|eh.e_ident
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eh.e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input file isn&squot;t a ELF file&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eh.e_ident
(braket
id|EI_CLASS
)braket
op_ne
id|ELFCLASS32
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input file isn&squot;t a 32 bit ELF file&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eh.e_ident
(braket
id|EI_DATA
)braket
op_ne
id|ELFDATA2LSB
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input file isn&squot;t a little endian ELF file&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eh.e_ident
(braket
id|EI_VERSION
)braket
op_ne
id|EV_CURRENT
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input file isn&squot;t a version %d ELF file&bslash;n&quot;
comma
id|EV_CURRENT
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, so far the file looks ok.  Now swap the rest of the header in&n;&t; * and do some more paranoia checks.&n;&t; */
id|eh.e_type
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|16
)paren
suffix:semicolon
id|eh.e_machine
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|18
)paren
suffix:semicolon
id|eh.e_version
op_assign
id|get_Elf32_Word
c_func
(paren
id|image
op_plus
l_int|20
)paren
suffix:semicolon
id|eh.e_entry
op_assign
id|get_Elf32_Addr
c_func
(paren
id|image
op_plus
l_int|24
)paren
suffix:semicolon
id|eh.e_phoff
op_assign
id|get_Elf32_Off
c_func
(paren
id|image
op_plus
l_int|28
)paren
suffix:semicolon
id|eh.e_shoff
op_assign
id|get_Elf32_Off
c_func
(paren
id|image
op_plus
l_int|32
)paren
suffix:semicolon
id|eh.e_flags
op_assign
id|get_Elf32_Word
c_func
(paren
id|image
op_plus
l_int|36
)paren
suffix:semicolon
id|eh.e_ehsize
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|40
)paren
suffix:semicolon
id|eh.e_phentsize
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|42
)paren
suffix:semicolon
id|eh.e_phnum
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|44
)paren
suffix:semicolon
id|eh.e_shentsize
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|46
)paren
suffix:semicolon
id|eh.e_shnum
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|48
)paren
suffix:semicolon
id|eh.e_shstrndx
op_assign
id|get_Elf32_Half
c_func
(paren
id|image
op_plus
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eh.e_type
op_ne
id|ET_EXEC
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input file isn&squot;t a executable.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eh.e_machine
op_ne
id|EM_MIPS
op_logical_and
id|eh.e_machine
op_ne
id|EM_MIPS_RS4_BE
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Input file isn&squot;t a MIPS executable.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now read the program headers ...&n;&t; */
id|ph
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
id|Elf32_Phdr
)paren
op_star
id|eh.e_phnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ph
op_eq
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;No memory for program header table.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eh.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
id|get_elfph
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|image
op_plus
id|eh.e_phoff
op_plus
id|i
op_star
l_int|32
)paren
comma
id|ph
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ... and then the section headers.&n;&t; */
id|sh
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
id|Elf32_Shdr
)paren
op_star
id|eh.e_shnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh
op_eq
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;No memory for section header table.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eh.e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
id|get_elfsh
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|image
op_plus
id|eh.e_shoff
op_plus
(paren
id|i
op_star
l_int|40
)paren
)paren
comma
id|sh
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the symboltable and the stringtable in the file.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eh.e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|image
op_plus
id|sh
(braket
id|eh.e_shstrndx
)braket
dot
id|sh_offset
op_plus
id|sh
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.symtab&quot;
)paren
)paren
(brace
id|symtabix
op_assign
id|i
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|image
op_plus
id|sh
(braket
id|eh.e_shstrndx
)braket
dot
id|sh_offset
op_plus
id|sh
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.strtab&quot;
)paren
)paren
(brace
id|strtabix
op_assign
id|i
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|symtabix
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;The executable doesn&squot;t have a symbol table&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strtabix
op_eq
op_minus
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;The executable doesn&squot;t have a string table&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Dig for the two required symbols in the symbol table.&n;&t; */
id|symnum
op_assign
id|sh
(braket
id|symtabix
)braket
dot
id|sh_size
op_div
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|symnum
suffix:semicolon
id|i
op_increment
)paren
(brace
id|get_elfsym
c_func
(paren
id|image
op_plus
id|sh
(braket
id|symtabix
)braket
dot
id|sh_offset
op_plus
(paren
id|i
op_star
l_int|16
)paren
comma
op_amp
id|sym
)paren
suffix:semicolon
id|symname
op_assign
id|image
op_plus
id|sh
(braket
id|strtabix
)braket
dot
id|sh_offset
op_plus
id|sym.st_name
suffix:semicolon
r_if
c_cond
(paren
id|ELF32_ST_BIND
c_func
(paren
id|sym.st_info
)paren
op_ne
id|STB_GLOBAL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ELF32_ST_TYPE
c_func
(paren
id|sym.st_info
)paren
op_ne
id|STT_NOTYPE
op_logical_and
id|ELF32_ST_TYPE
c_func
(paren
id|sym.st_info
)paren
op_ne
id|STT_OBJECT
op_logical_and
id|ELF32_ST_TYPE
c_func
(paren
id|sym.st_info
)paren
op_ne
id|STT_FUNC
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;kernel_entry&quot;
comma
id|symname
)paren
op_eq
l_int|0
)paren
(brace
id|kernel_entry
op_assign
id|sym.st_value
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;_end&quot;
comma
id|symname
)paren
op_eq
l_int|0
)paren
(brace
id|kernel_end
op_assign
id|sym.st_value
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
macro_line|#ifdef VERBOSE
multiline_comment|/*&n;&t; * And print what we will be loaded into memory.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eh.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ph
(braket
id|i
)braket
dot
id|p_type
op_ne
id|PT_LOAD
)paren
(brace
r_continue
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;  Offset: %08lx&bslash;n&quot;
comma
id|ph
(braket
id|i
)braket
dot
id|p_offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  file size: %08lx&bslash;n&quot;
comma
id|ph
(braket
id|i
)braket
dot
id|p_filesz
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  mem size: %08lx&bslash;n&quot;
comma
id|ph
(braket
id|i
)braket
dot
id|p_memsz
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Loading: %08lx - %08lx&bslash;n&quot;
comma
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
comma
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|ph
(braket
id|i
)braket
dot
id|p_filesz
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;    Zero mapping: %08lx - %08lx&bslash;n&quot;
comma
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|ph
(braket
id|i
)braket
dot
id|p_filesz
comma
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|ph
(braket
id|i
)braket
dot
id|p_memsz
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Time to open the outputfile.&n;&t; */
id|ofd
op_assign
id|open
c_func
(paren
id|outfile
comma
id|O_WRONLY
op_or
id|O_CREAT
op_or
id|O_TRUNC
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ofd
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;Can&squot;t open boot image for output.&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * First compute the layout of the file.  We need to do this&n;&t; * first because we can&squot;t seek back to the beginning due to the&n;&t; * broken Seek() call in the Magnum firmware.&n;&t; */
id|entry
op_assign
id|vaddr
op_assign
l_int|0xffffffff
suffix:semicolon
id|bss
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eh.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ph
(braket
id|i
)braket
dot
id|p_type
op_ne
id|PT_LOAD
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vaddr
op_eq
l_int|0xffffffff
)paren
id|entry
op_assign
id|vaddr
op_assign
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
suffix:semicolon
id|vaddr
op_assign
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|ph
(braket
id|i
)braket
dot
id|p_filesz
suffix:semicolon
id|bss
op_assign
id|ph
(braket
id|i
)braket
dot
id|p_memsz
op_minus
id|ph
(braket
id|i
)braket
dot
id|p_filesz
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In the next step we construct the boot image.  The boot file&n;&t; * looks essentially like a dump of the loaded kernel with a&n;&t; * minimal header.  Because Milo supports already a.out image&n;&t; * we simply dump the image in an a.out image ...  First let&squot;s&n;&t; * write the header.&n;&t; */
multiline_comment|/*&n;&t; * Create and write the a.out header.&n;&t; */
id|put_word
c_func
(paren
id|ahdr
comma
id|AOUT_INFO
c_func
(paren
id|OMAGIC
comma
id|M_MIPS1
comma
l_int|0
)paren
)paren
suffix:semicolon
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|4
comma
id|vaddr
op_minus
id|entry
)paren
suffix:semicolon
multiline_comment|/* text size */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|8
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* data size */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|12
comma
id|bss
)paren
suffix:semicolon
multiline_comment|/* bss size */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|16
comma
l_int|2
op_star
l_int|12
)paren
suffix:semicolon
multiline_comment|/* size of symbol table */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|20
comma
id|entry
)paren
suffix:semicolon
multiline_comment|/* base address */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|24
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* size of text relocations */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* size of data relocations */
id|do_write
c_func
(paren
id|ofd
comma
id|ahdr
comma
l_int|32
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write text and data segment combined into the a.out text segment&n;&t; * and a zero length data segment into the file.&n;&t; */
id|vaddr
op_assign
l_int|0xffffffff
suffix:semicolon
id|bss
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eh.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ph
(braket
id|i
)braket
dot
id|p_type
op_ne
id|PT_LOAD
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vaddr
op_eq
l_int|0xffffffff
)paren
id|vaddr
op_assign
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
suffix:semicolon
id|writepad
c_func
(paren
id|ofd
comma
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
op_minus
id|vaddr
)paren
suffix:semicolon
multiline_comment|/* Write zero pad */
id|do_write
c_func
(paren
id|ofd
comma
id|image
op_plus
id|ph
(braket
id|i
)braket
dot
id|p_offset
comma
id|ph
(braket
id|i
)braket
dot
id|p_filesz
)paren
suffix:semicolon
id|vaddr
op_assign
id|ph
(braket
id|i
)braket
dot
id|p_vaddr
op_plus
id|ph
(braket
id|i
)braket
dot
id|p_filesz
suffix:semicolon
id|bss
op_assign
id|ph
(braket
id|i
)braket
dot
id|p_memsz
op_minus
id|ph
(braket
id|i
)braket
dot
id|p_filesz
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now write the symbol table.  It has only two symbols,&n;&t; * kernel_entry and _end which we need for booting.&n;&t; */
id|put_word
c_func
(paren
id|ahdr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* n_un.n_strx */
id|put_byte
c_func
(paren
id|ahdr
op_plus
l_int|4
comma
id|N_TEXT
op_or
id|N_EXT
)paren
suffix:semicolon
multiline_comment|/* n_type */
id|put_byte
c_func
(paren
id|ahdr
op_plus
l_int|5
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* n_other */
id|put_half
c_func
(paren
id|ahdr
op_plus
l_int|6
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* n_desc */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|8
comma
id|kernel_entry
)paren
suffix:semicolon
multiline_comment|/* n_value */
id|do_write
c_func
(paren
id|ofd
comma
id|ahdr
comma
l_int|12
)paren
suffix:semicolon
id|put_word
c_func
(paren
id|ahdr
comma
l_int|4
op_plus
l_int|13
)paren
suffix:semicolon
multiline_comment|/* n_un.n_strx */
id|put_byte
c_func
(paren
id|ahdr
op_plus
l_int|4
comma
id|N_ABS
op_or
id|N_EXT
)paren
suffix:semicolon
multiline_comment|/* n_type */
id|put_byte
c_func
(paren
id|ahdr
op_plus
l_int|5
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* n_other */
id|put_half
c_func
(paren
id|ahdr
op_plus
l_int|6
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* n_desc */
id|put_word
c_func
(paren
id|ahdr
op_plus
l_int|8
comma
id|kernel_end
)paren
suffix:semicolon
multiline_comment|/* n_value */
id|do_write
c_func
(paren
id|ofd
comma
id|ahdr
comma
l_int|12
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now write stringtable size and the strings.&n;&t; */
id|put_word
c_func
(paren
id|ahdr
comma
l_int|4
op_plus
l_int|20
)paren
suffix:semicolon
id|do_write
c_func
(paren
id|ofd
comma
id|ahdr
comma
l_int|4
)paren
suffix:semicolon
id|do_write
c_func
(paren
id|ofd
comma
l_string|&quot;kernel_entry&bslash;0_end&bslash;0&bslash;0&quot;
comma
l_int|20
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * That&squot;s is all ...&n;&t; */
id|close
c_func
(paren
id|ofd
)paren
suffix:semicolon
macro_line|#ifdef VERBOSE
id|printf
c_func
(paren
l_string|&quot;Entry: %08lx&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Dumped image %08lx - %08lx&bslash;n&quot;
comma
l_int|0x80000000
comma
id|vaddr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Extra bss at end: %08lx&bslash;n&quot;
comma
id|bss
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
