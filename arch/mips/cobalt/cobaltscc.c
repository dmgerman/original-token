multiline_comment|/*&n; * Filename: cobaltscc.c&n; * &n; * Description: Functions for supporting and testing serial I/O&n; * &n; * Author(s): Timothy Stonis&n; * &n; * Copyright 1997, Cobalt Microserver, Inc.&n; */
macro_line|#include &quot;z8530.h&quot;
macro_line|#include &quot;diagdefs.h&quot;
macro_line|#include &quot;serial.h&quot;
macro_line|#include &quot;asm/io.h&quot;
multiline_comment|/*&n; * Function prototypes&n; */
r_void
id|InitSerialPort
c_func
(paren
r_int
r_char
op_star
)paren
suffix:semicolon
r_void
id|RegisterDelay
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|InitScc
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Function: RegisterDelay&n; *&n; * Description: A little delay since the SCC can&squot;t handle quick consecutive &n; *              accesses&n; * In: none&n; * Out: none&n; */
DECL|function|RegisterDelay
r_void
id|RegisterDelay
c_func
(paren
r_void
)paren
(brace
r_register
r_int
id|ctr
suffix:semicolon
r_for
c_loop
(paren
id|ctr
op_assign
l_int|0
suffix:semicolon
id|ctr
OL
l_int|0x40
suffix:semicolon
id|ctr
op_increment
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function: SccInit&n; *&n; * Description: Initialize all the SCC registers for 19200 baud, asynchronous,&n; *&t;&t;8 bit, 1 stop bit, no parity communication (Channel A)&n; *&n; * In: none&n; *&n; * Out: none&n; */
DECL|function|InitScc
r_void
id|InitScc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Force hardware reset */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R9
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|FHWRES
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* x32 clock, 1 stop bit, no parity */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R4
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|X16CLK
op_or
id|SB1
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Rx 8 bits, Rx disabled */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R3
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|Rx8
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Tx 8 bits, DTR, RTS, Tx off */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R5
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|Tx8
op_or
id|DTR
op_or
id|RTS
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Int. Disabled */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R9
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
l_int|0x0
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* NRZ */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R10
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|NRZ
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Tx &amp; Rx = BRG out, TRxC = BRG out */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R11
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|TCBR
op_or
id|RCBR
op_or
id|TRxCBR
op_or
id|TRxCOI
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Time constant = 0x01 */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R12
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|kSCC_115200
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Time constant high = 0x00 */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R13
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
l_int|0x00
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* BRG in = ~RTxC, BRG off, loopback */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R14
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|LOOPBAK
op_or
id|BRSRC
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: EnableScc&n; *&n; * Description: Enable transmit and receive on SCC Channel A&n; * In: none&n; * Out: none&n; */
DECL|function|EnableScc
r_void
id|EnableScc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Enable BRG */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R14
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|BRENABL
op_or
id|BRSRC
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Rx enable (Rx 8 bits) */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R3
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|RxENABLE
op_or
id|Rx8
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Tx enable (Tx8, DTR, RTS) */
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Command
comma
id|R5
op_or
id|NULLCODE
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
comma
id|TxENAB
op_or
id|Tx8
op_or
id|DTR
op_or
id|RTS
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: SccOutb&n; *&n; * Description: Write a byte to the SCC (Channel A) and blink LED&n; * In: Byte to send&n; * Out: none&n; */
DECL|function|SccOutb
r_void
id|SccOutb
c_func
(paren
r_int
r_char
id|byte
)paren
(brace
multiline_comment|/* LED on.. */
id|Write8530
c_func
(paren
id|kSCC_ChanB
op_or
id|kSCC_Command
comma
id|R5
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanB
op_or
id|kSCC_Command
comma
id|RTS
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|Read8530
c_func
(paren
id|kSCC_ChanA
)paren
op_amp
id|Tx_BUF_EMP
)paren
op_eq
l_int|0
)paren
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Direct
comma
id|byte
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* LED off.. */
id|Write8530
c_func
(paren
id|kSCC_ChanB
op_or
id|kSCC_Command
comma
id|R9
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
id|Write8530
c_func
(paren
id|kSCC_ChanB
op_or
id|kSCC_Command
comma
id|CHRB
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: SccInb&n; *&n; * Description: Read a byte from the SCC (Channel A)&n; * In: Byte to send&n; * Out: none&n; */
DECL|function|SccInb
r_void
id|SccInb
c_func
(paren
r_int
r_char
op_star
id|byte
)paren
(brace
r_while
c_loop
(paren
(paren
id|Read8530
c_func
(paren
id|kSCC_ChanA
)paren
op_amp
id|Rx_CH_AV
)paren
op_eq
l_int|0
)paren
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
op_star
id|byte
op_assign
id|Read8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Direct
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: SccWrite&n; *&n; * Description: Write a null terminated string to the SCC &n; * In: C string&n; * Out: none&n; */
DECL|function|SccWrite
r_void
id|SccWrite
c_func
(paren
r_const
r_int
r_char
op_star
id|string
)paren
(brace
r_while
c_loop
(paren
(paren
op_star
id|string
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|string
op_eq
l_int|10
)paren
id|SccOutb
c_func
(paren
(paren
r_int
r_char
)paren
l_int|13
)paren
suffix:semicolon
id|SccOutb
c_func
(paren
op_star
(paren
id|string
op_increment
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function: InitSerialPort&n; *&n; * Description: Initialize the SCC and spit out the header message &n; * In: Header message&n; * Out: none&n; */
DECL|function|InitSerialPort
r_void
id|InitSerialPort
c_func
(paren
r_int
r_char
op_star
id|msg
)paren
(brace
id|InitScc
c_func
(paren
)paren
suffix:semicolon
id|EnableScc
c_func
(paren
)paren
suffix:semicolon
id|SccWrite
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: SccInbTimeout&n; *&n; * Description: Read a byte from the SCC (Channel A) with timeout&n; * In: Byte to send&n; * Out: Timeout status&n; */
DECL|function|SccInbTimeout
r_int
r_char
id|SccInbTimeout
c_func
(paren
r_int
r_char
op_star
id|byte
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
r_int
id|ctr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|Read8530
c_func
(paren
id|kSCC_ChanA
)paren
op_amp
id|Rx_CH_AV
)paren
op_eq
l_int|0
)paren
(brace
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctr
op_increment
)paren
OG
id|timeout
)paren
r_return
l_int|0xFF
suffix:semicolon
)brace
op_star
id|byte
op_assign
id|Read8530
c_func
(paren
id|kSCC_ChanA
op_or
id|kSCC_Direct
)paren
suffix:semicolon
id|RegisterDelay
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#include &lt;linux/serial_reg.h&gt;
r_extern
r_int
id|serial_echo_init
(paren
r_int
id|base
)paren
suffix:semicolon
r_extern
r_int
id|serial_echo_print
(paren
r_const
r_char
op_star
id|s
)paren
suffix:semicolon
multiline_comment|/*&n; * this defines the address for the port to which printk echoing is done&n; *  when CONFIG_SERIAL_ECHO is defined&n; */
DECL|macro|SERIAL_ECHO_PORT
mdefine_line|#define SERIAL_ECHO_PORT       0x1C800000 
DECL|variable|serial_echo_port
r_static
r_int
id|serial_echo_port
op_assign
l_int|0
suffix:semicolon
DECL|macro|serial_echo_outb
mdefine_line|#define serial_echo_outb(v,a) outb((v),(a)+serial_echo_port)
DECL|macro|serial_echo_inb
mdefine_line|#define serial_echo_inb(a)    inb((a)+serial_echo_port)
DECL|macro|BOTH_EMPTY
mdefine_line|#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
multiline_comment|/* Wait for transmitter &amp; holding register to empty */
DECL|macro|WAIT_FOR_XMITR
mdefine_line|#define WAIT_FOR_XMITR &bslash;&n; do { &bslash;&n;       lsr = serial_echo_inb(UART_LSR); &bslash;&n; } while ((lsr &amp; BOTH_EMPTY) != BOTH_EMPTY)
multiline_comment|/*&n; * These two functions abstract the actual communications with the&n; * debug port.  This is so we can change the underlying communications&n; * mechanism without modifying the rest of the code.&n; */
r_int
DECL|function|serial_echo_print
id|serial_echo_print
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|lsr
comma
id|ier
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial_echo_port
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * First save the IER then disable the interrupts&n;         */
id|ier
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_IER
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
l_int|0x00
comma
id|UART_IER
)paren
suffix:semicolon
multiline_comment|/*&n;         * Now, do each character&n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|s
suffix:semicolon
id|i
op_increment
comma
id|s
op_increment
)paren
(brace
id|WAIT_FOR_XMITR
suffix:semicolon
multiline_comment|/* Send the character out. */
id|serial_echo_outb
c_func
(paren
op_star
id|s
comma
id|UART_TX
)paren
suffix:semicolon
multiline_comment|/* if a LF, also do CR... */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_int|10
)paren
(brace
id|WAIT_FOR_XMITR
suffix:semicolon
id|serial_echo_outb
c_func
(paren
l_int|13
comma
id|UART_TX
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;         * Finally, Wait for transmitter &amp; holding register to empty&n;         *  and restore the IER&n;         */
r_do
(brace
id|lsr
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|lsr
op_amp
id|BOTH_EMPTY
)paren
op_ne
id|BOTH_EMPTY
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
id|ier
comma
id|UART_IER
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|serial_echo_init
id|serial_echo_init
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|comstat
comma
id|hi
comma
id|lo
suffix:semicolon
id|serial_echo_port
op_assign
id|base
suffix:semicolon
multiline_comment|/*&n;         * read the Divisor Latch&n;         */
id|comstat
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_LCR
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
id|comstat
op_or
id|UART_LCR_DLAB
comma
id|UART_LCR
)paren
suffix:semicolon
id|hi
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_DLM
)paren
suffix:semicolon
id|lo
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_DLL
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
id|comstat
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/*&n;         * now do hardwired init&n;         */
id|serial_echo_outb
c_func
(paren
l_int|0x03
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* No parity, 8 data bits, 1 stop */
id|serial_echo_outb
c_func
(paren
l_int|0x83
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* Access divisor latch */
multiline_comment|/* This is computed using:&n;&t; *&n;&t; * const BASE_BAUD = (18432000 / 16);&n;&t; * UART_DLM = (BASE_BAUD / baud_I_want) &gt;&gt; 8;&n;&t; * UART_DLL = (BASE_BAUD / baud_I_want) &amp; 0xff;&n;&t; */
id|serial_echo_outb
c_func
(paren
l_int|0x00
comma
id|UART_DLM
)paren
suffix:semicolon
multiline_comment|/* 115200 baud */
id|serial_echo_outb
c_func
(paren
l_int|0x0A
comma
id|UART_DLL
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
l_int|0x03
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* Done with divisor */
multiline_comment|/*&n;&t; * Prior to disabling interrupts, read the LSR and RBR&n;         * registers&n;         */
id|comstat
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_LSR
)paren
suffix:semicolon
multiline_comment|/* COM? LSR */
id|comstat
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_RX
)paren
suffix:semicolon
multiline_comment|/* COM? RBR */
id|serial_echo_outb
c_func
(paren
l_int|0x00
comma
id|UART_IER
)paren
suffix:semicolon
multiline_comment|/* Disable all interrupts */
r_return
l_int|0
suffix:semicolon
)brace
eof
