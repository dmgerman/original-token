multiline_comment|/*&n; * irixelf.c: Code to load IRIX ELF executables which conform to&n; *            the MIPS ABI.&n; *&n; * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)&n; *&n; * Based upon work which is:&n; * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/elfcore.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/prctl.h&gt;
DECL|macro|DLINFO_ITEMS
mdefine_line|#define DLINFO_ITEMS 12
macro_line|#include &lt;linux/elf.h&gt;
DECL|macro|DEBUG_ELF
macro_line|#undef DEBUG_ELF
r_static
r_int
id|load_irix_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|load_irix_library
c_func
(paren
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|irix_core_dump
c_func
(paren
r_int
id|signr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_extern
r_int
id|dump_fpu
(paren
id|elf_fpregset_t
op_star
)paren
suffix:semicolon
DECL|variable|irix_format
r_static
r_struct
id|linux_binfmt
id|irix_format
op_assign
(brace
l_int|NULL
comma
id|THIS_MODULE
comma
id|load_irix_binary
comma
id|load_irix_library
comma
id|irix_core_dump
comma
id|PAGE_SIZE
)brace
suffix:semicolon
macro_line|#ifndef elf_addr_t
DECL|macro|elf_addr_t
mdefine_line|#define elf_addr_t unsigned long
DECL|macro|elf_caddr_t
mdefine_line|#define elf_caddr_t char *
macro_line|#endif
macro_line|#ifdef DEBUG_ELF
multiline_comment|/* Debugging routines. */
DECL|function|get_elf_p_type
r_static
r_char
op_star
id|get_elf_p_type
c_func
(paren
id|Elf32_Word
id|p_type
)paren
(brace
r_int
id|i
op_assign
(paren
r_int
)paren
id|p_type
suffix:semicolon
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
id|PT_NULL
suffix:colon
r_return
l_string|&quot;PT_NULL&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_LOAD
suffix:colon
r_return
l_string|&quot;PT_LOAD&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_DYNAMIC
suffix:colon
r_return
l_string|&quot;PT_DYNAMIC&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_INTERP
suffix:colon
r_return
l_string|&quot;PT_INTERP&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_NOTE
suffix:colon
r_return
l_string|&quot;PT_NOTE&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_SHLIB
suffix:colon
r_return
l_string|&quot;PT_SHLIB&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_PHDR
suffix:colon
r_return
l_string|&quot;PT_PHDR&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_LOPROC
suffix:colon
r_return
l_string|&quot;PT_LOPROC/REGINFO&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_HIPROC
suffix:colon
r_return
l_string|&quot;PT_HIPROC&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;PT_BOGUS&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|print_elfhdr
r_static
r_void
id|print_elfhdr
c_func
(paren
r_struct
id|elfhdr
op_star
id|ehp
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ELFHDR: e_ident&lt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EI_NIDENT
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
id|ehp-&gt;e_ident
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%x&gt;&bslash;n&quot;
comma
id|ehp-&gt;e_ident
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        e_type[%04x] e_machine[%04x] e_version[%08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_type
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_machine
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        e_entry[%08lx] e_phoff[%08lx] e_shoff[%08lx] &quot;
l_string|&quot;e_flags[%08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_entry
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_phoff
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_shoff
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        e_ehsize[%04x] e_phentsize[%04x] e_phnum[%04x]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_ehsize
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_phentsize
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_phnum
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        e_shentsize[%04x] e_shnum[%04x] e_shstrndx[%04x]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_shentsize
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_shnum
comma
(paren
r_int
r_int
)paren
id|ehp-&gt;e_shstrndx
)paren
suffix:semicolon
)brace
DECL|function|print_phdr
r_static
r_void
id|print_phdr
c_func
(paren
r_int
id|i
comma
r_struct
id|elf_phdr
op_star
id|ep
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PHDR[%d]: p_type[%s] p_offset[%08lx] p_vaddr[%08lx] &quot;
l_string|&quot;p_paddr[%08lx]&bslash;n&quot;
comma
id|i
comma
id|get_elf_p_type
c_func
(paren
id|ep-&gt;p_type
)paren
comma
(paren
r_int
r_int
)paren
id|ep-&gt;p_offset
comma
(paren
r_int
r_int
)paren
id|ep-&gt;p_vaddr
comma
(paren
r_int
r_int
)paren
id|ep-&gt;p_paddr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;         p_filesz[%08lx] p_memsz[%08lx] p_flags[%08lx] &quot;
l_string|&quot;p_align[%08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ep-&gt;p_filesz
comma
(paren
r_int
r_int
)paren
id|ep-&gt;p_memsz
comma
(paren
r_int
r_int
)paren
id|ep-&gt;p_flags
comma
(paren
r_int
r_int
)paren
id|ep-&gt;p_align
)paren
suffix:semicolon
)brace
DECL|function|dump_phdrs
r_static
r_void
id|dump_phdrs
c_func
(paren
r_struct
id|elf_phdr
op_star
id|ep
comma
r_int
id|pnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pnum
suffix:semicolon
id|i
op_increment
comma
id|ep
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ep-&gt;p_type
op_eq
id|PT_LOAD
)paren
op_logical_or
(paren
id|ep-&gt;p_type
op_eq
id|PT_INTERP
)paren
op_logical_or
(paren
id|ep-&gt;p_type
op_eq
id|PT_PHDR
)paren
)paren
(brace
id|print_phdr
c_func
(paren
id|i
comma
id|ep
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* (DEBUG_ELF) */
DECL|function|set_brk
r_static
r_void
id|set_brk
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|start
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start
)paren
suffix:semicolon
id|end
op_assign
id|PAGE_ALIGN
c_func
(paren
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_le
id|start
)paren
r_return
suffix:semicolon
id|do_brk
c_func
(paren
id|start
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
)brace
multiline_comment|/* We need to explicitly zero any fractional pages&n; * after the data section (i.e. bss).  This would&n; * contain the junk from the file that should not&n; * be in memory.&n; */
DECL|function|padzero
r_static
r_void
id|padzero
c_func
(paren
r_int
r_int
id|elf_bss
)paren
(brace
r_int
r_int
id|nbyte
suffix:semicolon
id|nbyte
op_assign
id|elf_bss
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nbyte
)paren
(brace
id|nbyte
op_assign
id|PAGE_SIZE
op_minus
id|nbyte
suffix:semicolon
id|clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|elf_bss
comma
id|nbyte
)paren
suffix:semicolon
)brace
)brace
DECL|function|create_irix_tables
r_int
r_int
op_star
id|create_irix_tables
c_func
(paren
r_char
op_star
id|p
comma
r_int
id|argc
comma
r_int
id|envc
comma
r_struct
id|elfhdr
op_star
id|exec
comma
r_int
r_int
id|load_addr
comma
r_int
r_int
id|interp_load_addr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|elf_phdr
op_star
id|ephdr
)paren
(brace
id|elf_caddr_t
op_star
id|argv
suffix:semicolon
id|elf_caddr_t
op_star
id|envp
suffix:semicolon
id|elf_addr_t
op_star
id|sp
comma
op_star
id|csp
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;create_irix_tables: p[%p] argc[%d] envc[%d] &quot;
l_string|&quot;load_addr[%08x] interp_load_addr[%08x]&bslash;n&quot;
comma
id|p
comma
id|argc
comma
id|envc
comma
id|load_addr
comma
id|interp_load_addr
)paren
suffix:semicolon
macro_line|#endif
id|sp
op_assign
(paren
id|elf_addr_t
op_star
)paren
(paren
op_complement
l_int|15UL
op_amp
(paren
r_int
r_int
)paren
id|p
)paren
suffix:semicolon
id|csp
op_assign
id|sp
suffix:semicolon
id|csp
op_sub_assign
id|exec
ques
c_cond
id|DLINFO_ITEMS
op_star
l_int|2
suffix:colon
l_int|2
suffix:semicolon
id|csp
op_sub_assign
id|envc
op_plus
l_int|1
suffix:semicolon
id|csp
op_sub_assign
id|argc
op_plus
l_int|1
suffix:semicolon
id|csp
op_sub_assign
l_int|1
suffix:semicolon
multiline_comment|/* argc itself */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|csp
op_amp
l_int|15UL
)paren
(brace
id|sp
op_sub_assign
(paren
l_int|16UL
op_minus
(paren
(paren
r_int
r_int
)paren
id|csp
op_amp
l_int|15UL
)paren
)paren
op_div
r_sizeof
(paren
op_star
id|sp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Put the ELF interpreter info on the stack&n;&t; */
DECL|macro|NEW_AUX_ENT
mdefine_line|#define NEW_AUX_ENT(nr, id, val) &bslash;&n;&t;  __put_user ((id), sp+(nr*2)); &bslash;&n;&t;  __put_user ((val), sp+(nr*2+1)); &bslash;&n;
id|sp
op_sub_assign
l_int|2
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
l_int|0
comma
id|AT_NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exec
)paren
(brace
id|sp
op_sub_assign
l_int|11
op_star
l_int|2
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|0
comma
id|AT_PHDR
comma
id|load_addr
op_plus
id|exec-&gt;e_phoff
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|1
comma
id|AT_PHENT
comma
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|2
comma
id|AT_PHNUM
comma
id|exec-&gt;e_phnum
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|3
comma
id|AT_PAGESZ
comma
id|ELF_EXEC_PAGESIZE
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|4
comma
id|AT_BASE
comma
id|interp_load_addr
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|5
comma
id|AT_FLAGS
comma
l_int|0
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|6
comma
id|AT_ENTRY
comma
(paren
id|elf_addr_t
)paren
id|exec-&gt;e_entry
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|7
comma
id|AT_UID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;uid
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|8
comma
id|AT_EUID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;euid
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|9
comma
id|AT_GID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;gid
)paren
suffix:semicolon
id|NEW_AUX_ENT
(paren
l_int|10
comma
id|AT_EGID
comma
(paren
id|elf_addr_t
)paren
id|current-&gt;egid
)paren
suffix:semicolon
)brace
DECL|macro|NEW_AUX_ENT
macro_line|#undef NEW_AUX_ENT
id|sp
op_sub_assign
id|envc
op_plus
l_int|1
suffix:semicolon
id|envp
op_assign
(paren
id|elf_caddr_t
op_star
)paren
id|sp
suffix:semicolon
id|sp
op_sub_assign
id|argc
op_plus
l_int|1
suffix:semicolon
id|argv
op_assign
(paren
id|elf_caddr_t
op_star
)paren
id|sp
suffix:semicolon
id|__put_user
c_func
(paren
(paren
id|elf_addr_t
)paren
id|argc
comma
op_decrement
id|sp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_start
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
OG
l_int|0
)paren
(brace
id|__put_user
c_func
(paren
(paren
id|elf_caddr_t
)paren
(paren
r_int
r_int
)paren
id|p
comma
id|argv
op_increment
)paren
suffix:semicolon
id|p
op_add_assign
id|strlen_user
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|__put_user
c_func
(paren
l_int|NULL
comma
id|argv
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_end
op_assign
id|current-&gt;mm-&gt;env_start
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_while
c_loop
(paren
id|envc
op_decrement
OG
l_int|0
)paren
(brace
id|__put_user
c_func
(paren
(paren
id|elf_caddr_t
)paren
(paren
r_int
r_int
)paren
id|p
comma
id|envp
op_increment
)paren
suffix:semicolon
id|p
op_add_assign
id|strlen_user
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|__put_user
c_func
(paren
l_int|NULL
comma
id|envp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;env_end
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_return
id|sp
suffix:semicolon
)brace
multiline_comment|/* This is much more generalized than the library routine read function,&n; * so we keep this separate.  Technically the library read function&n; * is only provided so that we can read a.out libraries that have&n; * an ELF header.&n; */
DECL|function|load_irix_interp
r_static
r_int
r_int
id|load_irix_interp
c_func
(paren
r_struct
id|elfhdr
op_star
id|interp_elf_ex
comma
r_struct
id|file
op_star
id|interpreter
comma
r_int
r_int
op_star
id|interp_load_addr
)paren
(brace
r_struct
id|elf_phdr
op_star
id|elf_phdata
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|elf_phdr
op_star
id|eppnt
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
r_int
id|load_addr
suffix:semicolon
r_int
id|elf_bss
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
r_int
id|last_bss
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|k
suffix:semicolon
id|elf_bss
op_assign
l_int|0
suffix:semicolon
id|last_bss
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|load_addr
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|print_elfhdr
c_func
(paren
id|interp_elf_ex
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* First of all, some simple consistency checks */
r_if
c_cond
(paren
(paren
id|interp_elf_ex-&gt;e_type
op_ne
id|ET_EXEC
op_logical_and
id|interp_elf_ex-&gt;e_type
op_ne
id|ET_DYN
)paren
op_logical_or
op_logical_neg
id|irix_elf_check_arch
c_func
(paren
id|interp_elf_ex
)paren
op_logical_or
op_logical_neg
id|interpreter-&gt;f_op-&gt;mmap
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRIX interp has bad e_type %d&bslash;n&quot;
comma
id|interp_elf_ex-&gt;e_type
)paren
suffix:semicolon
r_return
l_int|0xffffffff
suffix:semicolon
)brace
multiline_comment|/* Now read in all of the header information */
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|interp_elf_ex-&gt;e_phnum
OG
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRIX interp header bigger than a page (%d)&bslash;n&quot;
comma
(paren
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|interp_elf_ex-&gt;e_phnum
)paren
)paren
suffix:semicolon
r_return
l_int|0xffffffff
suffix:semicolon
)brace
id|elf_phdata
op_assign
(paren
r_struct
id|elf_phdr
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|interp_elf_ex-&gt;e_phnum
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_phdata
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot kmalloc phdata for IRIX interp.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffffffff
suffix:semicolon
)brace
multiline_comment|/* If the size of this structure has changed, then punt, since&n;&t; * we will be doing the wrong thing.&n;&t; */
r_if
c_cond
(paren
id|interp_elf_ex-&gt;e_phentsize
op_ne
l_int|32
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRIX interp e_phentsize == %d != 32 &quot;
comma
id|interp_elf_ex-&gt;e_phentsize
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
r_return
l_int|0xffffffff
suffix:semicolon
)brace
id|retval
op_assign
id|kernel_read
c_func
(paren
id|interpreter
comma
id|interp_elf_ex-&gt;e_phoff
comma
(paren
r_char
op_star
)paren
id|elf_phdata
comma
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|interp_elf_ex-&gt;e_phnum
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|dump_phdrs
c_func
(paren
id|elf_phdata
comma
id|interp_elf_ex-&gt;e_phnum
)paren
suffix:semicolon
macro_line|#endif
id|eppnt
op_assign
id|elf_phdata
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interp_elf_ex-&gt;e_phnum
suffix:semicolon
id|i
op_increment
comma
id|eppnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|eppnt-&gt;p_type
op_eq
id|PT_LOAD
)paren
(brace
r_int
id|elf_type
op_assign
id|MAP_PRIVATE
op_or
id|MAP_DENYWRITE
suffix:semicolon
r_int
id|elf_prot
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|vaddr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|eppnt-&gt;p_flags
op_amp
id|PF_R
)paren
id|elf_prot
op_assign
id|PROT_READ
suffix:semicolon
r_if
c_cond
(paren
id|eppnt-&gt;p_flags
op_amp
id|PF_W
)paren
id|elf_prot
op_or_assign
id|PROT_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|eppnt-&gt;p_flags
op_amp
id|PF_X
)paren
id|elf_prot
op_or_assign
id|PROT_EXEC
suffix:semicolon
id|elf_type
op_or_assign
id|MAP_FIXED
suffix:semicolon
id|vaddr
op_assign
id|eppnt-&gt;p_vaddr
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;INTERP do_mmap(%p, %08lx, %08lx, %08lx, %08lx, %08lx) &quot;
comma
id|interpreter
comma
id|vaddr
comma
(paren
r_int
r_int
)paren
(paren
id|eppnt-&gt;p_filesz
op_plus
(paren
id|eppnt-&gt;p_vaddr
op_amp
l_int|0xfff
)paren
)paren
comma
(paren
r_int
r_int
)paren
id|elf_prot
comma
(paren
r_int
r_int
)paren
id|elf_type
comma
(paren
r_int
r_int
)paren
(paren
id|eppnt-&gt;p_offset
op_amp
l_int|0xfffff000
)paren
)paren
suffix:semicolon
macro_line|#endif
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|error
op_assign
id|do_mmap
c_func
(paren
id|interpreter
comma
id|vaddr
comma
id|eppnt-&gt;p_filesz
op_plus
(paren
id|eppnt-&gt;p_vaddr
op_amp
l_int|0xfff
)paren
comma
id|elf_prot
comma
id|elf_type
comma
id|eppnt-&gt;p_offset
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
template_param
op_minus
l_int|1024
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aieee IRIX interp mmap error=%d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Real error */
)brace
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;error=%08lx &quot;
comma
(paren
r_int
r_int
)paren
id|error
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|load_addr
op_logical_and
id|interp_elf_ex-&gt;e_type
op_eq
id|ET_DYN
)paren
(brace
id|load_addr
op_assign
id|error
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;load_addr = error &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Find the end of the file  mapping for this phdr, and keep&n;&t;     * track of the largest address we see for this.&n;&t;     */
id|k
op_assign
id|eppnt-&gt;p_vaddr
op_plus
id|eppnt-&gt;p_filesz
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|elf_bss
)paren
(brace
id|elf_bss
op_assign
id|k
suffix:semicolon
)brace
multiline_comment|/* Do the same thing for the memory mapping - between&n;&t;     * elf_bss and last_bss is the bss section.&n;&t;     */
id|k
op_assign
id|eppnt-&gt;p_memsz
op_plus
id|eppnt-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|last_bss
)paren
(brace
id|last_bss
op_assign
id|k
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/* Now use mmap to map the library into memory. */
r_if
c_cond
(paren
id|error
template_param
op_minus
l_int|1024
)paren
(brace
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;got error %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
r_return
l_int|0xffffffff
suffix:semicolon
)brace
multiline_comment|/* Now fill out the bss section.  First pad the last page up&n;&t; * to the page boundary, and then perform a mmap to make sure&n;&t; * that there are zero-mapped pages up to and including the&n;&t; * last bss page.&n;&t; */
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;padzero(%08lx) &quot;
comma
(paren
r_int
r_int
)paren
(paren
id|elf_bss
)paren
)paren
suffix:semicolon
macro_line|#endif
id|padzero
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
id|len
op_assign
(paren
id|elf_bss
op_plus
l_int|0xfff
)paren
op_amp
l_int|0xfffff000
suffix:semicolon
multiline_comment|/* What we have mapped so far */
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;last_bss[%08lx] len[%08lx]&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|last_bss
comma
(paren
r_int
r_int
)paren
id|len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Map the last of the bss segment */
r_if
c_cond
(paren
id|last_bss
OG
id|len
)paren
(brace
id|do_brk
c_func
(paren
id|len
comma
(paren
id|last_bss
op_minus
id|len
)paren
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
op_star
id|interp_load_addr
op_assign
id|load_addr
suffix:semicolon
r_return
(paren
(paren
r_int
r_int
)paren
id|interp_elf_ex-&gt;e_entry
)paren
suffix:semicolon
)brace
multiline_comment|/* Check sanity of IRIX elf executable header. */
DECL|function|verify_binary
r_static
r_int
id|verify_binary
c_func
(paren
r_struct
id|elfhdr
op_star
id|ehp
comma
r_struct
id|linux_binprm
op_star
id|bprm
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|ehp-&gt;e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
multiline_comment|/* First of all, some simple consistency checks */
r_if
c_cond
(paren
(paren
id|ehp-&gt;e_type
op_ne
id|ET_EXEC
op_logical_and
id|ehp-&gt;e_type
op_ne
id|ET_DYN
)paren
op_logical_or
op_logical_neg
id|irix_elf_check_arch
c_func
(paren
id|ehp
)paren
op_logical_or
op_logical_neg
id|bprm-&gt;file-&gt;f_op-&gt;mmap
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Only support MIPS ARCH2 or greater IRIX binaries for now. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ehp-&gt;e_flags
op_amp
id|EF_MIPS_ARCH
)paren
op_logical_and
op_logical_neg
(paren
id|ehp-&gt;e_flags
op_amp
l_int|0x04
)paren
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* XXX Don&squot;t support N32 or 64bit binaries yet because they can&n;&t; * XXX and do execute 64 bit instructions and expect all registers&n;&t; * XXX to be 64 bit as well.  We need to make the kernel save&n;&t; * XXX all registers as 64bits on cpu&squot;s capable of this at&n;&t; * XXX exception time plus frob the XTLB exception vector.&n;&t; */
r_if
c_cond
(paren
(paren
id|ehp-&gt;e_flags
op_amp
l_int|0x20
)paren
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* It&squot;s ok. */
)brace
DECL|macro|IRIX_INTERP_PREFIX
mdefine_line|#define IRIX_INTERP_PREFIX &quot;/usr/gnemul/irix&quot;
multiline_comment|/* Look for an IRIX ELF interpreter. */
DECL|function|look_for_irix_interpreter
r_static
r_inline
r_int
id|look_for_irix_interpreter
c_func
(paren
r_char
op_star
op_star
id|name
comma
r_struct
id|file
op_star
op_star
id|interpreter
comma
r_struct
id|elfhdr
op_star
id|interp_elf_ex
comma
r_struct
id|elf_phdr
op_star
id|epp
comma
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_int
id|pnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pnum
suffix:semicolon
id|i
op_increment
comma
id|epp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|epp-&gt;p_type
op_ne
id|PT_INTERP
)paren
r_continue
suffix:semicolon
multiline_comment|/* It is illegal to have two interpreters for one executable. */
r_if
c_cond
(paren
op_star
id|name
op_ne
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
op_star
id|name
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|epp-&gt;p_filesz
op_plus
id|strlen
c_func
(paren
id|IRIX_INTERP_PREFIX
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|strcpy
c_func
(paren
op_star
id|name
comma
id|IRIX_INTERP_PREFIX
)paren
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|bprm-&gt;file
comma
id|epp-&gt;p_offset
comma
(paren
op_star
id|name
op_plus
l_int|16
)paren
comma
id|epp-&gt;p_filesz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|file
op_assign
id|open_exec
c_func
(paren
op_star
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
(brace
id|retval
op_assign
id|PTR_ERR
c_func
(paren
id|file
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
id|kernel_read
c_func
(paren
id|file
comma
l_int|0
comma
id|bprm-&gt;buf
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|dput_and_out
suffix:semicolon
op_star
id|interp_elf_ex
op_assign
op_star
(paren
r_struct
id|elfhdr
op_star
)paren
id|bprm-&gt;buf
suffix:semicolon
)brace
op_star
id|interpreter
op_assign
id|file
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|dput_and_out
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
op_star
id|name
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|verify_irix_interpreter
r_static
r_inline
r_int
id|verify_irix_interpreter
c_func
(paren
r_struct
id|elfhdr
op_star
id|ihp
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|ihp-&gt;e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ELIBBAD
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|EXEC_MAP_FLAGS
mdefine_line|#define EXEC_MAP_FLAGS (MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE)
DECL|function|map_executable
r_static
r_inline
r_void
id|map_executable
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_struct
id|elf_phdr
op_star
id|epp
comma
r_int
id|pnum
comma
r_int
r_int
op_star
id|estack
comma
r_int
r_int
op_star
id|laddr
comma
r_int
r_int
op_star
id|scode
comma
r_int
r_int
op_star
id|ebss
comma
r_int
r_int
op_star
id|ecode
comma
r_int
r_int
op_star
id|edata
comma
r_int
r_int
op_star
id|ebrk
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_int
id|i
comma
id|prot
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pnum
suffix:semicolon
id|i
op_increment
comma
id|epp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|epp-&gt;p_type
op_ne
id|PT_LOAD
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Map it. */
id|prot
op_assign
(paren
id|epp-&gt;p_flags
op_amp
id|PF_R
)paren
ques
c_cond
id|PROT_READ
suffix:colon
l_int|0
suffix:semicolon
id|prot
op_or_assign
(paren
id|epp-&gt;p_flags
op_amp
id|PF_W
)paren
ques
c_cond
id|PROT_WRITE
suffix:colon
l_int|0
suffix:semicolon
id|prot
op_or_assign
(paren
id|epp-&gt;p_flags
op_amp
id|PF_X
)paren
ques
c_cond
id|PROT_EXEC
suffix:colon
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
(paren
r_void
)paren
id|do_mmap
c_func
(paren
id|fp
comma
(paren
id|epp-&gt;p_vaddr
op_amp
l_int|0xfffff000
)paren
comma
(paren
id|epp-&gt;p_filesz
op_plus
(paren
id|epp-&gt;p_vaddr
op_amp
l_int|0xfff
)paren
)paren
comma
id|prot
comma
id|EXEC_MAP_FLAGS
comma
(paren
id|epp-&gt;p_offset
op_amp
l_int|0xfffff000
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/* Fixup location tracking vars. */
r_if
c_cond
(paren
(paren
id|epp-&gt;p_vaddr
op_amp
l_int|0xfffff000
)paren
OL
op_star
id|estack
)paren
(brace
op_star
id|estack
op_assign
(paren
id|epp-&gt;p_vaddr
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|laddr
)paren
(brace
op_star
id|laddr
op_assign
id|epp-&gt;p_vaddr
op_minus
id|epp-&gt;p_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|epp-&gt;p_vaddr
OL
op_star
id|scode
)paren
(brace
op_star
id|scode
op_assign
id|epp-&gt;p_vaddr
suffix:semicolon
)brace
id|tmp
op_assign
id|epp-&gt;p_vaddr
op_plus
id|epp-&gt;p_filesz
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
op_star
id|ebss
)paren
(brace
op_star
id|ebss
op_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|epp-&gt;p_flags
op_amp
id|PF_X
)paren
op_logical_and
op_star
id|ecode
OL
id|tmp
)paren
(brace
op_star
id|ecode
op_assign
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|edata
OL
id|tmp
)paren
(brace
op_star
id|edata
op_assign
id|tmp
suffix:semicolon
)brace
id|tmp
op_assign
id|epp-&gt;p_vaddr
op_plus
id|epp-&gt;p_memsz
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
op_star
id|ebrk
)paren
(brace
op_star
id|ebrk
op_assign
id|tmp
suffix:semicolon
)brace
)brace
)brace
DECL|function|map_interpreter
r_static
r_inline
r_int
id|map_interpreter
c_func
(paren
r_struct
id|elf_phdr
op_star
id|epp
comma
r_struct
id|elfhdr
op_star
id|ihp
comma
r_struct
id|file
op_star
id|interp
comma
r_int
r_int
op_star
id|iladdr
comma
r_int
id|pnum
comma
id|mm_segment_t
id|old_fs
comma
r_int
r_int
op_star
id|eentry
)paren
(brace
r_int
id|i
suffix:semicolon
op_star
id|eentry
op_assign
l_int|0xffffffff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pnum
suffix:semicolon
id|i
op_increment
comma
id|epp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|epp-&gt;p_type
op_ne
id|PT_INTERP
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* We should have fielded this error elsewhere... */
r_if
c_cond
(paren
op_star
id|eentry
op_ne
l_int|0xffffffff
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
op_star
id|eentry
op_assign
id|load_irix_interp
c_func
(paren
id|ihp
comma
id|interp
comma
id|iladdr
)paren
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|fput
c_func
(paren
id|interp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|eentry
op_eq
l_int|0xffffffff
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * IRIX maps a page at 0x200000 that holds information about the &n; * process and the system, here we map the page and fill the&n; * structure&n; */
DECL|function|irix_map_prda_page
r_void
id|irix_map_prda_page
(paren
r_void
)paren
(brace
r_int
r_int
id|v
suffix:semicolon
r_struct
id|prda
op_star
id|pp
suffix:semicolon
id|v
op_assign
id|do_brk
(paren
id|PRDA_ADDRESS
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
OL
l_int|0
)paren
r_return
suffix:semicolon
id|pp
op_assign
(paren
r_struct
id|prda
op_star
)paren
id|v
suffix:semicolon
id|pp-&gt;prda_sys.t_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|pp-&gt;prda_sys.t_prid
op_assign
id|read_32bit_cp0_register
(paren
id|CP0_PRID
)paren
suffix:semicolon
id|pp-&gt;prda_sys.t_rpid
op_assign
id|current-&gt;pid
suffix:semicolon
multiline_comment|/* We leave the rest set to zero */
)brace
multiline_comment|/* These are the functions used to load ELF style executables and shared&n; * libraries.  There is no binary dependent code anywhere else.&n; */
DECL|function|load_irix_binary
r_static
r_int
id|load_irix_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|elfhdr
id|elf_ex
comma
id|interp_elf_ex
suffix:semicolon
r_struct
id|file
op_star
id|interpreter
suffix:semicolon
r_struct
id|elf_phdr
op_star
id|elf_phdata
comma
op_star
id|elf_ihdr
comma
op_star
id|elf_ephdr
suffix:semicolon
r_int
r_int
id|load_addr
comma
id|elf_bss
comma
id|elf_brk
suffix:semicolon
r_int
r_int
id|elf_entry
comma
id|interp_load_addr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|start_code
comma
id|end_code
comma
id|end_data
comma
id|elf_stack
suffix:semicolon
r_int
id|retval
comma
id|has_interp
comma
id|has_ephdr
comma
id|size
comma
id|i
suffix:semicolon
r_char
op_star
id|elf_interpreter
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
id|load_addr
op_assign
l_int|0
suffix:semicolon
id|has_interp
op_assign
id|has_ephdr
op_assign
l_int|0
suffix:semicolon
id|elf_ihdr
op_assign
id|elf_ephdr
op_assign
l_int|0
suffix:semicolon
id|elf_ex
op_assign
op_star
(paren
(paren
r_struct
id|elfhdr
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_if
c_cond
(paren
id|verify_binary
c_func
(paren
op_amp
id|elf_ex
comma
id|bprm
)paren
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|print_elfhdr
c_func
(paren
op_amp
id|elf_ex
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Now read in all of the header information */
id|size
op_assign
id|elf_ex.e_phentsize
op_star
id|elf_ex.e_phnum
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|65536
)paren
r_goto
id|out
suffix:semicolon
id|elf_phdata
op_assign
(paren
r_struct
id|elf_phdr
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_phdata
op_eq
l_int|NULL
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
id|kernel_read
c_func
(paren
id|bprm-&gt;file
comma
id|elf_ex.e_phoff
comma
(paren
r_char
op_star
)paren
id|elf_phdata
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_free_ph
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|dump_phdrs
c_func
(paren
id|elf_phdata
comma
id|elf_ex.e_phnum
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set some things for later. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|elf_ex.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|elf_phdata
(braket
id|i
)braket
dot
id|p_type
)paren
(brace
r_case
id|PT_INTERP
suffix:colon
id|has_interp
op_assign
l_int|1
suffix:semicolon
id|elf_ihdr
op_assign
op_amp
id|elf_phdata
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PT_PHDR
suffix:colon
id|has_ephdr
op_assign
l_int|1
suffix:semicolon
id|elf_ephdr
op_assign
op_amp
id|elf_phdata
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|elf_bss
op_assign
l_int|0
suffix:semicolon
id|elf_brk
op_assign
l_int|0
suffix:semicolon
id|elf_stack
op_assign
l_int|0xffffffff
suffix:semicolon
id|elf_interpreter
op_assign
l_int|NULL
suffix:semicolon
id|start_code
op_assign
l_int|0xffffffff
suffix:semicolon
id|end_code
op_assign
l_int|0
suffix:semicolon
id|end_data
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|look_for_irix_interpreter
c_func
(paren
op_amp
id|elf_interpreter
comma
op_amp
id|interpreter
comma
op_amp
id|interp_elf_ex
comma
id|elf_phdata
comma
id|bprm
comma
id|elf_ex.e_phnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out_free_file
suffix:semicolon
r_if
c_cond
(paren
id|elf_interpreter
)paren
(brace
id|retval
op_assign
id|verify_irix_interpreter
c_func
(paren
op_amp
id|interp_elf_ex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_goto
id|out_free_interp
suffix:semicolon
)brace
)brace
multiline_comment|/* OK, we are done with that, now set up the arg stuff,&n;&t; * and then start this sucker up.&n;&t; */
id|retval
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bprm-&gt;sh_bang
op_logical_and
op_logical_neg
id|bprm-&gt;p
)paren
r_goto
id|out_free_interp
suffix:semicolon
multiline_comment|/* Flush all traces of the currently running executable */
id|retval
op_assign
id|flush_old_exec
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out_free_dentry
suffix:semicolon
multiline_comment|/* OK, This is the point of no return */
id|current-&gt;mm-&gt;end_data
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;mmap
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
id|elf_entry
op_assign
(paren
r_int
r_int
)paren
id|elf_ex.e_entry
suffix:semicolon
multiline_comment|/* Do this so that we can load the interpreter, if need be.  We will&n;&t; * change some of these later.&n;&t; */
id|current-&gt;mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|setup_arg_pages
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|current-&gt;mm-&gt;start_stack
op_assign
id|bprm-&gt;p
suffix:semicolon
multiline_comment|/* At this point, we assume that the image should be loaded at&n;&t; * fixed address, not at a variable address.&n;&t; */
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|map_executable
c_func
(paren
id|bprm-&gt;file
comma
id|elf_phdata
comma
id|elf_ex.e_phnum
comma
op_amp
id|elf_stack
comma
op_amp
id|load_addr
comma
op_amp
id|start_code
comma
op_amp
id|elf_bss
comma
op_amp
id|end_code
comma
op_amp
id|end_data
comma
op_amp
id|elf_brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_interpreter
)paren
(brace
id|retval
op_assign
id|map_interpreter
c_func
(paren
id|elf_phdata
comma
op_amp
id|interp_elf_ex
comma
id|interpreter
comma
op_amp
id|interp_load_addr
comma
id|elf_ex.e_phnum
comma
id|old_fs
comma
op_amp
id|elf_entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|elf_interpreter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to load IRIX ELF interpreter&bslash;n&quot;
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_free_file
suffix:semicolon
)brace
)brace
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
id|set_personality
c_func
(paren
id|PER_IRIX32
)paren
suffix:semicolon
id|set_binfmt
c_func
(paren
op_amp
id|irix_format
)paren
suffix:semicolon
id|compute_creds
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
id|bprm-&gt;p
op_assign
(paren
r_int
r_int
)paren
id|create_irix_tables
c_func
(paren
(paren
r_char
op_star
)paren
id|bprm-&gt;p
comma
id|bprm-&gt;argc
comma
id|bprm-&gt;envc
comma
(paren
id|elf_interpreter
ques
c_cond
op_amp
id|elf_ex
suffix:colon
l_int|NULL
)paren
comma
id|load_addr
comma
id|interp_load_addr
comma
id|regs
comma
id|elf_ephdr
)paren
suffix:semicolon
id|current-&gt;mm-&gt;start_brk
op_assign
id|current-&gt;mm-&gt;brk
op_assign
id|elf_brk
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
id|end_code
suffix:semicolon
id|current-&gt;mm-&gt;start_code
op_assign
id|start_code
suffix:semicolon
id|current-&gt;mm-&gt;end_data
op_assign
id|end_data
suffix:semicolon
id|current-&gt;mm-&gt;start_stack
op_assign
id|bprm-&gt;p
suffix:semicolon
multiline_comment|/* Calling set_brk effectively mmaps the pages that we need for the&n;&t; * bss and break sections.&n;&t; */
id|set_brk
c_func
(paren
id|elf_bss
comma
id|elf_brk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * IRIX maps a page at 0x200000 which holds some system&n;&t; * information.  Programs depend on this.&n;&t; */
id|irix_map_prda_page
(paren
)paren
suffix:semicolon
id|padzero
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;(start_brk) %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_brk
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(end_code) %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_code
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(start_code) %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_code
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(end_data) %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_data
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(start_stack) %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_stack
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(brk) %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;brk
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0 /* XXX No fucking way dude... */
multiline_comment|/* Why this, you ask???  Well SVr4 maps page 0 as read-only,&n;&t; * and some applications &quot;depend&quot; upon this behavior.&n;&t; * Since we do not have the power to recompile these, we&n;&t; * emulate the SVr4 behavior.  Sigh.&n;&t; */
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
(paren
r_void
)paren
id|do_mmap
c_func
(paren
l_int|NULL
comma
l_int|0
comma
l_int|4096
comma
id|PROT_READ
op_or
id|PROT_EXEC
comma
id|MAP_FIXED
op_or
id|MAP_PRIVATE
comma
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
macro_line|#endif
id|start_thread
c_func
(paren
id|regs
comma
id|elf_entry
comma
id|bprm-&gt;p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
id|out_free_dentry
suffix:colon
id|allow_write_access
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|fput
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|out_free_interp
suffix:colon
r_if
c_cond
(paren
id|elf_interpreter
)paren
id|kfree
c_func
(paren
id|elf_interpreter
)paren
suffix:semicolon
id|out_free_file
suffix:colon
id|out_free_ph
suffix:colon
id|kfree
(paren
id|elf_phdata
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* This is really simpleminded and specialized - we are loading an&n; * a.out library that is given an ELF header.&n; */
DECL|function|load_irix_library
r_static
r_int
id|load_irix_library
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|elfhdr
id|elf_ex
suffix:semicolon
r_struct
id|elf_phdr
op_star
id|elf_phdata
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|elf_bss
op_assign
l_int|0
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
r_int
id|bss
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
id|error
op_assign
id|kernel_read
c_func
(paren
id|file
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|elf_ex
comma
r_sizeof
(paren
id|elf_ex
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
r_sizeof
(paren
id|elf_ex
)paren
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|elf_ex.e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
multiline_comment|/* First of all, some simple consistency checks. */
r_if
c_cond
(paren
id|elf_ex.e_type
op_ne
id|ET_EXEC
op_logical_or
id|elf_ex.e_phnum
OG
l_int|2
op_logical_or
op_logical_neg
id|irix_elf_check_arch
c_func
(paren
op_amp
id|elf_ex
)paren
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Now read in all of the header information. */
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|elf_ex.e_phnum
OG
id|PAGE_SIZE
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
id|elf_phdata
op_assign
(paren
r_struct
id|elf_phdr
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|elf_ex.e_phnum
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_phdata
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|file
comma
id|elf_ex.e_phoff
comma
(paren
r_char
op_star
)paren
id|elf_phdata
comma
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|elf_ex.e_phnum
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|elf_ex.e_phnum
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|elf_phdata
op_plus
id|i
)paren
op_member_access_from_pointer
id|p_type
op_eq
id|PT_LOAD
)paren
(brace
id|j
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_ne
l_int|1
)paren
(brace
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
r_while
c_loop
(paren
id|elf_phdata-&gt;p_type
op_ne
id|PT_LOAD
)paren
(brace
id|elf_phdata
op_increment
suffix:semicolon
)brace
multiline_comment|/* Now use mmap to map the library into memory. */
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|error
op_assign
id|do_mmap
c_func
(paren
id|file
comma
id|elf_phdata-&gt;p_vaddr
op_amp
l_int|0xfffff000
comma
id|elf_phdata-&gt;p_filesz
op_plus
(paren
id|elf_phdata-&gt;p_vaddr
op_amp
l_int|0xfff
)paren
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
id|MAP_FIXED
op_or
id|MAP_PRIVATE
op_or
id|MAP_DENYWRITE
comma
id|elf_phdata-&gt;p_offset
op_amp
l_int|0xfffff000
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|k
op_assign
id|elf_phdata-&gt;p_vaddr
op_plus
id|elf_phdata-&gt;p_filesz
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|elf_bss
)paren
id|elf_bss
op_assign
id|k
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
(paren
id|elf_phdata-&gt;p_vaddr
op_amp
l_int|0xfffff000
)paren
)paren
(brace
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|padzero
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
id|len
op_assign
(paren
id|elf_phdata-&gt;p_filesz
op_plus
id|elf_phdata-&gt;p_vaddr
op_plus
l_int|0xfff
)paren
op_amp
l_int|0xfffff000
suffix:semicolon
id|bss
op_assign
id|elf_phdata-&gt;p_memsz
op_plus
id|elf_phdata-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|bss
OG
id|len
)paren
id|do_brk
c_func
(paren
id|len
comma
id|bss
op_minus
id|len
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called through irix_syssgi() to map an elf image given an FD,&n; * a phdr ptr USER_PHDRP in userspace, and a count CNT telling how many&n; * phdrs there are in the USER_PHDRP array.  We return the vaddr the&n; * first phdr was successfully mapped to.&n; */
DECL|function|irix_mapelf
r_int
r_int
id|irix_mapelf
c_func
(paren
r_int
id|fd
comma
r_struct
id|elf_phdr
op_star
id|user_phdrp
comma
r_int
id|cnt
)paren
(brace
r_struct
id|elf_phdr
op_star
id|hp
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|i
comma
id|retval
suffix:semicolon
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;irix_mapelf: fd[%d] user_phdrp[%p] cnt[%d]&bslash;n&quot;
comma
id|fd
comma
id|user_phdrp
comma
id|cnt
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* First get the verification out of the way. */
id|hp
op_assign
id|user_phdrp
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|hp
comma
(paren
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|cnt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;irix_mapelf: verify_area fails!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_ELF
id|dump_phdrs
c_func
(paren
id|user_phdrp
comma
id|cnt
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
comma
id|hp
op_increment
)paren
r_if
c_cond
(paren
id|hp-&gt;p_type
op_ne
id|PT_LOAD
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;irix_mapelf: One section is not PT_LOAD!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_op
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;irix_mapelf: Bogon filp!&bslash;n&quot;
)paren
suffix:semicolon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
id|hp
op_assign
id|user_phdrp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
comma
id|hp
op_increment
)paren
(brace
r_int
id|prot
suffix:semicolon
id|prot
op_assign
(paren
id|hp-&gt;p_flags
op_amp
id|PF_R
)paren
ques
c_cond
id|PROT_READ
suffix:colon
l_int|0
suffix:semicolon
id|prot
op_or_assign
(paren
id|hp-&gt;p_flags
op_amp
id|PF_W
)paren
ques
c_cond
id|PROT_WRITE
suffix:colon
l_int|0
suffix:semicolon
id|prot
op_or_assign
(paren
id|hp-&gt;p_flags
op_amp
id|PF_X
)paren
ques
c_cond
id|PROT_EXEC
suffix:colon
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|retval
op_assign
id|do_mmap
c_func
(paren
id|filp
comma
(paren
id|hp-&gt;p_vaddr
op_amp
l_int|0xfffff000
)paren
comma
(paren
id|hp-&gt;p_filesz
op_plus
(paren
id|hp-&gt;p_vaddr
op_amp
l_int|0xfff
)paren
)paren
comma
id|prot
comma
(paren
id|MAP_FIXED
op_or
id|MAP_PRIVATE
op_or
id|MAP_DENYWRITE
)paren
comma
(paren
id|hp-&gt;p_offset
op_amp
l_int|0xfffff000
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
(paren
id|hp-&gt;p_vaddr
op_amp
l_int|0xfffff000
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;irix_mapelf: do_mmap fails with %d!&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_ELF
id|printk
c_func
(paren
l_string|&quot;irix_mapelf: Success, returning %08lx&bslash;n&quot;
comma
id|user_phdrp-&gt;p_vaddr
)paren
suffix:semicolon
macro_line|#endif
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
r_return
id|user_phdrp-&gt;p_vaddr
suffix:semicolon
)brace
multiline_comment|/*&n; * ELF core dumper&n; *&n; * Modelled on fs/exec.c:aout_core_dump()&n; * Jeremy Fitzhardinge &lt;jeremy@sw.oz.au&gt;&n; */
multiline_comment|/* These are the only things you should do on a core-file: use only these&n; * functions to write out all the necessary info.&n; */
DECL|function|dump_write
r_static
r_int
id|dump_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_void
op_star
id|addr
comma
r_int
id|nr
)paren
(brace
r_return
id|file-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|file
comma
id|addr
comma
id|nr
comma
op_amp
id|file-&gt;f_pos
)paren
op_eq
id|nr
suffix:semicolon
)brace
DECL|function|dump_seek
r_static
r_int
id|dump_seek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|off_t
id|off
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;llseek
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|file
comma
id|off
comma
l_int|0
)paren
op_ne
id|off
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|file-&gt;f_pos
op_assign
id|off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Decide whether a segment is worth dumping; default is yes to be&n; * sure (missing info is worse than too much; etc).&n; * Personally I&squot;d include everything, and use the coredump limit...&n; *&n; * I think we should skip something. But I am not sure how. H.J.&n; */
DECL|function|maydump
r_static
r_inline
r_int
id|maydump
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_WRITE
op_or
id|VM_EXEC
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_WRITE
op_or
id|VM_GROWSUP
op_or
id|VM_GROWSDOWN
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_EXEC
op_or
id|VM_EXECUTABLE
op_or
id|VM_SHARED
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|roundup
mdefine_line|#define roundup(x, y)  ((((x)+((y)-1))/(y))*(y))
multiline_comment|/* An ELF note in memory. */
DECL|struct|memelfnote
r_struct
id|memelfnote
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|datasz
r_int
r_int
id|datasz
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
)brace
suffix:semicolon
DECL|function|notesize
r_static
r_int
id|notesize
c_func
(paren
r_struct
id|memelfnote
op_star
id|en
)paren
(brace
r_int
id|sz
suffix:semicolon
id|sz
op_assign
r_sizeof
(paren
r_struct
id|elf_note
)paren
suffix:semicolon
id|sz
op_add_assign
id|roundup
c_func
(paren
id|strlen
c_func
(paren
id|en-&gt;name
)paren
comma
l_int|4
)paren
suffix:semicolon
id|sz
op_add_assign
id|roundup
c_func
(paren
id|en-&gt;datasz
comma
l_int|4
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/* #define DEBUG */
DECL|macro|DUMP_WRITE
mdefine_line|#define DUMP_WRITE(addr, nr)&t;&bslash;&n;&t;if (!dump_write(file, (addr), (nr))) &bslash;&n;&t;&t;goto end_coredump;
DECL|macro|DUMP_SEEK
mdefine_line|#define DUMP_SEEK(off)&t;&bslash;&n;&t;if (!dump_seek(file, (off))) &bslash;&n;&t;&t;goto end_coredump;
DECL|function|writenote
r_static
r_int
id|writenote
c_func
(paren
r_struct
id|memelfnote
op_star
id|men
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|elf_note
id|en
suffix:semicolon
id|en.n_namesz
op_assign
id|strlen
c_func
(paren
id|men-&gt;name
)paren
suffix:semicolon
id|en.n_descsz
op_assign
id|men-&gt;datasz
suffix:semicolon
id|en.n_type
op_assign
id|men-&gt;type
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
op_amp
id|en
comma
r_sizeof
(paren
id|en
)paren
)paren
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
id|men-&gt;name
comma
id|en.n_namesz
)paren
suffix:semicolon
multiline_comment|/* XXX - cast from long long to long to avoid need for libgcc.a */
id|DUMP_SEEK
c_func
(paren
id|roundup
c_func
(paren
(paren
r_int
r_int
)paren
id|file-&gt;f_pos
comma
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX */
id|DUMP_WRITE
c_func
(paren
id|men-&gt;data
comma
id|men-&gt;datasz
)paren
suffix:semicolon
id|DUMP_SEEK
c_func
(paren
id|roundup
c_func
(paren
(paren
r_int
r_int
)paren
id|file-&gt;f_pos
comma
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX */
r_return
l_int|1
suffix:semicolon
id|end_coredump
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|DUMP_WRITE
macro_line|#undef DUMP_WRITE
DECL|macro|DUMP_SEEK
macro_line|#undef DUMP_SEEK
DECL|macro|DUMP_WRITE
mdefine_line|#define DUMP_WRITE(addr, nr)&t;&bslash;&n;&t;if (!dump_write(file, (addr), (nr))) &bslash;&n;&t;&t;goto end_coredump;
DECL|macro|DUMP_SEEK
mdefine_line|#define DUMP_SEEK(off)&t;&bslash;&n;&t;if (!dump_seek(file, (off))) &bslash;&n;&t;&t;goto end_coredump;
multiline_comment|/* Actual dumper.&n; *&n; * This is a two-pass process; first we find the offsets of the bits,&n; * and then they are actually written out.  If we run out of core limit&n; * we just truncate.&n; */
DECL|function|irix_core_dump
r_static
r_int
id|irix_core_dump
c_func
(paren
r_int
id|signr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|has_dumped
op_assign
l_int|0
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|segs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|elfhdr
id|elf
suffix:semicolon
id|off_t
id|offset
op_assign
l_int|0
comma
id|dataoff
suffix:semicolon
r_int
id|limit
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_CORE
)braket
dot
id|rlim_cur
suffix:semicolon
r_int
id|numnote
op_assign
l_int|4
suffix:semicolon
r_struct
id|memelfnote
id|notes
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|elf_prstatus
id|prstatus
suffix:semicolon
multiline_comment|/* NT_PRSTATUS */
id|elf_fpregset_t
id|fpu
suffix:semicolon
multiline_comment|/* NT_PRFPREG */
r_struct
id|elf_prpsinfo
id|psinfo
suffix:semicolon
multiline_comment|/* NT_PRPSINFO */
multiline_comment|/* Count what&squot;s needed to dump, up to the limit of coredump size. */
id|segs
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|current-&gt;mm-&gt;mmap
suffix:semicolon
id|vma
op_ne
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
id|maydump
c_func
(paren
id|vma
)paren
)paren
(brace
r_int
id|sz
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
op_plus
id|sz
op_ge
id|limit
)paren
r_break
suffix:semicolon
r_else
id|size
op_add_assign
id|sz
suffix:semicolon
)brace
id|segs
op_increment
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;irix_core_dump: %d segs taking %d bytes&bslash;n&quot;
comma
id|segs
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set up header. */
id|memcpy
c_func
(paren
id|elf.e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
suffix:semicolon
id|elf.e_ident
(braket
id|EI_CLASS
)braket
op_assign
id|ELFCLASS32
suffix:semicolon
id|elf.e_ident
(braket
id|EI_DATA
)braket
op_assign
id|ELFDATA2LSB
suffix:semicolon
id|elf.e_ident
(braket
id|EI_VERSION
)braket
op_assign
id|EV_CURRENT
suffix:semicolon
id|memset
c_func
(paren
id|elf.e_ident
op_plus
id|EI_PAD
comma
l_int|0
comma
id|EI_NIDENT
op_minus
id|EI_PAD
)paren
suffix:semicolon
id|elf.e_type
op_assign
id|ET_CORE
suffix:semicolon
id|elf.e_machine
op_assign
id|ELF_ARCH
suffix:semicolon
id|elf.e_version
op_assign
id|EV_CURRENT
suffix:semicolon
id|elf.e_entry
op_assign
l_int|0
suffix:semicolon
id|elf.e_phoff
op_assign
r_sizeof
(paren
id|elf
)paren
suffix:semicolon
id|elf.e_shoff
op_assign
l_int|0
suffix:semicolon
id|elf.e_flags
op_assign
l_int|0
suffix:semicolon
id|elf.e_ehsize
op_assign
r_sizeof
(paren
id|elf
)paren
suffix:semicolon
id|elf.e_phentsize
op_assign
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
suffix:semicolon
id|elf.e_phnum
op_assign
id|segs
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Include notes. */
id|elf.e_shentsize
op_assign
l_int|0
suffix:semicolon
id|elf.e_shnum
op_assign
l_int|0
suffix:semicolon
id|elf.e_shstrndx
op_assign
l_int|0
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|has_dumped
op_assign
l_int|1
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_DUMPCORE
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
op_amp
id|elf
comma
r_sizeof
(paren
id|elf
)paren
)paren
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
id|elf
)paren
suffix:semicolon
multiline_comment|/* Elf header. */
id|offset
op_add_assign
(paren
id|segs
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
suffix:semicolon
multiline_comment|/* Program headers. */
multiline_comment|/* Set up the notes in similar form to SVR4 core dumps made&n;&t; * with info from their /proc.&n;&t; */
id|memset
c_func
(paren
op_amp
id|psinfo
comma
l_int|0
comma
r_sizeof
(paren
id|psinfo
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|prstatus
comma
l_int|0
comma
r_sizeof
(paren
id|prstatus
)paren
)paren
suffix:semicolon
id|notes
(braket
l_int|0
)braket
dot
id|name
op_assign
l_string|&quot;CORE&quot;
suffix:semicolon
id|notes
(braket
l_int|0
)braket
dot
id|type
op_assign
id|NT_PRSTATUS
suffix:semicolon
id|notes
(braket
l_int|0
)braket
dot
id|datasz
op_assign
r_sizeof
(paren
id|prstatus
)paren
suffix:semicolon
id|notes
(braket
l_int|0
)braket
dot
id|data
op_assign
op_amp
id|prstatus
suffix:semicolon
id|prstatus.pr_info.si_signo
op_assign
id|prstatus.pr_cursig
op_assign
id|signr
suffix:semicolon
id|prstatus.pr_sigpend
op_assign
id|current-&gt;pending.signal.sig
(braket
l_int|0
)braket
suffix:semicolon
id|prstatus.pr_sighold
op_assign
id|current-&gt;blocked.sig
(braket
l_int|0
)braket
suffix:semicolon
id|psinfo.pr_pid
op_assign
id|prstatus.pr_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|psinfo.pr_ppid
op_assign
id|prstatus.pr_ppid
op_assign
id|current-&gt;p_pptr-&gt;pid
suffix:semicolon
id|psinfo.pr_pgrp
op_assign
id|prstatus.pr_pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
id|psinfo.pr_sid
op_assign
id|prstatus.pr_sid
op_assign
id|current-&gt;session
suffix:semicolon
id|prstatus.pr_utime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|current-&gt;times.tms_utime
)paren
suffix:semicolon
id|prstatus.pr_utime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|current-&gt;times.tms_utime
)paren
suffix:semicolon
id|prstatus.pr_stime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|current-&gt;times.tms_stime
)paren
suffix:semicolon
id|prstatus.pr_stime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|current-&gt;times.tms_stime
)paren
suffix:semicolon
id|prstatus.pr_cutime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|current-&gt;times.tms_cutime
)paren
suffix:semicolon
id|prstatus.pr_cutime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|current-&gt;times.tms_cutime
)paren
suffix:semicolon
id|prstatus.pr_cstime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|current-&gt;times.tms_cstime
)paren
suffix:semicolon
id|prstatus.pr_cstime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|current-&gt;times.tms_cstime
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|elf_gregset_t
)paren
op_ne
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sizeof(elf_gregset_t) (%d) != sizeof(struct pt_regs) &quot;
l_string|&quot;(%d)&bslash;n&quot;
comma
r_sizeof
(paren
id|elf_gregset_t
)paren
comma
r_sizeof
(paren
r_struct
id|pt_regs
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
r_struct
id|pt_regs
op_star
)paren
op_amp
id|prstatus.pr_reg
op_assign
op_star
id|regs
suffix:semicolon
)brace
id|notes
(braket
l_int|1
)braket
dot
id|name
op_assign
l_string|&quot;CORE&quot;
suffix:semicolon
id|notes
(braket
l_int|1
)braket
dot
id|type
op_assign
id|NT_PRPSINFO
suffix:semicolon
id|notes
(braket
l_int|1
)braket
dot
id|datasz
op_assign
r_sizeof
(paren
id|psinfo
)paren
suffix:semicolon
id|notes
(braket
l_int|1
)braket
dot
id|data
op_assign
op_amp
id|psinfo
suffix:semicolon
id|i
op_assign
id|current-&gt;state
ques
c_cond
id|ffz
c_func
(paren
op_complement
id|current-&gt;state
)paren
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|psinfo.pr_state
op_assign
id|i
suffix:semicolon
id|psinfo.pr_sname
op_assign
(paren
id|i
template_param
l_int|5
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_string|&quot;RSDZTD&quot;
(braket
id|i
)braket
suffix:semicolon
id|psinfo.pr_zomb
op_assign
id|psinfo.pr_sname
op_eq
l_char|&squot;Z&squot;
suffix:semicolon
id|psinfo.pr_nice
op_assign
id|current-&gt;nice
suffix:semicolon
id|psinfo.pr_flag
op_assign
id|current-&gt;flags
suffix:semicolon
id|psinfo.pr_uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|psinfo.pr_gid
op_assign
id|current-&gt;gid
suffix:semicolon
(brace
r_int
id|i
comma
id|len
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
id|len
op_assign
id|current-&gt;mm-&gt;arg_end
op_minus
id|current-&gt;mm-&gt;arg_start
suffix:semicolon
id|len
op_assign
id|len
op_ge
id|ELF_PRARGSZ
ques
c_cond
id|ELF_PRARGSZ
suffix:colon
id|len
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|psinfo.pr_psargs
comma
(paren
r_const
r_char
op_star
)paren
id|current-&gt;mm-&gt;arg_start
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|psinfo.pr_psargs
(braket
id|i
)braket
op_eq
l_int|0
)paren
id|psinfo.pr_psargs
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|psinfo.pr_psargs
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|psinfo.pr_fname
comma
id|current-&gt;comm
comma
r_sizeof
(paren
id|psinfo.pr_fname
)paren
)paren
suffix:semicolon
id|notes
(braket
l_int|2
)braket
dot
id|name
op_assign
l_string|&quot;CORE&quot;
suffix:semicolon
id|notes
(braket
l_int|2
)braket
dot
id|type
op_assign
id|NT_TASKSTRUCT
suffix:semicolon
id|notes
(braket
l_int|2
)braket
dot
id|datasz
op_assign
r_sizeof
(paren
op_star
id|current
)paren
suffix:semicolon
id|notes
(braket
l_int|2
)braket
dot
id|data
op_assign
id|current
suffix:semicolon
multiline_comment|/* Try to dump the FPU. */
id|prstatus.pr_fpvalid
op_assign
id|dump_fpu
(paren
op_amp
id|fpu
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prstatus.pr_fpvalid
)paren
(brace
id|numnote
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|notes
(braket
l_int|3
)braket
dot
id|name
op_assign
l_string|&quot;CORE&quot;
suffix:semicolon
id|notes
(braket
l_int|3
)braket
dot
id|type
op_assign
id|NT_PRFPREG
suffix:semicolon
id|notes
(braket
l_int|3
)braket
dot
id|datasz
op_assign
r_sizeof
(paren
id|fpu
)paren
suffix:semicolon
id|notes
(braket
l_int|3
)braket
dot
id|data
op_assign
op_amp
id|fpu
suffix:semicolon
)brace
multiline_comment|/* Write notes phdr entry. */
(brace
r_struct
id|elf_phdr
id|phdr
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numnote
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sz
op_add_assign
id|notesize
c_func
(paren
op_amp
id|notes
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|phdr.p_type
op_assign
id|PT_NOTE
suffix:semicolon
id|phdr.p_offset
op_assign
id|offset
suffix:semicolon
id|phdr.p_vaddr
op_assign
l_int|0
suffix:semicolon
id|phdr.p_paddr
op_assign
l_int|0
suffix:semicolon
id|phdr.p_filesz
op_assign
id|sz
suffix:semicolon
id|phdr.p_memsz
op_assign
l_int|0
suffix:semicolon
id|phdr.p_flags
op_assign
l_int|0
suffix:semicolon
id|phdr.p_align
op_assign
l_int|0
suffix:semicolon
id|offset
op_add_assign
id|phdr.p_filesz
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
op_amp
id|phdr
comma
r_sizeof
(paren
id|phdr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Page-align dumped data. */
id|dataoff
op_assign
id|offset
op_assign
id|roundup
c_func
(paren
id|offset
comma
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/* Write program headers for segments dump. */
r_for
c_loop
(paren
id|vma
op_assign
id|current-&gt;mm-&gt;mmap
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|segs
op_logical_and
id|vma
op_ne
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_struct
id|elf_phdr
id|phdr
suffix:semicolon
r_int
id|sz
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|sz
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
id|phdr.p_type
op_assign
id|PT_LOAD
suffix:semicolon
id|phdr.p_offset
op_assign
id|offset
suffix:semicolon
id|phdr.p_vaddr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
id|phdr.p_paddr
op_assign
l_int|0
suffix:semicolon
id|phdr.p_filesz
op_assign
id|maydump
c_func
(paren
id|vma
)paren
ques
c_cond
id|sz
suffix:colon
l_int|0
suffix:semicolon
id|phdr.p_memsz
op_assign
id|sz
suffix:semicolon
id|offset
op_add_assign
id|phdr.p_filesz
suffix:semicolon
id|phdr.p_flags
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_READ
ques
c_cond
id|PF_R
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
id|phdr.p_flags
op_or_assign
id|PF_W
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
id|phdr.p_flags
op_or_assign
id|PF_X
suffix:semicolon
id|phdr.p_align
op_assign
id|PAGE_SIZE
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
op_amp
id|phdr
comma
r_sizeof
(paren
id|phdr
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numnote
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|writenote
c_func
(paren
op_amp
id|notes
(braket
id|i
)braket
comma
id|file
)paren
)paren
r_goto
id|end_coredump
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
id|DUMP_SEEK
c_func
(paren
id|dataoff
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|vma
op_assign
id|current-&gt;mm-&gt;mmap
suffix:semicolon
id|i
OL
id|segs
op_logical_and
id|vma
op_ne
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_int
r_int
id|addr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_int
r_int
id|len
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|maydump
c_func
(paren
id|vma
)paren
)paren
r_continue
suffix:semicolon
id|i
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;elf_core_dump: writing %08lx %lx&bslash;n&quot;
comma
id|addr
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|DUMP_WRITE
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|off_t
)paren
id|file-&gt;f_pos
op_ne
id|offset
)paren
(brace
multiline_comment|/* Sanity check. */
id|printk
c_func
(paren
l_string|&quot;elf_core_dump: file-&gt;f_pos (%ld) != offset (%ld)&bslash;n&quot;
comma
(paren
id|off_t
)paren
id|file-&gt;f_pos
comma
id|offset
)paren
suffix:semicolon
)brace
id|end_coredump
suffix:colon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_return
id|has_dumped
suffix:semicolon
)brace
DECL|function|init_irix_binfmt
r_static
r_int
id|__init
id|init_irix_binfmt
c_func
(paren
r_void
)paren
(brace
r_return
id|register_binfmt
c_func
(paren
op_amp
id|irix_format
)paren
suffix:semicolon
)brace
DECL|function|exit_irix_binfmt
r_static
r_void
id|__exit
id|exit_irix_binfmt
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Remove the IRIX ELF loaders. */
id|unregister_binfmt
c_func
(paren
op_amp
id|irix_format
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|init_irix_binfmt
)paren
id|module_exit
c_func
(paren
id|exit_irix_binfmt
)paren
eof
