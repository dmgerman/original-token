multiline_comment|/*&n; *  arch/mips/kernel/gdb-stub.c&n; *&n; *  Originally written by Glenn Engel, Lake Stevens Instrument Division&n; *&n; *  Contributed by HP Systems&n; *&n; *  Modified for SPARC by Stu Grossman, Cygnus Support.&n; *&n; *  Modified for Linux/MIPS (and MIPS in general) by Andreas Busse&n; *  Send complaints, suggestions etc. to &lt;andy@waldorf-gmbh.de&gt;&n; *&n; *  Copyright (C) 1995 Andreas Busse&n; *&n; * $Id: gdb-stub.c,v 1.6 1999/05/01 22:40:35 ralf Exp $&n; */
multiline_comment|/*&n; *  To enable debugger support, two things need to happen.  One, a&n; *  call to set_debug_traps() is necessary in order to allow any breakpoints&n; *  or error conditions to be properly intercepted and reported to gdb.&n; *  Two, a breakpoint needs to be generated to begin communication.  This&n; *  is most easily accomplished by a call to breakpoint().  Breakpoint()&n; *  simulates a breakpoint by executing a BREAK instruction.&n; *&n; *&n; *    The following gdb commands are supported:&n; *&n; * command          function                               Return value&n; *&n; *    g             return the value of the CPU registers  hex data or ENN&n; *    G             set the value of the CPU registers     OK or ENN&n; *&n; *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN&n; *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN&n; *&n; *    c             Resume at current address              SNN   ( signal NN)&n; *    cAA..AA       Continue at address AA..AA             SNN&n; *&n; *    s             Step one instruction                   SNN&n; *    sAA..AA       Step one instruction from AA..AA       SNN&n; *&n; *    k             kill&n; *&n; *    ?             What was the last sigval ?             SNN   (signal NN)&n; *&n; *    bBB..BB&t;    Set baud rate to BB..BB&t;&t;   OK or BNN, then sets&n; *&t;&t;&t;&t;&t;&t;&t;   baud rate&n; *&n; * All commands and responses are sent with a packet which includes a&n; * checksum.  A packet consists of&n; *&n; * $&lt;packet info&gt;#&lt;checksum&gt;.&n; *&n; * where&n; * &lt;packet info&gt; :: &lt;characters representing the command or response&gt;&n; * &lt;checksum&gt;    :: &lt; two hex digits computed as modulo 256 sum of &lt;packetinfo&gt;&gt;&n; *&n; * When a packet is received, it is first acknowledged with either &squot;+&squot; or &squot;-&squot;.&n; * &squot;+&squot; indicates a successful transfer.  &squot;-&squot; indicates a failed transfer.&n; *&n; * Example:&n; *&n; * Host:                  Reply:&n; * $m0,10#2a               +$00010203040506070809101112131415#42&n; *&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/asm.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/gdb-stub.h&gt;
macro_line|#include &lt;asm/inst.h&gt;
multiline_comment|/*&n; * external low-level support routines&n; */
r_extern
r_int
id|putDebugChar
c_func
(paren
r_char
id|c
)paren
suffix:semicolon
multiline_comment|/* write a single character      */
r_extern
r_char
id|getDebugChar
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* read and return a single char */
r_extern
r_void
id|fltr_set_mem_err
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|trap_low
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * breakpoint and test functions&n; */
r_extern
r_void
id|breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|breakinst
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|adel
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * local prototypes&n; */
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|computeSignal
c_func
(paren
r_int
id|tt
)paren
suffix:semicolon
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
suffix:semicolon
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
suffix:semicolon
r_void
id|handle_exception
c_func
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; * BUFMAX defines the maximum number of characters in inbound/outbound buffers&n; * at least NUMREGBYTES*2 are needed for register packets&n; */
DECL|macro|BUFMAX
mdefine_line|#define BUFMAX 2048
DECL|variable|input_buffer
r_static
r_char
id|input_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|output_buffer
r_static
r_char
id|output_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|initialized
r_static
r_int
id|initialized
suffix:semicolon
multiline_comment|/* !0 means we&squot;ve been initialized */
DECL|variable|hexchars
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
multiline_comment|/*&n; * Convert ch from a hex digit to an int&n; */
DECL|function|hex
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * scan for the sequence $&lt;data&gt;#&lt;checksum&gt;&n; */
DECL|function|getpacket
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
r_char
id|xmitcsum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * wait around for the start character,&n;&t;&t; * ignore all other characters&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|ch
op_assign
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|xmitcsum
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now, read until a # or end of buffer is found&n;&t;&t; */
r_while
c_loop
(paren
id|count
OL
id|BUFMAX
)paren
(brace
id|ch
op_assign
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
id|checksum
op_assign
id|checksum
op_plus
id|ch
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
id|ch
suffix:semicolon
id|count
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
id|BUFMAX
)paren
r_continue
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|xmitcsum
op_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_lshift
l_int|4
suffix:semicolon
id|xmitcsum
op_or_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|xmitcsum
)paren
id|putDebugChar
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
multiline_comment|/* failed checksum */
r_else
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* successful transfer */
multiline_comment|/*&n;&t;&t;&t;&t; * if a sequence char is present,&n;&t;&t;&t;&t; * reply the sequence ID&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer
(braket
l_int|2
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * remove sequence chars from buffer&n;&t;&t;&t;&t;&t; */
id|count
op_assign
id|strlen
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
id|buffer
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|checksum
op_ne
id|xmitcsum
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send the packet in buffer.&n; */
DECL|function|putpacket
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&n;&t; * $&lt;packet info&gt;#&lt;checksum&gt;.&n;&t; */
r_do
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|buffer
(braket
id|count
)braket
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|putDebugChar
c_func
(paren
id|ch
)paren
)paren
)paren
r_return
suffix:semicolon
id|checksum
op_add_assign
id|ch
suffix:semicolon
id|count
op_add_assign
l_int|1
suffix:semicolon
)brace
id|putDebugChar
c_func
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_amp
l_int|0xf
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_ne
l_char|&squot;+&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Indicate to caller of mem2hex or hex2mem that there&n; * has been an error.&n; */
DECL|variable|mem_err
r_static
r_volatile
r_int
id|mem_err
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_static
r_void
id|set_mem_fault_trap
c_func
(paren
r_int
id|enable
)paren
(brace
id|mem_err
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|enable
)paren
id|exceptionHandler
c_func
(paren
l_int|9
comma
id|fltr_set_mem_err
)paren
suffix:semicolon
r_else
id|exceptionHandler
c_func
(paren
l_int|9
comma
id|trap_low
)paren
suffix:semicolon
macro_line|#endif  
)brace
macro_line|#endif /* dead code */
multiline_comment|/*&n; * Convert the memory pointed to by mem into hex, placing result in buf.&n; * Return a pointer to the last char put in buf (null), in case of mem fault,&n; * return 0.&n; * If MAY_FAULT is non-zero, then we will handle memory faults by returning&n; * a 0, else treat a fault like any other fault in the stub.&n; */
DECL|function|mem2hex
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&t;set_mem_fault_trap(may_fault); */
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|ch
op_assign
op_star
(paren
id|mem
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_err
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&t;set_mem_fault_trap(0); */
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * convert the hex array pointed to by buf into binary to be placed in mem&n; * return a pointer to the character AFTER the last byte written&n; */
DECL|function|hex2mem
r_static
r_char
op_star
id|hex2mem
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|mem
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&t;set_mem_fault_trap(may_fault); */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ch
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
op_star
(paren
id|mem
op_increment
)paren
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|mem_err
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;set_mem_fault_trap(0); */
r_return
id|mem
suffix:semicolon
)brace
multiline_comment|/*&n; * This table contains the mapping between SPARC hardware trap types, and&n; * signals, which are primarily what GDB understands.  It also indicates&n; * which hardware traps we need to commandeer when initializing the stub.&n; */
DECL|struct|hard_trap_info
r_static
r_struct
id|hard_trap_info
(brace
DECL|member|tt
r_int
r_char
id|tt
suffix:semicolon
multiline_comment|/* Trap type code for MIPS R3xxx and R4xxx */
DECL|member|signo
r_int
r_char
id|signo
suffix:semicolon
multiline_comment|/* Signal that we map this trap into */
DECL|variable|hard_trap_info
)brace
id|hard_trap_info
(braket
)braket
op_assign
(brace
(brace
l_int|4
comma
id|SIGBUS
)brace
comma
multiline_comment|/* address error (load) */
(brace
l_int|5
comma
id|SIGBUS
)brace
comma
multiline_comment|/* address error (store) */
(brace
l_int|6
comma
id|SIGBUS
)brace
comma
multiline_comment|/* instruction bus error */
(brace
l_int|7
comma
id|SIGBUS
)brace
comma
multiline_comment|/* data bus error */
(brace
l_int|9
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* break */
(brace
l_int|10
comma
id|SIGILL
)brace
comma
multiline_comment|/* reserved instruction */
multiline_comment|/*&t;{ 11, SIGILL },&t;&t;*/
multiline_comment|/* CPU unusable */
(brace
l_int|12
comma
id|SIGFPE
)brace
comma
multiline_comment|/* overflow */
(brace
l_int|13
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* trap */
(brace
l_int|14
comma
id|SIGSEGV
)brace
comma
multiline_comment|/* virtual instruction cache coherency */
(brace
l_int|15
comma
id|SIGFPE
)brace
comma
multiline_comment|/* floating point exception */
(brace
l_int|23
comma
id|SIGSEGV
)brace
comma
multiline_comment|/* watch */
(brace
l_int|31
comma
id|SIGSEGV
)brace
comma
multiline_comment|/* virtual data cache coherency */
(brace
l_int|0
comma
l_int|0
)brace
multiline_comment|/* Must be last */
)brace
suffix:semicolon
multiline_comment|/*&n; * Set up exception handlers for tracing and breakpoints&n; */
DECL|function|set_debug_traps
r_void
id|set_debug_traps
c_func
(paren
r_void
)paren
(brace
r_struct
id|hard_trap_info
op_star
id|ht
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ht
op_assign
id|hard_trap_info
suffix:semicolon
id|ht-&gt;tt
op_logical_and
id|ht-&gt;signo
suffix:semicolon
id|ht
op_increment
)paren
id|set_except_vector
c_func
(paren
id|ht-&gt;tt
comma
id|trap_low
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In case GDB is started before us, ack any packets&n;&t; * (presumably &quot;$?#xx&quot;) sitting there.&n;&t; */
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
(brace
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;#&squot;
)paren
(brace
suffix:semicolon
)brace
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* eat first csum byte */
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* eat second csum byte */
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* ack it */
id|initialized
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Trap handler for memory errors.  This just sets mem_err to be non-zero.  It&n; * assumes that %l1 is non-zero.  This should be safe, as it is doubtful that&n; * 0 would ever contain code that could mem fault.  This routine will skip&n; * past the faulting instruction after setting mem_err.&n; */
DECL|function|fltr_set_mem_err
r_extern
r_void
id|fltr_set_mem_err
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* FIXME: Needs to be written... */
)brace
multiline_comment|/*&n; * Convert the MIPS hardware trap type code to a Unix signal number.&n; */
DECL|function|computeSignal
r_static
r_int
id|computeSignal
c_func
(paren
r_int
id|tt
)paren
(brace
r_struct
id|hard_trap_info
op_star
id|ht
suffix:semicolon
r_for
c_loop
(paren
id|ht
op_assign
id|hard_trap_info
suffix:semicolon
id|ht-&gt;tt
op_logical_and
id|ht-&gt;signo
suffix:semicolon
id|ht
op_increment
)paren
r_if
c_cond
(paren
id|ht-&gt;tt
op_eq
id|tt
)paren
r_return
id|ht-&gt;signo
suffix:semicolon
r_return
id|SIGHUP
suffix:semicolon
multiline_comment|/* default for things we don&squot;t know about */
)brace
multiline_comment|/*&n; * While we find nice hex chars, build an int.&n; * Return number of chars processed.&n; */
DECL|function|hexToInt
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
(brace
r_int
id|numChars
op_assign
l_int|0
suffix:semicolon
r_int
id|hexValue
suffix:semicolon
op_star
id|intValue
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|ptr
)paren
(brace
id|hexValue
op_assign
id|hex
c_func
(paren
op_star
op_star
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hexValue
OL
l_int|0
)paren
r_break
suffix:semicolon
op_star
id|intValue
op_assign
(paren
op_star
id|intValue
op_lshift
l_int|4
)paren
op_or
id|hexValue
suffix:semicolon
id|numChars
op_increment
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
(paren
id|numChars
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Print registers (on target console)&n; * Used only to debug the stub...&n; */
r_void
id|show_gdbregs
c_func
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * Saved main processor registers&n;&t; */
id|printk
c_func
(paren
l_string|&quot;$0 : %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg0
comma
id|regs-&gt;reg1
comma
id|regs-&gt;reg2
comma
id|regs-&gt;reg3
comma
id|regs-&gt;reg4
comma
id|regs-&gt;reg5
comma
id|regs-&gt;reg6
comma
id|regs-&gt;reg7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$8 : %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg8
comma
id|regs-&gt;reg9
comma
id|regs-&gt;reg10
comma
id|regs-&gt;reg11
comma
id|regs-&gt;reg12
comma
id|regs-&gt;reg13
comma
id|regs-&gt;reg14
comma
id|regs-&gt;reg15
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$16: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg16
comma
id|regs-&gt;reg17
comma
id|regs-&gt;reg18
comma
id|regs-&gt;reg19
comma
id|regs-&gt;reg20
comma
id|regs-&gt;reg21
comma
id|regs-&gt;reg22
comma
id|regs-&gt;reg23
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$24: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg24
comma
id|regs-&gt;reg25
comma
id|regs-&gt;reg26
comma
id|regs-&gt;reg27
comma
id|regs-&gt;reg28
comma
id|regs-&gt;reg29
comma
id|regs-&gt;reg30
comma
id|regs-&gt;reg31
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Saved cp0 registers&n;&t; */
id|printk
c_func
(paren
l_string|&quot;epc  : %08lx&bslash;nStatus: %08lx&bslash;nCause : %08lx&bslash;n&quot;
comma
id|regs-&gt;cp0_epc
comma
id|regs-&gt;cp0_status
comma
id|regs-&gt;cp0_cause
)paren
suffix:semicolon
)brace
macro_line|#endif /* dead code */
multiline_comment|/*&n; * We single-step by setting breakpoints. When an exception&n; * is handled, we need to restore the instructions hoisted&n; * when the breakpoints were set.&n; *&n; * This is where we save the original instructions.&n; */
DECL|struct|gdb_bp_save
r_static
r_struct
id|gdb_bp_save
(brace
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
DECL|member|val
r_int
r_int
id|val
suffix:semicolon
DECL|variable|step_bp
)brace
id|step_bp
(braket
l_int|2
)braket
suffix:semicolon
DECL|macro|BP
mdefine_line|#define BP 0x0000000d  /* break opcode */
multiline_comment|/*&n; * Set breakpoint instructions for single stepping.&n; */
DECL|function|single_step
r_static
r_void
id|single_step
c_func
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
(brace
r_union
id|mips_instruction
id|insn
suffix:semicolon
r_int
r_int
id|targ
suffix:semicolon
r_int
id|is_branch
comma
id|is_cond
comma
id|i
suffix:semicolon
id|targ
op_assign
id|regs-&gt;cp0_epc
suffix:semicolon
id|insn.word
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|targ
suffix:semicolon
id|is_branch
op_assign
id|is_cond
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|insn.i_format.opcode
)paren
(brace
multiline_comment|/*&n;&t; * jr and jalr are in r_format format.&n;&t; */
r_case
id|spec_op
suffix:colon
r_switch
c_cond
(paren
id|insn.r_format.func
)paren
(brace
r_case
id|jalr_op
suffix:colon
r_case
id|jr_op
suffix:colon
id|targ
op_assign
op_star
(paren
op_amp
id|regs-&gt;reg0
op_plus
id|insn.r_format.rs
)paren
suffix:semicolon
id|is_branch
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * This group contains:&n;&t; * bltz_op, bgez_op, bltzl_op, bgezl_op,&n;&t; * bltzal_op, bgezal_op, bltzall_op, bgezall_op.&n;&t; */
r_case
id|bcond_op
suffix:colon
id|is_branch
op_assign
id|is_cond
op_assign
l_int|1
suffix:semicolon
id|targ
op_add_assign
l_int|4
op_plus
(paren
id|insn.i_format.simmediate
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * These are unconditional and in j_format.&n;&t; */
r_case
id|jal_op
suffix:colon
r_case
id|j_op
suffix:colon
id|is_branch
op_assign
l_int|1
suffix:semicolon
id|targ
op_add_assign
l_int|4
suffix:semicolon
id|targ
op_rshift_assign
l_int|28
suffix:semicolon
id|targ
op_lshift_assign
l_int|28
suffix:semicolon
id|targ
op_or_assign
(paren
id|insn.j_format.target
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * These are conditional.&n;&t; */
r_case
id|beq_op
suffix:colon
r_case
id|beql_op
suffix:colon
r_case
id|bne_op
suffix:colon
r_case
id|bnel_op
suffix:colon
r_case
id|blez_op
suffix:colon
r_case
id|blezl_op
suffix:colon
r_case
id|bgtz_op
suffix:colon
r_case
id|bgtzl_op
suffix:colon
r_case
id|cop0_op
suffix:colon
r_case
id|cop1_op
suffix:colon
r_case
id|cop2_op
suffix:colon
r_case
id|cop1x_op
suffix:colon
id|is_branch
op_assign
id|is_cond
op_assign
l_int|1
suffix:semicolon
id|targ
op_add_assign
l_int|4
op_plus
(paren
id|insn.i_format.simmediate
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_branch
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_cond
op_logical_and
id|targ
op_ne
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|8
)paren
)paren
(brace
id|step_bp
(braket
id|i
)braket
dot
id|addr
op_assign
id|regs-&gt;cp0_epc
op_plus
l_int|8
suffix:semicolon
id|step_bp
(braket
id|i
op_increment
)braket
dot
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|8
)paren
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|8
)paren
op_assign
id|BP
suffix:semicolon
)brace
id|step_bp
(braket
id|i
)braket
dot
id|addr
op_assign
id|targ
suffix:semicolon
id|step_bp
(braket
id|i
)braket
dot
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
id|targ
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|targ
op_assign
id|BP
suffix:semicolon
)brace
r_else
(brace
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|regs-&gt;cp0_epc
op_plus
l_int|4
suffix:semicolon
id|step_bp
(braket
l_int|0
)braket
dot
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|4
)paren
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|4
)paren
op_assign
id|BP
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  If asynchronously interrupted by gdb, then we need to set a breakpoint&n; *  at the interrupted instruction so that we wind up stopped with a &n; *  reasonable stack frame.&n; */
DECL|variable|async_bp
r_static
r_struct
id|gdb_bp_save
id|async_bp
suffix:semicolon
DECL|function|set_async_breakpoint
r_void
id|set_async_breakpoint
c_func
(paren
r_int
r_int
id|epc
)paren
(brace
id|async_bp.addr
op_assign
id|epc
suffix:semicolon
id|async_bp.val
op_assign
op_star
(paren
r_int
op_star
)paren
id|epc
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|epc
op_assign
id|BP
suffix:semicolon
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function does all command processing for interfacing to gdb.  It&n; * returns 1 if you should skip the instruction at the trap address, 0&n; * otherwise.&n; */
DECL|function|handle_exception
r_void
id|handle_exception
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
(brace
r_int
id|trap
suffix:semicolon
multiline_comment|/* Trap type */
r_int
id|sigval
suffix:semicolon
r_int
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
op_star
id|stack
suffix:semicolon
macro_line|#if 0&t;
id|printk
c_func
(paren
l_string|&quot;in handle_exception()&bslash;n&quot;
)paren
suffix:semicolon
id|show_gdbregs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * First check trap type. If this is CPU_UNUSABLE and CPU_ID is 1,&n;&t; * the simply switch the FPU on and return since this is no error&n;&t; * condition. kernel/traps.c does the same.&n;&t; * FIXME: This doesn&squot;t work yet, so we don&squot;t catch CPU_UNUSABLE&n;&t; * traps for now.&n;&t; */
id|trap
op_assign
(paren
id|regs-&gt;cp0_cause
op_amp
l_int|0x7c
)paren
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/*&t;printk(&quot;trap=%d&bslash;n&quot;,trap); */
r_if
c_cond
(paren
id|trap
op_eq
l_int|11
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|regs-&gt;cp0_cause
op_rshift
id|CAUSEB_CE
)paren
op_amp
l_int|3
)paren
op_eq
l_int|1
)paren
(brace
id|regs-&gt;cp0_status
op_or_assign
id|ST0_CU1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we&squot;re in breakpoint() increment the PC&n;&t; */
r_if
c_cond
(paren
id|trap
op_eq
l_int|9
op_logical_and
id|regs-&gt;cp0_epc
op_eq
(paren
r_int
r_int
)paren
id|breakinst
)paren
id|regs-&gt;cp0_epc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t; * If we were single_stepping, restore the opcodes hoisted&n;&t; * for the breakpoint[s].&n;&t; */
r_if
c_cond
(paren
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
)paren
(brace
op_star
(paren
r_int
op_star
)paren
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|step_bp
(braket
l_int|0
)braket
dot
id|val
suffix:semicolon
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|step_bp
(braket
l_int|1
)braket
dot
id|addr
)paren
(brace
op_star
(paren
r_int
op_star
)paren
id|step_bp
(braket
l_int|1
)braket
dot
id|addr
op_assign
id|step_bp
(braket
l_int|1
)braket
dot
id|val
suffix:semicolon
id|step_bp
(braket
l_int|1
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we were interrupted asynchronously by gdb, then a&n;&t; * breakpoint was set at the EPC of the interrupt so&n;&t; * that we&squot;d wind up here with an interesting stack frame.&n;&t; */
r_if
c_cond
(paren
id|async_bp.addr
)paren
(brace
op_star
(paren
r_int
op_star
)paren
id|async_bp.addr
op_assign
id|async_bp.val
suffix:semicolon
id|async_bp.addr
op_assign
l_int|0
suffix:semicolon
)brace
id|stack
op_assign
(paren
r_int
op_star
)paren
id|regs-&gt;reg29
suffix:semicolon
multiline_comment|/* stack ptr */
id|sigval
op_assign
id|computeSignal
c_func
(paren
id|trap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reply to host that an exception has occurred&n;&t; */
id|ptr
op_assign
id|output_buffer
suffix:semicolon
multiline_comment|/*&n;&t; * Send trap type (converted to signal)&n;&t; */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Send Error PC&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_EPC
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_EPC
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_epc
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send frame pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_FP
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_FP
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;reg30
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send stack pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_SP
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_SP
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;reg29
comma
id|ptr
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0
suffix:semicolon
id|putpacket
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
multiline_comment|/* send it off... */
multiline_comment|/*&n;&t; * Wait for input from remote GDB&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|getpacket
c_func
(paren
id|input_buffer
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|input_buffer
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;?&squot;
suffix:colon
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|output_buffer
(braket
l_int|1
)braket
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|2
)braket
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* toggle debug flag */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Return the value of the CPU registers&n;&t;&t; */
r_case
l_char|&squot;g&squot;
suffix:colon
id|ptr
op_assign
id|output_buffer
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;reg0
comma
id|ptr
comma
l_int|32
op_star
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* r0...r31 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_status
comma
id|ptr
comma
l_int|6
op_star
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* cp0 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;fpr0
comma
id|ptr
comma
l_int|32
op_star
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* f0...31 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp1_fsr
comma
id|ptr
comma
l_int|2
op_star
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* cp1 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;frame_ptr
comma
id|ptr
comma
l_int|2
op_star
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* frp */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_index
comma
id|ptr
comma
l_int|16
op_star
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* cp0 */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set the value of the CPU registers - return OK&n;&t;&t; * FIXME: Needs to be written&n;&t;&t; */
r_case
l_char|&squot;G&squot;
suffix:colon
(brace
macro_line|#if 0
r_int
r_int
op_star
id|newsp
comma
id|psr
suffix:semicolon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|registers
comma
l_int|16
op_star
l_int|4
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* G &amp; O regs */
multiline_comment|/*&n;&t;&t;&t; * See if the stack pointer has moved. If so, then copy the&n;&t;&t;&t; * saved locals and ins to the new location.&n;&t;&t;&t; */
id|newsp
op_assign
(paren
r_int
r_int
op_star
)paren
id|registers
(braket
id|SP
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_ne
id|newsp
)paren
id|sp
op_assign
id|memcpy
c_func
(paren
id|newsp
comma
id|sp
comma
l_int|16
op_star
l_int|4
)paren
suffix:semicolon
macro_line|#endif
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * mAA..AA,LLLL  Read LLLL bytes at address AA..AA&n;&t;&t; */
r_case
l_char|&squot;m&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
r_if
c_cond
(paren
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
id|addr
comma
id|output_buffer
comma
id|length
comma
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|strcpy
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK&n;&t;&t; */
r_case
l_char|&squot;M&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_if
c_cond
(paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|length
comma
l_int|1
)paren
)paren
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E02&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cAA..AA    Continue at address AA..AA(optional)&n;&t;&t; */
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* try to read optional parameter, pc unchanged if no parm */
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
)paren
id|regs-&gt;cp0_epc
op_assign
id|addr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to flush the instruction cache here, as we may&n;&t;&t;&t; * have deposited a breakpoint, and the icache probably&n;&t;&t;&t; * has no way of knowing that a data ref to some location&n;&t;&t;&t; * may have changed something that is in the instruction&n;&t;&t;&t; * cache.&n;&t;&t;&t; * NB: We flush both caches, just to be sure...&n;&t;&t;&t; */
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* NOTREACHED */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * kill the program&n;&t;&t; */
r_case
l_char|&squot;k&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* do nothing */
multiline_comment|/*&n;&t;&t; * Reset the whole machine (FIXME: system dependent)&n;&t;&t; */
r_case
l_char|&squot;r&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Step to next instruction&n;&t;&t; */
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * There is no single step insn in the MIPS ISA, so we&n;&t;&t;&t; * use breakpoints and continue, instead.&n;&t;&t;&t; */
id|single_step
c_func
(paren
id|regs
)paren
suffix:semicolon
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* NOTREACHED */
multiline_comment|/*&n;&t;&t; * Set baud rate (bBB)&n;&t;&t; * FIXME: Needs to be written&n;&t;&t; */
r_case
l_char|&squot;b&squot;
suffix:colon
(brace
macro_line|#if 0&t;&t;&t;&t;
r_int
id|baudrate
suffix:semicolon
r_extern
r_void
id|set_timer_3
c_func
(paren
)paren
suffix:semicolon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|baudrate
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;B01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Convert baud rate to uart clock divider */
r_switch
c_cond
(paren
id|baudrate
)paren
(brace
r_case
l_int|38400
suffix:colon
id|baudrate
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
id|baudrate
op_assign
l_int|33
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9600
suffix:colon
id|baudrate
op_assign
l_int|65
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|baudrate
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;B02&quot;
)paren
suffix:semicolon
r_goto
id|x1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|baudrate
)paren
(brace
id|putpacket
c_func
(paren
l_string|&quot;OK&quot;
)paren
suffix:semicolon
multiline_comment|/* Ack before changing speed */
id|set_timer_3
c_func
(paren
id|baudrate
)paren
suffix:semicolon
multiline_comment|/* Set it */
)brace
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
multiline_comment|/*&n;&t;&t; * reply to the request&n;&t;&t; */
id|putpacket
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* while */
)brace
multiline_comment|/*&n; * This function will generate a breakpoint exception.  It is used at the&n; * beginning of a program to sync up with a debugger and can be used&n; * otherwise as a quick means to stop program execution and &quot;break&quot; into&n; * the debugger.&n; */
DECL|function|breakpoint
r_void
id|breakpoint
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
dot
id|globl
id|breakinst
dot
id|set
id|noreorder
id|nop
id|breakinst
suffix:colon
r_break
id|nop
dot
id|set
id|reorder
"&quot;"
)paren
suffix:semicolon
)brace
DECL|function|adel
r_void
id|adel
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
dot
id|globl
id|adel
id|la
"$"
l_int|8
comma
l_int|0x80000001
id|lw
"$"
l_int|9
comma
l_int|0
(paren
"$"
l_int|8
)paren
"&quot;"
)paren
suffix:semicolon
)brace
eof
