multiline_comment|/*&n; * r4xx0.c: R4000 processor variant specific MMU/Cache routines.&n; *&n; * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)&n; *&n; * $Id: r4xx0.c,v 1.5 1997/08/08 18:13:07 miguel Exp $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/autoconf.h&gt;
macro_line|#include &lt;asm/sgi.h&gt;
macro_line|#include &lt;asm/sgimc.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/sgialib.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
multiline_comment|/* CP0 hazard avoidance. */
DECL|macro|BARRIER
mdefine_line|#define BARRIER __asm__ __volatile__(&quot;.set noreorder&bslash;n&bslash;t&quot; &bslash;&n;&t;&t;&t;&t;     &quot;nop; nop; nop; nop; nop; nop;&bslash;n&bslash;t&quot; &bslash;&n;&t;&t;&t;&t;     &quot;.set reorder&bslash;n&bslash;t&quot;)
multiline_comment|/* Primary cache parameters. */
DECL|variable|icache_size
DECL|variable|dcache_size
r_static
r_int
id|icache_size
comma
id|dcache_size
suffix:semicolon
multiline_comment|/* Size in bytes */
DECL|variable|ic_lsize
DECL|variable|dc_lsize
r_static
r_int
id|ic_lsize
comma
id|dc_lsize
suffix:semicolon
multiline_comment|/* LineSize in bytes */
multiline_comment|/* Secondary cache (if present) parameters. */
DECL|variable|scache_size
DECL|variable|sc_lsize
r_static
id|scache_size
comma
id|sc_lsize
suffix:semicolon
multiline_comment|/* Again, in bytes */
macro_line|#include &lt;asm/cacheops.h&gt;
macro_line|#include &lt;asm/r4kcache.h&gt;
DECL|macro|DEBUG_CACHE
macro_line|#undef DEBUG_CACHE
multiline_comment|/*&n; * Zero an entire page.&n; */
DECL|function|r4k_clear_page_d16
r_static
r_void
id|r4k_clear_page_d16
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t$1,%0,%2&bslash;n&quot;
l_string|&quot;1:&bslash;tcache&bslash;t%3,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%3,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%0,64&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%3,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%3,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$1,%0,1b&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips0&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|page
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|page
)paren
comma
l_string|&quot;I&quot;
(paren
id|PAGE_SIZE
)paren
comma
l_string|&quot;i&quot;
(paren
id|Create_Dirty_Excl_D
)paren
suffix:colon
l_string|&quot;$1&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|r4k_clear_page_d32
r_static
r_void
id|r4k_clear_page_d32
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t$1,%0,%2&bslash;n&quot;
l_string|&quot;1:&bslash;tcache&bslash;t%3,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%0,64&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%3,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$1,%0,1b&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips0&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|page
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|page
)paren
comma
l_string|&quot;I&quot;
(paren
id|PAGE_SIZE
)paren
comma
l_string|&quot;i&quot;
(paren
id|Create_Dirty_Excl_D
)paren
suffix:colon
l_string|&quot;$1&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This flavour of r4k_clear_page is for the R4600 V1.x.  Cite from the&n; * IDT R4600 V1.7 errata:&n; *&n; *  18. The CACHE instructions Hit_Writeback_Invalidate_D, Hit_Writeback_D,&n; *      Hit_Invalidate_D and Create_Dirty_Exclusive_D should only be&n; *      executed if there is no other dcache activity. If the dcache is&n; *      accessed for another instruction immeidately preceding when these&n; *      cache instructions are executing, it is possible that the dcache &n; *      tag match outputs used by these cache instructions will be &n; *      incorrect. These cache instructions should be preceded by at least&n; *      four instructions that are not any kind of load or store &n; *      instruction.&n; *&n; *      This is not allowed:    lw&n; *                              nop&n; *                              nop&n; *                              nop&n; *                              cache       Hit_Writeback_Invalidate_D&n; *&n; *      This is allowed:        lw&n; *                              nop&n; *                              nop&n; *                              nop&n; *                              nop&n; *                              cache       Hit_Writeback_Invalidate_D&n; */
DECL|function|r4k_clear_page_r4600_v1
r_static
r_void
id|r4k_clear_page_r4600_v1
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t$1,%0,%2&bslash;n&quot;
l_string|&quot;1:&bslash;tnop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%3,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%0,64&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%3,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$1,%0,1b&bslash;n&bslash;t&quot;
l_string|&quot;sd&bslash;t$0,-8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips0&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|page
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|page
)paren
comma
l_string|&quot;I&quot;
(paren
id|PAGE_SIZE
)paren
comma
l_string|&quot;i&quot;
(paren
id|Create_Dirty_Excl_D
)paren
suffix:colon
l_string|&quot;$1&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is still inefficient.  We only can do better if we know the&n; * virtual address where the copy will be accessed.&n; */
DECL|function|r4k_copy_page_d16
r_static
r_void
id|r4k_copy_page_d16
c_func
(paren
r_int
r_int
id|to
comma
r_int
r_int
id|from
)paren
(brace
r_int
r_int
id|dummy1
comma
id|dummy2
suffix:semicolon
r_int
r_int
id|reg1
comma
id|reg2
comma
id|reg3
comma
id|reg4
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t$1,%0,%8&bslash;n&quot;
l_string|&quot;1:&bslash;tcache&bslash;t%9,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,4(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,8(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,12(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,4(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,12(%0)&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%9,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,16(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,20(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,24(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,28(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,20(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,28(%0)&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%9,32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%0,64&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%1,64&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,-32(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,-28(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,-24(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,-20(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,-28(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,-24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,-20(%0)&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%9,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,-16(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,-12(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,-8(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,-4(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,-12(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,-8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$1,%0,1b&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,-4(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips0&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dummy1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|dummy2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg4
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|to
)paren
comma
l_string|&quot;1&quot;
(paren
id|from
)paren
comma
l_string|&quot;I&quot;
(paren
id|PAGE_SIZE
)paren
comma
l_string|&quot;i&quot;
(paren
id|Create_Dirty_Excl_D
)paren
)paren
suffix:semicolon
)brace
DECL|function|r4k_copy_page_d32
r_static
r_void
id|r4k_copy_page_d32
c_func
(paren
r_int
r_int
id|to
comma
r_int
r_int
id|from
)paren
(brace
r_int
r_int
id|dummy1
comma
id|dummy2
suffix:semicolon
r_int
r_int
id|reg1
comma
id|reg2
comma
id|reg3
comma
id|reg4
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t$1,%0,%8&bslash;n&quot;
l_string|&quot;1:&bslash;tcache&bslash;t%9,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,4(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,8(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,12(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,4(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,12(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,16(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,20(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,24(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,28(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,20(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,28(%0)&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%9,32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%0,64&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%1,64&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,-32(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,-28(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,-24(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,-20(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,-28(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,-24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,-20(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,-16(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,-12(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,-8(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,-4(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,-12(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,-8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$1,%0,1b&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,-4(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips0&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dummy1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|dummy2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg4
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|to
)paren
comma
l_string|&quot;1&quot;
(paren
id|from
)paren
comma
l_string|&quot;I&quot;
(paren
id|PAGE_SIZE
)paren
comma
l_string|&quot;i&quot;
(paren
id|Create_Dirty_Excl_D
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Again a special version for the R4600 V1.x&n; */
DECL|function|r4k_copy_page_r4600_v1
r_static
r_void
id|r4k_copy_page_r4600_v1
c_func
(paren
r_int
r_int
id|to
comma
r_int
r_int
id|from
)paren
(brace
r_int
r_int
id|dummy1
comma
id|dummy2
suffix:semicolon
r_int
r_int
id|reg1
comma
id|reg2
comma
id|reg3
comma
id|reg4
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t$1,%0,%8&bslash;n&quot;
l_string|&quot;1:&bslash;tnop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;&bslash;tcache&bslash;t%9,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,4(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,8(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,12(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,4(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,12(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,16(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,20(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,24(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,28(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,20(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,28(%0)&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;cache&bslash;t%9,32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%0,64&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%1,64&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,-32(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,-28(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,-24(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,-20(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,-32(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,-28(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,-24(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,-20(%0)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%2,-16(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%3,-12(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%4,-8(%1)&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t%5,-4(%1)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%2,-16(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%3,-12(%0)&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%4,-8(%0)&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$1,%0,1b&bslash;n&bslash;t&quot;
l_string|&quot;sw&bslash;t%5,-4(%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips0&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dummy1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|dummy2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|reg4
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|to
)paren
comma
l_string|&quot;1&quot;
(paren
id|from
)paren
comma
l_string|&quot;I&quot;
(paren
id|PAGE_SIZE
)paren
comma
l_string|&quot;i&quot;
(paren
id|Create_Dirty_Excl_D
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If you think for one second that this stuff coming up is a lot&n; * of bulky code eating too many kernel cache lines.  Think _again_.&n; *&n; * Consider:&n; * 1) Taken branches have a 3 cycle penalty on R4k&n; * 2) The branch itself is a real dead cycle on even R4600/R5000.&n; * 3) Only one of the following variants of each type is even used by&n; *    the kernel based upon the cache parameters we detect at boot time.&n; *&n; * QED.&n; */
DECL|function|r4k_flush_cache_all_s16d16i16
r_static
r_inline
r_void
id|r4k_flush_cache_all_s16d16i16
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16
c_func
(paren
)paren
suffix:semicolon
id|blast_icache16
c_func
(paren
)paren
suffix:semicolon
id|blast_scache16
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_s32d16i16
r_static
r_inline
r_void
id|r4k_flush_cache_all_s32d16i16
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16
c_func
(paren
)paren
suffix:semicolon
id|blast_icache16
c_func
(paren
)paren
suffix:semicolon
id|blast_scache32
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_s64d16i16
r_static
r_inline
r_void
id|r4k_flush_cache_all_s64d16i16
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16
c_func
(paren
)paren
suffix:semicolon
id|blast_icache16
c_func
(paren
)paren
suffix:semicolon
id|blast_scache64
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_s128d16i16
r_static
r_inline
r_void
id|r4k_flush_cache_all_s128d16i16
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16
c_func
(paren
)paren
suffix:semicolon
id|blast_icache16
c_func
(paren
)paren
suffix:semicolon
id|blast_scache128
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_s16d32i32
r_static
r_inline
r_void
id|r4k_flush_cache_all_s16d32i32
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32
c_func
(paren
)paren
suffix:semicolon
id|blast_icache32
c_func
(paren
)paren
suffix:semicolon
id|blast_scache16
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_s32d32i32
r_static
r_inline
r_void
id|r4k_flush_cache_all_s32d32i32
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32
c_func
(paren
)paren
suffix:semicolon
id|blast_icache32
c_func
(paren
)paren
suffix:semicolon
id|blast_scache32
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_s64d32i32
r_static
r_inline
r_void
id|r4k_flush_cache_all_s64d32i32
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32
c_func
(paren
)paren
suffix:semicolon
id|blast_icache32
c_func
(paren
)paren
suffix:semicolon
id|blast_scache64
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_s128d32i32
r_static
r_inline
r_void
id|r4k_flush_cache_all_s128d32i32
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32
c_func
(paren
)paren
suffix:semicolon
id|blast_icache32
c_func
(paren
)paren
suffix:semicolon
id|blast_scache128
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_d16i16
r_static
r_inline
r_void
id|r4k_flush_cache_all_d16i16
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16
c_func
(paren
)paren
suffix:semicolon
id|blast_icache16
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_all_d32i32
r_static
r_inline
r_void
id|r4k_flush_cache_all_d32i32
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32
c_func
(paren
)paren
suffix:semicolon
id|blast_icache32
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|r4k_flush_cache_range_s16d16i16
id|r4k_flush_cache_range_s16d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s16d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|r4k_flush_cache_range_s32d16i16
id|r4k_flush_cache_range_s32d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s32d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|r4k_flush_cache_range_s64d16i16
r_static
r_void
id|r4k_flush_cache_range_s64d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s64d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache64_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|r4k_flush_cache_range_s128d16i16
r_static
r_void
id|r4k_flush_cache_range_s128d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s128d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache128_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|r4k_flush_cache_range_s16d32i32
r_static
r_void
id|r4k_flush_cache_range_s16d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s16d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache16_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|r4k_flush_cache_range_s32d32i32
r_static
r_void
id|r4k_flush_cache_range_s32d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s32d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|r4k_flush_cache_range_s64d32i32
r_static
r_void
id|r4k_flush_cache_range_s64d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s64d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache64_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|r4k_flush_cache_range_s128d32i32
r_static
r_void
id|r4k_flush_cache_range_s128d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
id|r4k_flush_cache_all_s128d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|text
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|text
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|start
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_VALID
)paren
(brace
id|blast_dcache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|blast_scache128_page
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|r4k_flush_cache_range_d16i16
r_static
r_void
id|r4k_flush_cache_range_d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16
c_func
(paren
)paren
suffix:semicolon
id|blast_icache16
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_range_d32i32
r_static
r_void
id|r4k_flush_cache_range_d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;crange[%d,%08lx,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32
c_func
(paren
)paren
suffix:semicolon
id|blast_icache32
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * On architectures like the Sparc, we could get rid of lines in&n; * the cache created only by a certain context, but on the MIPS&n; * (and actually certain Sparc&squot;s) we cannot.&n; */
DECL|function|r4k_flush_cache_mm_s16d16i16
r_static
r_void
id|r4k_flush_cache_mm_s16d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s16d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_s32d16i16
r_static
r_void
id|r4k_flush_cache_mm_s32d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s32d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_s64d16i16
r_static
r_void
id|r4k_flush_cache_mm_s64d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s64d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_s128d16i16
r_static
r_void
id|r4k_flush_cache_mm_s128d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s128d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_s16d32i32
r_static
r_void
id|r4k_flush_cache_mm_s16d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s16d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_s32d32i32
r_static
r_void
id|r4k_flush_cache_mm_s32d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s32d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_s64d32i32
r_static
r_void
id|r4k_flush_cache_mm_s64d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s64d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_s128d32i32
r_static
r_void
id|r4k_flush_cache_mm_s128d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_s128d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_d16i16
r_static
r_void
id|r4k_flush_cache_mm_d16i16
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_d16i16
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_mm_d32i32
r_static
r_void
id|r4k_flush_cache_mm_d32i32
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cmm[%d]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|r4k_flush_cache_all_d32i32
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_page_s16d16i16
r_static
r_void
id|r4k_flush_cache_page_s16d16i16
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/* Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/* Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_s32d16i16
r_static
r_void
id|r4k_flush_cache_page_s32d16i16
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/* Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/* Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_s64d16i16
r_static
r_void
id|r4k_flush_cache_page_s64d16i16
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/* Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache64_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache64_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_s128d16i16
r_static
r_void
id|r4k_flush_cache_page_s128d16i16
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/* Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache128_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache128_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_s16d32i32
r_static
r_void
id|r4k_flush_cache_page_s16d32i32
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/* Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_s32d32i32
r_static
r_void
id|r4k_flush_cache_page_s32d32i32
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_s64d32i32
r_static
r_void
id|r4k_flush_cache_page_s64d32i32
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache64_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache64_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_s128d32i32
r_static
r_void
id|r4k_flush_cache_page_s128d32i32
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
id|current-&gt;mm-&gt;context
)paren
(brace
multiline_comment|/* Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|scache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache128_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|blast_scache128_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_d16i16
r_static
r_void
id|r4k_flush_cache_page_d16i16
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/* If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
(brace
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|dcache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_dcache16_page_indexed
c_func
(paren
id|page
op_xor
l_int|0x2000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache16_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_icache16_page_indexed
c_func
(paren
id|page
op_xor
l_int|0x2000
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_d32i32
r_static
r_void
id|r4k_flush_cache_page_d32i32
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_PRESENT
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
op_logical_and
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|dcache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_cache_page_d32i32_r4600
r_static
r_void
id|r4k_flush_cache_page_d32i32_r4600
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|text
suffix:semicolon
multiline_comment|/*&n;&t; * If ownes no valid ASID yet, cannot possibly have gotten&n;&t; * this page into the cache.&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cpage[%d,%08lx]&quot;
comma
(paren
r_int
)paren
id|mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|page
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|page
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the page isn&squot;t marked valid, the page cannot possibly be&n;&t; * in the cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_PRESENT
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|text
op_assign
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Doing flushes for another ASID than the current one is&n;&t; * too difficult since stupid R4k caches do a TLB translation&n;&t; * for every cache flush operation.  So we do indexed flushes&n;&t; * in that case, which doesn&squot;t overly flush the cache too much.&n;&t; */
r_if
c_cond
(paren
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
op_logical_and
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_amp
id|_PAGE_VALID
)paren
)paren
(brace
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Do indexed flush, too much work to get the (possible)&n;&t;&t; * tlb refills to work correctly.&n;&t;&t; */
id|page
op_assign
(paren
id|KSEG0
op_plus
(paren
id|page
op_amp
(paren
id|dcache_size
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|blast_dcache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_dcache32_page_indexed
c_func
(paren
id|page
op_xor
l_int|0x2000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|text
)paren
(brace
id|blast_icache32_page_indexed
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_icache32_page_indexed
c_func
(paren
id|page
op_xor
l_int|0x2000
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* If the addresses passed to these routines are valid, they are&n; * either:&n; *&n; * 1) In KSEG0, so we can do a direct flush of the page.&n; * 2) In KSEG2, and since every process can translate those&n; *    addresses all the time in kernel mode we can do a direct&n; *    flush.&n; * 3) In KSEG1, no flush necessary.&n; */
DECL|function|r4k_flush_page_to_ram_s16d16i16
r_static
r_void
id|r4k_flush_page_to_ram_s16d16i16
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_s32d16i16
r_static
r_void
id|r4k_flush_page_to_ram_s32d16i16
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_s64d16i16
r_static
r_void
id|r4k_flush_page_to_ram_s64d16i16
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache64_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_s128d16i16
r_static
r_void
id|r4k_flush_page_to_ram_s128d16i16
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache128_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_s16d32i32
r_static
r_void
id|r4k_flush_page_to_ram_s16d32i32
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_s32d32i32
r_static
r_void
id|r4k_flush_page_to_ram_s32d32i32
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_s64d32i32
r_static
r_void
id|r4k_flush_page_to_ram_s64d32i32
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache64_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_s128d32i32
r_static
r_void
id|r4k_flush_page_to_ram_s128d32i32
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_scache128_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_d16i16
r_static
r_void
id|r4k_flush_page_to_ram_d16i16
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache16_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_page_to_ram_d32i32
r_static
r_void
id|r4k_flush_page_to_ram_d32i32
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
id|printk
c_func
(paren
l_string|&quot;cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * R4600 v2.0 bug: &quot;The CACHE instructions Hit_Writeback_Invalidate_D,&n; * Hit_Writeback_D, Hit_Invalidate_D and Create_Dirty_Exclusive_D will only&n; * operate correctly if the internal data cache refill buffer is empty.  These&n; * CACHE instructions should be separated from any potential data cache miss&n; * by a load instruction to an uncached address to empty the response buffer.&quot;&n; * (Revision 2.0 device errata from IDT available on http://www.idt.com/&n; * in .pdf format.)&n; */
DECL|function|r4k_flush_page_to_ram_d32i32_r4600
r_static
r_void
id|r4k_flush_page_to_ram_d32i32_r4600
c_func
(paren
r_int
r_int
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_ge
id|KSEG0
op_logical_and
id|page
OL
id|KSEG1
)paren
op_logical_or
(paren
id|page
op_ge
id|KSEG2
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_CACHE
multiline_comment|/* #if 1 */
id|printk
c_func
(paren
l_string|&quot;r4600_cram[%08lx]&quot;
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Workaround for R4600 bug.  Explanation see above.&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
id|KSEG1
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|blast_dcache32_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|blast_dcache32_page
c_func
(paren
id|page
op_xor
l_int|0x2000
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SGI
(brace
r_int
r_int
id|tmp1
comma
id|tmp2
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * SGI goo.  Have to check this closer ...&n;&t;&t;&t; */
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
dot
id|set
id|noreorder
dot
id|set
id|mips3
id|li
op_mod
l_int|0
comma
l_int|0x1
id|dsll
op_mod
l_int|0
comma
l_int|31
op_logical_or
op_mod
l_int|0
comma
op_mod
l_int|0
comma
op_mod
l_int|2
id|lui
op_mod
l_int|1
comma
l_int|0x9000
id|dsll32
op_mod
l_int|1
comma
l_int|0
op_logical_or
op_mod
l_int|0
comma
op_mod
l_int|0
comma
op_mod
l_int|1
id|daddu
op_mod
l_int|1
comma
op_mod
l_int|0
comma
l_int|0x0fe0
id|li
op_mod
l_int|2
comma
l_int|0x80
id|mtc0
op_mod
l_int|2
comma
"$"
l_int|12
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
l_int|1
suffix:colon
id|sw
"$"
l_int|0
comma
l_int|0
(paren
op_mod
l_int|0
)paren
id|bltu
op_mod
l_int|0
comma
op_mod
l_int|1
comma
l_int|1
id|b
id|daddu
op_mod
l_int|0
comma
l_int|32
id|mtc0
"$"
l_int|0
comma
"$"
l_int|12
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
dot
id|set
id|mips0
dot
id|set
id|reorder
"&quot;"
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|page
)paren
suffix:colon
l_string|&quot;2&quot;
(paren
id|page
op_amp
l_int|0x0007f000
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SGI */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_cache_sigtramp
r_static
r_void
id|r4k_flush_cache_sigtramp
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|addr
op_and_assign
op_complement
(paren
id|dc_lsize
op_minus
l_int|1
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;nop;nop;nop;nop&quot;
)paren
suffix:semicolon
id|flush_dcache_line
c_func
(paren
id|addr
)paren
suffix:semicolon
id|flush_dcache_line
c_func
(paren
id|addr
op_plus
id|dc_lsize
)paren
suffix:semicolon
id|flush_icache_line
c_func
(paren
id|addr
)paren
suffix:semicolon
id|flush_icache_line
c_func
(paren
id|addr
op_plus
id|dc_lsize
)paren
suffix:semicolon
)brace
DECL|macro|DEBUG_TLB
macro_line|#undef DEBUG_TLB
DECL|macro|DEBUG_TLBUPDATE
macro_line|#undef DEBUG_TLBUPDATE
DECL|macro|NTLB_ENTRIES
mdefine_line|#define NTLB_ENTRIES       48  /* Fixed on all R4XX0 variants... */
DECL|macro|NTLB_ENTRIES_HALF
mdefine_line|#define NTLB_ENTRIES_HALF  24  /* Fixed on all R4XX0 variants... */
DECL|function|r4k_flush_tlb_all
r_static
r_inline
r_void
id|r4k_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|old_ctx
suffix:semicolon
r_int
id|entry
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
id|printk
c_func
(paren
l_string|&quot;[tlball]&quot;
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Save old context and create impossible VPN2 value */
id|old_ctx
op_assign
(paren
id|get_entryhi
c_func
(paren
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|KSEG0
)paren
suffix:semicolon
id|set_entrylo0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_entrylo1
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|entry
op_assign
id|get_wired
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Blast &squot;em all away. */
r_while
c_loop
(paren
id|entry
OL
id|NTLB_ENTRIES
)paren
(brace
id|set_index
c_func
(paren
id|entry
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|tlb_write_indexed
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|entry
op_increment
suffix:semicolon
)brace
id|BARRIER
suffix:semicolon
id|set_entryhi
c_func
(paren
id|old_ctx
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|r4k_flush_tlb_mm
r_static
r_void
id|r4k_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
id|printk
c_func
(paren
l_string|&quot;[tlbmm&lt;%d&gt;]&quot;
comma
id|mm-&gt;context
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|get_new_mmu_context
c_func
(paren
id|mm
comma
id|asid_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
(brace
id|set_entryhi
c_func
(paren
id|mm-&gt;context
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_tlb_range
r_static
r_void
id|r4k_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;context
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|size
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
id|printk
c_func
(paren
l_string|&quot;[tlbrange&lt;%02x,%08lx,%08lx&gt;]&quot;
comma
(paren
id|mm-&gt;context
op_amp
l_int|0xff
)paren
comma
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|size
op_assign
(paren
id|end
op_minus
id|start
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|size
op_assign
(paren
id|size
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
id|NTLB_ENTRIES_HALF
)paren
(brace
r_int
id|oldpid
op_assign
(paren
id|get_entryhi
c_func
(paren
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_int
id|newpid
op_assign
(paren
id|mm-&gt;context
op_amp
l_int|0xff
)paren
suffix:semicolon
id|start
op_and_assign
(paren
id|PAGE_MASK
op_lshift
l_int|1
)paren
suffix:semicolon
id|end
op_add_assign
(paren
(paren
id|PAGE_SIZE
op_lshift
l_int|1
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|end
op_and_assign
(paren
id|PAGE_MASK
op_lshift
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|start
OL
id|end
)paren
(brace
r_int
id|idx
suffix:semicolon
id|set_entryhi
c_func
(paren
id|start
op_or
id|newpid
)paren
suffix:semicolon
id|start
op_add_assign
(paren
id|PAGE_SIZE
op_lshift
l_int|1
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|tlb_probe
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|idx
op_assign
id|get_index
c_func
(paren
)paren
suffix:semicolon
id|set_entrylo0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_entrylo1
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|KSEG0
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|tlb_write_indexed
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
)brace
id|set_entryhi
c_func
(paren
id|oldpid
)paren
suffix:semicolon
)brace
r_else
(brace
id|get_new_mmu_context
c_func
(paren
id|mm
comma
id|asid_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
(brace
id|set_entryhi
c_func
(paren
id|mm-&gt;context
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|r4k_flush_tlb_page
r_static
r_void
id|r4k_flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_mm-&gt;context
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|oldpid
comma
id|newpid
comma
id|idx
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
id|printk
c_func
(paren
l_string|&quot;[tlbpage&lt;%d,%08lx&gt;]&quot;
comma
id|vma-&gt;vm_mm-&gt;context
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|newpid
op_assign
(paren
id|vma-&gt;vm_mm-&gt;context
op_amp
l_int|0xff
)paren
suffix:semicolon
id|page
op_and_assign
(paren
id|PAGE_MASK
op_lshift
l_int|1
)paren
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|oldpid
op_assign
(paren
id|get_entryhi
c_func
(paren
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|page
op_or
id|newpid
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|tlb_probe
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|idx
op_assign
id|get_index
c_func
(paren
)paren
suffix:semicolon
id|set_entrylo0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_entrylo1
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|KSEG0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
)paren
(brace
r_goto
id|finish
suffix:semicolon
)brace
id|BARRIER
suffix:semicolon
id|tlb_write_indexed
c_func
(paren
)paren
suffix:semicolon
id|finish
suffix:colon
id|BARRIER
suffix:semicolon
id|set_entryhi
c_func
(paren
id|oldpid
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Load a new root pointer into the TLB. */
DECL|function|r4k_load_pgd
r_static
r_void
id|r4k_load_pgd
c_func
(paren
r_int
r_int
id|pg_dir
)paren
(brace
)brace
DECL|function|r4k_pgd_init
r_static
r_void
id|r4k_pgd_init
c_func
(paren
r_int
r_int
id|page
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|page
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1024
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
id|p
(braket
id|i
op_plus
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|1
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|3
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|4
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|5
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|6
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|7
)braket
op_assign
(paren
r_int
r_int
)paren
id|invalid_pte_table
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_TLBUPDATE
DECL|variable|ehi_debug
r_static
r_int
r_int
id|ehi_debug
(braket
id|NTLB_ENTRIES
)braket
suffix:semicolon
DECL|variable|el0_debug
r_static
r_int
r_int
id|el0_debug
(braket
id|NTLB_ENTRIES
)braket
suffix:semicolon
DECL|variable|el1_debug
r_static
r_int
r_int
id|el1_debug
(braket
id|NTLB_ENTRIES
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* We will need multiple versions of update_mmu_cache(), one that just&n; * updates the TLB with the new pte(s), and another which also checks&n; * for the R4k &quot;end of page&quot; hardware bug and does the needy.&n; */
DECL|function|r4k_update_mmu_cache
r_static
r_void
id|r4k_update_mmu_cache
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
id|pte
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|idx
comma
id|pid
suffix:semicolon
id|pid
op_assign
(paren
id|get_entryhi
c_func
(paren
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
r_if
c_cond
(paren
(paren
id|pid
op_ne
(paren
id|vma-&gt;vm_mm-&gt;context
op_amp
l_int|0xff
)paren
)paren
op_logical_or
(paren
id|vma-&gt;vm_mm-&gt;context
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;update_mmu_cache: Wheee, bogus tlbpid mmpid=%d tlbpid=%d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|vma-&gt;vm_mm-&gt;context
op_amp
l_int|0xff
)paren
comma
id|pid
)paren
suffix:semicolon
)brace
macro_line|#endif
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|address
op_and_assign
(paren
id|PAGE_MASK
op_lshift
l_int|1
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|address
op_or
(paren
id|pid
)paren
)paren
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|vma-&gt;vm_mm
comma
id|address
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|tlb_probe
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|address
)paren
suffix:semicolon
id|idx
op_assign
id|get_index
c_func
(paren
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|address
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|set_entrylo0
c_func
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
op_increment
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|set_entrylo1
c_func
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|address
op_or
(paren
id|pid
)paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
)paren
(brace
id|tlb_write_random
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|BARRIER
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[MISS]&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|tlb_write_indexed
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|BARRIER
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[HIT]&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;args&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|NTLB_ENTRIES
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|BARRIER
suffix:semicolon
id|set_index
c_func
(paren
id|idx
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|tlb_read
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|address
op_assign
id|get_entryhi
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
r_if
c_cond
(paren
(paren
id|address
op_amp
l_int|0xff
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[%08lx]&quot;
comma
id|address
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
)brace
id|BARRIER
suffix:semicolon
macro_line|#endif
id|BARRIER
suffix:semicolon
id|set_entryhi
c_func
(paren
id|pid
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|r4k_update_mmu_cache_hwbug
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
id|pte
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pgd_t
op_star
id|pgdp
suffix:semicolon
id|pmd_t
op_star
id|pmdp
suffix:semicolon
id|pte_t
op_star
id|ptep
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|address
op_and_assign
(paren
id|PAGE_MASK
op_lshift
l_int|1
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|address
op_or
(paren
id|get_entryhi
c_func
(paren
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|pgdp
op_assign
id|pgd_offset
c_func
(paren
id|vma-&gt;vm_mm
comma
id|address
)paren
suffix:semicolon
id|tlb_probe
c_func
(paren
)paren
suffix:semicolon
id|pmdp
op_assign
id|pmd_offset
c_func
(paren
id|pgdp
comma
id|address
)paren
suffix:semicolon
id|idx
op_assign
id|get_index
c_func
(paren
)paren
suffix:semicolon
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmdp
comma
id|address
)paren
suffix:semicolon
id|set_entrylo0
c_func
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
op_increment
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|set_entrylo1
c_func
(paren
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
)paren
(brace
id|tlb_write_random
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|tlb_write_indexed
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|r4k_show_regs
r_static
r_void
id|r4k_show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Saved main processor registers. */
id|printk
c_func
(paren
l_string|&quot;$0 : %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
l_int|0UL
comma
id|regs-&gt;regs
(braket
l_int|1
)braket
comma
id|regs-&gt;regs
(braket
l_int|2
)braket
comma
id|regs-&gt;regs
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$4 : %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|4
)braket
comma
id|regs-&gt;regs
(braket
l_int|5
)braket
comma
id|regs-&gt;regs
(braket
l_int|6
)braket
comma
id|regs-&gt;regs
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$8 : %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|8
)braket
comma
id|regs-&gt;regs
(braket
l_int|9
)braket
comma
id|regs-&gt;regs
(braket
l_int|10
)braket
comma
id|regs-&gt;regs
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$12: %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|12
)braket
comma
id|regs-&gt;regs
(braket
l_int|13
)braket
comma
id|regs-&gt;regs
(braket
l_int|14
)braket
comma
id|regs-&gt;regs
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$16: %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|16
)braket
comma
id|regs-&gt;regs
(braket
l_int|17
)braket
comma
id|regs-&gt;regs
(braket
l_int|18
)braket
comma
id|regs-&gt;regs
(braket
l_int|19
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$20: %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|20
)braket
comma
id|regs-&gt;regs
(braket
l_int|21
)braket
comma
id|regs-&gt;regs
(braket
l_int|22
)braket
comma
id|regs-&gt;regs
(braket
l_int|23
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$24: %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|24
)braket
comma
id|regs-&gt;regs
(braket
l_int|25
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$28: %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|28
)braket
comma
id|regs-&gt;regs
(braket
l_int|29
)braket
comma
id|regs-&gt;regs
(braket
l_int|30
)braket
comma
id|regs-&gt;regs
(braket
l_int|31
)braket
)paren
suffix:semicolon
multiline_comment|/* Saved cp0 registers. */
id|printk
c_func
(paren
l_string|&quot;epc   : %08lx&bslash;nStatus: %08lx&bslash;nCause : %08lx&bslash;n&quot;
comma
id|regs-&gt;cp0_epc
comma
id|regs-&gt;cp0_status
comma
id|regs-&gt;cp0_cause
)paren
suffix:semicolon
)brace
DECL|function|r4k_add_wired_entry
r_static
r_void
id|r4k_add_wired_entry
c_func
(paren
r_int
r_int
id|entrylo0
comma
r_int
r_int
id|entrylo1
comma
r_int
r_int
id|entryhi
comma
r_int
r_int
id|pagemask
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|wired
suffix:semicolon
r_int
r_int
id|old_pagemask
suffix:semicolon
r_int
r_int
id|old_ctx
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Save old context and create impossible VPN2 value */
id|old_ctx
op_assign
(paren
id|get_entryhi
c_func
(paren
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|old_pagemask
op_assign
id|get_pagemask
c_func
(paren
)paren
suffix:semicolon
id|wired
op_assign
id|get_wired
c_func
(paren
)paren
suffix:semicolon
id|set_wired
(paren
id|wired
op_plus
l_int|1
)paren
suffix:semicolon
id|set_index
(paren
id|wired
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|set_pagemask
(paren
id|pagemask
)paren
suffix:semicolon
id|set_entryhi
c_func
(paren
id|entryhi
)paren
suffix:semicolon
id|set_entrylo0
c_func
(paren
id|entrylo0
)paren
suffix:semicolon
id|set_entrylo1
c_func
(paren
id|entrylo1
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|tlb_write_indexed
c_func
(paren
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|set_entryhi
c_func
(paren
id|old_ctx
)paren
suffix:semicolon
id|BARRIER
suffix:semicolon
id|set_pagemask
(paren
id|old_pagemask
)paren
suffix:semicolon
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Detect and size the various r4k caches. */
DECL|function|probe_icache
r_static
r_void
id|probe_icache
c_func
(paren
r_int
r_int
id|config
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|config
op_rshift
l_int|9
)paren
op_amp
l_int|7
suffix:semicolon
id|icache_size
op_assign
(paren
l_int|1
op_lshift
(paren
l_int|12
op_plus
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|config
op_rshift
l_int|5
)paren
op_amp
l_int|1
)paren
(brace
id|ic_lsize
op_assign
l_int|32
suffix:semicolon
)brace
r_else
id|ic_lsize
op_assign
l_int|16
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Primary ICACHE %dK (linesize %d bytes)&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|icache_size
op_rshift
l_int|10
)paren
comma
(paren
r_int
)paren
id|ic_lsize
)paren
suffix:semicolon
)brace
DECL|function|probe_dcache
r_static
r_void
id|probe_dcache
c_func
(paren
r_int
r_int
id|config
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|config
op_rshift
l_int|6
)paren
op_amp
l_int|7
suffix:semicolon
id|dcache_size
op_assign
(paren
l_int|1
op_lshift
(paren
l_int|12
op_plus
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|config
op_rshift
l_int|4
)paren
op_amp
l_int|1
)paren
(brace
id|dc_lsize
op_assign
l_int|32
suffix:semicolon
)brace
r_else
id|dc_lsize
op_assign
l_int|16
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Primary DCACHE %dK (linesize %d bytes)&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|dcache_size
op_rshift
l_int|10
)paren
comma
(paren
r_int
)paren
id|dc_lsize
)paren
suffix:semicolon
)brace
DECL|function|probe_scache_eeprom
r_static
r_int
id|probe_scache_eeprom
c_func
(paren
r_int
r_int
id|config
)paren
(brace
macro_line|#ifdef CONFIG_SGI
r_volatile
r_int
r_int
op_star
id|cpu_control
suffix:semicolon
r_int
r_int
id|cmd
op_assign
l_int|0xc220
suffix:semicolon
r_int
r_int
id|data
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
macro_line|#ifdef __MIPSEB__
id|cpu_control
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|KSEG1ADDR
c_func
(paren
l_int|0x1fa00034
)paren
suffix:semicolon
macro_line|#else
id|cpu_control
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
id|KSEG1ADDR
c_func
(paren
l_int|0x1fa00030
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|DEASSERT
mdefine_line|#define DEASSERT(bit) (*(cpu_control) &amp;= (~(bit)))
DECL|macro|ASSERT
mdefine_line|#define ASSERT(bit) (*(cpu_control) |= (bit))
DECL|macro|DELAY
mdefine_line|#define DELAY  for(n = 0; n &lt; 100000; n++) __asm__ __volatile__(&quot;&quot;)
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_PRE
)paren
suffix:semicolon
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_SDATAO
)paren
suffix:semicolon
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_PRE
)paren
suffix:semicolon
id|DELAY
suffix:semicolon
id|ASSERT
c_func
(paren
id|SGIMC_EEPROM_CSEL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|11
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_amp
(paren
l_int|1
op_lshift
l_int|15
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|SGIMC_EEPROM_SDATAO
)paren
suffix:semicolon
)brace
r_else
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_SDATAO
)paren
suffix:semicolon
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
id|cmd
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_SDATAO
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|8
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
id|DELAY
suffix:semicolon
id|ASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
id|DELAY
suffix:semicolon
id|data
op_lshift_assign
l_int|1
suffix:semicolon
id|tmp
op_assign
op_star
id|cpu_control
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
id|SGIMC_EEPROM_SDATAI
)paren
(brace
id|data
op_or_assign
l_int|1
suffix:semicolon
)brace
)brace
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
id|DEASSERT
c_func
(paren
id|SGIMC_EEPROM_CSEL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|SGIMC_EEPROM_PRE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|SGIMC_EEPROM_SECLOCK
)paren
suffix:semicolon
id|data
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R4600/R5000 SCACHE size %dK &quot;
comma
(paren
r_int
)paren
(paren
id|data
op_rshift
l_int|10
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mips_cputype
)paren
(brace
r_case
id|CPU_R4600
suffix:colon
r_case
id|CPU_R4640
suffix:colon
id|sc_lsize
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sc_lsize
op_assign
l_int|128
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;linesize %d bytes&bslash;n&quot;
comma
id|sc_lsize
)paren
suffix:semicolon
id|scache_size
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
(brace
r_int
r_int
id|addr
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
multiline_comment|/* Enable r4600/r5000 cache.  But flush it first. */
r_for
c_loop
(paren
id|addr
op_assign
id|KSEG0
suffix:semicolon
id|addr
OL
(paren
id|KSEG0
op_plus
id|dcache_size
)paren
suffix:semicolon
id|addr
op_add_assign
id|dc_lsize
)paren
(brace
id|flush_dcache_line_indexed
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|addr
op_assign
id|KSEG0
suffix:semicolon
id|addr
OL
(paren
id|KSEG0
op_plus
id|icache_size
)paren
suffix:semicolon
id|addr
op_add_assign
id|ic_lsize
)paren
(brace
id|flush_icache_line_indexed
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|addr
op_assign
id|KSEG0
suffix:semicolon
id|addr
OL
(paren
id|KSEG0
op_plus
id|scache_size
)paren
suffix:semicolon
id|addr
op_add_assign
id|sc_lsize
)paren
(brace
id|flush_scache_line_indexed
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/* R5000 scache enable is in CP0 config, on R4600 variants&n;&t;&t; * the scache is enable by the memory mapped cache controller.&n;&t;&t; */
r_if
c_cond
(paren
id|mips_cputype
op_eq
id|CPU_R5000
)paren
(brace
r_int
r_int
id|config
suffix:semicolon
id|config
op_assign
id|read_32bit_cp0_register
c_func
(paren
id|CP0_CONFIG
)paren
suffix:semicolon
id|config
op_or_assign
l_int|0x1000
suffix:semicolon
id|write_32bit_cp0_register
c_func
(paren
id|CP0_CONFIG
comma
id|config
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is really cool... */
id|printk
c_func
(paren
l_string|&quot;Enabling R4600 SCACHE&bslash;n&quot;
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
dot
id|set
id|noreorder
dot
id|set
id|mips3
id|mfc0
op_mod
l_int|2
comma
"$"
l_int|12
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|li
op_mod
l_int|1
comma
l_int|0x80
id|mtc0
op_mod
l_int|1
comma
"$"
l_int|12
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|li
op_mod
l_int|0
comma
l_int|0x1
id|dsll
op_mod
l_int|0
comma
l_int|31
id|lui
op_mod
l_int|1
comma
l_int|0x9000
id|dsll32
op_mod
l_int|1
comma
l_int|0
op_logical_or
op_mod
l_int|0
comma
op_mod
l_int|1
comma
op_mod
l_int|0
id|sb
"$"
l_int|0
comma
l_int|0
(paren
op_mod
l_int|0
)paren
id|mtc0
"$"
l_int|0
comma
"$"
l_int|12
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|mtc0
op_mod
l_int|2
comma
"$"
l_int|12
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
dot
id|set
id|mips0
dot
id|set
id|reorder
l_string|&quot; : &quot;
op_assign
id|r
l_string|&quot; (tmp1), &quot;
op_assign
id|r
l_string|&quot; (tmp2), &quot;
op_assign
id|r
"&quot;"
(paren
id|addr
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mips_cputype
op_eq
id|CPU_R5000
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n;&t; * XXX For now we don&squot;t panic and assume that existing chipset&n;&t; * controlled caches are setup correnctly and are completly&n;&t; * transparent.  Works fine for those MIPS machines I know.&n;&t; * Morituri the salutant ...&n;&t; */
r_return
l_int|0
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Cannot probe SCACHE on this machine.&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* If you even _breathe_ on this function, look at the gcc output&n; * and make sure it does not pop things on and off the stack for&n; * the cache sizing loop that executes in KSEG1 space or else&n; * you will crash and burn badly.  You have been warned.&n; */
DECL|function|probe_scache
r_static
r_int
id|probe_scache
c_func
(paren
r_int
r_int
id|config
)paren
(brace
r_extern
r_int
r_int
id|stext
suffix:semicolon
r_int
r_int
id|flags
comma
id|addr
comma
id|begin
comma
id|end
comma
id|pow2
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
(paren
id|config
op_rshift
l_int|17
)paren
op_amp
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|tmp
op_assign
(paren
(paren
id|config
op_rshift
l_int|22
)paren
op_amp
l_int|3
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|tmp
)paren
(brace
r_case
l_int|0
suffix:colon
id|sc_lsize
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|sc_lsize
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|sc_lsize
op_assign
l_int|64
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|sc_lsize
op_assign
l_int|128
suffix:semicolon
r_break
suffix:semicolon
)brace
id|begin
op_assign
(paren
r_int
r_int
)paren
op_amp
id|stext
suffix:semicolon
id|begin
op_and_assign
op_complement
(paren
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|end
op_assign
id|begin
op_plus
(paren
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* This is such a bitch, you&squot;d think they would make it&n;&t; * easy to do this.  Away you daemons of stupidity!&n;&t; */
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Fill each size-multiple cache line with a valid tag. */
id|pow2
op_assign
(paren
l_int|64
op_star
l_int|1024
)paren
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
id|begin
suffix:semicolon
id|addr
OL
id|end
suffix:semicolon
id|addr
op_assign
(paren
id|begin
op_plus
id|pow2
)paren
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;nop&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
multiline_comment|/* whee... */
id|pow2
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Load first line with zero (therefore invalid) tag. */
id|set_taglo
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|set_taghi
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;nop; nop; nop; nop;&quot;
)paren
suffix:semicolon
multiline_comment|/* avoid the hazard */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&bslash;n&bslash;t.set noreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set mips3&bslash;n&bslash;t&quot;
l_string|&quot;cache 8, (%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set mips0&bslash;n&bslash;t&quot;
l_string|&quot;.set reorder&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|begin
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&bslash;n&bslash;t.set noreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set mips3&bslash;n&bslash;t&quot;
l_string|&quot;cache 9, (%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set mips0&bslash;n&bslash;t&quot;
l_string|&quot;.set reorder&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|begin
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&bslash;n&bslash;t.set noreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set mips3&bslash;n&bslash;t&quot;
l_string|&quot;cache 11, (%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set mips0&bslash;n&bslash;t&quot;
l_string|&quot;.set reorder&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|begin
)paren
)paren
suffix:semicolon
multiline_comment|/* Now search for the wrap around point. */
id|pow2
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
(paren
id|begin
op_plus
(paren
l_int|128
op_star
l_int|1024
)paren
)paren
suffix:semicolon
id|addr
OL
(paren
id|end
)paren
suffix:semicolon
id|addr
op_assign
(paren
id|begin
op_plus
id|pow2
)paren
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&bslash;n&bslash;t.set noreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set mips3&bslash;n&bslash;t&quot;
l_string|&quot;cache 7, (%0)&bslash;n&bslash;t&quot;
l_string|&quot;.set mips0&bslash;n&bslash;t&quot;
l_string|&quot;.set reorder&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;nop; nop; nop; nop;&quot;
)paren
suffix:semicolon
multiline_comment|/* hazard... */
r_if
c_cond
(paren
op_logical_neg
id|get_taglo
c_func
(paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|pow2
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|addr
op_sub_assign
id|begin
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Secondary cache sized at %dK linesize %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|addr
op_rshift
l_int|10
)paren
comma
id|sc_lsize
)paren
suffix:semicolon
id|scache_size
op_assign
id|addr
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|setup_noscache_funcs
r_static
r_void
id|setup_noscache_funcs
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|dc_lsize
)paren
(brace
r_case
l_int|16
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d16
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d16
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_d16i16
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_d16i16
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_d16i16
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_d16i16
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_d16i16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
r_if
c_cond
(paren
(paren
id|read_32bit_cp0_register
c_func
(paren
id|CP0_PRID
)paren
op_amp
l_int|0xfff0
)paren
op_eq
l_int|0x2010
)paren
(brace
id|clear_page
op_assign
id|r4k_clear_page_r4600_v1
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_r4600_v1
suffix:semicolon
)brace
r_else
(brace
id|clear_page
op_assign
id|r4k_clear_page_d32
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d32
suffix:semicolon
)brace
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_d32i32
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_d32i32
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_d32i32
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_d32i32
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_d32i32
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|setup_scache_funcs
r_static
r_void
id|setup_scache_funcs
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|sc_lsize
)paren
(brace
r_case
l_int|16
suffix:colon
r_switch
c_cond
(paren
id|dc_lsize
)paren
(brace
r_case
l_int|16
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d16
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d16
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s16d16i16
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s16d16i16
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s16d16i16
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s16d16i16
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s16d16i16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d32
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d32
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s16d32i32
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s16d32i32
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s16d32i32
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s16d32i32
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s16d32i32
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
r_switch
c_cond
(paren
id|dc_lsize
)paren
(brace
r_case
l_int|16
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d16
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d16
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s32d16i16
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s32d16i16
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s32d16i16
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s32d16i16
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s32d16i16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d32
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d32
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s32d32i32
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s32d32i32
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s32d32i32
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s32d32i32
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s32d32i32
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_case
l_int|64
suffix:colon
r_switch
c_cond
(paren
id|dc_lsize
)paren
(brace
r_case
l_int|16
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d16
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d16
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s64d16i16
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s64d16i16
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s64d16i16
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s64d16i16
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s64d16i16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d32
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d32
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s64d32i32
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s64d32i32
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s64d32i32
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s64d32i32
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s64d32i32
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_case
l_int|128
suffix:colon
r_switch
c_cond
(paren
id|dc_lsize
)paren
(brace
r_case
l_int|16
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d16
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d16
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s128d16i16
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s128d16i16
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s128d16i16
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s128d16i16
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s128d16i16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
id|clear_page
op_assign
id|r4k_clear_page_d32
suffix:semicolon
id|copy_page
op_assign
id|r4k_copy_page_d32
suffix:semicolon
id|flush_cache_all
op_assign
id|r4k_flush_cache_all_s128d32i32
suffix:semicolon
id|flush_cache_mm
op_assign
id|r4k_flush_cache_mm_s128d32i32
suffix:semicolon
id|flush_cache_range
op_assign
id|r4k_flush_cache_range_s128d32i32
suffix:semicolon
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_s128d32i32
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_s128d32i32
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|typedef|probe_func_t
r_typedef
r_int
(paren
op_star
id|probe_func_t
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|probe_scache_kseg1
r_static
id|probe_func_t
id|probe_scache_kseg1
suffix:semicolon
DECL|function|ld_mmu_r4xx0
r_void
id|ld_mmu_r4xx0
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cfg
op_assign
id|read_32bit_cp0_register
c_func
(paren
id|CP0_CONFIG
)paren
suffix:semicolon
r_int
id|sc_present
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU REVISION IS: %08x&bslash;n&quot;
comma
id|read_32bit_cp0_register
c_func
(paren
id|CP0_PRID
)paren
)paren
suffix:semicolon
id|probe_icache
c_func
(paren
id|cfg
)paren
suffix:semicolon
id|probe_dcache
c_func
(paren
id|cfg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mips_cputype
)paren
(brace
r_case
id|CPU_R4000PC
suffix:colon
r_case
id|CPU_R4000SC
suffix:colon
r_case
id|CPU_R4000MC
suffix:colon
r_case
id|CPU_R4400PC
suffix:colon
r_case
id|CPU_R4400SC
suffix:colon
r_case
id|CPU_R4400MC
suffix:colon
id|try_again
suffix:colon
id|probe_scache_kseg1
op_assign
(paren
id|probe_func_t
)paren
(paren
id|KSEG1ADDR
c_func
(paren
op_amp
id|probe_scache
)paren
)paren
suffix:semicolon
id|sc_present
op_assign
id|probe_scache_kseg1
c_func
(paren
id|cfg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_R4600
suffix:colon
r_case
id|CPU_R4640
suffix:colon
r_case
id|CPU_R4700
suffix:colon
r_case
id|CPU_R5000
suffix:colon
id|probe_scache_kseg1
op_assign
(paren
id|probe_func_t
)paren
(paren
id|KSEG1ADDR
c_func
(paren
op_amp
id|probe_scache_eeprom
)paren
)paren
suffix:semicolon
id|sc_present
op_assign
id|probe_scache_eeprom
c_func
(paren
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Try using tags if eeprom give us bogus data. */
r_if
c_cond
(paren
id|sc_present
op_eq
op_minus
l_int|1
)paren
(brace
r_goto
id|try_again
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sc_present
)paren
(brace
multiline_comment|/* Lacks secondary cache. */
id|setup_noscache_funcs
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Has a secondary cache. */
r_if
c_cond
(paren
id|mips_cputype
op_ne
id|CPU_R4600
op_logical_and
id|mips_cputype
op_ne
id|CPU_R4640
op_logical_and
id|mips_cputype
op_ne
id|CPU_R4700
op_logical_and
id|mips_cputype
op_ne
id|CPU_R5000
)paren
(brace
id|setup_scache_funcs
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|setup_noscache_funcs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mips_cputype
op_ne
id|CPU_R5000
)paren
)paren
(brace
id|flush_cache_page
op_assign
id|r4k_flush_cache_page_d32i32_r4600
suffix:semicolon
id|flush_page_to_ram
op_assign
id|r4k_flush_page_to_ram_d32i32_r4600
suffix:semicolon
)brace
)brace
)brace
id|flush_cache_sigtramp
op_assign
id|r4k_flush_cache_sigtramp
suffix:semicolon
id|flush_tlb_all
op_assign
id|r4k_flush_tlb_all
suffix:semicolon
id|flush_tlb_mm
op_assign
id|r4k_flush_tlb_mm
suffix:semicolon
id|flush_tlb_range
op_assign
id|r4k_flush_tlb_range
suffix:semicolon
id|flush_tlb_page
op_assign
id|r4k_flush_tlb_page
suffix:semicolon
id|load_pgd
op_assign
id|r4k_load_pgd
suffix:semicolon
id|pgd_init
op_assign
id|r4k_pgd_init
suffix:semicolon
id|update_mmu_cache
op_assign
id|r4k_update_mmu_cache
suffix:semicolon
id|show_regs
op_assign
id|r4k_show_regs
suffix:semicolon
id|add_wired_entry
op_assign
id|r4k_add_wired_entry
suffix:semicolon
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
id|write_32bit_cp0_register
c_func
(paren
id|CP0_WIRED
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * You should never change this register:&n;&t; *   - On R4600 1.7 the tlbp never hits for pages smaller than&n;&t; *     the value in the c0_pagemask register.&n;&t; *   - The entire mm handling assumes the c0_pagemask register to&n;&t; *     be set for 4kb pages.&n;&t; */
id|write_32bit_cp0_register
c_func
(paren
id|CP0_PAGEMASK
comma
id|PM_4K
)paren
suffix:semicolon
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
eof
