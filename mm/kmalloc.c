multiline_comment|/*&n; *  linux/mm/kmalloc.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds &amp; Roger Wolff.&n; *&n; *  Written by R.E. Wolff Sept/Oct &squot;93.&n; *&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
DECL|macro|GFP_LEVEL_MASK
mdefine_line|#define GFP_LEVEL_MASK 0xf
multiline_comment|/* I want this low enough for a while to catch errors.&n;   I want this number to be increased in the near future:&n;        loadable device drivers should use this function to get memory */
DECL|macro|MAX_KMALLOC_K
mdefine_line|#define MAX_KMALLOC_K 4
multiline_comment|/* This defines how many times we should try to allocate a free page before&n;   giving up. Normally this shouldn&squot;t happen at all. */
DECL|macro|MAX_GET_FREE_PAGE_TRIES
mdefine_line|#define MAX_GET_FREE_PAGE_TRIES 4
multiline_comment|/* Private flags. */
DECL|macro|MF_USED
mdefine_line|#define MF_USED 0xffaa0055
DECL|macro|MF_FREE
mdefine_line|#define MF_FREE 0x0055ffaa
multiline_comment|/* &n; * Much care has gone into making these routines in this file reentrant.&n; *&n; * The fancy bookkeeping of nbytesmalloced and the like are only used to&n; * report them to the user (oooohhhhh, aaaaahhhhh....) are not &n; * protected by cli(). (If that goes wrong. So what?)&n; *&n; * These routines restore the interrupt status to allow calling with ints&n; * off. &n; */
multiline_comment|/* &n; * A block header. This is in front of every malloc-block, whether free or not.&n; */
DECL|struct|block_header
r_struct
id|block_header
(brace
DECL|member|bh_flags
r_int
r_int
id|bh_flags
suffix:semicolon
r_union
(brace
DECL|member|ubh_length
r_int
r_int
id|ubh_length
suffix:semicolon
DECL|member|fbh_next
r_struct
id|block_header
op_star
id|fbh_next
suffix:semicolon
DECL|member|vp
)brace
id|vp
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|bh_length
mdefine_line|#define bh_length vp.ubh_length
DECL|macro|bh_next
mdefine_line|#define bh_next   vp.fbh_next
DECL|macro|BH
mdefine_line|#define BH(p) ((struct block_header *)(p))
multiline_comment|/* &n; * The page descriptor is at the front of every page that malloc has in use. &n; */
DECL|struct|page_descriptor
r_struct
id|page_descriptor
(brace
DECL|member|next
r_struct
id|page_descriptor
op_star
id|next
suffix:semicolon
DECL|member|firstfree
r_struct
id|block_header
op_star
id|firstfree
suffix:semicolon
DECL|member|order
r_int
id|order
suffix:semicolon
DECL|member|nfree
r_int
id|nfree
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PAGE_DESC
mdefine_line|#define PAGE_DESC(p) ((struct page_descriptor *)(((unsigned long)(p)) &amp; PAGE_MASK))
multiline_comment|/*&n; * A size descriptor describes a specific class of malloc sizes.&n; * Each class of sizes has its own freelist.&n; */
DECL|struct|size_descriptor
r_struct
id|size_descriptor
(brace
DECL|member|firstfree
r_struct
id|page_descriptor
op_star
id|firstfree
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|nblocks
r_int
id|nblocks
suffix:semicolon
DECL|member|nmallocs
r_int
id|nmallocs
suffix:semicolon
DECL|member|nfrees
r_int
id|nfrees
suffix:semicolon
DECL|member|nbytesmalloced
r_int
id|nbytesmalloced
suffix:semicolon
DECL|member|npages
r_int
id|npages
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|sizes
r_struct
id|size_descriptor
id|sizes
(braket
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|32
comma
l_int|127
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|64
comma
l_int|63
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|128
comma
l_int|31
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|252
comma
l_int|16
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|508
comma
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|1020
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|2040
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|4080
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|NBLOCKS
mdefine_line|#define NBLOCKS(order)          (sizes[order].nblocks)
DECL|macro|BLOCKSIZE
mdefine_line|#define BLOCKSIZE(order)        (sizes[order].size)
DECL|function|kmalloc_init
r_int
id|kmalloc_init
(paren
r_int
id|start_mem
comma
r_int
id|end_mem
)paren
(brace
r_int
id|order
suffix:semicolon
multiline_comment|/* &n; * Check the static info array. Things will blow up terribly if it&squot;s&n; * incorrect. This is a late &quot;compile time&quot; check.....&n; */
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|BLOCKSIZE
c_func
(paren
id|order
)paren
suffix:semicolon
id|order
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|NBLOCKS
(paren
id|order
)paren
op_star
id|BLOCKSIZE
c_func
(paren
id|order
)paren
op_plus
r_sizeof
(paren
r_struct
id|page_descriptor
)paren
)paren
OG
id|PAGE_SIZE
)paren
(brace
id|printk
(paren
l_string|&quot;Cannot use %d bytes out of %d in order = %d block mallocs&bslash;n&quot;
comma
id|NBLOCKS
(paren
id|order
)paren
op_star
id|BLOCKSIZE
c_func
(paren
id|order
)paren
op_plus
r_sizeof
(paren
r_struct
id|page_descriptor
)paren
comma
(paren
r_int
)paren
id|PAGE_SIZE
comma
id|BLOCKSIZE
(paren
id|order
)paren
)paren
suffix:semicolon
id|panic
(paren
l_string|&quot;This only happens if someone messes with kmalloc&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|start_mem
suffix:semicolon
)brace
DECL|function|get_order
r_int
id|get_order
(paren
r_int
id|size
)paren
(brace
r_int
id|order
suffix:semicolon
multiline_comment|/* Add the size of the header */
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|block_header
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|BLOCKSIZE
c_func
(paren
id|order
)paren
suffix:semicolon
id|order
op_increment
)paren
r_if
c_cond
(paren
id|size
op_le
id|BLOCKSIZE
(paren
id|order
)paren
)paren
r_return
id|order
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|kmalloc
r_void
op_star
id|kmalloc
(paren
r_int
id|size
comma
r_int
id|priority
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|order
comma
id|tries
comma
id|i
comma
id|sz
suffix:semicolon
r_struct
id|block_header
op_star
id|p
suffix:semicolon
r_struct
id|page_descriptor
op_star
id|page
suffix:semicolon
r_extern
r_int
r_int
id|intr_count
suffix:semicolon
multiline_comment|/* Sanity check... */
r_if
c_cond
(paren
id|intr_count
op_logical_and
id|priority
op_ne
id|GFP_ATOMIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmalloc called nonatomically from interrupt %08lx&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|size
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|priority
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OG
id|MAX_KMALLOC_K
op_star
l_int|1024
)paren
(brace
id|printk
(paren
l_string|&quot;kmalloc: I refuse to allocate %d bytes (for now max = %d).&bslash;n&quot;
comma
id|size
comma
id|MAX_KMALLOC_K
op_star
l_int|1024
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|order
op_assign
id|get_order
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;kmalloc of too large a block (%d bytes).&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* It seems VERY unlikely to me that it would be possible that this &n;   loop will get executed more than once. */
id|tries
op_assign
id|MAX_GET_FREE_PAGE_TRIES
suffix:semicolon
r_while
c_loop
(paren
id|tries
op_decrement
)paren
(brace
multiline_comment|/* Try to allocate a &quot;recently&quot; freed memory block */
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_assign
id|sizes
(braket
id|order
)braket
dot
id|firstfree
)paren
op_logical_and
(paren
id|p
op_assign
id|page-&gt;firstfree
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;bh_flags
op_eq
id|MF_FREE
)paren
(brace
id|page-&gt;firstfree
op_assign
id|p-&gt;bh_next
suffix:semicolon
id|page-&gt;nfree
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;nfree
)paren
(brace
id|sizes
(braket
id|order
)braket
dot
id|firstfree
op_assign
id|page-&gt;next
suffix:semicolon
id|page-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sizes
(braket
id|order
)braket
dot
id|nmallocs
op_increment
suffix:semicolon
id|sizes
(braket
id|order
)braket
dot
id|nbytesmalloced
op_add_assign
id|size
suffix:semicolon
id|p-&gt;bh_flags
op_assign
id|MF_USED
suffix:semicolon
multiline_comment|/* As of now this block is officially in use */
id|p-&gt;bh_length
op_assign
id|size
suffix:semicolon
r_return
id|p
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Pointer arithmetic: increments past header */
)brace
id|printk
(paren
l_string|&quot;Problem: block on freelist at %08lx isn&squot;t free.&bslash;n&quot;
comma
(paren
r_int
)paren
id|p
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Now we&squot;re in trouble: We need to get a new free page..... */
id|sz
op_assign
id|BLOCKSIZE
c_func
(paren
id|order
)paren
suffix:semicolon
multiline_comment|/* sz is the size of the blocks we&squot;re dealing with */
multiline_comment|/* This can be done with ints on: This is private to this invocation */
id|page
op_assign
(paren
r_struct
id|page_descriptor
op_star
)paren
id|__get_free_page
(paren
id|priority
op_amp
id|GFP_LEVEL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|printk
(paren
l_string|&quot;Couldn&squot;t get a free page.....&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;Got page %08x to use for %d byte mallocs....&quot;
comma
(paren
r_int
)paren
id|page
comma
id|sz
)paren
suffix:semicolon
macro_line|#endif
id|sizes
(braket
id|order
)braket
dot
id|npages
op_increment
suffix:semicolon
multiline_comment|/* Loop for all but last block: */
r_for
c_loop
(paren
id|i
op_assign
id|NBLOCKS
c_func
(paren
id|order
)paren
comma
id|p
op_assign
id|BH
(paren
id|page
op_plus
l_int|1
)paren
suffix:semicolon
id|i
OG
l_int|1
suffix:semicolon
id|i
op_decrement
comma
id|p
op_assign
id|p-&gt;bh_next
)paren
(brace
id|p-&gt;bh_flags
op_assign
id|MF_FREE
suffix:semicolon
id|p-&gt;bh_next
op_assign
id|BH
(paren
(paren
(paren
r_int
)paren
id|p
)paren
op_plus
id|sz
)paren
suffix:semicolon
)brace
multiline_comment|/* Last block: */
id|p-&gt;bh_flags
op_assign
id|MF_FREE
suffix:semicolon
id|p-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
id|page-&gt;order
op_assign
id|order
suffix:semicolon
id|page-&gt;nfree
op_assign
id|NBLOCKS
c_func
(paren
id|order
)paren
suffix:semicolon
id|page-&gt;firstfree
op_assign
id|BH
c_func
(paren
id|page
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
id|printk
(paren
l_string|&quot;%d blocks per page&bslash;n&quot;
comma
id|page-&gt;nfree
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Now we&squot;re going to muck with the &quot;global&quot; freelist for this size:&n;       this should be uniterruptible */
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;     * sizes[order].firstfree used to be NULL, otherwise we wouldn&squot;t be&n;     * here, but you never know.... &n;     */
id|page-&gt;next
op_assign
id|sizes
(braket
id|order
)braket
dot
id|firstfree
suffix:semicolon
id|sizes
(braket
id|order
)braket
dot
id|firstfree
op_assign
id|page
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Pray that printk won&squot;t cause this to happen again :-) */
id|printk
(paren
l_string|&quot;Hey. This is very funny. I tried %d times to allocate a whole&bslash;n&quot;
l_string|&quot;new page for an object only %d bytes long, but some other process&bslash;n&quot;
l_string|&quot;beat me to actually allocating it. Also note that this &squot;error&squot;&bslash;n&quot;
l_string|&quot;message is soooo very long to catch your attention. I&squot;d appreciate&bslash;n&quot;
l_string|&quot;it if you&squot;d be so kind as to report what conditions caused this to&bslash;n&quot;
l_string|&quot;the author of this kmalloc: wolff@dutecai.et.tudelft.nl.&bslash;n&quot;
l_string|&quot;(Executive summary: This can&squot;t happen)&bslash;n&quot;
comma
id|MAX_GET_FREE_PAGE_TRIES
comma
id|size
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|kfree_s
r_void
id|kfree_s
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|order
suffix:semicolon
r_register
r_struct
id|block_header
op_star
id|p
op_assign
(paren
(paren
r_struct
id|block_header
op_star
)paren
id|ptr
)paren
op_minus
l_int|1
suffix:semicolon
r_struct
id|page_descriptor
op_star
id|page
comma
op_star
id|pg2
suffix:semicolon
id|page
op_assign
id|PAGE_DESC
(paren
id|p
)paren
suffix:semicolon
id|order
op_assign
id|page-&gt;order
suffix:semicolon
r_if
c_cond
(paren
(paren
id|order
OL
l_int|0
)paren
op_logical_or
(paren
id|order
OG
r_sizeof
(paren
id|sizes
)paren
op_div
r_sizeof
(paren
id|sizes
(braket
l_int|0
)braket
)paren
)paren
op_logical_or
(paren
(paren
(paren
r_int
)paren
(paren
id|page-&gt;next
)paren
)paren
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
(paren
id|p-&gt;bh_flags
op_ne
id|MF_USED
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;kfree of non-kmalloced memory: %p, next= %p, order=%d&bslash;n&quot;
comma
id|p
comma
id|page-&gt;next
comma
id|page-&gt;order
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_logical_and
id|size
op_ne
id|p-&gt;bh_length
)paren
(brace
id|printk
(paren
l_string|&quot;Trying to free pointer at %p with wrong size: %d instead of %lu.&bslash;n&quot;
comma
id|p
comma
id|size
comma
id|p-&gt;bh_length
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|size
op_assign
id|p-&gt;bh_length
suffix:semicolon
id|p-&gt;bh_flags
op_assign
id|MF_FREE
suffix:semicolon
multiline_comment|/* As of now this block is officially free */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|p-&gt;bh_next
op_assign
id|page-&gt;firstfree
suffix:semicolon
id|page-&gt;firstfree
op_assign
id|p
suffix:semicolon
id|page-&gt;nfree
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;nfree
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Page went from full to one free block: put it on the freelist */
r_if
c_cond
(paren
id|page-&gt;next
)paren
(brace
id|printk
(paren
l_string|&quot;Page %p already on freelist dazed and confused....&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|page-&gt;next
op_assign
id|sizes
(braket
id|order
)braket
dot
id|firstfree
suffix:semicolon
id|sizes
(braket
id|order
)braket
dot
id|firstfree
op_assign
id|page
suffix:semicolon
)brace
)brace
multiline_comment|/* If page is completely free, free it */
r_if
c_cond
(paren
id|page-&gt;nfree
op_eq
id|NBLOCKS
(paren
id|page-&gt;order
)paren
)paren
(brace
macro_line|#if 0
id|printk
(paren
l_string|&quot;Freeing page %08x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|page
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sizes
(braket
id|order
)braket
dot
id|firstfree
op_eq
id|page
)paren
(brace
id|sizes
(braket
id|order
)braket
dot
id|firstfree
op_assign
id|page-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|pg2
op_assign
id|sizes
(braket
id|order
)braket
dot
id|firstfree
suffix:semicolon
(paren
id|pg2
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|pg2-&gt;next
op_ne
id|page
)paren
suffix:semicolon
id|pg2
op_assign
id|pg2-&gt;next
)paren
multiline_comment|/* Nothing */
suffix:semicolon
r_if
c_cond
(paren
id|pg2
op_ne
l_int|NULL
)paren
id|pg2-&gt;next
op_assign
id|page-&gt;next
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;Ooops. page %p doesn&squot;t show on freelist.&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
)brace
id|free_page
(paren
(paren
r_int
)paren
id|page
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sizes
(braket
id|order
)braket
dot
id|nfrees
op_increment
suffix:semicolon
multiline_comment|/* Noncritical (monitoring) admin stuff */
id|sizes
(braket
id|order
)braket
dot
id|nbytesmalloced
op_sub_assign
id|size
suffix:semicolon
)brace
eof
