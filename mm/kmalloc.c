multiline_comment|/*&n; *  linux/mm/kmalloc.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds &amp; Roger Wolff.&n; *&n; *  Written by R.E. Wolff Sept/Oct &squot;93.&n; *&n; */
multiline_comment|/*&n; * Modified by Alex Bligh (alex@cconcepts.co.uk) 4 Apr 1994 to use multiple&n; * pages. So for &squot;page&squot; throughout, read &squot;area&squot;.&n; *&n; * Largely rewritten.. Linus&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
multiline_comment|/* Define this if you want slow routines that try to trip errors */
DECL|macro|SADISTIC_KMALLOC
macro_line|#undef SADISTIC_KMALLOC
multiline_comment|/* Private flags. */
DECL|macro|MF_USED
mdefine_line|#define MF_USED 0xffaa0055
DECL|macro|MF_DMA
mdefine_line|#define MF_DMA  0xff00aa55
DECL|macro|MF_FREE
mdefine_line|#define MF_FREE 0x0055ffaa
multiline_comment|/*&n; * Much care has gone into making these routines in this file reentrant.&n; *&n; * The fancy bookkeeping of nbytesmalloced and the like are only used to&n; * report them to the user (oooohhhhh, aaaaahhhhh....) are not&n; * protected by cli(). (If that goes wrong. So what?)&n; *&n; * These routines restore the interrupt status to allow calling with ints&n; * off.&n; */
multiline_comment|/*&n; * A block header. This is in front of every malloc-block, whether free or not.&n; */
DECL|struct|block_header
r_struct
id|block_header
(brace
DECL|member|bh_flags
r_int
r_int
id|bh_flags
suffix:semicolon
r_union
(brace
DECL|member|ubh_length
r_int
r_int
id|ubh_length
suffix:semicolon
DECL|member|fbh_next
r_struct
id|block_header
op_star
id|fbh_next
suffix:semicolon
DECL|member|vp
)brace
id|vp
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|bh_length
mdefine_line|#define bh_length vp.ubh_length
DECL|macro|bh_next
mdefine_line|#define bh_next   vp.fbh_next
DECL|macro|BH
mdefine_line|#define BH(p) ((struct block_header *)(p))
multiline_comment|/*&n; * The page descriptor is at the front of every page that malloc has in use.&n; */
DECL|struct|page_descriptor
r_struct
id|page_descriptor
(brace
DECL|member|next
r_struct
id|page_descriptor
op_star
id|next
suffix:semicolon
DECL|member|firstfree
r_struct
id|block_header
op_star
id|firstfree
suffix:semicolon
DECL|member|order
r_int
id|order
suffix:semicolon
DECL|member|nfree
r_int
id|nfree
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PAGE_DESC
mdefine_line|#define PAGE_DESC(p) ((struct page_descriptor *)(((unsigned long)(p)) &amp; PAGE_MASK))
multiline_comment|/*&n; * A size descriptor describes a specific class of malloc sizes.&n; * Each class of sizes has its own freelist.&n; */
DECL|struct|size_descriptor
r_struct
id|size_descriptor
(brace
DECL|member|firstfree
r_struct
id|page_descriptor
op_star
id|firstfree
suffix:semicolon
DECL|member|dmafree
r_struct
id|page_descriptor
op_star
id|dmafree
suffix:semicolon
multiline_comment|/* DMA-able memory */
DECL|member|nblocks
r_int
id|nblocks
suffix:semicolon
DECL|member|nmallocs
r_int
id|nmallocs
suffix:semicolon
DECL|member|nfrees
r_int
id|nfrees
suffix:semicolon
DECL|member|nbytesmalloced
r_int
id|nbytesmalloced
suffix:semicolon
DECL|member|npages
r_int
id|npages
suffix:semicolon
DECL|member|gfporder
r_int
r_int
id|gfporder
suffix:semicolon
multiline_comment|/* number of pages in the area required */
)brace
suffix:semicolon
multiline_comment|/*&n; * For now it is unsafe to allocate bucket sizes between n and&n; * n-sizeof(page_descriptor) where n is PAGE_SIZE * any power of two&n; *&n; * The blocksize and sizes arrays _must_ match!&n; */
macro_line|#if PAGE_SIZE == 4096
DECL|variable|blocksize
r_static
r_const
r_int
r_int
id|blocksize
(braket
)braket
op_assign
(brace
l_int|32
comma
l_int|64
comma
l_int|128
comma
l_int|252
comma
l_int|508
comma
l_int|1020
comma
l_int|2040
comma
l_int|4096
op_minus
l_int|16
comma
l_int|8192
op_minus
l_int|16
comma
l_int|16384
op_minus
l_int|16
comma
l_int|32768
op_minus
l_int|16
comma
l_int|65536
op_minus
l_int|16
comma
l_int|131072
op_minus
l_int|16
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|sizes
r_static
r_struct
id|size_descriptor
id|sizes
(braket
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|127
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|63
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|31
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|16
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|3
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|4
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|5
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#elif PAGE_SIZE == 8192
DECL|variable|blocksize
r_static
r_const
r_int
r_int
id|blocksize
(braket
)braket
op_assign
(brace
l_int|64
comma
l_int|128
comma
l_int|248
comma
l_int|504
comma
l_int|1016
comma
l_int|2040
comma
l_int|4080
comma
l_int|8192
op_minus
l_int|32
comma
l_int|16384
op_minus
l_int|32
comma
l_int|32768
op_minus
l_int|32
comma
l_int|65536
op_minus
l_int|32
comma
l_int|131072
op_minus
l_int|32
comma
l_int|262144
op_minus
l_int|32
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|sizes
r_struct
id|size_descriptor
id|sizes
(braket
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|127
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|63
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|31
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|16
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|3
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|4
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|5
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#else
macro_line|#error you need to make a version for your pagesize
macro_line|#endif
DECL|macro|NBLOCKS
mdefine_line|#define NBLOCKS(order)          (sizes[order].nblocks)
DECL|macro|BLOCKSIZE
mdefine_line|#define BLOCKSIZE(order)        (blocksize[order])
DECL|macro|AREASIZE
mdefine_line|#define AREASIZE(order)&t;&t;(PAGE_SIZE&lt;&lt;(sizes[order].gfporder))
multiline_comment|/*&n; * Create a small cache of page allocations: this helps a bit with&n; * those pesky 8kB+ allocations for NFS when we&squot;re temporarily&n; * out of memory..&n; *&n; * This is a _truly_ small cache, we just cache one single page&n; * order (for orders 0, 1 and 2, that is  4, 8 and 16kB on x86).&n; */
DECL|macro|MAX_CACHE_ORDER
mdefine_line|#define MAX_CACHE_ORDER 3
DECL|variable|kmalloc_cache
r_struct
id|page_descriptor
op_star
id|kmalloc_cache
(braket
id|MAX_CACHE_ORDER
)braket
suffix:semicolon
DECL|function|get_kmalloc_pages
r_static
r_inline
r_struct
id|page_descriptor
op_star
id|get_kmalloc_pages
c_func
(paren
r_int
r_int
id|priority
comma
r_int
r_int
id|order
comma
r_int
id|dma
)paren
(brace
r_return
(paren
r_struct
id|page_descriptor
op_star
)paren
id|__get_free_pages
c_func
(paren
id|priority
comma
id|order
comma
id|dma
)paren
suffix:semicolon
)brace
DECL|function|free_kmalloc_pages
r_static
r_inline
r_void
id|free_kmalloc_pages
c_func
(paren
r_struct
id|page_descriptor
op_star
id|page
comma
r_int
r_int
id|order
comma
r_int
id|dma
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma
op_logical_and
id|order
OL
id|MAX_CACHE_ORDER
)paren
(brace
id|page
op_assign
id|xchg
c_func
(paren
id|kmalloc_cache
op_plus
id|order
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
suffix:semicolon
)brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|page
comma
id|order
)paren
suffix:semicolon
)brace
DECL|function|kmalloc_init
r_int
id|kmalloc_init
c_func
(paren
r_int
id|start_mem
comma
r_int
id|end_mem
)paren
(brace
r_int
id|order
suffix:semicolon
multiline_comment|/*&n; * Check the static info array. Things will blow up terribly if it&squot;s&n; * incorrect. This is a late &quot;compile time&quot; check.....&n; */
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|BLOCKSIZE
c_func
(paren
id|order
)paren
suffix:semicolon
id|order
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|NBLOCKS
c_func
(paren
id|order
)paren
op_star
id|BLOCKSIZE
c_func
(paren
id|order
)paren
op_plus
r_sizeof
(paren
r_struct
id|page_descriptor
)paren
)paren
OG
id|AREASIZE
c_func
(paren
id|order
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot use %d bytes out of %d in order = %d block mallocs&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|NBLOCKS
c_func
(paren
id|order
)paren
op_star
id|BLOCKSIZE
c_func
(paren
id|order
)paren
op_plus
r_sizeof
(paren
r_struct
id|page_descriptor
)paren
)paren
comma
(paren
r_int
)paren
id|AREASIZE
c_func
(paren
id|order
)paren
comma
id|BLOCKSIZE
c_func
(paren
id|order
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;This only happens if someone messes with kmalloc&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|start_mem
suffix:semicolon
)brace
multiline_comment|/*&n; * Ugh, this is ugly, but we want the default case to run&n; * straight through, which is why we have the ugly goto&squot;s&n; */
DECL|function|kmalloc
r_void
op_star
id|kmalloc
c_func
(paren
r_int
id|size
comma
r_int
id|priority
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|order
comma
id|dma
suffix:semicolon
r_struct
id|block_header
op_star
id|p
suffix:semicolon
r_struct
id|page_descriptor
op_star
id|page
comma
op_star
op_star
id|pg
suffix:semicolon
r_struct
id|size_descriptor
op_star
id|bucket
op_assign
id|sizes
suffix:semicolon
multiline_comment|/* Get order */
id|order
op_assign
l_int|0
suffix:semicolon
(brace
r_int
r_int
id|realsize
op_assign
id|size
op_plus
r_sizeof
(paren
r_struct
id|block_header
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|ordersize
op_assign
id|BLOCKSIZE
c_func
(paren
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|realsize
op_le
id|ordersize
)paren
r_break
suffix:semicolon
id|order
op_increment
suffix:semicolon
id|bucket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ordersize
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;kmalloc of too large a block (%d bytes).&bslash;n&quot;
comma
(paren
r_int
)paren
id|size
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|dma
op_assign
l_int|0
suffix:semicolon
id|type
op_assign
id|MF_USED
suffix:semicolon
id|pg
op_assign
op_amp
id|bucket-&gt;firstfree
suffix:semicolon
r_if
c_cond
(paren
id|priority
op_amp
id|GFP_DMA
)paren
(brace
id|dma
op_assign
l_int|1
suffix:semicolon
id|type
op_assign
id|MF_DMA
suffix:semicolon
id|pg
op_assign
op_amp
id|bucket-&gt;dmafree
suffix:semicolon
)brace
id|priority
op_and_assign
id|GFP_LEVEL_MASK
suffix:semicolon
multiline_comment|/* Sanity check... */
macro_line|#if 0&t;/* no longer valid */
r_if
c_cond
(paren
id|intr_count
op_logical_and
id|priority
op_ne
id|GFP_ATOMIC
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmalloc called nonatomically from interrupt %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|priority
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
)brace
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|page
op_assign
op_star
id|pg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_bucket_page
suffix:semicolon
id|p
op_assign
id|page-&gt;firstfree
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;bh_flags
op_ne
id|MF_FREE
)paren
r_goto
id|not_free_on_freelist
suffix:semicolon
id|found_it
suffix:colon
id|page-&gt;firstfree
op_assign
id|p-&gt;bh_next
suffix:semicolon
id|page-&gt;nfree
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;nfree
)paren
op_star
id|pg
op_assign
id|page-&gt;next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|bucket-&gt;nmallocs
op_increment
suffix:semicolon
id|bucket-&gt;nbytesmalloced
op_add_assign
id|size
suffix:semicolon
id|p-&gt;bh_flags
op_assign
id|type
suffix:semicolon
multiline_comment|/* As of now this block is officially in use */
id|p-&gt;bh_length
op_assign
id|size
suffix:semicolon
macro_line|#ifdef SADISTIC_KMALLOC
id|memset
c_func
(paren
id|p
op_plus
l_int|1
comma
l_int|0xf0
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_return
id|p
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Pointer arithmetic: increments past header */
id|no_bucket_page
suffix:colon
multiline_comment|/*&n;&t; * If we didn&squot;t find a page already allocated for this&n;&t; * bucket size, we need to get one..&n;&t; *&n;&t; * This can be done with ints on: it is private to this invocation&n;&t; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
(brace
r_int
id|i
comma
id|sz
suffix:semicolon
multiline_comment|/* sz is the size of the blocks we&squot;re dealing with */
id|sz
op_assign
id|BLOCKSIZE
c_func
(paren
id|order
)paren
suffix:semicolon
id|page
op_assign
id|get_kmalloc_pages
c_func
(paren
id|priority
comma
id|bucket-&gt;gfporder
comma
id|dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_free_page
suffix:semicolon
id|found_cached_page
suffix:colon
id|bucket-&gt;npages
op_increment
suffix:semicolon
id|page-&gt;order
op_assign
id|order
suffix:semicolon
multiline_comment|/* Loop for all but last block: */
id|i
op_assign
(paren
id|page-&gt;nfree
op_assign
id|bucket-&gt;nblocks
)paren
op_minus
l_int|1
suffix:semicolon
id|p
op_assign
id|BH
c_func
(paren
id|page
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
id|i
op_decrement
suffix:semicolon
id|p-&gt;bh_flags
op_assign
id|MF_FREE
suffix:semicolon
id|p-&gt;bh_next
op_assign
id|BH
c_func
(paren
(paren
(paren
r_int
)paren
id|p
)paren
op_plus
id|sz
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;bh_next
suffix:semicolon
)brace
multiline_comment|/* Last block: */
id|p-&gt;bh_flags
op_assign
id|MF_FREE
suffix:semicolon
id|p-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
id|p
op_assign
id|BH
c_func
(paren
id|page
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we&squot;re going to muck with the &quot;global&quot; freelist&n;&t; * for this size: this should be uninterruptible&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|page-&gt;next
op_assign
op_star
id|pg
suffix:semicolon
op_star
id|pg
op_assign
id|page
suffix:semicolon
r_goto
id|found_it
suffix:semicolon
id|no_free_page
suffix:colon
multiline_comment|/*&n;&t; * No free pages, check the kmalloc cache of&n;&t; * pages to see if maybe we have something available&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dma
op_logical_and
id|order
OL
id|MAX_CACHE_ORDER
)paren
(brace
id|page
op_assign
id|xchg
c_func
(paren
id|kmalloc_cache
op_plus
id|order
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|found_cached_page
suffix:semicolon
)brace
(brace
r_static
r_int
r_int
id|last
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|priority
op_ne
id|GFP_BUFFER
op_logical_and
(paren
id|last
op_plus
l_int|10
op_star
id|HZ
OL
id|jiffies
)paren
)paren
(brace
id|last
op_assign
id|jiffies
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t get a free page.....&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|not_free_on_freelist
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Problem: block on freelist at %08lx isn&squot;t free.&bslash;n&quot;
comma
(paren
r_int
)paren
id|p
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|kfree
r_void
id|kfree
c_func
(paren
r_void
op_star
id|__ptr
)paren
(brace
r_int
id|dma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|order
suffix:semicolon
r_struct
id|page_descriptor
op_star
id|page
comma
op_star
op_star
id|pg
suffix:semicolon
r_struct
id|size_descriptor
op_star
id|bucket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__ptr
)paren
r_goto
id|null_kfree
suffix:semicolon
DECL|macro|ptr
mdefine_line|#define ptr ((struct block_header *) __ptr)
id|page
op_assign
id|PAGE_DESC
c_func
(paren
id|ptr
)paren
suffix:semicolon
id|__ptr
op_assign
id|ptr
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|PAGE_MASK
op_amp
(paren
r_int
r_int
)paren
id|page-&gt;next
)paren
r_goto
id|bad_order
suffix:semicolon
id|order
op_assign
id|page-&gt;order
suffix:semicolon
r_if
c_cond
(paren
id|order
op_ge
r_sizeof
(paren
id|sizes
)paren
op_div
r_sizeof
(paren
id|sizes
(braket
l_int|0
)braket
)paren
)paren
r_goto
id|bad_order
suffix:semicolon
id|bucket
op_assign
id|sizes
op_plus
id|order
suffix:semicolon
id|dma
op_assign
l_int|0
suffix:semicolon
id|pg
op_assign
op_amp
id|bucket-&gt;firstfree
suffix:semicolon
r_if
c_cond
(paren
id|ptr-&gt;bh_flags
op_eq
id|MF_DMA
)paren
(brace
id|dma
op_assign
l_int|1
suffix:semicolon
id|ptr-&gt;bh_flags
op_assign
id|MF_USED
suffix:semicolon
id|pg
op_assign
op_amp
id|bucket-&gt;dmafree
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr-&gt;bh_flags
op_ne
id|MF_USED
)paren
r_goto
id|bad_order
suffix:semicolon
id|ptr-&gt;bh_flags
op_assign
id|MF_FREE
suffix:semicolon
multiline_comment|/* As of now this block is officially free */
macro_line|#ifdef SADISTIC_KMALLOC
id|memset
c_func
(paren
id|ptr
op_plus
l_int|1
comma
l_int|0x0e
comma
id|ptr-&gt;bh_length
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bucket-&gt;nfrees
op_increment
suffix:semicolon
id|bucket-&gt;nbytesmalloced
op_sub_assign
id|ptr-&gt;bh_length
suffix:semicolon
id|ptr-&gt;bh_next
op_assign
id|page-&gt;firstfree
suffix:semicolon
id|page-&gt;firstfree
op_assign
id|ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;nfree
op_increment
)paren
(brace
multiline_comment|/* Page went from full to one free block: put it on the freelist. */
r_if
c_cond
(paren
id|bucket-&gt;nblocks
op_eq
l_int|1
)paren
r_goto
id|free_page
suffix:semicolon
id|page-&gt;next
op_assign
op_star
id|pg
suffix:semicolon
op_star
id|pg
op_assign
id|page
suffix:semicolon
)brace
multiline_comment|/* If page is completely free, free it */
r_if
c_cond
(paren
id|page-&gt;nfree
op_eq
id|bucket-&gt;nblocks
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|page_descriptor
op_star
id|tmp
op_assign
op_star
id|pg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_goto
id|not_on_freelist
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|page
)paren
r_break
suffix:semicolon
id|pg
op_assign
op_amp
id|tmp-&gt;next
suffix:semicolon
)brace
op_star
id|pg
op_assign
id|page-&gt;next
suffix:semicolon
id|free_page
suffix:colon
id|bucket-&gt;npages
op_decrement
suffix:semicolon
id|free_kmalloc_pages
c_func
(paren
id|page
comma
id|bucket-&gt;gfporder
comma
id|dma
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|null_kfree
suffix:colon
r_return
suffix:semicolon
id|bad_order
suffix:colon
id|printk
c_func
(paren
l_string|&quot;kfree of non-kmalloced memory: %p, next= %p, order=%d&bslash;n&quot;
comma
id|ptr
op_plus
l_int|1
comma
id|page-&gt;next
comma
id|page-&gt;order
)paren
suffix:semicolon
r_return
suffix:semicolon
id|not_on_freelist
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Ooops. page %p doesn&squot;t show on freelist.&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
eof
