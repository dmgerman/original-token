multiline_comment|/*&n; *  linux/mm/page_io.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  Swap reorganised 29.12.95, &n; *  Asynchronous swapping added 30.12.95. Stephen Tweedie&n; *  Removed race in async swapping. 14.4.1996. Bruno Haible&n; *  Add swap of shared pages through the page cache. 20.2.1998. Stephen Tweedie&n; *  Always use brw_page, life becomes simpler. 12 May 1998 Eric Biederman&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/*&n; * Reads or writes a swap page.&n; * wait=1: start I/O and wait for completion. wait=0: start asynchronous I/O.&n; *&n; * Important prevention of race condition: the caller *must* atomically &n; * create a unique swap cache entry for this swap page before calling&n; * rw_swap_page, and must lock that page.  By ensuring that there is a&n; * single page of memory reserved for the swap entry, the normal VM page&n; * lock on that page also doubles as a lock on swap entries.  Having only&n; * one lock to deal with per swap entry (rather than locking swap and memory&n; * independently) also makes it easier to make certain swapping operations&n; * atomic, which is particularly important when we are trying to ensure &n; * that shared pages stay shared while being swapped.&n; */
DECL|function|rw_swap_page_base
r_static
r_void
id|rw_swap_page_base
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|wait
comma
r_int
id|dolock
)paren
(brace
r_int
r_int
id|type
comma
id|offset
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
id|zones
(braket
id|PAGE_SIZE
op_div
l_int|512
)braket
suffix:semicolon
r_int
id|zones_used
suffix:semicolon
id|kdev_t
id|dev
op_assign
l_int|0
suffix:semicolon
r_int
id|block_size
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
(paren
l_string|&quot;DebugVM: %s_swap_page entry %08lx, page %p (count %d), %s&bslash;n&quot;
comma
(paren
id|rw
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
comma
id|entry
comma
(paren
r_char
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|page_count
c_func
(paren
id|page
)paren
comma
id|wait
ques
c_cond
l_string|&quot;wait&quot;
suffix:colon
l_string|&quot;nowait&quot;
)paren
suffix:semicolon
macro_line|#endif
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Internal error: bad swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t allow too many pending pages in flight.. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|nr_async_pages
)paren
OG
id|pager_daemon.swap_cluster
)paren
id|wait
op_assign
l_int|1
suffix:semicolon
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;swap_map
op_logical_and
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: &quot;
l_string|&quot;Trying to %s unallocated swap (%08lx)&bslash;n&quot;
comma
(paren
id|rw
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
comma
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: &quot;
l_string|&quot;Trying to swap to unused swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VM: swap page is unlocked&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
(brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|kstat.pswpin
op_increment
suffix:semicolon
)brace
r_else
id|kstat.pswpout
op_increment
suffix:semicolon
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
)paren
(brace
id|zones
(braket
l_int|0
)braket
op_assign
id|offset
suffix:semicolon
id|zones_used
op_assign
l_int|1
suffix:semicolon
id|dev
op_assign
id|p-&gt;swap_device
suffix:semicolon
id|block_size
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
r_struct
id|inode
op_star
id|swapf
op_assign
id|p-&gt;swap_file-&gt;d_inode
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|j
suffix:semicolon
r_int
r_int
id|block
op_assign
id|offset
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|swapf-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|block_size
op_assign
id|swapf-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
id|block_size
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|zones
(braket
id|i
)braket
op_assign
id|bmap
c_func
(paren
id|swapf
comma
id|block
op_increment
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: bad swap file&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|zones_used
op_assign
id|i
suffix:semicolon
id|dev
op_assign
id|swapf-&gt;i_dev
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: no swap file or device&bslash;n&quot;
)paren
suffix:semicolon
id|put_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
id|set_bit
c_func
(paren
id|PG_decr_after
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|nr_async_pages
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dolock
)paren
(brace
id|set_bit
c_func
(paren
id|PG_free_swap_after
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_increment
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|PG_free_after
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* block_size == PAGE_SIZE/zones_used */
id|brw_page
c_func
(paren
id|rw
comma
id|page
comma
id|dev
comma
id|zones
comma
id|block_size
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Note! For consistency we do all of the logic,&n; &t; * decrementing the page count, and unlocking the page in the&n; &t; * swap lock map - in the IO completion handler.&n; &t; */
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
r_return
suffix:semicolon
)brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* This shouldn&squot;t happen, but check to be sure. */
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: page unused while waiting!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
(paren
l_string|&quot;DebugVM: %s_swap_page finished on page %p (count %d)&bslash;n&quot;
comma
(paren
id|rw
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
comma
(paren
r_char
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|page_count
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * A simple wrapper so the base function doesn&squot;t need to enforce&n; * that all swap pages go through the swap cache! We verify that:&n; *  - the page is locked&n; *  - it&squot;s marked as being swap-cache&n; *  - it&squot;s associated with the swap inode&n; */
DECL|function|rw_swap_page
r_void
id|rw_swap_page
c_func
(paren
r_int
id|rw
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|entry
op_assign
id|page-&gt;offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;inode
op_ne
op_amp
id|swapper_inode
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|rw_swap_page_base
c_func
(paren
id|rw
comma
id|entry
comma
id|page
comma
id|wait
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmfs needs a version that doesn&squot;t put the page in the page cache!&n; * The swap lock map insists that pages be in the page cache!&n; * Therefore we can&squot;t use it.  Later when we can remove the need for the&n; * lock map and we can reduce the number of functions exported.&n; */
DECL|function|rw_swap_page_nolock
r_void
id|rw_swap_page_nolock
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_char
op_star
id|buf
comma
r_int
id|wait
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|rw_swap_page_base
c_func
(paren
id|rw
comma
id|entry
comma
id|page
comma
id|wait
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
