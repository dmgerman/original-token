multiline_comment|/*&n; *  linux/mm/page_io.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  Swap reorganised 29.12.95, &n; *  Asynchronous swapping added 30.12.95. Stephen Tweedie&n; *  Removed race in async swapping. 14.4.1996. Bruno Haible&n; *  Add swap of shared pages through the page cache. 20.2.1998. Stephen Tweedie&n; *  Always use brw_page, life becomes simpler. 12 May 1998 Eric Biederman&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|lock_queue
)paren
suffix:semicolon
multiline_comment|/*&n; * Reads or writes a swap page.&n; * wait=1: start I/O and wait for completion. wait=0: start asynchronous I/O.&n; *&n; * Important prevention of race condition: the caller *must* atomically &n; * create a unique swap cache entry for this swap page before calling&n; * rw_swap_page, and must lock that page.  By ensuring that there is a&n; * single page of memory reserved for the swap entry, the normal VM page&n; * lock on that page also doubles as a lock on swap entries.  Having only&n; * one lock to deal with per swap entry (rather than locking swap and memory&n; * independently) also makes it easier to make certain swapping operations&n; * atomic, which is particularly important when we are trying to ensure &n; * that shared pages stay shared while being swapped.&n; */
DECL|function|rw_swap_page_base
r_static
r_void
id|rw_swap_page_base
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|type
comma
id|offset
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
id|zones
(braket
id|PAGE_SIZE
op_div
l_int|512
)braket
suffix:semicolon
r_int
id|zones_used
suffix:semicolon
id|kdev_t
id|dev
op_assign
l_int|0
suffix:semicolon
r_int
id|block_size
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
(paren
l_string|&quot;DebugVM: %s_swap_page entry %08lx, page %p (count %d), %s&bslash;n&quot;
comma
(paren
id|rw
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
comma
id|entry
comma
(paren
r_char
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
comma
id|wait
ques
c_cond
l_string|&quot;wait&quot;
suffix:colon
l_string|&quot;nowait&quot;
)paren
suffix:semicolon
macro_line|#endif
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Internal error: bad swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t allow too many pending pages in flight.. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|nr_async_pages
)paren
OG
id|pager_daemon.swap_cluster
)paren
id|wait
op_assign
l_int|1
suffix:semicolon
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;swap_map
op_logical_and
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: &quot;
l_string|&quot;Trying to %s unallocated swap (%08lx)&bslash;n&quot;
comma
(paren
id|rw
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
comma
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: &quot;
l_string|&quot;Trying to swap to unused swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VM: swap page is unlocked&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* Make sure we are the only process doing I/O with this swap page. */
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Make sure that we have a swap cache association for this&n;&t;&t; * page.  We need this to find which swap page to unlock once&n;&t;&t; * the swap IO has completed to the physical page.  If the page&n;&t;&t; * is not already in the cache, just overload the offset entry&n;&t;&t; * as if it were: we are not allowed to manipulate the inode&n;&t;&t; * hashing for locked pages.&n;&t;&t; */
r_if
c_cond
(paren
id|page-&gt;offset
op_ne
id|entry
)paren
(brace
id|printk
(paren
l_string|&quot;swap entry mismatch&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
(brace
id|clear_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|kstat.pswpin
op_increment
suffix:semicolon
)brace
r_else
id|kstat.pswpout
op_increment
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
)paren
(brace
id|zones
(braket
l_int|0
)braket
op_assign
id|offset
suffix:semicolon
id|zones_used
op_assign
l_int|1
suffix:semicolon
id|dev
op_assign
id|p-&gt;swap_device
suffix:semicolon
id|block_size
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
r_struct
id|inode
op_star
id|swapf
op_assign
id|p-&gt;swap_file-&gt;d_inode
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|swapf-&gt;i_op-&gt;bmap
op_eq
l_int|NULL
op_logical_and
id|swapf-&gt;i_op-&gt;smap
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;With MS-DOS, we use msdos_smap which returns&n;&t;&t;&t;&t;a sector number (not a cluster or block number).&n;&t;&t;&t;&t;It is a patch to enable the UMSDOS project.&n;&t;&t;&t;&t;Other people are working on better solution.&n;&n;&t;&t;&t;&t;It sounds like ll_rw_swap_file defined&n;&t;&t;&t;&t;its operation size (sector size) based on&n;&t;&t;&t;&t;PAGE_SIZE and the number of blocks to read.&n;&t;&t;&t;&t;So using bmap or smap should work even if&n;&t;&t;&t;&t;smap will require more blocks.&n;&t;&t;&t;*/
r_int
id|j
suffix:semicolon
r_int
r_int
id|block
op_assign
id|offset
op_lshift
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
l_int|512
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|zones
(braket
id|i
)braket
op_assign
id|swapf-&gt;i_op
op_member_access_from_pointer
id|smap
c_func
(paren
id|swapf
comma
id|block
op_increment
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: bad swap file&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|block_size
op_assign
l_int|512
suffix:semicolon
)brace
r_else
(brace
r_int
id|j
suffix:semicolon
r_int
r_int
id|block
op_assign
id|offset
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|swapf-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|block_size
op_assign
id|swapf-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
id|block_size
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|zones
(braket
id|i
)braket
op_assign
id|bmap
c_func
(paren
id|swapf
comma
id|block
op_increment
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: bad swap file&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|zones_used
op_assign
id|i
suffix:semicolon
id|dev
op_assign
id|swapf-&gt;i_dev
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: no swap file or device&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Do some cleaning up so if this ever happens we can hopefully&n;&t;&t; * trigger controlled shutdown.&n;&t;&t; */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;swap_after_unlock_page: lock already cleared&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
id|set_bit
c_func
(paren
id|PG_decr_after
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|nr_async_pages
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* only lock/unlock swap cache pages! */
id|set_bit
c_func
(paren
id|PG_swap_unlock_after
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|PG_free_after
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* block_size == PAGE_SIZE/zones_used */
id|brw_page
c_func
(paren
id|rw
comma
id|page
comma
id|dev
comma
id|zones
comma
id|block_size
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Note! For consistency we do all of the logic,&n; &t; * decrementing the page count, and unlocking the page in the&n; &t; * swap lock map - in the IO completion handler.&n; &t; */
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_return
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* This shouldn&squot;t happen, but check to be sure. */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: page unused while waiting!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
(paren
l_string|&quot;DebugVM: %s_swap_page finished on page %p (count %d)&bslash;n&quot;
comma
(paren
id|rw
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
comma
(paren
r_char
op_star
)paren
id|page_adddress
c_func
(paren
id|page
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Note: We could remove this totally asynchronous function,&n; * and improve swap performance, and remove the need for the swap lock map,&n; * by not removing pages from the swap cache until after I/O has been&n; * processed and letting remove_from_page_cache decrement the swap count&n; * just before it removes the page from the page cache.&n; */
multiline_comment|/* This is run when asynchronous page I/O has completed. */
DECL|function|swap_after_unlock_page
r_void
id|swap_after_unlock_page
(paren
r_int
r_int
id|entry
)paren
(brace
r_int
r_int
id|type
comma
id|offset
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_after_unlock_page: bad swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_after_unlock_page: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;swap_after_unlock_page: lock already cleared&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
)brace
multiline_comment|/* A simple wrapper so the base function doesn&squot;t need to enforce&n; * that all swap pages go through the swap cache!&n; */
DECL|function|rw_swap_page
r_void
id|rw_swap_page
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_char
op_star
id|buf
comma
r_int
id|wait
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;inode
op_logical_and
id|page-&gt;inode
op_ne
op_amp
id|swapper_inode
)paren
id|panic
(paren
l_string|&quot;Tried to swap a non-swapper page&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that we have a swap cache association for this&n;&t; * page.  We need this to find which swap page to unlock once&n;&t; * the swap IO has completed to the physical page.  If the page&n;&t; * is not already in the cache, just overload the offset entry&n;&t; * as if it were: we are not allowed to manipulate the inode&n;&t; * hashing for locked pages.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: swap page is not in swap cache&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;offset
op_ne
id|entry
)paren
(brace
id|printk
(paren
l_string|&quot;swap entry mismatch&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rw_swap_page_base
c_func
(paren
id|rw
comma
id|entry
comma
id|page
comma
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setting up a new swap file needs a simple wrapper just to read the &n; * swap signature.  SysV shared memory also needs a simple wrapper.&n; */
DECL|function|rw_swap_page_nocache
r_void
id|rw_swap_page_nocache
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|PG_swap_cache
comma
op_amp
id|page-&gt;flags
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;VM: read_swap_page: page already in swap cache!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;inode
)paren
(brace
id|printk
(paren
l_string|&quot;VM: read_swap_page: page already in page cache!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|page-&gt;inode
op_assign
op_amp
id|swapper_inode
suffix:semicolon
id|page-&gt;offset
op_assign
id|entry
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Protect from shrink_mmap() */
id|rw_swap_page
c_func
(paren
id|rw
comma
id|entry
comma
id|buffer
comma
l_int|1
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
id|page-&gt;inode
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_swap_cache
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmfs needs a version that doesn&squot;t put the page in the page cache!&n; * The swap lock map insists that pages be in the page cache!&n; * Therefore we can&squot;t use it.  Later when we can remove the need for the&n; * lock map and we can reduce the number of functions exported.&n; */
DECL|function|rw_swap_page_nolock
r_void
id|rw_swap_page_nolock
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_char
op_star
id|buffer
comma
r_int
id|wait
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: rw_swap_page_nolock: page not locked!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;VM: rw_swap_page_nolock: page in swap cache!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rw_swap_page_base
c_func
(paren
id|rw
comma
id|entry
comma
id|page
comma
id|wait
)paren
suffix:semicolon
)brace
eof
