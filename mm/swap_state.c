multiline_comment|/*&n; *  linux/mm/swap_state.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *  Swap reorganised 29.12.95, Stephen Tweedie&n; *&n; *  Rewritten to use page cache, (C) 1998 Stephen Tweedie&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|variable|swapper_space
r_struct
id|address_space
id|swapper_space
op_assign
(brace
(brace
multiline_comment|/* pages&t;*/
op_amp
id|swapper_space.pages
comma
multiline_comment|/*        .next */
op_amp
id|swapper_space.pages
multiline_comment|/*&t;  .prev */
)brace
comma
l_int|0
multiline_comment|/* nrpages&t;*/
)brace
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
DECL|variable|swap_cache_add_total
r_int
r_int
id|swap_cache_add_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_del_total
r_int
r_int
id|swap_cache_del_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_find_total
r_int
r_int
id|swap_cache_find_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_find_success
r_int
r_int
id|swap_cache_find_success
op_assign
l_int|0
suffix:semicolon
DECL|function|show_swap_cache_info
r_void
id|show_swap_cache_info
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Swap cache: add %ld, delete %ld, find %ld/%ld&bslash;n&quot;
comma
id|swap_cache_add_total
comma
id|swap_cache_del_total
comma
id|swap_cache_find_success
comma
id|swap_cache_find_total
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|add_to_swap_cache
r_void
id|add_to_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|swp_entry_t
id|entry
)paren
(brace
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_add_total
op_increment
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|PageTestandSetSwapCache
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|add_to_page_cache
c_func
(paren
id|page
comma
op_amp
id|swapper_space
comma
id|entry.val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that a swap entry is valid and increment its swap map count.&n; *&n; * Note: if swap_map[] reaches SWAP_MAP_MAX the entries are treated as&n; * &quot;permanent&quot;, but will be reclaimed by the next swapoff.&n; */
DECL|function|swap_duplicate
r_int
id|swap_duplicate
c_func
(paren
id|swp_entry_t
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Swap entry 0 is illegal */
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|out
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|SHM_SWP_TYPE
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_file
suffix:semicolon
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_unused
suffix:semicolon
multiline_comment|/*&n;&t; * Entry is valid, so increment the map count.&n;&t; */
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
OL
id|SWAP_MAP_MAX
)paren
id|p-&gt;swap_map
(braket
id|offset
)braket
op_increment
suffix:semicolon
r_else
(brace
r_static
r_int
id|overflow
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|overflow
op_increment
OL
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;VM: swap entry overflow&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_assign
id|SWAP_MAP_MAX
suffix:semicolon
)brace
id|result
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|bad_file
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Bad swap file entry %08lx&bslash;n&quot;
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Bad swap offset entry %08lx&bslash;n&quot;
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_unused
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unused swap offset entry %08lx&bslash;n&quot;
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|swap_count
r_int
id|swap_count
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|entry.val
op_assign
id|page-&gt;pg_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|bad_entry
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|SHM_SWP_TYPE
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_file
suffix:semicolon
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_unused
suffix:semicolon
id|retval
op_assign
id|p-&gt;swap_map
(braket
id|offset
)braket
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
id|bad_entry
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: null entry!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_file
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Bad swap file entry %08lx&bslash;n&quot;
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Bad swap offset entry %08lx&bslash;n&quot;
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_unused
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unused swap offset entry %08lx&bslash;n&quot;
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|remove_from_swap_cache
r_static
r_inline
r_void
id|remove_from_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping
op_ne
op_amp
id|swapper_space
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|PageClearSwapCache
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This must be called only on pages that have&n; * been verified to be in the swap cache.&n; */
DECL|function|__delete_from_swap_cache
r_void
id|__delete_from_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
id|entry.val
op_assign
id|page-&gt;pg_offset
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_del_total
op_increment
suffix:semicolon
macro_line|#endif
id|remove_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|delete_from_swap_cache_nolock
r_static
r_void
id|delete_from_swap_cache_nolock
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|block_flushpage
c_func
(paren
l_int|NULL
comma
id|page
comma
l_int|0
)paren
)paren
id|lru_cache_del
c_func
(paren
id|page
)paren
suffix:semicolon
id|__delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This must be called only on pages that have&n; * been verified to be in the swap cache.&n; */
DECL|function|delete_from_swap_cache
r_void
id|delete_from_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|delete_from_swap_cache_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Perform a free_page(), also freeing any swap cache associated with&n; * this page if it is the last user of the page. &n; */
DECL|function|free_page_and_swap_cache
r_void
id|free_page_and_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/* &n;&t; * If we are the only user, then free up the swap cache. &n;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|is_page_shared
c_func
(paren
id|page
)paren
)paren
(brace
id|delete_from_swap_cache_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_swap_entry
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup a swap entry in the swap cache. A found page will be returned&n; * unlocked and with its refcount incremented - we rely on the kernel&n; * lock getting page table operations atomic even if we drop the page&n; * lock before returning.&n; */
DECL|function|lookup_swap_cache
r_struct
id|page
op_star
id|lookup_swap_cache
c_func
(paren
id|swp_entry_t
id|entry
)paren
(brace
r_struct
id|page
op_star
id|found
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_find_total
op_increment
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Right now the pagecache is 32-bit only.  But it&squot;s a 32 bit index. =)&n;&t;&t; */
id|found
op_assign
id|find_lock_page
c_func
(paren
op_amp
id|swapper_space
comma
id|entry.val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|found-&gt;mapping
op_ne
op_amp
id|swapper_space
op_logical_or
op_logical_neg
id|PageSwapCache
c_func
(paren
id|found
)paren
)paren
r_goto
id|out_bad
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_find_success
op_increment
suffix:semicolon
macro_line|#endif
id|UnlockPage
c_func
(paren
id|found
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
id|out_bad
suffix:colon
id|printk
(paren
id|KERN_ERR
l_string|&quot;VM: Found a non-swapper swap page!&bslash;n&quot;
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|found
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|found
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Locate a page of swap in physical memory, reserving swap cache space&n; * and reading the disk if it is not already cached.  If wait==0, we are&n; * only doing readahead, so don&squot;t worry if the page is already locked.&n; *&n; * A failure return means that either the page allocation failed or that&n; * the swap entry is no longer in use.&n; */
DECL|function|read_swap_cache_async
r_struct
id|page
op_star
id|read_swap_cache_async
c_func
(paren
id|swp_entry_t
id|entry
comma
r_int
id|wait
)paren
(brace
r_struct
id|page
op_star
id|found_page
op_assign
l_int|0
comma
op_star
id|new_page
suffix:semicolon
r_int
r_int
id|new_page_addr
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the swap entry is still in use.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|swap_duplicate
c_func
(paren
id|entry
)paren
)paren
multiline_comment|/* Account for the swap cache */
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Look for the page in the swap cache.&n;&t; */
id|found_page
op_assign
id|lookup_swap_cache
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found_page
)paren
r_goto
id|out_free_swap
suffix:semicolon
id|new_page_addr
op_assign
id|__get_free_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page_addr
)paren
r_goto
id|out_free_swap
suffix:semicolon
multiline_comment|/* Out of memory */
id|new_page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|new_page_addr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check the swap cache again, in case we stalled above.&n;&t; */
id|found_page
op_assign
id|lookup_swap_cache
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found_page
)paren
r_goto
id|out_free_page
suffix:semicolon
multiline_comment|/* &n;&t; * Add it to the swap cache and read its contents.&n;&t; */
id|add_to_swap_cache
c_func
(paren
id|new_page
comma
id|entry
)paren
suffix:semicolon
id|rw_swap_page
c_func
(paren
id|READ
comma
id|new_page
comma
id|wait
)paren
suffix:semicolon
r_return
id|new_page
suffix:semicolon
id|out_free_page
suffix:colon
id|__free_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|out_free_swap
suffix:colon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|found_page
suffix:semicolon
)brace
eof
