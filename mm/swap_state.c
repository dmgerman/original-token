multiline_comment|/*&n; *  linux/mm/swap_state.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *  Swap reorganised 29.12.95, Stephen Tweedie&n; *&n; *  Rewritten to use page cache, (C) 1998 Stephen Tweedie&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/* &n; * Keep a reserved false inode which we will use to mark pages in the&n; * page cache are acting as swap cache instead of file cache. &n; *&n; * We only need a unique pointer to satisfy the page cache, but we&squot;ll&n; * reserve an entire zeroed inode structure for the purpose just to&n; * ensure that any mistaken dereferences of this structure cause a&n; * kernel oops.&n; */
DECL|variable|swapper_inode_operations
r_static
r_struct
id|inode_operations
id|swapper_inode_operations
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* default file operations */
l_int|NULL
comma
multiline_comment|/* create */
l_int|NULL
comma
multiline_comment|/* lookup */
l_int|NULL
comma
multiline_comment|/* link */
l_int|NULL
comma
multiline_comment|/* unlink */
l_int|NULL
comma
multiline_comment|/* symlink */
l_int|NULL
comma
multiline_comment|/* mkdir */
l_int|NULL
comma
multiline_comment|/* rmdir */
l_int|NULL
comma
multiline_comment|/* mknod */
l_int|NULL
comma
multiline_comment|/* rename */
l_int|NULL
comma
multiline_comment|/* readlink */
l_int|NULL
comma
multiline_comment|/* follow_link */
l_int|NULL
comma
multiline_comment|/* bmap */
l_int|NULL
comma
multiline_comment|/* readpage */
l_int|NULL
comma
multiline_comment|/* writepage */
id|block_flushpage
comma
multiline_comment|/* flushpage */
l_int|NULL
comma
multiline_comment|/* truncate */
l_int|NULL
comma
multiline_comment|/* permission */
l_int|NULL
comma
multiline_comment|/* smap */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
DECL|variable|swapper_inode
r_struct
id|inode
id|swapper_inode
op_assign
(brace
id|i_op
suffix:colon
op_amp
id|swapper_inode_operations
)brace
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
DECL|variable|swap_cache_add_total
r_int
r_int
id|swap_cache_add_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_del_total
r_int
r_int
id|swap_cache_del_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_find_total
r_int
r_int
id|swap_cache_find_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_find_success
r_int
r_int
id|swap_cache_find_success
op_assign
l_int|0
suffix:semicolon
DECL|function|show_swap_cache_info
r_void
id|show_swap_cache_info
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Swap cache: add %ld, delete %ld, find %ld/%ld&bslash;n&quot;
comma
id|swap_cache_add_total
comma
id|swap_cache_del_total
comma
id|swap_cache_find_success
comma
id|swap_cache_find_total
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|add_to_swap_cache
r_void
id|add_to_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|entry
)paren
(brace
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_add_total
op_increment
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_SWAP
id|printk
c_func
(paren
l_string|&quot;DebugVM: add_to_swap_cache(%08lx count %d, entry %08lx)&bslash;n&quot;
comma
id|page_address
c_func
(paren
id|page
)paren
comma
id|page_count
c_func
(paren
id|page
)paren
comma
id|entry
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|PageTestandSetSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_cache: replacing non-empty entry %08lx &quot;
l_string|&quot;on page %08lx&bslash;n&quot;
comma
id|page-&gt;offset
comma
id|page_address
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_cache: replacing page-cached entry &quot;
l_string|&quot;on page %08lx&bslash;n&quot;
comma
id|page_address
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
)brace
id|add_to_page_cache
c_func
(paren
id|page
comma
op_amp
id|swapper_inode
comma
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that a swap entry is valid and increment its swap map count.&n; *&n; * Note: if swap_map[] reaches SWAP_MAP_MAX the entries are treated as&n; * &quot;permanent&quot;, but will be reclaimed by the next swapoff.&n; */
DECL|function|swap_duplicate
r_int
id|swap_duplicate
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_goto
id|out
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|SHM_SWP_TYPE
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_file
suffix:semicolon
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_unused
suffix:semicolon
multiline_comment|/*&n;&t; * Entry is valid, so increment the map count.&n;&t; */
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
OL
id|SWAP_MAP_MAX
)paren
id|p-&gt;swap_map
(braket
id|offset
)braket
op_increment
suffix:semicolon
r_else
(brace
r_static
r_int
id|overflow
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|overflow
op_increment
OL
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;swap_duplicate: entry %08lx map count=%d&bslash;n&quot;
comma
id|entry
comma
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_assign
id|SWAP_MAP_MAX
suffix:semicolon
)brace
id|result
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
c_func
(paren
l_string|&quot;DebugVM: swap_duplicate(entry %08lx, count now %d)&bslash;n&quot;
comma
id|entry
comma
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|bad_file
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_duplicate: entry %08lx, nonexistent swap file&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_duplicate: entry %08lx, offset exceeds max&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_unused
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_duplicate at %8p: entry %08lx, unused page&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|entry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|swap_count
r_int
id|swap_count
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_goto
id|bad_entry
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|SHM_SWP_TYPE
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_file
suffix:semicolon
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_unused
suffix:semicolon
id|retval
op_assign
id|p-&gt;swap_map
(braket
id|offset
)braket
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
c_func
(paren
l_string|&quot;DebugVM: swap_count(entry %08lx, count %d)&bslash;n&quot;
comma
id|entry
comma
id|retval
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
id|bad_entry
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: null entry!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_file
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: entry %08lx, nonexistent swap file!&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: entry %08lx, offset exceeds max!&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_unused
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count at %8p: entry %08lx, unused page!&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|entry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|remove_from_swap_cache
r_static
r_inline
r_void
id|remove_from_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
(paren
l_string|&quot;VM: Removing swap cache page with zero inode hash &quot;
l_string|&quot;on page %08lx&bslash;n&quot;
comma
id|page_address
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode
op_ne
op_amp
id|swapper_inode
)paren
(brace
id|printk
(paren
l_string|&quot;VM: Removing swap cache page with wrong inode hash &quot;
l_string|&quot;on page %08lx&bslash;n&quot;
comma
id|page_address
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
c_func
(paren
l_string|&quot;DebugVM: remove_from_swap_cache(%08lx count %d)&bslash;n&quot;
comma
id|page_address
c_func
(paren
id|page
)paren
comma
id|page_count
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
macro_line|#endif
id|PageClearSwapCache
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op-&gt;flushpage
)paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|flushpage
c_func
(paren
id|inode
comma
id|page
comma
l_int|0
)paren
suffix:semicolon
id|remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This must be called only on pages that have&n; * been verified to be in the swap cache.&n; */
DECL|function|__delete_from_swap_cache
r_void
id|__delete_from_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|entry
op_assign
id|page-&gt;offset
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_del_total
op_increment
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_SWAP
id|printk
c_func
(paren
l_string|&quot;DebugVM: delete_from_swap_cache(%08lx count %d, &quot;
l_string|&quot;entry %08lx)&bslash;n&quot;
comma
id|page_address
c_func
(paren
id|page
)paren
comma
id|page_count
c_func
(paren
id|page
)paren
comma
id|entry
)paren
suffix:semicolon
macro_line|#endif
id|remove_from_swap_cache
(paren
id|page
)paren
suffix:semicolon
id|swap_free
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This must be called only on pages that have&n; * been verified to be in the swap cache.&n; */
DECL|function|delete_from_swap_cache
r_void
id|delete_from_swap_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|__delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Perform a free_page(), also freeing any swap cache associated with&n; * this page if it is the last user of the page. &n; */
DECL|function|free_page_and_swap_cache
r_void
id|free_page_and_swap_cache
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If we are the only user, then free up the swap cache. &n;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|is_page_shared
c_func
(paren
id|page
)paren
)paren
(brace
r_int
id|entry
op_assign
id|page-&gt;offset
suffix:semicolon
id|remove_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup a swap entry in the swap cache. A found page will be returned&n; * unlocked and with its refcount incremented - we rely on the kernel&n; * lock getting page table operations atomic even if we drop the page&n; * lock before returning.&n; */
DECL|function|lookup_swap_cache
r_struct
id|page
op_star
id|lookup_swap_cache
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_struct
id|page
op_star
id|found
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_find_total
op_increment
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|found
op_assign
id|find_lock_page
c_func
(paren
op_amp
id|swapper_inode
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|found-&gt;inode
op_ne
op_amp
id|swapper_inode
op_logical_or
op_logical_neg
id|PageSwapCache
c_func
(paren
id|found
)paren
)paren
r_goto
id|out_bad
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_find_success
op_increment
suffix:semicolon
macro_line|#endif
id|UnlockPage
c_func
(paren
id|found
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
id|out_bad
suffix:colon
id|printk
(paren
id|KERN_ERR
l_string|&quot;VM: Found a non-swapper swap page!&bslash;n&quot;
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|found
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|found
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Locate a page of swap in physical memory, reserving swap cache space&n; * and reading the disk if it is not already cached.  If wait==0, we are&n; * only doing readahead, so don&squot;t worry if the page is already locked.&n; *&n; * A failure return means that either the page allocation failed or that&n; * the swap entry is no longer in use.&n; */
DECL|function|read_swap_cache_async
r_struct
id|page
op_star
id|read_swap_cache_async
c_func
(paren
r_int
r_int
id|entry
comma
r_int
id|wait
)paren
(brace
r_struct
id|page
op_star
id|found_page
op_assign
l_int|0
comma
op_star
id|new_page
suffix:semicolon
r_int
r_int
id|new_page_addr
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
c_func
(paren
l_string|&quot;DebugVM: read_swap_cache_async entry %08lx%s&bslash;n&quot;
comma
id|entry
comma
id|wait
ques
c_cond
l_string|&quot;, wait&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Make sure the swap entry is still in use.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|swap_duplicate
c_func
(paren
id|entry
)paren
)paren
multiline_comment|/* Account for the swap cache */
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Look for the page in the swap cache.&n;&t; */
id|found_page
op_assign
id|lookup_swap_cache
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found_page
)paren
r_goto
id|out_free_swap
suffix:semicolon
id|new_page_addr
op_assign
id|__get_free_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page_addr
)paren
r_goto
id|out_free_swap
suffix:semicolon
multiline_comment|/* Out of memory */
id|new_page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|new_page_addr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check the swap cache again, in case we stalled above.&n;&t; */
id|found_page
op_assign
id|lookup_swap_cache
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found_page
)paren
r_goto
id|out_free_page
suffix:semicolon
multiline_comment|/* &n;&t; * Add it to the swap cache and read its contents.&n;&t; */
id|add_to_swap_cache
c_func
(paren
id|new_page
comma
id|entry
)paren
suffix:semicolon
id|rw_swap_page
c_func
(paren
id|READ
comma
id|new_page
comma
id|wait
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
c_func
(paren
l_string|&quot;DebugVM: read_swap_cache_async created &quot;
l_string|&quot;entry %08lx at %p&bslash;n&quot;
comma
id|entry
comma
(paren
r_char
op_star
)paren
id|page_address
c_func
(paren
id|new_page
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|new_page
suffix:semicolon
id|out_free_page
suffix:colon
id|__free_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|out_free_swap
suffix:colon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|found_page
suffix:semicolon
)brace
eof
