multiline_comment|/*&n; * linux/mm/slab.c&n; * Written by Mark Hemment, 1996/97.&n; * (markhe@nextd.demon.co.uk)&n; *&n; * 11 April &squot;97.  Started multi-threading - markhe&n; *&t;The global cache-chain is protected by the semaphore &squot;cache_chain_sem&squot;.&n; *&t;The sem is only needed when accessing/extending the cache-chain, which&n; *&t;can never happen inside an interrupt (kmem_cache_create(),&n; *&t;kmem_cache_shrink() and kmem_cache_reap()).&n; *&t;This is a medium-term exclusion lock.&n; *&n; *&t;Each cache has its own lock; &squot;c_spinlock&squot;.  This lock is needed only&n; *&t;when accessing non-constant members of a cache-struct.&n; *&t;Note: &squot;constant members&squot; are assigned a value in kmem_cache_create() before&n; *&t;the cache is linked into the cache-chain.  The values never change, so not&n; *&t;even a multi-reader lock is needed for these members.&n; *&t;The c_spinlock is only ever held for a few cycles.&n; *&n; *&t;To prevent kmem_cache_shrink() trying to shrink a &squot;growing&squot; cache (which&n; *&t;maybe be sleeping and therefore not holding the semaphore/lock), the&n; *&t;c_growing field is used.  This also prevents reaping from a cache.&n; *&n; *&t;Note, caches can _never_ be destroyed.  When a sub-system (eg module) has&n; *&t;finished with a cache, it can only be shrunk.  This leaves the cache empty,&n; *&t;but already enabled for re-use, eg. during a module re-load.&n; *&n; *&t;Notes:&n; *&t;&t;o Constructors/deconstructors are called while the cache-lock&n; *&t;&t;  is _not_ held.  Therefore they _must_ be threaded.&n; *&t;&t;o Constructors must not attempt to allocate memory from the&n; *&t;&t;  same cache that they are a constructor for - infinite loop!&n; *&t;&t;  (There is no easy way to trap this.)&n; *&t;&t;o The per-cache locks must be obtained with local-interrupts disabled.&n; *&t;&t;o When compiled with debug support, and an object-verify (upon release)&n; *&t;&t;  is request for a cache, the verify-function is called with the cache&n; *&t;&t;  lock held.  This helps debugging.&n; *&t;&t;o The functions called from try_to_free_page() must not attempt&n; *&t;&t;  to allocate memory from a cache which is being grown.&n; *&t;&t;  The buffer sub-system might try to allocate memory, via buffer_cachep.&n; *&t;&t;  As this pri is passed to the SLAB, and then (if necessary) onto the&n; *&t;&t;  gfp() funcs (which avoid calling try_to_free_page()), no deadlock&n; *&t;&t;  should happen.&n; *&n; *&t;The positioning of the per-cache lock is tricky.  If the lock is&n; *&t;placed on the same h/w cache line as commonly accessed members&n; *&t;the number of L1 cache-line faults is reduced.  However, this can&n; *&t;lead to the cache-line ping-ponging between processors when the&n; *&t;lock is in contention (and the common members are being accessed).&n; *&t;Decided to keep it away from common members.&n; *&n; *&t;More fine-graining is possible, with per-slab locks...but this might be&n; *&t;taking fine graining too far, but would have the advantage;&n; *&t;&t;During most allocs/frees no writes occur to the cache-struct.&n; *&t;&t;Therefore a multi-reader/one writer lock could be used (the writer&n; *&t;&t;needed when the slab chain is being link/unlinked).&n; *&t;&t;As we would not have an exclusion lock for the cache-structure, one&n; *&t;&t;would be needed per-slab (for updating s_free ptr, and/or the contents&n; *&t;&t;of s_index).&n; *&t;The above locking would allow parallel operations to different slabs within&n; *&t;the same cache with reduced spinning.&n; *&n; *&t;Per-engine slab caches, backed by a global cache (as in Mach&squot;s Zone allocator),&n; *&t;would allow most allocations from the same cache to execute in parallel.&n; *&n; *&t;At present, each engine can be growing a cache.  This should be blocked.&n; *&n; *&t;It is not currently 100% safe to examine the page_struct outside of a kernel&n; *&t;or global cli lock.  The risk is v. small, and non-fatal.&n; *&n; *&t;Calls to printk() are not 100% safe (the function is not threaded).  However,&n; *&t;printk() is only used under an error condition, and the risk is v. small (not&n; *&t;sure if the console write functions &squot;enjoy&squot; executing multiple contextes in&n; *&t;parallel.  I guess they don&squot;t...).&n; *&t;Note, for most calls to printk() any held cache-lock is dropped.  This is not&n; *&t;always done for text size reasons - having *_unlock() everywhere is bloat.&n; */
multiline_comment|/*&n; * An implementation of the Slab Allocator as described in outline in;&n; *&t;UNIX Internals: The New Frontiers by Uresh Vahalia&n; *&t;Pub: Prentice Hall&t;ISBN 0-13-101908-2&n; * or with a little more detail in;&n; *&t;The Slab Allocator: An Object-Caching Kernel Memory Allocator&n; *&t;Jeff Bonwick (Sun Microsystems).&n; *&t;Presented at: USENIX Summer 1994 Technical Conference&n; */
multiline_comment|/*&n; * This implementation deviates from Bonwick&squot;s paper as it&n; * does not use a hash-table for large objects, but rather a per slab&n; * index to hold the bufctls.  This allows the bufctl structure to&n; * be small (one word), but limits the number of objects a slab (not&n; * a cache) can contain when off-slab bufctls are used.  The limit is the&n; * size of the largest general-cache that does not use off-slab bufctls,&n; * divided by the size of a bufctl.  For 32bit archs, is this 256/4 = 64.&n; * This is not serious, as it is only for large objects, when it is unwise&n; * to have too many per slab.&n; * Note: This limit can be raised by introducing a general-cache whose size&n; * is less than 512 (PAGE_SIZE&lt;&lt;3), but greater than 256.&n; */
macro_line|#include&t;&lt;linux/mm.h&gt;
macro_line|#include&t;&lt;linux/slab.h&gt;
macro_line|#include&t;&lt;linux/interrupt.h&gt;
macro_line|#include&t;&lt;linux/config.h&gt;
macro_line|#include&t;&lt;linux/init.h&gt;
macro_line|#include&t;&lt;linux/smp.h&gt;
macro_line|#include&t;&lt;asm/system.h&gt;
macro_line|#include&t;&lt;asm/atomic.h&gt;
macro_line|#include&t;&lt;asm/smp_lock.h&gt;
macro_line|#include&t;&lt;asm/spinlock.h&gt;
multiline_comment|/* If there is a different PAGE_SIZE around, and it works with this allocator,&n; * then change the following.&n; */
macro_line|#if&t;(PAGE_SIZE != 8192 &amp;&amp; PAGE_SIZE != 4096)
macro_line|#error&t;Your page size is probably not correctly supported - please check
macro_line|#endif
multiline_comment|/* SLAB_MGMT_CHECKS&t;- 1 to enable extra checks in kmem_cache_create().&n; *&t;&t;&t;  0 if you wish to reduce memory usage.&n; *&n; * SLAB_DEBUG_SUPPORT&t;- 1 for kmem_cache_create() to honour; SLAB_DEBUG_FREE,&n; *&t;&t;&t;  SLAB_DEBUG_INITIAL, SLAB_RED_ZONE &amp; SLAB_POISION.&n; *&t;&t;&t;  0 for faster, smaller, code (espically in the critical paths).&n; *&n; * SLAB_STATS&t;&t;- 1 to collect stats for /proc/slabinfo.&n; *&t;&t;&t;  0 for faster, smaller, code (espically in the critical paths).&n; *&n; * SLAB_SELFTEST&t;- 1 to perform a few tests, mainly for developement.&n; */
DECL|macro|SLAB_MGMT_CHECKS
mdefine_line|#define&t;&t;SLAB_MGMT_CHECKS&t;1
DECL|macro|SLAB_DEBUG_SUPPORT
mdefine_line|#define&t;&t;SLAB_DEBUG_SUPPORT&t;0
DECL|macro|SLAB_STATS
mdefine_line|#define&t;&t;SLAB_STATS&t;&t;0
DECL|macro|SLAB_SELFTEST
mdefine_line|#define&t;&t;SLAB_SELFTEST&t;&t;0
multiline_comment|/* Shouldn&squot;t this be in a header file somewhere? */
DECL|macro|BYTES_PER_WORD
mdefine_line|#define&t;BYTES_PER_WORD&t;&t;sizeof(void *)
multiline_comment|/* Legal flag mask for kmem_cache_create(). */
macro_line|#if&t;SLAB_DEBUG_SUPPORT
macro_line|#if&t;0
mdefine_line|#define&t;SLAB_C_MASK&t;&t;(SLAB_DEBUG_FREE|SLAB_DEBUG_INITIAL|SLAB_RED_ZONE| &bslash;&n;&t;&t;&t;&t; SLAB_POISION|SLAB_HWCACHE_ALIGN|SLAB_NO_REAP| &bslash;&n;&t;&t;&t;&t; SLAB_HIGH_PACK)
macro_line|#endif
DECL|macro|SLAB_C_MASK
mdefine_line|#define&t;SLAB_C_MASK&t;&t;(SLAB_DEBUG_FREE|SLAB_DEBUG_INITIAL|SLAB_RED_ZONE| &bslash;&n;&t;&t;&t;&t; SLAB_POISION|SLAB_HWCACHE_ALIGN|SLAB_NO_REAP)
macro_line|#else
macro_line|#if&t;0
mdefine_line|#define&t;SLAB_C_MASK&t;&t;(SLAB_HWCACHE_ALIGN|SLAB_NO_REAP|SLAB_HIGH_PACK)
macro_line|#endif
DECL|macro|SLAB_C_MASK
mdefine_line|#define&t;SLAB_C_MASK&t;&t;(SLAB_HWCACHE_ALIGN|SLAB_NO_REAP)
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
multiline_comment|/* Slab management struct.&n; * Manages the objs in a slab.  Placed either at the end of mem allocated&n; * for a slab, or from an internal obj cache (cache_slabp).&n; * Slabs are chained into a partially ordered list; fully used first, partial&n; * next, and then fully free slabs.&n; * The first 4 members are referenced during an alloc/free operation, and&n; * should always appear on the same cache line.&n; * Note: The offset between some members _must_ match offsets within&n; * the kmem_cache_t - see kmem_cache_init() for the checks. */
DECL|macro|SLAB_OFFSET_BITS
mdefine_line|#define&t;SLAB_OFFSET_BITS&t;16&t;/* could make this larger for 64bit archs */
DECL|struct|kmem_slab_s
r_typedef
r_struct
id|kmem_slab_s
(brace
DECL|member|s_freep
r_struct
id|kmem_bufctl_s
op_star
id|s_freep
suffix:semicolon
multiline_comment|/* ptr to first inactive obj in slab */
DECL|member|s_index
r_struct
id|kmem_bufctl_s
op_star
id|s_index
suffix:semicolon
DECL|member|s_magic
r_int
r_int
id|s_magic
suffix:semicolon
DECL|member|s_inuse
r_int
r_int
id|s_inuse
suffix:semicolon
multiline_comment|/* num of objs active in slab */
DECL|member|s_nextp
r_struct
id|kmem_slab_s
op_star
id|s_nextp
suffix:semicolon
DECL|member|s_prevp
r_struct
id|kmem_slab_s
op_star
id|s_prevp
suffix:semicolon
DECL|member|s_mem
r_void
op_star
id|s_mem
suffix:semicolon
multiline_comment|/* addr of first obj in slab */
DECL|member|s_offset
r_int
r_int
id|s_offset
suffix:colon
id|SLAB_OFFSET_BITS
comma
DECL|member|s_dma
id|s_dma
suffix:colon
l_int|1
suffix:semicolon
DECL|typedef|kmem_slab_t
)brace
id|kmem_slab_t
suffix:semicolon
multiline_comment|/* When the slab mgmt is on-slab, this gives the size to use. */
DECL|macro|slab_align_size
mdefine_line|#define&t;slab_align_size&t;&t;(L1_CACHE_ALIGN(sizeof(kmem_slab_t)))
multiline_comment|/* Test for end of slab chain. */
DECL|macro|kmem_slab_end
mdefine_line|#define&t;kmem_slab_end(x)&t;((kmem_slab_t*)&amp;((x)-&gt;c_offset))
multiline_comment|/* s_magic */
DECL|macro|SLAB_MAGIC_ALLOC
mdefine_line|#define&t;SLAB_MAGIC_ALLOC&t;0xA5C32F2BUL&t;/* slab is alive */
DECL|macro|SLAB_MAGIC_DESTROYED
mdefine_line|#define&t;SLAB_MAGIC_DESTROYED&t;0xB2F23C5AUL&t;/* slab has been destoryed */
multiline_comment|/* Bufctl&squot;s are used for linking objs within a slab, identifying what slab an obj&n; * is in, and the address of the associated obj (for sanity checking with off-slab&n; * bufctls).  What a bufctl contains depends upon the state of the obj and&n; * the organisation of the cache.&n; */
DECL|struct|kmem_bufctl_s
r_typedef
r_struct
id|kmem_bufctl_s
(brace
r_union
(brace
DECL|member|buf_nextp
r_struct
id|kmem_bufctl_s
op_star
id|buf_nextp
suffix:semicolon
DECL|member|buf_slabp
id|kmem_slab_t
op_star
id|buf_slabp
suffix:semicolon
multiline_comment|/* slab for obj */
DECL|member|buf_objp
r_void
op_star
id|buf_objp
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
DECL|typedef|kmem_bufctl_t
)brace
id|kmem_bufctl_t
suffix:semicolon
multiline_comment|/* ...shorthand... */
DECL|macro|buf_nextp
mdefine_line|#define&t;buf_nextp&t;u.buf_nextp
DECL|macro|buf_slabp
mdefine_line|#define&t;buf_slabp&t;u.buf_slabp
DECL|macro|buf_objp
mdefine_line|#define&t;buf_objp&t;u.buf_objp
macro_line|#if&t;SLAB_DEBUG_SUPPORT
multiline_comment|/* Magic nums for obj red zoning.&n; * Placed in the first word before and the first word after an obj.&n; */
DECL|macro|SLAB_RED_MAGIC1
mdefine_line|#define&t;SLAB_RED_MAGIC1&t;&t;0x5A2CF071UL&t;/* when obj is active */
DECL|macro|SLAB_RED_MAGIC2
mdefine_line|#define&t;SLAB_RED_MAGIC2&t;&t;0x170FC2A5UL&t;/* when obj is inactive */
multiline_comment|/* ...and for poisioning */
DECL|macro|SLAB_POISION_BYTE
mdefine_line|#define&t;SLAB_POISION_BYTE&t;0x5a&t;&t;/* byte value for poisioning */
DECL|macro|SLAB_POISION_END
mdefine_line|#define&t;SLAB_POISION_END&t;0xa5&t;&t;/* end-byte of poisioning */
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
multiline_comment|/* Cache struct - manages a cache.&n; * First four members are commonly referenced during an alloc/free operation.&n; */
DECL|struct|kmem_cache_s
r_struct
id|kmem_cache_s
(brace
DECL|member|c_freep
id|kmem_slab_t
op_star
id|c_freep
suffix:semicolon
multiline_comment|/* first slab w. free objs */
DECL|member|c_flags
r_int
r_int
id|c_flags
suffix:semicolon
multiline_comment|/* constant flags */
DECL|member|c_offset
r_int
r_int
id|c_offset
suffix:semicolon
DECL|member|c_num
r_int
r_int
id|c_num
suffix:semicolon
multiline_comment|/* # of objs per slab */
DECL|member|c_magic
r_int
r_int
id|c_magic
suffix:semicolon
DECL|member|c_inuse
r_int
r_int
id|c_inuse
suffix:semicolon
multiline_comment|/* kept at zero */
DECL|member|c_firstp
id|kmem_slab_t
op_star
id|c_firstp
suffix:semicolon
multiline_comment|/* first slab in chain */
DECL|member|c_lastp
id|kmem_slab_t
op_star
id|c_lastp
suffix:semicolon
multiline_comment|/* last slab in chain */
DECL|member|c_spinlock
id|spinlock_t
id|c_spinlock
suffix:semicolon
DECL|member|c_growing
r_int
r_int
id|c_growing
suffix:semicolon
DECL|member|c_dflags
r_int
r_int
id|c_dflags
suffix:semicolon
multiline_comment|/* dynamic flags */
DECL|member|c_org_size
r_int
id|c_org_size
suffix:semicolon
DECL|member|c_gfporder
r_int
r_int
id|c_gfporder
suffix:semicolon
multiline_comment|/* order of pgs per slab (2^n) */
DECL|member|c_ctor
r_void
(paren
op_star
id|c_ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* constructor func */
DECL|member|c_dtor
r_void
(paren
op_star
id|c_dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* de-constructor func */
DECL|member|c_align
r_int
r_int
id|c_align
suffix:semicolon
multiline_comment|/* alignment of objs */
DECL|member|c_colour
r_int
id|c_colour
suffix:semicolon
multiline_comment|/* cache colouring range */
DECL|member|c_colour_next
r_int
id|c_colour_next
suffix:semicolon
multiline_comment|/* cache colouring */
DECL|member|c_failures
r_int
r_int
id|c_failures
suffix:semicolon
DECL|member|c_name
r_const
r_char
op_star
id|c_name
suffix:semicolon
DECL|member|c_nextp
r_struct
id|kmem_cache_s
op_star
id|c_nextp
suffix:semicolon
DECL|member|c_index_cachep
id|kmem_cache_t
op_star
id|c_index_cachep
suffix:semicolon
macro_line|#if&t;SLAB_STATS
DECL|member|c_num_active
r_int
r_int
id|c_num_active
suffix:semicolon
DECL|member|c_num_allocations
r_int
r_int
id|c_num_allocations
suffix:semicolon
DECL|member|c_high_mark
r_int
r_int
id|c_high_mark
suffix:semicolon
DECL|member|c_grown
r_int
r_int
id|c_grown
suffix:semicolon
DECL|member|c_reaped
r_int
r_int
id|c_reaped
suffix:semicolon
DECL|member|c_errors
id|atomic_t
id|c_errors
suffix:semicolon
macro_line|#endif&t;/* SLAB_STATS */
)brace
suffix:semicolon
multiline_comment|/* internal c_flags */
DECL|macro|SLAB_CFLGS_OFF_SLAB
mdefine_line|#define&t;SLAB_CFLGS_OFF_SLAB&t;0x010000UL&t;/* slab mgmt in own cache */
DECL|macro|SLAB_CFLGS_BUFCTL
mdefine_line|#define&t;SLAB_CFLGS_BUFCTL&t;0x020000UL&t;/* bufctls in own cache */
DECL|macro|SLAB_CFLGS_GENERAL
mdefine_line|#define&t;SLAB_CFLGS_GENERAL&t;0x080000UL&t;/* a general-cache */
multiline_comment|/* c_dflags (dynamic flags).  Need to hold the spinlock to access this member */
DECL|macro|SLAB_CFLGS_GROWN
mdefine_line|#define&t;SLAB_CFLGS_GROWN&t;0x000002UL&t;/* don&squot;t reap a recently grown */
DECL|macro|SLAB_OFF_SLAB
mdefine_line|#define&t;SLAB_OFF_SLAB(x)&t;((x) &amp; SLAB_CFLGS_OFF_SLAB)
DECL|macro|SLAB_BUFCTL
mdefine_line|#define&t;SLAB_BUFCTL(x)&t;&t;((x) &amp; SLAB_CFLGS_BUFCTL)
DECL|macro|SLAB_GROWN
mdefine_line|#define&t;SLAB_GROWN(x)&t;&t;((x) &amp; SLAB_CFLGS_GROWN)
macro_line|#if&t;SLAB_STATS
DECL|macro|SLAB_STATS_INC_ACTIVE
mdefine_line|#define&t;SLAB_STATS_INC_ACTIVE(x)&t;((x)-&gt;c_num_active++)
DECL|macro|SLAB_STATS_DEC_ACTIVE
mdefine_line|#define&t;SLAB_STATS_DEC_ACTIVE(x)&t;((x)-&gt;c_num_active--)
DECL|macro|SLAB_STATS_INC_ALLOCED
mdefine_line|#define&t;SLAB_STATS_INC_ALLOCED(x)&t;((x)-&gt;c_num_allocations++)
DECL|macro|SLAB_STATS_INC_GROWN
mdefine_line|#define&t;SLAB_STATS_INC_GROWN(x)&t;&t;((x)-&gt;c_grown++)
DECL|macro|SLAB_STATS_INC_REAPED
mdefine_line|#define&t;SLAB_STATS_INC_REAPED(x)&t;((x)-&gt;c_reaped++)
DECL|macro|SLAB_STATS_SET_HIGH
mdefine_line|#define&t;SLAB_STATS_SET_HIGH(x)&t;&t;do { if ((x)-&gt;c_num_active &gt; (x)-&gt;c_high_mark) &bslash;&n;&t;&t;&t;&t;&t;&t;(x)-&gt;c_high_mark = (x)-&gt;c_num_active; &bslash;&n;&t;&t;&t;&t;&t;} while (0)
DECL|macro|SLAB_STATS_INC_ERR
mdefine_line|#define&t;SLAB_STATS_INC_ERR(x)&t;&t;(atomic_inc(&amp;(x)-&gt;c_errors))
macro_line|#else
DECL|macro|SLAB_STATS_INC_ACTIVE
mdefine_line|#define&t;SLAB_STATS_INC_ACTIVE(x)
DECL|macro|SLAB_STATS_DEC_ACTIVE
mdefine_line|#define&t;SLAB_STATS_DEC_ACTIVE(x)
DECL|macro|SLAB_STATS_INC_ALLOCED
mdefine_line|#define&t;SLAB_STATS_INC_ALLOCED(x)
DECL|macro|SLAB_STATS_INC_GROWN
mdefine_line|#define&t;SLAB_STATS_INC_GROWN(x)
DECL|macro|SLAB_STATS_INC_REAPED
mdefine_line|#define&t;SLAB_STATS_INC_REAPED(x)
DECL|macro|SLAB_STATS_SET_HIGH
mdefine_line|#define&t;SLAB_STATS_SET_HIGH(x)
DECL|macro|SLAB_STATS_INC_ERR
mdefine_line|#define&t;SLAB_STATS_INC_ERR(x)
macro_line|#endif&t;/* SLAB_STATS */
macro_line|#if&t;SLAB_SELFTEST
macro_line|#if&t;!SLAB_DEBUG_SUPPORT
macro_line|#error&t;Debug support needed for self-test
macro_line|#endif
r_static
r_void
id|kmem_self_test
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif&t;/* SLAB_SELFTEST */
multiline_comment|/* c_magic - used to detect &squot;out of slabs&squot; in __kmem_cache_alloc() */
DECL|macro|SLAB_C_MAGIC
mdefine_line|#define&t;SLAB_C_MAGIC&t;&t;0x4F17A36DUL
multiline_comment|/* maximum size of an obj (in 2^order pages) */
DECL|macro|SLAB_OBJ_MAX_ORDER
mdefine_line|#define&t;SLAB_OBJ_MAX_ORDER&t;5&t;/* 32 pages */
multiline_comment|/* maximum num of pages for a slab (prevents large requests to the VM layer) */
DECL|macro|SLAB_MAX_GFP_ORDER
mdefine_line|#define&t;SLAB_MAX_GFP_ORDER&t;5&t;/* 32 pages */
multiline_comment|/* the &squot;prefered&squot; minimum num of objs per slab - maybe less for large objs */
DECL|macro|SLAB_MIN_OBJS_PER_SLAB
mdefine_line|#define&t;SLAB_MIN_OBJS_PER_SLAB&t;4
multiline_comment|/* If the num of objs per slab is &lt;= SLAB_MIN_OBJS_PER_SLAB,&n; * then the page order must be less than this before trying the next order.&n; */
DECL|macro|SLAB_BREAK_GFP_ORDER
mdefine_line|#define&t;SLAB_BREAK_GFP_ORDER&t;2
multiline_comment|/* Macros for storing/retrieving the cachep and or slab from the&n; * global &squot;mem_map&squot;.  With off-slab bufctls, these are used to find the&n; * slab an obj belongs to.  With kmalloc(), and kfree(), these are used&n; * to find the cache which an obj belongs to.&n; */
DECL|macro|SLAB_SET_PAGE_CACHE
mdefine_line|#define&t;SLAB_SET_PAGE_CACHE(pg, x)&t;((pg)-&gt;next = (struct page *)(x))
DECL|macro|SLAB_GET_PAGE_CACHE
mdefine_line|#define&t;SLAB_GET_PAGE_CACHE(pg)&t;&t;((kmem_cache_t *)(pg)-&gt;next)
DECL|macro|SLAB_SET_PAGE_SLAB
mdefine_line|#define&t;SLAB_SET_PAGE_SLAB(pg, x)&t;((pg)-&gt;prev = (struct page *)(x))
DECL|macro|SLAB_GET_PAGE_SLAB
mdefine_line|#define&t;SLAB_GET_PAGE_SLAB(pg)&t;&t;((kmem_slab_t *)(pg)-&gt;prev)
multiline_comment|/* Size description struct for general-caches. */
DECL|struct|cache_sizes
r_typedef
r_struct
id|cache_sizes
(brace
DECL|member|cs_size
r_int
id|cs_size
suffix:semicolon
DECL|member|cs_cachep
id|kmem_cache_t
op_star
id|cs_cachep
suffix:semicolon
DECL|typedef|cache_sizes_t
)brace
id|cache_sizes_t
suffix:semicolon
DECL|variable|cache_sizes
r_static
id|cache_sizes_t
id|cache_sizes
(braket
)braket
op_assign
(brace
macro_line|#if&t;PAGE_SIZE == 4096
(brace
l_int|32
comma
l_int|NULL
)brace
comma
macro_line|#endif
(brace
l_int|64
comma
l_int|NULL
)brace
comma
(brace
l_int|128
comma
l_int|NULL
)brace
comma
(brace
l_int|256
comma
l_int|NULL
)brace
comma
(brace
l_int|512
comma
l_int|NULL
)brace
comma
(brace
l_int|1024
comma
l_int|NULL
)brace
comma
(brace
l_int|2048
comma
l_int|NULL
)brace
comma
(brace
l_int|4096
comma
l_int|NULL
)brace
comma
(brace
l_int|8192
comma
l_int|NULL
)brace
comma
(brace
l_int|16384
comma
l_int|NULL
)brace
comma
(brace
l_int|32768
comma
l_int|NULL
)brace
comma
(brace
l_int|65536
comma
l_int|NULL
)brace
comma
(brace
l_int|131072
comma
l_int|NULL
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* Names for the general-caches.  Not placed into the sizes struct for&n; * a good reason; the string ptr is not needed while searching in kmalloc(),&n; * and would &squot;get-in-the-way&squot; in the h/w cache.&n; */
DECL|variable|cache_sizes_name
r_static
r_char
op_star
id|cache_sizes_name
(braket
)braket
op_assign
(brace
macro_line|#if&t;PAGE_SIZE == 4096
l_string|&quot;size-32&quot;
comma
macro_line|#endif
l_string|&quot;size-64&quot;
comma
l_string|&quot;size-128&quot;
comma
l_string|&quot;size-256&quot;
comma
l_string|&quot;size-512&quot;
comma
l_string|&quot;size-1024&quot;
comma
l_string|&quot;size-2048&quot;
comma
l_string|&quot;size-4096&quot;
comma
l_string|&quot;size-8192&quot;
comma
l_string|&quot;size-16384&quot;
comma
l_string|&quot;size-32768&quot;
comma
l_string|&quot;size-65536&quot;
comma
l_string|&quot;size-131072&quot;
)brace
suffix:semicolon
multiline_comment|/* internal cache of cache description objs */
DECL|variable|cache_cache
r_static
id|kmem_cache_t
id|cache_cache
op_assign
(brace
multiline_comment|/* freep, flags */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_cache
)paren
comma
id|SLAB_NO_REAP
comma
multiline_comment|/* offset, num */
r_sizeof
(paren
id|kmem_cache_t
)paren
comma
l_int|0
comma
multiline_comment|/* c_magic, c_inuse */
id|SLAB_C_MAGIC
comma
l_int|0
comma
multiline_comment|/* firstp, lastp */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_cache
)paren
comma
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_cache
)paren
comma
multiline_comment|/* spinlock */
id|SPIN_LOCK_UNLOCKED
comma
multiline_comment|/* growing */
l_int|0
comma
multiline_comment|/* dflags */
l_int|0
comma
multiline_comment|/* org_size, gfp */
l_int|0
comma
l_int|0
comma
multiline_comment|/* ctor, dtor, align */
l_int|NULL
comma
l_int|NULL
comma
id|L1_CACHE_BYTES
comma
multiline_comment|/* colour, colour_next */
l_int|0
comma
l_int|0
comma
multiline_comment|/* failures */
l_int|0
comma
multiline_comment|/* name */
l_string|&quot;kmem_cache&quot;
comma
multiline_comment|/* nextp */
op_amp
id|cache_cache
comma
multiline_comment|/* index */
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* Guard access to the cache-chain. */
DECL|variable|cache_chain_sem
r_static
r_struct
id|semaphore
id|cache_chain_sem
suffix:semicolon
multiline_comment|/* Place maintainer for reaping. */
DECL|variable|clock_searchp
r_static
id|kmem_cache_t
op_star
id|clock_searchp
op_assign
op_amp
id|cache_cache
suffix:semicolon
multiline_comment|/* Internal slab mgmt cache, for when slab mgmt is off-slab. */
DECL|variable|cache_slabp
r_static
id|kmem_cache_t
op_star
id|cache_slabp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Max number of objs-per-slab for caches which use bufctl&squot;s.&n; * Needed to avoid a possible looping condition in kmem_cache_grow().&n; */
DECL|variable|bufctl_limit
r_static
r_int
r_int
id|bufctl_limit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialisation - setup the `cache&squot; cache. */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|kmem_cache_init
c_func
(paren
r_int
id|start
comma
r_int
id|end
)paren
)paren
(brace
r_int
id|size
comma
id|i
suffix:semicolon
DECL|macro|kmem_slab_offset
mdefine_line|#define&t;kmem_slab_offset(x)  ((unsigned long)&amp;((kmem_slab_t *)0)-&gt;x)
DECL|macro|kmem_slab_diff
mdefine_line|#define kmem_slab_diff(a,b)  (kmem_slab_offset(a) - kmem_slab_offset(b))
DECL|macro|kmem_cache_offset
mdefine_line|#define&t;kmem_cache_offset(x) ((unsigned long)&amp;((kmem_cache_t *)0)-&gt;x)
DECL|macro|kmem_cache_diff
mdefine_line|#define kmem_cache_diff(a,b) (kmem_cache_offset(a) - kmem_cache_offset(b))
multiline_comment|/* Sanity checks... */
r_if
c_cond
(paren
id|kmem_cache_diff
c_func
(paren
id|c_firstp
comma
id|c_magic
)paren
op_ne
id|kmem_slab_diff
c_func
(paren
id|s_nextp
comma
id|s_magic
)paren
op_logical_or
id|kmem_cache_diff
c_func
(paren
id|c_firstp
comma
id|c_inuse
)paren
op_ne
id|kmem_slab_diff
c_func
(paren
id|s_nextp
comma
id|s_inuse
)paren
op_logical_or
(paren
(paren
id|kmem_cache_offset
c_func
(paren
id|c_lastp
)paren
op_minus
(paren
(paren
r_int
r_int
)paren
id|kmem_slab_end
c_func
(paren
(paren
id|kmem_cache_t
op_star
)paren
l_int|NULL
)paren
)paren
)paren
op_ne
id|kmem_slab_offset
c_func
(paren
id|s_prevp
)paren
)paren
op_logical_or
id|kmem_cache_diff
c_func
(paren
id|c_lastp
comma
id|c_firstp
)paren
op_ne
id|kmem_slab_diff
c_func
(paren
id|s_prevp
comma
id|s_nextp
)paren
)paren
(brace
multiline_comment|/* Offsets to the magic are incorrect, either the structures have&n;&t;&t; * been incorrectly changed, or adjustments are needed for your&n;&t;&t; * architecture.&n;&t;&t; */
id|panic
c_func
(paren
l_string|&quot;kmem_cache_init(): Offsets are wrong - I&squot;ve been messed with!&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
DECL|macro|kmem_cache_offset
macro_line|#undef&t;kmem_cache_offset
DECL|macro|kmem_cache_diff
macro_line|#undef&t;kmem_cache_diff
DECL|macro|kmem_slab_offset
macro_line|#undef&t;kmem_slab_offset
DECL|macro|kmem_slab_diff
macro_line|#undef&t;kmem_slab_diff
id|cache_chain_sem
op_assign
id|MUTEX
suffix:semicolon
id|size
op_assign
id|cache_cache.c_offset
op_plus
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
id|size
op_add_assign
(paren
id|L1_CACHE_BYTES
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|L1_CACHE_BYTES
op_minus
l_int|1
)paren
suffix:semicolon
id|cache_cache.c_offset
op_assign
id|size
op_minus
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
id|i
op_assign
(paren
id|PAGE_SIZE
op_lshift
id|cache_cache.c_gfporder
)paren
op_minus
id|slab_align_size
suffix:semicolon
id|cache_cache.c_num
op_assign
id|i
op_div
id|size
suffix:semicolon
multiline_comment|/* num of objs per slab */
multiline_comment|/* Cache colouring. */
id|cache_cache.c_colour
op_assign
(paren
id|i
op_minus
(paren
id|cache_cache.c_num
op_star
id|size
)paren
)paren
op_div
id|L1_CACHE_BYTES
suffix:semicolon
id|cache_cache.c_colour_next
op_assign
id|cache_cache.c_colour
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
multiline_comment|/* Initialisation - setup remaining internal and general caches.&n; * Called after the gfp() functions have been enabled, and before smp_init().&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|kmem_cache_sizes_init
c_func
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|cache_slabp
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;slab_cache&quot;
comma
r_sizeof
(paren
id|kmem_slab_t
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cache_slabp
)paren
(brace
r_char
op_star
op_star
id|names
op_assign
id|cache_sizes_name
suffix:semicolon
id|cache_sizes_t
op_star
id|sizes
op_assign
id|cache_sizes
suffix:semicolon
r_do
(brace
multiline_comment|/* For performance, all the general-caches are L1 aligned.&n;&t;&t;&t; * This should be particularly beneficial on SMP boxes, as it&n;&t;&t;&t; * elimantes &quot;false sharing&quot;.&n;&t;&t;&t; * Note for systems short on memory removing the alignment will&n;&t;&t;&t; * allow tighter packing of the smaller caches. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sizes-&gt;cs_cachep
op_assign
id|kmem_cache_create
c_func
(paren
op_star
id|names
op_increment
comma
id|sizes-&gt;cs_size
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
)paren
r_goto
id|panic_time
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
multiline_comment|/* Inc off-slab bufctl limit until the ceiling is hit. */
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|sizes-&gt;cs_cachep-&gt;c_flags
)paren
)paren
id|found
op_increment
suffix:semicolon
r_else
id|bufctl_limit
op_assign
(paren
id|sizes-&gt;cs_size
op_div
r_sizeof
(paren
id|kmem_bufctl_t
)paren
)paren
suffix:semicolon
)brace
id|sizes-&gt;cs_cachep-&gt;c_flags
op_or_assign
id|SLAB_CFLGS_GENERAL
suffix:semicolon
id|sizes
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sizes-&gt;cs_size
)paren
suffix:semicolon
macro_line|#if&t;SLAB_SELFTEST
id|kmem_self_test
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;/* SLAB_SELFTEST */
r_return
suffix:semicolon
)brace
id|panic_time
suffix:colon
id|panic
c_func
(paren
l_string|&quot;kmem_cache_sizes_init: Error creating caches&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/* Interface to system&squot;s page allocator.  Dma pts to non-zero if all&n; * of memory is DMAable. No need to hold the cache-lock.&n; */
r_static
r_inline
r_void
op_star
DECL|function|kmem_getpages
id|kmem_getpages
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
comma
r_int
r_int
op_star
id|dma
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
op_star
id|dma
op_assign
id|flags
op_amp
id|SLAB_DMA
suffix:semicolon
id|addr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
comma
id|cachep-&gt;c_gfporder
comma
op_star
id|dma
)paren
suffix:semicolon
multiline_comment|/* Assume that now we have the pages no one else can legally&n;&t; * messes with the &squot;struct page&squot;s.&n;&t; * However vm_scan() might try to test the structure to see if&n;&t; * it is a named-page or buffer-page.  The members it tests are&n;&t; * of no interest here.....&n;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|dma
op_logical_and
id|addr
)paren
(brace
multiline_comment|/* Need to check if can dma. */
r_struct
id|page
op_star
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
suffix:semicolon
op_star
id|dma
op_assign
l_int|1
op_lshift
id|cachep-&gt;c_gfporder
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|dma
)paren
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageDMA
c_func
(paren
id|page
)paren
)paren
(brace
op_star
id|dma
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|page
op_increment
suffix:semicolon
)brace
)brace
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/* Interface to system&squot;s page release. */
r_static
r_inline
r_void
DECL|function|kmem_freepages
id|kmem_freepages
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
r_int
id|i
op_assign
(paren
l_int|1
op_lshift
id|cachep-&gt;c_gfporder
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
suffix:semicolon
multiline_comment|/* free_pages() does not clear the type bit - we do that.&n;&t; * The pages have been unlinked from their cache-slab,&n;&t; * but their &squot;struct page&squot;s might be accessed in&n;&t; * vm_scan(). Shouldn&squot;t be a worry.&n;&t; */
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|PageClearSlab
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|cachep-&gt;c_gfporder
)paren
suffix:semicolon
)brace
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_static
r_inline
r_void
DECL|function|kmem_poision_obj
id|kmem_poision_obj
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
id|memset
c_func
(paren
id|addr
comma
id|SLAB_POISION_BYTE
comma
id|cachep-&gt;c_org_size
)paren
suffix:semicolon
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|addr
op_plus
id|cachep-&gt;c_org_size
op_minus
l_int|1
)paren
op_assign
id|SLAB_POISION_END
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|kmem_check_poision_obj
id|kmem_check_poision_obj
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_void
op_star
id|end
suffix:semicolon
id|end
op_assign
id|memchr
c_func
(paren
id|addr
comma
id|SLAB_POISION_END
comma
id|cachep-&gt;c_org_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ne
(paren
id|addr
op_plus
id|cachep-&gt;c_org_size
op_minus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
multiline_comment|/* Three slab chain funcs - all called with ints disabled and the appropiate&n; * cache-lock held.&n; */
r_static
r_inline
r_void
DECL|function|kmem_slab_unlink
id|kmem_slab_unlink
c_func
(paren
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
id|kmem_slab_t
op_star
id|prevp
op_assign
id|slabp-&gt;s_prevp
suffix:semicolon
id|kmem_slab_t
op_star
id|nextp
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
id|prevp-&gt;s_nextp
op_assign
id|nextp
suffix:semicolon
id|nextp-&gt;s_prevp
op_assign
id|prevp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kmem_slab_link_end
id|kmem_slab_link_end
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
id|kmem_slab_t
op_star
id|lastp
op_assign
id|cachep-&gt;c_lastp
suffix:semicolon
id|slabp-&gt;s_nextp
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp-&gt;s_prevp
op_assign
id|lastp
suffix:semicolon
id|cachep-&gt;c_lastp
op_assign
id|slabp
suffix:semicolon
id|lastp-&gt;s_nextp
op_assign
id|slabp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kmem_slab_link_free
id|kmem_slab_link_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
id|kmem_slab_t
op_star
id|nextp
op_assign
id|cachep-&gt;c_freep
suffix:semicolon
id|kmem_slab_t
op_star
id|prevp
op_assign
id|nextp-&gt;s_prevp
suffix:semicolon
id|slabp-&gt;s_nextp
op_assign
id|nextp
suffix:semicolon
id|slabp-&gt;s_prevp
op_assign
id|prevp
suffix:semicolon
id|nextp-&gt;s_prevp
op_assign
id|slabp
suffix:semicolon
id|slabp-&gt;s_prevp-&gt;s_nextp
op_assign
id|slabp
suffix:semicolon
)brace
multiline_comment|/* Destroy all the objs in a slab, and release the mem back to the system.&n; * Before calling the slab must have been unlinked from the cache.&n; * The cache-lock is not held/needed.&n; */
r_static
r_void
DECL|function|kmem_slab_destroy
id|kmem_slab_destroy
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;c_dtor
macro_line|#if&t;SLAB_DEBUG_SUPPORT
op_logical_or
id|cachep-&gt;c_flags
op_amp
(paren
id|SLAB_POISION
op_logical_or
id|SLAB_RED_ZONE
)paren
macro_line|#endif&t;/*SLAB_DEBUG_SUPPORT*/
)paren
(brace
multiline_comment|/* Doesn&squot;t use the bufctl ptrs to find objs. */
r_int
r_int
id|num
op_assign
id|cachep-&gt;c_num
suffix:semicolon
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
suffix:semicolon
r_do
(brace
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_ne
id|SLAB_RED_MAGIC1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_slab_destroy: &quot;
l_string|&quot;Bad front redzone - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
)paren
op_ne
id|SLAB_RED_MAGIC1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_slab_destroy: &quot;
l_string|&quot;Bad rear redzone - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;c_dtor
)paren
macro_line|#endif&t;/*SLAB_DEBUG_SUPPORT*/
(paren
id|cachep-&gt;c_dtor
)paren
(paren
id|objp
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_else
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_POISION
)paren
(brace
r_if
c_cond
(paren
id|kmem_check_poision_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_slab_destory: &quot;
l_string|&quot;Bad poision - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|objp
op_add_assign
id|cachep-&gt;c_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;s_index
)paren
id|objp
op_add_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|num
)paren
suffix:semicolon
)brace
id|slabp-&gt;s_magic
op_assign
id|SLAB_MAGIC_DESTROYED
suffix:semicolon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|slabp-&gt;s_mem
op_minus
id|slabp-&gt;s_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;s_index
)paren
id|kmem_cache_free
c_func
(paren
id|cachep-&gt;c_index_cachep
comma
id|slabp-&gt;s_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_OFF_SLAB
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|cache_slabp
comma
id|slabp
)paren
suffix:semicolon
)brace
multiline_comment|/* Cal the num objs, wastage, and bytes left over for a given slab size. */
r_static
r_inline
r_int
DECL|function|kmem_cache_cal_waste
id|kmem_cache_cal_waste
c_func
(paren
r_int
r_int
id|gfporder
comma
r_int
id|size
comma
r_int
id|extra
comma
r_int
r_int
id|flags
comma
r_int
op_star
id|left_over
comma
r_int
r_int
op_star
id|num
)paren
(brace
r_int
id|wastage
op_assign
id|PAGE_SIZE
op_lshift
id|gfporder
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_OFF_SLAB
c_func
(paren
id|flags
)paren
)paren
id|gfporder
op_assign
l_int|0
suffix:semicolon
r_else
id|gfporder
op_assign
id|slab_align_size
suffix:semicolon
id|wastage
op_sub_assign
id|gfporder
suffix:semicolon
op_star
id|num
op_assign
id|wastage
op_div
id|size
suffix:semicolon
id|wastage
op_sub_assign
(paren
op_star
id|num
op_star
id|size
)paren
suffix:semicolon
op_star
id|left_over
op_assign
id|wastage
suffix:semicolon
r_return
(paren
id|wastage
op_plus
id|gfporder
op_plus
(paren
id|extra
op_star
op_star
id|num
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Create a cache:&n; * Returns a ptr to the cache on success, NULL on failure.&n; * Cannot be called within a int, but can be interrupted.&n; * NOTE: The &squot;name&squot; is assumed to be memory that is _not_  going to disappear.&n; */
id|kmem_cache_t
op_star
DECL|function|kmem_cache_create
id|kmem_cache_create
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|size
comma
r_int
id|offset
comma
r_int
r_int
id|flags
comma
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
comma
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
)paren
(brace
r_const
r_char
op_star
id|func_nm
op_assign
id|KERN_ERR
l_string|&quot;kmem_create: &quot;
suffix:semicolon
id|kmem_cache_t
op_star
id|searchp
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
op_assign
l_int|NULL
suffix:semicolon
r_int
id|extra
suffix:semicolon
r_int
id|left_over
suffix:semicolon
r_int
id|align
suffix:semicolon
multiline_comment|/* Sanity checks... */
macro_line|#if&t;SLAB_MGMT_CHECKS
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sNULL ptr&bslash;n&quot;
comma
id|func_nm
)paren
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sCalled during int - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OL
id|BYTES_PER_WORD
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sSize too small %d - %s&bslash;n&quot;
comma
id|func_nm
comma
(paren
r_int
)paren
id|size
comma
id|name
)paren
suffix:semicolon
id|size
op_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OG
(paren
(paren
l_int|1
op_lshift
id|SLAB_OBJ_MAX_ORDER
)paren
op_star
id|PAGE_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sSize too large %d - %s&bslash;n&quot;
comma
id|func_nm
comma
(paren
r_int
)paren
id|size
comma
id|name
)paren
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dtor
op_logical_and
op_logical_neg
id|ctor
)paren
(brace
multiline_comment|/* Decon, but no con - doesn&squot;t make sense */
id|printk
c_func
(paren
l_string|&quot;%sDecon but no con - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
template_param
id|size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sOffset weired %d - %s&bslash;n&quot;
comma
id|func_nm
comma
(paren
r_int
)paren
id|offset
comma
id|name
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
op_logical_and
op_logical_neg
id|ctor
)paren
(brace
multiline_comment|/* No constructor, but inital state check requested */
id|printk
c_func
(paren
l_string|&quot;%sNo con, but init state check requested - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_DEBUG_INITIAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_POISION
)paren
op_logical_and
id|ctor
)paren
(brace
multiline_comment|/* request for poisioning, but we can&squot;t do that with a constructor */
id|printk
c_func
(paren
l_string|&quot;%sPoisioning requested, but con given - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_POISION
suffix:semicolon
)brace
macro_line|#if&t;0
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_HIGH_PACK
)paren
op_logical_and
id|ctor
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sHigh pack requested, but con given - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_HIGH_PACK
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_HIGH_PACK
)paren
op_logical_and
(paren
id|flags
op_amp
(paren
id|SLAB_POISION
op_or
id|SLAB_RED_ZONE
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sHigh pack requested, but with poisioning/red-zoning - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_HIGH_PACK
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
macro_line|#endif&t;/* SLAB_MGMT_CHECKS */
multiline_comment|/* Always checks flags, a caller might be expecting debug&n;&t; * support which isn&squot;t available.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
id|SLAB_C_MASK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sIllgl flg %lX - %s&bslash;n&quot;
comma
id|func_nm
comma
id|flags
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
id|SLAB_C_MASK
suffix:semicolon
)brace
multiline_comment|/* Get cache&squot;s description obj. */
id|cachep
op_assign
(paren
id|kmem_cache_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_cache
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|opps
suffix:semicolon
id|memset
c_func
(paren
id|cachep
comma
l_int|0
comma
r_sizeof
(paren
id|kmem_cache_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Check that size is in terms of words.  This is needed to avoid&n;&t; * unaligned accesses for some archs when redzoning is used, and makes&n;&t; * sure any on-slab bufctl&squot;s are also correctly aligned.&n;&t; */
r_if
c_cond
(paren
id|size
op_amp
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
)paren
(brace
id|size
op_add_assign
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%sForcing size word alignment - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
)brace
id|cachep-&gt;c_org_size
op_assign
id|size
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
multiline_comment|/* There is no point trying to honour cache alignment when redzoning. */
id|flags
op_and_assign
op_complement
id|SLAB_HWCACHE_ALIGN
suffix:semicolon
id|size
op_add_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
multiline_comment|/* words for redzone */
)brace
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|align
op_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
id|align
op_assign
id|L1_CACHE_BYTES
suffix:semicolon
multiline_comment|/* Determine if the slab mgmt and/or bufclts are &squot;on&squot; or &squot;off&squot; slab. */
id|extra
op_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
(paren
id|PAGE_SIZE
op_rshift
l_int|3
)paren
)paren
(brace
multiline_comment|/* Size is small(ish).  Use packing where bufctl size per&n;&t;&t; * obj is low, and slab mngmnt is on-slab.&n;&t;&t; */
macro_line|#if&t;0
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_HIGH_PACK
)paren
)paren
(brace
multiline_comment|/* Special high packing for small objects&n;&t;&t;&t; * (mainly for vm_mapping structs, but&n;&t;&t;&t; * others can use it).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|size
op_eq
(paren
id|L1_CACHE_BYTES
op_div
l_int|4
)paren
op_logical_or
id|size
op_eq
(paren
id|L1_CACHE_BYTES
op_div
l_int|2
)paren
op_logical_or
id|size
op_eq
id|L1_CACHE_BYTES
)paren
(brace
multiline_comment|/* The bufctl is stored with the object. */
id|extra
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|flags
op_and_assign
op_complement
id|SLAB_HIGH_PACK
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* Size is large, assume best to place the slab mngmnt obj&n;&t;&t; * off-slab (should allow better packing of objs).&n;&t;&t; */
id|flags
op_or_assign
id|SLAB_CFLGS_OFF_SLAB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|size
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|size
op_eq
(paren
id|PAGE_SIZE
op_div
l_int|2
)paren
op_logical_or
id|size
op_eq
(paren
id|PAGE_SIZE
op_div
l_int|4
)paren
op_logical_or
id|size
op_eq
(paren
id|PAGE_SIZE
op_div
l_int|8
)paren
)paren
(brace
multiline_comment|/* To avoid waste the bufctls are off-slab... */
id|flags
op_or_assign
id|SLAB_CFLGS_BUFCTL
suffix:semicolon
id|extra
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* else slab mngmnt is off-slab, but freelist ptrs are on. */
)brace
id|size
op_add_assign
id|extra
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
(brace
multiline_comment|/* Need to adjust size so that objs are cache aligned. */
r_if
c_cond
(paren
id|size
OG
(paren
id|L1_CACHE_BYTES
op_div
l_int|2
)paren
)paren
(brace
r_int
id|words
op_assign
id|size
op_mod
id|L1_CACHE_BYTES
suffix:semicolon
r_if
c_cond
(paren
id|words
)paren
id|size
op_add_assign
(paren
id|L1_CACHE_BYTES
op_minus
id|words
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Small obj size, can get at least two per cache line. */
r_int
id|num_per_line
op_assign
id|L1_CACHE_BYTES
op_div
id|size
suffix:semicolon
id|left_over
op_assign
id|L1_CACHE_BYTES
op_minus
(paren
id|num_per_line
op_star
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left_over
)paren
(brace
multiline_comment|/* Need to adjust size so objs cache align. */
r_if
c_cond
(paren
id|left_over
op_mod
id|num_per_line
)paren
(brace
multiline_comment|/* Odd num of objs per line - fixup. */
id|num_per_line
op_decrement
suffix:semicolon
id|left_over
op_add_assign
id|size
suffix:semicolon
)brace
id|size
op_add_assign
(paren
id|left_over
op_div
id|num_per_line
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|size
op_mod
id|L1_CACHE_BYTES
)paren
)paren
(brace
multiline_comment|/* Size happens to cache align... */
id|flags
op_or_assign
id|SLAB_HWCACHE_ALIGN
suffix:semicolon
id|align
op_assign
id|L1_CACHE_BYTES
suffix:semicolon
)brace
multiline_comment|/* Cal size (in pages) of slabs, and the num of objs per slab.&n;&t; * This could be made much more intelligent.  For now, try to avoid&n;&t; * using high page-orders for slabs.  When the gfp() funcs are more&n;&t; * friendly towards high-order requests, this should be changed.&n;&t; */
r_do
(brace
r_int
id|wastage
suffix:semicolon
r_int
r_int
id|break_flag
op_assign
l_int|0
suffix:semicolon
id|cal_wastage
suffix:colon
id|wastage
op_assign
id|kmem_cache_cal_waste
c_func
(paren
id|cachep-&gt;c_gfporder
comma
id|size
comma
id|extra
comma
id|flags
comma
op_amp
id|left_over
comma
op_amp
id|cachep-&gt;c_num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;c_num
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|break_flag
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|flags
)paren
op_logical_and
id|cachep-&gt;c_num
OG
id|bufctl_limit
)paren
(brace
multiline_comment|/* Oops, this num of objs will cause problems. */
id|cachep-&gt;c_gfporder
op_decrement
suffix:semicolon
id|break_flag
op_increment
suffix:semicolon
r_goto
id|cal_wastage
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;c_gfporder
op_eq
id|SLAB_MAX_GFP_ORDER
)paren
r_break
suffix:semicolon
multiline_comment|/* Large num of objs is good, but v. large slabs are currently&n;&t;&t; * bad for the gfp()s.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;c_num
op_le
id|SLAB_MIN_OBJS_PER_SLAB
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;c_gfporder
OL
id|SLAB_BREAK_GFP_ORDER
)paren
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* Stop caches with small objs having a large num of pages. */
r_if
c_cond
(paren
id|left_over
op_le
id|slab_align_size
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wastage
op_star
l_int|8
)paren
op_le
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;c_gfporder
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Acceptable internal fragmentation. */
id|next
suffix:colon
id|cachep-&gt;c_gfporder
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If the slab has been placed off-slab, and we have enough space then&n;&t; * move it on-slab.  This is at the expense of any extra colouring.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_CFLGS_OFF_SLAB
)paren
op_logical_and
op_logical_neg
id|SLAB_BUFCTL
c_func
(paren
id|flags
)paren
op_logical_and
id|left_over
op_ge
id|slab_align_size
)paren
(brace
id|flags
op_and_assign
op_complement
id|SLAB_CFLGS_OFF_SLAB
suffix:semicolon
id|left_over
op_sub_assign
id|slab_align_size
suffix:semicolon
)brace
multiline_comment|/* Offset must be a factor of the alignment. */
id|offset
op_add_assign
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
id|offset
op_and_assign
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Mess around with the offset alignment. */
r_if
c_cond
(paren
op_logical_neg
id|left_over
)paren
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|left_over
OL
id|offset
)paren
(brace
id|offset
op_assign
id|align
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
(brace
r_if
c_cond
(paren
id|left_over
OL
id|offset
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Offset is BYTES_PER_WORD, and left_over is at&n;&t;&t;&t; * least BYTES_PER_WORD.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|left_over
op_ge
(paren
id|BYTES_PER_WORD
op_star
l_int|2
)paren
)paren
(brace
id|offset
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|left_over
op_ge
(paren
id|BYTES_PER_WORD
op_star
l_int|4
)paren
)paren
id|offset
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
multiline_comment|/* No offset requested, but space enough - give one. */
id|offset
op_assign
id|left_over
op_div
id|align
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
(brace
r_if
c_cond
(paren
id|offset
op_ge
l_int|8
)paren
(brace
multiline_comment|/* A large number of colours - use a larger alignment. */
id|align
op_lshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|offset
op_ge
l_int|10
)paren
(brace
id|align
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
l_int|16
)paren
id|align
op_lshift_assign
l_int|1
suffix:semicolon
)brace
)brace
id|offset
op_assign
id|align
suffix:semicolon
)brace
macro_line|#if&t;0
id|printk
c_func
(paren
l_string|&quot;%s: Left_over:%d Align:%d Size:%d&bslash;n&quot;
comma
id|name
comma
id|left_over
comma
id|offset
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|cachep-&gt;c_align
op_assign
(paren
r_int
r_int
)paren
id|offset
)paren
)paren
id|cachep-&gt;c_colour
op_assign
(paren
id|left_over
op_div
id|offset
)paren
suffix:semicolon
id|cachep-&gt;c_colour_next
op_assign
id|cachep-&gt;c_colour
suffix:semicolon
multiline_comment|/* If the bufctl&squot;s are on-slab, c_offset does not include the size of bufctl. */
r_if
c_cond
(paren
op_logical_neg
id|SLAB_BUFCTL
c_func
(paren
id|flags
)paren
)paren
id|size
op_sub_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
r_else
id|cachep-&gt;c_index_cachep
op_assign
id|kmem_find_general_cachep
c_func
(paren
id|cachep-&gt;c_num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
)paren
suffix:semicolon
id|cachep-&gt;c_offset
op_assign
(paren
r_int
r_int
)paren
id|size
suffix:semicolon
id|cachep-&gt;c_freep
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;c_firstp
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;c_lastp
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;c_flags
op_assign
id|flags
suffix:semicolon
id|cachep-&gt;c_ctor
op_assign
id|ctor
suffix:semicolon
id|cachep-&gt;c_dtor
op_assign
id|dtor
suffix:semicolon
id|cachep-&gt;c_magic
op_assign
id|SLAB_C_MAGIC
suffix:semicolon
id|cachep-&gt;c_name
op_assign
id|name
suffix:semicolon
multiline_comment|/* Simply point to the name. */
id|spin_lock_init
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
multiline_comment|/* Need the semaphore to access the chain. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|searchp
op_assign
op_amp
id|cache_cache
suffix:semicolon
r_do
(brace
multiline_comment|/* The name field is constant - no lock needed. */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|searchp-&gt;c_name
comma
id|name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sDup name - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|searchp
op_assign
id|searchp-&gt;c_nextp
suffix:semicolon
)brace
r_while
c_loop
(paren
id|searchp
op_ne
op_amp
id|cache_cache
)paren
suffix:semicolon
multiline_comment|/* There is no reason to lock our new cache before we&n;&t; * link it in - no one knows about it yet...&n;&t; */
id|cachep-&gt;c_nextp
op_assign
id|cache_cache.c_nextp
suffix:semicolon
id|cache_cache.c_nextp
op_assign
id|cachep
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|opps
suffix:colon
r_return
id|cachep
suffix:semicolon
)brace
multiline_comment|/* Shrink a cache.  Releases as many slabs as possible for a cache.&n; * It is expected this function will be called by a module when it is&n; * unloaded.  The cache is _not_ removed, this creates too many problems and&n; * the cache-structure does not take up much room.  A module should keep its&n; * cache pointer(s) in unloaded memory, so when reloaded it knows the cache&n; * is available.  To help debugging, a zero exit status indicates all slabs&n; * were released.&n; */
r_int
DECL|function|kmem_cache_shrink
id|kmem_cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|kmem_cache_t
op_star
id|searchp
suffix:semicolon
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_shrink: NULL ptr&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_shrink: Called during int - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
multiline_comment|/* Semaphore is needed. */
id|searchp
op_assign
op_amp
id|cache_cache
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|searchp-&gt;c_nextp
op_ne
op_amp
id|cache_cache
suffix:semicolon
id|searchp
op_assign
id|searchp-&gt;c_nextp
)paren
(brace
r_if
c_cond
(paren
id|searchp-&gt;c_nextp
op_ne
id|cachep
)paren
r_continue
suffix:semicolon
multiline_comment|/* Accessing clock_searchp is safe - we hold the mutex. */
r_if
c_cond
(paren
id|cachep
op_eq
id|clock_searchp
)paren
id|clock_searchp
op_assign
id|cachep-&gt;c_nextp
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_shrink: Invalid cache addr %p&bslash;n&quot;
comma
id|cachep
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
id|found
suffix:colon
multiline_comment|/* Relase the sempahore before getting the cache-lock.  This could&n;&t; * mean multiple engines are shrinking the cache, but so what...&n;&t; */
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
multiline_comment|/* If the cache is growing, stop shrinking. */
r_while
c_loop
(paren
op_logical_neg
id|cachep-&gt;c_growing
)paren
(brace
id|slabp
op_assign
id|cachep-&gt;c_lastp
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;s_inuse
op_logical_or
id|slabp
op_eq
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
r_break
suffix:semicolon
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
id|kmem_slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_lastp
op_eq
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
id|ret
op_decrement
suffix:semicolon
multiline_comment|/* Cache is empty. */
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Get the mem for a slab mgmt obj. */
r_static
r_inline
id|kmem_slab_t
op_star
DECL|function|kmem_cache_slabmgmt
id|kmem_cache_slabmgmt
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
comma
r_int
id|local_flags
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_OFF_SLAB
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
multiline_comment|/* Slab mgmt obj is off-slab. */
id|slabp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|cache_slabp
comma
id|local_flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Slab mgmnt at end of slab mem, placed so that&n;&t;&t; * the position is &squot;coloured&squot;.&n;&t;&t; */
r_void
op_star
id|end
suffix:semicolon
id|end
op_assign
id|objp
op_plus
(paren
id|cachep-&gt;c_num
op_star
id|cachep-&gt;c_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|end
op_add_assign
(paren
id|cachep-&gt;c_num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
)paren
suffix:semicolon
id|slabp
op_assign
(paren
id|kmem_slab_t
op_star
)paren
id|L1_CACHE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|end
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slabp
)paren
(brace
id|slabp-&gt;s_inuse
op_assign
l_int|0
suffix:semicolon
id|slabp-&gt;s_dma
op_assign
l_int|0
suffix:semicolon
id|slabp-&gt;s_index
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|slabp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kmem_cache_init_objs
id|kmem_cache_init_objs
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
comma
r_void
op_star
id|objp
comma
r_int
r_int
id|ctor_flags
)paren
(brace
id|kmem_bufctl_t
op_star
op_star
id|bufpp
op_assign
op_amp
id|slabp-&gt;s_freep
suffix:semicolon
r_int
r_int
id|num
op_assign
id|cachep-&gt;c_num
op_minus
l_int|1
suffix:semicolon
r_do
(brace
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_assign
id|SLAB_RED_MAGIC1
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
)paren
op_assign
id|SLAB_RED_MAGIC1
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
multiline_comment|/* Constructors are not allowed to allocate memory from the same cache&n;&t;&t; * which they are a constructor for.  Otherwise, deadlock.&n;&t;&t; * They must also be threaded.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;c_ctor
)paren
id|cachep
op_member_access_from_pointer
id|c_ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_else
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_POISION
)paren
(brace
multiline_comment|/* need to poision the objs */
id|kmem_poision_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
)paren
op_ne
id|SLAB_RED_MAGIC1
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
)paren
op_assign
id|SLAB_RED_MAGIC1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_init_obj: Bad rear redzone &quot;
l_string|&quot;after constructor - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
)brace
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_ne
id|SLAB_RED_MAGIC1
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_assign
id|SLAB_RED_MAGIC1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_init_obj: Bad front redzone &quot;
l_string|&quot;after constructor - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|objp
op_add_assign
id|cachep-&gt;c_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;s_index
)paren
(brace
op_star
id|bufpp
op_assign
id|objp
suffix:semicolon
id|objp
op_add_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
)brace
r_else
op_star
id|bufpp
op_assign
op_amp
id|slabp-&gt;s_index
(braket
id|num
)braket
suffix:semicolon
id|bufpp
op_assign
op_amp
(paren
op_star
id|bufpp
)paren
op_member_access_from_pointer
id|buf_nextp
suffix:semicolon
)brace
r_while
c_loop
(paren
id|num
op_decrement
)paren
suffix:semicolon
op_star
id|bufpp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Grow (by 1) the number of slabs within a cache.  This is called by&n; * kmem_cache_alloc() when there are no active objs left in a cache.&n; */
r_static
r_int
DECL|function|kmem_cache_grow
id|kmem_cache_grow
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
r_int
id|dma
comma
id|local_flags
suffix:semicolon
r_int
r_int
id|ctor_flags
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
multiline_comment|/* Be lazy and only check for valid flags here,&n; &t; * keeping it out of the critical path in kmem_cache_alloc().&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|SLAB_DMA
op_or
id|SLAB_LEVEL_MASK
op_or
id|SLAB_NO_GROW
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;kmem_grow: Illegal flgs %X (correcting) - %s&bslash;n&quot;
comma
id|flags
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
id|flags
op_and_assign
(paren
id|SLAB_DMA
op_or
id|SLAB_LEVEL_MASK
op_or
id|SLAB_NO_GROW
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_NO_GROW
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* The test for missing atomic flag is performed here, rather than&n;&t; * the more obvious place, simply to reduce the critical path length&n;&t; * in kmem_cache_alloc().  If a caller is slightly mis-behaving they&n;&t; * will eventually be caught here (where it matters).&n;&t; */
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_and
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
op_ne
id|SLAB_ATOMIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_grow: Called nonatomically from int - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_LEVEL_MASK
suffix:semicolon
id|flags
op_or_assign
id|SLAB_ATOMIC
suffix:semicolon
)brace
id|ctor_flags
op_assign
id|SLAB_CTOR_CONSTRUCTOR
suffix:semicolon
id|local_flags
op_assign
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_flags
op_eq
id|SLAB_ATOMIC
)paren
(brace
multiline_comment|/* Not allowed to sleep.  Need to tell a constructor about&n;&t;&t; * this - it might need to know...&n;&t;&t; */
id|ctor_flags
op_or_assign
id|SLAB_CTOR_ATOMIC
suffix:semicolon
)brace
multiline_comment|/* About to mess with non-constant members - lock. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
multiline_comment|/* Get colour for the slab, and cal the next value. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|offset
op_assign
id|cachep-&gt;c_colour_next
op_decrement
)paren
)paren
id|cachep-&gt;c_colour_next
op_assign
id|cachep-&gt;c_colour
suffix:semicolon
id|offset
op_mul_assign
id|cachep-&gt;c_align
suffix:semicolon
id|cachep-&gt;c_dflags
op_assign
id|SLAB_CFLGS_GROWN
suffix:semicolon
id|cachep-&gt;c_growing
op_increment
suffix:semicolon
id|re_try
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
multiline_comment|/* A series of memory allocations for a new slab.&n;&t; * Neither the cache-chain semaphore, or cache-lock, are&n;&t; * held, but the incrementing c_growing prevents this&n;&t; * this cache from being reaped or shrunk.&n;&t; * Note: The cache could be selected in for reaping in&n;&t; * kmem_cache_reap(), but when the final test is made the&n;&t; * growing value will be seen.&n;&t; */
multiline_comment|/* Get mem for the objs. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|objp
op_assign
id|kmem_getpages
c_func
(paren
id|cachep
comma
id|flags
comma
op_amp
id|dma
)paren
)paren
)paren
r_goto
id|failed
suffix:semicolon
multiline_comment|/* Get slab mgmt. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp
op_assign
id|kmem_cache_slabmgmt
c_func
(paren
id|cachep
comma
id|objp
op_plus
id|offset
comma
id|local_flags
)paren
)paren
)paren
r_goto
id|opps1
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
id|slabp-&gt;s_dma
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
id|slabp-&gt;s_index
op_assign
id|kmem_cache_alloc
c_func
(paren
id|cachep-&gt;c_index_cachep
comma
id|local_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;s_index
)paren
r_goto
id|opps2
suffix:semicolon
)brace
multiline_comment|/* Nasty!!!!!!  I hope this is OK. */
id|dma
op_assign
l_int|1
op_lshift
id|cachep-&gt;c_gfporder
suffix:semicolon
id|page
op_assign
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|objp
)paren
)braket
suffix:semicolon
r_do
(brace
id|SLAB_SET_PAGE_CACHE
c_func
(paren
id|page
comma
id|cachep
)paren
suffix:semicolon
id|SLAB_SET_PAGE_SLAB
c_func
(paren
id|page
comma
id|slabp
)paren
suffix:semicolon
id|PageSetSlab
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|dma
)paren
suffix:semicolon
id|slabp-&gt;s_offset
op_assign
id|offset
suffix:semicolon
multiline_comment|/* It will fit... */
id|objp
op_add_assign
id|offset
suffix:semicolon
multiline_comment|/* Address of first object. */
id|slabp-&gt;s_mem
op_assign
id|objp
suffix:semicolon
multiline_comment|/* For on-slab bufctls, c_offset is the distance between the start of&n;&t; * an obj and its related bufctl.  For off-slab bufctls, c_offset is&n;&t; * the distance between objs in the slab.&n;&t; */
id|kmem_cache_init_objs
c_func
(paren
id|cachep
comma
id|slabp
comma
id|objp
comma
id|ctor_flags
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
multiline_comment|/* Make slab active. */
id|slabp-&gt;s_magic
op_assign
id|SLAB_MAGIC_ALLOC
suffix:semicolon
id|kmem_slab_link_end
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_freep
op_eq
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
id|cachep-&gt;c_freep
op_assign
id|slabp
suffix:semicolon
id|SLAB_STATS_INC_GROWN
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;c_failures
op_assign
l_int|0
suffix:semicolon
id|cachep-&gt;c_growing
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|opps2
suffix:colon
r_if
c_cond
(paren
id|SLAB_OFF_SLAB
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|cache_slabp
comma
id|slabp
)paren
suffix:semicolon
id|opps1
suffix:colon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|failed
suffix:colon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_flags
op_ne
id|SLAB_ATOMIC
op_logical_and
id|cachep-&gt;c_gfporder
)paren
(brace
multiline_comment|/* For large order (&gt;0) slabs, we try again.&n;&t;&t; * Needed because the gfp() functions are not good at giving&n;&t;&t; * out contigious pages unless pushed (but do not push too hard).&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;c_failures
op_increment
OL
l_int|4
op_logical_and
id|cachep-&gt;c_freep
op_eq
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
r_goto
id|re_try
suffix:semicolon
id|cachep-&gt;c_failures
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Memory is low, don&squot;t try as hard next time. */
)brace
id|cachep-&gt;c_growing
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|kmem_report_alloc_err
id|kmem_report_alloc_err
c_func
(paren
r_const
r_char
op_star
id|str
comma
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_if
c_cond
(paren
id|cachep
)paren
id|SLAB_STATS_INC_ERR
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* this is atomic */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_alloc: %s (name=%s)&bslash;n&quot;
comma
id|str
comma
id|cachep
ques
c_cond
id|cachep-&gt;c_name
suffix:colon
l_string|&quot;unknown&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|kmem_report_free_err
id|kmem_report_free_err
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_void
op_star
id|objp
comma
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_if
c_cond
(paren
id|cachep
)paren
id|SLAB_STATS_INC_ERR
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: %s (objp=%p, name=%s)&bslash;n&quot;
comma
id|str
comma
id|objp
comma
id|cachep
ques
c_cond
id|cachep-&gt;c_name
suffix:colon
l_string|&quot;unknown&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Search for a slab whose objs are suitable for DMA.&n; * Note: since testing the first free slab (in __kmem_cache_alloc()),&n; * ints must not have been enabled, or the cache-lock released!&n; */
r_static
r_inline
id|kmem_slab_t
op_star
DECL|function|kmem_cache_search_dma
id|kmem_cache_search_dma
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
op_assign
id|cachep-&gt;c_freep-&gt;s_nextp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp
op_assign
id|slabp-&gt;s_nextp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp-&gt;s_dma
)paren
)paren
r_continue
suffix:semicolon
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|kmem_slab_link_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|cachep-&gt;c_freep
op_assign
id|slabp
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|slabp
suffix:semicolon
)brace
macro_line|#if&t;SLAB_DEBUG_SUPPORT
multiline_comment|/* Perform extra freeing checks.  Currently, this check is only for caches&n; * that use bufctl structures within the slab.  Those which use bufctl&squot;s&n; * from the internal cache have a reasonable check when the address is&n; * searched for.  Called with the cache-lock held.&n; */
r_static
r_void
op_star
DECL|function|kmem_extra_free_checks
id|kmem_extra_free_checks
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_bufctl_t
op_star
id|search_bufp
comma
id|kmem_bufctl_t
op_star
id|bufp
comma
r_void
op_star
id|objp
)paren
(brace
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
r_return
id|objp
suffix:semicolon
multiline_comment|/* Check slab&squot;s freelist to see if this obj is there. */
r_for
c_loop
(paren
suffix:semicolon
id|search_bufp
suffix:semicolon
id|search_bufp
op_assign
id|search_bufp-&gt;buf_nextp
)paren
(brace
r_if
c_cond
(paren
id|search_bufp
op_ne
id|bufp
)paren
r_continue
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|objp
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
multiline_comment|/* Called with cache lock held. */
r_static
r_inline
r_void
DECL|function|kmem_cache_full_free
id|kmem_cache_full_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
r_if
c_cond
(paren
id|slabp-&gt;s_nextp-&gt;s_inuse
)paren
(brace
multiline_comment|/* Not at correct position. */
r_if
c_cond
(paren
id|cachep-&gt;c_freep
op_eq
id|slabp
)paren
id|cachep-&gt;c_freep
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|kmem_slab_link_end
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Called with cache lock held. */
r_static
r_inline
r_void
DECL|function|kmem_cache_one_free
id|kmem_cache_one_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
r_if
c_cond
(paren
id|slabp-&gt;s_nextp-&gt;s_inuse
op_eq
id|cachep-&gt;c_num
)paren
(brace
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|kmem_slab_link_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
)brace
id|cachep-&gt;c_freep
op_assign
id|slabp
suffix:semicolon
)brace
multiline_comment|/* Returns a ptr to an obj in the given cache. */
r_static
r_inline
r_void
op_star
DECL|function|__kmem_cache_alloc
id|__kmem_cache_alloc
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
id|kmem_bufctl_t
op_star
id|bufp
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
multiline_comment|/* Sanity check. */
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|nul_ptr
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|try_again
suffix:colon
multiline_comment|/* Get slab alloc is to come from. */
id|slabp
op_assign
id|cachep-&gt;c_freep
suffix:semicolon
multiline_comment|/* Magic is a sanity check _and_ says if we need a new slab. */
r_if
c_cond
(paren
id|slabp-&gt;s_magic
op_ne
id|SLAB_MAGIC_ALLOC
)paren
r_goto
id|alloc_new_slab
suffix:semicolon
multiline_comment|/* DMA requests are &squot;rare&squot; - keep out of the critical path. */
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_DMA
)paren
r_goto
id|search_dma
suffix:semicolon
id|try_again_dma
suffix:colon
id|SLAB_STATS_INC_ALLOCED
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|SLAB_STATS_INC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|SLAB_STATS_SET_HIGH
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp-&gt;s_inuse
op_increment
suffix:semicolon
id|bufp
op_assign
id|slabp-&gt;s_freep
suffix:semicolon
id|slabp-&gt;s_freep
op_assign
id|bufp-&gt;buf_nextp
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;s_freep
)paren
(brace
id|ret_obj
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;s_index
)paren
(brace
id|bufp-&gt;buf_slabp
op_assign
id|slabp
suffix:semicolon
id|objp
op_assign
(paren
(paren
r_void
op_star
)paren
id|bufp
)paren
op_minus
id|cachep-&gt;c_offset
suffix:semicolon
id|finished
suffix:colon
multiline_comment|/* The lock is not needed by the red-zone or poision ops, and the&n;&t;&t;&t; * obj has been removed from the slab.  Should be safe to drop&n;&t;&t;&t; * the lock here.&n;&t;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
r_goto
id|red_zone
suffix:semicolon
id|ret_red
suffix:colon
r_if
c_cond
(paren
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_POISION
)paren
op_logical_and
id|kmem_check_poision_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
id|kmem_report_alloc_err
c_func
(paren
l_string|&quot;Bad poision&quot;
comma
id|cachep
)paren
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
r_return
id|objp
suffix:semicolon
)brace
multiline_comment|/* Update index ptr. */
id|objp
op_assign
(paren
(paren
id|bufp
op_minus
id|slabp-&gt;s_index
)paren
op_star
id|cachep-&gt;c_offset
)paren
op_plus
id|slabp-&gt;s_mem
suffix:semicolon
id|bufp-&gt;buf_objp
op_assign
id|objp
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
id|cachep-&gt;c_freep
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
r_goto
id|ret_obj
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
id|red_zone
suffix:colon
multiline_comment|/* Set alloc red-zone, and check old one. */
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|objp
comma
id|SLAB_RED_MAGIC2
)paren
op_ne
id|SLAB_RED_MAGIC1
)paren
id|kmem_report_alloc_err
c_func
(paren
l_string|&quot;Bad front redzone&quot;
comma
id|cachep
)paren
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
comma
id|SLAB_RED_MAGIC2
)paren
op_ne
id|SLAB_RED_MAGIC1
)paren
id|kmem_report_alloc_err
c_func
(paren
l_string|&quot;Bad rear redzone&quot;
comma
id|cachep
)paren
suffix:semicolon
r_goto
id|ret_red
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|search_dma
suffix:colon
r_if
c_cond
(paren
id|slabp-&gt;s_dma
op_logical_or
(paren
id|slabp
op_assign
id|kmem_cache_search_dma
c_func
(paren
id|cachep
)paren
)paren
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
r_goto
id|try_again_dma
suffix:semicolon
id|alloc_new_slab
suffix:colon
multiline_comment|/* Either out of slabs, or magic number corruption. */
r_if
c_cond
(paren
id|slabp
op_eq
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
(brace
multiline_comment|/* Need a new slab.  Release the lock before calling kmem_cache_grow().&n;&t;&t; * This allows objs to be released back into the cache while growing.&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_grow
c_func
(paren
id|cachep
comma
id|flags
)paren
)paren
(brace
multiline_comment|/* Someone may have stolen our objs.  Doesn&squot;t matter, we&squot;ll&n;&t;&t;&t; * just come back here again.&n;&t;&t;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
multiline_comment|/* Couldn&squot;t grow, but some objs may have been freed. */
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_freep
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
r_goto
id|try_again
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Very serious error - maybe panic() here? */
id|kmem_report_alloc_err
c_func
(paren
l_string|&quot;Bad slab magic (corrupt)&quot;
comma
id|cachep
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|err_exit
suffix:colon
r_return
l_int|NULL
suffix:semicolon
id|nul_ptr
suffix:colon
id|kmem_report_alloc_err
c_func
(paren
l_string|&quot;NULL ptr&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_goto
id|err_exit
suffix:semicolon
)brace
multiline_comment|/* Release an obj back to its cache.  If the obj has a constructed state,&n; * it should be in this state _before_ it is released.&n; */
r_static
r_inline
r_void
DECL|function|__kmem_cache_free
id|__kmem_cache_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
id|kmem_bufctl_t
op_star
id|bufp
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
multiline_comment|/* Basic sanity checks. */
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_or
op_logical_neg
id|objp
)paren
r_goto
id|null_addr
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
multiline_comment|/* A verify func is called without the cache-lock held. */
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
r_goto
id|init_state_check
suffix:semicolon
id|finished_initial
suffix:colon
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
r_goto
id|red_zone
suffix:semicolon
id|return_red
suffix:colon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
r_goto
id|bufctl
suffix:semicolon
id|bufp
op_assign
(paren
id|kmem_bufctl_t
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_offset
)paren
suffix:semicolon
multiline_comment|/* Get slab for the object. */
macro_line|#if&t;0
multiline_comment|/* _NASTY_IF/ELSE_, but avoids a &squot;distant&squot; memory ref for some objects.&n;&t; * Is this worth while? XXX&n;&t; */
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_HIGH_PACK
)paren
id|slabp
op_assign
id|SLAB_GET_PAGE_SLAB
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|bufp
)paren
)braket
)paren
suffix:semicolon
r_else
macro_line|#endif
id|slabp
op_assign
id|bufp-&gt;buf_slabp
suffix:semicolon
id|check_magic
suffix:colon
r_if
c_cond
(paren
id|slabp-&gt;s_magic
op_ne
id|SLAB_MAGIC_ALLOC
)paren
multiline_comment|/* Sanity check. */
r_goto
id|bad_slab
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_DEBUG_FREE
)paren
r_goto
id|extra_checks
suffix:semicolon
id|passed_extra
suffix:colon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
r_if
c_cond
(paren
id|slabp-&gt;s_inuse
)paren
(brace
multiline_comment|/* Sanity check. */
id|SLAB_STATS_DEC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp-&gt;s_inuse
op_decrement
suffix:semicolon
id|bufp-&gt;buf_nextp
op_assign
id|slabp-&gt;s_freep
suffix:semicolon
id|slabp-&gt;s_freep
op_assign
id|bufp
suffix:semicolon
r_if
c_cond
(paren
id|bufp-&gt;buf_nextp
)paren
(brace
r_if
c_cond
(paren
id|slabp-&gt;s_inuse
)paren
(brace
multiline_comment|/* (hopefully) The most common case. */
id|finished
suffix:colon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_POISION
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
id|kmem_poision_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kmem_cache_full_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
id|kmem_cache_one_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t add to freelist. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|kmem_report_free_err
c_func
(paren
l_string|&quot;free with no active objs&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
r_return
suffix:semicolon
id|bufctl
suffix:colon
multiline_comment|/* No &squot;extra&squot; checks are performed for objs stored this way, finding&n;&t; * the obj is check enough.&n;&t; */
id|slabp
op_assign
id|SLAB_GET_PAGE_SLAB
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|objp
)paren
)braket
)paren
suffix:semicolon
id|bufp
op_assign
op_amp
id|slabp-&gt;s_index
(braket
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;c_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bufp-&gt;buf_objp
op_eq
id|objp
)paren
r_goto
id|check_magic
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|kmem_report_free_err
c_func
(paren
l_string|&quot;Either bad obj addr or double free&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if&t;SLAB_DEBUG_SUPPORT
id|init_state_check
suffix:colon
multiline_comment|/* Need to call the slab&squot;s constructor so the&n;&t; * caller can perform a verify of its state (debugging).&n;&t; */
id|cachep
op_member_access_from_pointer
id|c_ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|SLAB_CTOR_CONSTRUCTOR
op_or
id|SLAB_CTOR_VERIFY
)paren
suffix:semicolon
r_goto
id|finished_initial
suffix:semicolon
id|extra_checks
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|kmem_extra_free_checks
c_func
(paren
id|cachep
comma
id|slabp-&gt;s_freep
comma
id|bufp
comma
id|objp
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|kmem_report_free_err
c_func
(paren
l_string|&quot;Double free detected during checks&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_goto
id|passed_extra
suffix:semicolon
id|red_zone
suffix:colon
multiline_comment|/* We do not hold the cache-lock while checking the red-zone.&n;&t; */
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|objp
comma
id|SLAB_RED_MAGIC1
)paren
op_ne
id|SLAB_RED_MAGIC2
)paren
(brace
multiline_comment|/* Either write before start of obj, or a double free. */
id|kmem_report_free_err
c_func
(paren
l_string|&quot;Bad front redzone&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
op_plus
id|BYTES_PER_WORD
)paren
comma
id|SLAB_RED_MAGIC1
)paren
op_ne
id|SLAB_RED_MAGIC2
)paren
(brace
multiline_comment|/* Either write past end of obj, or a double free. */
id|kmem_report_free_err
c_func
(paren
l_string|&quot;Bad rear redzone&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
)brace
r_goto
id|return_red
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|bad_slab
suffix:colon
multiline_comment|/* Slab doesn&squot;t contain the correct magic num. */
r_if
c_cond
(paren
id|slabp-&gt;s_magic
op_eq
id|SLAB_MAGIC_DESTROYED
)paren
(brace
multiline_comment|/* Magic num says this is a destroyed slab. */
id|kmem_report_free_err
c_func
(paren
l_string|&quot;free from inactive slab&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
)brace
r_else
id|kmem_report_free_err
c_func
(paren
l_string|&quot;Bad obj addr&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|null_addr
suffix:colon
id|kmem_report_free_err
c_func
(paren
l_string|&quot;NULL ptr&quot;
comma
id|objp
comma
id|cachep
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
op_star
DECL|function|kmem_cache_alloc
id|kmem_cache_alloc
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_return
id|__kmem_cache_alloc
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|kmem_cache_free
id|kmem_cache_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|__kmem_cache_free
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|kmalloc
id|kmalloc
c_func
(paren
r_int
id|size
comma
r_int
id|flags
)paren
(brace
id|cache_sizes_t
op_star
id|csizep
op_assign
id|cache_sizes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
r_return
id|__kmem_cache_alloc
c_func
(paren
id|csizep-&gt;cs_cachep
comma
id|flags
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmalloc: Size (%lu) too large&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|size
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|kfree
id|kfree
c_func
(paren
r_void
op_star
id|objp
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_goto
id|null_ptr
suffix:semicolon
id|nr
op_assign
id|MAP_NR
c_func
(paren
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|max_mapnr
)paren
r_goto
id|null_ptr
suffix:semicolon
multiline_comment|/* Assume we own the page structure - hence no locking.&n;&t; * If someone is misbehaving (eg. someone calling us with a bad&n;&t; * address), then access to the page structure can race with the&n;&t; * kmem_slab_destory() code.  Need to add a spin_lock to each page&n;&t; * structure, which would be useful in threading the gfp() functions....&n;&t; */
id|page
op_assign
op_amp
id|mem_map
(braket
id|nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PageSlab
c_func
(paren
id|page
)paren
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
multiline_comment|/* Here, we (again) assume the obj address is good.&n;&t;&t; * If it isn&squot;t, and happens to map onto another&n;&t;&t; * general-cache page which has no active objs, then&n;&t;&t; * we race....&n;&t;&t; */
id|cachep
op_assign
id|SLAB_GET_PAGE_CACHE
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep
op_logical_and
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_CFLGS_GENERAL
)paren
)paren
(brace
id|__kmem_cache_free
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|null_ptr
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kfree: Bad obj %p&bslash;n&quot;
comma
id|objp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|kfree_s
id|kfree_s
c_func
(paren
r_void
op_star
id|objp
comma
r_int
id|size
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_goto
id|null_ptr
suffix:semicolon
id|nr
op_assign
id|MAP_NR
c_func
(paren
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|max_mapnr
)paren
r_goto
id|null_ptr
suffix:semicolon
multiline_comment|/* See comment in kfree() */
id|page
op_assign
op_amp
id|mem_map
(braket
id|nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PageSlab
c_func
(paren
id|page
)paren
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
multiline_comment|/* See comment in kfree() */
id|cachep
op_assign
id|SLAB_GET_PAGE_CACHE
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep
op_logical_and
id|cachep-&gt;c_flags
op_amp
id|SLAB_CFLGS_GENERAL
)paren
(brace
r_if
c_cond
(paren
id|size
op_le
id|cachep-&gt;c_org_size
)paren
(brace
multiline_comment|/* XXX better check */
id|__kmem_cache_free
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|null_ptr
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kfree_s: Bad obj %p&bslash;n&quot;
comma
id|objp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kmem_cache_t
op_star
DECL|function|kmem_find_general_cachep
id|kmem_find_general_cachep
c_func
(paren
r_int
id|size
)paren
(brace
id|cache_sizes_t
op_star
id|csizep
op_assign
id|cache_sizes
suffix:semicolon
multiline_comment|/* This function could be moved to the header-file, and&n;&t; * made inline so consumers can quickly determine what&n;&t; * cache-ptr they require.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|csizep-&gt;cs_cachep
suffix:semicolon
)brace
multiline_comment|/* Called from try_to_free_page().&n; * This function _cannot_ be called within a int, but it&n; * can be interrupted.&n; */
r_int
DECL|function|kmem_cache_reap
id|kmem_cache_reap
c_func
(paren
r_int
id|pri
comma
r_int
id|dma
comma
r_int
id|wait
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
id|kmem_cache_t
op_star
id|searchp
suffix:semicolon
id|kmem_cache_t
op_star
id|best_cachep
suffix:semicolon
r_int
r_int
id|scan
suffix:semicolon
r_int
r_int
id|reap_level
suffix:semicolon
r_static
r_int
r_int
id|call_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmem_cache_reap() called within int!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We really need a test semphore op so we can avoid sleeping when&n;&t; * !wait is true.&n;&t; */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|scan
op_assign
l_int|10
op_minus
id|pri
suffix:semicolon
r_if
c_cond
(paren
id|pri
op_eq
l_int|6
op_logical_and
op_logical_neg
id|dma
)paren
(brace
r_if
c_cond
(paren
op_increment
id|call_count
op_eq
l_int|199
)paren
(brace
multiline_comment|/* Hack Alert!&n;&t;&t;&t; * Occassionally we try hard to reap a slab.&n;&t;&t;&t; */
id|call_count
op_assign
l_int|0UL
suffix:semicolon
id|reap_level
op_assign
l_int|0
suffix:semicolon
id|scan
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
id|reap_level
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pri
op_ge
l_int|5
)paren
(brace
multiline_comment|/* We also come here for dma==1 at pri==6, just&n;&t;&t;&t; * to try that bit harder (assumes that there are&n;&t;&t;&t; * less DMAable pages in a system - not always true,&n;&t;&t;&t; * but this doesn&squot;t hurt).&n;&t;&t;&t; */
id|reap_level
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|reap_level
op_assign
l_int|0
suffix:semicolon
)brace
id|best_cachep
op_assign
l_int|NULL
suffix:semicolon
id|searchp
op_assign
id|clock_searchp
suffix:semicolon
r_do
(brace
r_int
r_int
id|full_free
suffix:semicolon
r_int
r_int
id|dma_flag
suffix:semicolon
multiline_comment|/* It&squot;s safe to test this without holding the cache-lock. */
r_if
c_cond
(paren
id|searchp-&gt;c_flags
op_amp
id|SLAB_NO_REAP
)paren
r_goto
id|next
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|searchp-&gt;c_spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;c_growing
)paren
r_goto
id|next_unlock
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;c_dflags
op_amp
id|SLAB_CFLGS_GROWN
)paren
(brace
id|searchp-&gt;c_dflags
op_and_assign
op_complement
id|SLAB_CFLGS_GROWN
suffix:semicolon
r_goto
id|next_unlock
suffix:semicolon
)brace
multiline_comment|/* Sanity check for corruption of static values. */
r_if
c_cond
(paren
id|searchp-&gt;c_inuse
op_logical_or
id|searchp-&gt;c_magic
op_ne
id|SLAB_C_MAGIC
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|searchp-&gt;c_spinlock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_reap: Corrupted cache struct for %s&bslash;n&quot;
comma
id|searchp-&gt;c_name
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
id|dma_flag
op_assign
l_int|0
suffix:semicolon
id|full_free
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Count num of fully free slabs.  Hopefully there are not many,&n;&t;&t; * we are holding the cache lock....&n;&t;&t; */
id|slabp
op_assign
id|searchp-&gt;c_lastp
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|slabp-&gt;s_inuse
op_logical_and
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|searchp
)paren
)paren
(brace
id|slabp
op_assign
id|slabp-&gt;s_prevp
suffix:semicolon
id|full_free
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;s_dma
)paren
id|dma_flag
op_increment
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|searchp-&gt;c_spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_logical_and
op_logical_neg
id|dma_flag
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|full_free
)paren
(brace
r_if
c_cond
(paren
id|full_free
op_ge
l_int|10
)paren
(brace
id|best_cachep
op_assign
id|searchp
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Try to avoid slabs with constructors and/or&n;&t;&t;&t; * more than one page per slab (as it can be difficult&n;&t;&t;&t; * to get high orders from gfp()).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pri
op_eq
l_int|6
)paren
(brace
multiline_comment|/* magic &squot;6&squot; from try_to_free_page() */
r_if
c_cond
(paren
id|searchp-&gt;c_gfporder
op_logical_or
id|searchp-&gt;c_ctor
)paren
id|full_free
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|full_free
op_ge
id|reap_level
)paren
(brace
id|reap_level
op_assign
id|full_free
suffix:semicolon
id|best_cachep
op_assign
id|searchp
suffix:semicolon
)brace
)brace
r_goto
id|next
suffix:semicolon
id|next_unlock
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|searchp-&gt;c_spinlock
)paren
suffix:semicolon
id|next
suffix:colon
id|searchp
op_assign
id|searchp-&gt;c_nextp
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|scan
op_logical_and
id|searchp
op_ne
id|clock_searchp
)paren
suffix:semicolon
id|clock_searchp
op_assign
id|searchp
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|best_cachep
)paren
(brace
multiline_comment|/* couldn&squot;t find anthying to reap */
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|best_cachep-&gt;c_spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|best_cachep-&gt;c_growing
op_logical_and
op_logical_neg
(paren
id|slabp
op_assign
id|best_cachep-&gt;c_lastp
)paren
op_member_access_from_pointer
id|s_inuse
op_logical_and
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|best_cachep
)paren
)paren
(brace
r_if
c_cond
(paren
id|dma
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|slabp-&gt;s_dma
)paren
r_goto
id|good_dma
suffix:semicolon
id|slabp
op_assign
id|slabp-&gt;s_prevp
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|slabp-&gt;s_inuse
op_logical_and
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|best_cachep
)paren
)paren
suffix:semicolon
multiline_comment|/* Didn&squot;t found a DMA slab (there was a free one -&n;&t;&t;&t; * must have been become active).&n;&t;&t;&t; */
r_goto
id|dma_fail
suffix:semicolon
id|good_dma
suffix:colon
)brace
r_if
c_cond
(paren
id|slabp
op_eq
id|best_cachep-&gt;c_freep
)paren
id|best_cachep-&gt;c_freep
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|SLAB_STATS_INC_REAPED
c_func
(paren
id|best_cachep
)paren
suffix:semicolon
multiline_comment|/* Safe to drop the lock.  The slab is no longer linked to the&n;&t;&t; * cache.&n;&t;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|best_cachep-&gt;c_spinlock
)paren
suffix:semicolon
id|kmem_slab_destroy
c_func
(paren
id|best_cachep
comma
id|slabp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dma_fail
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|best_cachep-&gt;c_spinlock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if&t;SLAB_SELFTEST
multiline_comment|/* A few v. simple tests */
r_static
r_void
DECL|function|kmem_self_test
id|kmem_self_test
c_func
(paren
r_void
)paren
(brace
id|kmem_cache_t
op_star
id|test_cachep
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;kmem_test() - start&bslash;n&quot;
)paren
suffix:semicolon
id|test_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;test-cachep&quot;
comma
l_int|16
comma
l_int|0
comma
id|SLAB_RED_ZONE
op_or
id|SLAB_POISION
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_cachep
)paren
(brace
r_char
op_star
id|objp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|test_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|objp
)paren
(brace
multiline_comment|/* Write in front and past end, red-zone test. */
op_star
(paren
id|objp
op_minus
l_int|1
)paren
op_assign
l_int|1
suffix:semicolon
op_star
(paren
id|objp
op_plus
l_int|16
)paren
op_assign
l_int|1
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|test_cachep
comma
id|objp
)paren
suffix:semicolon
multiline_comment|/* Mess up poisioning. */
op_star
id|objp
op_assign
l_int|10
suffix:semicolon
id|objp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|test_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|test_cachep
comma
id|objp
)paren
suffix:semicolon
multiline_comment|/* Mess up poisioning (again). */
op_star
id|objp
op_assign
l_int|10
suffix:semicolon
id|kmem_cache_shrink
c_func
(paren
id|test_cachep
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;kmem_test() - finished&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_SELFTEST */
macro_line|#if&t;defined(CONFIG_PROC_FS)
multiline_comment|/* /proc/slabinfo&n; * cache-name num-active-objs total-objs num-active-slabs total-slabs num-pages-per-slab&n; */
r_int
DECL|function|get_slabinfo
id|get_slabinfo
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|active_objs
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
r_int
r_int
id|num_slabs
suffix:semicolon
r_int
r_int
id|num_objs
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
macro_line|#if&t;SLAB_STATS
r_int
r_int
id|active_slabs
suffix:semicolon
macro_line|#endif&t;/* SLAB_STATS */
id|__save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
multiline_comment|/* Output format version, so at least we can change it without _too_&n;&t; * many complaints.&n;&t; */
macro_line|#if&t;SLAB_STATS
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;slabinfo - version: 1.0 (statistics)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;slabinfo - version: 1.0&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;/* SLAB_STATS */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|cachep
op_assign
op_amp
id|cache_cache
suffix:semicolon
r_do
(brace
macro_line|#if&t;SLAB_STATS
id|active_slabs
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;/* SLAB_STATS */
id|num_slabs
op_assign
id|active_objs
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slabp
op_assign
id|cachep-&gt;c_firstp
suffix:semicolon
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp
op_assign
id|slabp-&gt;s_nextp
)paren
(brace
id|active_objs
op_add_assign
id|slabp-&gt;s_inuse
suffix:semicolon
id|num_slabs
op_increment
suffix:semicolon
macro_line|#if&t;SLAB_STATS
r_if
c_cond
(paren
id|slabp-&gt;s_inuse
)paren
id|active_slabs
op_increment
suffix:semicolon
macro_line|#endif&t;/* SLAB_STATS */
)brace
id|num_objs
op_assign
id|cachep-&gt;c_num
op_star
id|num_slabs
suffix:semicolon
macro_line|#if&t;SLAB_STATS
(brace
r_int
r_int
id|errors
suffix:semicolon
r_int
r_int
id|high
op_assign
id|cachep-&gt;c_high_mark
suffix:semicolon
r_int
r_int
id|grown
op_assign
id|cachep-&gt;c_grown
suffix:semicolon
r_int
r_int
id|reaped
op_assign
id|cachep-&gt;c_reaped
suffix:semicolon
r_int
r_int
id|allocs
op_assign
id|cachep-&gt;c_num_allocations
suffix:semicolon
id|errors
op_assign
(paren
r_int
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;c_errors
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%-16s %6lu %6lu %4lu %4lu %4lu %6lu %7lu %5lu %4lu %4lu&bslash;n&quot;
comma
id|cachep-&gt;c_name
comma
id|active_objs
comma
id|num_objs
comma
id|active_slabs
comma
id|num_slabs
comma
(paren
l_int|1
op_lshift
id|cachep-&gt;c_gfporder
)paren
op_star
id|num_slabs
comma
id|high
comma
id|allocs
comma
id|grown
comma
id|reaped
comma
id|errors
)paren
suffix:semicolon
)brace
macro_line|#else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;c_spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%-17s %6lu %6lu&bslash;n&quot;
comma
id|cachep-&gt;c_name
comma
id|active_objs
comma
id|num_objs
)paren
suffix:semicolon
macro_line|#endif&t;/* SLAB_STATS */
)brace
r_while
c_loop
(paren
(paren
id|cachep
op_assign
id|cachep-&gt;c_nextp
)paren
op_ne
op_amp
id|cache_cache
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PROC_FS */
eof
