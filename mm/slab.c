multiline_comment|/*&n; * linux/mm/slab.c&n; * Written by Mark Hemment, 1996.&n; * (markhe@nextd.demon.co.uk)&n; */
multiline_comment|/*&n; * An implementation of the Slab Allocator as described in outline in;&n; *&t;UNIX Internals: The New Frontiers by Uresh Vahalia&n; *&t;Pub: Prentice Hall&t;ISBN 0-13-101908-2&n; * or with a little more detail in;&n; *&t;The Slab Allocator: An Object-Caching Kernel Memory Allocator&n; *&t;Jeff Bonwick (Sun Microsystems).&n; *      Presented at: USENIX Summer 1994 Technical Conference&n; */
macro_line|#include&t;&lt;linux/slab.h&gt;
macro_line|#include&t;&lt;linux/mm.h&gt;
macro_line|#include&t;&lt;linux/interrupt.h&gt;
macro_line|#include&t;&lt;asm/system.h&gt;
macro_line|#include&t;&lt;asm/cache.h&gt;
multiline_comment|/* SLAB_MGMT_CHECKS&t;- define to enable extra checks in&n; *                        kmem_cache_[create|destroy|shrink].&n; *&t;&t;&t;  If you&squot;re not messing around with these funcs, then undef this.&n; * SLAB_HIGH_PACK&t;- define to allow &squot;bufctl&squot;s to be stored within objs that do not&n; *&t;&t;&t;  have a state.  This allows more objs per slab, but removes the&n; *&t;&t;&t;  ability to sanity check an addr on release (if the addr is&n; *                        within any slab, anywhere, kmem_cache_free() will accept it!).&n; * SLAB_DEBUG_SUPPORT&t;- when defined, kmem_cache_create() will honour; SLAB_DEBUG_FREE,&n; *&t;&t;&t;  SLAB_DEBUG_INITIAL and SLAB_RED_ZONE.&n; */
DECL|macro|SLAB_MGMT_CHECKS
mdefine_line|#define&t;&t;SLAB_MGMT_CHECKS
DECL|macro|SLAB_HIGH_PACK
macro_line|#undef&t;&t;SLAB_HIGH_PACK
DECL|macro|SLAB_DEBUG_SUPPORT
mdefine_line|#define&t;&t;SLAB_DEBUG_SUPPORT&t;/* undef this when your cache is stable */
DECL|macro|BYTES_PER_WORD
mdefine_line|#define&t;BYTES_PER_WORD&t;sizeof(void *)
multiline_comment|/* legal flag mask for kmem_cache_create() */
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
DECL|macro|SLAB_C_MASK
mdefine_line|#define&t;SLAB_C_MASK&t;&t;(SLAB_DEBUG_FREE|SLAB_DEBUG_INITIAL|SLAB_HWCACHE_ALIGN|SLAB_RED_ZONE)
macro_line|#else
DECL|macro|SLAB_C_MASK
mdefine_line|#define&t;SLAB_C_MASK&t;&t;(SLAB_HWCACHE_ALIGN)
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
multiline_comment|/* Magic num for red zoning.&n; * Placed in the first word after the end of an obj&n; */
DECL|macro|SLAB_RED_MAGIC1
mdefine_line|#define&t;SLAB_RED_MAGIC1&t;&t;0x5A2CF071UL&t;/* when obj is active */
DECL|macro|SLAB_RED_MAGIC2
mdefine_line|#define&t;SLAB_RED_MAGIC2&t;&t;0x170FC2A5UL&t;/* when obj is inactive */
multiline_comment|/* Used for linking objs within a slab.  How much of the struct is&n; * used, and where its placed, depends on the packing used in a cache.&n; * Don&squot;t mess with the order!&n; */
DECL|struct|kmem_bufctl_s
r_typedef
r_struct
id|kmem_bufctl_s
(brace
DECL|member|buf_nextp
r_struct
id|kmem_bufctl_s
op_star
id|buf_nextp
suffix:semicolon
DECL|member|buf_slabp
r_struct
id|kmem_slab_s
op_star
id|buf_slabp
suffix:semicolon
DECL|member|buf_objp
r_void
op_star
id|buf_objp
suffix:semicolon
multiline_comment|/* start of obj */
DECL|member|buf_hnextp
r_struct
id|kmem_bufctl_s
op_star
id|buf_hnextp
suffix:semicolon
DECL|member|buf_hashp
r_struct
id|kmem_bufctl_s
op_star
op_star
id|buf_hashp
suffix:semicolon
DECL|typedef|kmem_bufctl_t
)brace
id|kmem_bufctl_t
suffix:semicolon
multiline_comment|/* different portions of the bufctl are used - so need some macros */
DECL|macro|kmem_bufctl_offset
mdefine_line|#define&t;kmem_bufctl_offset(x) ((unsigned long)&amp;((kmem_bufctl_t *)0)-&gt;x)
DECL|macro|kmem_bufctl_short_size
mdefine_line|#define&t;kmem_bufctl_short_size&t;(kmem_bufctl_offset(buf_objp))
DECL|macro|kmem_bufctl_very_short_size
mdefine_line|#define&t;kmem_bufctl_very_short_size&t;(kmem_bufctl_offset(buf_slabp))
multiline_comment|/* Slab management struct.&n; * Manages the objs in a slab.  Placed either at the end of mem allocated&n; * for the slab, or from an internal obj cache (SLAB_CFLGS_OFF_SLAB).&n; * Slabs are chain into a partially ordered list.  The linking ptrs must&n; * be first in the struct!&n; * The size of the struct is important(ish);  it should align well on&n; * cache line(s)&n; */
DECL|struct|kmem_slab_s
r_typedef
r_struct
id|kmem_slab_s
(brace
DECL|member|s_nextp
r_struct
id|kmem_slab_s
op_star
id|s_nextp
suffix:semicolon
DECL|member|s_prevp
r_struct
id|kmem_slab_s
op_star
id|s_prevp
suffix:semicolon
DECL|member|s_mem
r_void
op_star
id|s_mem
suffix:semicolon
multiline_comment|/* addr of mem allocated for slab */
DECL|member|s_jiffies
r_int
r_int
id|s_jiffies
suffix:semicolon
DECL|member|s_freep
id|kmem_bufctl_t
op_star
id|s_freep
suffix:semicolon
multiline_comment|/* ptr to first inactive obj in slab */
DECL|member|s_flags
r_int
r_int
id|s_flags
suffix:semicolon
DECL|member|s_magic
r_int
r_int
id|s_magic
suffix:semicolon
DECL|member|s_inuse
r_int
r_int
id|s_inuse
suffix:semicolon
multiline_comment|/* num of objs active in slab */
DECL|typedef|kmem_slab_t
)brace
id|kmem_slab_t
suffix:semicolon
multiline_comment|/* to test for end of slab chain */
DECL|macro|kmem_slab_end
mdefine_line|#define&t;kmem_slab_end(x)&t;((kmem_slab_t*)&amp;((x)-&gt;c_firstp))
multiline_comment|/* s_magic */
DECL|macro|SLAB_MAGIC_ALLOC
mdefine_line|#define&t;SLAB_MAGIC_ALLOC&t;0xA5C32F2BUL
DECL|macro|SLAB_MAGIC_UNALLOC
mdefine_line|#define&t;SLAB_MAGIC_UNALLOC&t;0xB2F23C5AUL
multiline_comment|/* s_flags */
DECL|macro|SLAB_SFLGS_DMA
mdefine_line|#define&t;SLAB_SFLGS_DMA&t;&t;0x000001UL&t;/* slab&squot;s mem can do DMA */
multiline_comment|/* cache struct - manages a cache.&n; * c_lastp must appear immediately after c_firstp!&n; */
DECL|struct|kmem_cache_s
r_struct
id|kmem_cache_s
(brace
DECL|member|c_freep
id|kmem_slab_t
op_star
id|c_freep
suffix:semicolon
multiline_comment|/* first slab w. free objs */
DECL|member|c_flags
r_int
r_int
id|c_flags
suffix:semicolon
DECL|member|c_offset
r_int
r_int
id|c_offset
suffix:semicolon
DECL|member|c_hashp
r_struct
id|kmem_bufctl_s
op_star
op_star
id|c_hashp
suffix:semicolon
multiline_comment|/* ptr for off-slab bufctls */
DECL|member|c_firstp
id|kmem_slab_t
op_star
id|c_firstp
suffix:semicolon
multiline_comment|/* first slab in chain */
DECL|member|c_lastp
id|kmem_slab_t
op_star
id|c_lastp
suffix:semicolon
multiline_comment|/* last slab in chain */
DECL|member|c_hashbits
r_int
r_int
id|c_hashbits
suffix:semicolon
DECL|member|c_num
r_int
r_int
id|c_num
suffix:semicolon
multiline_comment|/* # of objs per slab */
DECL|member|c_gfporder
r_int
r_int
id|c_gfporder
suffix:semicolon
multiline_comment|/* order of pgs per slab (2^n) */
DECL|member|c_org_size
r_int
r_int
id|c_org_size
suffix:semicolon
DECL|member|c_magic
r_int
r_int
id|c_magic
suffix:semicolon
DECL|member|c_inuse
r_int
r_int
id|c_inuse
suffix:semicolon
multiline_comment|/* kept at zero */
DECL|member|c_ctor
r_void
(paren
op_star
id|c_ctor
)paren
(paren
r_void
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* constructor func */
DECL|member|c_dtor
r_void
(paren
op_star
id|c_dtor
)paren
(paren
r_void
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* de-constructor func */
DECL|member|c_align
r_int
r_int
id|c_align
suffix:semicolon
multiline_comment|/* alignment of objs */
DECL|member|c_colour
r_int
r_int
id|c_colour
suffix:semicolon
multiline_comment|/* cache colouring range */
DECL|member|c_colour_next
r_int
r_int
id|c_colour_next
suffix:semicolon
multiline_comment|/* cache colouring */
DECL|member|c_name
r_const
r_char
op_star
id|c_name
suffix:semicolon
DECL|member|c_nextp
r_struct
id|kmem_cache_s
op_star
id|c_nextp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* magic # for c_magic - used to detect out-of-slabs in __kmem_cache_alloc() */
DECL|macro|SLAB_C_MAGIC
mdefine_line|#define&t;SLAB_C_MAGIC&t;&t;0x4F17A36DUL
multiline_comment|/* internal c_flags */
DECL|macro|SLAB_CFLGS_OFF_SLAB
mdefine_line|#define&t;SLAB_CFLGS_OFF_SLAB&t;0x010000UL&t;/* slab mgmt in own cache */
DECL|macro|SLAB_CFLGS_BUFCTL
mdefine_line|#define&t;SLAB_CFLGS_BUFCTL&t;0x020000UL&t;/* bufctls in own cache */
DECL|macro|SLAB_CFLGS_RELEASED
mdefine_line|#define&t;SLAB_CFLGS_RELEASED&t;0x040000UL&t;/* cache is/being destroyed */
macro_line|#if&t;defined(SLAB_HIGH_PACK)
DECL|macro|SLAB_CFLGS_PTR_IN_OBJ
mdefine_line|#define&t;SLAB_CFLGS_PTR_IN_OBJ&t;0x080000UL&t;/* free ptr in obj */
macro_line|#endif
DECL|macro|SLAB_OFF_SLAB
mdefine_line|#define&t;SLAB_OFF_SLAB(x)&t;((x) &amp; SLAB_CFLGS_OFF_SLAB)
DECL|macro|SLAB_BUFCTL
mdefine_line|#define&t;SLAB_BUFCTL(x)&t;&t;((x) &amp; SLAB_CFLGS_BUFCTL)
DECL|macro|SLAB_RELEASED
mdefine_line|#define&t;SLAB_RELEASED(x)&t;((x) &amp; SLAB_CFLGS_RELEASED)
macro_line|#if&t;defined(SLAB_HIGH_PACK)
DECL|macro|SLAB_PTR_IN_OBJ
mdefine_line|#define&t;SLAB_PTR_IN_OBJ(x)&t;((x) &amp; SLAB_CFLGS_PTR_IN_OBJ)
macro_line|#else
DECL|macro|SLAB_PTR_IN_OBJ
mdefine_line|#define&t;SLAB_PTR_IN_OBJ(x)&t;(0)
macro_line|#endif
multiline_comment|/* maximum size of an obj (in 2^order pages) */
DECL|macro|SLAB_OBJ_MAX_ORDER
mdefine_line|#define&t;SLAB_OBJ_MAX_ORDER&t;5&t;/* 32 pages */
multiline_comment|/* maximum num of pages for a slab (avoids trying to ask for too may contigious pages) */
DECL|macro|SLAB_MAX_GFP_ORDER
mdefine_line|#define&t;SLAB_MAX_GFP_ORDER&t;5&t;/* 32 pages */
multiline_comment|/* the &squot;prefered&squot; minimum num of objs per slab - maybe less for large objs */
DECL|macro|SLAB_MIN_OBJS_PER_SLAB
mdefine_line|#define&t;SLAB_MIN_OBJS_PER_SLAB&t;4
multiline_comment|/* if the num of objs per slab is &lt;= SLAB_MIN_OBJS_PER_SLAB,&n; * then the page order must be less than this before trying the next order&n; */
DECL|macro|SLAB_BREAK_GFP_ORDER
mdefine_line|#define&t;SLAB_BREAK_GFP_ORDER&t;2
multiline_comment|/* size of hash tables for caches which use off-slab bufctls (SLAB_CFLGS_BUFCTL) */
DECL|macro|KMEM_HASH_SIZE
mdefine_line|#define&t;KMEM_HASH_SIZE&t;128
multiline_comment|/* size description struct for general-caches */
DECL|struct|cache_sizes
r_typedef
r_struct
id|cache_sizes
(brace
DECL|member|cs_size
r_int
r_int
id|cs_size
suffix:semicolon
DECL|member|cs_cachep
id|kmem_cache_t
op_star
id|cs_cachep
suffix:semicolon
DECL|typedef|cache_sizes_t
)brace
id|cache_sizes_t
suffix:semicolon
DECL|variable|cache_sizes
r_static
id|cache_sizes_t
id|cache_sizes
(braket
)braket
op_assign
(brace
macro_line|#if&t;PAGE_SIZE == 4096
(brace
l_int|32
comma
l_int|NULL
)brace
comma
macro_line|#endif
(brace
l_int|64
comma
l_int|NULL
)brace
comma
(brace
l_int|128
comma
l_int|NULL
)brace
comma
(brace
l_int|256
comma
l_int|NULL
)brace
comma
(brace
l_int|512
comma
l_int|NULL
)brace
comma
(brace
l_int|1024
comma
l_int|NULL
)brace
comma
(brace
l_int|2048
comma
l_int|NULL
)brace
comma
(brace
l_int|4096
comma
l_int|NULL
)brace
comma
(brace
l_int|8192
comma
l_int|NULL
)brace
comma
macro_line|#if&t;PAGE_SIZE == 8192
(brace
l_int|16384
comma
l_int|NULL
)brace
comma
macro_line|#endif
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* Names for the general-caches.&n; * Not placed into the sizes struct for a good reason; the&n; * string ptr is not needed while searching in kmem_alloc()/&n; * kmem_free(), and would &squot;get-in-the-way&squot; - think about it.&n; */
DECL|variable|cache_sizes_name
r_static
r_char
op_star
id|cache_sizes_name
(braket
)braket
op_assign
(brace
macro_line|#if&t;PAGE_SIZE == 4096
l_string|&quot;cache-32&quot;
comma
macro_line|#endif
l_string|&quot;cache-64&quot;
comma
l_string|&quot;cache-128&quot;
comma
l_string|&quot;cache-256&quot;
comma
l_string|&quot;cache-512&quot;
comma
l_string|&quot;cache-1024&quot;
comma
l_string|&quot;cache-2048&quot;
comma
l_string|&quot;cache-4096&quot;
comma
macro_line|#if&t;PAGE_SIZE == 4096
l_string|&quot;cache-8192&quot;
macro_line|#elif&t;PAGE_SIZE == 8192
l_string|&quot;cache-8192&quot;
comma
l_string|&quot;cache-16384&quot;
macro_line|#else
macro_line|#error&t;Your page size is not supported for the general-caches - please fix
macro_line|#endif
)brace
suffix:semicolon
r_static
r_void
id|kmem_hash_ctor
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* fwd ref */
r_extern
id|kmem_cache_t
id|cache_cache
suffix:semicolon
multiline_comment|/* fwd ref */
multiline_comment|/* internal cache of hash objs, only used when bufctls are off-slab */
DECL|variable|cache_hash
r_static
id|kmem_cache_t
id|cache_hash
op_assign
(brace
multiline_comment|/* freep, flags */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_hash
)paren
comma
l_int|0
comma
multiline_comment|/* offset, hashp */
r_sizeof
(paren
id|kmem_bufctl_t
op_star
)paren
op_star
id|KMEM_HASH_SIZE
comma
l_int|NULL
comma
multiline_comment|/* firstp, lastp */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_hash
)paren
comma
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_hash
)paren
comma
multiline_comment|/* hashbits, num, gfporder */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* org_size, magic */
r_sizeof
(paren
id|kmem_bufctl_t
op_star
)paren
op_star
id|KMEM_HASH_SIZE
comma
id|SLAB_C_MAGIC
comma
multiline_comment|/* inuse, ctor, dtor, align */
l_int|0
comma
id|kmem_hash_ctor
comma
l_int|NULL
comma
id|L1_CACHE_BYTES
comma
multiline_comment|/* colour, colour_next */
l_int|0
comma
l_int|0
comma
multiline_comment|/* name, nextp */
l_string|&quot;hash_cache&quot;
comma
op_amp
id|cache_cache
)brace
suffix:semicolon
multiline_comment|/* internal cache of freelist mgmnt objs, only use when bufctls are off-slab */
DECL|variable|cache_bufctl
r_static
id|kmem_cache_t
id|cache_bufctl
op_assign
(brace
multiline_comment|/* freep, flags */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_bufctl
)paren
comma
l_int|0
comma
multiline_comment|/* offset, hashp */
r_sizeof
(paren
id|kmem_bufctl_t
)paren
comma
l_int|NULL
comma
multiline_comment|/* firstp, lastp */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_bufctl
)paren
comma
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_bufctl
)paren
comma
multiline_comment|/* hashbits, num, gfporder */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* org_size, magic */
r_sizeof
(paren
id|kmem_bufctl_t
)paren
comma
id|SLAB_C_MAGIC
comma
multiline_comment|/* inuse, ctor, dtor, align */
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
id|BYTES_PER_WORD
op_star
l_int|2
comma
multiline_comment|/* colour, colour_next */
l_int|0
comma
l_int|0
comma
multiline_comment|/* name, nextp */
l_string|&quot;bufctl_cache&quot;
comma
op_amp
id|cache_hash
)brace
suffix:semicolon
multiline_comment|/* internal cache of slab mngmnt objs, only used when slab mgmt is off-slab */
DECL|variable|cache_slab
r_static
id|kmem_cache_t
id|cache_slab
op_assign
(brace
multiline_comment|/* freep, flags */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_slab
)paren
comma
l_int|0
comma
multiline_comment|/* offset, hashp */
r_sizeof
(paren
id|kmem_slab_t
)paren
comma
l_int|NULL
comma
multiline_comment|/* firstp, lastp */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_slab
)paren
comma
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_slab
)paren
comma
multiline_comment|/* hashbits, num, gfporder */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* org_size, magic */
r_sizeof
(paren
id|kmem_slab_t
)paren
comma
id|SLAB_C_MAGIC
comma
multiline_comment|/* inuse, ctor, dtor, align */
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
id|L1_CACHE_BYTES
comma
multiline_comment|/* colour, colour_next */
l_int|0
comma
l_int|0
comma
multiline_comment|/* name, nextp */
l_string|&quot;slab_cache&quot;
comma
op_amp
id|cache_bufctl
)brace
suffix:semicolon
multiline_comment|/* internal cache of cache description objs */
DECL|variable|cache_cache
r_static
id|kmem_cache_t
id|cache_cache
op_assign
(brace
multiline_comment|/* freep, flags */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_cache
)paren
comma
l_int|0
comma
multiline_comment|/* offset, hashp */
r_sizeof
(paren
id|kmem_cache_t
)paren
comma
l_int|NULL
comma
multiline_comment|/* firstp, lastp */
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_cache
)paren
comma
id|kmem_slab_end
c_func
(paren
op_amp
id|cache_cache
)paren
comma
multiline_comment|/* hashbits, num, gfporder */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* org_size, magic */
r_sizeof
(paren
id|kmem_cache_t
)paren
comma
id|SLAB_C_MAGIC
comma
multiline_comment|/* inuse, ctor, dtor, align */
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
id|L1_CACHE_BYTES
comma
multiline_comment|/* colour, colour_next */
l_int|0
comma
l_int|0
comma
multiline_comment|/* name */
l_string|&quot;kmem_cache&quot;
comma
multiline_comment|/* nextp */
op_amp
id|cache_slab
)brace
suffix:semicolon
multiline_comment|/* constructor for hash tables */
DECL|function|kmem_hash_ctor
r_static
r_void
id|kmem_hash_ctor
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
r_sizeof
(paren
id|kmem_bufctl_t
op_star
)paren
op_star
id|KMEM_HASH_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* place maintainer for reaping */
DECL|variable|clock_searchp
r_static
id|kmem_cache_t
op_star
id|clock_searchp
op_assign
op_amp
id|cache_cache
suffix:semicolon
multiline_comment|/* Init an internal cache */
r_static
r_void
DECL|function|kmem_own_cache_init
id|kmem_own_cache_init
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_int
r_int
id|size
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_inuse
op_logical_or
id|cachep-&gt;c_magic
op_ne
id|SLAB_C_MAGIC
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Bad init of internal cache %s&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
id|size
op_assign
id|cachep-&gt;c_offset
op_plus
id|kmem_bufctl_short_size
suffix:semicolon
id|i
op_assign
id|size
op_mod
id|cachep-&gt;c_align
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|size
op_add_assign
(paren
id|cachep-&gt;c_align
op_minus
id|i
)paren
suffix:semicolon
id|cachep-&gt;c_offset
op_assign
id|size
op_minus
id|kmem_bufctl_short_size
suffix:semicolon
id|i
op_assign
(paren
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;c_gfporder
)paren
op_minus
r_sizeof
(paren
id|kmem_slab_t
)paren
)paren
suffix:semicolon
id|cachep-&gt;c_num
op_assign
id|i
op_div
id|size
suffix:semicolon
multiline_comment|/* num of objs per slab */
multiline_comment|/* cache colouring */
id|cachep-&gt;c_colour
op_assign
l_int|1
op_plus
(paren
id|i
op_minus
(paren
id|cachep-&gt;c_num
op_star
id|size
)paren
)paren
op_div
id|cachep-&gt;c_align
suffix:semicolon
id|cachep-&gt;c_colour_next
op_assign
id|cachep-&gt;c_colour
suffix:semicolon
)brace
multiline_comment|/* Initialisation - setup all internal caches */
r_int
DECL|function|kmem_cache_init
id|kmem_cache_init
c_func
(paren
r_int
id|start
comma
r_int
id|end
)paren
(brace
multiline_comment|/* sanity */
DECL|macro|kmem_cache_offset
mdefine_line|#define&t;kmem_cache_offset(x) ((unsigned long)&amp;((kmem_cache_t *)0)-&gt;x)
DECL|macro|kmem_slab_offset
mdefine_line|#define&t;kmem_slab_offset(x) ((unsigned long)&amp;((kmem_slab_t *)0)-&gt;x)
r_if
c_cond
(paren
(paren
(paren
id|kmem_cache_offset
c_func
(paren
id|c_magic
)paren
op_minus
id|kmem_cache_offset
c_func
(paren
id|c_firstp
)paren
)paren
op_ne
id|kmem_slab_offset
c_func
(paren
id|s_magic
)paren
)paren
op_logical_or
(paren
(paren
id|kmem_cache_offset
c_func
(paren
id|c_inuse
)paren
op_minus
id|kmem_cache_offset
c_func
(paren
id|c_firstp
)paren
)paren
op_ne
id|kmem_slab_offset
c_func
(paren
id|s_inuse
)paren
)paren
)paren
(brace
multiline_comment|/* Offsets to the magic are incorrect, either the structures have&n;&t;&t; * been incorrectly changed, or adjustments are needed for your&n;&t;&t; * architecture.&n;&t;&t; */
id|panic
c_func
(paren
l_string|&quot;kmem_cache_init(): Offsets are different - been messed with!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
DECL|macro|kmem_cache_offset
macro_line|#undef&t;kmem_cache_offset
DECL|macro|kmem_slab_offset
macro_line|#undef&t;kmem_slab_offset
id|kmem_own_cache_init
c_func
(paren
op_amp
id|cache_cache
)paren
suffix:semicolon
id|kmem_own_cache_init
c_func
(paren
op_amp
id|cache_slab
)paren
suffix:semicolon
id|kmem_own_cache_init
c_func
(paren
op_amp
id|cache_bufctl
)paren
suffix:semicolon
id|kmem_own_cache_init
c_func
(paren
op_amp
id|cache_hash
)paren
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
multiline_comment|/* Initialisation - setup general caches */
r_void
DECL|function|kmem_cache_sizes_init
id|kmem_cache_sizes_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|i
op_assign
r_sizeof
(paren
id|cache_sizes
)paren
op_div
r_sizeof
(paren
id|cache_sizes
(braket
l_int|0
)braket
)paren
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|cache_sizes
(braket
id|i
)braket
dot
id|cs_cachep
op_assign
id|kmem_cache_create
c_func
(paren
id|cache_sizes_name
(braket
id|i
)braket
comma
id|cache_sizes
(braket
id|i
)braket
dot
id|cs_size
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Interface to system&squot;s page allocator.&n; * dma pts to non-zero if all of the mem is suitable for DMA&n; */
r_static
r_inline
r_void
op_star
DECL|function|kmem_getpages
id|kmem_getpages
c_func
(paren
r_const
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
comma
r_int
r_int
op_star
id|dma
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
id|addr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
comma
"&bslash;"
id|cachep-&gt;c_gfporder
comma
id|flags
op_amp
id|SLAB_DMA
)paren
suffix:semicolon
op_star
id|dma
op_assign
l_int|1
op_lshift
id|cachep-&gt;c_gfporder
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|SLAB_DMA
)paren
op_logical_and
id|addr
)paren
(brace
multiline_comment|/* need to check if can dma */
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|dma
)paren
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageDMA
c_func
(paren
id|page
)paren
)paren
(brace
op_star
id|dma
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|page
op_increment
suffix:semicolon
)brace
)brace
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/* Interface to system&squot;s page release */
r_static
r_inline
r_void
DECL|function|kmem_freepages
id|kmem_freepages
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|cachep-&gt;c_gfporder
)paren
suffix:semicolon
)brace
multiline_comment|/* Hashing function - used for caches with off-slab bufctls */
r_static
r_inline
r_int
DECL|function|kmem_hash
id|kmem_hash
c_func
(paren
r_const
id|kmem_cache_t
op_star
id|cachep
comma
r_const
r_void
op_star
id|objp
)paren
(brace
r_return
(paren
(paren
(paren
r_int
r_int
)paren
id|objp
op_rshift
id|cachep-&gt;c_hashbits
)paren
op_amp
(paren
id|KMEM_HASH_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Link bufctl into a hash table - used for caches with off-slab bufctls &n; * - called with ints disabled&n; */
r_static
r_inline
r_void
op_star
DECL|function|kmem_add_to_hash
id|kmem_add_to_hash
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_bufctl_t
op_star
id|bufp
)paren
(brace
id|kmem_bufctl_t
op_star
op_star
id|bufpp
op_assign
id|bufp-&gt;buf_hashp
suffix:semicolon
id|bufp-&gt;buf_hnextp
op_assign
op_star
id|bufpp
suffix:semicolon
r_return
(paren
op_star
id|bufpp
op_assign
id|bufp
)paren
op_member_access_from_pointer
id|buf_objp
suffix:semicolon
)brace
multiline_comment|/* Find bufcntl for given obj addr, and unlink.&n; * - called with ints disabled&n; */
r_static
r_inline
id|kmem_bufctl_t
op_star
DECL|function|kmem_remove_from_hash
id|kmem_remove_from_hash
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_const
r_void
op_star
id|objp
)paren
(brace
id|kmem_bufctl_t
op_star
id|bufp
suffix:semicolon
id|kmem_bufctl_t
op_star
op_star
id|bufpp
op_assign
op_amp
id|cachep-&gt;c_hashp
(braket
id|kmem_hash
c_func
(paren
id|cachep
comma
id|objp
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|bufpp
suffix:semicolon
id|bufpp
op_assign
op_amp
(paren
op_star
id|bufpp
)paren
op_member_access_from_pointer
id|buf_hnextp
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|bufpp
)paren
op_member_access_from_pointer
id|buf_objp
op_ne
id|objp
)paren
r_continue
suffix:semicolon
id|bufp
op_assign
op_star
id|bufpp
suffix:semicolon
op_star
id|bufpp
op_assign
id|bufp-&gt;buf_hnextp
suffix:semicolon
r_return
id|bufp
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Three slab chain funcs - all called with ints disabled */
r_static
r_inline
r_void
DECL|function|kmem_slab_unlink
id|kmem_slab_unlink
c_func
(paren
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
id|kmem_slab_t
op_star
id|prevp
op_assign
id|slabp-&gt;s_prevp
suffix:semicolon
id|kmem_slab_t
op_star
id|nextp
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
id|prevp-&gt;s_nextp
op_assign
id|nextp
suffix:semicolon
id|nextp-&gt;s_prevp
op_assign
id|prevp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kmem_slab_link_end
id|kmem_slab_link_end
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
id|slabp-&gt;s_nextp
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp-&gt;s_prevp
op_assign
id|cachep-&gt;c_lastp
suffix:semicolon
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|s_prevp
op_assign
id|slabp
suffix:semicolon
id|slabp-&gt;s_prevp-&gt;s_nextp
op_assign
id|slabp
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kmem_slab_link_free
id|kmem_slab_link_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
id|kmem_slab_t
op_star
id|nextp
op_assign
id|cachep-&gt;c_freep
suffix:semicolon
id|slabp-&gt;s_nextp
op_assign
id|nextp
suffix:semicolon
id|cachep-&gt;c_freep
op_assign
id|slabp
suffix:semicolon
id|slabp-&gt;s_prevp
op_assign
id|nextp-&gt;s_prevp
suffix:semicolon
id|nextp-&gt;s_prevp
op_assign
id|slabp
suffix:semicolon
id|slabp-&gt;s_prevp-&gt;s_nextp
op_assign
id|slabp
suffix:semicolon
)brace
multiline_comment|/* Cal the num objs, wastage, and bytes left over for a given slab size */
r_static
r_int
DECL|function|kmem_cache_cal_waste
id|kmem_cache_cal_waste
c_func
(paren
r_int
r_int
id|gfporder
comma
r_int
r_int
id|size
comma
r_int
r_int
id|extra
comma
r_int
r_int
id|flags
comma
r_int
r_int
op_star
id|left_over
comma
r_int
r_int
op_star
id|num
)paren
(brace
r_int
r_int
id|wastage
suffix:semicolon
id|wastage
op_assign
id|PAGE_SIZE
op_lshift
id|gfporder
suffix:semicolon
id|gfporder
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SLAB_OFF_SLAB
c_func
(paren
id|flags
)paren
)paren
id|gfporder
op_assign
r_sizeof
(paren
id|kmem_slab_t
)paren
suffix:semicolon
id|wastage
op_sub_assign
id|gfporder
suffix:semicolon
op_star
id|num
op_assign
id|wastage
op_div
id|size
suffix:semicolon
id|wastage
op_sub_assign
(paren
op_star
id|num
op_star
id|size
)paren
suffix:semicolon
op_star
id|left_over
op_assign
id|wastage
suffix:semicolon
id|wastage
op_add_assign
(paren
id|extra
op_star
op_star
id|num
)paren
suffix:semicolon
id|wastage
op_add_assign
id|gfporder
suffix:semicolon
r_return
id|wastage
suffix:semicolon
)brace
multiline_comment|/* Create a cache&n; * Returns a ptr to the cache on success, NULL on failure.&n; * Cannot be called within a int, but can be interrupted.&n; * NOTE: The &squot;name&squot; is assumed to be memory that is _not_  going to disappear.&n; */
id|kmem_cache_t
op_star
DECL|function|kmem_cache_create
id|kmem_cache_create
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|size
comma
r_int
r_int
id|align
comma
r_int
r_int
id|flags
comma
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
r_int
comma
r_int
r_int
)paren
comma
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
r_int
comma
r_int
r_int
)paren
)paren
(brace
r_const
r_char
op_star
id|func_nm
op_assign
l_string|&quot;kmem_create: &quot;
suffix:semicolon
id|kmem_cache_t
op_star
id|searchp
comma
op_star
id|cachep
suffix:semicolon
r_int
r_int
id|words
comma
id|i
suffix:semicolon
r_int
r_int
id|num
comma
id|left_over
suffix:semicolon
multiline_comment|/* sanity checks */
macro_line|#if&t;defined(SLAB_MGMT_CHECKS)
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sNULL ptr&bslash;n&quot;
comma
id|func_nm
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sCalled during int - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OL
id|kmem_bufctl_very_short_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%sSize too small %lu - %s&bslash;n&quot;
comma
id|func_nm
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|size
op_assign
id|kmem_bufctl_very_short_size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OG
(paren
(paren
l_int|1
op_lshift
id|SLAB_OBJ_MAX_ORDER
)paren
op_star
id|PAGE_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sSize too large %lu - %s&bslash;n&quot;
comma
id|func_nm
comma
id|size
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_MGMT_CHECKS */
multiline_comment|/* always checks flags, a caller might be expecting debug support which&n;&t; * isn&squot;t available&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
id|SLAB_C_MASK
)paren
(brace
multiline_comment|/* Illegal flags */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%sIllgl flg %lX - %s&bslash;n&quot;
comma
id|func_nm
comma
id|flags
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
id|SLAB_C_MASK
suffix:semicolon
)brace
macro_line|#if&t;defined(SLAB_MGMT_CHECKS)
r_if
c_cond
(paren
id|align
OL
l_int|0
op_logical_or
id|align
op_ge
id|size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%sAlign weired %lu - %s&bslash;n&quot;
comma
id|func_nm
comma
id|align
comma
id|name
)paren
suffix:semicolon
id|align
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dtor
op_logical_and
op_logical_neg
id|ctor
)paren
(brace
multiline_comment|/* Descon, but no con - doesn&squot;t make sense */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sDecon but no con - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
op_logical_and
op_logical_neg
id|ctor
)paren
(brace
multiline_comment|/* No constructor, but inital state check requested */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%sNo con, but init state check requested - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_DEBUG_INITIAL
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_MGMT_CHECKS */
multiline_comment|/* get cache&squot;s description obj */
id|cachep
op_assign
(paren
id|kmem_cache_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_cache
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|opps
suffix:semicolon
multiline_comment|/* remember original size, so can be passed to a constructor or decon.&n;&t; * Allows the same con/decon to be used for caches of similar objs&n;&t; * that have a different size data buffer assoicated with them&n;&t; */
id|cachep-&gt;c_org_size
op_assign
id|size
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_RED_ZONE
)paren
id|size
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
multiline_comment|/* word for redzone */
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
multiline_comment|/* Make a guess if slab mngmnt obj and/or bufctls are &squot;on&squot; or &squot;off&squot; slab */
id|i
op_assign
id|kmem_bufctl_short_size
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
(paren
id|PAGE_SIZE
op_rshift
l_int|3
)paren
)paren
(brace
multiline_comment|/* Size is small(ish).  Use format where bufctl size per&n;&t;&t; * obj is low, and slab mngmnt is on-slab&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ctor
op_logical_and
op_logical_neg
id|dtor
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|SLAB_RED_ZONE
)paren
)paren
(brace
multiline_comment|/* the objs in this cache have no state - can store&n;&t;&t;&t; * store freelist ptr within obj. (redzoning is a state)&n;&t;&t;&t; */
macro_line|#if&t;defined(SLAB_HIGH_PACK)
id|i
op_assign
l_int|0
suffix:semicolon
id|flags
op_or_assign
id|SLAB_CFLGS_PTR_IN_OBJ
suffix:semicolon
macro_line|#else
id|i
op_assign
id|kmem_bufctl_very_short_size
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
multiline_comment|/* Size is large, assume best to place the slab mngmnt obj&n;&t;&t; * off-slab (should allow better packing of objs)&n;&t;&t; */
id|flags
op_or_assign
id|SLAB_CFLGS_OFF_SLAB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|size
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|size
op_eq
(paren
id|PAGE_SIZE
op_plus
id|PAGE_SIZE
op_div
l_int|2
)paren
op_logical_or
id|size
op_eq
(paren
id|PAGE_SIZE
op_div
l_int|2
)paren
op_logical_or
id|size
op_eq
(paren
id|PAGE_SIZE
op_div
l_int|4
)paren
op_logical_or
id|size
op_eq
(paren
id|PAGE_SIZE
op_div
l_int|8
)paren
)paren
(brace
multiline_comment|/* to avoid waste the bufctls are off-slab */
id|flags
op_or_assign
id|SLAB_CFLGS_BUFCTL
suffix:semicolon
multiline_comment|/* get hash table for cache */
id|cachep-&gt;c_hashp
op_assign
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_hash
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_hashp
op_eq
l_int|NULL
)paren
(brace
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
id|cachep-&gt;c_hashbits
op_assign
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
(paren
id|PAGE_SIZE
op_div
l_int|2
)paren
)paren
(brace
id|cachep-&gt;c_hashbits
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
(paren
id|PAGE_SIZE
op_div
l_int|4
)paren
)paren
id|cachep-&gt;c_hashbits
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
(paren
id|PAGE_SIZE
op_div
l_int|8
)paren
)paren
id|cachep-&gt;c_hashbits
op_sub_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/* else slab mngmnt is off-slab, but freelist ptrs are on */
)brace
id|size
op_add_assign
id|i
suffix:semicolon
multiline_comment|/* Adjust the mem used for objs so they will align correctly.&n;&t; * Force objs to start on word boundaries, but caller may specify&n;&t; * h/w cache line boundaries.  This &squot;alignment&squot; is slightly different&n;&t; * to the &squot;align&squot; argument.  Objs may be requested to start on h/w&n;&t; * lines (as that is how the members of the obj have been organised),&n;&t; * but the &squot;align&squot; may be quite high (say 64) as the first 64 bytes&n;&t; * are commonly accessed/modified within a loop (stops h/w line&n;&t; * thrashing).  The &squot;align&squot; is the slab colouring.&n;&t; */
id|words
op_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
id|words
op_assign
id|L1_CACHE_BYTES
suffix:semicolon
id|words
op_decrement
suffix:semicolon
id|size
op_add_assign
id|words
suffix:semicolon
id|size
op_assign
id|size
op_amp
op_complement
id|words
suffix:semicolon
multiline_comment|/* alignment might not be a factor of the boundary alignment - fix-up */
id|align
op_add_assign
id|words
suffix:semicolon
id|align
op_assign
id|align
op_amp
op_complement
id|words
suffix:semicolon
multiline_comment|/* Cal size (in pages) of slabs, and the num of objs per slab.&n;&t; * This could be made much more intelligent. */
id|cachep-&gt;c_gfporder
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
r_int
id|wastage
suffix:semicolon
id|wastage
op_assign
id|kmem_cache_cal_waste
c_func
(paren
id|cachep-&gt;c_gfporder
comma
id|size
comma
id|i
comma
id|flags
comma
op_amp
id|left_over
comma
op_amp
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_PTR_IN_OBJ
c_func
(paren
id|flags
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_gfporder
op_eq
id|SLAB_MAX_GFP_ORDER
)paren
r_break
suffix:semicolon
multiline_comment|/* large num of objs is good, but v. large slabs are bad for the&n;&t;&t; * VM sub-system&n;&t;&t; */
r_if
c_cond
(paren
id|num
op_le
id|SLAB_MIN_OBJS_PER_SLAB
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;c_gfporder
OL
id|SLAB_BREAK_GFP_ORDER
)paren
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* stop caches with small objs having a large num of pages */
r_if
c_cond
(paren
id|left_over
op_le
r_sizeof
(paren
id|kmem_slab_t
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wastage
op_star
l_int|8
)paren
op_le
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;c_gfporder
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* acceptable wastage */
id|next
suffix:colon
id|cachep-&gt;c_gfporder
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|cachep-&gt;c_num
op_assign
id|num
suffix:semicolon
multiline_comment|/* try with requested alignment, but reduce it if that will&n;&t; * allow at least some alignment words&n;&t; */
id|words
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|left_over
OL
id|align
)paren
id|align
op_assign
(paren
id|left_over
op_div
id|words
)paren
op_star
id|words
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|align
op_logical_and
id|words
op_le
id|left_over
)paren
(brace
multiline_comment|/* no alignment given, but space enough - give one */
id|align
op_assign
id|words
suffix:semicolon
r_if
c_cond
(paren
id|words
op_eq
id|BYTES_PER_WORD
)paren
(brace
r_if
c_cond
(paren
id|BYTES_PER_WORD
op_star
l_int|4
op_le
id|left_over
)paren
id|align
op_add_assign
id|align
suffix:semicolon
r_if
c_cond
(paren
id|BYTES_PER_WORD
op_star
l_int|8
op_le
id|left_over
)paren
id|align
op_add_assign
id|align
suffix:semicolon
)brace
)brace
id|cachep-&gt;c_align
op_assign
id|align
suffix:semicolon
macro_line|#if&t;0
id|printk
c_func
(paren
l_string|&quot;Size:%lu Orig:%lu Left:%lu Align %lu Pages:%d - %s&bslash;n&quot;
comma
id|size
comma
id|cachep-&gt;c_org_size
comma
id|left_over
comma
id|align
comma
l_int|1
op_lshift
id|cachep-&gt;c_gfporder
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_OFF_SLAB
c_func
(paren
id|flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;OFF SLAB&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;BUFCTL PTRS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* if the bufctl&squot;s are on-slab, c_offset does not inc the size of the bufctl */
r_if
c_cond
(paren
op_logical_neg
id|SLAB_BUFCTL
c_func
(paren
id|flags
)paren
)paren
id|size
op_sub_assign
id|kmem_bufctl_short_size
suffix:semicolon
id|cachep-&gt;c_freep
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;c_flags
op_assign
id|flags
suffix:semicolon
id|cachep-&gt;c_offset
op_assign
id|size
suffix:semicolon
id|cachep-&gt;c_firstp
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;c_lastp
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;c_ctor
op_assign
id|ctor
suffix:semicolon
id|cachep-&gt;c_dtor
op_assign
id|dtor
suffix:semicolon
id|cachep-&gt;c_magic
op_assign
id|SLAB_C_MAGIC
suffix:semicolon
id|cachep-&gt;c_inuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always zero */
id|cachep-&gt;c_name
op_assign
id|name
suffix:semicolon
multiline_comment|/* simply point to the name */
id|cachep-&gt;c_colour
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|align
)paren
id|cachep-&gt;c_colour
op_add_assign
(paren
id|left_over
op_div
id|align
)paren
suffix:semicolon
id|cachep-&gt;c_colour_next
op_assign
id|cachep-&gt;c_colour
suffix:semicolon
multiline_comment|/* warn on dup cache names */
id|searchp
op_assign
op_amp
id|cache_cache
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|searchp-&gt;c_name
comma
id|name
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%sDup name - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|searchp
op_assign
id|searchp-&gt;c_nextp
suffix:semicolon
)brace
r_while
c_loop
(paren
id|searchp
op_ne
op_amp
id|cache_cache
)paren
suffix:semicolon
id|cachep-&gt;c_nextp
op_assign
id|cache_cache.c_nextp
suffix:semicolon
id|cache_cache.c_nextp
op_assign
id|cachep
suffix:semicolon
r_return
id|cachep
suffix:semicolon
id|opps
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%sOut of mem creating cache %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Destroy all the objs in a slab, and release the mem back to the system.&n; * Before calling the slab must have been unlinked&n; */
r_static
r_void
DECL|function|kmem_slab_destroy
id|kmem_slab_destroy
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
comma
r_int
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;c_dtor
op_logical_or
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
id|kmem_bufctl_t
op_star
id|bufp
op_assign
id|slabp-&gt;s_freep
suffix:semicolon
multiline_comment|/* for each obj in slab... */
r_while
c_loop
(paren
id|bufp
)paren
(brace
id|kmem_bufctl_t
op_star
id|freep
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_dtor
)paren
(brace
r_void
op_star
id|objp
op_assign
(paren
(paren
r_void
op_star
)paren
id|bufp
)paren
op_minus
id|cachep-&gt;c_offset
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|objp
op_assign
id|bufp-&gt;buf_objp
suffix:semicolon
(paren
id|cachep-&gt;c_dtor
)paren
(paren
id|objp
comma
id|cachep-&gt;c_org_size
comma
id|flags
)paren
suffix:semicolon
)brace
id|freep
op_assign
id|bufp
suffix:semicolon
id|bufp
op_assign
id|bufp-&gt;buf_nextp
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_bufctl
comma
id|freep
)paren
suffix:semicolon
)brace
)brace
id|slabp-&gt;s_magic
op_assign
id|SLAB_MAGIC_UNALLOC
suffix:semicolon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|slabp-&gt;s_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_OFF_SLAB
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_slab
comma
id|slabp
)paren
suffix:semicolon
)brace
multiline_comment|/* Destroy (remove) a cache.&n; * All objs in the cache should be inactive&n; */
r_int
DECL|function|kmem_cache_destroy
id|kmem_cache_destroy
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|kmem_cache_t
op_star
op_star
id|searchp
suffix:semicolon
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
macro_line|#if&t;defined(SLAB_MGMT_CHECKS)
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_dest: NULL ptr&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_dest: Called during int - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
id|err_end
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_MGMT_CHECKS */
multiline_comment|/* unlink the cache from the chain of active caches.&n;&t; * Note: the chain is never modified during an int&n;&t; */
id|searchp
op_assign
op_amp
(paren
id|cache_cache.c_nextp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|searchp
op_ne
op_amp
id|cache_cache
suffix:semicolon
id|searchp
op_assign
op_amp
(paren
(paren
op_star
id|searchp
)paren
op_member_access_from_pointer
id|c_nextp
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|searchp
op_ne
id|cachep
)paren
r_continue
suffix:semicolon
r_goto
id|good_cache
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_dest: Invalid cache addr %p&bslash;n&quot;
comma
id|cachep
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|good_cache
suffix:colon
multiline_comment|/* disable cache so attempts to allocated from an int can&n;&t; * be caught.&n;&t; */
id|save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_freep
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_dest: active cache - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
op_star
id|searchp
op_assign
id|cachep-&gt;c_nextp
suffix:semicolon
multiline_comment|/* remove from cache chain */
id|cachep-&gt;c_flags
op_or_assign
id|SLAB_CFLGS_RELEASED
suffix:semicolon
id|cachep-&gt;c_freep
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep
op_eq
id|clock_searchp
)paren
id|clock_searchp
op_assign
id|cachep-&gt;c_nextp
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|slabp
op_assign
id|cachep-&gt;c_firstp
)paren
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
(brace
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|kmem_slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_hash
comma
id|cachep-&gt;c_hashp
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Shrink a cache, ie. remove _all_ inactive slabs.&n; * Can be called when a user of a cache knows they are not going to be&n; * needing any new objs for a while.&n; * NOTE: This func is probably going to disappear - let me know if you&n; * are using it!&n; */
r_int
DECL|function|kmem_cache_shrink
id|kmem_cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|wait
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|dtor_flags
suffix:semicolon
r_int
r_int
id|save_flags
comma
id|num_freed
op_assign
l_int|0
suffix:semicolon
macro_line|#if&t;defined(SLAB_MGMT_CHECKS)
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_shrink: NULL ptr&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_shrink: Called during int - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_MGMT_CHECKS */
id|dtor_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
multiline_comment|/* not allowed to wait */
id|dtor_flags
op_assign
id|SLAB_DTOR_ATOMIC
suffix:semicolon
id|save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|0
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|slabp
op_assign
id|cachep-&gt;c_lastp
suffix:semicolon
r_if
c_cond
(paren
id|slabp
op_eq
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
op_logical_or
id|slabp-&gt;s_inuse
)paren
(brace
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_freep
op_eq
id|slabp
)paren
id|cachep-&gt;c_freep
op_assign
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|num_freed
op_increment
suffix:semicolon
id|kmem_slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
comma
id|dtor_flags
)paren
suffix:semicolon
)brace
id|end
suffix:colon
r_return
id|num_freed
suffix:semicolon
)brace
multiline_comment|/* Search for a slab whose objs are suitable for DMA.&n; * Note: since testing the first free slab (in __kmem_cache_alloc()),&n; * ints must not have been enabled!&n; */
r_static
r_inline
id|kmem_slab_t
op_star
DECL|function|kmem_cache_search_dma
id|kmem_cache_search_dma
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
op_assign
id|cachep-&gt;c_freep-&gt;s_nextp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp
op_assign
id|slabp-&gt;s_nextp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp-&gt;s_flags
op_amp
id|SLAB_SFLGS_DMA
)paren
)paren
r_continue
suffix:semicolon
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|kmem_slab_link_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_return
id|slabp
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* get the mem for a slab mgmt obj */
r_static
r_inline
id|kmem_slab_t
op_star
DECL|function|kmem_cache_slabmgmt
id|kmem_cache_slabmgmt
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
comma
r_int
r_int
id|local_flags
comma
r_int
r_int
id|offset
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_OFF_SLAB
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
multiline_comment|/* slab mngmnt obj is off-slab */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp
op_assign
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_slab
comma
id|local_flags
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* slab mngmnt at end of slab mem */
id|slabp
op_assign
id|objp
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;c_gfporder
)paren
suffix:semicolon
id|slabp
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SLAB_PTR_IN_OBJ
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
multiline_comment|/* A bit of extra help for the L1 cache; try to position the slab&n;&t;&t;&t; * mgmnt struct at different offsets within the gap at the end&n;&t;&t;&t; * of a slab.  This helps avoid thrashing the h/w cache lines,&n;&t;&t;&t; * that map to the end of a page, too much...&n;&t;&t;&t; */
r_int
r_int
id|gap
op_assign
id|cachep-&gt;c_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|gap
op_add_assign
id|kmem_bufctl_short_size
suffix:semicolon
id|gap
op_assign
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;c_gfporder
)paren
op_minus
(paren
(paren
id|gap
op_star
id|cachep-&gt;c_num
)paren
op_plus
id|offset
op_plus
r_sizeof
(paren
op_star
id|slabp
)paren
)paren
suffix:semicolon
id|gap
op_div_assign
(paren
r_sizeof
(paren
op_star
id|slabp
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|gap
op_mul_assign
(paren
r_sizeof
(paren
op_star
id|slabp
)paren
op_div
l_int|2
)paren
suffix:semicolon
id|slabp
op_assign
(paren
(paren
(paren
r_void
op_star
)paren
id|slabp
)paren
op_minus
id|gap
)paren
suffix:semicolon
)brace
)brace
id|slabp-&gt;s_flags
op_assign
id|slabp-&gt;s_inuse
op_assign
id|slabp-&gt;s_jiffies
op_assign
l_int|0
suffix:semicolon
r_return
id|slabp
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|kmem_cache_init_objs
id|kmem_cache_init_objs
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
comma
r_void
op_star
id|objp
comma
r_int
r_int
id|local_flags
comma
r_int
r_int
id|ctor_flags
)paren
(brace
id|kmem_bufctl_t
op_star
op_star
id|bufpp
op_assign
op_amp
id|slabp-&gt;s_freep
suffix:semicolon
r_int
r_int
id|num
op_assign
id|cachep-&gt;c_num
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|bufpp
op_assign
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_bufctl
comma
id|local_flags
)paren
)paren
)paren
(brace
id|kmem_slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
(paren
op_star
id|bufpp
)paren
op_member_access_from_pointer
id|buf_objp
op_assign
id|objp
suffix:semicolon
(paren
op_star
id|bufpp
)paren
op_member_access_from_pointer
id|buf_hashp
op_assign
op_amp
id|cachep-&gt;c_hashp
(braket
id|kmem_hash
c_func
(paren
id|cachep
comma
id|objp
)paren
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;c_ctor
)paren
id|cachep
op_member_access_from_pointer
id|c_ctor
c_func
(paren
id|objp
comma
id|cachep-&gt;c_org_size
comma
id|ctor_flags
)paren
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
)paren
op_assign
id|SLAB_RED_MAGIC1
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|objp
op_add_assign
id|cachep-&gt;c_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
op_star
id|bufpp
op_assign
id|objp
suffix:semicolon
id|objp
op_add_assign
id|kmem_bufctl_short_size
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SLAB_PTR_IN_OBJ
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(paren
op_star
id|bufpp
)paren
op_member_access_from_pointer
id|buf_slabp
op_assign
id|slabp
suffix:semicolon
id|bufpp
op_assign
op_amp
(paren
op_star
id|bufpp
)paren
op_member_access_from_pointer
id|buf_nextp
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|num
)paren
suffix:semicolon
op_star
id|bufpp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Grow (by 1) the number of slabs within a cache.&n; * This is called by kmem_cache_alloc() when there are no&n; * inactive objs left in a cache&n; */
r_static
r_void
DECL|function|kmem_cache_grow
id|kmem_cache_grow
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_int
r_int
id|offset
comma
id|dma
suffix:semicolon
r_int
r_int
id|ctor_flags
comma
id|local_flags
comma
id|save_flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_NO_GROW
)paren
r_return
suffix:semicolon
multiline_comment|/* caller doesn&squot;t want us to grow */
id|save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
multiline_comment|/* The test for missing atomic flag is performed here, rather than&n;&t; * the more obvious place, simply to reduce the critical path length&n;&t; * in kmem_cache_alloc().  If a caller is slightly mis-behaving,&n;&t; * will eventually be caught here (where it matters)&n;&t; */
r_if
c_cond
(paren
id|intr_count
op_logical_and
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
op_ne
id|SLAB_ATOMIC
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_grow: Called nonatomically from &quot;
l_string|&quot;int - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|flags
op_and_assign
op_complement
id|SLAB_LEVEL_MASK
suffix:semicolon
id|flags
op_or_assign
id|SLAB_ATOMIC
suffix:semicolon
)brace
id|local_flags
op_assign
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
suffix:semicolon
id|ctor_flags
op_assign
id|SLAB_CTOR_CONSTRUCTOR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
op_eq
id|SLAB_ATOMIC
)paren
(brace
multiline_comment|/* Not allowed to sleep.&n;&t;&t; * Need to tell a constructor about this - it&n;&t;&t; * might need to know....&n;&t;&t; */
id|ctor_flags
op_or_assign
id|SLAB_CTOR_ATOMIC
suffix:semicolon
)brace
id|slabp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get mem for the objs */
r_if
c_cond
(paren
op_logical_neg
(paren
id|objp
op_assign
id|kmem_getpages
c_func
(paren
id|cachep
comma
id|flags
comma
op_amp
id|dma
)paren
)paren
)paren
r_goto
id|opps1
suffix:semicolon
multiline_comment|/* get colour for the slab, and cal the next value */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|offset
op_assign
op_decrement
(paren
id|cachep-&gt;c_colour_next
)paren
)paren
)paren
id|cachep-&gt;c_colour_next
op_assign
id|cachep-&gt;c_colour
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|offset
op_mul_assign
id|cachep-&gt;c_align
suffix:semicolon
multiline_comment|/* get slab mgmt */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp
op_assign
id|kmem_cache_slabmgmt
c_func
(paren
id|cachep
comma
id|objp
comma
id|local_flags
comma
id|offset
)paren
)paren
)paren
r_goto
id|opps2
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
id|slabp-&gt;s_flags
op_assign
id|SLAB_SFLGS_DMA
suffix:semicolon
id|slabp-&gt;s_mem
op_assign
id|objp
suffix:semicolon
id|objp
op_add_assign
id|offset
suffix:semicolon
multiline_comment|/* address of first object */
multiline_comment|/* For on-slab bufctls, c_offset is the distance between the start of&n;&t; * an obj and its related bufctl.  For off-slab bufctls, c_offset is&n;&t; * the distance between objs in the slab.&n;&t; * Reason for bufctl at end of obj (when on slab), as opposed to the front;&n;&t; * if stored within the obj (has no state), and the obj is &squot;used&squot; after being&n;&t; * freed then (normally) most activity occurs at the beginning of the obj.&n;&t; * By keeping the bufctl ptr away from the front, should reduce the chance of&n;&t; * corruption.  Also, allows easier alignment of objs onto cache lines when&n;&t; * bufctl is not stored with the objs.&n;&t; * Downsize; if, while an obj is active, a write is made past its end, then the&n;&t; * bufctl will be corrupted :(&n;&t; */
r_if
c_cond
(paren
id|kmem_cache_init_objs
c_func
(paren
id|cachep
comma
id|slabp
comma
id|objp
comma
id|local_flags
comma
id|ctor_flags
)paren
)paren
r_goto
id|no_objs
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make slab active */
id|slabp-&gt;s_magic
op_assign
id|SLAB_MAGIC_ALLOC
suffix:semicolon
id|kmem_slab_link_end
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;c_freep
op_eq
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
id|cachep-&gt;c_freep
op_assign
id|slabp
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|no_objs
suffix:colon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|slabp-&gt;s_mem
)paren
suffix:semicolon
id|opps2
suffix:colon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|opps1
suffix:colon
r_if
c_cond
(paren
id|slabp
op_logical_and
id|SLAB_OFF_SLAB
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_slab
comma
id|slabp
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;kmem_alloc: Out of mem - %s&bslash;n&quot;, cachep-&gt;c_name); */
r_return
suffix:semicolon
)brace
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
multiline_comment|/* Perform extra freeing checks.&n; * Currently, this check is only for caches that use bufctl structures&n; * within the slab.  Those which use bufctl&squot;s from the internal cache&n; * have a reasonable check when the address is searched for.&n; */
r_static
r_void
op_star
DECL|function|kmem_extra_free_checks
id|kmem_extra_free_checks
c_func
(paren
r_const
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_bufctl_t
op_star
id|search_bufp
comma
r_const
id|kmem_bufctl_t
op_star
id|bufp
comma
r_void
op_star
id|objp
)paren
(brace
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
r_goto
id|end
suffix:semicolon
multiline_comment|/* check slab&squot;s freelist to see if this obj is there */
r_for
c_loop
(paren
suffix:semicolon
id|search_bufp
suffix:semicolon
id|search_bufp
op_assign
id|search_bufp-&gt;buf_nextp
)paren
(brace
r_if
c_cond
(paren
id|search_bufp
op_ne
id|bufp
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: Double free detected during checking &quot;
l_string|&quot;%p - %s&bslash;n&quot;
comma
id|objp
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|end
suffix:colon
r_return
id|objp
suffix:semicolon
)brace
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
r_static
r_inline
r_void
DECL|function|kmem_cache_full_free
id|kmem_cache_full_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;s_nextp-&gt;s_inuse
)paren
r_return
suffix:semicolon
multiline_comment|/* at correct position */
id|slabp-&gt;s_jiffies
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* set release time */
r_if
c_cond
(paren
id|cachep-&gt;c_freep
op_eq
id|slabp
)paren
id|cachep-&gt;c_freep
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|kmem_slab_link_end
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|kmem_cache_one_free
id|kmem_cache_one_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|kmem_slab_t
op_star
id|slabp
)paren
(brace
r_if
c_cond
(paren
id|slabp-&gt;s_nextp-&gt;s_inuse
op_ne
id|cachep-&gt;c_num
)paren
(brace
id|cachep-&gt;c_freep
op_assign
id|slabp
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kmem_slab_unlink
c_func
(paren
id|slabp
)paren
suffix:semicolon
id|kmem_slab_link_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Returns a ptr to an obj in the given cache.&n; * The obj is in the initial state (if there is one)&n; */
r_static
r_inline
r_void
op_star
DECL|function|__kmem_cache_alloc
id|__kmem_cache_alloc
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
id|kmem_bufctl_t
op_star
id|bufp
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|nul_ptr
suffix:semicolon
id|save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get slab alloc is to come from */
id|slabp
op_assign
id|cachep-&gt;c_freep
suffix:semicolon
multiline_comment|/* magic is a sanity check _and_ says if we need a new slab */
r_if
c_cond
(paren
id|slabp-&gt;s_magic
op_ne
id|SLAB_MAGIC_ALLOC
)paren
r_goto
id|alloc_new_slab
suffix:semicolon
id|try_again
suffix:colon
multiline_comment|/* DMA allocations are &squot;rare&squot; - keep out of critical path */
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_DMA
)paren
r_goto
id|search_dma
suffix:semicolon
id|try_again_dma
suffix:colon
id|slabp-&gt;s_inuse
op_increment
suffix:semicolon
id|bufp
op_assign
id|slabp-&gt;s_freep
suffix:semicolon
id|slabp-&gt;s_freep
op_assign
id|bufp-&gt;buf_nextp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
multiline_comment|/* Nasty - we want the &squot;if&squot; to be taken in the common case */
r_if
c_cond
(paren
id|slabp-&gt;s_freep
)paren
(brace
id|short_finished
suffix:colon
id|objp
op_assign
(paren
(paren
r_void
op_star
)paren
id|bufp
)paren
op_minus
id|cachep-&gt;c_offset
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
r_goto
id|red_zone
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
r_return
id|objp
suffix:semicolon
)brace
r_else
(brace
id|cachep-&gt;c_freep
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
r_goto
id|short_finished
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;s_freep
)paren
id|cachep-&gt;c_freep
op_assign
id|slabp-&gt;s_nextp
suffix:semicolon
multiline_comment|/* link into hash chain */
id|objp
op_assign
id|kmem_add_to_hash
c_func
(paren
id|cachep
comma
id|bufp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
r_if
c_cond
(paren
op_logical_neg
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
)paren
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
r_return
id|objp
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
id|red_zone
suffix:colon
multiline_comment|/* set alloc red-zone, and check old one */
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
comma
id|SLAB_RED_MAGIC2
)paren
op_ne
id|SLAB_RED_MAGIC1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_alloc: Bad redzone %p - %s&bslash;n&quot;
comma
id|objp
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
id|objp
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|search_dma
suffix:colon
r_if
c_cond
(paren
id|slabp-&gt;s_flags
op_amp
id|SLAB_SFLGS_DMA
)paren
r_goto
id|try_again_dma
suffix:semicolon
multiline_comment|/* need to search... */
r_if
c_cond
(paren
(paren
id|slabp
op_assign
id|kmem_cache_search_dma
c_func
(paren
id|cachep
)paren
)paren
)paren
r_goto
id|try_again_dma
suffix:semicolon
id|alloc_new_slab
suffix:colon
multiline_comment|/* Either out of slabs, or magic number corruption */
r_if
c_cond
(paren
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
r_goto
id|bad_slab
suffix:semicolon
multiline_comment|/* need a new slab */
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLAB_RELEASED
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_alloc: destroyed cache&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
multiline_comment|/* Be lazy and only check for valid flags&n;&t; * here (keeping it out of the critical path above)&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|SLAB_DMA
op_or
id|SLAB_LEVEL_MASK
op_or
id|SLAB_NO_GROW
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_alloc: Illegal flgs %lX (correcting) - %s&bslash;n&quot;
comma
id|flags
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
id|flags
op_and_assign
(paren
id|SLAB_DMA
op_or
id|SLAB_LEVEL_MASK
op_or
id|SLAB_NO_GROW
)paren
suffix:semicolon
)brace
id|kmem_cache_grow
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slabp
op_assign
id|cachep-&gt;c_freep
)paren
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
)paren
r_goto
id|try_again
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|end
suffix:colon
r_return
l_int|NULL
suffix:semicolon
id|bad_slab
suffix:colon
multiline_comment|/* v. serious error - maybe panic() here? */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_alloc: Bad slab magic (corruption) - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
id|nul_ptr
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_alloc: NULL ptr&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
multiline_comment|/* Release an obj back to its cache.&n; * If the obj has a constructed state, it should be&n; * in this state _before_ it is released.&n; */
r_static
r_inline
r_void
DECL|function|__kmem_cache_free
id|__kmem_cache_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
id|kmem_bufctl_t
op_star
id|bufp
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
multiline_comment|/* basic sanity checks */
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|nul_cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_goto
id|nul_obj
suffix:semicolon
id|save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
r_goto
id|init_state_check
suffix:semicolon
id|finished_initial
suffix:colon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
r_if
c_cond
(paren
id|SLAB_BUFCTL
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
r_goto
id|bufctl
suffix:semicolon
id|bufp
op_assign
(paren
id|kmem_bufctl_t
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_offset
)paren
suffix:semicolon
multiline_comment|/* get slab for the obj */
r_if
c_cond
(paren
id|SLAB_PTR_IN_OBJ
c_func
(paren
id|cachep-&gt;c_flags
)paren
)paren
(brace
multiline_comment|/* if SLAB_HIGH_PACK is undef, the below is optimised away */
id|slabp
op_assign
(paren
id|kmem_slab_t
op_star
)paren
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|objp
)paren
op_amp
id|PAGE_MASK
)paren
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
id|slabp
op_decrement
suffix:semicolon
)brace
r_else
id|slabp
op_assign
(paren
id|kmem_slab_t
op_star
)paren
id|bufp-&gt;buf_slabp
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;s_magic
op_ne
id|SLAB_MAGIC_ALLOC
)paren
multiline_comment|/* sanity check */
r_goto
id|bad_obj
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
(paren
id|SLAB_DEBUG_FREE
op_or
id|SLAB_RED_ZONE
)paren
)paren
r_goto
id|extra_checks
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|passed_extra
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;s_inuse
)paren
multiline_comment|/* sanity check */
r_goto
id|too_many
suffix:semicolon
id|bufp-&gt;buf_nextp
op_assign
id|slabp-&gt;s_freep
suffix:semicolon
id|slabp-&gt;s_freep
op_assign
id|bufp
suffix:semicolon
r_if
c_cond
(paren
op_decrement
(paren
id|slabp-&gt;s_inuse
)paren
)paren
(brace
r_if
c_cond
(paren
id|bufp-&gt;buf_nextp
)paren
(brace
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kmem_cache_one_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kmem_cache_full_free
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|bufctl
suffix:colon
multiline_comment|/* Off-slab bufctls.  Need to search hash for bufctl, and hence the slab.&n;&t; * No &squot;extra&squot; checks are performed for objs stored this way, finding&n;&t; * the obj a check enough&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bufp
op_assign
id|kmem_remove_from_hash
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
)paren
(brace
id|slabp
op_assign
(paren
id|kmem_slab_t
op_star
)paren
id|bufp-&gt;buf_slabp
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
r_goto
id|red_zone
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
r_goto
id|passed_extra
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: Either bad obj addr or double free: %p - %s&bslash;n&quot;
comma
id|objp
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if&t;defined(SLAB_DEBUG_SUPPORT)
id|red_zone
suffix:colon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;c_org_size
)paren
comma
id|SLAB_RED_MAGIC1
)paren
op_ne
id|SLAB_RED_MAGIC2
)paren
(brace
multiline_comment|/* Either write past end of the object, or a double free */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: Bad redzone %p - %s&bslash;n&quot;
comma
id|objp
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
)brace
r_goto
id|passed_extra
suffix:semicolon
id|init_state_check
suffix:colon
multiline_comment|/* Need to call the slab&squot;s constructor so that&n;&t; * the caller can perform a verify of its state (debugging)&n;&t; */
id|cachep
op_member_access_from_pointer
id|c_ctor
c_func
(paren
id|objp
comma
id|cachep-&gt;c_org_size
comma
id|SLAB_CTOR_CONSTRUCTOR
op_or
id|SLAB_CTOR_VERIFY
)paren
suffix:semicolon
r_goto
id|finished_initial
suffix:semicolon
id|extra_checks
suffix:colon
r_if
c_cond
(paren
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_DEBUG_FREE
)paren
op_logical_and
(paren
id|objp
op_ne
id|kmem_extra_free_checks
c_func
(paren
id|cachep
comma
id|slabp-&gt;s_freep
comma
id|bufp
comma
id|objp
)paren
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;c_flags
op_amp
id|SLAB_RED_ZONE
)paren
r_goto
id|red_zone
suffix:semicolon
r_goto
id|passed_extra
suffix:semicolon
macro_line|#endif&t;/* SLAB_DEBUG_SUPPORT */
id|bad_obj
suffix:colon
multiline_comment|/* The addr of the slab doesn&squot;t contain the correct&n;&t; * magic num&n;&t; */
r_if
c_cond
(paren
id|slabp-&gt;s_magic
op_eq
id|SLAB_MAGIC_UNALLOC
)paren
(brace
multiline_comment|/* magic num says this is an unalloc slab */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: obj %p from destroyed slab - %s&bslash;n&quot;
comma
id|objp
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: Bad obj %p - %s&bslash;n&quot;
comma
id|objp
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
suffix:semicolon
id|too_many
suffix:colon
multiline_comment|/* don&squot;t add to freelist */
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: obj free for slab with no active objs - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
suffix:semicolon
id|nul_obj
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: NULL obj - %s&bslash;n&quot;
comma
id|cachep-&gt;c_name
)paren
suffix:semicolon
r_return
suffix:semicolon
id|nul_cache
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: NULL cache ptr&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
op_star
DECL|function|kmem_cache_alloc
id|kmem_cache_alloc
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_return
id|__kmem_cache_alloc
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|kmem_cache_free
id|kmem_cache_free
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|__kmem_cache_free
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
)brace
r_void
op_star
DECL|function|kmem_alloc
id|kmem_alloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
id|cache_sizes_t
op_star
id|cachep
op_assign
id|cache_sizes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cachep-&gt;cs_size
suffix:semicolon
id|cachep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|cachep-&gt;cs_size
)paren
r_continue
suffix:semicolon
multiline_comment|/* should the inline version be used here? */
r_return
id|kmem_cache_alloc
c_func
(paren
id|cachep-&gt;cs_cachep
comma
id|flags
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_alloc: Size (%lu) too large&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|kmem_free
id|kmem_free
c_func
(paren
r_void
op_star
id|objp
comma
r_int
r_int
id|size
)paren
(brace
id|cache_sizes_t
op_star
id|cachep
op_assign
id|cache_sizes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cachep-&gt;cs_size
suffix:semicolon
id|cachep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|cachep-&gt;cs_size
)paren
r_continue
suffix:semicolon
multiline_comment|/* should the inline version be used here? */
id|kmem_cache_free
c_func
(paren
id|cachep-&gt;cs_cachep
comma
id|objp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_free: Size (%lu) too large - strange&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/* Called from try_to_free_page().&n; * Ideal solution would have a weight for each cache, based on;&n; *&t;o num of fully free slabs&n; *&t;o if the objs have a constructor/deconstructor&n; *&t;o length of time slabs have been fully free (ie. ageing)&n; * This function _cannot_ be called within a int, but it&n; * can be interrupted.&n; */
r_int
DECL|function|kmem_cache_reap
id|kmem_cache_reap
c_func
(paren
r_int
id|pri
comma
r_int
id|dma
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|dtor_flags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|best_jiffie
suffix:semicolon
r_int
r_int
id|now
suffix:semicolon
r_int
id|count
op_assign
l_int|8
suffix:semicolon
id|kmem_slab_t
op_star
id|best_slabp
op_assign
l_int|NULL
suffix:semicolon
id|kmem_cache_t
op_star
id|best_cachep
op_assign
l_int|NULL
suffix:semicolon
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
id|kmem_cache_t
op_star
id|searchp
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
multiline_comment|/* &squot;pri&squot; maps to the number of caches to examine, not the number of slabs.&n;&t; * This avoids only checking the jiffies for slabs in one cache at the&n;&t; * expensive spending more cycles&n;&t; */
id|pri
op_assign
(paren
l_int|9
op_minus
id|pri
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
multiline_comment|/* not allowed to wait */
id|dtor_flags
op_assign
id|SLAB_DTOR_ATOMIC
suffix:semicolon
id|searchp
op_assign
id|clock_searchp
suffix:semicolon
id|save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|now
op_assign
id|jiffies
suffix:semicolon
id|best_jiffie
op_assign
id|now
op_minus
(paren
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* 2secs - avoid heavy thrashing */
r_while
c_loop
(paren
id|pri
op_decrement
)paren
(brace
id|kmem_slab_t
op_star
id|local_slabp
suffix:semicolon
r_int
r_int
id|local_jiffie
suffix:semicolon
r_if
c_cond
(paren
id|searchp
op_eq
op_amp
id|cache_cache
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* sanity check for corruption */
r_if
c_cond
(paren
id|searchp-&gt;c_inuse
op_logical_or
id|searchp-&gt;c_magic
op_ne
id|SLAB_C_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_reap: Corrupted cache struct for %s&bslash;n&quot;
comma
id|searchp-&gt;c_name
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
id|local_slabp
op_assign
l_int|NULL
suffix:semicolon
id|local_jiffie
op_assign
id|now
op_minus
(paren
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* As the fully free slabs, within a cache, have no particular&n;&t;&t; * order, we need to test them all.  Infact, we only check &squot;count&squot;&n;&t;&t; * slabs.&n;&t;&t; */
id|slabp
op_assign
id|searchp-&gt;c_lastp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|count
op_logical_and
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|searchp
)paren
op_logical_and
op_logical_neg
id|slabp-&gt;s_inuse
suffix:semicolon
id|slabp
op_assign
id|slabp-&gt;s_prevp
comma
id|count
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|slabp-&gt;s_jiffies
op_ge
id|local_jiffie
)paren
r_continue
suffix:semicolon
multiline_comment|/* weight caches with a con/decon */
r_if
c_cond
(paren
(paren
id|searchp-&gt;c_ctor
op_logical_or
id|searchp-&gt;c_dtor
)paren
op_logical_and
id|slabp-&gt;s_jiffies
op_ge
(paren
id|local_jiffie
op_minus
(paren
l_int|2
op_star
id|HZ
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* weight caches with high page orders.  Avoids stressing the&n;&t;&t;&t; * VM sub-system by reducing the frequency requests for a large&n;&t;&t;&t; * num of contigious pages&n;&t;&t;&t; */
r_if
c_cond
(paren
id|searchp-&gt;c_gfporder
OG
l_int|1
op_logical_and
id|slabp-&gt;s_jiffies
op_ge
(paren
id|local_jiffie
op_minus
(paren
l_int|4
op_star
id|HZ
)paren
)paren
)paren
r_continue
suffix:semicolon
id|local_jiffie
op_assign
id|slabp-&gt;s_jiffies
suffix:semicolon
id|local_slabp
op_assign
id|slabp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|searchp-&gt;c_gfporder
op_logical_and
(paren
id|now
op_minus
id|local_jiffie
)paren
op_ge
(paren
l_int|300
op_star
id|HZ
)paren
)paren
(brace
multiline_comment|/* an old, one page slab.  Make a quick get away... */
id|pri
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|local_slabp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|count
op_logical_or
id|local_jiffie
OL
id|best_jiffie
)paren
(brace
id|best_slabp
op_assign
id|local_slabp
suffix:semicolon
id|best_jiffie
op_assign
id|local_jiffie
suffix:semicolon
id|best_cachep
op_assign
id|searchp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_break
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|next
suffix:colon
id|searchp
op_assign
id|searchp-&gt;c_nextp
suffix:semicolon
r_if
c_cond
(paren
id|searchp
op_eq
id|clock_searchp
)paren
r_break
suffix:semicolon
id|count
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* # of slabs at which we force a reap */
)brace
multiline_comment|/* only move along with we didn&squot;t find an over allocated cache */
r_if
c_cond
(paren
id|count
)paren
id|clock_searchp
op_assign
id|clock_searchp-&gt;c_nextp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|best_slabp
)paren
r_return
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best_slabp-&gt;s_inuse
)paren
(brace
multiline_comment|/* an object in our selected slab has been&n;&t;&t; * allocated.  This souldn&squot;t happen v. often, so we&n;&t;&t; * simply fail - which isn&squot;t ideal but will do.&n;&t;&t; * NOTE: No test for the case where an obj has been&n;&t;&t; * allocated from the slab, and then freed.  While&n;&t;&t; * this would change our idea of the best slab to&n;&t;&t; * reap, it&squot;s not worth the re-calculation effort.&n;&t;&t; */
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|best_cachep-&gt;c_freep
op_eq
id|best_slabp
)paren
id|best_cachep-&gt;c_freep
op_assign
id|best_slabp-&gt;s_nextp
suffix:semicolon
id|kmem_slab_unlink
c_func
(paren
id|best_slabp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|kmem_slab_destroy
c_func
(paren
id|best_cachep
comma
id|best_slabp
comma
id|dtor_flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* /proc/slabinfo&n; *  cache-name num-active-objs total-objs num-active-slabs total-slabs num-pages-per-slab&n; */
r_int
DECL|function|get_slabinfo
id|get_slabinfo
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
id|kmem_slab_t
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|active_objs
suffix:semicolon
r_int
r_int
id|num_slabs
comma
id|active_slabs
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* output format version, so at least we can change it without _too_&n;&t; * many complaints&n;&t; */
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;slabinfo - version: 1.0&bslash;n&quot;
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|cachep
op_assign
op_amp
id|cache_cache
suffix:semicolon
r_do
(brace
id|active_slabs
op_assign
id|num_slabs
op_assign
id|active_objs
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|slabp
op_assign
id|cachep-&gt;c_firstp
suffix:semicolon
id|slabp
op_ne
id|kmem_slab_end
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|slabp
op_assign
id|slabp-&gt;s_nextp
)paren
(brace
id|num_slabs
op_increment
suffix:semicolon
id|active_objs
op_add_assign
id|slabp-&gt;s_inuse
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;s_inuse
)paren
id|active_slabs
op_increment
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|save_flags
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%-20s%lu %lu %lu %lu %d&bslash;n&quot;
comma
id|cachep-&gt;c_name
comma
id|active_objs
comma
id|cachep-&gt;c_num
op_star
id|num_slabs
comma
id|active_slabs
comma
id|num_slabs
comma
l_int|1
op_lshift
id|cachep-&gt;c_gfporder
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cachep
op_assign
id|cachep-&gt;c_nextp
)paren
op_ne
op_amp
id|cache_cache
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
eof
