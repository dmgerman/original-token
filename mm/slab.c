multiline_comment|/*&n; * linux/mm/slab.c&n; * Written by Mark Hemment, 1996/97.&n; * (markhe@nextd.demon.co.uk)&n; *&n; * kmem_cache_destroy() + some cleanup - 1999 Andrea Arcangeli&n; *&n; * Major cleanup, different bufctl logic, per-cpu arrays&n; *&t;(c) 2000 Manfred Spraul&n; *&n; * An implementation of the Slab Allocator as described in outline in;&n; *&t;UNIX Internals: The New Frontiers by Uresh Vahalia&n; *&t;Pub: Prentice Hall&t;ISBN 0-13-101908-2&n; * or with a little more detail in;&n; *&t;The Slab Allocator: An Object-Caching Kernel Memory Allocator&n; *&t;Jeff Bonwick (Sun Microsystems).&n; *&t;Presented at: USENIX Summer 1994 Technical Conference&n; *&n; *&n; * The memory is organized in caches, one cache for each object type.&n; * (e.g. inode_cache, dentry_cache, buffer_head, vm_area_struct)&n; * Each cache consists out of many slabs (they are small (usually one&n; * page long) and always contiguous), and each slab contains multiple&n; * initialized objects.&n; *&n; * Each cache can only support one memory type (GFP_DMA, GFP_HIGHMEM,&n; * normal). If you need a special memory type, then must create a new&n; * cache for that memory type.&n; *&n; * In order to reduce fragmentation, the slabs are sorted in 3 groups:&n; *   full slabs with 0 free objects&n; *   partial slabs&n; *   empty slabs with no allocated objects&n; *&n; * If partial slabs exist, then new allocations come from these slabs,&n; * otherwise from empty slabs or new slabs are allocated.&n; *&n; * kmem_cache_destroy() CAN CRASH if you try to allocate from the cache&n; * during kmem_cache_destroy(). The caller must prevent concurrent allocs.&n; *&n; * On SMP systems, each cache has a short per-cpu head array, most allocs&n; * and frees go into that array, and if that array overflows, then 1/2&n; * of the entries in the array are given back into the global cache.&n; * This reduces the number of spinlock operations.&n; *&n; * The c_cpuarray may not be read with enabled local interrupts.&n; *&n; * SMP synchronization:&n; *  constructors and destructors are called without any locking.&n; *  Several members in kmem_cache_t and slab_t never change, they&n; *&t;are accessed without any locking.&n; *  The per-cpu arrays are never accessed from the wrong cpu, no locking.&n; *  The non-constant members are protected with a per-cache irq spinlock.&n; *&n; * Further notes from the original documentation:&n; *&n; * 11 April &squot;97.  Started multi-threading - markhe&n; *&t;The global cache-chain is protected by the semaphore &squot;cache_chain_sem&squot;.&n; *&t;The sem is only needed when accessing/extending the cache-chain, which&n; *&t;can never happen inside an interrupt (kmem_cache_create(),&n; *&t;kmem_cache_shrink() and kmem_cache_reap()).&n; *&n; *&t;To prevent kmem_cache_shrink() trying to shrink a &squot;growing&squot; cache (which&n; *&t;maybe be sleeping and therefore not holding the semaphore/lock), the&n; *&t;growing field is used.  This also prevents reaping from a cache.&n; *&n; *&t;At present, each engine can be growing a cache.  This should be blocked.&n; *&n; */
macro_line|#include&t;&lt;linux/config.h&gt;
macro_line|#include&t;&lt;linux/slab.h&gt;
macro_line|#include&t;&lt;linux/interrupt.h&gt;
macro_line|#include&t;&lt;linux/init.h&gt;
macro_line|#include&t;&lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * DEBUG&t;- 1 for kmem_cache_create() to honour; SLAB_DEBUG_INITIAL,&n; *&t;&t;  SLAB_RED_ZONE &amp; SLAB_POISON.&n; *&t;&t;  0 for faster, smaller code (especially in the critical paths).&n; *&n; * STATS&t;- 1 to collect stats for /proc/slabinfo.&n; *&t;&t;  0 for faster, smaller code (especially in the critical paths).&n; *&n; * FORCED_DEBUG&t;- 1 enables SLAB_RED_ZONE and SLAB_POISON (if possible)&n; */
DECL|macro|DEBUG
mdefine_line|#define&t;DEBUG&t;&t;0
DECL|macro|STATS
mdefine_line|#define&t;STATS&t;&t;0
DECL|macro|FORCED_DEBUG
mdefine_line|#define&t;FORCED_DEBUG&t;0
multiline_comment|/*&n; * Parameters for kmem_cache_reap&n; */
DECL|macro|REAP_SCANLEN
mdefine_line|#define REAP_SCANLEN&t;10
DECL|macro|REAP_PERFECT
mdefine_line|#define REAP_PERFECT&t;10
multiline_comment|/* Shouldn&squot;t this be in a header file somewhere? */
DECL|macro|BYTES_PER_WORD
mdefine_line|#define&t;BYTES_PER_WORD&t;&t;sizeof(void *)
multiline_comment|/* Legal flag mask for kmem_cache_create(). */
macro_line|#if DEBUG
DECL|macro|CREATE_MASK
macro_line|# define CREATE_MASK&t;(SLAB_DEBUG_INITIAL | SLAB_RED_ZONE | &bslash;&n;&t;&t;&t; SLAB_POISON | SLAB_HWCACHE_ALIGN | &bslash;&n;&t;&t;&t; SLAB_NO_REAP | SLAB_CACHE_DMA)
macro_line|#else
DECL|macro|CREATE_MASK
macro_line|# define CREATE_MASK&t;(SLAB_HWCACHE_ALIGN | SLAB_NO_REAP | SLAB_CACHE_DMA)
macro_line|#endif
multiline_comment|/*&n; * kmem_bufctl_t:&n; *&n; * Bufctl&squot;s are used for linking objs within a slab&n; * linked offsets.&n; *&n; * This implementaion relies on &quot;struct page&quot; for locating the cache &amp;&n; * slab an object belongs to.&n; * This allows the bufctl structure to be small (one int), but limits&n; * the number of objects a slab (not a cache) can contain when off-slab&n; * bufctls are used. The limit is the size of the largest general cache&n; * that does not use off-slab slabs.&n; * For 32bit archs with 4 kB pages, is this 56.&n; * This is not serious, as it is only for large objects, when it is unwise&n; * to have too many per slab.&n; * Note: This limit can be raised by introducing a general cache whose size&n; * is less than 512 (PAGE_SIZE&lt;&lt;3), but greater than 256.&n; */
DECL|macro|BUFCTL_END
mdefine_line|#define BUFCTL_END 0xffffFFFF
DECL|macro|SLAB_LIMIT
mdefine_line|#define&t;SLAB_LIMIT 0xffffFFFE
DECL|typedef|kmem_bufctl_t
r_typedef
r_int
r_int
id|kmem_bufctl_t
suffix:semicolon
multiline_comment|/* Max number of objs-per-slab for caches which use off-slab slabs.&n; * Needed to avoid a possible looping condition in kmem_cache_grow().&n; */
DECL|variable|offslab_limit
r_static
r_int
r_int
id|offslab_limit
suffix:semicolon
multiline_comment|/*&n; * slab_t&n; *&n; * Manages the objs in a slab. Placed either at the beginning of mem allocated&n; * for a slab, or allocated from an general cache.&n; * Slabs are chained into one ordered list: fully used, partial, then fully&n; * free slabs.&n; */
DECL|struct|slab_s
r_typedef
r_struct
id|slab_s
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|colouroff
r_int
r_int
id|colouroff
suffix:semicolon
DECL|member|s_mem
r_void
op_star
id|s_mem
suffix:semicolon
multiline_comment|/* including colour offset */
DECL|member|inuse
r_int
r_int
id|inuse
suffix:semicolon
multiline_comment|/* num of objs active in slab */
DECL|member|free
id|kmem_bufctl_t
id|free
suffix:semicolon
DECL|typedef|slab_t
)brace
id|slab_t
suffix:semicolon
DECL|macro|slab_bufctl
mdefine_line|#define slab_bufctl(slabp) &bslash;&n;&t;((kmem_bufctl_t *)(((slab_t*)slabp)+1))
multiline_comment|/*&n; * cpucache_t&n; *&n; * Per cpu structures&n; * The limit is stored in the per-cpu structure to reduce the data cache&n; * footprint.&n; */
DECL|struct|cpucache_s
r_typedef
r_struct
id|cpucache_s
(brace
DECL|member|avail
r_int
r_int
id|avail
suffix:semicolon
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
DECL|typedef|cpucache_t
)brace
id|cpucache_t
suffix:semicolon
DECL|macro|cc_entry
mdefine_line|#define cc_entry(cpucache) &bslash;&n;&t;((void **)(((cpucache_t*)cpucache)+1))
DECL|macro|cc_data
mdefine_line|#define cc_data(cachep) &bslash;&n;&t;((cachep)-&gt;cpudata[smp_processor_id()])
multiline_comment|/*&n; * kmem_cache_t&n; *&n; * manages a cache.&n; */
DECL|macro|CACHE_NAMELEN
mdefine_line|#define CACHE_NAMELEN&t;20&t;/* max name length for a slab cache */
DECL|struct|kmem_cache_s
r_struct
id|kmem_cache_s
(brace
multiline_comment|/* 1) each alloc &amp; free */
multiline_comment|/* full, partial first, then free */
DECL|member|slabs
r_struct
id|list_head
id|slabs
suffix:semicolon
DECL|member|firstnotfull
r_struct
id|list_head
op_star
id|firstnotfull
suffix:semicolon
DECL|member|objsize
r_int
r_int
id|objsize
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* constant flags */
DECL|member|num
r_int
r_int
id|num
suffix:semicolon
multiline_comment|/* # of objs per slab */
DECL|member|spinlock
id|spinlock_t
id|spinlock
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|member|batchcount
r_int
r_int
id|batchcount
suffix:semicolon
macro_line|#endif
multiline_comment|/* 2) slab additions /removals */
multiline_comment|/* order of pgs per slab (2^n) */
DECL|member|gfporder
r_int
r_int
id|gfporder
suffix:semicolon
multiline_comment|/* force GFP flags, e.g. GFP_DMA */
DECL|member|gfpflags
r_int
r_int
id|gfpflags
suffix:semicolon
DECL|member|colour
r_int
id|colour
suffix:semicolon
multiline_comment|/* cache colouring range */
DECL|member|colour_off
r_int
r_int
id|colour_off
suffix:semicolon
multiline_comment|/* colour offset */
DECL|member|colour_next
r_int
r_int
id|colour_next
suffix:semicolon
multiline_comment|/* cache colouring */
DECL|member|slabp_cache
id|kmem_cache_t
op_star
id|slabp_cache
suffix:semicolon
DECL|member|growing
r_int
r_int
id|growing
suffix:semicolon
DECL|member|dflags
r_int
r_int
id|dflags
suffix:semicolon
multiline_comment|/* dynamic flags */
multiline_comment|/* constructor func */
DECL|member|ctor
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* de-constructor func */
DECL|member|dtor
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|failures
r_int
r_int
id|failures
suffix:semicolon
multiline_comment|/* 3) cache creation/removal */
DECL|member|name
r_char
id|name
(braket
id|CACHE_NAMELEN
)braket
suffix:semicolon
DECL|member|next
r_struct
id|list_head
id|next
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* 4) per-cpu data */
DECL|member|cpudata
id|cpucache_t
op_star
id|cpudata
(braket
id|NR_CPUS
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if STATS
DECL|member|num_active
r_int
r_int
id|num_active
suffix:semicolon
DECL|member|num_allocations
r_int
r_int
id|num_allocations
suffix:semicolon
DECL|member|high_mark
r_int
r_int
id|high_mark
suffix:semicolon
DECL|member|grown
r_int
r_int
id|grown
suffix:semicolon
DECL|member|reaped
r_int
r_int
id|reaped
suffix:semicolon
DECL|member|errors
r_int
r_int
id|errors
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|member|allochit
id|atomic_t
id|allochit
suffix:semicolon
DECL|member|allocmiss
id|atomic_t
id|allocmiss
suffix:semicolon
DECL|member|freehit
id|atomic_t
id|freehit
suffix:semicolon
DECL|member|freemiss
id|atomic_t
id|freemiss
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* internal c_flags */
DECL|macro|CFLGS_OFF_SLAB
mdefine_line|#define&t;CFLGS_OFF_SLAB&t;0x010000UL&t;/* slab management in own cache */
DECL|macro|CFLGS_OPTIMIZE
mdefine_line|#define&t;CFLGS_OPTIMIZE&t;0x020000UL&t;/* optimized slab lookup */
multiline_comment|/* c_dflags (dynamic flags). Need to hold the spinlock to access this member */
DECL|macro|DFLGS_GROWN
mdefine_line|#define&t;DFLGS_GROWN&t;0x000001UL&t;/* don&squot;t reap a recently grown */
DECL|macro|OFF_SLAB
mdefine_line|#define&t;OFF_SLAB(x)&t;((x)-&gt;flags &amp; CFLGS_OFF_SLAB)
DECL|macro|OPTIMIZE
mdefine_line|#define&t;OPTIMIZE(x)&t;((x)-&gt;flags &amp; CFLGS_OPTIMIZE)
DECL|macro|GROWN
mdefine_line|#define&t;GROWN(x)&t;((x)-&gt;dlags &amp; DFLGS_GROWN)
macro_line|#if STATS
DECL|macro|STATS_INC_ACTIVE
mdefine_line|#define&t;STATS_INC_ACTIVE(x)&t;((x)-&gt;num_active++)
DECL|macro|STATS_DEC_ACTIVE
mdefine_line|#define&t;STATS_DEC_ACTIVE(x)&t;((x)-&gt;num_active--)
DECL|macro|STATS_INC_ALLOCED
mdefine_line|#define&t;STATS_INC_ALLOCED(x)&t;((x)-&gt;num_allocations++)
DECL|macro|STATS_INC_GROWN
mdefine_line|#define&t;STATS_INC_GROWN(x)&t;((x)-&gt;grown++)
DECL|macro|STATS_INC_REAPED
mdefine_line|#define&t;STATS_INC_REAPED(x)&t;((x)-&gt;reaped++)
DECL|macro|STATS_SET_HIGH
mdefine_line|#define&t;STATS_SET_HIGH(x)&t;do { if ((x)-&gt;num_active &gt; (x)-&gt;high_mark) &bslash;&n;&t;&t;&t;&t;&t;(x)-&gt;high_mark = (x)-&gt;num_active; &bslash;&n;&t;&t;&t;&t;} while (0)
DECL|macro|STATS_INC_ERR
mdefine_line|#define&t;STATS_INC_ERR(x)&t;((x)-&gt;errors++)
macro_line|#else
DECL|macro|STATS_INC_ACTIVE
mdefine_line|#define&t;STATS_INC_ACTIVE(x)&t;do { } while (0)
DECL|macro|STATS_DEC_ACTIVE
mdefine_line|#define&t;STATS_DEC_ACTIVE(x)&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCED
mdefine_line|#define&t;STATS_INC_ALLOCED(x)&t;do { } while (0)
DECL|macro|STATS_INC_GROWN
mdefine_line|#define&t;STATS_INC_GROWN(x)&t;do { } while (0)
DECL|macro|STATS_INC_REAPED
mdefine_line|#define&t;STATS_INC_REAPED(x)&t;do { } while (0)
DECL|macro|STATS_SET_HIGH
mdefine_line|#define&t;STATS_SET_HIGH(x)&t;do { } while (0)
DECL|macro|STATS_INC_ERR
mdefine_line|#define&t;STATS_INC_ERR(x)&t;do { } while (0)
macro_line|#endif
macro_line|#if STATS &amp;&amp; defined(CONFIG_SMP)
DECL|macro|STATS_INC_ALLOCHIT
mdefine_line|#define STATS_INC_ALLOCHIT(x)&t;atomic_inc(&amp;(x)-&gt;allochit)
DECL|macro|STATS_INC_ALLOCMISS
mdefine_line|#define STATS_INC_ALLOCMISS(x)&t;atomic_inc(&amp;(x)-&gt;allocmiss)
DECL|macro|STATS_INC_FREEHIT
mdefine_line|#define STATS_INC_FREEHIT(x)&t;atomic_inc(&amp;(x)-&gt;freehit)
DECL|macro|STATS_INC_FREEMISS
mdefine_line|#define STATS_INC_FREEMISS(x)&t;atomic_inc(&amp;(x)-&gt;freemiss)
macro_line|#else
DECL|macro|STATS_INC_ALLOCHIT
mdefine_line|#define STATS_INC_ALLOCHIT(x)&t;do { } while (0)
DECL|macro|STATS_INC_ALLOCMISS
mdefine_line|#define STATS_INC_ALLOCMISS(x)&t;do { } while (0)
DECL|macro|STATS_INC_FREEHIT
mdefine_line|#define STATS_INC_FREEHIT(x)&t;do { } while (0)
DECL|macro|STATS_INC_FREEMISS
mdefine_line|#define STATS_INC_FREEMISS(x)&t;do { } while (0)
macro_line|#endif
macro_line|#if DEBUG
multiline_comment|/* Magic nums for obj red zoning.&n; * Placed in the first word before and the first word after an obj.&n; */
DECL|macro|RED_MAGIC1
mdefine_line|#define&t;RED_MAGIC1&t;0x5A2CF071UL&t;/* when obj is active */
DECL|macro|RED_MAGIC2
mdefine_line|#define&t;RED_MAGIC2&t;0x170FC2A5UL&t;/* when obj is inactive */
multiline_comment|/* ...and for poisoning */
DECL|macro|POISON_BYTE
mdefine_line|#define&t;POISON_BYTE&t;0x5a&t;&t;/* byte value for poisoning */
DECL|macro|POISON_END
mdefine_line|#define&t;POISON_END&t;0xa5&t;&t;/* end-byte of poisoning */
macro_line|#endif
multiline_comment|/* maximum size of an obj (in 2^order pages) */
DECL|macro|MAX_OBJ_ORDER
mdefine_line|#define&t;MAX_OBJ_ORDER&t;5&t;/* 32 pages */
multiline_comment|/*&n; * Do not go above this order unless 0 objects fit into the slab.&n; */
DECL|macro|BREAK_GFP_ORDER_HI
mdefine_line|#define&t;BREAK_GFP_ORDER_HI&t;2
DECL|macro|BREAK_GFP_ORDER_LO
mdefine_line|#define&t;BREAK_GFP_ORDER_LO&t;1
DECL|variable|slab_break_gfp_order
r_static
r_int
id|slab_break_gfp_order
op_assign
id|BREAK_GFP_ORDER_LO
suffix:semicolon
multiline_comment|/*&n; * Absolute limit for the gfp order&n; */
DECL|macro|MAX_GFP_ORDER
mdefine_line|#define&t;MAX_GFP_ORDER&t;5&t;/* 32 pages */
multiline_comment|/* Macros for storing/retrieving the cachep and or slab from the&n; * global &squot;mem_map&squot;. These are used to find the slab an obj belongs to.&n; * With kfree(), these are used to find the cache which an obj belongs to.&n; */
DECL|macro|SET_PAGE_CACHE
mdefine_line|#define&t;SET_PAGE_CACHE(pg,x)  ((pg)-&gt;list.next = (struct list_head *)(x))
DECL|macro|GET_PAGE_CACHE
mdefine_line|#define&t;GET_PAGE_CACHE(pg)    ((kmem_cache_t *)(pg)-&gt;list.next)
DECL|macro|SET_PAGE_SLAB
mdefine_line|#define&t;SET_PAGE_SLAB(pg,x)   ((pg)-&gt;list.prev = (struct list_head *)(x))
DECL|macro|GET_PAGE_SLAB
mdefine_line|#define&t;GET_PAGE_SLAB(pg)     ((slab_t *)(pg)-&gt;list.prev)
multiline_comment|/* Size description struct for general caches. */
DECL|struct|cache_sizes
r_typedef
r_struct
id|cache_sizes
(brace
DECL|member|cs_size
r_int
id|cs_size
suffix:semicolon
DECL|member|cs_cachep
id|kmem_cache_t
op_star
id|cs_cachep
suffix:semicolon
DECL|member|cs_dmacachep
id|kmem_cache_t
op_star
id|cs_dmacachep
suffix:semicolon
DECL|typedef|cache_sizes_t
)brace
id|cache_sizes_t
suffix:semicolon
DECL|variable|cache_sizes
r_static
id|cache_sizes_t
id|cache_sizes
(braket
)braket
op_assign
(brace
macro_line|#if PAGE_SIZE == 4096
(brace
l_int|32
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
macro_line|#endif
(brace
l_int|64
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|128
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|256
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|512
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|1024
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|2048
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|4096
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|8192
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|16384
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|32768
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|65536
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|131072
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* internal cache of cache description objs */
DECL|variable|cache_cache
r_static
id|kmem_cache_t
id|cache_cache
op_assign
(brace
id|slabs
suffix:colon
id|LIST_HEAD_INIT
c_func
(paren
id|cache_cache.slabs
)paren
comma
id|firstnotfull
suffix:colon
op_amp
id|cache_cache.slabs
comma
id|objsize
suffix:colon
r_sizeof
(paren
id|kmem_cache_t
)paren
comma
id|flags
suffix:colon
id|SLAB_NO_REAP
comma
id|spinlock
suffix:colon
id|SPIN_LOCK_UNLOCKED
comma
id|colour_off
suffix:colon
id|L1_CACHE_BYTES
comma
id|name
suffix:colon
l_string|&quot;kmem_cache&quot;
comma
)brace
suffix:semicolon
multiline_comment|/* Guard access to the cache-chain. */
DECL|variable|cache_chain_sem
r_static
r_struct
id|semaphore
id|cache_chain_sem
suffix:semicolon
multiline_comment|/* Place maintainer for reaping. */
DECL|variable|clock_searchp
r_static
id|kmem_cache_t
op_star
id|clock_searchp
op_assign
op_amp
id|cache_cache
suffix:semicolon
DECL|macro|cache_chain
mdefine_line|#define cache_chain (cache_cache.next)
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * chicken and egg problem: delay the per-cpu array allocation&n; * until the general caches are up.&n; */
DECL|variable|g_cpucache_up
r_static
r_int
id|g_cpucache_up
suffix:semicolon
r_static
r_void
id|enable_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
suffix:semicolon
r_static
r_void
id|enable_all_cpucaches
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Cal the num objs, wastage, and bytes left over for a given slab size. */
DECL|function|kmem_cache_estimate
r_static
r_void
id|kmem_cache_estimate
(paren
r_int
r_int
id|gfporder
comma
r_int
id|size
comma
r_int
id|flags
comma
r_int
op_star
id|left_over
comma
r_int
r_int
op_star
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|wastage
op_assign
id|PAGE_SIZE
op_lshift
id|gfporder
suffix:semicolon
r_int
id|extra
op_assign
l_int|0
suffix:semicolon
r_int
id|base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
)paren
(brace
id|base
op_assign
r_sizeof
(paren
id|slab_t
)paren
suffix:semicolon
id|extra
op_assign
r_sizeof
(paren
id|kmem_bufctl_t
)paren
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
op_star
id|size
op_plus
id|L1_CACHE_ALIGN
c_func
(paren
id|base
op_plus
id|i
op_star
id|extra
)paren
op_le
id|wastage
)paren
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|i
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|SLAB_LIMIT
)paren
id|i
op_assign
id|SLAB_LIMIT
suffix:semicolon
op_star
id|num
op_assign
id|i
suffix:semicolon
id|wastage
op_sub_assign
id|i
op_star
id|size
suffix:semicolon
id|wastage
op_sub_assign
id|L1_CACHE_ALIGN
c_func
(paren
id|base
op_plus
id|i
op_star
id|extra
)paren
suffix:semicolon
op_star
id|left_over
op_assign
id|wastage
suffix:semicolon
)brace
multiline_comment|/* Initialisation - setup the `cache&squot; cache. */
DECL|function|kmem_cache_init
r_void
id|__init
id|kmem_cache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|left_over
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cache_chain
)paren
suffix:semicolon
id|kmem_cache_estimate
c_func
(paren
l_int|0
comma
id|cache_cache.objsize
comma
l_int|0
comma
op_amp
id|left_over
comma
op_amp
id|cache_cache.num
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache_cache.num
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|cache_cache.colour
op_assign
id|left_over
op_div
id|cache_cache.colour_off
suffix:semicolon
id|cache_cache.colour_next
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialisation - setup remaining internal and general caches.&n; * Called after the gfp() functions have been enabled, and before smp_init().&n; */
DECL|function|kmem_cache_sizes_init
r_void
id|__init
id|kmem_cache_sizes_init
c_func
(paren
r_void
)paren
(brace
id|cache_sizes_t
op_star
id|sizes
op_assign
id|cache_sizes
suffix:semicolon
r_char
id|name
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Fragmentation resistance on low memory - only use bigger&n;&t; * page orders on machines with more than 32MB of memory.&n;&t; */
r_if
c_cond
(paren
id|num_physpages
OG
(paren
l_int|32
op_lshift
l_int|20
)paren
op_rshift
id|PAGE_SHIFT
)paren
id|slab_break_gfp_order
op_assign
id|BREAK_GFP_ORDER_HI
suffix:semicolon
r_do
(brace
multiline_comment|/* For performance, all the general caches are L1 aligned.&n;&t;&t; * This should be particularly beneficial on SMP boxes, as it&n;&t;&t; * eliminates &quot;false sharing&quot;.&n;&t;&t; * Note for systems short on memory removing the alignment will&n;&t;&t; * allow tighter packing of the smaller caches. */
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;size-%Zd&quot;
comma
id|sizes-&gt;cs_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sizes-&gt;cs_cachep
op_assign
id|kmem_cache_create
c_func
(paren
id|name
comma
id|sizes-&gt;cs_size
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Inc off-slab bufctl limit until the ceiling is hit. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|OFF_SLAB
c_func
(paren
id|sizes-&gt;cs_cachep
)paren
)paren
)paren
(brace
id|offslab_limit
op_assign
id|sizes-&gt;cs_size
op_minus
r_sizeof
(paren
id|slab_t
)paren
suffix:semicolon
id|offslab_limit
op_div_assign
l_int|2
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;size-%Zd(DMA)&quot;
comma
id|sizes-&gt;cs_size
)paren
suffix:semicolon
id|sizes-&gt;cs_dmacachep
op_assign
id|kmem_cache_create
c_func
(paren
id|name
comma
id|sizes-&gt;cs_size
comma
l_int|0
comma
id|SLAB_CACHE_DMA
op_or
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sizes-&gt;cs_dmacachep
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|sizes
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sizes-&gt;cs_size
)paren
suffix:semicolon
)brace
DECL|function|kmem_cpucache_init
r_int
id|__init
id|kmem_cpucache_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|g_cpucache_up
op_assign
l_int|1
suffix:semicolon
id|enable_all_cpucaches
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|kmem_cpucache_init
id|__initcall
c_func
(paren
id|kmem_cpucache_init
)paren
suffix:semicolon
multiline_comment|/* Interface to system&squot;s page allocator. No need to hold the cache-lock.&n; */
DECL|function|kmem_getpages
r_static
r_inline
r_void
op_star
id|kmem_getpages
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * If we requested dmaable memory, we will get it. Even if we&n;&t; * did not request dmaable memory, we might get it, but that&n;&t; * would be relatively rare and ignorable.&n;&t; */
id|flags
op_or_assign
id|cachep-&gt;gfpflags
suffix:semicolon
id|addr
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|flags
comma
id|cachep-&gt;gfporder
)paren
suffix:semicolon
multiline_comment|/* Assume that now we have the pages no one else can legally&n;&t; * messes with the &squot;struct page&squot;s.&n;&t; * However vm_scan() might try to test the structure to see if&n;&t; * it is a named-page or buffer-page.  The members it tests are&n;&t; * of no interest here.....&n;&t; */
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/* Interface to system&squot;s page release. */
DECL|function|kmem_freepages
r_static
r_inline
r_void
id|kmem_freepages
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
r_int
id|i
op_assign
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
multiline_comment|/* free_pages() does not clear the type bit - we do that.&n;&t; * The pages have been unlinked from their cache-slab,&n;&t; * but their &squot;struct page&squot;s might be accessed in&n;&t; * vm_scan(). Shouldn&squot;t be a worry.&n;&t; */
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|PageClearSlab
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|cachep-&gt;gfporder
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
DECL|function|kmem_poison_obj
r_static
r_inline
r_void
id|kmem_poison_obj
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|size
op_assign
id|cachep-&gt;objsize
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|addr
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
id|size
op_sub_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
)brace
id|memset
c_func
(paren
id|addr
comma
id|POISON_BYTE
comma
id|size
)paren
suffix:semicolon
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|addr
op_plus
id|size
op_minus
l_int|1
)paren
op_assign
id|POISON_END
suffix:semicolon
)brace
DECL|function|kmem_check_poison_obj
r_static
r_inline
r_int
id|kmem_check_poison_obj
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|size
op_assign
id|cachep-&gt;objsize
suffix:semicolon
r_void
op_star
id|end
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|addr
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
id|size
op_sub_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
)brace
id|end
op_assign
id|memchr
c_func
(paren
id|addr
comma
id|POISON_END
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ne
(paren
id|addr
op_plus
id|size
op_minus
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Destroy all the objs in a slab, and release the mem back to the system.&n; * Before calling the slab must have been unlinked from the cache.&n; * The cache-lock is not held/needed.&n; */
DECL|function|kmem_slab_destroy
r_static
r_void
id|kmem_slab_destroy
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|slab_t
op_star
id|slabp
)paren
(brace
r_if
c_cond
(paren
id|cachep-&gt;dtor
macro_line|#if DEBUG
op_logical_or
id|cachep-&gt;flags
op_amp
(paren
id|SLAB_POISON
op_or
id|SLAB_RED_ZONE
)paren
macro_line|#endif
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cachep-&gt;dtor
)paren
(paren
id|cachep-&gt;dtor
)paren
(paren
id|objp
comma
id|cachep
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
op_logical_and
id|kmem_check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|slabp-&gt;s_mem
op_minus
id|slabp-&gt;colouroff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|cachep-&gt;slabp_cache
comma
id|slabp
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_create - Create a cache.&n; * @name: A string which is used in /proc/slabinfo to identify this cache.&n; * @size: The size of objects to be created in this cache.&n; * @offset: The offset to use within the page.&n; * @flags: SLAB flags&n; * @ctor: A constructor for the objects.&n; * @dtor: A destructor for the objects.&n; *&n; * Returns a ptr to the cache on success, NULL on failure.&n; * Cannot be called within a int, but can be interrupted.&n; * The @ctor is run when new pages are allocated by the cache&n; * and the @dtor is run before the pages are handed back.&n; * The flags are&n; *&n; * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)&n; * to catch references to uninitialised memory.&n; *&n; * %SLAB_RED_ZONE - Insert `Red&squot; zones around the allocated memory to check&n; * for buffer overruns.&n; *&n; * %SLAB_NO_REAP - Don&squot;t automatically reap this cache when we&squot;re under&n; * memory pressure.&n; *&n; * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware&n; * cacheline.  This can be beneficial if you&squot;re counting cycles as closely&n; * as davem.&n; */
id|kmem_cache_t
op_star
DECL|function|kmem_cache_create
id|kmem_cache_create
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|size
comma
r_int
id|offset
comma
r_int
r_int
id|flags
comma
r_void
(paren
op_star
id|ctor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
comma
r_void
(paren
op_star
id|dtor
)paren
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
)paren
(brace
r_const
r_char
op_star
id|func_nm
op_assign
id|KERN_ERR
l_string|&quot;kmem_create: &quot;
suffix:semicolon
r_int
id|left_over
comma
id|align
comma
id|slab_size
suffix:semicolon
id|kmem_cache_t
op_star
id|cachep
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity checks... these are all serious usage bugs.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|name
)paren
op_logical_or
(paren
(paren
id|strlen
c_func
(paren
id|name
)paren
op_ge
id|CACHE_NAMELEN
op_minus
l_int|1
)paren
)paren
op_logical_or
id|in_interrupt
c_func
(paren
)paren
op_logical_or
(paren
id|size
OL
id|BYTES_PER_WORD
)paren
op_logical_or
(paren
id|size
OG
(paren
l_int|1
op_lshift
id|MAX_OBJ_ORDER
)paren
op_star
id|PAGE_SIZE
)paren
op_logical_or
(paren
id|dtor
op_logical_and
op_logical_neg
id|ctor
)paren
op_logical_or
(paren
id|offset
template_param
id|size
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
op_logical_and
op_logical_neg
id|ctor
)paren
(brace
multiline_comment|/* No constructor, but inital state check requested */
id|printk
c_func
(paren
l_string|&quot;%sNo con, but init state check requested - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_DEBUG_INITIAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SLAB_POISON
)paren
op_logical_and
id|ctor
)paren
(brace
multiline_comment|/* request for poisoning, but we can&squot;t do that with a constructor */
id|printk
c_func
(paren
l_string|&quot;%sPoisoning requested, but con given - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|SLAB_POISON
suffix:semicolon
)brace
macro_line|#if FORCED_DEBUG
r_if
c_cond
(paren
id|size
OL
(paren
id|PAGE_SIZE
op_rshift
l_int|3
)paren
)paren
multiline_comment|/*&n;&t;&t; * do not red zone large object, causes severe&n;&t;&t; * fragmentation.&n;&t;&t; */
id|flags
op_or_assign
id|SLAB_RED_ZONE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctor
)paren
id|flags
op_or_assign
id|SLAB_POISON
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t; * Always checks flags, a caller might be expecting debug&n;&t; * support which isn&squot;t available.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
id|CREATE_MASK
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get cache&squot;s description obj. */
id|cachep
op_assign
(paren
id|kmem_cache_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
op_amp
id|cache_cache
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|opps
suffix:semicolon
id|memset
c_func
(paren
id|cachep
comma
l_int|0
comma
r_sizeof
(paren
id|kmem_cache_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Check that size is in terms of words.  This is needed to avoid&n;&t; * unaligned accesses for some archs when redzoning is used, and makes&n;&t; * sure any on-slab bufctl&squot;s are also correctly aligned.&n;&t; */
r_if
c_cond
(paren
id|size
op_amp
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
)paren
(brace
id|size
op_add_assign
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|BYTES_PER_WORD
op_minus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%sForcing size word alignment - %s&bslash;n&quot;
comma
id|func_nm
comma
id|name
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is no point trying to honour cache alignment&n;&t;&t; * when redzoning.&n;&t;&t; */
id|flags
op_and_assign
op_complement
id|SLAB_HWCACHE_ALIGN
suffix:semicolon
id|size
op_add_assign
l_int|2
op_star
id|BYTES_PER_WORD
suffix:semicolon
multiline_comment|/* words for redzone */
)brace
macro_line|#endif
id|align
op_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
id|align
op_assign
id|L1_CACHE_BYTES
suffix:semicolon
multiline_comment|/* Determine if the slab management is &squot;on&squot; or &squot;off&squot; slab. */
r_if
c_cond
(paren
id|size
op_ge
(paren
id|PAGE_SIZE
op_rshift
l_int|3
)paren
)paren
multiline_comment|/*&n;&t;&t; * Size is large, assume best to place the slab management obj&n;&t;&t; * off-slab (should allow better packing of objs).&n;&t;&t; */
id|flags
op_or_assign
id|CFLGS_OFF_SLAB
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_HWCACHE_ALIGN
)paren
(brace
multiline_comment|/* Need to adjust size so that objs are cache aligned. */
multiline_comment|/* Small obj size, can get at least two per cache line. */
multiline_comment|/* FIXME: only power of 2 supported, was better */
r_while
c_loop
(paren
id|size
OL
id|align
op_div
l_int|2
)paren
id|align
op_div_assign
l_int|2
suffix:semicolon
id|size
op_assign
(paren
id|size
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
(paren
op_complement
(paren
id|align
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Cal size (in pages) of slabs, and the num of objs per slab.&n;&t; * This could be made much more intelligent.  For now, try to avoid&n;&t; * using high page-orders for slabs.  When the gfp() funcs are more&n;&t; * friendly towards high-order requests, this should be changed.&n;&t; */
r_do
(brace
r_int
r_int
id|break_flag
op_assign
l_int|0
suffix:semicolon
id|cal_wastage
suffix:colon
id|kmem_cache_estimate
c_func
(paren
id|cachep-&gt;gfporder
comma
id|size
comma
id|flags
comma
op_amp
id|left_over
comma
op_amp
id|cachep-&gt;num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_flag
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;gfporder
op_ge
id|MAX_GFP_ORDER
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;num
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
op_logical_and
id|cachep-&gt;num
OG
id|offslab_limit
)paren
(brace
multiline_comment|/* Oops, this num of objs will cause problems. */
id|cachep-&gt;gfporder
op_decrement
suffix:semicolon
id|break_flag
op_increment
suffix:semicolon
r_goto
id|cal_wastage
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Large num of objs is good, but v. large slabs are currently&n;&t;&t; * bad for the gfp()s.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;gfporder
op_ge
id|slab_break_gfp_order
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|left_over
op_star
l_int|8
)paren
op_le
(paren
id|PAGE_SIZE
op_lshift
id|cachep-&gt;gfporder
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Acceptable internal fragmentation. */
id|next
suffix:colon
id|cachep-&gt;gfporder
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;num
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kmem_cache_create: couldn&squot;t create cache %s.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
id|cachep
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|opps
suffix:semicolon
)brace
id|slab_size
op_assign
id|L1_CACHE_ALIGN
c_func
(paren
id|cachep-&gt;num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
op_plus
r_sizeof
(paren
id|slab_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the slab has been placed off-slab, and we have enough space then&n;&t; * move it on-slab. This is at the expense of any extra colouring.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
op_logical_and
id|left_over
op_ge
id|slab_size
)paren
(brace
id|flags
op_and_assign
op_complement
id|CFLGS_OFF_SLAB
suffix:semicolon
id|left_over
op_sub_assign
id|slab_size
suffix:semicolon
)brace
multiline_comment|/* Offset must be a multiple of the alignment. */
id|offset
op_add_assign
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
id|offset
op_and_assign
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
id|offset
op_assign
id|L1_CACHE_BYTES
suffix:semicolon
id|cachep-&gt;colour_off
op_assign
id|offset
suffix:semicolon
id|cachep-&gt;colour
op_assign
id|left_over
op_div
id|offset
suffix:semicolon
multiline_comment|/* init remaining fields */
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;gfporder
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
)paren
id|flags
op_or_assign
id|CFLGS_OPTIMIZE
suffix:semicolon
id|cachep-&gt;flags
op_assign
id|flags
suffix:semicolon
id|cachep-&gt;gfpflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_CACHE_DMA
)paren
id|cachep-&gt;gfpflags
op_or_assign
id|GFP_DMA
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;objsize
op_assign
id|size
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cachep-&gt;slabs
)paren
suffix:semicolon
id|cachep-&gt;firstnotfull
op_assign
op_amp
id|cachep-&gt;slabs
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|CFLGS_OFF_SLAB
)paren
id|cachep-&gt;slabp_cache
op_assign
id|kmem_find_general_cachep
c_func
(paren
id|slab_size
comma
l_int|0
)paren
suffix:semicolon
id|cachep-&gt;ctor
op_assign
id|ctor
suffix:semicolon
id|cachep-&gt;dtor
op_assign
id|dtor
suffix:semicolon
multiline_comment|/* Copy name over so we don&squot;t have problems with unloaded modules */
id|strcpy
c_func
(paren
id|cachep-&gt;name
comma
id|name
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|g_cpucache_up
)paren
id|enable_cpucache
c_func
(paren
id|cachep
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Need the semaphore to access the chain. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|pc
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
multiline_comment|/* The name field is constant - no lock needed. */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|pc-&gt;name
comma
id|name
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* There is no reason to lock our new cache before we&n;&t; * link it in - no one knows about it yet...&n;&t; */
id|list_add
c_func
(paren
op_amp
id|cachep-&gt;next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|opps
suffix:colon
r_return
id|cachep
suffix:semicolon
)brace
multiline_comment|/*&n; * This check if the kmem_cache_t pointer is chained in the cache_cache&n; * list. -arca&n; */
DECL|function|is_chained_kmem_cache
r_static
r_int
id|is_chained_kmem_cache
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|cachep-&gt;next
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * Waits for all CPUs to execute func().&n; */
DECL|function|smp_call_function_all_cpus
r_static
r_void
id|smp_call_function_all_cpus
c_func
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|arg
)paren
comma
r_void
op_star
id|arg
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|func
c_func
(paren
id|arg
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_call_function
c_func
(paren
id|func
comma
id|arg
comma
l_int|1
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|struct|ccupdate_struct_s
r_typedef
r_struct
id|ccupdate_struct_s
(brace
DECL|member|cachep
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
DECL|member|new
id|cpucache_t
op_star
r_new
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|typedef|ccupdate_struct_t
)brace
id|ccupdate_struct_t
suffix:semicolon
DECL|function|do_ccupdate_local
r_static
r_void
id|do_ccupdate_local
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|ccupdate_struct_t
op_star
r_new
op_assign
(paren
id|ccupdate_struct_t
op_star
)paren
id|info
suffix:semicolon
id|cpucache_t
op_star
id|old
op_assign
id|cc_data
c_func
(paren
r_new
op_member_access_from_pointer
id|cachep
)paren
suffix:semicolon
id|cc_data
c_func
(paren
r_new
op_member_access_from_pointer
id|cachep
)paren
op_assign
r_new
op_member_access_from_pointer
r_new
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_new
op_member_access_from_pointer
r_new
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|old
suffix:semicolon
)brace
r_static
r_void
id|free_block
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|len
)paren
suffix:semicolon
DECL|function|drain_cpu_caches
r_static
r_void
id|drain_cpu_caches
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|ccupdate_struct_t
r_new
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
op_amp
r_new
dot
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_new
dot
r_new
)paren
)paren
suffix:semicolon
r_new
dot
id|cachep
op_assign
id|cachep
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|smp_call_function_all_cpus
c_func
(paren
id|do_ccupdate_local
comma
(paren
r_void
op_star
)paren
op_amp
r_new
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpucache_t
op_star
id|ccold
op_assign
r_new
dot
r_new
(braket
id|cpu_logical_map
c_func
(paren
id|i
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccold
op_logical_or
(paren
id|ccold-&gt;avail
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
id|cc_entry
c_func
(paren
id|ccold
)paren
comma
id|ccold-&gt;avail
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|ccold-&gt;avail
op_assign
l_int|0
suffix:semicolon
)brace
id|smp_call_function_all_cpus
c_func
(paren
id|do_ccupdate_local
comma
(paren
r_void
op_star
)paren
op_amp
r_new
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|drain_cpu_caches
mdefine_line|#define drain_cpu_caches(cachep)&t;do { } while (0)
macro_line|#endif
DECL|function|__kmem_cache_shrink
r_static
r_int
id|__kmem_cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
id|slab_t
op_star
id|slabp
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|drain_cpu_caches
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
multiline_comment|/* If the cache is growing, stop shrinking. */
r_while
c_loop
(paren
op_logical_neg
id|cachep-&gt;growing
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|p
op_assign
id|cachep-&gt;slabs.prev
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|cachep-&gt;slabs
)paren
r_break
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|cachep-&gt;slabs.prev
comma
id|slab_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
)paren
r_break
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;firstnotfull
op_eq
op_amp
id|slabp-&gt;list
)paren
id|cachep-&gt;firstnotfull
op_assign
op_amp
id|cachep-&gt;slabs
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|kmem_slab_destroy
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cachep-&gt;slabs
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_shrink - Shrink a cache.&n; * @cachep: The cache to shrink.&n; *&n; * Releases as many slabs as possible for a cache.&n; * To help debugging, a zero exit status indicates all slabs were released.&n; */
DECL|function|kmem_cache_shrink
r_int
id|kmem_cache_shrink
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_or
id|in_interrupt
c_func
(paren
)paren
op_logical_or
op_logical_neg
id|is_chained_kmem_cache
c_func
(paren
id|cachep
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|__kmem_cache_shrink
c_func
(paren
id|cachep
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_destroy - delete a cache&n; * @cachep: the cache to destroy&n; *&n; * Remove a kmem_cache_t object from the slab cache.&n; * Returns 0 on success.&n; *&n; * It is expected this function will be called by a module when it is&n; * unloaded.  This will remove the cache completely, and avoid a duplicate&n; * cache being allocated each time a module is loaded and unloaded, if the&n; * module doesn&squot;t have persistent in-kernel storage across loads and unloads.&n; *&n; * The caller must guarantee that noone will allocate memory from the cache&n; * during the kmem_cache_destroy().&n; */
DECL|function|kmem_cache_destroy
r_int
id|kmem_cache_destroy
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cachep
op_logical_or
id|in_interrupt
c_func
(paren
)paren
op_logical_or
id|cachep-&gt;growing
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
multiline_comment|/* the chain is never empty, cache_cache is never destroyed */
r_if
c_cond
(paren
id|clock_searchp
op_eq
id|cachep
)paren
id|clock_searchp
op_assign
id|list_entry
c_func
(paren
id|cachep-&gt;next.next
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cachep-&gt;next
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__kmem_cache_shrink
c_func
(paren
id|cachep
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmem_cache_destroy: Can&squot;t free all objects %p&bslash;n&quot;
comma
id|cachep
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cachep-&gt;next
comma
op_amp
id|cache_chain
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|cachep-&gt;cpudata
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|kmem_cache_free
c_func
(paren
op_amp
id|cache_cache
comma
id|cachep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the memory for a slab management obj. */
DECL|function|kmem_cache_slabmgmt
r_static
r_inline
id|slab_t
op_star
id|kmem_cache_slabmgmt
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
comma
r_int
id|colour_off
comma
r_int
id|local_flags
)paren
(brace
id|slab_t
op_star
id|slabp
suffix:semicolon
r_if
c_cond
(paren
id|OFF_SLAB
c_func
(paren
id|cachep
)paren
)paren
(brace
multiline_comment|/* Slab management obj is off-slab. */
id|slabp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|cachep-&gt;slabp_cache
comma
id|local_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* FIXME: change to&n;&t;&t;&t;slabp = objp&n;&t;&t; * if you enable OPTIMIZE&n;&t;&t; */
id|slabp
op_assign
id|objp
op_plus
id|colour_off
suffix:semicolon
id|colour_off
op_add_assign
id|L1_CACHE_ALIGN
c_func
(paren
id|cachep-&gt;num
op_star
r_sizeof
(paren
id|kmem_bufctl_t
)paren
op_plus
r_sizeof
(paren
id|slab_t
)paren
)paren
suffix:semicolon
)brace
id|slabp-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|slabp-&gt;colouroff
op_assign
id|colour_off
suffix:semicolon
id|slabp-&gt;s_mem
op_assign
id|objp
op_plus
id|colour_off
suffix:semicolon
r_return
id|slabp
suffix:semicolon
)brace
DECL|function|kmem_cache_init_objs
r_static
r_inline
r_void
id|kmem_cache_init_objs
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|slab_t
op_star
id|slabp
comma
r_int
r_int
id|ctor_flags
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cachep-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|cachep-&gt;objsize
op_star
id|i
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_assign
id|RED_MAGIC1
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
)paren
op_assign
id|RED_MAGIC1
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Constructors are not allowed to allocate memory from&n;&t;&t; * the same cache which they are a constructor for.&n;&t;&t; * Otherwise, deadlock. They must also be threaded.&n;&t;&t; */
r_if
c_cond
(paren
id|cachep-&gt;ctor
)paren
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|ctor_flags
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
multiline_comment|/* need to poison the objs */
id|kmem_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
)braket
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|BUFCTL_END
suffix:semicolon
id|slabp-&gt;free
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Grow (by 1) the number of slabs within a cache.  This is called by&n; * kmem_cache_alloc() when there are no active objs left in a cache.&n; */
DECL|function|kmem_cache_grow
r_static
r_int
id|kmem_cache_grow
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
id|slab_t
op_star
id|slabp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
r_int
id|i
comma
id|local_flags
suffix:semicolon
r_int
r_int
id|ctor_flags
suffix:semicolon
r_int
r_int
id|save_flags
suffix:semicolon
multiline_comment|/* Be lazy and only check for valid flags here,&n; &t; * keeping it out of the critical path in kmem_cache_alloc().&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|SLAB_DMA
op_or
id|SLAB_LEVEL_MASK
op_or
id|SLAB_NO_GROW
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_NO_GROW
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The test for missing atomic flag is performed here, rather than&n;&t; * the more obvious place, simply to reduce the critical path length&n;&t; * in kmem_cache_alloc(). If a caller is seriously mis-behaving they&n;&t; * will eventually be caught here (where it matters).&n;&t; */
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_and
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
op_ne
id|SLAB_ATOMIC
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ctor_flags
op_assign
id|SLAB_CTOR_CONSTRUCTOR
suffix:semicolon
id|local_flags
op_assign
(paren
id|flags
op_amp
id|SLAB_LEVEL_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_flags
op_eq
id|SLAB_ATOMIC
)paren
multiline_comment|/*&n;&t;&t; * Not allowed to sleep.  Need to tell a constructor about&n;&t;&t; * this - it might need to know...&n;&t;&t; */
id|ctor_flags
op_or_assign
id|SLAB_CTOR_ATOMIC
suffix:semicolon
multiline_comment|/* About to mess with non-constant members - lock. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cachep-&gt;spinlock
comma
id|save_flags
)paren
suffix:semicolon
multiline_comment|/* Get colour for the slab, and cal the next value. */
id|offset
op_assign
id|cachep-&gt;colour_next
suffix:semicolon
id|cachep-&gt;colour_next
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;colour_next
op_ge
id|cachep-&gt;colour
)paren
id|cachep-&gt;colour_next
op_assign
l_int|0
suffix:semicolon
id|offset
op_mul_assign
id|cachep-&gt;colour_off
suffix:semicolon
id|cachep-&gt;dflags
op_or_assign
id|DFLGS_GROWN
suffix:semicolon
id|cachep-&gt;growing
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;spinlock
comma
id|save_flags
)paren
suffix:semicolon
multiline_comment|/* A series of memory allocations for a new slab.&n;&t; * Neither the cache-chain semaphore, or cache-lock, are&n;&t; * held, but the incrementing c_growing prevents this&n;&t; * cache from being reaped or shrunk.&n;&t; * Note: The cache could be selected in for reaping in&n;&t; * kmem_cache_reap(), but when the final test is made the&n;&t; * growing value will be seen.&n;&t; */
multiline_comment|/* Get mem for the objs. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|objp
op_assign
id|kmem_getpages
c_func
(paren
id|cachep
comma
id|flags
)paren
)paren
)paren
r_goto
id|failed
suffix:semicolon
multiline_comment|/* Get slab management. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|slabp
op_assign
id|kmem_cache_slabmgmt
c_func
(paren
id|cachep
comma
id|objp
comma
id|offset
comma
id|local_flags
)paren
)paren
)paren
r_goto
id|opps1
suffix:semicolon
multiline_comment|/* Nasty!!!!!! I hope this is OK. */
id|i
op_assign
l_int|1
op_lshift
id|cachep-&gt;gfporder
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
suffix:semicolon
r_do
(brace
id|SET_PAGE_CACHE
c_func
(paren
id|page
comma
id|cachep
)paren
suffix:semicolon
id|SET_PAGE_SLAB
c_func
(paren
id|page
comma
id|slabp
)paren
suffix:semicolon
id|PageSetSlab
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
id|kmem_cache_init_objs
c_func
(paren
id|cachep
comma
id|slabp
comma
id|ctor_flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cachep-&gt;spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|cachep-&gt;growing
op_decrement
suffix:semicolon
multiline_comment|/* Make slab active. */
id|list_add_tail
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|cachep-&gt;slabs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;firstnotfull
op_eq
op_amp
id|cachep-&gt;slabs
)paren
id|cachep-&gt;firstnotfull
op_assign
op_amp
id|slabp-&gt;list
suffix:semicolon
id|STATS_INC_GROWN
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cachep-&gt;failures
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|opps1
suffix:colon
id|kmem_freepages
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|failed
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cachep-&gt;spinlock
comma
id|save_flags
)paren
suffix:semicolon
id|cachep-&gt;growing
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cachep-&gt;spinlock
comma
id|save_flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform extra freeing checks:&n; * - detect double free&n; * - detect bad pointers.&n; * Called with the cache-lock held.&n; */
macro_line|#if DEBUG
DECL|function|kmem_extra_free_checks
r_static
r_int
id|kmem_extra_free_checks
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|slab_t
op_star
id|slabp
comma
r_void
op_star
id|objp
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|objnr
op_assign
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;objsize
suffix:semicolon
r_if
c_cond
(paren
id|objnr
op_ge
id|cachep-&gt;num
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|objp
op_ne
id|slabp-&gt;s_mem
op_plus
id|objnr
op_star
id|cachep-&gt;objsize
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check slab&squot;s freelist to see if this obj is there. */
r_for
c_loop
(paren
id|i
op_assign
id|slabp-&gt;free
suffix:semicolon
id|i
op_ne
id|BUFCTL_END
suffix:semicolon
id|i
op_assign
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|objnr
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|kmem_cache_alloc_head
r_static
r_inline
r_void
id|kmem_cache_alloc_head
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
macro_line|#if DEBUG
r_if
c_cond
(paren
id|flags
op_amp
id|SLAB_DMA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cachep-&gt;gfpflags
op_amp
id|GFP_DMA
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cachep-&gt;gfpflags
op_amp
id|GFP_DMA
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|kmem_cache_alloc_one_tail
r_static
r_inline
r_void
op_star
id|kmem_cache_alloc_one_tail
(paren
id|kmem_cache_t
op_star
id|cachep
comma
id|slab_t
op_star
id|slabp
)paren
(brace
r_void
op_star
id|objp
suffix:semicolon
id|STATS_INC_ALLOCED
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_INC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|STATS_SET_HIGH
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* get obj pointer */
id|slabp-&gt;inuse
op_increment
suffix:semicolon
id|objp
op_assign
id|slabp-&gt;s_mem
op_plus
id|slabp-&gt;free
op_star
id|cachep-&gt;objsize
suffix:semicolon
id|slabp-&gt;free
op_assign
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|slabp-&gt;free
)braket
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;free
op_eq
id|BUFCTL_END
)paren
multiline_comment|/* slab now full: move to next slab for next alloc */
id|cachep-&gt;firstnotfull
op_assign
id|slabp-&gt;list.next
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
r_if
c_cond
(paren
id|kmem_check_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
multiline_comment|/* Set alloc red-zone, and check old one. */
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|objp
comma
id|RED_MAGIC2
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
comma
id|RED_MAGIC2
)paren
op_ne
id|RED_MAGIC1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|objp
op_add_assign
id|BYTES_PER_WORD
suffix:semicolon
)brace
macro_line|#endif
r_return
id|objp
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns a ptr to an obj in the given cache.&n; * caller must guarantee synchronization&n; * #define for the goto optimization 8-)&n; */
DECL|macro|kmem_cache_alloc_one
mdefine_line|#define kmem_cache_alloc_one(cachep)&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;slab_t&t;*slabp;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* Get slab alloc is to come from. */&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;struct list_head* p = cachep-&gt;firstnotfull;&t;&bslash;&n;&t;&t;if (p == &amp;cachep-&gt;slabs)&t;&t;&t;&bslash;&n;&t;&t;&t;goto alloc_new_slab;&t;&t;&t;&bslash;&n;&t;&t;slabp = list_entry(p,slab_t, list);&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;kmem_cache_alloc_one_tail(cachep, slabp);&t;&t;&bslash;&n;})
macro_line|#ifdef CONFIG_SMP
DECL|function|kmem_cache_alloc_batch
r_void
op_star
id|kmem_cache_alloc_batch
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_int
id|batchcount
op_assign
id|cachep-&gt;batchcount
suffix:semicolon
id|cpucache_t
op_star
id|cc
op_assign
id|cc_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|batchcount
op_decrement
)paren
(brace
multiline_comment|/* Get slab alloc is to come from. */
r_struct
id|list_head
op_star
id|p
op_assign
id|cachep-&gt;firstnotfull
suffix:semicolon
id|slab_t
op_star
id|slabp
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|cachep-&gt;slabs
)paren
r_break
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|slab_t
comma
id|list
)paren
suffix:semicolon
id|cc_entry
c_func
(paren
id|cc
)paren
(braket
id|cc-&gt;avail
op_increment
)braket
op_assign
id|kmem_cache_alloc_one_tail
c_func
(paren
id|cachep
comma
id|slabp
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;avail
)paren
r_return
id|cc_entry
c_func
(paren
id|cc
)paren
(braket
op_decrement
id|cc-&gt;avail
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
DECL|function|__kmem_cache_alloc
r_static
r_inline
r_void
op_star
id|__kmem_cache_alloc
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|save_flags
suffix:semicolon
r_void
op_star
id|objp
suffix:semicolon
id|kmem_cache_alloc_head
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
id|try_again
suffix:colon
id|local_irq_save
c_func
(paren
id|save_flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
(brace
id|cpucache_t
op_star
id|cc
op_assign
id|cc_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
)paren
(brace
r_if
c_cond
(paren
id|cc-&gt;avail
)paren
(brace
id|STATS_INC_ALLOCHIT
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|objp
op_assign
id|cc_entry
c_func
(paren
id|cc
)paren
(braket
op_decrement
id|cc-&gt;avail
)braket
suffix:semicolon
)brace
r_else
(brace
id|STATS_INC_ALLOCMISS
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|objp
op_assign
id|kmem_cache_alloc_batch
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_goto
id|alloc_new_slab_nolock
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|objp
op_assign
id|kmem_cache_alloc_one
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
id|objp
op_assign
id|kmem_cache_alloc_one
c_func
(paren
id|cachep
)paren
suffix:semicolon
macro_line|#endif
id|local_irq_restore
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_return
id|objp
suffix:semicolon
id|alloc_new_slab
suffix:colon
macro_line|#ifdef CONFIG_SMP
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|alloc_new_slab_nolock
suffix:colon
macro_line|#endif
id|local_irq_restore
c_func
(paren
id|save_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_grow
c_func
(paren
id|cachep
comma
id|flags
)paren
)paren
multiline_comment|/* Someone may have stolen our objs.  Doesn&squot;t matter, we&squot;ll&n;&t;&t; * just come back here again.&n;&t;&t; */
r_goto
id|try_again
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Release an obj back to its cache. If the obj has a constructed&n; * state, it should be in this state _before_ it is released.&n; * - caller is responsible for the synchronization&n; */
macro_line|#if DEBUG
DECL|macro|CHECK_NR
macro_line|# define CHECK_NR(pg)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!VALID_PAGE(pg)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;printk(KERN_ERR &quot;kfree: out of range ptr %lxh.&bslash;n&quot;, &bslash;&n;&t;&t;&t;&t;(unsigned long)objp);&t;&t;&bslash;&n;&t;&t;&t;BUG();&t;&t;&t;&t;&t;&bslash;&n;&t;&t;} &bslash;&n;&t;} while (0)
DECL|macro|CHECK_PAGE
macro_line|# define CHECK_PAGE(page)&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;CHECK_NR(page);&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!PageSlab(page)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;printk(KERN_ERR &quot;kfree: bad ptr %lxh.&bslash;n&quot;, &bslash;&n;&t;&t;&t;&t;(unsigned long)objp);&t;&t;&bslash;&n;&t;&t;&t;BUG();&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
macro_line|#else
DECL|macro|CHECK_PAGE
macro_line|# define CHECK_PAGE(pg)&t;do { } while (0)
macro_line|#endif
DECL|function|kmem_cache_free_one
r_static
r_inline
r_void
id|kmem_cache_free_one
c_func
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
id|slab_t
op_star
id|slabp
suffix:semicolon
id|CHECK_PAGE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
multiline_comment|/* reduces memory footprint&n;&t; *&n;&t;if (OPTIMIZE(cachep))&n;&t;&t;slabp = (void*)((unsigned long)objp&amp;(~(PAGE_SIZE-1)));&n;&t; else&n;&t; */
id|slabp
op_assign
id|GET_PAGE_SLAB
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_DEBUG_INITIAL
)paren
multiline_comment|/* Need to call the slab&squot;s constructor so the&n;&t;&t; * caller can perform a verify of its state (debugging).&n;&t;&t; * Called without the cache-lock held.&n;&t;&t; */
id|cachep
op_member_access_from_pointer
id|ctor
c_func
(paren
id|objp
comma
id|cachep
comma
id|SLAB_CTOR_CONSTRUCTOR
op_or
id|SLAB_CTOR_VERIFY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_RED_ZONE
)paren
(brace
id|objp
op_sub_assign
id|BYTES_PER_WORD
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|objp
comma
id|RED_MAGIC1
)paren
op_ne
id|RED_MAGIC2
)paren
multiline_comment|/* Either write before start, or a double free. */
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xchg
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|objp
op_plus
id|cachep-&gt;objsize
op_minus
id|BYTES_PER_WORD
)paren
comma
id|RED_MAGIC1
)paren
op_ne
id|RED_MAGIC2
)paren
multiline_comment|/* Either write past end, or a double free. */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cachep-&gt;flags
op_amp
id|SLAB_POISON
)paren
id|kmem_poison_obj
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_extra_free_checks
c_func
(paren
id|cachep
comma
id|slabp
comma
id|objp
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
(brace
r_int
r_int
id|objnr
op_assign
(paren
id|objp
op_minus
id|slabp-&gt;s_mem
)paren
op_div
id|cachep-&gt;objsize
suffix:semicolon
id|slab_bufctl
c_func
(paren
id|slabp
)paren
(braket
id|objnr
)braket
op_assign
id|slabp-&gt;free
suffix:semicolon
id|slabp-&gt;free
op_assign
id|objnr
suffix:semicolon
)brace
id|STATS_DEC_ACTIVE
c_func
(paren
id|cachep
)paren
suffix:semicolon
multiline_comment|/* fixup slab chain */
r_if
c_cond
(paren
id|slabp-&gt;inuse
op_decrement
op_eq
id|cachep-&gt;num
)paren
r_goto
id|moveslab_partial
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slabp-&gt;inuse
)paren
r_goto
id|moveslab_free
suffix:semicolon
r_return
suffix:semicolon
id|moveslab_partial
suffix:colon
multiline_comment|/* was full.&n;&t; * Even if the page is now empty, we can set c_firstnotfull to&n;&t; * slabp: there are no partial slabs in this case&n;&t; */
(brace
r_struct
id|list_head
op_star
id|t
op_assign
id|cachep-&gt;firstnotfull
suffix:semicolon
id|cachep-&gt;firstnotfull
op_assign
op_amp
id|slabp-&gt;list
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;list.next
op_eq
id|t
)paren
r_return
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|slabp-&gt;list
comma
id|t
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|moveslab_free
suffix:colon
multiline_comment|/*&n;&t; * was partial, now empty.&n;&t; * c_firstnotfull might point to slabp&n;&t; * FIXME: optimize&n;&t; */
(brace
r_struct
id|list_head
op_star
id|t
op_assign
id|cachep-&gt;firstnotfull-&gt;prev
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|slabp-&gt;list
comma
op_amp
id|cachep-&gt;slabs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;firstnotfull
op_eq
op_amp
id|slabp-&gt;list
)paren
id|cachep-&gt;firstnotfull
op_assign
id|t-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|__free_block
r_static
r_inline
r_void
id|__free_block
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|len
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|len
op_decrement
comma
id|objpp
op_increment
)paren
id|kmem_cache_free_one
c_func
(paren
id|cachep
comma
op_star
id|objpp
)paren
suffix:semicolon
)brace
DECL|function|free_block
r_static
r_void
id|free_block
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
op_star
id|objpp
comma
r_int
id|len
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|__free_block
c_func
(paren
id|cachep
comma
id|objpp
comma
id|len
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * __kmem_cache_free&n; * called with disabled ints&n; */
DECL|function|__kmem_cache_free
r_static
r_inline
r_void
id|__kmem_cache_free
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|cpucache_t
op_star
id|cc
op_assign
id|cc_data
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|CHECK_PAGE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
)paren
(brace
r_int
id|batchcount
suffix:semicolon
r_if
c_cond
(paren
id|cc-&gt;avail
OL
id|cc-&gt;limit
)paren
(brace
id|STATS_INC_FREEHIT
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|cc_entry
c_func
(paren
id|cc
)paren
(braket
id|cc-&gt;avail
op_increment
)braket
op_assign
id|objp
suffix:semicolon
r_return
suffix:semicolon
)brace
id|STATS_INC_FREEMISS
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|batchcount
op_assign
id|cachep-&gt;batchcount
suffix:semicolon
id|cc-&gt;avail
op_sub_assign
id|batchcount
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
op_amp
id|cc_entry
c_func
(paren
id|cc
)paren
(braket
id|cc-&gt;avail
)braket
comma
id|batchcount
)paren
suffix:semicolon
id|cc_entry
c_func
(paren
id|cc
)paren
(braket
id|cc-&gt;avail
op_increment
)braket
op_assign
id|objp
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|free_block
c_func
(paren
id|cachep
comma
op_amp
id|objp
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#else
id|kmem_cache_free_one
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; * kmem_cache_alloc - Allocate an object&n; * @cachep: The cache to allocate from.&n; * @flags: See kmalloc().&n; *&n; * Allocate an object from this cache.  The flags are only relevant&n; * if the cache has no available objects.&n; */
DECL|function|kmem_cache_alloc
r_void
op_star
id|kmem_cache_alloc
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|flags
)paren
(brace
r_return
id|__kmem_cache_alloc
c_func
(paren
id|cachep
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kmalloc - allocate memory&n; * @size: how many bytes of memory are required.&n; * @flags: the type of memory to allocate.&n; *&n; * kmalloc is the normal method of allocating memory&n; * in the kernel.  The @flags argument may be one of:&n; *&n; * %GFP_BUFFER - XXX&n; *&n; * %GFP_ATOMIC - allocation will not sleep.  Use inside interrupt handlers.&n; *&n; * %GFP_USER - allocate memory on behalf of user.  May sleep.&n; *&n; * %GFP_KERNEL - allocate normal kernel ram.  May sleep.&n; *&n; * %GFP_NFS - has a slightly lower probability of sleeping than %GFP_KERNEL.&n; * Don&squot;t use unless you&squot;re in the NFS code.&n; *&n; * %GFP_KSWAPD - Don&squot;t use unless you&squot;re modifying kswapd.&n; */
DECL|function|kmalloc
r_void
op_star
id|kmalloc
(paren
r_int
id|size
comma
r_int
id|flags
)paren
(brace
id|cache_sizes_t
op_star
id|csizep
op_assign
id|cache_sizes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
r_return
id|__kmem_cache_alloc
c_func
(paren
id|flags
op_amp
id|GFP_DMA
ques
c_cond
id|csizep-&gt;cs_dmacachep
suffix:colon
id|csizep-&gt;cs_cachep
comma
id|flags
)paren
suffix:semicolon
)brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// too big size
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * kmem_cache_free - Deallocate an object&n; * @cachep: The cache the allocation was from.&n; * @objp: The previously allocated object.&n; *&n; * Free an object which was previously allocated from this&n; * cache.&n; */
DECL|function|kmem_cache_free
r_void
id|kmem_cache_free
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_void
op_star
id|objp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|CHECK_PAGE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachep
op_ne
id|GET_PAGE_CACHE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__kmem_cache_free
c_func
(paren
id|cachep
comma
id|objp
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kfree - free previously allocated memory&n; * @objp: pointer returned by kmalloc.&n; *&n; * Don&squot;t free memory not originally allocated by kmalloc()&n; * or you will run into trouble.&n; */
DECL|function|kfree
r_void
id|kfree
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
id|kmem_cache_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
)paren
r_return
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|CHECK_PAGE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|c
op_assign
id|GET_PAGE_CACHE
c_func
(paren
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
suffix:semicolon
id|__kmem_cache_free
c_func
(paren
id|c
comma
(paren
r_void
op_star
)paren
id|objp
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|kmem_find_general_cachep
id|kmem_cache_t
op_star
id|kmem_find_general_cachep
(paren
r_int
id|size
comma
r_int
id|gfpflags
)paren
(brace
id|cache_sizes_t
op_star
id|csizep
op_assign
id|cache_sizes
suffix:semicolon
multiline_comment|/* This function could be moved to the header file, and&n;&t; * made inline so consumers can quickly determine what&n;&t; * cache pointer they require.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|csizep-&gt;cs_size
suffix:semicolon
id|csizep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|csizep-&gt;cs_size
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|gfpflags
op_amp
id|GFP_DMA
)paren
ques
c_cond
id|csizep-&gt;cs_dmacachep
suffix:colon
id|csizep-&gt;cs_cachep
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* called with cache_chain_sem acquired.  */
DECL|function|kmem_tune_cpucache
r_static
r_int
id|kmem_tune_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
comma
r_int
id|limit
comma
r_int
id|batchcount
)paren
(brace
id|ccupdate_struct_t
r_new
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * These are admin-provided, so we are more graceful.&n;&t; */
r_if
c_cond
(paren
id|limit
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|batchcount
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|batchcount
OG
id|limit
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
l_int|0
op_logical_and
op_logical_neg
id|batchcount
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memset
c_func
(paren
op_amp
r_new
dot
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_new
dot
r_new
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpucache_t
op_star
id|ccnew
suffix:semicolon
id|ccnew
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|limit
op_plus
r_sizeof
(paren
id|cpucache_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccnew
)paren
r_goto
id|oom
suffix:semicolon
id|ccnew-&gt;limit
op_assign
id|limit
suffix:semicolon
id|ccnew-&gt;avail
op_assign
l_int|0
suffix:semicolon
r_new
dot
r_new
(braket
id|cpu_logical_map
c_func
(paren
id|i
)paren
)braket
op_assign
id|ccnew
suffix:semicolon
)brace
)brace
r_new
dot
id|cachep
op_assign
id|cachep
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|cachep-&gt;batchcount
op_assign
id|batchcount
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|smp_call_function_all_cpus
c_func
(paren
id|do_ccupdate_local
comma
(paren
r_void
op_star
)paren
op_amp
r_new
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpucache_t
op_star
id|ccold
op_assign
r_new
dot
r_new
(braket
id|cpu_logical_map
c_func
(paren
id|i
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccold
)paren
r_continue
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|free_block
c_func
(paren
id|cachep
comma
id|cc_entry
c_func
(paren
id|ccold
)paren
comma
id|ccold-&gt;avail
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ccold
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|oom
suffix:colon
r_for
c_loop
(paren
id|i
op_decrement
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|kfree
c_func
(paren
r_new
dot
r_new
(braket
id|cpu_logical_map
c_func
(paren
id|i
)paren
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|enable_cpucache
r_static
r_void
id|enable_cpucache
(paren
id|kmem_cache_t
op_star
id|cachep
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|limit
suffix:semicolon
multiline_comment|/* FIXME: optimize */
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
id|PAGE_SIZE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
l_int|1024
)paren
id|limit
op_assign
l_int|60
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cachep-&gt;objsize
OG
l_int|256
)paren
id|limit
op_assign
l_int|124
suffix:semicolon
r_else
id|limit
op_assign
l_int|252
suffix:semicolon
id|err
op_assign
id|kmem_tune_cpucache
c_func
(paren
id|cachep
comma
id|limit
comma
id|limit
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;enable_cpucache failed for %s, error %d.&bslash;n&quot;
comma
id|cachep-&gt;name
comma
op_minus
id|err
)paren
suffix:semicolon
)brace
DECL|function|enable_all_cpucaches
r_static
r_void
id|enable_all_cpucaches
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|cache_cache.next
suffix:semicolon
r_do
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
id|enable_cpucache
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|p
op_assign
id|cachep-&gt;next.next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
op_ne
op_amp
id|cache_cache.next
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * kmem_cache_reap - Reclaim memory from caches.&n; * @gfp_mask: the type of memory required.&n; *&n; * Called from try_to_free_page().&n; */
DECL|function|kmem_cache_reap
r_void
id|kmem_cache_reap
(paren
r_int
id|gfp_mask
)paren
(brace
id|slab_t
op_star
id|slabp
suffix:semicolon
id|kmem_cache_t
op_star
id|searchp
suffix:semicolon
id|kmem_cache_t
op_star
id|best_cachep
suffix:semicolon
r_int
r_int
id|best_pages
suffix:semicolon
r_int
r_int
id|best_len
suffix:semicolon
r_int
r_int
id|scan
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|cache_chain_sem
)paren
)paren
r_return
suffix:semicolon
id|scan
op_assign
id|REAP_SCANLEN
suffix:semicolon
id|best_len
op_assign
l_int|0
suffix:semicolon
id|best_pages
op_assign
l_int|0
suffix:semicolon
id|best_cachep
op_assign
l_int|NULL
suffix:semicolon
id|searchp
op_assign
id|clock_searchp
suffix:semicolon
r_do
(brace
r_int
r_int
id|pages
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
r_int
id|full_free
suffix:semicolon
multiline_comment|/* It&squot;s safe to test this without holding the cache-lock. */
r_if
c_cond
(paren
id|searchp-&gt;flags
op_amp
id|SLAB_NO_REAP
)paren
r_goto
id|next
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;growing
)paren
r_goto
id|next_unlock
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;dflags
op_amp
id|DFLGS_GROWN
)paren
(brace
id|searchp-&gt;dflags
op_and_assign
op_complement
id|DFLGS_GROWN
suffix:semicolon
r_goto
id|next_unlock
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
(brace
id|cpucache_t
op_star
id|cc
op_assign
id|cc_data
c_func
(paren
id|searchp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_logical_and
id|cc-&gt;avail
)paren
(brace
id|__free_block
c_func
(paren
id|searchp
comma
id|cc_entry
c_func
(paren
id|cc
)paren
comma
id|cc-&gt;avail
)paren
suffix:semicolon
id|cc-&gt;avail
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
id|full_free
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|searchp-&gt;slabs.prev
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
op_amp
id|searchp-&gt;slabs
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|slab_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
)paren
r_break
suffix:semicolon
id|full_free
op_increment
suffix:semicolon
id|p
op_assign
id|p-&gt;prev
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Try to avoid slabs with constructors and/or&n;&t;&t; * more than one page per slab (as it can be difficult&n;&t;&t; * to get high orders from gfp()).&n;&t;&t; */
id|pages
op_assign
id|full_free
op_star
(paren
l_int|1
op_lshift
id|searchp-&gt;gfporder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;ctor
)paren
id|pages
op_assign
(paren
id|pages
op_star
l_int|4
op_plus
l_int|1
)paren
op_div
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|searchp-&gt;gfporder
)paren
id|pages
op_assign
(paren
id|pages
op_star
l_int|4
op_plus
l_int|1
)paren
op_div
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|pages
OG
id|best_pages
)paren
(brace
id|best_cachep
op_assign
id|searchp
suffix:semicolon
id|best_len
op_assign
id|full_free
suffix:semicolon
id|best_pages
op_assign
id|pages
suffix:semicolon
r_if
c_cond
(paren
id|full_free
op_ge
id|REAP_PERFECT
)paren
(brace
id|clock_searchp
op_assign
id|list_entry
c_func
(paren
id|searchp-&gt;next.next
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_goto
id|perfect
suffix:semicolon
)brace
)brace
id|next_unlock
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|searchp-&gt;spinlock
)paren
suffix:semicolon
id|next
suffix:colon
id|searchp
op_assign
id|list_entry
c_func
(paren
id|searchp-&gt;next.next
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|scan
op_logical_and
id|searchp
op_ne
id|clock_searchp
)paren
suffix:semicolon
id|clock_searchp
op_assign
id|searchp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|best_cachep
)paren
multiline_comment|/* couldn&squot;t find anything to reap */
r_goto
id|out
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|best_cachep-&gt;spinlock
)paren
suffix:semicolon
id|perfect
suffix:colon
multiline_comment|/* free only 80% of the free slabs */
id|best_len
op_assign
(paren
id|best_len
op_star
l_int|4
op_plus
l_int|1
)paren
op_div
l_int|5
suffix:semicolon
r_for
c_loop
(paren
id|scan
op_assign
l_int|0
suffix:semicolon
id|scan
OL
id|best_len
suffix:semicolon
id|scan
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|best_cachep-&gt;growing
)paren
r_break
suffix:semicolon
id|p
op_assign
id|best_cachep-&gt;slabs.prev
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|best_cachep-&gt;slabs
)paren
r_break
suffix:semicolon
id|slabp
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|slab_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
)paren
r_break
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|slabp-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|best_cachep-&gt;firstnotfull
op_eq
op_amp
id|slabp-&gt;list
)paren
id|best_cachep-&gt;firstnotfull
op_assign
op_amp
id|best_cachep-&gt;slabs
suffix:semicolon
id|STATS_INC_REAPED
c_func
(paren
id|best_cachep
)paren
suffix:semicolon
multiline_comment|/* Safe to drop the lock. The slab is no longer linked to the&n;&t;&t; * cache.&n;&t;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|best_cachep-&gt;spinlock
)paren
suffix:semicolon
id|kmem_slab_destroy
c_func
(paren
id|best_cachep
comma
id|slabp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|best_cachep-&gt;spinlock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|best_cachep-&gt;spinlock
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* /proc/slabinfo&n; *&t;cache-name num-active-objs total-objs&n; *&t;obj-size num-active-slabs total-slabs&n; *&t;num-pages-per-slab&n; */
DECL|macro|FIXUP
mdefine_line|#define FIXUP(t)&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (len &lt;= off) {&t;&t;&bslash;&n;&t;&t;&t;off -= len;&t;&t;&bslash;&n;&t;&t;&t;len = 0;&t;&t;&bslash;&n;&t;&t;} else {&t;&t;&t;&bslash;&n;&t;&t;&t;if (len-off &gt; count)&t;&bslash;&n;&t;&t;&t;&t;goto t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&bslash;&n;&t;} while (0)
DECL|function|proc_getdata
r_static
r_int
id|proc_getdata
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Output format version, so at least we can change it without _too_&n;&t; * many complaints.&n;&t; */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;slabinfo - version: 1.1&quot;
macro_line|#if STATS
l_string|&quot; (statistics)&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_SMP
l_string|&quot; (SMP)&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|FIXUP
c_func
(paren
id|got_data
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|cache_cache.next
suffix:semicolon
r_do
(brace
id|kmem_cache_t
op_star
id|cachep
suffix:semicolon
r_struct
id|list_head
op_star
id|q
suffix:semicolon
id|slab_t
op_star
id|slabp
suffix:semicolon
r_int
r_int
id|active_objs
suffix:semicolon
r_int
r_int
id|num_objs
suffix:semicolon
r_int
r_int
id|active_slabs
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|num_slabs
suffix:semicolon
id|cachep
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|active_objs
op_assign
l_int|0
suffix:semicolon
id|num_slabs
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|q
comma
op_amp
id|cachep-&gt;slabs
)paren
(brace
id|slabp
op_assign
id|list_entry
c_func
(paren
id|q
comma
id|slab_t
comma
id|list
)paren
suffix:semicolon
id|active_objs
op_add_assign
id|slabp-&gt;inuse
suffix:semicolon
id|num_objs
op_add_assign
id|cachep-&gt;num
suffix:semicolon
r_if
c_cond
(paren
id|slabp-&gt;inuse
)paren
id|active_slabs
op_increment
suffix:semicolon
r_else
id|num_slabs
op_increment
suffix:semicolon
)brace
id|num_slabs
op_add_assign
id|active_slabs
suffix:semicolon
id|num_objs
op_assign
id|num_slabs
op_star
id|cachep-&gt;num
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%-17s %6lu %6lu %6u %4lu %4lu %4u&quot;
comma
id|cachep-&gt;name
comma
id|active_objs
comma
id|num_objs
comma
id|cachep-&gt;objsize
comma
id|active_slabs
comma
id|num_slabs
comma
(paren
l_int|1
op_lshift
id|cachep-&gt;gfporder
)paren
)paren
suffix:semicolon
macro_line|#if STATS
(brace
r_int
r_int
id|errors
op_assign
id|cachep-&gt;errors
suffix:semicolon
r_int
r_int
id|high
op_assign
id|cachep-&gt;high_mark
suffix:semicolon
r_int
r_int
id|grown
op_assign
id|cachep-&gt;grown
suffix:semicolon
r_int
r_int
id|reaped
op_assign
id|cachep-&gt;reaped
suffix:semicolon
r_int
r_int
id|allocs
op_assign
id|cachep-&gt;num_allocations
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot; : %6lu %7lu %5lu %4lu %4lu&quot;
comma
id|high
comma
id|allocs
comma
id|grown
comma
id|reaped
comma
id|errors
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_SMP
(brace
r_int
r_int
id|batchcount
op_assign
id|cachep-&gt;batchcount
suffix:semicolon
r_int
r_int
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|cc_data
c_func
(paren
id|cachep
)paren
)paren
id|limit
op_assign
id|cc_data
c_func
(paren
id|cachep
)paren
op_member_access_from_pointer
id|limit
suffix:semicolon
r_else
id|limit
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot; : %4u %4u&quot;
comma
id|limit
comma
id|batchcount
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if STATS &amp;&amp; defined(CONFIG_SMP)
(brace
r_int
r_int
id|allochit
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;allochit
)paren
suffix:semicolon
r_int
r_int
id|allocmiss
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;allocmiss
)paren
suffix:semicolon
r_int
r_int
id|freehit
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;freehit
)paren
suffix:semicolon
r_int
r_int
id|freemiss
op_assign
id|atomic_read
c_func
(paren
op_amp
id|cachep-&gt;freemiss
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot; : %6lu %6lu %6lu %6lu&quot;
comma
id|allochit
comma
id|allocmiss
comma
id|freehit
comma
id|freemiss
)paren
suffix:semicolon
)brace
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|cachep-&gt;spinlock
)paren
suffix:semicolon
id|FIXUP
c_func
(paren
id|got_data_up
)paren
suffix:semicolon
id|p
op_assign
id|cachep-&gt;next.next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
op_ne
op_amp
id|cache_cache.next
)paren
suffix:semicolon
id|got_data_up
suffix:colon
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|got_data
suffix:colon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; * slabinfo_read_proc - generates /proc/slabinfo&n; * @page: scratch area, one page long&n; * @start: pointer to the pointer to the output buffer&n; * @off: offset within /proc/slabinfo the caller is interested in&n; * @count: requested len in bytes&n; * @eof: eof marker&n; * @data: unused&n; *&n; * The contents of the buffer are&n; * cache-name&n; * num-active-objs&n; * total-objs&n; * object size&n; * num-active-slabs&n; * total-slabs&n; * num-pages-per-slab&n; * + further values on SMP and with statistics enabled&n; */
DECL|function|slabinfo_read_proc
r_int
id|slabinfo_read_proc
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|proc_getdata
c_func
(paren
id|page
comma
id|start
comma
id|off
comma
id|count
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
op_star
id|start
op_minus
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|macro|MAX_SLABINFO_WRITE
mdefine_line|#define MAX_SLABINFO_WRITE 128
multiline_comment|/**&n; * slabinfo_write_proc - SMP tuning for the slab allocator&n; * @file: unused&n; * @buffer: user buffer&n; * @count: data len&n; * @data: unused&n; */
DECL|function|slabinfo_write_proc
r_int
id|slabinfo_write_proc
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_char
id|kbuf
(braket
id|MAX_SLABINFO_WRITE
)braket
comma
op_star
id|tmp
suffix:semicolon
r_int
id|limit
comma
id|batchcount
comma
id|res
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|MAX_SLABINFO_WRITE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|kbuf
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tmp
op_assign
id|strchr
c_func
(paren
id|kbuf
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
id|tmp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|tmp
op_increment
suffix:semicolon
id|limit
op_assign
id|simple_strtol
c_func
(paren
id|tmp
comma
op_amp
id|tmp
comma
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tmp
op_eq
l_char|&squot; &squot;
)paren
id|tmp
op_increment
suffix:semicolon
id|batchcount
op_assign
id|simple_strtol
c_func
(paren
id|tmp
comma
op_amp
id|tmp
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Find the cache in the chain of caches. */
id|down
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|cache_chain
)paren
(brace
id|kmem_cache_t
op_star
id|cachep
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|kmem_cache_t
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|cachep-&gt;name
comma
id|kbuf
)paren
)paren
(brace
id|res
op_assign
id|kmem_tune_cpucache
c_func
(paren
id|cachep
comma
id|limit
comma
id|batchcount
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|cache_chain_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ge
l_int|0
)paren
id|res
op_assign
id|count
suffix:semicolon
r_return
id|res
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
eof
