multiline_comment|/*&n; *&t;linux/mm/recow.c&n; *&n; * Copyright (C) 1998 Linus Torvalds&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/*&n; * This implements the &quot;re-COW&quot; system call.&n; *&n; * &quot;re-cow&quot; - synchronize two page-aligned areas with each other,&n; * returning the first offset at which they differ. This is useful&n; * for doing large memory compares. One example is simulating a&n; * VGA device under DOSEMU, where you cache the old state of the&n; * screen, and let DOSEMU have a private copy that it can change.&n; *&n; * When you want to synchronize the real screen with the private&n; * simulation, you &quot;re-cow()&quot; the areas and see where the changes&n; * have been. It will not only tell you what pages have been modified,&n; * it will also share pages if they are the same..&n; *&n; * Doing this in user mode is prohibitive, as we need to access&n; * the page tables in order to do this efficiently.&n; */
DECL|macro|verify_recow
mdefine_line|#define verify_recow(mm, vma, addr, len) do { &bslash;&n;&t;vma = find_vma(mm, addr); &bslash;&n;&t;if (!vma || (vma-&gt;vm_flags &amp; VM_SHARED) || addr &lt; vma-&gt;vm_start || vma-&gt;vm_end - addr &lt; len) &bslash;&n;&t;&t;goto badvma; &bslash;&n;} while (0)
DECL|function|do_compare
r_static
r_int
id|do_compare
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pte_t
op_star
id|firstpte
comma
r_int
r_int
id|addr
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pmd_t
op_star
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_t
op_star
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|addr
)paren
suffix:semicolon
id|pte_t
id|entry
op_assign
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|entry
)paren
)paren
(brace
r_int
r_int
id|page1
op_assign
id|pte_page
c_func
(paren
op_star
id|firstpte
)paren
suffix:semicolon
r_int
r_int
id|page2
op_assign
id|pte_page
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page1
op_eq
id|page2
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
(paren
r_void
op_star
)paren
id|page1
comma
(paren
r_void
op_star
)paren
id|page2
comma
id|PAGE_SIZE
)paren
)paren
(brace
id|entry
op_assign
id|pte_wrprotect
c_func
(paren
id|entry
)paren
suffix:semicolon
op_star
id|firstpte
op_assign
id|entry
suffix:semicolon
op_star
id|pte
op_assign
id|entry
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page2
)paren
)braket
dot
id|count
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page1
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE! We return zero for all &quot;special&quot; cases, &n; * so that if something is not present for any&n; * reason the user has to compare that by hand.&n; */
DECL|function|same_page
r_static
r_int
id|same_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr1
comma
r_int
r_int
id|addr2
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|addr1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pmd_t
op_star
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|addr1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_t
op_star
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|addr1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
r_return
id|do_compare
c_func
(paren
id|mm
comma
id|pte
comma
id|addr2
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_mrecow
id|asmlinkage
r_int
id|sys_mrecow
c_func
(paren
r_int
r_int
id|addr1
comma
r_int
r_int
id|addr2
comma
r_int
id|len
)paren
(brace
r_int
id|shared
op_assign
l_int|0
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma1
comma
op_star
id|vma2
suffix:semicolon
multiline_comment|/*&n;&t; * Everything has to be page-aligned..&n;&t; */
r_if
c_cond
(paren
(paren
id|addr1
op_or
id|addr2
op_or
id|len
)paren
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Make sure we&squot;re not aliased (trivially the same for the whole length) */
r_if
c_cond
(paren
id|addr1
op_eq
id|addr2
)paren
r_return
id|len
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We require that the comparison areas are fully contained&n;&t; * within the vm_area_structs, and that they are both private&n;&t; * mappings..&n;&t; */
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|verify_recow
c_func
(paren
id|mm
comma
id|vma1
comma
id|addr1
comma
id|len
)paren
suffix:semicolon
id|verify_recow
c_func
(paren
id|mm
comma
id|vma2
comma
id|addr2
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to have the same page protections on both&n;&t; * areas, otherwise we&squot;ll mess up when we combine pages.&n;&t; *&n;&t; * Right now we also only allow this on anonymous areas,&n;&t; * I don&squot;t know if we&squot;d want to expand it to other things&n;&t; * at some point.&n;&t; */
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pgprot_val
c_func
(paren
id|vma1-&gt;vm_page_prot
)paren
op_ne
id|pgprot_val
c_func
(paren
id|vma2-&gt;vm_page_prot
)paren
)paren
r_goto
id|badvma
suffix:semicolon
r_if
c_cond
(paren
id|vma1-&gt;vm_file
op_logical_or
id|vma2-&gt;vm_file
)paren
r_goto
id|badvma
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, start the page walk..&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
r_int
id|same
op_assign
id|same_page
c_func
(paren
id|mm
comma
id|addr1
comma
id|addr2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|same
)paren
r_break
suffix:semicolon
id|shared
op_or_assign
id|same
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|retval
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|addr1
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|addr2
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shared
)paren
id|flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
id|badvma
suffix:colon
id|up
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
eof
