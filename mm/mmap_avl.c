multiline_comment|/*&n; * Searching a VMA in the linear list task-&gt;mm-&gt;mmap is horribly slow.&n; * Use an AVL (Adelson-Velskii and Landis) tree to speed up this search&n; * from O(n) to O(log n), where n is the number of VMAs of the task&n; * n is typically around 6, but may reach 3000 in some cases: object-oriented&n; * databases, persistent store, generational garbage collection (Java, Lisp),&n; * ElectricFence.&n; * Written by Bruno Haible &lt;haible@ma2s2.mathematik.uni-karlsruhe.de&gt;.&n; */
multiline_comment|/* We keep the list and tree sorted by address. */
DECL|macro|vm_avl_key
mdefine_line|#define vm_avl_key&t;vm_end
DECL|macro|vm_avl_key_t
mdefine_line|#define vm_avl_key_t&t;unsigned long&t;/* typeof(vma-&gt;avl_key) */
multiline_comment|/*&n; * task-&gt;mm-&gt;mmap_avl is the AVL tree corresponding to task-&gt;mm-&gt;mmap&n; * or, more exactly, its root.&n; * A vm_area_struct has the following fields:&n; *   vm_avl_left     left son of a tree node&n; *   vm_avl_right    right son of a tree node&n; *   vm_avl_height   1+max(heightof(left),heightof(right))&n; * The empty tree is represented as NULL.&n; */
multiline_comment|/* Since the trees are balanced, their height will never be large. */
DECL|macro|avl_maxheight
mdefine_line|#define avl_maxheight&t;41&t;/* why this? a small exercise */
DECL|macro|heightof
mdefine_line|#define heightof(tree)&t;((tree) == vm_avl_empty ? 0 : (tree)-&gt;vm_avl_height)
multiline_comment|/*&n; * Consistency and balancing rules:&n; * 1. tree-&gt;vm_avl_height == 1+max(heightof(tree-&gt;vm_avl_left),heightof(tree-&gt;vm_avl_right))&n; * 2. abs( heightof(tree-&gt;vm_avl_left) - heightof(tree-&gt;vm_avl_right) ) &lt;= 1&n; * 3. foreach node in tree-&gt;vm_avl_left: node-&gt;vm_avl_key &lt;= tree-&gt;vm_avl_key,&n; *    foreach node in tree-&gt;vm_avl_right: node-&gt;vm_avl_key &gt;= tree-&gt;vm_avl_key.&n; */
macro_line|#ifdef DEBUG_AVL
multiline_comment|/* Look up the nodes at the left and at the right of a given node. */
DECL|function|avl_neighbours
r_static
r_void
id|avl_neighbours
(paren
r_struct
id|vm_area_struct
op_star
id|node
comma
r_struct
id|vm_area_struct
op_star
id|tree
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_left
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_right
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|node-&gt;vm_avl_key
suffix:semicolon
op_star
id|to_the_left
op_assign
op_star
id|to_the_right
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|vm_avl_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;avl_neighbours: node not found in the tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|key
op_eq
id|tree-&gt;vm_avl_key
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|tree-&gt;vm_avl_key
)paren
(brace
op_star
id|to_the_right
op_assign
id|tree
suffix:semicolon
id|tree
op_assign
id|tree-&gt;vm_avl_left
suffix:semicolon
)brace
r_else
(brace
op_star
id|to_the_left
op_assign
id|tree
suffix:semicolon
id|tree
op_assign
id|tree-&gt;vm_avl_right
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tree
op_ne
id|node
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;avl_neighbours: node not exactly found in the tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree-&gt;vm_avl_left
op_ne
id|vm_avl_empty
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|tree-&gt;vm_avl_left
suffix:semicolon
id|node-&gt;vm_avl_right
op_ne
id|vm_avl_empty
suffix:semicolon
id|node
op_assign
id|node-&gt;vm_avl_right
)paren
r_continue
suffix:semicolon
op_star
id|to_the_left
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree-&gt;vm_avl_right
op_ne
id|vm_avl_empty
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|tree-&gt;vm_avl_right
suffix:semicolon
id|node-&gt;vm_avl_left
op_ne
id|vm_avl_empty
suffix:semicolon
id|node
op_assign
id|node-&gt;vm_avl_left
)paren
r_continue
suffix:semicolon
op_star
id|to_the_right
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|to_the_left
op_logical_and
(paren
(paren
op_star
id|to_the_left
)paren
op_member_access_from_pointer
id|vm_next
op_ne
id|node
)paren
)paren
op_logical_or
(paren
id|node-&gt;vm_next
op_ne
op_star
id|to_the_right
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;avl_neighbours: tree inconsistent with list&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Rebalance a tree.&n; * After inserting or deleting a node of a tree we have a sequence of subtrees&n; * nodes[0]..nodes[k-1] such that&n; * nodes[0] is the root and nodes[i+1] = nodes[i]-&gt;{vm_avl_left|vm_avl_right}.&n; */
DECL|function|avl_rebalance
r_static
r_void
id|avl_rebalance
(paren
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|nodeplaces_ptr
comma
r_int
id|count
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|count
op_decrement
)paren
(brace
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
op_star
op_decrement
id|nodeplaces_ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|nodeleft
op_assign
id|node-&gt;vm_avl_left
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|noderight
op_assign
id|node-&gt;vm_avl_right
suffix:semicolon
r_int
id|heightleft
op_assign
id|heightof
c_func
(paren
id|nodeleft
)paren
suffix:semicolon
r_int
id|heightright
op_assign
id|heightof
c_func
(paren
id|noderight
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightright
op_plus
l_int|1
OL
id|heightleft
)paren
(brace
multiline_comment|/*                                                      */
multiline_comment|/*                            *                         */
multiline_comment|/*                          /   &bslash;                       */
multiline_comment|/*                       n+2      n                     */
multiline_comment|/*                                                      */
r_struct
id|vm_area_struct
op_star
id|nodeleftleft
op_assign
id|nodeleft-&gt;vm_avl_left
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|nodeleftright
op_assign
id|nodeleft-&gt;vm_avl_right
suffix:semicolon
r_int
id|heightleftright
op_assign
id|heightof
c_func
(paren
id|nodeleftright
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightof
c_func
(paren
id|nodeleftleft
)paren
op_ge
id|heightleftright
)paren
(brace
multiline_comment|/*                                                        */
multiline_comment|/*                *                    n+2|n+3            */
multiline_comment|/*              /   &bslash;                  /    &bslash;             */
multiline_comment|/*           n+2      n      --&gt;      /   n+1|n+2         */
multiline_comment|/*           / &bslash;                      |    /    &bslash;         */
multiline_comment|/*         n+1 n|n+1                 n+1  n|n+1  n        */
multiline_comment|/*                                                        */
id|node-&gt;vm_avl_left
op_assign
id|nodeleftright
suffix:semicolon
id|nodeleft-&gt;vm_avl_right
op_assign
id|node
suffix:semicolon
id|nodeleft-&gt;vm_avl_height
op_assign
l_int|1
op_plus
(paren
id|node-&gt;vm_avl_height
op_assign
l_int|1
op_plus
id|heightleftright
)paren
suffix:semicolon
op_star
id|nodeplace
op_assign
id|nodeleft
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*                                                        */
multiline_comment|/*                *                     n+2               */
multiline_comment|/*              /   &bslash;                 /     &bslash;             */
multiline_comment|/*           n+2      n      --&gt;    n+1     n+1           */
multiline_comment|/*           / &bslash;                    / &bslash;     / &bslash;           */
multiline_comment|/*          n  n+1                 n   L   R   n          */
multiline_comment|/*             / &bslash;                                        */
multiline_comment|/*            L   R                                       */
multiline_comment|/*                                                        */
id|nodeleft-&gt;vm_avl_right
op_assign
id|nodeleftright-&gt;vm_avl_left
suffix:semicolon
id|node-&gt;vm_avl_left
op_assign
id|nodeleftright-&gt;vm_avl_right
suffix:semicolon
id|nodeleftright-&gt;vm_avl_left
op_assign
id|nodeleft
suffix:semicolon
id|nodeleftright-&gt;vm_avl_right
op_assign
id|node
suffix:semicolon
id|nodeleft-&gt;vm_avl_height
op_assign
id|node-&gt;vm_avl_height
op_assign
id|heightleftright
suffix:semicolon
id|nodeleftright-&gt;vm_avl_height
op_assign
id|heightleft
suffix:semicolon
op_star
id|nodeplace
op_assign
id|nodeleftright
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|heightleft
op_plus
l_int|1
OL
id|heightright
)paren
(brace
multiline_comment|/* similar to the above, just interchange &squot;left&squot; &lt;--&gt; &squot;right&squot; */
r_struct
id|vm_area_struct
op_star
id|noderightright
op_assign
id|noderight-&gt;vm_avl_right
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|noderightleft
op_assign
id|noderight-&gt;vm_avl_left
suffix:semicolon
r_int
id|heightrightleft
op_assign
id|heightof
c_func
(paren
id|noderightleft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightof
c_func
(paren
id|noderightright
)paren
op_ge
id|heightrightleft
)paren
(brace
id|node-&gt;vm_avl_right
op_assign
id|noderightleft
suffix:semicolon
id|noderight-&gt;vm_avl_left
op_assign
id|node
suffix:semicolon
id|noderight-&gt;vm_avl_height
op_assign
l_int|1
op_plus
(paren
id|node-&gt;vm_avl_height
op_assign
l_int|1
op_plus
id|heightrightleft
)paren
suffix:semicolon
op_star
id|nodeplace
op_assign
id|noderight
suffix:semicolon
)brace
r_else
(brace
id|noderight-&gt;vm_avl_left
op_assign
id|noderightleft-&gt;vm_avl_right
suffix:semicolon
id|node-&gt;vm_avl_right
op_assign
id|noderightleft-&gt;vm_avl_left
suffix:semicolon
id|noderightleft-&gt;vm_avl_right
op_assign
id|noderight
suffix:semicolon
id|noderightleft-&gt;vm_avl_left
op_assign
id|node
suffix:semicolon
id|noderight-&gt;vm_avl_height
op_assign
id|node-&gt;vm_avl_height
op_assign
id|heightrightleft
suffix:semicolon
id|noderightleft-&gt;vm_avl_height
op_assign
id|heightright
suffix:semicolon
op_star
id|nodeplace
op_assign
id|noderightleft
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|height
op_assign
(paren
id|heightleft
OL
id|heightright
ques
c_cond
id|heightright
suffix:colon
id|heightleft
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|height
op_eq
id|node-&gt;vm_avl_height
)paren
r_break
suffix:semicolon
id|node-&gt;vm_avl_height
op_assign
id|height
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Insert a node into a tree. */
DECL|function|avl_insert
r_static
r_inline
r_void
id|avl_insert
(paren
r_struct
id|vm_area_struct
op_star
id|new_node
comma
r_struct
id|vm_area_struct
op_star
op_star
id|ptree
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|new_node-&gt;vm_avl_key
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
id|ptree
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|vm_avl_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|node-&gt;vm_avl_key
)paren
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
r_else
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
id|new_node-&gt;vm_avl_left
op_assign
id|vm_avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_right
op_assign
id|vm_avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_height
op_assign
l_int|1
suffix:semicolon
op_star
id|nodeplace
op_assign
id|new_node
suffix:semicolon
id|avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert a node into a tree, and&n; * return the node to the left of it and the node to the right of it.&n; */
DECL|function|avl_insert_neighbours
r_static
r_inline
r_void
id|avl_insert_neighbours
(paren
r_struct
id|vm_area_struct
op_star
id|new_node
comma
r_struct
id|vm_area_struct
op_star
op_star
id|ptree
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_left
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_right
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|new_node-&gt;vm_avl_key
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
id|ptree
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
op_star
id|to_the_left
op_assign
op_star
id|to_the_right
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|vm_avl_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|node-&gt;vm_avl_key
)paren
(brace
op_star
id|to_the_right
op_assign
id|node
suffix:semicolon
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
)brace
r_else
(brace
op_star
id|to_the_left
op_assign
id|node
suffix:semicolon
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
)brace
id|new_node-&gt;vm_avl_left
op_assign
id|vm_avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_right
op_assign
id|vm_avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_height
op_assign
l_int|1
suffix:semicolon
op_star
id|nodeplace
op_assign
id|new_node
suffix:semicolon
id|avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Removes a node out of a tree. */
DECL|function|avl_remove
r_static
r_void
id|avl_remove
(paren
r_struct
id|vm_area_struct
op_star
id|node_to_delete
comma
r_struct
id|vm_area_struct
op_star
op_star
id|ptree
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|node_to_delete-&gt;vm_avl_key
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
id|ptree
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace_to_delete
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
macro_line|#ifdef DEBUG_AVL
r_if
c_cond
(paren
id|node
op_eq
id|vm_avl_empty
)paren
(brace
multiline_comment|/* what? node_to_delete not found in tree? */
id|printk
c_func
(paren
l_string|&quot;avl_remove: node to delete not found in tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|node-&gt;vm_avl_key
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|node-&gt;vm_avl_key
)paren
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
r_else
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
id|nodeplace_to_delete
op_assign
id|nodeplace
suffix:semicolon
multiline_comment|/* Have to remove node_to_delete = *nodeplace_to_delete. */
r_if
c_cond
(paren
id|node_to_delete-&gt;vm_avl_left
op_eq
id|vm_avl_empty
)paren
(brace
op_star
id|nodeplace_to_delete
op_assign
id|node_to_delete-&gt;vm_avl_right
suffix:semicolon
id|stack_ptr
op_decrement
suffix:semicolon
id|stack_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr_to_delete
op_assign
id|stack_ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
op_amp
id|node_to_delete-&gt;vm_avl_left
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;vm_avl_right
op_eq
id|vm_avl_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
op_star
id|nodeplace
op_assign
id|node-&gt;vm_avl_left
suffix:semicolon
multiline_comment|/* node replaces node_to_delete */
id|node-&gt;vm_avl_left
op_assign
id|node_to_delete-&gt;vm_avl_left
suffix:semicolon
id|node-&gt;vm_avl_right
op_assign
id|node_to_delete-&gt;vm_avl_right
suffix:semicolon
id|node-&gt;vm_avl_height
op_assign
id|node_to_delete-&gt;vm_avl_height
suffix:semicolon
op_star
id|nodeplace_to_delete
op_assign
id|node
suffix:semicolon
multiline_comment|/* replace node_to_delete */
op_star
id|stack_ptr_to_delete
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
multiline_comment|/* replace &amp;node_to_delete-&gt;vm_avl_left */
)brace
id|avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_AVL
multiline_comment|/* print a list */
DECL|function|printk_list
r_static
r_void
id|printk_list
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|vma
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08lX-%08lX&quot;
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;]&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* print a tree */
DECL|function|printk_avl
r_static
r_void
id|printk_avl
(paren
r_struct
id|vm_area_struct
op_star
id|tree
)paren
(brace
r_if
c_cond
(paren
id|tree
op_ne
id|vm_avl_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_left
op_ne
id|vm_avl_empty
)paren
(brace
id|printk_avl
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%08lX-%08lX&quot;
comma
id|tree-&gt;vm_start
comma
id|tree-&gt;vm_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_right
op_ne
id|vm_avl_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|printk_avl
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|variable|avl_check_point
r_static
r_char
op_star
id|avl_check_point
op_assign
l_string|&quot;somewhere&quot;
suffix:semicolon
multiline_comment|/* check a tree&squot;s consistency and balancing */
DECL|function|avl_checkheights
r_static
r_void
id|avl_checkheights
(paren
r_struct
id|vm_area_struct
op_star
id|tree
)paren
(brace
r_int
id|h
comma
id|hl
comma
id|hr
suffix:semicolon
r_if
c_cond
(paren
id|tree
op_eq
id|vm_avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkheights
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|avl_checkheights
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
id|h
op_assign
id|tree-&gt;vm_avl_height
suffix:semicolon
id|hl
op_assign
id|heightof
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|hr
op_assign
id|heightof
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h
op_eq
id|hl
op_plus
l_int|1
)paren
op_logical_and
(paren
id|hr
op_le
id|hl
)paren
op_logical_and
(paren
id|hl
op_le
id|hr
op_plus
l_int|1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h
op_eq
id|hr
op_plus
l_int|1
)paren
op_logical_and
(paren
id|hl
op_le
id|hr
)paren
op_logical_and
(paren
id|hr
op_le
id|hl
op_plus
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkheights: heights inconsistent&bslash;n&quot;
comma
id|avl_check_point
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values stored in a tree are &lt; key */
DECL|function|avl_checkleft
r_static
r_void
id|avl_checkleft
(paren
r_struct
id|vm_area_struct
op_star
id|tree
comma
id|vm_avl_key_t
id|key
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|vm_avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;vm_avl_left
comma
id|key
)paren
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;vm_avl_right
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_key
OL
id|key
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkleft: left key %lu &gt;= top key %lu&bslash;n&quot;
comma
id|avl_check_point
comma
id|tree-&gt;vm_avl_key
comma
id|key
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values stored in a tree are &gt; key */
DECL|function|avl_checkright
r_static
r_void
id|avl_checkright
(paren
r_struct
id|vm_area_struct
op_star
id|tree
comma
id|vm_avl_key_t
id|key
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|vm_avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;vm_avl_left
comma
id|key
)paren
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;vm_avl_right
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_key
OG
id|key
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkright: right key %lu &lt;= top key %lu&bslash;n&quot;
comma
id|avl_check_point
comma
id|tree-&gt;vm_avl_key
comma
id|key
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values are properly increasing */
DECL|function|avl_checkorder
r_static
r_void
id|avl_checkorder
(paren
r_struct
id|vm_area_struct
op_star
id|tree
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|vm_avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;vm_avl_left
comma
id|tree-&gt;vm_avl_key
)paren
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;vm_avl_right
comma
id|tree-&gt;vm_avl_key
)paren
suffix:semicolon
)brace
multiline_comment|/* all checks */
DECL|function|avl_check
r_static
r_void
id|avl_check
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_char
op_star
id|caller
)paren
(brace
id|avl_check_point
op_assign
id|caller
suffix:semicolon
multiline_comment|/*&t;printk(&quot;task &bslash;&quot;%s&bslash;&quot;, %s&bslash;n&quot;,task-&gt;comm,caller); */
multiline_comment|/*&t;printk(&quot;task &bslash;&quot;%s&bslash;&quot; list: &quot;,task-&gt;comm); printk_list(task-&gt;mm-&gt;mmap); printk(&quot;&bslash;n&quot;); */
multiline_comment|/*&t;printk(&quot;task &bslash;&quot;%s&bslash;&quot; tree: &quot;,task-&gt;comm); printk_avl(task-&gt;mm-&gt;mmap_avl); printk(&quot;&bslash;n&quot;); */
id|avl_checkheights
c_func
(paren
id|task-&gt;mm-&gt;mmap_avl
)paren
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|task-&gt;mm-&gt;mmap_avl
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
