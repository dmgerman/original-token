multiline_comment|/*&n; *  linux/mm/initmem.c&n; *&n; *  Copyright (C) 1999 Ingo Molnar&n; *&n; *  simple boot-time physical memory area allocator and&n; *  free memory collector. It&squot;s used to deal with reserved&n; *  system memory and memory holes as well.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
multiline_comment|/*&n; * Pointer to a bitmap - the bits represent all physical memory pages&n; * from physical address 0 to physical address end_mem.&n; *&n; * Access to this subsystem has to be serialized externally. (this is&n; * true for the boot process anyway)&n; */
DECL|variable|bootmem_map
r_static
r_void
op_star
id|bootmem_map
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|max_low_pfn
r_int
r_int
id|max_low_pfn
suffix:semicolon
multiline_comment|/*&n; * Called once to set up the allocator itself.&n; */
DECL|function|init_bootmem
r_int
r_int
id|__init
id|init_bootmem
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|pages
)paren
(brace
r_int
r_int
id|mapsize
op_assign
(paren
id|pages
op_plus
l_int|7
)paren
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|bootmem_map
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bootmem_map
op_assign
id|__va
c_func
(paren
id|start
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|max_low_pfn
op_assign
id|pages
suffix:semicolon
multiline_comment|/*&n;&t; * Initially all pages are reserved - setup_arch() has to&n;&t; * register free RAM areas explicitly.&n;&t; */
id|memset
c_func
(paren
id|bootmem_map
comma
l_int|0xff
comma
id|mapsize
)paren
suffix:semicolon
r_return
id|mapsize
suffix:semicolon
)brace
multiline_comment|/*&n; * Marks a particular physical memory range as usable. Usable RAM&n; * might be used for boot-time allocations - or it might get added&n; * to the free page pool later on.&n; */
DECL|function|reserve_bootmem
r_void
id|__init
id|reserve_bootmem
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * round up, partially reserved pages are considered&n;&t; * fully reserved.&n;&t; */
r_int
r_int
id|end
op_assign
(paren
id|addr
op_plus
id|size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bootmem_map
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|max_low_pfn
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|addr
op_div
id|PAGE_SIZE
suffix:semicolon
id|i
OL
id|end
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|i
comma
id|bootmem_map
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_bootmem
r_void
id|__init
id|free_bootmem
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * round down end of usable mem, partially free pages are&n;&t; * considered reserved.&n;&t; */
r_int
r_int
id|end
op_assign
(paren
id|addr
op_plus
id|size
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bootmem_map
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|max_low_pfn
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|addr
op_div
id|PAGE_SIZE
suffix:semicolon
id|i
OL
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|i
comma
id|bootmem_map
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We &squot;merge&squot; subsequent allocations to save space. We might &squot;lose&squot;&n; * some fraction of a page if allocations cannot be satisfied due to&n; * size constraints on boxes where there is physical RAM space&n; * fragmentation - in these cases * (mostly large memory boxes) this&n; * is not a problem.&n; *&n; * On low memory boxes we get it right in 100% of the cases.&n; */
DECL|variable|last_pos
r_static
r_int
r_int
id|last_pos
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_offset
r_static
r_int
r_int
id|last_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * alignment has to be a power of 2 value.&n; */
DECL|function|__alloc_bootmem
r_void
op_star
id|__init
id|__alloc_bootmem
(paren
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_int
id|area
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
comma
id|start
op_assign
l_int|0
comma
id|reserved
suffix:semicolon
r_void
op_star
id|ret
suffix:semicolon
r_int
r_int
id|offset
comma
id|remaining_size
suffix:semicolon
r_int
r_int
id|areasize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bootmem_map
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|areasize
op_assign
(paren
id|size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_low_pfn
suffix:semicolon
id|i
op_increment
)paren
(brace
id|reserved
op_assign
id|test_bit
c_func
(paren
id|i
comma
id|bootmem_map
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reserved
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|area
)paren
(brace
id|area
op_assign
l_int|1
suffix:semicolon
id|start
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_minus
id|start
op_plus
l_int|1
op_eq
id|areasize
)paren
r_goto
id|found
suffix:semicolon
)brace
r_else
(brace
id|area
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|start
op_ge
id|max_low_pfn
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is the next page of the previous allocation-end the start&n;&t; * of this allocation&squot;s buffer? If yes then we can &squot;merge&squot;&n;&t; * the previous partial page with this allocation.&n;&t; */
r_if
c_cond
(paren
id|last_offset
op_logical_and
(paren
id|last_pos
op_plus
l_int|1
op_eq
id|start
)paren
)paren
(brace
id|offset
op_assign
(paren
id|last_offset
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|remaining_size
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|remaining_size
OG
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|remaining_size
)paren
(brace
id|areasize
op_assign
l_int|0
suffix:semicolon
singleline_comment|// last_pos unchanged
id|last_offset
op_assign
id|offset
op_plus
id|size
suffix:semicolon
id|ret
op_assign
id|__va
c_func
(paren
id|last_pos
op_star
id|PAGE_SIZE
op_plus
id|offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|size
op_sub_assign
id|remaining_size
suffix:semicolon
id|areasize
op_assign
(paren
id|size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
id|ret
op_assign
id|__va
c_func
(paren
id|last_pos
op_star
id|PAGE_SIZE
op_plus
id|offset
)paren
suffix:semicolon
id|last_pos
op_assign
id|start
op_plus
id|areasize
op_minus
l_int|1
suffix:semicolon
id|last_offset
op_assign
id|size
suffix:semicolon
)brace
id|last_offset
op_and_assign
op_complement
id|PAGE_MASK
suffix:semicolon
)brace
r_else
(brace
id|last_pos
op_assign
id|start
op_plus
id|areasize
op_minus
l_int|1
suffix:semicolon
id|last_offset
op_assign
id|size
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|ret
op_assign
id|__va
c_func
(paren
id|start
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reserve the area now:&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|start
suffix:semicolon
id|i
OL
id|start
op_plus
id|areasize
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|i
comma
id|bootmem_map
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|free_all_bootmem
r_int
r_int
id|__init
id|free_all_bootmem
(paren
r_void
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|i
comma
id|count
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bootmem_map
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;freeing all bootmem().&bslash;n&quot;
)paren
suffix:semicolon
id|page
op_assign
id|mem_map
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_low_pfn
suffix:semicolon
id|i
op_increment
comma
id|page
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|i
comma
id|bootmem_map
)paren
)paren
(brace
id|count
op_increment
suffix:semicolon
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|total
op_add_assign
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * Now free the allocator bitmap itself, it&squot;s not&n;&t; * needed anymore:&n;&t; */
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|bootmem_map
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|max_low_pfn
op_div
l_int|8
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|page
op_increment
)paren
(brace
id|count
op_increment
suffix:semicolon
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|total
op_add_assign
id|count
suffix:semicolon
id|bootmem_map
op_assign
l_int|NULL
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
eof
