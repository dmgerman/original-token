multiline_comment|/*&n; * Resizable simple shmem filesystem for Linux.&n; *&n; * Copyright (C) 2000 Linus Torvalds.&n; *&t;&t; 2000 Transmeta Corp.&n; *&t;&t; 2000 Christoph Rohland&n; * &n; * This file is released under the GPL.&n; */
multiline_comment|/*&n; * This shared memory handling is heavily based on the ramfs. It&n; * extends the ramfs by the ability to use swap which would makes it a&n; * completely usable filesystem.&n; *&n; * But read and write are not supported (yet)&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;asm/smplock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|SHMEM_MAGIC
mdefine_line|#define SHMEM_MAGIC&t;0x01021994
DECL|macro|ENTRIES_PER_PAGE
mdefine_line|#define ENTRIES_PER_PAGE (PAGE_SIZE/sizeof(unsigned long))
DECL|macro|NR_SINGLE
mdefine_line|#define NR_SINGLE (ENTRIES_PER_PAGE + SHMEM_NR_DIRECT)
DECL|variable|shmem_ops
r_static
r_struct
id|super_operations
id|shmem_ops
suffix:semicolon
DECL|variable|shmem_aops
r_static
r_struct
id|address_space_operations
id|shmem_aops
suffix:semicolon
DECL|variable|shmem_file_operations
r_static
r_struct
id|file_operations
id|shmem_file_operations
suffix:semicolon
DECL|variable|shmem_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_inode_operations
suffix:semicolon
DECL|variable|shmem_dir_operations
r_static
r_struct
id|file_operations
id|shmem_dir_operations
suffix:semicolon
DECL|variable|shmem_dir_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_dir_inode_operations
suffix:semicolon
DECL|variable|shmem_shared_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_shared_vm_ops
suffix:semicolon
DECL|variable|shmem_private_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_private_vm_ops
suffix:semicolon
DECL|variable|shmem_inodes
id|LIST_HEAD
(paren
id|shmem_inodes
)paren
suffix:semicolon
DECL|variable|shmem_ilock
r_static
id|spinlock_t
id|shmem_ilock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|shmem_swp_entry
r_static
id|swp_entry_t
op_star
id|shmem_swp_entry
(paren
r_struct
id|shmem_inode_info
op_star
id|info
comma
r_int
r_int
id|index
)paren
(brace
r_if
c_cond
(paren
id|index
OL
id|SHMEM_NR_DIRECT
)paren
r_return
id|info-&gt;i_direct
op_plus
id|index
suffix:semicolon
id|index
op_sub_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|ENTRIES_PER_PAGE
op_star
id|ENTRIES_PER_PAGE
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
)paren
(brace
id|info-&gt;i_indirect
op_assign
(paren
id|swp_entry_t
op_star
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;i_indirect
(braket
id|index
op_div
id|ENTRIES_PER_PAGE
)braket
)paren
)paren
(brace
id|info-&gt;i_indirect
(braket
id|index
op_div
id|ENTRIES_PER_PAGE
)braket
op_assign
(paren
id|swp_entry_t
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;i_indirect
(braket
id|index
op_div
id|ENTRIES_PER_PAGE
)braket
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|info-&gt;i_indirect
(braket
id|index
op_div
id|ENTRIES_PER_PAGE
)braket
op_plus
id|index
op_mod
id|ENTRIES_PER_PAGE
suffix:semicolon
)brace
DECL|function|shmem_free_swp
r_static
r_int
id|shmem_free_swp
c_func
(paren
id|swp_entry_t
op_star
id|dir
comma
r_int
r_int
id|count
)paren
(brace
id|swp_entry_t
op_star
id|ptr
comma
id|entry
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|freed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|dir
suffix:semicolon
id|ptr
OL
id|dir
op_plus
id|count
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ptr-&gt;val
)paren
r_continue
suffix:semicolon
id|entry
op_assign
op_star
id|ptr
suffix:semicolon
id|swap_free
(paren
id|entry
)paren
suffix:semicolon
op_star
id|ptr
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
id|freed
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|lookup_swap_cache
c_func
(paren
id|entry
)paren
)paren
)paren
r_continue
suffix:semicolon
id|delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|freed
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_truncate_part - free a bunch of swap entries&n; *&n; * @dir:&t;pointer to swp_entries &n; * @size:&t;number of entries in dir&n; * @start:&t;offset to start from&n; * @inode:&t;inode for statistics&n; * @freed:&t;counter for freed pages&n; *&n; * It frees the swap entries from dir+start til dir+size&n; *&n; * returns 0 if it truncated something, else (offset-size)&n; */
r_static
r_int
r_int
DECL|function|shmem_truncate_part
id|shmem_truncate_part
(paren
id|swp_entry_t
op_star
id|dir
comma
r_int
r_int
id|size
comma
r_int
r_int
id|start
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
op_star
id|freed
)paren
(brace
r_if
c_cond
(paren
id|start
OG
id|size
)paren
r_return
id|start
op_minus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
op_star
id|freed
op_add_assign
id|shmem_free_swp
(paren
id|dir
op_plus
id|start
comma
id|size
op_minus
id|start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_truncate
r_static
r_void
id|shmem_truncate
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|clear_base
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
r_int
r_int
id|mmfreed
comma
id|freed
op_assign
l_int|0
suffix:semicolon
id|swp_entry_t
op_star
op_star
id|base
comma
op_star
op_star
id|ptr
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|start
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|start
op_assign
id|shmem_truncate_part
(paren
id|info-&gt;i_direct
comma
id|SHMEM_NR_DIRECT
comma
id|start
comma
id|inode
comma
op_amp
id|freed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base
op_assign
id|info-&gt;i_indirect
)paren
)paren
r_goto
id|out
suffix:semicolon
suffix:semicolon
id|clear_base
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|base
suffix:semicolon
id|ptr
OL
id|base
op_plus
id|ENTRIES_PER_PAGE
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|start
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ptr
)paren
r_continue
suffix:semicolon
id|freed
op_add_assign
id|shmem_free_swp
(paren
op_star
id|ptr
comma
id|ENTRIES_PER_PAGE
)paren
suffix:semicolon
id|free_page
(paren
(paren
r_int
r_int
)paren
op_star
id|ptr
)paren
suffix:semicolon
op_star
id|ptr
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|clear_base
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|shmem_truncate_part
(paren
op_star
id|ptr
comma
id|ENTRIES_PER_PAGE
comma
id|start
comma
id|inode
comma
op_amp
id|freed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|clear_base
)paren
r_goto
id|out
suffix:semicolon
id|free_page
(paren
(paren
r_int
r_int
)paren
id|base
)paren
suffix:semicolon
id|info-&gt;i_indirect
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * We have to calculate the free blocks since we do not know&n;&t; * how many pages the mm discarded&n;&t; *&n;&t; * But we know that normally&n;&t; * inodes-&gt;i_blocks == inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped&n;&t; *&n;&t; * So the mm freed &n;&t; * inodes-&gt;i_blocks - (inode-&gt;i_mapping-&gt;nrpages + info-&gt;swapped)&n;&t; */
id|mmfreed
op_assign
id|inode-&gt;i_blocks
op_minus
(paren
id|inode-&gt;i_mapping-&gt;nrpages
op_plus
id|info-&gt;swapped
)paren
suffix:semicolon
id|info-&gt;swapped
op_sub_assign
id|freed
suffix:semicolon
id|inode-&gt;i_blocks
op_sub_assign
id|freed
op_plus
id|mmfreed
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|inode-&gt;i_sb-&gt;u.shmem_sb.free_blocks
op_add_assign
id|freed
op_plus
id|mmfreed
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
)brace
DECL|function|shmem_delete_inode
r_static
r_void
id|shmem_delete_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|shmem_sb_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb
suffix:semicolon
id|spin_lock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|inode-&gt;u.shmem_i.list
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
id|shmem_truncate
(paren
id|inode
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|info-&gt;free_inodes
op_increment
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|clear_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Move the page from the page cache to the swap cache&n; */
DECL|function|shmem_writepage
r_static
r_int
id|shmem_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
id|swp_entry_t
op_star
id|entry
comma
id|swap
suffix:semicolon
id|info
op_assign
op_amp
id|page-&gt;mapping-&gt;host-&gt;u.shmem_i
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;locked
)paren
r_return
l_int|1
suffix:semicolon
id|swap
op_assign
id|__get_swap_page
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swap.val
)paren
r_return
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|entry
op_assign
id|shmem_swp_entry
(paren
id|info
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
multiline_comment|/* this had been allocted on page allocation */
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;val
)paren
(brace
id|__swap_free
c_func
(paren
id|swap
comma
l_int|2
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|entry
op_assign
id|swap
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remove the from the page cache */
id|lru_cache_del
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Add it to the swap cache */
id|add_to_swap_cache
c_func
(paren
id|page
comma
id|swap
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|info-&gt;swapped
op_increment
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_nopage - either get the page from swap or allocate a new one&n; *&n; * If we allocate a new one we do not mark it dirty. That&squot;s up to the&n; * vm. If we swap it in we mark it dirty since we also free the swap&n; * entry since a page cannot live in both the swap and page cache&n; */
DECL|function|shmem_nopage
r_struct
id|page
op_star
id|shmem_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|no_share
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
id|swp_entry_t
op_star
id|entry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
suffix:semicolon
id|idx
op_assign
(paren
id|address
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|idx
op_add_assign
id|vma-&gt;vm_pgoff
suffix:semicolon
id|down
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|size
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|page
op_assign
id|NOPAGE_SIGBUS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
op_ge
id|size
)paren
op_logical_and
(paren
id|vma-&gt;vm_mm
op_eq
id|current-&gt;mm
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* retry, we may have slept */
id|page
op_assign
id|__find_lock_page
c_func
(paren
id|mapping
comma
id|idx
comma
id|page_hash
(paren
id|mapping
comma
id|idx
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|cached_page
suffix:semicolon
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
id|entry
op_assign
id|shmem_swp_entry
(paren
id|info
comma
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_goto
id|oom
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Look it up and read it in.. */
id|page
op_assign
id|lookup_swap_cache
c_func
(paren
op_star
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|swapin_readahead
c_func
(paren
op_star
id|entry
)paren
suffix:semicolon
id|page
op_assign
id|read_swap_cache
c_func
(paren
op_star
id|entry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|oom
suffix:semicolon
)brace
multiline_comment|/* We have to this with page locked to prevent races */
id|spin_lock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
id|swap_free
c_func
(paren
op_star
id|entry
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|delete_from_swap_cache_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
op_star
id|entry
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
id|flags
op_assign
id|page-&gt;flags
op_amp
op_complement
(paren
(paren
l_int|1
op_lshift
id|PG_uptodate
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_error
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_referenced
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_arch_1
)paren
)paren
suffix:semicolon
id|page-&gt;flags
op_assign
id|flags
op_or
(paren
l_int|1
op_lshift
id|PG_dirty
)paren
suffix:semicolon
id|add_to_page_cache_locked
c_func
(paren
id|page
comma
id|mapping
comma
id|idx
)paren
suffix:semicolon
id|info-&gt;swapped
op_decrement
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_lock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;u.shmem_sb.free_blocks
op_eq
l_int|0
)paren
r_goto
id|no_space
suffix:semicolon
id|inode-&gt;i_sb-&gt;u.shmem_sb.free_blocks
op_decrement
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
multiline_comment|/* Ok, get a new page */
id|page
op_assign
id|page_cache_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|oom
suffix:semicolon
id|clear_user_highpage
c_func
(paren
id|page
comma
id|address
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_increment
suffix:semicolon
id|add_to_page_cache
(paren
id|page
comma
id|mapping
comma
id|idx
)paren
suffix:semicolon
)brace
multiline_comment|/* We have the page */
id|SetPageUptodate
(paren
id|page
)paren
suffix:semicolon
id|cached_page
suffix:colon
id|UnlockPage
(paren
id|page
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|no_share
)paren
(brace
r_struct
id|page
op_star
id|new_page
op_assign
id|page_cache_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_page
)paren
(brace
id|copy_user_highpage
c_func
(paren
id|new_page
comma
id|page
comma
id|address
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|new_page
)paren
suffix:semicolon
)brace
r_else
id|new_page
op_assign
id|NOPAGE_OOM
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|new_page
suffix:semicolon
)brace
id|flush_page_to_ram
(paren
id|page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
id|no_space
suffix:colon
id|spin_unlock
(paren
op_amp
id|inode-&gt;i_sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|oom
suffix:colon
id|page
op_assign
id|NOPAGE_OOM
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|function|shmem_get_inode
r_struct
id|inode
op_star
id|shmem_get_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|mode
comma
r_int
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|spin_lock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;u.shmem_sb.free_inodes
)paren
(brace
id|spin_unlock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sb-&gt;u.shmem_sb.free_inodes
op_decrement
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|to_kdev_t
c_func
(paren
id|dev
)paren
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|shmem_aops
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|inode-&gt;u.shmem_i.lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_default
suffix:colon
id|init_special_inode
c_func
(paren
id|inode
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|shmem_file_operations
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|inode-&gt;i_op
op_assign
op_amp
id|shmem_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|shmem_dir_operations
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFLNK
suffix:colon
id|inode-&gt;i_op
op_assign
op_amp
id|page_symlink_inode_operations
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|inode-&gt;u.shmem_i.list
comma
op_amp
id|shmem_inodes
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
)brace
r_return
id|inode
suffix:semicolon
)brace
DECL|function|shmem_statfs
r_static
r_int
id|shmem_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
id|buf-&gt;f_type
op_assign
id|SHMEM_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|spin_lock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;u.shmem_sb.max_blocks
op_ne
id|ULONG_MAX
op_logical_or
id|sb-&gt;u.shmem_sb.max_inodes
op_ne
id|ULONG_MAX
)paren
(brace
id|buf-&gt;f_blocks
op_assign
id|sb-&gt;u.shmem_sb.max_blocks
suffix:semicolon
id|buf-&gt;f_bavail
op_assign
id|buf-&gt;f_bfree
op_assign
id|sb-&gt;u.shmem_sb.free_blocks
suffix:semicolon
id|buf-&gt;f_files
op_assign
id|sb-&gt;u.shmem_sb.max_inodes
suffix:semicolon
id|buf-&gt;f_ffree
op_assign
id|sb-&gt;u.shmem_sb.free_inodes
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
l_int|255
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup the data. This is trivial - if the dentry didn&squot;t already&n; * exist, we know it is negative.&n; */
DECL|function|shmem_lookup
r_static
r_struct
id|dentry
op_star
id|shmem_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|d_add
c_func
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * File creation. Allocate an inode, and we&squot;re done..&n; */
DECL|function|shmem_mknod
r_static
r_int
id|shmem_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|dir-&gt;i_sb
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Extra count - pin the dentry in core */
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_mkdir
r_static
r_int
id|shmem_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_return
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
op_or
id|S_IFDIR
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|shmem_create
r_static
r_int
id|shmem_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_return
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
op_or
id|S_IFREG
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Link a file..&n; */
DECL|function|shmem_link
r_static
r_int
id|shmem_link
c_func
(paren
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
multiline_comment|/* New dentry reference */
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Extra pinning count for the created dentry */
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_positive
r_static
r_inline
r_int
id|shmem_positive
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
id|dentry-&gt;d_inode
op_logical_and
op_logical_neg
id|d_unhashed
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that a directory is empty (this works&n; * for regular files too, they&squot;ll just always be&n; * considered empty..).&n; *&n; * Note that an empty directory can still have&n; * children, they just all have to be negative..&n; */
DECL|function|shmem_empty
r_static
r_int
id|shmem_empty
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|list
op_assign
id|dentry-&gt;d_subdirs.next
suffix:semicolon
r_while
c_loop
(paren
id|list
op_ne
op_amp
id|dentry-&gt;d_subdirs
)paren
(brace
r_struct
id|dentry
op_star
id|de
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shmem_positive
c_func
(paren
id|de
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This works for both directories and regular files.&n; * (non-directories will always have empty subdirs)&n; */
DECL|function|shmem_unlink
r_static
r_int
id|shmem_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_if
c_cond
(paren
id|shmem_empty
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Undo the count from &quot;create&quot; - this does all the work */
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|shmem_rmdir
mdefine_line|#define shmem_rmdir shmem_unlink
multiline_comment|/*&n; * The VFS layer already does all the dentry stuff for rename,&n; * we just have to decrement the usage count for the target if&n; * it exists so that the VFS layer correctly free&squot;s it when it&n; * gets overwritten.&n; */
DECL|function|shmem_rename
r_static
r_int
id|shmem_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_if
c_cond
(paren
id|shmem_empty
c_func
(paren
id|new_dentry
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|new_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_symlink
r_static
r_int
id|shmem_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|shmem_mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|S_IFLNK
op_or
id|S_IRWXUGO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_int
id|l
op_assign
id|strlen
c_func
(paren
id|symname
)paren
op_plus
l_int|1
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|error
op_assign
id|block_symlink
c_func
(paren
id|inode
comma
id|symname
comma
id|l
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|shmem_mmap
r_static
r_int
id|shmem_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_operations_struct
op_star
id|ops
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|ops
op_assign
op_amp
id|shmem_private_vm_ops
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
op_logical_and
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_MAYWRITE
)paren
)paren
id|ops
op_assign
op_amp
id|shmem_shared_vm_ops
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
id|ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_parse_options
r_static
r_int
id|shmem_parse_options
c_func
(paren
r_char
op_star
id|options
comma
r_int
op_star
id|mode
comma
r_int
r_int
op_star
id|blocks
comma
r_int
r_int
op_star
id|inodes
)paren
(brace
r_char
op_star
id|this_char
comma
op_star
id|value
suffix:semicolon
id|this_char
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|options
)paren
id|this_char
op_assign
id|strtok
c_func
(paren
id|options
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|this_char
suffix:semicolon
id|this_char
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
c_func
(paren
id|this_char
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|value
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;nr_blocks&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|blocks
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|blocks
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;nr_inodes&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|inodes
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|inodes
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;mode&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
op_logical_or
op_logical_neg
id|mode
)paren
r_return
l_int|1
suffix:semicolon
op_star
id|mode
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|value
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|value
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shmem_read_super
r_static
r_struct
id|super_block
op_star
id|shmem_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|root
suffix:semicolon
r_int
r_int
id|blocks
op_assign
id|ULONG_MAX
suffix:semicolon
multiline_comment|/* unlimited */
r_int
r_int
id|inodes
op_assign
id|ULONG_MAX
suffix:semicolon
multiline_comment|/* unlimited */
r_int
id|mode
op_assign
id|S_IRWXUGO
op_or
id|S_ISVTX
suffix:semicolon
r_if
c_cond
(paren
id|shmem_parse_options
(paren
id|data
comma
op_amp
id|mode
comma
op_amp
id|blocks
comma
op_amp
id|inodes
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;shmem fs invalid option&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|spin_lock_init
(paren
op_amp
id|sb-&gt;u.shmem_sb.stat_lock
)paren
suffix:semicolon
id|sb-&gt;u.shmem_sb.max_blocks
op_assign
id|blocks
suffix:semicolon
id|sb-&gt;u.shmem_sb.free_blocks
op_assign
id|blocks
suffix:semicolon
id|sb-&gt;u.shmem_sb.max_inodes
op_assign
id|inodes
suffix:semicolon
id|sb-&gt;u.shmem_sb.free_inodes
op_assign
id|inodes
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|SHMEM_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|shmem_ops
suffix:semicolon
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|sb
comma
id|S_IFDIR
op_or
id|mode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
l_int|NULL
suffix:semicolon
id|root
op_assign
id|d_alloc_root
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sb-&gt;s_root
op_assign
id|root
suffix:semicolon
r_return
id|sb
suffix:semicolon
)brace
DECL|function|shmem_remount_fs
r_static
r_int
id|shmem_remount_fs
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|data
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|max_blocks
comma
id|blocks
suffix:semicolon
r_int
r_int
id|max_inodes
comma
id|inodes
suffix:semicolon
r_struct
id|shmem_sb_info
op_star
id|info
op_assign
op_amp
id|sb-&gt;u.shmem_sb
suffix:semicolon
r_if
c_cond
(paren
id|shmem_parse_options
(paren
id|data
comma
l_int|NULL
comma
op_amp
id|max_blocks
comma
op_amp
id|max_inodes
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
id|blocks
op_assign
id|info-&gt;max_blocks
op_minus
id|info-&gt;free_blocks
suffix:semicolon
id|inodes
op_assign
id|info-&gt;max_inodes
op_minus
id|info-&gt;free_inodes
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|max_blocks
OL
id|blocks
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|max_inodes
OL
id|inodes
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|info-&gt;max_blocks
op_assign
id|max_blocks
suffix:semicolon
id|info-&gt;free_blocks
op_assign
id|max_blocks
op_minus
id|blocks
suffix:semicolon
id|info-&gt;max_inodes
op_assign
id|max_inodes
suffix:semicolon
id|info-&gt;free_inodes
op_assign
id|max_inodes
op_minus
id|inodes
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;stat_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|shmem_aops
r_static
r_struct
id|address_space_operations
id|shmem_aops
op_assign
(brace
id|writepage
suffix:colon
id|shmem_writepage
)brace
suffix:semicolon
DECL|variable|shmem_file_operations
r_static
r_struct
id|file_operations
id|shmem_file_operations
op_assign
(brace
id|mmap
suffix:colon
id|shmem_mmap
)brace
suffix:semicolon
DECL|variable|shmem_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_inode_operations
op_assign
(brace
id|truncate
suffix:colon
id|shmem_truncate
comma
)brace
suffix:semicolon
DECL|variable|shmem_dir_operations
r_static
r_struct
id|file_operations
id|shmem_dir_operations
op_assign
(brace
id|read
suffix:colon
id|generic_read_dir
comma
id|readdir
suffix:colon
id|dcache_readdir
comma
)brace
suffix:semicolon
DECL|variable|shmem_dir_inode_operations
r_static
r_struct
id|inode_operations
id|shmem_dir_inode_operations
op_assign
(brace
id|create
suffix:colon
id|shmem_create
comma
id|lookup
suffix:colon
id|shmem_lookup
comma
id|link
suffix:colon
id|shmem_link
comma
id|unlink
suffix:colon
id|shmem_unlink
comma
id|symlink
suffix:colon
id|shmem_symlink
comma
id|mkdir
suffix:colon
id|shmem_mkdir
comma
id|rmdir
suffix:colon
id|shmem_rmdir
comma
id|mknod
suffix:colon
id|shmem_mknod
comma
id|rename
suffix:colon
id|shmem_rename
comma
)brace
suffix:semicolon
DECL|variable|shmem_ops
r_static
r_struct
id|super_operations
id|shmem_ops
op_assign
(brace
id|statfs
suffix:colon
id|shmem_statfs
comma
id|remount_fs
suffix:colon
id|shmem_remount_fs
comma
id|delete_inode
suffix:colon
id|shmem_delete_inode
comma
id|put_inode
suffix:colon
id|force_delete
comma
)brace
suffix:semicolon
DECL|variable|shmem_private_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_private_vm_ops
op_assign
(brace
id|nopage
suffix:colon
id|shmem_nopage
comma
)brace
suffix:semicolon
DECL|variable|shmem_shared_vm_ops
r_static
r_struct
id|vm_operations_struct
id|shmem_shared_vm_ops
op_assign
(brace
id|nopage
suffix:colon
id|shmem_nopage
comma
)brace
suffix:semicolon
r_static
id|DECLARE_FSTYPE
c_func
(paren
id|shmem_fs_type
comma
l_string|&quot;shm&quot;
comma
id|shmem_read_super
comma
id|FS_LITTER
)paren
suffix:semicolon
DECL|function|init_shmem_fs
r_static
r_int
id|__init
id|init_shmem_fs
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|vfsmount
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|shmem_fs_type
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Could not register shmem fs&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|res
op_assign
id|kern_mount
c_func
(paren
op_amp
id|shmem_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|res
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;could not kern_mount shmem fs&bslash;n&quot;
)paren
suffix:semicolon
id|unregister_filesystem
c_func
(paren
op_amp
id|shmem_fs_type
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;shm&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|exit_shmem_fs
r_static
r_void
id|__exit
id|exit_shmem_fs
c_func
(paren
r_void
)paren
(brace
id|unregister_filesystem
c_func
(paren
op_amp
id|shmem_fs_type
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|init_shmem_fs
)paren
id|module_exit
c_func
(paren
id|exit_shmem_fs
)paren
DECL|function|shmem_clear_swp
r_static
r_int
id|shmem_clear_swp
(paren
id|swp_entry_t
id|entry
comma
id|swp_entry_t
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
id|swp_entry_t
op_star
id|test
suffix:semicolon
r_for
c_loop
(paren
id|test
op_assign
id|ptr
suffix:semicolon
id|test
OL
id|ptr
op_plus
id|size
suffix:semicolon
id|test
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test-&gt;val
op_eq
id|entry.val
)paren
(brace
id|swap_free
(paren
id|entry
)paren
suffix:semicolon
op_star
id|test
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
r_return
id|test
op_minus
id|ptr
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|shmem_unuse_inode
r_static
r_int
id|shmem_unuse_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|swp_entry_t
op_star
op_star
id|base
comma
op_star
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_struct
id|shmem_inode_info
op_star
id|info
op_assign
op_amp
id|inode-&gt;u.shmem_i
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
id|spin_lock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_assign
id|shmem_clear_swp
(paren
id|entry
comma
id|info-&gt;i_direct
comma
id|SHMEM_NR_DIRECT
)paren
)paren
op_ge
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|idx
op_assign
id|SHMEM_NR_DIRECT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|base
op_assign
id|info-&gt;i_indirect
)paren
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
id|base
suffix:semicolon
id|ptr
OL
id|base
op_plus
id|ENTRIES_PER_PAGE
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_logical_and
(paren
id|offset
op_assign
id|shmem_clear_swp
(paren
id|entry
comma
op_star
id|ptr
comma
id|ENTRIES_PER_PAGE
)paren
)paren
op_ge
l_int|0
)paren
r_goto
id|found
suffix:semicolon
id|idx
op_add_assign
id|ENTRIES_PER_PAGE
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|found
suffix:colon
id|add_to_page_cache
c_func
(paren
id|page
comma
id|inode-&gt;i_mapping
comma
id|offset
op_plus
id|idx
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|info-&gt;swapped
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * unuse_shmem() search for an eventually swapped out shmem page.&n; */
DECL|function|shmem_unuse
r_void
id|shmem_unuse
c_func
(paren
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|spin_lock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|shmem_inodes
)paren
(brace
id|inode
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|inode
comma
id|u.shmem_i.list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shmem_unuse_inode
c_func
(paren
id|inode
comma
id|entry
comma
id|page
)paren
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|shmem_ilock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_file_setup - get an unlinked file living in shmem fs&n; *&n; * @name: name for dentry (to be seen in /proc/&lt;pid&gt;/maps&n; * @size: size to be set for the file&n; *&n; */
DECL|function|shmem_file_setup
r_struct
id|file
op_star
id|shmem_file_setup
c_func
(paren
r_char
op_star
id|name
comma
id|loff_t
id|size
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|root
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_int
id|vm_enough_memory
c_func
(paren
r_int
id|pages
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
(paren
id|size
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_goto
id|out
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* will go */
id|root
op_assign
id|shmem_fs_type.kern_mnt-&gt;mnt_root
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|put_dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|inode
op_assign
id|shmem_get_inode
c_func
(paren
id|root-&gt;d_sb
comma
id|S_IFREG
op_or
id|S_IRWXUGO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|close_file
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dentry-&gt;d_inode-&gt;i_size
op_assign
id|size
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|shmem_fs_type.kern_mnt
)paren
suffix:semicolon
id|file-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|shmem_file_operations
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_WRITE
op_or
id|FMODE_READ
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* It is unlinked */
r_return
id|file
suffix:semicolon
id|close_file
suffix:colon
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|put_dentry
suffix:colon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shmem_zero_setup - setup a shared anonymous mapping&n; *&n; * @vma: the vma to be mmapped is prepared by do_mmap_pgoff&n; */
DECL|function|shmem_zero_setup
r_int
id|shmem_zero_setup
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
id|loff_t
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
id|file
op_assign
id|shmem_file_setup
c_func
(paren
l_string|&quot;dev/zero&quot;
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|fput
(paren
id|vma-&gt;vm_file
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
op_amp
id|shmem_shared_vm_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
