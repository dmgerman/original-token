multiline_comment|/*&n; *  linux/mm/swap.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; */
multiline_comment|/*&n; * This file should contain most things doing the swapping from/to disk.&n; * Started 18.12.91&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;asm/system.h&gt; /* for cli()/sti() */
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|MAX_SWAPFILES
mdefine_line|#define MAX_SWAPFILES 8
DECL|macro|SWP_USED
mdefine_line|#define SWP_USED&t;1
DECL|macro|SWP_WRITEOK
mdefine_line|#define SWP_WRITEOK&t;3
DECL|macro|SWP_TYPE
mdefine_line|#define SWP_TYPE(entry) (((entry) &amp; 0xfe) &gt;&gt; 1)
DECL|macro|SWP_OFFSET
mdefine_line|#define SWP_OFFSET(entry) ((entry) &gt;&gt; PAGE_SHIFT)
DECL|macro|SWP_ENTRY
mdefine_line|#define SWP_ENTRY(type,offset) (((type) &lt;&lt; 1) | ((offset) &lt;&lt; PAGE_SHIFT))
DECL|variable|min_free_pages
r_int
id|min_free_pages
op_assign
l_int|20
suffix:semicolon
DECL|variable|nr_swapfiles
r_static
r_int
id|nr_swapfiles
op_assign
l_int|0
suffix:semicolon
DECL|variable|lock_queue
r_static
r_struct
id|wait_queue
op_star
id|lock_queue
op_assign
l_int|NULL
suffix:semicolon
DECL|struct|swap_info_struct
r_static
r_struct
id|swap_info_struct
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|swap_file
r_struct
id|inode
op_star
id|swap_file
suffix:semicolon
DECL|member|swap_device
r_int
r_int
id|swap_device
suffix:semicolon
DECL|member|swap_map
r_int
r_char
op_star
id|swap_map
suffix:semicolon
DECL|member|swap_lockmap
r_int
r_char
op_star
id|swap_lockmap
suffix:semicolon
DECL|member|pages
r_int
id|pages
suffix:semicolon
DECL|member|lowest_bit
r_int
id|lowest_bit
suffix:semicolon
DECL|member|highest_bit
r_int
id|highest_bit
suffix:semicolon
DECL|member|max
r_int
r_int
id|max
suffix:semicolon
DECL|variable|swap_info
)brace
id|swap_info
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
r_extern
r_int
id|shm_swap
(paren
r_int
)paren
suffix:semicolon
DECL|variable|swap_cache
r_int
r_int
op_star
id|swap_cache
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
DECL|variable|swap_cache_add_total
r_int
r_int
id|swap_cache_add_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_add_success
r_int
r_int
id|swap_cache_add_success
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_del_total
r_int
r_int
id|swap_cache_del_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_del_success
r_int
r_int
id|swap_cache_del_success
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_find_total
r_int
r_int
id|swap_cache_find_total
op_assign
l_int|0
suffix:semicolon
DECL|variable|swap_cache_find_success
r_int
r_int
id|swap_cache_find_success
op_assign
l_int|0
suffix:semicolon
DECL|function|show_swap_cache_info
r_extern
r_inline
r_void
id|show_swap_cache_info
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Swap cache: add %ld/%ld, delete %ld/%ld, find %ld/%ld&bslash;n&quot;
comma
id|swap_cache_add_total
comma
id|swap_cache_add_success
comma
id|swap_cache_del_total
comma
id|swap_cache_del_success
comma
id|swap_cache_find_total
comma
id|swap_cache_find_success
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|add_to_swap_cache
r_extern
r_inline
r_int
id|add_to_swap_cache
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
op_assign
op_amp
id|swap_info
(braket
id|SWP_TYPE
c_func
(paren
id|entry
)paren
)braket
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_add_total
op_increment
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_WRITEOK
)paren
op_eq
id|SWP_WRITEOK
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;xchgl %0,%1&bslash;n&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|swap_cache
(braket
id|addr
op_rshift
id|PAGE_SHIFT
)braket
)paren
comma
l_string|&quot;=r&quot;
(paren
id|entry
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|swap_cache
(braket
id|addr
op_rshift
id|PAGE_SHIFT
)braket
)paren
comma
l_string|&quot;1&quot;
(paren
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_cache: replacing non-NULL entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef SWAP_CACHE_INFO
id|swap_cache_add_success
op_increment
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_swap_cache
r_static
r_int
r_int
id|init_swap_cache
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_int
r_int
id|swap_cache_size
suffix:semicolon
id|mem_start
op_assign
(paren
id|mem_start
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
id|swap_cache
op_assign
(paren
r_int
r_int
op_star
)paren
id|mem_start
suffix:semicolon
id|swap_cache_size
op_assign
id|mem_end
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|memset
c_func
(paren
id|swap_cache
comma
l_int|0
comma
id|swap_cache_size
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
(paren
id|swap_cache
op_plus
id|swap_cache_size
)paren
suffix:semicolon
)brace
DECL|function|rw_swap_page
r_void
id|rw_swap_page
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_char
op_star
id|buf
)paren
(brace
r_int
r_int
id|type
comma
id|offset
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Internal error: bad swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to swap to unused swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|set_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|sleep_on
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|kstat.pswpin
op_increment
suffix:semicolon
r_else
id|kstat.pswpout
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
)paren
(brace
id|ll_rw_page
c_func
(paren
id|rw
comma
id|p-&gt;swap_device
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
r_struct
id|inode
op_star
id|swapf
op_assign
id|p-&gt;swap_file
suffix:semicolon
r_int
r_int
id|zones
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|swapf-&gt;i_op-&gt;bmap
op_eq
l_int|NULL
op_logical_and
id|swapf-&gt;i_op-&gt;smap
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;With MsDOS, we use msdos_smap which return&n;&t;&t;&t;&t;a sector number (not a cluster or block number).&n;&t;&t;&t;&t;It is a patch to enable the UMSDOS project.&n;&t;&t;&t;&t;Other people are working on better solution.&n;&n;&t;&t;&t;&t;It sounds like ll_rw_swap_file defined&n;&t;&t;&t;&t;it operation size (sector size) based on&n;&t;&t;&t;&t;PAGE_SIZE and the number of block to read.&n;&t;&t;&t;&t;So using bmap or smap should work even if&n;&t;&t;&t;&t;smap will require more blocks.&n;&t;&t;&t;*/
r_int
id|j
suffix:semicolon
r_int
r_int
id|block
op_assign
id|offset
op_lshift
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
l_int|512
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|zones
(braket
id|i
)braket
op_assign
id|swapf-&gt;i_op
op_member_access_from_pointer
id|smap
c_func
(paren
id|swapf
comma
id|block
op_increment
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: bad swap file&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_int
id|j
suffix:semicolon
r_int
r_int
id|block
op_assign
id|offset
op_lshift
(paren
l_int|12
op_minus
id|swapf-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
id|swapf-&gt;i_sb-&gt;s_blocksize
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|zones
(braket
id|i
)braket
op_assign
id|bmap
c_func
(paren
id|swapf
comma
id|block
op_increment
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: bad swap file&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|ll_rw_swap_file
c_func
(paren
id|rw
comma
id|swapf-&gt;i_dev
comma
id|zones
comma
id|i
comma
id|buf
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;re_swap_page: no swap file or device&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_logical_and
op_logical_neg
id|clear_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: lock already cleared&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
)brace
DECL|function|get_swap_page
r_int
r_int
id|get_swap_page
c_func
(paren
r_void
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_WRITEOK
)paren
op_ne
id|SWP_WRITEOK
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
id|p-&gt;lowest_bit
suffix:semicolon
id|offset
op_le
id|p-&gt;highest_bit
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_continue
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_assign
l_int|1
suffix:semicolon
id|nr_swap_pages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
id|p-&gt;highest_bit
)paren
id|p-&gt;highest_bit
op_decrement
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
id|offset
suffix:semicolon
r_return
id|SWP_ENTRY
c_func
(paren
id|type
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swap_duplicate
r_int
r_int
id|swap_duplicate
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|SHM_SWP_TYPE
)paren
r_return
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to duplicate nonexistent swap-page&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_duplicate: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_duplicate: trying to duplicate unused page&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p-&gt;swap_map
(braket
id|offset
)braket
op_increment
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
DECL|function|swap_free
r_void
id|swap_free
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|SHM_SWP_TYPE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free nonexistent swap-page&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_free: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free swap from unused swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|set_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|sleep_on
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|p-&gt;highest_bit
)paren
id|p-&gt;highest_bit
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;swap_free: swap-space map bad (entry %08lx)&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
id|nr_swap_pages
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;swap_free: lock already cleared&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
)brace
DECL|function|swap_in
r_int
r_int
id|swap_in
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|oom
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
id|BAD_PAGE
suffix:semicolon
)brace
id|read_swap_page
c_func
(paren
id|entry
comma
(paren
r_char
op_star
)paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_to_swap_cache
c_func
(paren
id|page
comma
id|entry
)paren
)paren
r_return
id|page
op_or
id|PAGE_PRESENT
suffix:semicolon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
id|page
op_or
id|PAGE_DIRTY
op_or
id|PAGE_PRESENT
suffix:semicolon
)brace
DECL|function|try_to_swap_out
r_static
r_inline
r_int
id|try_to_swap_out
c_func
(paren
r_int
r_int
op_star
id|table_ptr
)paren
(brace
r_int
r_int
id|page
comma
id|entry
suffix:semicolon
id|page
op_assign
op_star
id|table_ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PAGE_PRESENT
op_amp
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|page
op_ge
id|high_memory
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_amp
id|MAP_PAGE_RESERVED
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|PAGE_DIRTY
op_amp
id|page
)paren
op_logical_and
id|delete_from_swap_cache
c_func
(paren
id|page
)paren
)paren
(brace
op_star
id|table_ptr
op_and_assign
op_complement
id|PAGE_ACCESSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PAGE_ACCESSED
op_amp
id|page
)paren
(brace
op_star
id|table_ptr
op_and_assign
op_complement
id|PAGE_ACCESSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PAGE_DIRTY
op_amp
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_ne
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|table_ptr
op_assign
id|entry
suffix:semicolon
id|invalidate
c_func
(paren
)paren
suffix:semicolon
id|write_swap_page
c_func
(paren
id|entry
comma
(paren
r_char
op_star
)paren
id|page
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|find_in_swap_cache
c_func
(paren
id|page
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_ne
l_int|1
)paren
(brace
op_star
id|table_ptr
op_or_assign
id|PAGE_DIRTY
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aiee.. duplicated cached swap-cache entry&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|table_ptr
op_assign
id|entry
suffix:semicolon
id|invalidate
c_func
(paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
op_star
id|table_ptr
op_assign
l_int|0
suffix:semicolon
id|invalidate
c_func
(paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
op_plus
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * A new implementation of swap_out().  We do not swap complete processes,&n; * but only a small number of blocks, before we continue with the next&n; * process.  The number of blocks actually swapped is determined on the&n; * number of page faults, that this process actually had in the last time,&n; * so we won&squot;t swap heavily used processes all the time ...&n; *&n; * Note: the priority argument is a hint on much CPU to waste with the&n; *       swap block search, not a hint, of how much blocks to swap with&n; *       each process.&n; *&n; * (C) 1993 Kai Petzke, wpp@marie.physik.tu-berlin.de&n; */
multiline_comment|/*&n; * These are the minimum and maximum number of pages to swap from one process,&n; * before proceeding to the next:&n; */
DECL|macro|SWAP_MIN
mdefine_line|#define SWAP_MIN&t;4
DECL|macro|SWAP_MAX
mdefine_line|#define SWAP_MAX&t;32
multiline_comment|/*&n; * The actual number of pages to swap is determined as:&n; * SWAP_RATIO / (number of recent major page faults)&n; */
DECL|macro|SWAP_RATIO
mdefine_line|#define SWAP_RATIO&t;128
DECL|function|swap_out_process
r_static
r_int
id|swap_out_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
op_star
id|pgdir
suffix:semicolon
r_int
r_int
id|pg_table
suffix:semicolon
multiline_comment|/*&n;&t; * Go through process&squot; page directory.&n;&t; */
id|address
op_assign
id|p-&gt;mm-&gt;swap_address
suffix:semicolon
id|pgdir
op_assign
(paren
id|address
op_rshift
id|PGDIR_SHIFT
)paren
op_plus
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.cr3
suffix:semicolon
id|offset
op_assign
id|address
op_amp
op_complement
id|PGDIR_MASK
suffix:semicolon
id|address
op_and_assign
id|PGDIR_MASK
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|address
OL
id|TASK_SIZE
suffix:semicolon
id|pgdir
op_increment
comma
id|address
op_assign
id|address
op_plus
id|PGDIR_SIZE
comma
id|offset
op_assign
l_int|0
)paren
(brace
id|pg_table
op_assign
op_star
id|pgdir
suffix:semicolon
r_if
c_cond
(paren
id|pg_table
op_ge
id|high_memory
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|pg_table
)paren
)braket
op_amp
id|MAP_PAGE_RESERVED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PAGE_PRESENT
op_amp
id|pg_table
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_out_process (%s): bad page-table at vm %08lx: %08lx&bslash;n&quot;
comma
id|p-&gt;comm
comma
id|address
op_plus
id|offset
comma
id|pg_table
)paren
suffix:semicolon
op_star
id|pgdir
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pg_table
op_and_assign
l_int|0xfffff000
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go through this page table.&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|offset
OL
op_complement
id|PGDIR_MASK
suffix:semicolon
id|offset
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_switch
c_cond
(paren
id|try_to_swap_out
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|pg_table
op_plus
(paren
id|offset
op_rshift
l_int|10
)paren
)paren
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|p-&gt;mm-&gt;rss
op_decrement
suffix:semicolon
multiline_comment|/* continue with the following page the next time */
id|p-&gt;mm-&gt;swap_address
op_assign
id|address
op_plus
id|offset
op_plus
id|PAGE_SIZE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
id|p-&gt;mm-&gt;rss
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Finish work with this process, if we reached the end of the page&n;&t; * directory.  Mark restart from the beginning the next time.&n;&t; */
id|p-&gt;mm-&gt;swap_address
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swap_out
r_static
r_int
id|swap_out
c_func
(paren
r_int
r_int
id|priority
)paren
(brace
r_static
r_int
id|swap_task
suffix:semicolon
r_int
id|loop
suffix:semicolon
r_int
id|counter
op_assign
id|NR_TASKS
op_star
l_int|2
op_rshift
id|priority
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|counter
op_assign
id|NR_TASKS
op_star
l_int|2
op_rshift
id|priority
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|counter
op_ge
l_int|0
suffix:semicolon
id|counter
op_decrement
comma
id|swap_task
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Check that swap_task is suitable for swapping.  If not, look for&n;&t;&t; * the next suitable process.&n;&t;&t; */
id|loop
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|swap_task
op_ge
id|NR_TASKS
)paren
(brace
id|swap_task
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|loop
)paren
multiline_comment|/* all processes are unswappable or already swapped out */
r_return
l_int|0
suffix:semicolon
id|loop
op_assign
l_int|1
suffix:semicolon
)brace
id|p
op_assign
id|task
(braket
id|swap_task
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p
op_logical_and
id|p-&gt;mm-&gt;swappable
op_logical_and
id|p-&gt;mm-&gt;rss
)paren
r_break
suffix:semicolon
id|swap_task
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Determine the number of pages to swap from this process.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;mm-&gt;swap_cnt
)paren
(brace
id|p-&gt;mm-&gt;dec_flt
op_assign
(paren
id|p-&gt;mm-&gt;dec_flt
op_star
l_int|3
)paren
op_div
l_int|4
op_plus
id|p-&gt;mm-&gt;maj_flt
op_minus
id|p-&gt;mm-&gt;old_maj_flt
suffix:semicolon
id|p-&gt;mm-&gt;old_maj_flt
op_assign
id|p-&gt;mm-&gt;maj_flt
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;mm-&gt;dec_flt
op_ge
id|SWAP_RATIO
op_div
id|SWAP_MIN
)paren
(brace
id|p-&gt;mm-&gt;dec_flt
op_assign
id|SWAP_RATIO
op_div
id|SWAP_MIN
suffix:semicolon
id|p-&gt;mm-&gt;swap_cnt
op_assign
id|SWAP_MIN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;mm-&gt;dec_flt
op_le
id|SWAP_RATIO
op_div
id|SWAP_MAX
)paren
id|p-&gt;mm-&gt;swap_cnt
op_assign
id|SWAP_MAX
suffix:semicolon
r_else
id|p-&gt;mm-&gt;swap_cnt
op_assign
id|SWAP_RATIO
op_div
id|p-&gt;mm-&gt;dec_flt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swap_out_process
c_func
(paren
id|p
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_decrement
id|p-&gt;mm-&gt;swap_cnt
)paren
op_eq
l_int|0
)paren
id|swap_task
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|try_to_free_page
r_static
r_int
id|try_to_free_page
c_func
(paren
r_int
id|priority
)paren
(brace
r_int
id|i
op_assign
l_int|6
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|priority
op_ne
id|GFP_NOBUFFER
op_logical_and
id|shrink_buffers
c_func
(paren
id|i
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|shm_swap
c_func
(paren
id|i
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|swap_out
c_func
(paren
id|i
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_mem_queue
r_static
r_inline
r_void
id|add_mem_queue
c_func
(paren
r_struct
id|mem_list
op_star
id|head
comma
r_struct
id|mem_list
op_star
id|entry
)paren
(brace
id|entry-&gt;prev
op_assign
id|head
suffix:semicolon
id|entry-&gt;next
op_assign
id|head-&gt;next
suffix:semicolon
id|entry-&gt;next-&gt;prev
op_assign
id|entry
suffix:semicolon
id|head-&gt;next
op_assign
id|entry
suffix:semicolon
)brace
DECL|function|remove_mem_queue
r_static
r_inline
r_void
id|remove_mem_queue
c_func
(paren
r_struct
id|mem_list
op_star
id|head
comma
r_struct
id|mem_list
op_star
id|entry
)paren
(brace
id|entry-&gt;next-&gt;prev
op_assign
id|entry-&gt;prev
suffix:semicolon
id|entry-&gt;prev-&gt;next
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n; * Free_page() adds the page to the free lists. This is optimized for&n; * fast normal cases (no error jumps taken normally).&n; *&n; * The way to optimize jumps for gcc-2.2.2 is to:&n; *  - select the &quot;normal&quot; case and put it inside the if () { XXX }&n; *  - no else-statements if you can avoid them&n; *&n; * With the above two rules, you get a straight-line execution path&n; * for the normal case, giving better asm-code.&n; */
multiline_comment|/*&n; * Buddy system. Hairy. You really aren&squot;t expected to understand this&n; */
DECL|function|free_pages_ok
r_static
r_inline
r_void
id|free_pages_ok
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|order
)paren
(brace
r_int
r_int
id|index
op_assign
id|addr
op_rshift
(paren
id|PAGE_SHIFT
op_plus
l_int|1
op_plus
id|order
)paren
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|PAGE_MASK
op_lshift
id|order
suffix:semicolon
id|addr
op_and_assign
id|mask
suffix:semicolon
id|nr_free_pages
op_add_assign
l_int|1
op_lshift
id|order
suffix:semicolon
r_while
c_loop
(paren
id|order
OL
id|NR_MEM_LISTS
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|change_bit
c_func
(paren
id|index
comma
id|free_area_map
(braket
id|order
)braket
)paren
)paren
r_break
suffix:semicolon
id|remove_mem_queue
c_func
(paren
id|free_area_list
op_plus
id|order
comma
(paren
r_struct
id|mem_list
op_star
)paren
(paren
id|addr
op_xor
(paren
l_int|1
op_plus
op_complement
id|mask
)paren
)paren
)paren
suffix:semicolon
id|order
op_increment
suffix:semicolon
id|index
op_rshift_assign
l_int|1
suffix:semicolon
id|mask
op_lshift_assign
l_int|1
suffix:semicolon
id|addr
op_and_assign
id|mask
suffix:semicolon
)brace
id|add_mem_queue
c_func
(paren
id|free_area_list
op_plus
id|order
comma
(paren
r_struct
id|mem_list
op_star
)paren
id|addr
)paren
suffix:semicolon
)brace
DECL|function|check_free_buffers
r_static
r_inline
r_void
id|check_free_buffers
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|buffer_pages
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tmp-&gt;b_list
op_eq
id|BUF_SHARED
op_logical_and
id|tmp-&gt;b_dev
op_ne
l_int|0xffff
)paren
id|refile_buffer
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_pages
r_void
id|free_pages
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
id|addr
OL
id|high_memory
)paren
(brace
r_int
r_int
id|flag
suffix:semicolon
r_int
r_int
op_star
id|map
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|map
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|map
op_amp
id|MAP_PAGE_RESERVED
)paren
)paren
(brace
id|save_flags
c_func
(paren
id|flag
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
op_star
id|map
)paren
(brace
id|free_pages_ok
c_func
(paren
id|addr
comma
id|order
)paren
suffix:semicolon
id|delete_from_swap_cache
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|map
op_eq
l_int|1
)paren
id|check_free_buffers
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free memory (%08lx): memory probably corrupted&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PC = %08lx&bslash;n&quot;
comma
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|addr
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Some ugly macros to speed up __get_free_pages()..&n; */
DECL|macro|RMQUEUE
mdefine_line|#define RMQUEUE(order) &bslash;&n;do { struct mem_list * queue = free_area_list+order; &bslash;&n;     unsigned long new_order = order; &bslash;&n;&t;do { struct mem_list *next = queue-&gt;next; &bslash;&n;&t;&t;if (queue != next) { &bslash;&n;&t;&t;&t;(queue-&gt;next = next-&gt;next)-&gt;prev = queue; &bslash;&n;&t;&t;&t;mark_used((unsigned long) next, new_order); &bslash;&n;&t;&t;&t;nr_free_pages -= 1 &lt;&lt; order; &bslash;&n;&t;&t;&t;restore_flags(flags); &bslash;&n;&t;&t;&t;EXPAND(next, order, new_order); &bslash;&n;&t;&t;&t;return (unsigned long) next; &bslash;&n;&t;&t;} new_order++; queue++; &bslash;&n;&t;} while (new_order &lt; NR_MEM_LISTS); &bslash;&n;} while (0)
DECL|function|mark_used
r_static
r_inline
r_int
id|mark_used
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|order
)paren
(brace
r_return
id|change_bit
c_func
(paren
id|addr
op_rshift
(paren
id|PAGE_SHIFT
op_plus
l_int|1
op_plus
id|order
)paren
comma
id|free_area_map
(braket
id|order
)braket
)paren
suffix:semicolon
)brace
DECL|macro|EXPAND
mdefine_line|#define EXPAND(addr,low,high) &bslash;&n;do { unsigned long size = PAGE_SIZE &lt;&lt; high; &bslash;&n;&t;while (high &gt; low) { &bslash;&n;&t;&t;high--; size &gt;&gt;= 1; cli(); &bslash;&n;&t;&t;add_mem_queue(free_area_list+high, addr); &bslash;&n;&t;&t;mark_used((unsigned long) addr, high); &bslash;&n;&t;&t;restore_flags(flags); &bslash;&n;&t;&t;addr = (struct mem_list *) (size + (unsigned long) addr); &bslash;&n;&t;} mem_map[MAP_NR((unsigned long) addr)] = 1; &bslash;&n;} while (0)
DECL|function|__get_free_pages
r_int
r_int
id|__get_free_pages
c_func
(paren
r_int
id|priority
comma
r_int
r_int
id|order
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|reserved_pages
suffix:semicolon
r_if
c_cond
(paren
id|intr_count
op_logical_and
id|priority
op_ne
id|GFP_ATOMIC
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;gfp called nonatomically from interrupt %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|priority
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
)brace
id|reserved_pages
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|priority
op_ne
id|GFP_NFS
)paren
id|reserved_pages
op_assign
id|min_free_pages
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|repeat
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|priority
op_eq
id|GFP_ATOMIC
)paren
op_logical_or
id|nr_free_pages
OG
id|reserved_pages
)paren
(brace
id|RMQUEUE
c_func
(paren
id|order
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priority
op_ne
id|GFP_BUFFER
op_logical_and
id|try_to_free_page
c_func
(paren
id|priority
)paren
)paren
r_goto
id|repeat
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Yes, I know this is ugly. Don&squot;t tell me.&n; */
DECL|function|__get_dma_pages
r_int
r_int
id|__get_dma_pages
c_func
(paren
r_int
id|priority
comma
r_int
r_int
id|order
)paren
(brace
r_int
r_int
id|list
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
r_int
r_int
id|limit
op_assign
l_int|16
op_star
l_int|1024
op_star
l_int|1024
suffix:semicolon
multiline_comment|/* if (EISA_bus) limit = ~0UL; */
r_if
c_cond
(paren
id|priority
op_ne
id|GFP_ATOMIC
)paren
id|priority
op_assign
id|GFP_BUFFER
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|result
op_assign
id|__get_free_pages
c_func
(paren
id|priority
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
id|limit
)paren
multiline_comment|/* covers failure as well */
r_break
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|result
op_assign
id|list
suffix:semicolon
id|list
op_assign
id|result
suffix:semicolon
)brace
r_while
c_loop
(paren
id|list
)paren
(brace
r_int
r_int
id|tmp
op_assign
id|list
suffix:semicolon
id|list
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|list
suffix:semicolon
id|free_pages
c_func
(paren
id|tmp
comma
id|order
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Show free area list (used inside shift_scroll-lock stuff)&n; * We also calculate the percentage fragmentation. We do this by counting the&n; * memory on each free list with the exception of the first item on the list.&n; */
DECL|function|show_free_areas
r_void
id|show_free_areas
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|order
comma
id|flags
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Free pages:      %6dkB&bslash;n ( &quot;
comma
id|nr_free_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
id|NR_MEM_LISTS
suffix:semicolon
id|order
op_increment
)paren
(brace
r_struct
id|mem_list
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|free_area_list
(braket
id|order
)braket
dot
id|next
suffix:semicolon
id|tmp
op_ne
id|free_area_list
op_plus
id|order
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
id|nr
op_increment
suffix:semicolon
)brace
id|total
op_add_assign
id|nr
op_star
(paren
l_int|4
op_lshift
id|order
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu*%ukB &quot;
comma
id|nr
comma
l_int|4
op_lshift
id|order
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;= %lukB)&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
macro_line|#ifdef SWAP_CACHE_INFO
id|show_swap_cache_info
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; * Trying to stop swapping from a file is fraught with races, so&n; * we repeat quite a bit here when we have to pause. swapoff()&n; * isn&squot;t exactly timing-critical, so who cares?&n; */
DECL|function|try_to_unuse
r_static
r_int
id|try_to_unuse
c_func
(paren
r_int
r_int
id|type
)paren
(brace
r_int
id|nr
comma
id|pgt
comma
id|pg
suffix:semicolon
r_int
r_int
id|page
comma
op_star
id|ppage
suffix:semicolon
r_int
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|nr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * When we have to sleep, we restart the whole algorithm from the same&n; * task we stopped in. That at least rids us of all races.&n; */
id|repeat
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|nr
OL
id|NR_TASKS
suffix:semicolon
id|nr
op_increment
)paren
(brace
id|p
op_assign
id|task
(braket
id|nr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|pgt
op_assign
l_int|0
suffix:semicolon
id|pgt
OL
id|PTRS_PER_PAGE
suffix:semicolon
id|pgt
op_increment
)paren
(brace
id|ppage
op_assign
id|pgt
op_plus
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.cr3
)paren
suffix:semicolon
id|page
op_assign
op_star
id|ppage
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_amp
id|PAGE_PRESENT
)paren
op_logical_or
(paren
id|page
op_ge
id|high_memory
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_amp
id|MAP_PAGE_RESERVED
)paren
r_continue
suffix:semicolon
id|ppage
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|page
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pg
op_assign
l_int|0
suffix:semicolon
id|pg
OL
id|PTRS_PER_PAGE
suffix:semicolon
id|pg
op_increment
comma
id|ppage
op_increment
)paren
(brace
id|page
op_assign
op_star
id|ppage
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|page
op_amp
id|PAGE_PRESENT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|in_swap_cache
c_func
(paren
id|page
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|SWP_TYPE
c_func
(paren
id|page
)paren
op_ne
id|type
)paren
r_continue
suffix:semicolon
op_star
id|ppage
op_or_assign
id|PAGE_DIRTY
suffix:semicolon
id|delete_from_swap_cache
c_func
(paren
op_star
id|ppage
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SWP_TYPE
c_func
(paren
id|page
)paren
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|read_swap_page
c_func
(paren
id|page
comma
(paren
r_char
op_star
)paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppage
op_eq
id|page
)paren
(brace
op_star
id|ppage
op_assign
id|tmp
op_or
(paren
id|PAGE_DIRTY
op_or
id|PAGE_PRIVATE
)paren
suffix:semicolon
op_increment
id|p-&gt;mm-&gt;rss
suffix:semicolon
id|swap_free
c_func
(paren
id|page
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
)brace
)brace
id|free_page
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_swapoff
id|asmlinkage
r_int
id|sys_swapoff
c_func
(paren
r_const
r_char
op_star
id|specialfile
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|namei
c_func
(paren
id|specialfile
comma
op_amp
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_WRITEOK
)paren
op_ne
id|SWP_WRITEOK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_file
op_eq
id|inode
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
op_eq
id|inode-&gt;i_rdev
)paren
r_break
suffix:semicolon
)brace
)brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|i
op_assign
id|try_to_unuse
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|p-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|nr_swap_pages
op_sub_assign
id|p-&gt;pages
suffix:semicolon
id|iput
c_func
(paren
id|p-&gt;swap_file
)paren
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|vfree
c_func
(paren
id|p-&gt;swap_map
)paren
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
)paren
id|p-&gt;swap_lockmap
)paren
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Written 01/25/92 by Simmule Turner, heavily changed by Linus.&n; *&n; * The swapon system call&n; */
DECL|function|sys_swapon
id|asmlinkage
r_int
id|sys_swapon
c_func
(paren
r_const
r_char
op_star
id|specialfile
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_struct
id|inode
op_star
id|swap_inode
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|MAX_SWAPFILES
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
id|nr_swapfiles
op_assign
id|type
op_plus
l_int|1
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;max
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|namei
c_func
(paren
id|specialfile
comma
op_amp
id|swap_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bad_swap
suffix:semicolon
id|p-&gt;swap_file
op_assign
id|swap_inode
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|swap_inode-&gt;i_count
op_ne
l_int|1
)paren
r_goto
id|bad_swap
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|swap_inode-&gt;i_mode
)paren
)paren
(brace
id|p-&gt;swap_device
op_assign
id|swap_inode-&gt;i_rdev
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|iput
c_func
(paren
id|swap_inode
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_device
)paren
r_goto
id|bad_swap
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
op_eq
id|swap_info
(braket
id|i
)braket
dot
id|swap_device
)paren
r_goto
id|bad_swap
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|swap_inode-&gt;i_mode
)paren
)paren
r_goto
id|bad_swap
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_lockmap
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to start swapping: out of memory :-)&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|read_swap_page
c_func
(paren
id|SWP_ENTRY
c_func
(paren
id|type
comma
l_int|0
)paren
comma
(paren
r_char
op_star
)paren
id|p-&gt;swap_lockmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|p-&gt;swap_lockmap
op_plus
l_int|4086
comma
l_int|10
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to find swap-space signature&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|memset
c_func
(paren
id|p-&gt;swap_lockmap
op_plus
id|PAGE_SIZE
op_minus
l_int|10
comma
l_int|0
comma
l_int|10
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
op_star
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
id|p-&gt;swap_lockmap
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|i
suffix:semicolon
id|p-&gt;highest_bit
op_assign
id|i
suffix:semicolon
id|p-&gt;max
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|j
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Empty swap-file&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|p-&gt;swap_map
op_assign
(paren
r_int
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|p-&gt;max
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|p-&gt;max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
l_int|0x80
suffix:semicolon
)brace
id|p-&gt;swap_map
(braket
l_int|0
)braket
op_assign
l_int|0x80
suffix:semicolon
id|memset
c_func
(paren
id|p-&gt;swap_lockmap
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
id|p-&gt;pages
op_assign
id|j
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Adding Swap: %dk swap-space&bslash;n&quot;
comma
id|j
op_lshift
l_int|2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad_swap
suffix:colon
id|free_page
c_func
(paren
(paren
r_int
)paren
id|p-&gt;swap_lockmap
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|p-&gt;swap_map
)paren
suffix:semicolon
id|iput
c_func
(paren
id|p-&gt;swap_file
)paren
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|si_swapinfo
r_void
id|si_swapinfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
id|val-&gt;freeswap
op_assign
id|val-&gt;totalswap
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_amp
id|SWP_WRITEOK
)paren
op_ne
id|SWP_WRITEOK
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|swap_info
(braket
id|i
)braket
dot
id|max
suffix:semicolon
op_increment
id|j
)paren
r_switch
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|swap_map
(braket
id|j
)braket
)paren
(brace
r_case
l_int|128
suffix:colon
r_continue
suffix:semicolon
r_case
l_int|0
suffix:colon
op_increment
id|val-&gt;freeswap
suffix:semicolon
r_default
suffix:colon
op_increment
id|val-&gt;totalswap
suffix:semicolon
)brace
)brace
id|val-&gt;freeswap
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;totalswap
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * set up the free-area data structures:&n; *   - mark all pages MAP_PAGE_RESERVED&n; *   - mark all memory queues empty&n; *   - clear the memory bitmaps&n; */
DECL|function|free_area_init
r_int
r_int
id|free_area_init
c_func
(paren
r_int
r_int
id|start_mem
comma
r_int
r_int
id|end_mem
)paren
(brace
r_int
r_int
op_star
id|p
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|PAGE_MASK
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * select nr of pages we try to keep free for important stuff&n;&t; * with a minimum of 16 pages. This is totally arbitrary&n;&t; */
id|i
op_assign
id|end_mem
op_rshift
(paren
id|PAGE_SHIFT
op_plus
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|16
)paren
id|i
op_assign
l_int|16
suffix:semicolon
id|min_free_pages
op_assign
id|i
suffix:semicolon
id|start_mem
op_assign
id|init_swap_cache
c_func
(paren
id|start_mem
comma
id|end_mem
)paren
suffix:semicolon
id|mem_map
op_assign
(paren
r_int
r_int
op_star
)paren
id|start_mem
suffix:semicolon
id|p
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|end_mem
)paren
suffix:semicolon
id|start_mem
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_while
c_loop
(paren
id|p
OG
id|mem_map
)paren
op_star
op_decrement
id|p
op_assign
id|MAP_PAGE_RESERVED
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_MEM_LISTS
suffix:semicolon
id|i
op_increment
comma
id|mask
op_lshift_assign
l_int|1
)paren
(brace
r_int
r_int
id|bitmap_size
suffix:semicolon
id|free_area_list
(braket
id|i
)braket
dot
id|prev
op_assign
id|free_area_list
(braket
id|i
)braket
dot
id|next
op_assign
op_amp
id|free_area_list
(braket
id|i
)braket
suffix:semicolon
id|end_mem
op_assign
(paren
id|end_mem
op_plus
op_complement
id|mask
)paren
op_amp
id|mask
suffix:semicolon
id|bitmap_size
op_assign
id|end_mem
op_rshift
(paren
id|PAGE_SHIFT
op_plus
id|i
)paren
suffix:semicolon
id|bitmap_size
op_assign
(paren
id|bitmap_size
op_plus
l_int|7
)paren
op_rshift
l_int|3
suffix:semicolon
id|free_area_map
(braket
id|i
)braket
op_assign
(paren
r_int
r_char
op_star
)paren
id|start_mem
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|start_mem
comma
l_int|0
comma
id|bitmap_size
)paren
suffix:semicolon
id|start_mem
op_add_assign
id|bitmap_size
suffix:semicolon
)brace
r_return
id|start_mem
suffix:semicolon
)brace
eof
