multiline_comment|/*&n; *  linux/mm/swap.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; */
multiline_comment|/*&n; * This file contains the default values for the opereation of the&n; * Linux VM subsystem. Fine-tuning documentation can be found in&n; * linux/Documentation/sysctl/vm.txt.&n; * Started 18.12.91&n; * Swap aging added 23.2.95, Stephen Tweedie.&n; * Buffermem limits added 12.3.98, Rik van Riel.&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt; /* for copy_to/from_user */
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/*&n; * We identify three levels of free memory.  We never let free mem&n; * fall below the freepages.min except for atomic allocations.  We&n; * start background swapping if we fall below freepages.high free&n; * pages, and we begin intensive swapping below freepages.low.&n; *&n; * Actual initialization is done in mm/page_alloc.c or &n; * arch/sparc(64)/mm/init.c.&n; */
DECL|variable|freepages
id|freepages_t
id|freepages
op_assign
(brace
l_int|0
comma
multiline_comment|/* freepages.min */
l_int|0
comma
multiline_comment|/* freepages.low */
l_int|0
multiline_comment|/* freepages.high */
)brace
suffix:semicolon
multiline_comment|/* How many pages do we try to swap or page in/out together? */
DECL|variable|page_cluster
r_int
id|page_cluster
suffix:semicolon
multiline_comment|/*&n; * This variable contains the amount of page steals the system&n; * is doing, averaged over a minute. We use this to determine how&n; * many inactive pages we should have.&n; *&n; * In reclaim_page and __alloc_pages: memory_pressure++&n; * In __free_pages_ok: memory_pressure--&n; * In recalculate_vm_stats the value is decayed (once a second)&n; */
DECL|variable|memory_pressure
r_int
id|memory_pressure
suffix:semicolon
multiline_comment|/* We track the number of pages currently being asynchronously swapped&n;   out, so that we don&squot;t try to swap TOO many pages out at once */
DECL|variable|nr_async_pages
id|atomic_t
id|nr_async_pages
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|buffer_mem
id|buffer_mem_t
id|buffer_mem
op_assign
(brace
l_int|2
comma
multiline_comment|/* minimum percent buffer */
l_int|10
comma
multiline_comment|/* borrow percent buffer */
l_int|60
multiline_comment|/* maximum percent buffer */
)brace
suffix:semicolon
DECL|variable|page_cache
id|buffer_mem_t
id|page_cache
op_assign
(brace
l_int|2
comma
multiline_comment|/* minimum percent page cache */
l_int|15
comma
multiline_comment|/* borrow percent page cache */
l_int|75
multiline_comment|/* maximum */
)brace
suffix:semicolon
DECL|variable|pager_daemon
id|pager_daemon_t
id|pager_daemon
op_assign
(brace
l_int|512
comma
multiline_comment|/* base number for calculating the number of tries */
id|SWAP_CLUSTER_MAX
comma
multiline_comment|/* minimum number of tries */
l_int|8
comma
multiline_comment|/* do swap I/O in clusters of this size */
)brace
suffix:semicolon
multiline_comment|/**&n; * age_page_{up,down} -&t;page aging helper functions&n; * @page - the page we want to age&n; * @nolock - are we already holding the pagelist_lru_lock?&n; *&n; * If the page is on one of the lists (active, inactive_dirty or&n; * inactive_clean), we will grab the pagelist_lru_lock as needed.&n; * If you&squot;re already holding the lock, call this function with the&n; * nolock argument non-zero.&n; */
DECL|function|age_page_up_nolock
r_void
id|age_page_up_nolock
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/*&n;&t; * We&squot;re dealing with an inactive page, move the page&n;&t; * to the active list.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;age
)paren
id|activate_page_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The actual page aging bit */
id|page-&gt;age
op_add_assign
id|PAGE_AGE_ADV
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;age
OG
id|PAGE_AGE_MAX
)paren
id|page-&gt;age
op_assign
id|PAGE_AGE_MAX
suffix:semicolon
)brace
multiline_comment|/*&n; * We use this (minimal) function in the case where we&n; * know we can&squot;t deactivate the page (yet).&n; */
DECL|function|age_page_down_ageonly
r_void
id|age_page_down_ageonly
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|page-&gt;age
op_div_assign
l_int|2
suffix:semicolon
)brace
DECL|function|age_page_down_nolock
r_void
id|age_page_down_nolock
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/* The actual page aging bit */
id|page-&gt;age
op_div_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * The page is now an old page. Move to the inactive&n;&t; * list (if possible ... see below).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;age
)paren
id|deactivate_page_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|age_page_up
r_void
id|age_page_up
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/*&n;&t; * We&squot;re dealing with an inactive page, move the page&n;&t; * to the active list.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;age
)paren
id|activate_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The actual page aging bit */
id|page-&gt;age
op_add_assign
id|PAGE_AGE_ADV
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;age
OG
id|PAGE_AGE_MAX
)paren
id|page-&gt;age
op_assign
id|PAGE_AGE_MAX
suffix:semicolon
)brace
DECL|function|age_page_down
r_void
id|age_page_down
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/* The actual page aging bit */
id|page-&gt;age
op_div_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * The page is now an old page. Move to the inactive&n;&t; * list (if possible ... see below).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;age
)paren
id|deactivate_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * (de)activate_page - move pages from/to active and inactive lists&n; * @page: the page we want to move&n; * @nolock - are we already holding the pagemap_lru_lock?&n; *&n; * Deactivate_page will move an active page to the right&n; * inactive list, while activate_page will move a page back&n; * from one of the inactive lists to the active list. If&n; * called on a page which is not on any of the lists, the&n; * page is left alone.&n; */
DECL|function|deactivate_page_nolock
r_void
id|deactivate_page_nolock
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/*&n;&t; * One for the cache, one for the extra reference the&n;&t; * caller has and (maybe) one for the buffers.&n;&t; *&n;&t; * This isn&squot;t perfect, but works for just about everything.&n;&t; * Besides, as long as we don&squot;t move unfreeable pages to the&n;&t; * inactive_clean list it doesn&squot;t need to be perfect...&n;&t; */
r_int
id|maxcount
op_assign
(paren
id|page-&gt;buffers
ques
c_cond
l_int|3
suffix:colon
l_int|2
)paren
suffix:semicolon
id|page-&gt;age
op_assign
l_int|0
suffix:semicolon
id|ClearPageReferenced
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t touch it if it&squot;s not on the active list.&n;&t; * (some pages aren&squot;t on any list at all)&n;&t; */
r_if
c_cond
(paren
id|PageActive
c_func
(paren
id|page
)paren
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
op_le
id|maxcount
op_logical_and
op_logical_neg
id|page_ramdisk
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
DECL|function|deactivate_page
r_void
id|deactivate_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|deactivate_page_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Move an inactive page to the active list.&n; */
DECL|function|activate_page_nolock
r_void
id|activate_page_nolock
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|PageInactiveDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PageInactiveClean
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The page was not on any list, so we take care&n;&t;&t; * not to do anything.&n;&t;&t; */
)brace
multiline_comment|/* Make sure the page gets a fair chance at staying active. */
r_if
c_cond
(paren
id|page-&gt;age
OL
id|PAGE_AGE_START
)paren
id|page-&gt;age
op_assign
id|PAGE_AGE_START
suffix:semicolon
)brace
DECL|function|activate_page
r_void
id|activate_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|activate_page_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * lru_cache_add: add a page to the page lists&n; * @page: the page to add&n; */
DECL|function|lru_cache_add
r_void
id|lru_cache_add
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|DEBUG_ADD_PAGE
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* This should be relatively rare */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;age
)paren
id|deactivate_page_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * __lru_cache_del: remove a page from the page lists&n; * @page: the page to add&n; *&n; * This function is for when the caller already holds&n; * the pagemap_lru_lock.&n; */
DECL|function|__lru_cache_del
r_void
id|__lru_cache_del
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|PageActive
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PageInactiveDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PageInactiveClean
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;VM: __lru_cache_del, found unknown page ?!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|DEBUG_ADD_PAGE
)brace
multiline_comment|/**&n; * lru_cache_del: remove a page from the page lists&n; * @page: the page to remove&n; */
DECL|function|lru_cache_del
r_void
id|lru_cache_del
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|__lru_cache_del
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * recalculate_vm_stats - recalculate VM statistics&n; *&n; * This function should be called once a second to recalculate&n; * some useful statistics the VM subsystem uses to determine&n; * its behaviour.&n; */
DECL|function|recalculate_vm_stats
r_void
id|recalculate_vm_stats
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Substract one second worth of memory_pressure from&n;&t; * memory_pressure.&n;&t; */
id|memory_pressure
op_sub_assign
(paren
id|memory_pressure
op_rshift
id|INACTIVE_SHIFT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform any setup for the swap system&n; */
DECL|function|swap_setup
r_void
id|__init
id|swap_setup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Use a smaller cluster for memory &lt;16MB or &lt;32MB */
r_if
c_cond
(paren
id|num_physpages
OL
(paren
(paren
l_int|16
op_star
l_int|1024
op_star
l_int|1024
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
id|page_cluster
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|num_physpages
OL
(paren
(paren
l_int|32
op_star
l_int|1024
op_star
l_int|1024
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
id|page_cluster
op_assign
l_int|3
suffix:semicolon
r_else
id|page_cluster
op_assign
l_int|4
suffix:semicolon
)brace
eof
