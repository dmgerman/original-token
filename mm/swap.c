multiline_comment|/*&n; *  linux/mm/swap.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * This file should contain most things doing the swapping from/to disk.&n; * Started 18.12.91&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/head.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;asm/system.h&gt; /* for cli()/sti() */
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|MAX_SWAPFILES
mdefine_line|#define MAX_SWAPFILES 8
DECL|macro|SWP_USED
mdefine_line|#define SWP_USED&t;1
DECL|macro|SWP_WRITEOK
mdefine_line|#define SWP_WRITEOK&t;3
DECL|macro|SWP_TYPE
mdefine_line|#define SWP_TYPE(entry) (((entry) &amp; 0xfe) &gt;&gt; 1)
DECL|macro|SWP_OFFSET
mdefine_line|#define SWP_OFFSET(entry) ((entry) &gt;&gt; PAGE_SHIFT)
DECL|macro|SWP_ENTRY
mdefine_line|#define SWP_ENTRY(type,offset) (((type) &lt;&lt; 1) | ((offset) &lt;&lt; PAGE_SHIFT))
DECL|variable|nr_swapfiles
r_static
r_int
id|nr_swapfiles
op_assign
l_int|0
suffix:semicolon
DECL|variable|lock_queue
r_static
r_struct
id|wait_queue
op_star
id|lock_queue
op_assign
l_int|NULL
suffix:semicolon
DECL|struct|swap_info_struct
r_static
r_struct
id|swap_info_struct
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|swap_file
r_struct
id|inode
op_star
id|swap_file
suffix:semicolon
DECL|member|swap_device
r_int
r_int
id|swap_device
suffix:semicolon
DECL|member|swap_map
r_int
r_char
op_star
id|swap_map
suffix:semicolon
DECL|member|swap_lockmap
r_int
r_char
op_star
id|swap_lockmap
suffix:semicolon
DECL|member|pages
r_int
id|pages
suffix:semicolon
DECL|member|lowest_bit
r_int
id|lowest_bit
suffix:semicolon
DECL|member|highest_bit
r_int
id|highest_bit
suffix:semicolon
DECL|member|max
r_int
r_int
id|max
suffix:semicolon
DECL|variable|swap_info
)brace
id|swap_info
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
r_extern
r_int
r_int
id|free_page_list
suffix:semicolon
r_extern
r_int
id|shm_swap
(paren
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * The following are used to make sure we don&squot;t thrash too much...&n; * NOTE!! NR_LAST_FREE_PAGES must be a power of 2...&n; */
DECL|macro|NR_LAST_FREE_PAGES
mdefine_line|#define NR_LAST_FREE_PAGES 32
DECL|variable|last_free_pages
r_static
r_int
r_int
id|last_free_pages
(braket
id|NR_LAST_FREE_PAGES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|function|rw_swap_page
r_void
id|rw_swap_page
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|entry
comma
r_char
op_star
id|buf
)paren
(brace
r_int
r_int
id|type
comma
id|offset
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Internal error: bad swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to swap to unused swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|set_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|sleep_on
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|kstat.pswpin
op_increment
suffix:semicolon
r_else
id|kstat.pswpout
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
)paren
(brace
id|ll_rw_page
c_func
(paren
id|rw
comma
id|p-&gt;swap_device
comma
id|offset
comma
id|buf
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
r_int
r_int
id|zones
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|block
op_assign
id|offset
op_lshift
(paren
l_int|12
op_minus
id|p-&gt;swap_file-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
id|p-&gt;swap_file-&gt;i_sb-&gt;s_blocksize
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|zones
(braket
id|i
)braket
op_assign
id|bmap
c_func
(paren
id|p-&gt;swap_file
comma
id|block
op_increment
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: bad swap file&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ll_rw_swap_file
c_func
(paren
id|rw
comma
id|p-&gt;swap_file-&gt;i_dev
comma
id|zones
comma
id|i
comma
id|buf
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;re_swap_page: no swap file or device&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_logical_and
op_logical_neg
id|clear_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;rw_swap_page: lock already cleared&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
)brace
DECL|function|get_swap_page
r_int
r_int
id|get_swap_page
c_func
(paren
r_void
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_WRITEOK
)paren
op_ne
id|SWP_WRITEOK
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
id|p-&gt;lowest_bit
suffix:semicolon
id|offset
op_le
id|p-&gt;highest_bit
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_continue
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_assign
l_int|1
suffix:semicolon
id|nr_swap_pages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
id|p-&gt;highest_bit
)paren
id|p-&gt;highest_bit
op_decrement
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
id|offset
suffix:semicolon
r_return
id|SWP_ENTRY
c_func
(paren
id|type
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swap_duplicate
r_int
r_int
id|swap_duplicate
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
l_int|0
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|SHM_SWP_TYPE
)paren
r_return
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to duplicate nonexistent swap-page&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_free: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_duplicate: trying to duplicate unused page&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p-&gt;swap_map
(braket
id|offset
)braket
op_increment
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
DECL|function|swap_free
r_void
id|swap_free
c_func
(paren
r_int
r_int
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|SHM_SWP_TYPE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free nonexistent swap-page&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_free: weirdness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free swap from unused swap-device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|set_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|sleep_on
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|p-&gt;highest_bit
)paren
id|p-&gt;highest_bit
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;swap_free: swap-space map bad (entry %08lx)&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
id|nr_swap_pages
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_bit
c_func
(paren
id|offset
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;swap_free: lock already cleared&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|lock_queue
)paren
suffix:semicolon
)brace
DECL|function|swap_in
r_void
id|swap_in
c_func
(paren
r_int
r_int
op_star
id|table_ptr
)paren
(brace
r_int
r_int
id|entry
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
id|entry
op_assign
op_star
id|table_ptr
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_PRESENT
op_amp
id|entry
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;trying to swap in present page&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No swap page in swap_in&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SWP_TYPE
c_func
(paren
id|entry
)paren
op_eq
id|SHM_SWP_TYPE
)paren
(brace
id|shm_no_page
(paren
(paren
r_int
r_int
op_star
)paren
id|table_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|oom
c_func
(paren
id|current
)paren
suffix:semicolon
id|page
op_assign
id|BAD_PAGE
suffix:semicolon
)brace
r_else
id|read_swap_page
c_func
(paren
id|entry
comma
(paren
r_char
op_star
)paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|table_ptr
op_ne
id|entry
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_star
id|table_ptr
op_assign
id|page
op_or
(paren
id|PAGE_DIRTY
op_or
id|PAGE_PRIVATE
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
DECL|function|try_to_swap_out
r_static
r_inline
r_int
id|try_to_swap_out
c_func
(paren
r_int
r_int
op_star
id|table_ptr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
r_int
id|entry
suffix:semicolon
id|page
op_assign
op_star
id|table_ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PAGE_PRESENT
op_amp
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|page
op_ge
id|high_memory
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_amp
id|MAP_PAGE_RESERVED
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_ACCESSED
op_amp
id|page
)paren
(brace
op_star
id|table_ptr
op_and_assign
op_complement
id|PAGE_ACCESSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LAST_FREE_PAGES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|last_free_pages
(braket
id|i
)braket
op_eq
(paren
id|page
op_amp
id|PAGE_MASK
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_DIRTY
op_amp
id|page
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_ne
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|table_ptr
op_assign
id|entry
suffix:semicolon
id|invalidate
c_func
(paren
)paren
suffix:semicolon
id|write_swap_page
c_func
(paren
id|entry
comma
(paren
r_char
op_star
)paren
id|page
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
op_star
id|table_ptr
op_assign
l_int|0
suffix:semicolon
id|invalidate
c_func
(paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
op_plus
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_idle() does nothing much: it just searches for likely candidates for&n; * swapping out or forgetting about. This speeds up the search when we&n; * actually have to swap.&n; */
DECL|function|sys_idle
id|asmlinkage
r_int
id|sys_idle
c_func
(paren
r_void
)paren
(brace
id|need_resched
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * A new implementation of swap_out().  We do not swap complete processes,&n; * but only a small number of blocks, before we continue with the next&n; * process.  The number of blocks actually swapped is determined on the&n; * number of page faults, that this process actually had in the last time,&n; * so we won&squot;t swap heavily used processes all the time ...&n; *&n; * Note: the priority argument is a hint on much CPU to waste with the&n; *       swap block search, not a hint, of how much blocks to swap with&n; *       each process.&n; *&n; * (C) 1993 Kai Petzke, wpp@marie.physik.tu-berlin.de&n; */
macro_line|#ifdef NEW_SWAP
multiline_comment|/*&n; * These are the miminum and maximum number of pages to swap from one process,&n; * before proceeding to the next:&n; */
DECL|macro|SWAP_MIN
mdefine_line|#define SWAP_MIN&t;4
DECL|macro|SWAP_MAX
mdefine_line|#define SWAP_MAX&t;32
multiline_comment|/*&n; * The actual number of pages to swap is determined as:&n; * SWAP_RATIO / (number of recent major page faults)&n; */
DECL|macro|SWAP_RATIO
mdefine_line|#define SWAP_RATIO&t;128
DECL|function|swap_out
r_static
r_int
id|swap_out
c_func
(paren
r_int
r_int
id|priority
)paren
(brace
r_static
r_int
id|swap_task
suffix:semicolon
r_int
id|table
suffix:semicolon
r_int
id|page
suffix:semicolon
r_int
id|pg_table
suffix:semicolon
r_int
id|loop
suffix:semicolon
r_int
id|counter
op_assign
id|NR_TASKS
op_star
l_int|2
op_rshift
id|priority
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|counter
op_assign
id|NR_TASKS
op_star
l_int|2
op_rshift
id|priority
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|counter
op_ge
l_int|0
suffix:semicolon
id|counter
op_decrement
comma
id|swap_task
op_increment
)paren
(brace
multiline_comment|/*&n;&t; * Check that swap_task is suitable for swapping.  If not, look for&n;&t; * the next suitable process.&n;&t; */
id|loop
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|swap_task
op_ge
id|NR_TASKS
)paren
(brace
id|swap_task
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|loop
)paren
(brace
multiline_comment|/* all processes are unswappable or already swapped out */
r_return
l_int|0
suffix:semicolon
)brace
id|loop
op_assign
l_int|1
suffix:semicolon
)brace
id|p
op_assign
id|task
(braket
id|swap_task
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p
op_logical_and
id|p-&gt;swappable
op_logical_and
id|p-&gt;rss
)paren
(brace
r_break
suffix:semicolon
)brace
id|swap_task
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Determine the number of pages to swap from this process.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|p
op_member_access_from_pointer
id|swap_cnt
)paren
(brace
id|p-&gt;dec_flt
op_assign
(paren
id|p-&gt;dec_flt
op_star
l_int|3
)paren
op_div
l_int|4
op_plus
id|p-&gt;maj_flt
op_minus
id|p-&gt;old_maj_flt
suffix:semicolon
id|p-&gt;old_maj_flt
op_assign
id|p-&gt;maj_flt
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dec_flt
op_ge
id|SWAP_RATIO
op_div
id|SWAP_MIN
)paren
(brace
id|p-&gt;dec_flt
op_assign
id|SWAP_RATIO
op_div
id|SWAP_MIN
suffix:semicolon
id|p-&gt;swap_cnt
op_assign
id|SWAP_MIN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;dec_flt
op_le
id|SWAP_RATIO
op_div
id|SWAP_MAX
)paren
(brace
id|p-&gt;swap_cnt
op_assign
id|SWAP_MAX
suffix:semicolon
)brace
r_else
id|p-&gt;swap_cnt
op_assign
id|SWAP_RATIO
op_div
id|p-&gt;dec_flt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go through process&squot; page directory.&n;&t; */
r_for
c_loop
(paren
id|table
op_assign
id|p-&gt;swap_table
suffix:semicolon
id|table
OL
l_int|1024
suffix:semicolon
id|table
op_increment
)paren
(brace
id|pg_table
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.cr3
)paren
(braket
id|table
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pg_table
op_ge
id|high_memory
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|pg_table
)paren
)braket
op_amp
id|MAP_PAGE_RESERVED
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|PAGE_PRESENT
op_amp
id|pg_table
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swap_out: bad page-table at pg_dir[%d]: %08lx&bslash;n&quot;
comma
id|table
comma
id|pg_table
)paren
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.cr3
)paren
(braket
id|table
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pg_table
op_and_assign
l_int|0xfffff000
suffix:semicolon
multiline_comment|/*&n;&t;     * Go through this page table.&n;&t;     */
r_for
c_loop
(paren
id|page
op_assign
id|p-&gt;swap_page
suffix:semicolon
id|page
OL
l_int|1024
suffix:semicolon
id|page
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|try_to_swap_out
c_func
(paren
id|page
op_plus
(paren
r_int
r_int
op_star
)paren
id|pg_table
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|p-&gt;rss
op_decrement
suffix:semicolon
multiline_comment|/* continue with the following page the next time */
id|p-&gt;swap_table
op_assign
id|table
suffix:semicolon
id|p-&gt;swap_page
op_assign
id|page
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_decrement
id|p-&gt;swap_cnt
)paren
op_eq
l_int|0
)paren
(brace
id|swap_task
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
id|p-&gt;rss
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|p-&gt;swap_page
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finish work with this process, if we reached the end of the page&n;&t; * directory.  Mark restart from the beginning the next time.&n;&t; */
id|p-&gt;swap_table
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else /* old swapping procedure */
multiline_comment|/*&n; * Go through the page tables, searching for a user page that&n; * we can swap out.&n; * &n; * We now check that the process is swappable (normally only &squot;init&squot;&n; * is un-swappable), allowing high-priority processes which cannot be&n; * swapped out (things like user-level device drivers (Not implemented)).&n; */
DECL|function|swap_out
r_static
r_int
id|swap_out
c_func
(paren
r_int
r_int
id|priority
)paren
(brace
r_static
r_int
id|swap_task
op_assign
l_int|1
suffix:semicolon
r_static
r_int
id|swap_table
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|swap_page
op_assign
l_int|0
suffix:semicolon
r_int
id|counter
op_assign
id|NR_TASKS
op_star
l_int|8
suffix:semicolon
r_int
id|pg_table
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|counter
op_rshift_assign
id|priority
suffix:semicolon
id|check_task
suffix:colon
r_if
c_cond
(paren
id|counter
op_decrement
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|swap_task
op_ge
id|NR_TASKS
)paren
(brace
id|swap_task
op_assign
l_int|1
suffix:semicolon
r_goto
id|check_task
suffix:semicolon
)brace
id|p
op_assign
id|task
(braket
id|swap_task
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
op_logical_or
op_logical_neg
id|p-&gt;swappable
)paren
(brace
id|swap_task
op_increment
suffix:semicolon
r_goto
id|check_task
suffix:semicolon
)brace
id|check_dir
suffix:colon
r_if
c_cond
(paren
id|swap_table
op_ge
id|PTRS_PER_PAGE
)paren
(brace
id|swap_table
op_assign
l_int|0
suffix:semicolon
id|swap_task
op_increment
suffix:semicolon
r_goto
id|check_task
suffix:semicolon
)brace
id|pg_table
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.cr3
)paren
(braket
id|swap_table
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pg_table
op_ge
id|high_memory
op_logical_or
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|pg_table
)paren
)braket
op_amp
id|MAP_PAGE_RESERVED
)paren
)paren
(brace
id|swap_table
op_increment
suffix:semicolon
r_goto
id|check_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|PAGE_PRESENT
op_amp
id|pg_table
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad page-table at pg_dir[%d]: %08x&bslash;n&quot;
comma
id|swap_table
comma
id|pg_table
)paren
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.cr3
)paren
(braket
id|swap_table
)braket
op_assign
l_int|0
suffix:semicolon
id|swap_table
op_increment
suffix:semicolon
r_goto
id|check_dir
suffix:semicolon
)brace
id|pg_table
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|check_table
suffix:colon
r_if
c_cond
(paren
id|swap_page
op_ge
id|PTRS_PER_PAGE
)paren
(brace
id|swap_page
op_assign
l_int|0
suffix:semicolon
id|swap_table
op_increment
suffix:semicolon
r_goto
id|check_dir
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|try_to_swap_out
c_func
(paren
id|swap_page
op_plus
(paren
r_int
r_int
op_star
)paren
id|pg_table
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|p-&gt;rss
op_decrement
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
id|p-&gt;rss
op_decrement
suffix:semicolon
)brace
id|swap_page
op_increment
suffix:semicolon
r_goto
id|check_table
suffix:semicolon
)brace
macro_line|#endif
DECL|function|try_to_free_page
r_static
r_int
id|try_to_free_page
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|6
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|shrink_buffers
c_func
(paren
id|i
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|shm_swap
c_func
(paren
id|i
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|swap_out
c_func
(paren
id|i
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that this must be atomic, or bad things will happen when&n; * pages are requested in interrupts (as malloc can do). Thus the&n; * cli/sti&squot;s.&n; */
DECL|function|add_mem_queue
r_static
r_inline
r_void
id|add_mem_queue
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
op_star
id|queue
)paren
(brace
id|addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|addr
op_assign
op_star
id|queue
suffix:semicolon
op_star
id|queue
op_assign
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Free_page() adds the page to the free lists. This is optimized for&n; * fast normal cases (no error jumps taken normally).&n; *&n; * The way to optimize jumps for gcc-2.2.2 is to:&n; *  - select the &quot;normal&quot; case and put it inside the if () { XXX }&n; *  - no else-statements if you can avoid them&n; *&n; * With the above two rules, you get a straight-line execution path&n; * for the normal case, giving better asm-code.&n; */
DECL|function|free_page
r_void
id|free_page
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
id|addr
OL
id|high_memory
)paren
(brace
r_int
r_int
op_star
id|map
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|map
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|map
op_amp
id|MAP_PAGE_RESERVED
)paren
)paren
(brace
r_int
r_int
id|flag
suffix:semicolon
id|save_flags
c_func
(paren
id|flag
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
op_star
id|map
)paren
(brace
r_if
c_cond
(paren
id|nr_secondary_pages
OL
id|MAX_SECONDARY_PAGES
)paren
(brace
id|add_mem_queue
c_func
(paren
id|addr
comma
op_amp
id|secondary_page_list
)paren
suffix:semicolon
id|nr_secondary_pages
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|add_mem_queue
c_func
(paren
id|addr
comma
op_amp
id|free_page_list
)paren
suffix:semicolon
id|nr_free_pages
op_increment
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flag
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Trying to free free memory (%08lx): memory probabably corrupted&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PC = %08lx&bslash;n&quot;
comma
op_star
(paren
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|addr
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is one ugly macro, but it simplifies checking, and makes&n; * this speed-critical place reasonably fast, especially as we have&n; * to do things with the interrupt flag etc.&n; *&n; * Note that this #define is heavily optimized to give fast code&n; * for the normal case - the if-statements are ordered so that gcc-2.2.2&n; * will make *no* jumps for the normal code. Don&squot;t touch unless you&n; * know what you are doing.&n; */
DECL|macro|REMOVE_FROM_MEM_QUEUE
mdefine_line|#define REMOVE_FROM_MEM_QUEUE(queue,nr) &bslash;&n;&t;cli(); &bslash;&n;&t;if ((result = queue) != 0) { &bslash;&n;&t;&t;if (!(result &amp; ~PAGE_MASK) &amp;&amp; result &lt; high_memory) { &bslash;&n;&t;&t;&t;queue = *(unsigned long *) result; &bslash;&n;&t;&t;&t;if (!mem_map[MAP_NR(result)]) { &bslash;&n;&t;&t;&t;&t;mem_map[MAP_NR(result)] = 1; &bslash;&n;&t;&t;&t;&t;nr--; &bslash;&n;last_free_pages[index = (index + 1) &amp; (NR_LAST_FREE_PAGES - 1)] = result; &bslash;&n;&t;&t;&t;&t;restore_flags(flag); &bslash;&n;&t;&t;&t;&t;return result; &bslash;&n;&t;&t;&t;} &bslash;&n;&t;&t;&t;printk(&quot;Free page %08lx has mem_map = %d&bslash;n&quot;, &bslash;&n;&t;&t;&t;&t;result,mem_map[MAP_NR(result)]); &bslash;&n;&t;&t;} else &bslash;&n;&t;&t;&t;printk(&quot;Result = 0x%08lx - memory map destroyed&bslash;n&quot;, result); &bslash;&n;&t;&t;queue = 0; &bslash;&n;&t;&t;nr = 0; &bslash;&n;&t;} else if (nr) { &bslash;&n;&t;&t;printk(#nr &quot; is %d, but &quot; #queue &quot; is empty&bslash;n&quot;,nr); &bslash;&n;&t;&t;nr = 0; &bslash;&n;&t;} &bslash;&n;&t;restore_flags(flag)
multiline_comment|/*&n; * Get physical address of first (actually last :-) free page, and mark it&n; * used. If no free pages left, return 0.&n; *&n; * Note that this is one of the most heavily called functions in the kernel,&n; * so it&squot;s a bit timing-critical (especially as we have to disable interrupts&n; * in it). See the above macro which does most of the work, and which is&n; * optimized for a fast normal path of execution.&n; */
DECL|function|__get_free_page
r_int
r_int
id|__get_free_page
c_func
(paren
r_int
id|priority
)paren
(brace
r_int
r_int
id|result
comma
id|flag
suffix:semicolon
r_static
r_int
r_int
id|index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this routine can be called at interrupt time via&n;&t;   malloc.  We want to make sure that the critical&n;&t;   sections of code have interrupts disabled. -RAB&n;&t;   Is this code reentrant? */
id|save_flags
c_func
(paren
id|flag
)paren
suffix:semicolon
id|repeat
suffix:colon
id|REMOVE_FROM_MEM_QUEUE
c_func
(paren
id|free_page_list
comma
id|nr_free_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priority
op_eq
id|GFP_BUFFER
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|priority
op_ne
id|GFP_ATOMIC
)paren
r_if
c_cond
(paren
id|try_to_free_page
c_func
(paren
)paren
)paren
r_goto
id|repeat
suffix:semicolon
id|REMOVE_FROM_MEM_QUEUE
c_func
(paren
id|secondary_page_list
comma
id|nr_secondary_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Trying to stop swapping from a file is fraught with races, so&n; * we repeat quite a bit here when we have to pause. swapoff()&n; * isn&squot;t exactly timing-critical, so who cares?&n; */
DECL|function|try_to_unuse
r_static
r_int
id|try_to_unuse
c_func
(paren
r_int
r_int
id|type
)paren
(brace
r_int
id|nr
comma
id|pgt
comma
id|pg
suffix:semicolon
r_int
r_int
id|page
comma
op_star
id|ppage
suffix:semicolon
r_int
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|nr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * When we have to sleep, we restart the whole algorithm from the same&n; * task we stopped in. That at least rids us of all races.&n; */
id|repeat
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|nr
OL
id|NR_TASKS
suffix:semicolon
id|nr
op_increment
)paren
(brace
id|p
op_assign
id|task
(braket
id|nr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|pgt
op_assign
l_int|0
suffix:semicolon
id|pgt
OL
id|PTRS_PER_PAGE
suffix:semicolon
id|pgt
op_increment
)paren
(brace
id|ppage
op_assign
id|pgt
op_plus
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.cr3
)paren
suffix:semicolon
id|page
op_assign
op_star
id|ppage
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_amp
id|PAGE_PRESENT
)paren
op_logical_or
(paren
id|page
op_ge
id|high_memory
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_amp
id|MAP_PAGE_RESERVED
)paren
r_continue
suffix:semicolon
id|ppage
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|page
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pg
op_assign
l_int|0
suffix:semicolon
id|pg
OL
id|PTRS_PER_PAGE
suffix:semicolon
id|pg
op_increment
comma
id|ppage
op_increment
)paren
(brace
id|page
op_assign
op_star
id|ppage
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|page
op_amp
id|PAGE_PRESENT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|SWP_TYPE
c_func
(paren
id|page
)paren
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|read_swap_page
c_func
(paren
id|page
comma
(paren
r_char
op_star
)paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppage
op_eq
id|page
)paren
(brace
op_star
id|ppage
op_assign
id|tmp
op_or
(paren
id|PAGE_DIRTY
op_or
id|PAGE_PRIVATE
)paren
suffix:semicolon
op_increment
id|p-&gt;rss
suffix:semicolon
id|swap_free
c_func
(paren
id|page
)paren
suffix:semicolon
id|tmp
op_assign
l_int|0
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
)brace
)brace
id|free_page
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_swapoff
id|asmlinkage
r_int
id|sys_swapoff
c_func
(paren
r_const
r_char
op_star
id|specialfile
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|namei
c_func
(paren
id|specialfile
comma
op_amp
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_WRITEOK
)paren
op_ne
id|SWP_WRITEOK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_file
op_eq
id|inode
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
op_eq
id|inode-&gt;i_rdev
)paren
r_break
suffix:semicolon
)brace
)brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|i
op_assign
id|try_to_unuse
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|p-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|nr_swap_pages
op_sub_assign
id|p-&gt;pages
suffix:semicolon
id|iput
c_func
(paren
id|p-&gt;swap_file
)paren
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|vfree
c_func
(paren
id|p-&gt;swap_map
)paren
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
)paren
id|p-&gt;swap_lockmap
)paren
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Written 01/25/92 by Simmule Turner, heavily changed by Linus.&n; *&n; * The swapon system call&n; */
DECL|function|sys_swapon
id|asmlinkage
r_int
id|sys_swapon
c_func
(paren
r_const
r_char
op_star
id|specialfile
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_struct
id|inode
op_star
id|swap_inode
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|MAX_SWAPFILES
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
id|nr_swapfiles
op_assign
id|type
op_plus
l_int|1
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;max
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|namei
c_func
(paren
id|specialfile
comma
op_amp
id|swap_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bad_swap
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|swap_inode-&gt;i_count
op_ne
l_int|1
)paren
r_goto
id|bad_swap
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|swap_inode-&gt;i_mode
)paren
)paren
(brace
id|p-&gt;swap_device
op_assign
id|swap_inode-&gt;i_rdev
suffix:semicolon
id|iput
c_func
(paren
id|swap_inode
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_device
)paren
r_goto
id|bad_swap
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_device
op_eq
id|swap_info
(braket
id|i
)braket
dot
id|swap_device
)paren
r_goto
id|bad_swap
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|swap_inode-&gt;i_mode
)paren
)paren
id|p-&gt;swap_file
op_assign
id|swap_inode
suffix:semicolon
r_else
r_goto
id|bad_swap
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_lockmap
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to start swapping: out of memory :-)&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|read_swap_page
c_func
(paren
id|SWP_ENTRY
c_func
(paren
id|type
comma
l_int|0
)paren
comma
(paren
r_char
op_star
)paren
id|p-&gt;swap_lockmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|p-&gt;swap_lockmap
op_plus
l_int|4086
comma
l_int|10
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to find swap-space signature&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|memset
c_func
(paren
id|p-&gt;swap_lockmap
op_plus
id|PAGE_SIZE
op_minus
l_int|10
comma
l_int|0
comma
l_int|10
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
op_star
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
id|p-&gt;swap_lockmap
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|i
suffix:semicolon
id|p-&gt;highest_bit
op_assign
id|i
suffix:semicolon
id|p-&gt;max
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|j
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Empty swap-file&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|p-&gt;swap_map
op_assign
(paren
r_int
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|p-&gt;max
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|p-&gt;max
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
id|p-&gt;swap_lockmap
)paren
)paren
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
l_int|0x80
suffix:semicolon
)brace
id|p-&gt;swap_map
(braket
l_int|0
)braket
op_assign
l_int|0x80
suffix:semicolon
id|memset
c_func
(paren
id|p-&gt;swap_lockmap
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
id|p-&gt;pages
op_assign
id|j
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Adding Swap: %dk swap-space&bslash;n&quot;
comma
id|j
op_lshift
l_int|2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad_swap
suffix:colon
id|free_page
c_func
(paren
(paren
r_int
)paren
id|p-&gt;swap_lockmap
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|p-&gt;swap_map
)paren
suffix:semicolon
id|iput
c_func
(paren
id|p-&gt;swap_file
)paren
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_lockmap
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|si_swapinfo
r_void
id|si_swapinfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
id|val-&gt;freeswap
op_assign
id|val-&gt;totalswap
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_amp
id|SWP_USED
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|swap_info
(braket
id|i
)braket
dot
id|max
suffix:semicolon
op_increment
id|j
)paren
r_switch
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|swap_map
(braket
id|j
)braket
)paren
(brace
r_case
l_int|128
suffix:colon
r_continue
suffix:semicolon
r_case
l_int|0
suffix:colon
op_increment
id|val-&gt;freeswap
suffix:semicolon
r_default
suffix:colon
op_increment
id|val-&gt;totalswap
suffix:semicolon
)brace
)brace
id|val-&gt;freeswap
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|val-&gt;totalswap
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
