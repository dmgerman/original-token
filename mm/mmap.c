multiline_comment|/*&n; *&t;linux/mm/mmap.c&n; *&n; * Written by obz.&n; */
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/*&n; * Map memory not associated with any file into a process&n; * address space.  Adjacent memory is merged.&n; */
DECL|function|anon_map
r_static
r_inline
r_int
id|anon_map
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_if
c_cond
(paren
id|zeromap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * description of effects of mapping type and prot in current implementation.&n; * this is due to the limited x86 page protection hardware.  The expected&n; * behavior is in parens:&n; *&n; * map_type&t;prot&n; *&t;&t;PROT_NONE&t;PROT_READ&t;PROT_WRITE&t;PROT_EXEC&n; * MAP_SHARED&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (yes) yes&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&t;&t;&n; * MAP_PRIVATE&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (copy) copy&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&n; */
DECL|variable|protection_map
id|pgprot_t
id|protection_map
(braket
l_int|16
)braket
op_assign
(brace
id|__P000
comma
id|__P001
comma
id|__P010
comma
id|__P011
comma
id|__P100
comma
id|__P101
comma
id|__P110
comma
id|__P111
comma
id|__S000
comma
id|__S001
comma
id|__S010
comma
id|__S011
comma
id|__S100
comma
id|__S101
comma
id|__S110
comma
id|__S111
)brace
suffix:semicolon
DECL|function|do_mmap
r_int
r_int
id|do_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|off
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_logical_or
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* offset overflow? */
r_if
c_cond
(paren
id|off
op_plus
id|len
OL
id|off
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* mlock MCL_FUTURE? */
r_if
c_cond
(paren
id|current-&gt;mm-&gt;def_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
op_assign
id|current-&gt;mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * do simple checking here so the lower-level routines won&squot;t have&n;&t; * to. we assume access permissions have been handled by the open&n;&t; * of the memory object, so we don&squot;t do any here.&n;&t; */
r_if
c_cond
(paren
id|file
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_case
id|MAP_SHARED
suffix:colon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MAP_PRIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|1
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_DENYWRITE
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_inode-&gt;i_writecount
OG
l_int|0
)paren
r_return
op_minus
id|ETXTBSY
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
op_ne
id|MAP_PRIVATE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * obtain the address to map to. we verify (or select) it and ensure&n;&t; * that it represents a valid section of the address space.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_FIXED
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
op_logical_or
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
id|get_unmapped_area
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * determine the object being mapped and call the appropriate&n;&t; * specific mapper. the address has already been validated, but&n;&t; * not unmapped, but the maps are removed from the list.&n;&t; */
r_if
c_cond
(paren
id|file
op_logical_and
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|vma
op_assign
(paren
r_struct
id|vm_area_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vm_area_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vma-&gt;vm_mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|prot
op_amp
(paren
id|VM_READ
op_or
id|VM_WRITE
op_or
id|VM_EXEC
)paren
suffix:semicolon
id|vma-&gt;vm_flags
op_or_assign
id|flags
op_amp
(paren
id|VM_GROWSDOWN
op_or
id|VM_DENYWRITE
op_or
id|VM_EXECUTABLE
)paren
suffix:semicolon
id|vma-&gt;vm_flags
op_or_assign
id|current-&gt;mm-&gt;def_flags
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
l_int|1
)paren
id|vma-&gt;vm_flags
op_or_assign
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
(brace
id|vma-&gt;vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This looks strange, but when we don&squot;t have the file open&n;&t;&t;&t; * for writing, we can demote the shared mapping to a simpler&n;&t;&t;&t; * private mapping. That also takes care of a security hole&n;&t;&t;&t; * with ptrace() writing to a shared mapping without write&n;&t;&t;&t; * permissions.&n;&t;&t;&t; *&n;&t;&t;&t; * We leave the VM_MAYSHARE bit on, just to get correct output&n;&t;&t;&t; * from /proc/xxx/maps..&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
)paren
id|vma-&gt;vm_flags
op_and_assign
op_complement
(paren
id|VM_MAYWRITE
op_or
id|VM_SHARED
)paren
suffix:semicolon
)brace
)brace
r_else
id|vma-&gt;vm_flags
op_or_assign
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|vma-&gt;vm_flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_offset
op_assign
id|off
suffix:semicolon
id|vma-&gt;vm_inode
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pte
op_assign
l_int|0
suffix:semicolon
id|do_munmap
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Clear old maps */
r_if
c_cond
(paren
id|file
)paren
id|error
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file-&gt;f_inode
comma
id|file
comma
id|vma
)paren
suffix:semicolon
r_else
id|error
op_assign
id|anon_map
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kfree
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|flags
op_assign
id|vma-&gt;vm_flags
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|current
comma
id|vma
)paren
suffix:semicolon
id|merge_segments
c_func
(paren
id|current
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
multiline_comment|/* merge_segments might have merged our vma, so we can&squot;t use it any more */
id|current-&gt;mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|start
op_assign
id|addr
suffix:semicolon
id|current-&gt;mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_do
(brace
r_char
id|c
op_assign
id|get_user
c_func
(paren
(paren
r_char
op_star
)paren
id|start
)paren
suffix:semicolon
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|c
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Get an address range which is currently unmapped.&n; * For mmap() without MAP_FIXED and shmat() with addr=0.&n; * Return value 0 means ENOMEM.&n; */
DECL|function|get_unmapped_area
r_int
r_int
id|get_unmapped_area
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vmm
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
id|TASK_SIZE
op_div
l_int|3
suffix:semicolon
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vmm
op_assign
id|current-&gt;mm-&gt;mmap
suffix:semicolon
suffix:semicolon
id|vmm
op_assign
id|vmm-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
OL
id|addr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vmm
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
id|vmm-&gt;vm_end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_plus
id|len
OG
id|vmm-&gt;vm_start
)paren
(brace
id|addr
op_assign
id|vmm-&gt;vm_end
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Searching a VMA in the linear list task-&gt;mm-&gt;mmap is horribly slow.&n; * Use an AVL (Adelson-Velskii and Landis) tree to speed up this search&n; * from O(n) to O(log n), where n is the number of VMAs of the task&n; * (typically around 6, but may reach 3000 in some cases).&n; * Written by Bruno Haible &lt;haible@ma2s2.mathematik.uni-karlsruhe.de&gt;.&n; */
multiline_comment|/* We keep the list and tree sorted by address. */
DECL|macro|vm_avl_key
mdefine_line|#define vm_avl_key&t;vm_end
DECL|macro|vm_avl_key_t
mdefine_line|#define vm_avl_key_t&t;unsigned long&t;/* typeof(vma-&gt;avl_key) */
multiline_comment|/*&n; * task-&gt;mm-&gt;mmap_avl is the AVL tree corresponding to task-&gt;mm-&gt;mmap&n; * or, more exactly, its root.&n; * A vm_area_struct has the following fields:&n; *   vm_avl_left     left son of a tree node&n; *   vm_avl_right    right son of a tree node&n; *   vm_avl_height   1+max(heightof(left),heightof(right))&n; * The empty tree is represented as NULL.&n; */
multiline_comment|/* Since the trees are balanced, their height will never be large. */
DECL|macro|avl_maxheight
mdefine_line|#define avl_maxheight&t;41&t;/* why this? a small exercise */
DECL|macro|heightof
mdefine_line|#define heightof(tree)&t;((tree) == avl_empty ? 0 : (tree)-&gt;vm_avl_height)
multiline_comment|/*&n; * Consistency and balancing rules:&n; * 1. tree-&gt;vm_avl_height == 1+max(heightof(tree-&gt;vm_avl_left),heightof(tree-&gt;vm_avl_right))&n; * 2. abs( heightof(tree-&gt;vm_avl_left) - heightof(tree-&gt;vm_avl_right) ) &lt;= 1&n; * 3. foreach node in tree-&gt;vm_avl_left: node-&gt;vm_avl_key &lt;= tree-&gt;vm_avl_key,&n; *    foreach node in tree-&gt;vm_avl_right: node-&gt;vm_avl_key &gt;= tree-&gt;vm_avl_key.&n; */
multiline_comment|/* Look up the nodes at the left and at the right of a given node. */
DECL|function|avl_neighbours
r_static
r_inline
r_void
id|avl_neighbours
(paren
r_struct
id|vm_area_struct
op_star
id|node
comma
r_struct
id|vm_area_struct
op_star
id|tree
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_left
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_right
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|node-&gt;vm_avl_key
suffix:semicolon
op_star
id|to_the_left
op_assign
op_star
id|to_the_right
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;avl_neighbours: node not found in the tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|key
op_eq
id|tree-&gt;vm_avl_key
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|tree-&gt;vm_avl_key
)paren
(brace
op_star
id|to_the_right
op_assign
id|tree
suffix:semicolon
id|tree
op_assign
id|tree-&gt;vm_avl_left
suffix:semicolon
)brace
r_else
(brace
op_star
id|to_the_left
op_assign
id|tree
suffix:semicolon
id|tree
op_assign
id|tree-&gt;vm_avl_right
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tree
op_ne
id|node
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;avl_neighbours: node not exactly found in the tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree-&gt;vm_avl_left
op_ne
id|avl_empty
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|tree-&gt;vm_avl_left
suffix:semicolon
id|node-&gt;vm_avl_right
op_ne
id|avl_empty
suffix:semicolon
id|node
op_assign
id|node-&gt;vm_avl_right
)paren
r_continue
suffix:semicolon
op_star
id|to_the_left
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tree-&gt;vm_avl_right
op_ne
id|avl_empty
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
id|tree-&gt;vm_avl_right
suffix:semicolon
id|node-&gt;vm_avl_left
op_ne
id|avl_empty
suffix:semicolon
id|node
op_assign
id|node-&gt;vm_avl_left
)paren
r_continue
suffix:semicolon
op_star
id|to_the_right
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|to_the_left
op_logical_and
(paren
(paren
op_star
id|to_the_left
)paren
op_member_access_from_pointer
id|vm_next
op_ne
id|node
)paren
)paren
op_logical_or
(paren
id|node-&gt;vm_next
op_ne
op_star
id|to_the_right
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;avl_neighbours: tree inconsistent with list&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Rebalance a tree.&n; * After inserting or deleting a node of a tree we have a sequence of subtrees&n; * nodes[0]..nodes[k-1] such that&n; * nodes[0] is the root and nodes[i+1] = nodes[i]-&gt;{vm_avl_left|vm_avl_right}.&n; */
DECL|function|avl_rebalance
r_static
r_inline
r_void
id|avl_rebalance
(paren
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|nodeplaces_ptr
comma
r_int
id|count
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|count
op_decrement
)paren
(brace
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
op_star
op_decrement
id|nodeplaces_ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|nodeleft
op_assign
id|node-&gt;vm_avl_left
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|noderight
op_assign
id|node-&gt;vm_avl_right
suffix:semicolon
r_int
id|heightleft
op_assign
id|heightof
c_func
(paren
id|nodeleft
)paren
suffix:semicolon
r_int
id|heightright
op_assign
id|heightof
c_func
(paren
id|noderight
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightright
op_plus
l_int|1
OL
id|heightleft
)paren
(brace
multiline_comment|/*                                                      */
multiline_comment|/*                            *                         */
multiline_comment|/*                          /   &bslash;                       */
multiline_comment|/*                       n+2      n                     */
multiline_comment|/*                                                      */
r_struct
id|vm_area_struct
op_star
id|nodeleftleft
op_assign
id|nodeleft-&gt;vm_avl_left
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|nodeleftright
op_assign
id|nodeleft-&gt;vm_avl_right
suffix:semicolon
r_int
id|heightleftright
op_assign
id|heightof
c_func
(paren
id|nodeleftright
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightof
c_func
(paren
id|nodeleftleft
)paren
op_ge
id|heightleftright
)paren
(brace
multiline_comment|/*                                                        */
multiline_comment|/*                *                    n+2|n+3            */
multiline_comment|/*              /   &bslash;                  /    &bslash;             */
multiline_comment|/*           n+2      n      --&gt;      /   n+1|n+2         */
multiline_comment|/*           / &bslash;                      |    /    &bslash;         */
multiline_comment|/*         n+1 n|n+1                 n+1  n|n+1  n        */
multiline_comment|/*                                                        */
id|node-&gt;vm_avl_left
op_assign
id|nodeleftright
suffix:semicolon
id|nodeleft-&gt;vm_avl_right
op_assign
id|node
suffix:semicolon
id|nodeleft-&gt;vm_avl_height
op_assign
l_int|1
op_plus
(paren
id|node-&gt;vm_avl_height
op_assign
l_int|1
op_plus
id|heightleftright
)paren
suffix:semicolon
op_star
id|nodeplace
op_assign
id|nodeleft
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*                                                        */
multiline_comment|/*                *                     n+2               */
multiline_comment|/*              /   &bslash;                 /     &bslash;             */
multiline_comment|/*           n+2      n      --&gt;    n+1     n+1           */
multiline_comment|/*           / &bslash;                    / &bslash;     / &bslash;           */
multiline_comment|/*          n  n+1                 n   L   R   n          */
multiline_comment|/*             / &bslash;                                        */
multiline_comment|/*            L   R                                       */
multiline_comment|/*                                                        */
id|nodeleft-&gt;vm_avl_right
op_assign
id|nodeleftright-&gt;vm_avl_left
suffix:semicolon
id|node-&gt;vm_avl_left
op_assign
id|nodeleftright-&gt;vm_avl_right
suffix:semicolon
id|nodeleftright-&gt;vm_avl_left
op_assign
id|nodeleft
suffix:semicolon
id|nodeleftright-&gt;vm_avl_right
op_assign
id|node
suffix:semicolon
id|nodeleft-&gt;vm_avl_height
op_assign
id|node-&gt;vm_avl_height
op_assign
id|heightleftright
suffix:semicolon
id|nodeleftright-&gt;vm_avl_height
op_assign
id|heightleft
suffix:semicolon
op_star
id|nodeplace
op_assign
id|nodeleftright
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|heightleft
op_plus
l_int|1
OL
id|heightright
)paren
(brace
multiline_comment|/* similar to the above, just interchange &squot;left&squot; &lt;--&gt; &squot;right&squot; */
r_struct
id|vm_area_struct
op_star
id|noderightright
op_assign
id|noderight-&gt;vm_avl_right
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|noderightleft
op_assign
id|noderight-&gt;vm_avl_left
suffix:semicolon
r_int
id|heightrightleft
op_assign
id|heightof
c_func
(paren
id|noderightleft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|heightof
c_func
(paren
id|noderightright
)paren
op_ge
id|heightrightleft
)paren
(brace
id|node-&gt;vm_avl_right
op_assign
id|noderightleft
suffix:semicolon
id|noderight-&gt;vm_avl_left
op_assign
id|node
suffix:semicolon
id|noderight-&gt;vm_avl_height
op_assign
l_int|1
op_plus
(paren
id|node-&gt;vm_avl_height
op_assign
l_int|1
op_plus
id|heightrightleft
)paren
suffix:semicolon
op_star
id|nodeplace
op_assign
id|noderight
suffix:semicolon
)brace
r_else
(brace
id|noderight-&gt;vm_avl_left
op_assign
id|noderightleft-&gt;vm_avl_right
suffix:semicolon
id|node-&gt;vm_avl_right
op_assign
id|noderightleft-&gt;vm_avl_left
suffix:semicolon
id|noderightleft-&gt;vm_avl_right
op_assign
id|noderight
suffix:semicolon
id|noderightleft-&gt;vm_avl_left
op_assign
id|node
suffix:semicolon
id|noderight-&gt;vm_avl_height
op_assign
id|node-&gt;vm_avl_height
op_assign
id|heightrightleft
suffix:semicolon
id|noderightleft-&gt;vm_avl_height
op_assign
id|heightright
suffix:semicolon
op_star
id|nodeplace
op_assign
id|noderightleft
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|height
op_assign
(paren
id|heightleft
OL
id|heightright
ques
c_cond
id|heightright
suffix:colon
id|heightleft
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|height
op_eq
id|node-&gt;vm_avl_height
)paren
r_break
suffix:semicolon
id|node-&gt;vm_avl_height
op_assign
id|height
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Insert a node into a tree. */
DECL|function|avl_insert
r_static
r_inline
r_void
id|avl_insert
(paren
r_struct
id|vm_area_struct
op_star
id|new_node
comma
r_struct
id|vm_area_struct
op_star
op_star
id|ptree
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|new_node-&gt;vm_avl_key
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
id|ptree
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|avl_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|node-&gt;vm_avl_key
)paren
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
r_else
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
id|new_node-&gt;vm_avl_left
op_assign
id|avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_right
op_assign
id|avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_height
op_assign
l_int|1
suffix:semicolon
op_star
id|nodeplace
op_assign
id|new_node
suffix:semicolon
id|avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert a node into a tree, and&n; * return the node to the left of it and the node to the right of it.&n; */
DECL|function|avl_insert_neighbours
r_static
r_inline
r_void
id|avl_insert_neighbours
(paren
r_struct
id|vm_area_struct
op_star
id|new_node
comma
r_struct
id|vm_area_struct
op_star
op_star
id|ptree
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_left
comma
r_struct
id|vm_area_struct
op_star
op_star
id|to_the_right
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|new_node-&gt;vm_avl_key
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
id|ptree
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
op_star
id|to_the_left
op_assign
op_star
id|to_the_right
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|avl_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|node-&gt;vm_avl_key
)paren
(brace
op_star
id|to_the_right
op_assign
id|node
suffix:semicolon
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
)brace
r_else
(brace
op_star
id|to_the_left
op_assign
id|node
suffix:semicolon
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
)brace
id|new_node-&gt;vm_avl_left
op_assign
id|avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_right
op_assign
id|avl_empty
suffix:semicolon
id|new_node-&gt;vm_avl_height
op_assign
l_int|1
suffix:semicolon
op_star
id|nodeplace
op_assign
id|new_node
suffix:semicolon
id|avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Removes a node out of a tree. */
DECL|function|avl_remove
r_static
r_inline
r_void
id|avl_remove
(paren
r_struct
id|vm_area_struct
op_star
id|node_to_delete
comma
r_struct
id|vm_area_struct
op_star
op_star
id|ptree
)paren
(brace
id|vm_avl_key_t
id|key
op_assign
id|node_to_delete-&gt;vm_avl_key
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
id|ptree
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|stack
(braket
id|avl_maxheight
)braket
suffix:semicolon
r_int
id|stack_count
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr
op_assign
op_amp
id|stack
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* = &amp;stack[stackcount] */
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace_to_delete
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node
op_eq
id|avl_empty
)paren
(brace
multiline_comment|/* what? node_to_delete not found in tree? */
id|printk
c_func
(paren
l_string|&quot;avl_remove: node to delete not found in tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|node-&gt;vm_avl_key
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|node-&gt;vm_avl_key
)paren
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
r_else
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
id|nodeplace_to_delete
op_assign
id|nodeplace
suffix:semicolon
multiline_comment|/* Have to remove node_to_delete = *nodeplace_to_delete. */
r_if
c_cond
(paren
id|node_to_delete-&gt;vm_avl_left
op_eq
id|avl_empty
)paren
(brace
op_star
id|nodeplace_to_delete
op_assign
id|node_to_delete-&gt;vm_avl_right
suffix:semicolon
id|stack_ptr
op_decrement
suffix:semicolon
id|stack_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_struct
id|vm_area_struct
op_star
op_star
op_star
id|stack_ptr_to_delete
op_assign
id|stack_ptr
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|nodeplace
op_assign
op_amp
id|node_to_delete-&gt;vm_avl_left
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|node
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|node
op_assign
op_star
id|nodeplace
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;vm_avl_right
op_eq
id|avl_empty
)paren
r_break
suffix:semicolon
op_star
id|stack_ptr
op_increment
op_assign
id|nodeplace
suffix:semicolon
id|stack_count
op_increment
suffix:semicolon
id|nodeplace
op_assign
op_amp
id|node-&gt;vm_avl_right
suffix:semicolon
)brace
op_star
id|nodeplace
op_assign
id|node-&gt;vm_avl_left
suffix:semicolon
multiline_comment|/* node replaces node_to_delete */
id|node-&gt;vm_avl_left
op_assign
id|node_to_delete-&gt;vm_avl_left
suffix:semicolon
id|node-&gt;vm_avl_right
op_assign
id|node_to_delete-&gt;vm_avl_right
suffix:semicolon
id|node-&gt;vm_avl_height
op_assign
id|node_to_delete-&gt;vm_avl_height
suffix:semicolon
op_star
id|nodeplace_to_delete
op_assign
id|node
suffix:semicolon
multiline_comment|/* replace node_to_delete */
op_star
id|stack_ptr_to_delete
op_assign
op_amp
id|node-&gt;vm_avl_left
suffix:semicolon
multiline_comment|/* replace &amp;node_to_delete-&gt;vm_avl_left */
)brace
id|avl_rebalance
c_func
(paren
id|stack_ptr
comma
id|stack_count
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_AVL
multiline_comment|/* print a list */
DECL|function|printk_list
r_static
r_void
id|printk_list
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|vma
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08lX-%08lX&quot;
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;]&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* print a tree */
DECL|function|printk_avl
r_static
r_void
id|printk_avl
(paren
r_struct
id|vm_area_struct
op_star
id|tree
)paren
(brace
r_if
c_cond
(paren
id|tree
op_ne
id|avl_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_left
op_ne
id|avl_empty
)paren
(brace
id|printk_avl
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%08lX-%08lX&quot;
comma
id|tree-&gt;vm_start
comma
id|tree-&gt;vm_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_right
op_ne
id|avl_empty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&gt;&quot;
)paren
suffix:semicolon
id|printk_avl
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|variable|avl_check_point
r_static
r_char
op_star
id|avl_check_point
op_assign
l_string|&quot;somewhere&quot;
suffix:semicolon
multiline_comment|/* check a tree&squot;s consistency and balancing */
DECL|function|avl_checkheights
r_static
r_void
id|avl_checkheights
(paren
r_struct
id|vm_area_struct
op_star
id|tree
)paren
(brace
r_int
id|h
comma
id|hl
comma
id|hr
suffix:semicolon
r_if
c_cond
(paren
id|tree
op_eq
id|avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkheights
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|avl_checkheights
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
id|h
op_assign
id|tree-&gt;vm_avl_height
suffix:semicolon
id|hl
op_assign
id|heightof
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|hr
op_assign
id|heightof
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h
op_eq
id|hl
op_plus
l_int|1
)paren
op_logical_and
(paren
id|hr
op_le
id|hl
)paren
op_logical_and
(paren
id|hl
op_le
id|hr
op_plus
l_int|1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h
op_eq
id|hr
op_plus
l_int|1
)paren
op_logical_and
(paren
id|hl
op_le
id|hr
)paren
op_logical_and
(paren
id|hr
op_le
id|hl
op_plus
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkheights: heights inconsistent&bslash;n&quot;
comma
id|avl_check_point
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values stored in a tree are &lt; key */
DECL|function|avl_checkleft
r_static
r_void
id|avl_checkleft
(paren
r_struct
id|vm_area_struct
op_star
id|tree
comma
id|vm_avl_key_t
id|key
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;vm_avl_left
comma
id|key
)paren
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;vm_avl_right
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_key
OL
id|key
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkleft: left key %lu &gt;= top key %lu&bslash;n&quot;
comma
id|avl_check_point
comma
id|tree-&gt;vm_avl_key
comma
id|key
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values stored in a tree are &gt; key */
DECL|function|avl_checkright
r_static
r_void
id|avl_checkright
(paren
r_struct
id|vm_area_struct
op_star
id|tree
comma
id|vm_avl_key_t
id|key
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;vm_avl_left
comma
id|key
)paren
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;vm_avl_right
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_avl_key
OG
id|key
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: avl_checkright: right key %lu &lt;= top key %lu&bslash;n&quot;
comma
id|avl_check_point
comma
id|tree-&gt;vm_avl_key
comma
id|key
)paren
suffix:semicolon
)brace
multiline_comment|/* check that all values are properly increasing */
DECL|function|avl_checkorder
r_static
r_void
id|avl_checkorder
(paren
r_struct
id|vm_area_struct
op_star
id|tree
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|avl_empty
)paren
r_return
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|tree-&gt;vm_avl_left
)paren
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|tree-&gt;vm_avl_right
)paren
suffix:semicolon
id|avl_checkleft
c_func
(paren
id|tree-&gt;vm_avl_left
comma
id|tree-&gt;vm_avl_key
)paren
suffix:semicolon
id|avl_checkright
c_func
(paren
id|tree-&gt;vm_avl_right
comma
id|tree-&gt;vm_avl_key
)paren
suffix:semicolon
)brace
multiline_comment|/* all checks */
DECL|function|avl_check
r_static
r_void
id|avl_check
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_char
op_star
id|caller
)paren
(brace
id|avl_check_point
op_assign
id|caller
suffix:semicolon
multiline_comment|/*&t;printk(&quot;task &bslash;&quot;%s&bslash;&quot;, %s&bslash;n&quot;,task-&gt;comm,caller); */
multiline_comment|/*&t;printk(&quot;task &bslash;&quot;%s&bslash;&quot; list: &quot;,task-&gt;comm); printk_list(task-&gt;mm-&gt;mmap); printk(&quot;&bslash;n&quot;); */
multiline_comment|/*&t;printk(&quot;task &bslash;&quot;%s&bslash;&quot; tree: &quot;,task-&gt;comm); printk_avl(task-&gt;mm-&gt;mmap_avl); printk(&quot;&bslash;n&quot;); */
id|avl_checkheights
c_func
(paren
id|task-&gt;mm-&gt;mmap_avl
)paren
suffix:semicolon
id|avl_checkorder
c_func
(paren
id|task-&gt;mm-&gt;mmap_avl
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Normal function to fix up a mapping&n; * This function is the default for when an area has no specific&n; * function.  This may be used as part of a more specific routine.&n; * This function works out what part of an area is affected and&n; * adjusts the mapping information.  Since the actual page&n; * manipulation is done in do_mmap(), none need be done here,&n; * though it would probably be more appropriate.&n; *&n; * By the time this function is called, the area struct has been&n; * removed from the process mapping list, so it needs to be&n; * reinserted if necessary.&n; *&n; * The 4 main cases are:&n; *    Unmapping the whole area&n; *    Unmapping from the start of the segment to a point in it&n; *    Unmapping from an intermediate point to the end&n; *    Unmapping between to intermediate points, making a hole.&n; *&n; * Case 4 involves the creation of 2 new areas, for each side of&n; * the hole.&n; */
DECL|function|unmap_fixup
r_static
r_void
id|unmap_fixup
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|addr
template_param
id|area-&gt;vm_end
op_logical_or
id|end
OL
id|addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unmap_fixup: area=%lx-%lx, unmap %lx-%lx!!&bslash;n&quot;
comma
id|area-&gt;vm_start
comma
id|area-&gt;vm_end
comma
id|addr
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|area-&gt;vm_mm-&gt;total_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|area-&gt;vm_mm-&gt;locked_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Unmapping the whole area */
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
op_logical_and
id|end
op_eq
id|area-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;close
)paren
id|area-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|area
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_inode
)paren
id|iput
c_func
(paren
id|area-&gt;vm_inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Work out to one of the ends */
r_if
c_cond
(paren
id|end
op_eq
id|area-&gt;vm_end
)paren
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
)paren
(brace
id|area-&gt;vm_offset
op_add_assign
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
suffix:semicolon
id|area-&gt;vm_start
op_assign
id|end
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unmapping a hole: area-&gt;vm_start &lt; addr &lt;= end &lt; area-&gt;vm_end */
multiline_comment|/* Add end mapping -- leave beginning for below */
id|mpnt
op_assign
(paren
r_struct
id|vm_area_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mpnt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
suffix:semicolon
op_star
id|mpnt
op_assign
op_star
id|area
suffix:semicolon
id|mpnt-&gt;vm_offset
op_add_assign
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_inode
)paren
id|mpnt-&gt;vm_inode-&gt;i_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;open
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Truncate area */
id|insert_vm_struct
c_func
(paren
id|current
comma
id|mpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* construct whatever mapping is needed */
id|mpnt
op_assign
(paren
r_struct
id|vm_area_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mpnt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
suffix:semicolon
op_star
id|mpnt
op_assign
op_star
id|area
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;open
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|mpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;close
)paren
(brace
id|area-&gt;vm_end
op_assign
id|area-&gt;vm_start
suffix:semicolon
id|area-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|area
)paren
suffix:semicolon
)brace
id|insert_vm_struct
c_func
(paren
id|current
comma
id|mpnt
)paren
suffix:semicolon
)brace
DECL|function|sys_munmap
id|asmlinkage
r_int
id|sys_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_return
id|do_munmap
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Munmap is split into 2 main parts -- this part which finds&n; * what needs doing, and the areas themselves, which do the&n; * work.  This now handles partial unmappings.&n; * Jeremy Fitzhardine &lt;jeremy@sw.oz.au&gt;&n; */
DECL|function|do_munmap
r_int
id|do_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
op_star
id|prev
comma
op_star
id|next
comma
op_star
op_star
id|npp
comma
op_star
id|free
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|addr
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_minus
id|addr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Check if this memory area is ok - put it on the temporary&n;&t; * list if so..  The checks here are pretty simple --&n;&t; * every area affected in some way (by any overlap) is put&n;&t; * on the list.  If nothing is put on, nothing is affected.&n;&t; */
id|mpnt
op_assign
id|find_vma
c_func
(paren
id|current
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
l_int|0
suffix:semicolon
id|avl_neighbours
c_func
(paren
id|mpnt
comma
id|current-&gt;mm-&gt;mmap_avl
comma
op_amp
id|prev
comma
op_amp
id|next
)paren
suffix:semicolon
multiline_comment|/* we have  prev-&gt;vm_next == mpnt &amp;&amp; mpnt-&gt;vm_next = next */
multiline_comment|/* and  addr &lt; mpnt-&gt;vm_end  */
id|npp
op_assign
(paren
id|prev
ques
c_cond
op_amp
id|prev-&gt;vm_next
suffix:colon
op_amp
id|current-&gt;mm-&gt;mmap
)paren
suffix:semicolon
id|free
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|mpnt
op_logical_and
id|mpnt-&gt;vm_start
OL
id|addr
op_plus
id|len
suffix:semicolon
id|mpnt
op_assign
op_star
id|npp
)paren
(brace
op_star
id|npp
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|mpnt-&gt;vm_next
op_assign
id|free
suffix:semicolon
id|free
op_assign
id|mpnt
suffix:semicolon
id|avl_remove
c_func
(paren
id|mpnt
comma
op_amp
id|current-&gt;mm-&gt;mmap_avl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Ok - we have the memory areas we should free on the &squot;free&squot; list,&n;&t; * so release them, and unmap the page range..&n;&t; * If the one of the segments is only being partially unmapped,&n;&t; * it will put new vm_area_struct(s) into the address space.&n;&t; */
r_while
c_loop
(paren
id|free
)paren
(brace
r_int
r_int
id|st
comma
id|end
suffix:semicolon
id|mpnt
op_assign
id|free
suffix:semicolon
id|free
op_assign
id|free-&gt;vm_next
suffix:semicolon
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|st
op_assign
id|addr
OL
id|mpnt-&gt;vm_start
ques
c_cond
id|mpnt-&gt;vm_start
suffix:colon
id|addr
suffix:semicolon
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|end
op_assign
id|end
OG
id|mpnt-&gt;vm_end
ques
c_cond
id|mpnt-&gt;vm_end
suffix:colon
id|end
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;unmap
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|unmap
c_func
(paren
id|mpnt
comma
id|st
comma
id|end
op_minus
id|st
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|current-&gt;mm
comma
id|st
comma
id|end
op_minus
id|st
)paren
suffix:semicolon
id|unmap_fixup
c_func
(paren
id|mpnt
comma
id|st
comma
id|end
op_minus
id|st
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
id|zap_page_range
c_func
(paren
id|current-&gt;mm
comma
id|addr
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Build the AVL tree corresponding to the VMA list. */
DECL|function|build_mmap_avl
r_void
id|build_mmap_avl
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|mm-&gt;mmap_avl
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
id|avl_insert
c_func
(paren
id|vma
comma
op_amp
id|mm-&gt;mmap_avl
)paren
suffix:semicolon
)brace
multiline_comment|/* Release all mmaps. */
DECL|function|exit_mmap
r_void
id|exit_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|mm-&gt;mmap
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;mmap_avl
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;total_vm
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;locked_vm
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|mpnt
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
)paren
(brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops-&gt;unmap
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|unmap
c_func
(paren
id|mpnt
comma
id|mpnt-&gt;vm_start
comma
id|mpnt-&gt;vm_end
op_minus
id|mpnt-&gt;vm_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops-&gt;close
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|mm
comma
id|mpnt-&gt;vm_start
comma
id|mpnt-&gt;vm_end
op_minus
id|mpnt-&gt;vm_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_inode
)paren
id|iput
c_func
(paren
id|mpnt-&gt;vm_inode
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Insert vm structure into process list sorted by address&n; * and into the inode&squot;s i_mmap ring.&n; */
DECL|function|insert_vm_struct
r_void
id|insert_vm_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|t
comma
r_struct
id|vm_area_struct
op_star
id|vmp
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|share
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
macro_line|#if 0 /* equivalent, but slow */
r_struct
id|vm_area_struct
op_star
op_star
id|p
comma
op_star
id|mpnt
suffix:semicolon
id|p
op_assign
op_amp
id|t-&gt;mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mpnt
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_start
OG
id|vmp-&gt;vm_start
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_end
OG
id|vmp-&gt;vm_start
)paren
id|printk
c_func
(paren
l_string|&quot;insert_vm_struct: overlapping memory areas&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|mpnt-&gt;vm_next
suffix:semicolon
)brace
id|vmp-&gt;vm_next
op_assign
id|mpnt
suffix:semicolon
op_star
id|p
op_assign
id|vmp
suffix:semicolon
macro_line|#else
r_struct
id|vm_area_struct
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|avl_insert_neighbours
c_func
(paren
id|vmp
comma
op_amp
id|t-&gt;mm-&gt;mmap_avl
comma
op_amp
id|prev
comma
op_amp
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|prev
ques
c_cond
id|prev-&gt;vm_next
suffix:colon
id|t-&gt;mm-&gt;mmap
)paren
op_ne
id|next
)paren
id|printk
c_func
(paren
l_string|&quot;insert_vm_struct: tree inconsistent with list&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;vm_next
op_assign
id|vmp
suffix:semicolon
r_else
id|t-&gt;mm-&gt;mmap
op_assign
id|vmp
suffix:semicolon
id|vmp-&gt;vm_next
op_assign
id|next
suffix:semicolon
macro_line|#endif
id|inode
op_assign
id|vmp-&gt;vm_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
suffix:semicolon
multiline_comment|/* insert vmp into inode&squot;s circular share list */
r_if
c_cond
(paren
(paren
id|share
op_assign
id|inode-&gt;i_mmap
)paren
)paren
(brace
id|vmp-&gt;vm_next_share
op_assign
id|share-&gt;vm_next_share
suffix:semicolon
id|vmp-&gt;vm_next_share-&gt;vm_prev_share
op_assign
id|vmp
suffix:semicolon
id|share-&gt;vm_next_share
op_assign
id|vmp
suffix:semicolon
id|vmp-&gt;vm_prev_share
op_assign
id|share
suffix:semicolon
)brace
r_else
id|inode-&gt;i_mmap
op_assign
id|vmp-&gt;vm_next_share
op_assign
id|vmp-&gt;vm_prev_share
op_assign
id|vmp
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove one vm structure from the inode&squot;s i_mmap ring.&n; */
DECL|function|remove_shared_vm_struct
r_void
id|remove_shared_vm_struct
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|mpnt
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|mpnt-&gt;vm_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_next_share
op_eq
id|mpnt
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_mmap
op_ne
id|mpnt
)paren
id|printk
c_func
(paren
l_string|&quot;Inode i_mmap ring corrupted&bslash;n&quot;
)paren
suffix:semicolon
id|inode-&gt;i_mmap
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_mmap
op_eq
id|mpnt
)paren
id|inode-&gt;i_mmap
op_assign
id|mpnt-&gt;vm_next_share
suffix:semicolon
id|mpnt-&gt;vm_prev_share-&gt;vm_next_share
op_assign
id|mpnt-&gt;vm_next_share
suffix:semicolon
id|mpnt-&gt;vm_next_share-&gt;vm_prev_share
op_assign
id|mpnt-&gt;vm_prev_share
suffix:semicolon
)brace
multiline_comment|/*&n; * Merge the list of memory segments if possible.&n; * Redundant vm_area_structs are freed.&n; * This assumes that the list is ordered by address.&n; * We don&squot;t need to traverse the entire list, only those segments&n; * which intersect or are adjacent to a given interval.&n; */
DECL|function|merge_segments
r_void
id|merge_segments
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
id|start_addr
comma
r_int
r_int
id|end_addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|prev
comma
op_star
id|mpnt
comma
op_star
id|next
suffix:semicolon
id|mpnt
op_assign
id|find_vma
c_func
(paren
id|task
comma
id|start_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
suffix:semicolon
id|avl_neighbours
c_func
(paren
id|mpnt
comma
id|task-&gt;mm-&gt;mmap_avl
comma
op_amp
id|prev
comma
op_amp
id|next
)paren
suffix:semicolon
multiline_comment|/* we have  prev-&gt;vm_next == mpnt &amp;&amp; mpnt-&gt;vm_next = next */
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|prev
op_assign
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* prev and mpnt cycle through the list, as long as&n;&t; * start_addr &lt; mpnt-&gt;vm_end &amp;&amp; prev-&gt;vm_start &lt; end_addr&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|mpnt
op_logical_and
id|prev-&gt;vm_start
OL
id|end_addr
suffix:semicolon
id|prev
op_assign
id|mpnt
comma
id|mpnt
op_assign
id|next
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;looping in merge_segments, mpnt=0x%lX&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|mpnt
)paren
suffix:semicolon
macro_line|#endif
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
multiline_comment|/*&n;&t;&t; * To share, we must have the same inode, operations.. &n;&t;&t; */
r_if
c_cond
(paren
id|mpnt-&gt;vm_inode
op_ne
id|prev-&gt;vm_inode
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_pte
op_ne
id|prev-&gt;vm_pte
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_ne
id|prev-&gt;vm_ops
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_flags
op_ne
id|prev-&gt;vm_flags
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;vm_end
op_ne
id|mpnt-&gt;vm_start
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * and if we have an inode, the offsets must be contiguous..&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mpnt-&gt;vm_inode
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_SHM
)paren
)paren
(brace
r_if
c_cond
(paren
id|prev-&gt;vm_offset
op_plus
id|prev-&gt;vm_end
op_minus
id|prev-&gt;vm_start
op_ne
id|mpnt-&gt;vm_offset
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * merge prev with mpnt and set up pointers so the new&n;&t;&t; * big segment can possibly merge with the next one.&n;&t;&t; * The old unused mpnt is freed.&n;&t;&t; */
id|avl_remove
c_func
(paren
id|mpnt
comma
op_amp
id|task-&gt;mm-&gt;mmap_avl
)paren
suffix:semicolon
id|prev-&gt;vm_end
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
id|prev-&gt;vm_next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;close
)paren
(brace
id|mpnt-&gt;vm_offset
op_add_assign
id|mpnt-&gt;vm_end
op_minus
id|mpnt-&gt;vm_start
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_inode
)paren
id|mpnt-&gt;vm_inode-&gt;i_count
op_decrement
suffix:semicolon
id|kfree_s
c_func
(paren
id|mpnt
comma
r_sizeof
(paren
op_star
id|mpnt
)paren
)paren
suffix:semicolon
id|mpnt
op_assign
id|prev
suffix:semicolon
)brace
)brace
eof
