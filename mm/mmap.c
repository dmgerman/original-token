multiline_comment|/*&n; *&t;linux/mm/mmap.c&n; *&n; * Written by obz.&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
multiline_comment|/* description of effects of mapping type and prot in current implementation.&n; * this is due to the limited x86 page protection hardware.  The expected&n; * behavior is in parens:&n; *&n; * map_type&t;prot&n; *&t;&t;PROT_NONE&t;PROT_READ&t;PROT_WRITE&t;PROT_EXEC&n; * MAP_SHARED&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (yes) yes&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&t;&t;&n; * MAP_PRIVATE&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (copy) copy&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&n; */
DECL|variable|protection_map
id|pgprot_t
id|protection_map
(braket
l_int|16
)braket
op_assign
(brace
id|__P000
comma
id|__P001
comma
id|__P010
comma
id|__P011
comma
id|__P100
comma
id|__P101
comma
id|__P110
comma
id|__P111
comma
id|__S000
comma
id|__S001
comma
id|__S010
comma
id|__S011
comma
id|__S100
comma
id|__S101
comma
id|__S110
comma
id|__S111
)brace
suffix:semicolon
DECL|variable|sysctl_overcommit_memory
r_int
id|sysctl_overcommit_memory
suffix:semicolon
multiline_comment|/* Check that a process has enough memory to allocate a&n; * new virtual mapping.&n; */
DECL|function|vm_enough_memory
r_int
id|vm_enough_memory
c_func
(paren
r_int
id|pages
)paren
(brace
multiline_comment|/* Stupid algorithm to decide if we have enough memory: while&n;&t; * simple, it hopefully works in most obvious cases.. Easy to&n;&t; * fool it, but this should catch most mistakes.&n;&t; */
multiline_comment|/* 23/11/98 NJC: Somewhat less stupid version of algorithm,&n;&t; * which tries to do &quot;TheRightThing&quot;.  Instead of using half of&n;&t; * (buffers+cache), use the minimum values.  Allow an extra 2%&n;&t; * of num_physpages for safety margin.&n;&t; */
r_int
id|free
suffix:semicolon
multiline_comment|/* Sometimes we want to use more memory than we have. */
r_if
c_cond
(paren
id|sysctl_overcommit_memory
)paren
r_return
l_int|1
suffix:semicolon
id|free
op_assign
id|atomic_read
c_func
(paren
op_amp
id|buffermem_pages
)paren
suffix:semicolon
id|free
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|page_cache_size
)paren
suffix:semicolon
id|free
op_add_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|free
op_add_assign
id|nr_swap_pages
suffix:semicolon
r_return
id|free
OG
id|pages
suffix:semicolon
)brace
multiline_comment|/* Remove one vm structure from the inode&squot;s i_mapping address space. */
DECL|function|__remove_shared_vm_struct
r_static
r_inline
r_void
id|__remove_shared_vm_struct
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_next_share
)paren
(brace
id|vma-&gt;vm_next_share-&gt;vm_pprev_share
op_assign
id|vma-&gt;vm_pprev_share
suffix:semicolon
)brace
op_star
id|vma-&gt;vm_pprev_share
op_assign
id|vma-&gt;vm_next_share
suffix:semicolon
)brace
)brace
DECL|function|remove_shared_vm_struct
r_static
r_inline
r_void
id|remove_shared_vm_struct
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|lock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
id|__remove_shared_vm_struct
c_func
(paren
id|vma
)paren
suffix:semicolon
id|unlock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
)brace
DECL|function|lock_vma_mappings
r_void
id|lock_vma_mappings
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
id|mapping
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|mapping
op_assign
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;i_shared_lock
)paren
suffix:semicolon
)brace
DECL|function|unlock_vma_mappings
r_void
id|unlock_vma_mappings
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
id|mapping
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|mapping
op_assign
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;i_shared_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  sys_brk() for the most part doesn&squot;t need the global kernel&n; *  lock, except when an application is doing something nasty&n; *  like trying to un-brk an area that has already been mapped&n; *  to a regular file.  in this case, the unmapping will need&n; *  to invoke file system routines that need the global lock.&n; */
DECL|function|sys_brk
id|asmlinkage
r_int
r_int
id|sys_brk
c_func
(paren
r_int
r_int
id|brk
)paren
(brace
r_int
r_int
id|rlim
comma
id|retval
suffix:semicolon
r_int
r_int
id|newbrk
comma
id|oldbrk
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brk
OL
id|mm-&gt;end_code
)paren
r_goto
id|out
suffix:semicolon
id|newbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|brk
)paren
suffix:semicolon
id|oldbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mm-&gt;brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldbrk
op_eq
id|newbrk
)paren
r_goto
id|set_brk
suffix:semicolon
multiline_comment|/* Always allow shrinking brk. */
r_if
c_cond
(paren
id|brk
op_le
id|mm-&gt;brk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_munmap
c_func
(paren
id|mm
comma
id|newbrk
comma
id|oldbrk
op_minus
id|newbrk
)paren
)paren
r_goto
id|set_brk
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Check against rlimit.. */
id|rlim
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_DATA
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|rlim
template_param
id|rlim
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check against existing mmap mappings. */
r_if
c_cond
(paren
id|find_vma_intersection
c_func
(paren
id|mm
comma
id|oldbrk
comma
id|newbrk
op_plus
id|PAGE_SIZE
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check if we have enough memory.. */
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
(paren
id|newbrk
op_minus
id|oldbrk
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Ok, looks good - let it rip. */
r_if
c_cond
(paren
id|do_brk
c_func
(paren
id|oldbrk
comma
id|newbrk
op_minus
id|oldbrk
)paren
op_ne
id|oldbrk
)paren
r_goto
id|out
suffix:semicolon
id|set_brk
suffix:colon
id|mm-&gt;brk
op_assign
id|brk
suffix:semicolon
id|out
suffix:colon
id|retval
op_assign
id|mm-&gt;brk
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Combine the mmap &quot;prot&quot; and &quot;flags&quot; argument into one &quot;vm_flags&quot; used&n; * internally. Essentially, translate the &quot;PROT_xxx&quot; and &quot;MAP_xxx&quot; bits&n; * into &quot;VM_xxx&quot;.&n; */
DECL|function|vm_flags
r_static
r_inline
r_int
r_int
id|vm_flags
c_func
(paren
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
)paren
(brace
DECL|macro|_trans
mdefine_line|#define _trans(x,bit1,bit2) &bslash;&n;((bit1==bit2)?(x&amp;bit1):(x&amp;bit1)?bit2:0)
r_int
r_int
id|prot_bits
comma
id|flag_bits
suffix:semicolon
id|prot_bits
op_assign
id|_trans
c_func
(paren
id|prot
comma
id|PROT_READ
comma
id|VM_READ
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_WRITE
comma
id|VM_WRITE
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_EXEC
comma
id|VM_EXEC
)paren
suffix:semicolon
id|flag_bits
op_assign
id|_trans
c_func
(paren
id|flags
comma
id|MAP_GROWSDOWN
comma
id|VM_GROWSDOWN
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_DENYWRITE
comma
id|VM_DENYWRITE
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_EXECUTABLE
comma
id|VM_EXECUTABLE
)paren
suffix:semicolon
r_return
id|prot_bits
op_or
id|flag_bits
suffix:semicolon
DECL|macro|_trans
macro_line|#undef _trans
)brace
DECL|function|do_mmap_pgoff
r_int
r_int
id|do_mmap_pgoff
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|pgoff
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
id|correct_wcount
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
op_logical_or
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* offset overflow? */
r_if
c_cond
(paren
(paren
id|pgoff
op_plus
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
OL
id|pgoff
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Too many mappings? */
r_if
c_cond
(paren
id|mm-&gt;map_count
OG
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* mlock MCL_FUTURE? */
r_if
c_cond
(paren
id|mm-&gt;def_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
op_assign
id|mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Do simple checking here so the lower-level routines won&squot;t have&n;&t; * to. we assume access permissions have been handled by the open&n;&t; * of the memory object, so we don&squot;t do any here.&n;&t; */
r_if
c_cond
(paren
id|file
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_case
id|MAP_SHARED
suffix:colon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t allow writing to an append-only file.. */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* make sure there are no mandatory locks on the file. */
r_if
c_cond
(paren
id|locks_verify_locked
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MAP_PRIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* Obtain the address to map to. we verify (or select) it and ensure&n;&t; * that it represents a valid section of the address space.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_FIXED
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
id|get_unmapped_area
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Determine the object being mapped and call the appropriate&n;&t; * specific mapper. the address has already been validated, but&n;&t; * not unmapped, but the maps are removed from the list.&n;&t; */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|vm_flags
c_func
(paren
id|prot
comma
id|flags
)paren
op_or
id|mm-&gt;def_flags
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
id|VM_ClearReadHint
c_func
(paren
id|vma
)paren
suffix:semicolon
id|vma-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|vma-&gt;vm_flags
op_or_assign
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
(brace
id|vma-&gt;vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
multiline_comment|/* This looks strange, but when we don&squot;t have the file open&n;&t;&t;&t; * for writing, we can demote the shared mapping to a simpler&n;&t;&t;&t; * private mapping. That also takes care of a security hole&n;&t;&t;&t; * with ptrace() writing to a shared mapping without write&n;&t;&t;&t; * permissions.&n;&t;&t;&t; *&n;&t;&t;&t; * We leave the VM_MAYSHARE bit on, just to get correct output&n;&t;&t;&t; * from /proc/xxx/maps..&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
id|vma-&gt;vm_flags
op_and_assign
op_complement
(paren
id|VM_MAYWRITE
op_or
id|VM_SHARED
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|vma-&gt;vm_flags
op_or_assign
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
id|vma-&gt;vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
)brace
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|vma-&gt;vm_flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
id|pgoff
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Clear old maps */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
)paren
r_goto
id|free_vma
suffix:semicolon
multiline_comment|/* Check against address space limit. */
r_if
c_cond
(paren
(paren
id|mm-&gt;total_vm
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|len
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_goto
id|free_vma
suffix:semicolon
multiline_comment|/* Private writable mapping? Check memory availability.. */
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_SHARED
op_or
id|VM_WRITE
)paren
)paren
op_eq
id|VM_WRITE
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MAP_NORESERVE
)paren
op_logical_and
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_goto
id|free_vma
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
(brace
id|error
op_assign
id|deny_write_access
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|free_vma
suffix:semicolon
id|correct_wcount
op_assign
l_int|1
suffix:semicolon
)brace
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
id|error
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|unmap_and_free_vma
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
(brace
id|error
op_assign
id|shmem_zero_setup
c_func
(paren
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|free_vma
suffix:semicolon
)brace
multiline_comment|/* Can addr have changed??&n;&t; *&n;&t; * Answer: Yes, several device drivers can do it in their&n;&t; *         f_op-&gt;mmap method. -DaveM&n;&t; */
id|flags
op_assign
id|vma-&gt;vm_flags
suffix:semicolon
id|addr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|correct_wcount
)paren
id|atomic_inc
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|VM_LOCKED
)paren
(brace
id|mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|make_pages_present
c_func
(paren
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
id|unmap_and_free_vma
suffix:colon
r_if
c_cond
(paren
id|correct_wcount
)paren
id|atomic_inc
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
multiline_comment|/* Undo any partial mapping done by a device driver. */
id|flush_cache_range
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|flush_tlb_range
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|free_vma
suffix:colon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Get an address range which is currently unmapped.&n; * For mmap() without MAP_FIXED and shmat() with addr=0.&n; * Return value 0 means ENOMEM.&n; */
macro_line|#ifndef HAVE_ARCH_UNMAPPED_AREA
DECL|function|get_unmapped_area
r_int
r_int
id|get_unmapped_area
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vmm
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vmm
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|addr
)paren
suffix:semicolon
suffix:semicolon
id|vmm
op_assign
id|vmm-&gt;vm_next
)paren
(brace
multiline_comment|/* At this point:  (!vmm || addr &lt; vmm-&gt;vm_end). */
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
OL
id|addr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vmm
op_logical_or
id|addr
op_plus
id|len
op_le
id|vmm-&gt;vm_start
)paren
r_return
id|addr
suffix:semicolon
id|addr
op_assign
id|vmm-&gt;vm_end
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|macro|vm_avl_empty
mdefine_line|#define vm_avl_empty&t;(struct vm_area_struct *) NULL
macro_line|#include &quot;mmap_avl.c&quot;
multiline_comment|/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */
DECL|function|find_vma
r_struct
id|vm_area_struct
op_star
id|find_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
multiline_comment|/* Check the cache first. */
multiline_comment|/* (Cache hit rate is typically around 35%.) */
id|vma
op_assign
id|mm-&gt;mmap_cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma
op_logical_and
id|vma-&gt;vm_end
OG
id|addr
op_logical_and
id|vma-&gt;vm_start
op_le
id|addr
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mm-&gt;mmap_avl
)paren
(brace
multiline_comment|/* Go through the linear list. */
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|vma
op_logical_and
id|vma-&gt;vm_end
op_le
id|addr
)paren
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Then go through the AVL tree quickly. */
r_struct
id|vm_area_struct
op_star
id|tree
op_assign
id|mm-&gt;mmap_avl
suffix:semicolon
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|vm_avl_empty
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_end
OG
id|addr
)paren
(brace
id|vma
op_assign
id|tree
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_start
op_le
id|addr
)paren
r_break
suffix:semicolon
id|tree
op_assign
id|tree-&gt;vm_avl_left
suffix:semicolon
)brace
r_else
id|tree
op_assign
id|tree-&gt;vm_avl_right
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vma
)paren
id|mm-&gt;mmap_cache
op_assign
id|vma
suffix:semicolon
)brace
)brace
r_return
id|vma
suffix:semicolon
)brace
multiline_comment|/* Same as find_vma, but also return a pointer to the previous VMA in *pprev. */
DECL|function|find_vma_prev
r_struct
id|vm_area_struct
op_star
id|find_vma_prev
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
)paren
(brace
r_if
c_cond
(paren
id|mm
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mm-&gt;mmap_avl
)paren
(brace
multiline_comment|/* Go through the linear list. */
r_struct
id|vm_area_struct
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|vma
op_logical_and
id|vma-&gt;vm_end
op_le
id|addr
)paren
(brace
id|prev
op_assign
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
op_star
id|pprev
op_assign
id|prev
suffix:semicolon
r_return
id|vma
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Go through the AVL tree quickly. */
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|last_turn_right
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|tree
op_assign
id|mm-&gt;mmap_avl
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|tree
op_eq
id|vm_avl_empty
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_end
OG
id|addr
)paren
(brace
id|vma
op_assign
id|tree
suffix:semicolon
id|prev
op_assign
id|last_turn_right
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;vm_start
op_le
id|addr
)paren
r_break
suffix:semicolon
id|tree
op_assign
id|tree-&gt;vm_avl_left
suffix:semicolon
)brace
r_else
(brace
id|last_turn_right
op_assign
id|tree
suffix:semicolon
id|tree
op_assign
id|tree-&gt;vm_avl_right
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_avl_left
op_ne
id|vm_avl_empty
)paren
(brace
id|prev
op_assign
id|vma-&gt;vm_avl_left
suffix:semicolon
r_while
c_loop
(paren
id|prev-&gt;vm_avl_right
op_ne
id|vm_avl_empty
)paren
id|prev
op_assign
id|prev-&gt;vm_avl_right
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|prev
ques
c_cond
id|prev-&gt;vm_next
suffix:colon
id|mm-&gt;mmap
)paren
op_ne
id|vma
)paren
id|printk
c_func
(paren
l_string|&quot;find_vma_prev: tree inconsistent with list&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|pprev
op_assign
id|prev
suffix:semicolon
r_return
id|vma
suffix:semicolon
)brace
)brace
)brace
op_star
id|pprev
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_extend_vma
r_struct
id|vm_area_struct
op_star
id|find_extend_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
id|addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_le
id|addr
)paren
r_return
id|vma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_GROWSDOWN
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|expand_stack
c_func
(paren
id|vma
comma
id|addr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|make_pages_present
c_func
(paren
id|addr
comma
id|start
)paren
suffix:semicolon
)brace
r_return
id|vma
suffix:semicolon
)brace
multiline_comment|/* Normal function to fix up a mapping&n; * This function is the default for when an area has no specific&n; * function.  This may be used as part of a more specific routine.&n; * This function works out what part of an area is affected and&n; * adjusts the mapping information.  Since the actual page&n; * manipulation is done in do_mmap(), none need be done here,&n; * though it would probably be more appropriate.&n; *&n; * By the time this function is called, the area struct has been&n; * removed from the process mapping list, so it needs to be&n; * reinserted if necessary.&n; *&n; * The 4 main cases are:&n; *    Unmapping the whole area&n; *    Unmapping from the start of the segment to a point in it&n; *    Unmapping from an intermediate point to the end&n; *    Unmapping between to intermediate points, making a hole.&n; *&n; * Case 4 involves the creation of 2 new areas, for each side of&n; * the hole.  If possible, we reuse the existing area rather than&n; * allocate a new one, and the return indicates whether the old&n; * area was reused.&n; */
DECL|function|unmap_fixup
r_static
r_struct
id|vm_area_struct
op_star
id|unmap_fixup
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|addr
comma
r_int
id|len
comma
r_struct
id|vm_area_struct
op_star
id|extra
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|area-&gt;vm_mm-&gt;total_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|area-&gt;vm_mm-&gt;locked_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Unmapping the whole area. */
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
op_logical_and
id|end
op_eq
id|area-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;close
)paren
id|area-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|area
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_file
)paren
id|fput
c_func
(paren
id|area-&gt;vm_file
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|area
)paren
suffix:semicolon
r_return
id|extra
suffix:semicolon
)brace
multiline_comment|/* Work out to one of the ends. */
r_if
c_cond
(paren
id|end
op_eq
id|area-&gt;vm_end
)paren
(brace
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
id|lock_vma_mappings
c_func
(paren
id|area
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
)paren
(brace
id|area-&gt;vm_pgoff
op_add_assign
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|area-&gt;vm_start
op_assign
id|end
suffix:semicolon
id|lock_vma_mappings
c_func
(paren
id|area
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unmapping a hole: area-&gt;vm_start &lt; addr &lt;= end &lt; area-&gt;vm_end */
multiline_comment|/* Add end mapping -- leave beginning for below */
id|mpnt
op_assign
id|extra
suffix:semicolon
id|extra
op_assign
l_int|NULL
suffix:semicolon
id|mpnt-&gt;vm_mm
op_assign
id|area-&gt;vm_mm
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|end
suffix:semicolon
id|mpnt-&gt;vm_end
op_assign
id|area-&gt;vm_end
suffix:semicolon
id|mpnt-&gt;vm_page_prot
op_assign
id|area-&gt;vm_page_prot
suffix:semicolon
id|mpnt-&gt;vm_flags
op_assign
id|area-&gt;vm_flags
suffix:semicolon
id|mpnt-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|mpnt-&gt;vm_ops
op_assign
id|area-&gt;vm_ops
suffix:semicolon
id|mpnt-&gt;vm_pgoff
op_assign
id|area-&gt;vm_pgoff
op_plus
(paren
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|mpnt-&gt;vm_file
op_assign
id|area-&gt;vm_file
suffix:semicolon
id|mpnt-&gt;vm_private_data
op_assign
id|area-&gt;vm_private_data
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_file
)paren
id|get_file
c_func
(paren
id|mpnt-&gt;vm_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;open
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Truncate area */
multiline_comment|/* Because mpnt-&gt;vm_file == area-&gt;vm_file this locks&n;&t;&t; * things correctly.&n;&t;&t; */
id|lock_vma_mappings
c_func
(paren
id|area
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|__insert_vm_struct
c_func
(paren
id|mm
comma
id|mpnt
)paren
suffix:semicolon
)brace
id|__insert_vm_struct
c_func
(paren
id|mm
comma
id|area
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|unlock_vma_mappings
c_func
(paren
id|area
)paren
suffix:semicolon
r_return
id|extra
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to free as many page directory entries as we can,&n; * without having to work very hard at actually scanning&n; * the page tables themselves.&n; *&n; * Right now we try to free page tables if we have a nice&n; * PGDIR-aligned area that got free&squot;d up. We could be more&n; * granular if we want to, but this is fast and simple,&n; * and covers the bad cases.&n; *&n; * &quot;prev&quot;, if it exists, points to a vma before the one&n; * we just free&squot;d - but there&squot;s no telling how much before.&n; */
DECL|function|free_pgtables
r_static
r_void
id|free_pgtables
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|first
op_assign
id|start
op_amp
id|PGDIR_MASK
suffix:semicolon
r_int
r_int
id|last
op_assign
id|end
op_plus
id|PGDIR_SIZE
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|start_index
comma
id|end_index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|prev
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
r_goto
id|no_mmaps
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;vm_end
OG
id|start
)paren
(brace
r_if
c_cond
(paren
id|last
OG
id|prev-&gt;vm_start
)paren
id|last
op_assign
id|prev-&gt;vm_start
suffix:semicolon
r_goto
id|no_mmaps
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|prev-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;vm_start
OL
id|start
)paren
(brace
id|prev
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
OG
id|next-&gt;vm_start
)paren
id|last
op_assign
id|next-&gt;vm_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev-&gt;vm_end
OG
id|first
)paren
id|first
op_assign
id|prev-&gt;vm_end
op_plus
id|PGDIR_SIZE
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|no_mmaps
suffix:colon
multiline_comment|/*&n;&t; * If the PGD bits are not consecutive in the virtual address, the&n;&t; * old method of shifting the VA &gt;&gt; by PGDIR_SHIFT doesn&squot;t work.&n;&t; */
id|start_index
op_assign
id|pgd_index
c_func
(paren
id|first
)paren
suffix:semicolon
id|end_index
op_assign
id|pgd_index
c_func
(paren
id|last
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end_index
OG
id|start_index
)paren
(brace
id|clear_page_tables
c_func
(paren
id|mm
comma
id|start_index
comma
id|end_index
op_minus
id|start_index
)paren
suffix:semicolon
id|flush_tlb_pgtables
c_func
(paren
id|mm
comma
id|first
op_amp
id|PGDIR_MASK
comma
id|last
op_amp
id|PGDIR_MASK
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Munmap is split into 2 main parts -- this part which finds&n; * what needs doing, and the areas themselves, which do the&n; * work.  This now handles partial unmappings.&n; * Jeremy Fitzhardine &lt;jeremy@sw.oz.au&gt;&n; */
DECL|function|do_munmap
r_int
id|do_munmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
op_star
id|prev
comma
op_star
op_star
id|npp
comma
op_star
id|free
comma
op_star
id|extra
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|addr
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_minus
id|addr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check if this memory area is ok - put it on the temporary&n;&t; * list if so..  The checks here are pretty simple --&n;&t; * every area affected in some way (by any overlap) is put&n;&t; * on the list.  If nothing is put on, nothing is affected.&n;&t; */
id|mpnt
op_assign
id|find_vma_prev
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we have  addr &lt; mpnt-&gt;vm_end  */
r_if
c_cond
(paren
id|mpnt-&gt;vm_start
op_ge
id|addr
op_plus
id|len
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If we&squot;ll make &quot;hole&quot;, check the vm areas limit */
r_if
c_cond
(paren
(paren
id|mpnt-&gt;vm_start
template_param
id|addr
op_plus
id|len
)paren
op_logical_and
id|mm-&gt;map_count
op_ge
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * We may need one additional vma to fix up the mappings ... &n;&t; * and this is the last chance for an easy error exit.&n;&t; */
id|extra
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|extra
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|npp
op_assign
(paren
id|prev
ques
c_cond
op_amp
id|prev-&gt;vm_next
suffix:colon
op_amp
id|mm-&gt;mmap
)paren
suffix:semicolon
id|free
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|mpnt
op_logical_and
id|mpnt-&gt;vm_start
OL
id|addr
op_plus
id|len
suffix:semicolon
id|mpnt
op_assign
op_star
id|npp
)paren
(brace
op_star
id|npp
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|mpnt-&gt;vm_next
op_assign
id|free
suffix:semicolon
id|free
op_assign
id|mpnt
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;mmap_avl
)paren
id|avl_remove
c_func
(paren
id|mpnt
comma
op_amp
id|mm-&gt;mmap_avl
)paren
suffix:semicolon
)brace
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Kill the cache. */
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
multiline_comment|/* Ok - we have the memory areas we should free on the &squot;free&squot; list,&n;&t; * so release them, and unmap the page range..&n;&t; * If the one of the segments is only being partially unmapped,&n;&t; * it will put new vm_area_struct(s) into the address space.&n;&t; * In that case we have to be careful with VM_DENYWRITE.&n;&t; */
r_while
c_loop
(paren
(paren
id|mpnt
op_assign
id|free
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|st
comma
id|end
comma
id|size
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
id|free
op_assign
id|free-&gt;vm_next
suffix:semicolon
id|st
op_assign
id|addr
OL
id|mpnt-&gt;vm_start
ques
c_cond
id|mpnt-&gt;vm_start
suffix:colon
id|addr
suffix:semicolon
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|end
op_assign
id|end
OG
id|mpnt-&gt;vm_end
ques
c_cond
id|mpnt-&gt;vm_end
suffix:colon
id|end
suffix:semicolon
id|size
op_assign
id|end
op_minus
id|st
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_DENYWRITE
op_logical_and
(paren
id|st
op_ne
id|mpnt-&gt;vm_start
op_logical_or
id|end
op_ne
id|mpnt-&gt;vm_end
)paren
op_logical_and
(paren
id|file
op_assign
id|mpnt-&gt;vm_file
)paren
op_ne
l_int|NULL
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
suffix:semicolon
)brace
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|mm
comma
id|st
comma
id|end
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|mm
comma
id|st
comma
id|size
)paren
suffix:semicolon
id|flush_tlb_range
c_func
(paren
id|mm
comma
id|st
comma
id|end
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fix the mapping, and free the old area if it wasn&squot;t reused.&n;&t;&t; */
id|extra
op_assign
id|unmap_fixup
c_func
(paren
id|mm
comma
id|mpnt
comma
id|st
comma
id|size
comma
id|extra
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|atomic_inc
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
suffix:semicolon
)brace
multiline_comment|/* Release the extra vma struct if it wasn&squot;t used */
r_if
c_cond
(paren
id|extra
)paren
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|extra
)paren
suffix:semicolon
id|free_pgtables
c_func
(paren
id|mm
comma
id|prev
comma
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_munmap
id|asmlinkage
r_int
id|sys_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|ret
op_assign
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *  this is really a simplified &quot;do_mmap&quot;.  it only handles&n; *  anonymous maps.  eventually we may be able to do some&n; *  brk-specific accounting here.&n; */
DECL|function|do_brk
r_int
r_int
id|do_brk
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|flags
comma
id|retval
suffix:semicolon
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * mlock MCL_FUTURE?&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;def_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
op_assign
id|mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear old maps.  this also does some error checking for us&n;&t; */
id|retval
op_assign
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* Check against address space limits *after* clearing old maps... */
r_if
c_cond
(paren
(paren
id|mm-&gt;total_vm
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|len
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;map_count
OG
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|flags
op_assign
id|vm_flags
c_func
(paren
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
id|MAP_FIXED
op_or
id|MAP_PRIVATE
)paren
op_or
id|mm-&gt;def_flags
suffix:semicolon
id|flags
op_or_assign
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
multiline_comment|/* Can we just expand an old anonymous mapping? */
r_if
c_cond
(paren
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
id|vma-&gt;vm_end
op_eq
id|addr
op_logical_and
op_logical_neg
id|vma-&gt;vm_file
op_logical_and
id|vma-&gt;vm_flags
op_eq
id|flags
)paren
(brace
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * create a vma struct for an anonymous mapping&n;&t; */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|flags
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
l_int|0
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
l_int|NULL
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|out
suffix:colon
id|mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|VM_LOCKED
)paren
(brace
id|mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|make_pages_present
c_func
(paren
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/* Build the AVL tree corresponding to the VMA list. */
DECL|function|build_mmap_avl
r_void
id|build_mmap_avl
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|mm-&gt;mmap_avl
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
id|avl_insert
c_func
(paren
id|vma
comma
op_amp
id|mm-&gt;mmap_avl
)paren
suffix:semicolon
)brace
multiline_comment|/* Release all mmaps. */
DECL|function|exit_mmap
r_void
id|exit_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
id|release_segments
c_func
(paren
id|mm
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|mpnt
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|mm-&gt;mmap
op_assign
id|mm-&gt;mmap_avl
op_assign
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;total_vm
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;locked_vm
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|mpnt
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
r_int
r_int
id|start
op_assign
id|mpnt-&gt;vm_start
suffix:semicolon
r_int
r_int
id|end
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
r_int
r_int
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
)paren
(brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops-&gt;close
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|mm
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|mm
comma
id|start
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_file
)paren
id|fput
c_func
(paren
id|mpnt-&gt;vm_file
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* This is just debugging */
r_if
c_cond
(paren
id|mm-&gt;map_count
)paren
id|printk
c_func
(paren
l_string|&quot;exit_mmap: map count is %d&bslash;n&quot;
comma
id|mm-&gt;map_count
)paren
suffix:semicolon
id|clear_page_tables
c_func
(paren
id|mm
comma
id|FIRST_USER_PGD_NR
comma
id|USER_PTRS_PER_PGD
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert vm structure into process list sorted by address&n; * and into the inode&squot;s i_mmap ring.  If vm_file is non-NULL&n; * then the i_shared_lock must be held here.&n; */
DECL|function|__insert_vm_struct
r_void
id|__insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vmp
)paren
(brace
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm-&gt;mmap_avl
)paren
(brace
id|pprev
op_assign
op_amp
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pprev
op_logical_and
(paren
op_star
id|pprev
)paren
op_member_access_from_pointer
id|vm_start
op_le
id|vmp-&gt;vm_start
)paren
id|pprev
op_assign
op_amp
(paren
op_star
id|pprev
)paren
op_member_access_from_pointer
id|vm_next
suffix:semicolon
)brace
r_else
(brace
r_struct
id|vm_area_struct
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|avl_insert_neighbours
c_func
(paren
id|vmp
comma
op_amp
id|mm-&gt;mmap_avl
comma
op_amp
id|prev
comma
op_amp
id|next
)paren
suffix:semicolon
id|pprev
op_assign
(paren
id|prev
ques
c_cond
op_amp
id|prev-&gt;vm_next
suffix:colon
op_amp
id|mm-&gt;mmap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pprev
op_ne
id|next
)paren
id|printk
c_func
(paren
l_string|&quot;insert_vm_struct: tree inconsistent with list&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|vmp-&gt;vm_next
op_assign
op_star
id|pprev
suffix:semicolon
op_star
id|pprev
op_assign
id|vmp
suffix:semicolon
id|mm-&gt;map_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;map_count
op_ge
id|AVL_MIN_MAP_COUNT
op_logical_and
op_logical_neg
id|mm-&gt;mmap_avl
)paren
id|build_mmap_avl
c_func
(paren
id|mm
)paren
suffix:semicolon
id|file
op_assign
id|vmp-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|vm_area_struct
op_star
op_star
id|head
suffix:semicolon
r_if
c_cond
(paren
id|vmp-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|atomic_dec
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|mapping-&gt;i_mmap
suffix:semicolon
r_if
c_cond
(paren
id|vmp-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
id|head
op_assign
op_amp
id|mapping-&gt;i_mmap_shared
suffix:semicolon
multiline_comment|/* insert vmp into inode&squot;s share list */
r_if
c_cond
(paren
(paren
id|vmp-&gt;vm_next_share
op_assign
op_star
id|head
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|vm_pprev_share
op_assign
op_amp
id|vmp-&gt;vm_next_share
suffix:semicolon
)brace
op_star
id|head
op_assign
id|vmp
suffix:semicolon
id|vmp-&gt;vm_pprev_share
op_assign
id|head
suffix:semicolon
)brace
)brace
DECL|function|insert_vm_struct
r_void
id|insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vmp
)paren
(brace
id|lock_vma_mappings
c_func
(paren
id|vmp
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|current-&gt;mm-&gt;page_table_lock
)paren
suffix:semicolon
id|__insert_vm_struct
c_func
(paren
id|mm
comma
id|vmp
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|current-&gt;mm-&gt;page_table_lock
)paren
suffix:semicolon
id|unlock_vma_mappings
c_func
(paren
id|vmp
)paren
suffix:semicolon
)brace
eof
