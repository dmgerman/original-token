multiline_comment|/*&n; *&t;linux/mm/mmap.c&n; *&n; * Written by obz.&n; */
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/* description of effects of mapping type and prot in current implementation.&n; * this is due to the limited x86 page protection hardware.  The expected&n; * behavior is in parens:&n; *&n; * map_type&t;prot&n; *&t;&t;PROT_NONE&t;PROT_READ&t;PROT_WRITE&t;PROT_EXEC&n; * MAP_SHARED&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (yes) yes&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&t;&t;&n; * MAP_PRIVATE&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (copy) copy&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&n; */
DECL|variable|protection_map
id|pgprot_t
id|protection_map
(braket
l_int|16
)braket
op_assign
(brace
id|__P000
comma
id|__P001
comma
id|__P010
comma
id|__P011
comma
id|__P100
comma
id|__P101
comma
id|__P110
comma
id|__P111
comma
id|__S000
comma
id|__S001
comma
id|__S010
comma
id|__S011
comma
id|__S100
comma
id|__S101
comma
id|__S110
comma
id|__S111
)brace
suffix:semicolon
multiline_comment|/* SLAB cache for vm_area_struct&squot;s. */
DECL|variable|vm_area_cachep
id|kmem_cache_t
op_star
id|vm_area_cachep
suffix:semicolon
DECL|variable|sysctl_overcommit_memory
r_int
id|sysctl_overcommit_memory
suffix:semicolon
multiline_comment|/* Check that a process has enough memory to allocate a&n; * new virtual mapping.&n; */
DECL|function|vm_enough_memory
r_int
id|vm_enough_memory
c_func
(paren
r_int
id|pages
)paren
(brace
multiline_comment|/* Stupid algorithm to decide if we have enough memory: while&n;&t; * simple, it hopefully works in most obvious cases.. Easy to&n;&t; * fool it, but this should catch most mistakes.&n;&t; */
r_int
id|freepages
suffix:semicolon
multiline_comment|/* Sometimes we want to use more memory than we have. */
r_if
c_cond
(paren
id|sysctl_overcommit_memory
)paren
r_return
l_int|1
suffix:semicolon
id|freepages
op_assign
id|buffermem
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|freepages
op_add_assign
id|page_cache_size
suffix:semicolon
id|freepages
op_rshift_assign
l_int|1
suffix:semicolon
id|freepages
op_add_assign
id|nr_free_pages
suffix:semicolon
id|freepages
op_add_assign
id|nr_swap_pages
suffix:semicolon
id|freepages
op_sub_assign
id|num_physpages
op_rshift
l_int|4
suffix:semicolon
r_return
id|freepages
OG
id|pages
suffix:semicolon
)brace
multiline_comment|/* Remove one vm structure from the inode&squot;s i_mmap ring. */
DECL|function|remove_shared_vm_struct
r_static
r_inline
r_void
id|remove_shared_vm_struct
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_next_share
)paren
(brace
id|vma-&gt;vm_next_share-&gt;vm_pprev_share
op_assign
id|vma-&gt;vm_pprev_share
suffix:semicolon
)brace
op_star
id|vma-&gt;vm_pprev_share
op_assign
id|vma-&gt;vm_next_share
suffix:semicolon
)brace
)brace
DECL|function|sys_brk
id|asmlinkage
r_int
r_int
id|sys_brk
c_func
(paren
r_int
r_int
id|brk
)paren
(brace
r_int
r_int
id|rlim
comma
id|retval
suffix:semicolon
r_int
r_int
id|newbrk
comma
id|oldbrk
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brk
OL
id|mm-&gt;end_code
)paren
r_goto
id|out
suffix:semicolon
id|newbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|brk
)paren
suffix:semicolon
id|oldbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mm-&gt;brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldbrk
op_eq
id|newbrk
)paren
r_goto
id|set_brk
suffix:semicolon
multiline_comment|/* Always allow shrinking brk. */
r_if
c_cond
(paren
id|brk
op_le
id|mm-&gt;brk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_munmap
c_func
(paren
id|newbrk
comma
id|oldbrk
op_minus
id|newbrk
)paren
)paren
r_goto
id|set_brk
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Check against rlimit and stack.. */
id|rlim
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_DATA
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|rlim
template_param
id|rlim
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check against existing mmap mappings. */
r_if
c_cond
(paren
id|find_vma_intersection
c_func
(paren
id|mm
comma
id|oldbrk
comma
id|newbrk
op_plus
id|PAGE_SIZE
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check if we have enough memory.. */
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
(paren
id|newbrk
op_minus
id|oldbrk
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Ok, looks good - let it rip. */
r_if
c_cond
(paren
id|do_mmap
c_func
(paren
l_int|NULL
comma
id|oldbrk
comma
id|newbrk
op_minus
id|oldbrk
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
id|MAP_FIXED
op_or
id|MAP_PRIVATE
comma
l_int|0
)paren
op_ne
id|oldbrk
)paren
r_goto
id|out
suffix:semicolon
id|set_brk
suffix:colon
id|mm-&gt;brk
op_assign
id|brk
suffix:semicolon
id|out
suffix:colon
id|retval
op_assign
id|mm-&gt;brk
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Combine the mmap &quot;prot&quot; and &quot;flags&quot; argument into one &quot;vm_flags&quot; used&n; * internally. Essentially, translate the &quot;PROT_xxx&quot; and &quot;MAP_xxx&quot; bits&n; * into &quot;VM_xxx&quot;.&n; */
DECL|function|vm_flags
r_static
r_inline
r_int
r_int
id|vm_flags
c_func
(paren
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
)paren
(brace
DECL|macro|_trans
mdefine_line|#define _trans(x,bit1,bit2) &bslash;&n;((bit1==bit2)?(x&amp;bit1):(x&amp;bit1)?bit2:0)
r_int
r_int
id|prot_bits
comma
id|flag_bits
suffix:semicolon
id|prot_bits
op_assign
id|_trans
c_func
(paren
id|prot
comma
id|PROT_READ
comma
id|VM_READ
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_WRITE
comma
id|VM_WRITE
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_EXEC
comma
id|VM_EXEC
)paren
suffix:semicolon
id|flag_bits
op_assign
id|_trans
c_func
(paren
id|flags
comma
id|MAP_GROWSDOWN
comma
id|VM_GROWSDOWN
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_DENYWRITE
comma
id|VM_DENYWRITE
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_EXECUTABLE
comma
id|VM_EXECUTABLE
)paren
suffix:semicolon
r_return
id|prot_bits
op_or
id|flag_bits
suffix:semicolon
DECL|macro|_trans
macro_line|#undef _trans
)brace
DECL|function|do_mmap
r_int
r_int
id|do_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|off
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
id|correct_wcount
op_assign
l_int|0
comma
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
op_logical_or
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* offset overflow? */
r_if
c_cond
(paren
id|off
op_plus
id|len
OL
id|off
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Too many mappings? */
r_if
c_cond
(paren
id|mm-&gt;map_count
OG
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* mlock MCL_FUTURE? */
r_if
c_cond
(paren
id|mm-&gt;def_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
op_assign
id|mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Do simple checking here so the lower-level routines won&squot;t have&n;&t; * to. we assume access permissions have been handled by the open&n;&t; * of the memory object, so we don&squot;t do any here.&n;&t; */
r_if
c_cond
(paren
id|file
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_case
id|MAP_SHARED
suffix:colon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* make sure there are no mandatory locks on the file. */
r_if
c_cond
(paren
id|locks_verify_locked
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MAP_PRIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|1
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
op_ne
id|MAP_PRIVATE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Obtain the address to map to. we verify (or select) it and ensure&n;&t; * that it represents a valid section of the address space.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_FIXED
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
id|get_unmapped_area
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Determine the object being mapped and call the appropriate&n;&t; * specific mapper. the address has already been validated, but&n;&t; * not unmapped, but the maps are removed from the list.&n;&t; */
r_if
c_cond
(paren
id|file
op_logical_and
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|vm_flags
c_func
(paren
id|prot
comma
id|flags
)paren
op_or
id|mm-&gt;def_flags
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
l_int|1
)paren
id|vma-&gt;vm_flags
op_or_assign
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
(brace
id|vma-&gt;vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
multiline_comment|/* This looks strange, but when we don&squot;t have the file open&n;&t;&t;&t; * for writing, we can demote the shared mapping to a simpler&n;&t;&t;&t; * private mapping. That also takes care of a security hole&n;&t;&t;&t; * with ptrace() writing to a shared mapping without write&n;&t;&t;&t; * permissions.&n;&t;&t;&t; *&n;&t;&t;&t; * We leave the VM_MAYSHARE bit on, just to get correct output&n;&t;&t;&t; * from /proc/xxx/maps..&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
)paren
id|vma-&gt;vm_flags
op_and_assign
op_complement
(paren
id|VM_MAYWRITE
op_or
id|VM_SHARED
)paren
suffix:semicolon
)brace
)brace
r_else
id|vma-&gt;vm_flags
op_or_assign
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|vma-&gt;vm_flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_offset
op_assign
id|off
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pte
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear old maps */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|do_munmap
c_func
(paren
id|addr
comma
id|len
)paren
)paren
r_goto
id|free_vma
suffix:semicolon
multiline_comment|/* Check against address space limit. */
r_if
c_cond
(paren
(paren
id|mm-&gt;total_vm
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|len
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_goto
id|free_vma
suffix:semicolon
multiline_comment|/* Private writable mapping? Check memory availability.. */
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_SHARED
op_or
id|VM_WRITE
)paren
)paren
op_eq
id|VM_WRITE
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|MAP_NORESERVE
)paren
op_logical_and
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_goto
id|free_vma
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
OG
l_int|0
)paren
id|error
op_assign
op_minus
id|ETXTBSY
suffix:semicolon
r_else
(brace
multiline_comment|/* f_op-&gt;mmap might possibly sleep&n;&t;&t;&t;&t; * (generic_file_mmap doesn&squot;t, but other code&n;&t;&t;&t;&t; * might). In any case, this takes care of any&n;&t;&t;&t;&t; * race that this might cause.&n;&t;&t;&t;&t; */
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
op_decrement
suffix:semicolon
id|correct_wcount
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
)brace
multiline_comment|/* Fix up the count if necessary, then check for an error */
r_if
c_cond
(paren
id|correct_wcount
)paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|free_vma
suffix:semicolon
multiline_comment|/*&n;&t; * merge_segments may merge our vma, so we can&squot;t refer to it&n;&t; * after the call.  Save the values we need now ...&n;&t; */
id|flags
op_assign
id|vma-&gt;vm_flags
suffix:semicolon
id|addr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
multiline_comment|/* can addr have changed?? */
id|insert_vm_struct
c_func
(paren
id|mm
comma
id|vma
)paren
suffix:semicolon
id|merge_segments
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|VM_LOCKED
)paren
(brace
id|mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|make_pages_present
c_func
(paren
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
id|free_vma
suffix:colon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Get an address range which is currently unmapped.&n; * For mmap() without MAP_FIXED and shmat() with addr=0.&n; * Return value 0 means ENOMEM.&n; */
DECL|function|get_unmapped_area
r_int
r_int
id|get_unmapped_area
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vmm
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
id|addr
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vmm
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|addr
)paren
suffix:semicolon
suffix:semicolon
id|vmm
op_assign
id|vmm-&gt;vm_next
)paren
(brace
multiline_comment|/* At this point:  (!vmm || addr &lt; vmm-&gt;vm_end). */
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
OL
id|addr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vmm
op_logical_or
id|addr
op_plus
id|len
op_le
id|vmm-&gt;vm_start
)paren
r_return
id|addr
suffix:semicolon
id|addr
op_assign
id|vmm-&gt;vm_end
suffix:semicolon
)brace
)brace
multiline_comment|/* Normal function to fix up a mapping&n; * This function is the default for when an area has no specific&n; * function.  This may be used as part of a more specific routine.&n; * This function works out what part of an area is affected and&n; * adjusts the mapping information.  Since the actual page&n; * manipulation is done in do_mmap(), none need be done here,&n; * though it would probably be more appropriate.&n; *&n; * By the time this function is called, the area struct has been&n; * removed from the process mapping list, so it needs to be&n; * reinserted if necessary.&n; *&n; * The 4 main cases are:&n; *    Unmapping the whole area&n; *    Unmapping from the start of the segment to a point in it&n; *    Unmapping from an intermediate point to the end&n; *    Unmapping between to intermediate points, making a hole.&n; *&n; * Case 4 involves the creation of 2 new areas, for each side of&n; * the hole.  If possible, we reuse the existing area rather than&n; * allocate a new one, and the return indicates whether the old&n; * area was reused.&n; */
DECL|function|unmap_fixup
r_static
r_int
id|unmap_fixup
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|addr
comma
r_int
id|len
comma
r_struct
id|vm_area_struct
op_star
op_star
id|extra
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|area-&gt;vm_mm-&gt;total_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|area-&gt;vm_mm-&gt;locked_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Unmapping the whole area. */
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
op_logical_and
id|end
op_eq
id|area-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;close
)paren
id|area-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|area
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_file
)paren
id|fput
c_func
(paren
id|area-&gt;vm_file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Work out to one of the ends. */
r_if
c_cond
(paren
id|end
op_eq
id|area-&gt;vm_end
)paren
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
)paren
(brace
id|area-&gt;vm_offset
op_add_assign
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
suffix:semicolon
id|area-&gt;vm_start
op_assign
id|end
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unmapping a hole: area-&gt;vm_start &lt; addr &lt;= end &lt; area-&gt;vm_end */
multiline_comment|/* Add end mapping -- leave beginning for below */
id|mpnt
op_assign
op_star
id|extra
suffix:semicolon
op_star
id|extra
op_assign
l_int|NULL
suffix:semicolon
id|mpnt-&gt;vm_mm
op_assign
id|area-&gt;vm_mm
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|end
suffix:semicolon
id|mpnt-&gt;vm_end
op_assign
id|area-&gt;vm_end
suffix:semicolon
id|mpnt-&gt;vm_page_prot
op_assign
id|area-&gt;vm_page_prot
suffix:semicolon
id|mpnt-&gt;vm_flags
op_assign
id|area-&gt;vm_flags
suffix:semicolon
id|mpnt-&gt;vm_ops
op_assign
id|area-&gt;vm_ops
suffix:semicolon
id|mpnt-&gt;vm_offset
op_assign
id|area-&gt;vm_offset
op_plus
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
suffix:semicolon
id|mpnt-&gt;vm_file
op_assign
id|area-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_file
)paren
id|mpnt-&gt;vm_file-&gt;f_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;open
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Truncate area */
id|insert_vm_struct
c_func
(paren
id|current-&gt;mm
comma
id|mpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Close the current area ... */
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;close
)paren
(brace
id|end
op_assign
id|area-&gt;vm_end
suffix:semicolon
multiline_comment|/* save new end */
id|area-&gt;vm_end
op_assign
id|area-&gt;vm_start
suffix:semicolon
id|area-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|area
)paren
suffix:semicolon
id|area-&gt;vm_end
op_assign
id|end
suffix:semicolon
)brace
multiline_comment|/* ... then reopen and reinsert. */
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;open
)paren
id|area-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|area
)paren
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|current-&gt;mm
comma
id|area
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Munmap is split into 2 main parts -- this part which finds&n; * what needs doing, and the areas themselves, which do the&n; * work.  This now handles partial unmappings.&n; * Jeremy Fitzhardine &lt;jeremy@sw.oz.au&gt;&n; */
DECL|function|do_munmap
r_int
id|do_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
op_star
id|free
comma
op_star
id|extra
suffix:semicolon
r_int
id|freed
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|addr
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_minus
id|addr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Check if this memory area is ok - put it on the temporary&n;&t; * list if so..  The checks here are pretty simple --&n;&t; * every area affected in some way (by any overlap) is put&n;&t; * on the list.  If nothing is put on, nothing is affected.&n;&t; */
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|mpnt
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|mpnt
op_logical_and
id|mpnt-&gt;vm_end
op_le
id|addr
)paren
(brace
id|mpnt
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If we&squot;ll make &quot;hole&quot;, check the vm areas limit */
r_if
c_cond
(paren
(paren
id|mpnt-&gt;vm_start
template_param
id|addr
op_plus
id|len
)paren
op_logical_and
id|mm-&gt;map_count
OG
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * We may need one additional vma to fix up the mappings ... &n;&t; * and this is the last chance for an easy error exit.&n;&t; */
id|extra
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|extra
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* we have addr &lt; mpnt-&gt;vm_end */
id|free
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|mpnt
op_logical_and
id|mpnt-&gt;vm_start
OL
id|addr
op_plus
id|len
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_next
)paren
(brace
id|mpnt-&gt;vm_next-&gt;vm_pprev
op_assign
id|mpnt-&gt;vm_pprev
suffix:semicolon
)brace
op_star
id|mpnt-&gt;vm_pprev
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|mpnt-&gt;vm_next
op_assign
id|free
suffix:semicolon
id|free
op_assign
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* Ok - we have the memory areas we should free on the &squot;free&squot; list,&n;&t; * so release them, and unmap the page range..&n;&t; * If the one of the segments is only being partially unmapped,&n;&t; * it will put new vm_area_struct(s) into the address space.&n;&t; */
id|freed
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mpnt
op_assign
id|free
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|st
comma
id|end
comma
id|size
suffix:semicolon
id|free
op_assign
id|free-&gt;vm_next
suffix:semicolon
id|freed
op_assign
l_int|1
suffix:semicolon
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|st
op_assign
id|addr
OL
id|mpnt-&gt;vm_start
ques
c_cond
id|mpnt-&gt;vm_start
suffix:colon
id|addr
suffix:semicolon
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|end
op_assign
id|end
OG
id|mpnt-&gt;vm_end
ques
c_cond
id|mpnt-&gt;vm_end
suffix:colon
id|end
suffix:semicolon
id|size
op_assign
id|end
op_minus
id|st
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;unmap
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|unmap
c_func
(paren
id|mpnt
comma
id|st
comma
id|size
)paren
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|mm
comma
id|st
comma
id|end
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|mm
comma
id|st
comma
id|size
)paren
suffix:semicolon
id|flush_tlb_range
c_func
(paren
id|mm
comma
id|st
comma
id|end
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fix the mapping, and free the old area if it wasn&squot;t reused.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|unmap_fixup
c_func
(paren
id|mpnt
comma
id|st
comma
id|size
comma
op_amp
id|extra
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|mpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Release the extra vma struct if it wasn&squot;t used */
r_if
c_cond
(paren
id|extra
)paren
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|extra
)paren
suffix:semicolon
r_if
c_cond
(paren
id|freed
)paren
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Kill the cache. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_munmap
id|asmlinkage
r_int
id|sys_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|do_munmap
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Release all mmaps. */
DECL|function|exit_mmap
r_void
id|exit_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|mm-&gt;mmap
op_assign
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;total_vm
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;locked_vm
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|mpnt
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
r_int
r_int
id|start
op_assign
id|mpnt-&gt;vm_start
suffix:semicolon
r_int
r_int
id|end
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
r_int
r_int
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
)paren
(brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops-&gt;unmap
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|unmap
c_func
(paren
id|mpnt
comma
id|start
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops-&gt;close
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|mm
comma
id|start
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_file
)paren
id|fput
c_func
(paren
id|mpnt-&gt;vm_file
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* This is just debugging */
r_if
c_cond
(paren
id|mm-&gt;map_count
)paren
id|printk
c_func
(paren
l_string|&quot;exit_mmap: map count is %d&bslash;n&quot;
comma
id|mm-&gt;map_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert vm structure into process list sorted by address&n; * and into the inode&squot;s i_mmap ring.&n; */
DECL|function|insert_vm_struct
r_void
id|insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vmp
)paren
(brace
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
op_assign
op_amp
id|mm-&gt;mmap
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
id|mm-&gt;map_count
op_increment
suffix:semicolon
multiline_comment|/* Find where to link it in. */
r_while
c_loop
(paren
op_star
id|pprev
op_logical_and
(paren
op_star
id|pprev
)paren
op_member_access_from_pointer
id|vm_start
op_le
id|vmp-&gt;vm_start
)paren
(brace
id|pprev
op_assign
op_amp
(paren
op_star
id|pprev
)paren
op_member_access_from_pointer
id|vm_next
suffix:semicolon
)brace
multiline_comment|/* Insert it. */
r_if
c_cond
(paren
(paren
id|vmp-&gt;vm_next
op_assign
op_star
id|pprev
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|pprev
)paren
op_member_access_from_pointer
id|vm_pprev
op_assign
op_amp
id|vmp-&gt;vm_next
suffix:semicolon
)brace
op_star
id|pprev
op_assign
id|vmp
suffix:semicolon
id|vmp-&gt;vm_pprev
op_assign
id|pprev
suffix:semicolon
id|file
op_assign
id|vmp-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|vmp-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|inode-&gt;i_writecount
op_decrement
suffix:semicolon
multiline_comment|/* insert vmp into inode&squot;s share list */
r_if
c_cond
(paren
(paren
id|vmp-&gt;vm_next_share
op_assign
id|inode-&gt;i_mmap
)paren
op_ne
l_int|NULL
)paren
(brace
id|inode-&gt;i_mmap-&gt;vm_pprev_share
op_assign
op_amp
id|vmp-&gt;vm_next_share
suffix:semicolon
)brace
id|inode-&gt;i_mmap
op_assign
id|vmp
suffix:semicolon
id|vmp-&gt;vm_pprev_share
op_assign
op_amp
id|inode-&gt;i_mmap
suffix:semicolon
)brace
)brace
multiline_comment|/* Merge the list of memory segments if possible.&n; * Redundant vm_area_structs are freed.&n; * This assumes that the list is ordered by address.&n; * We don&squot;t need to traverse the entire list, only those segments&n; * which intersect or are adjacent to a given interval.&n; *&n; * We must already hold the mm semaphore when we get here..&n; */
DECL|function|merge_segments
r_void
id|merge_segments
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start_addr
comma
r_int
r_int
id|end_addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|prev
comma
op_star
id|mpnt
comma
op_star
id|next
suffix:semicolon
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|mpnt
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|mpnt
op_logical_and
id|mpnt-&gt;vm_end
op_le
id|start_addr
)paren
(brace
id|prev
op_assign
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
suffix:semicolon
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
multiline_comment|/* we have prev-&gt;vm_next == mpnt &amp;&amp; mpnt-&gt;vm_next = next */
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|prev
op_assign
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* prev and mpnt cycle through the list, as long as&n;&t; * start_addr &lt; mpnt-&gt;vm_end &amp;&amp; prev-&gt;vm_start &lt; end_addr&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|mpnt
op_logical_and
id|prev-&gt;vm_start
OL
id|end_addr
suffix:semicolon
id|prev
op_assign
id|mpnt
comma
id|mpnt
op_assign
id|next
)paren
(brace
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
multiline_comment|/* To share, we must have the same file, operations.. */
r_if
c_cond
(paren
(paren
id|mpnt-&gt;vm_file
op_ne
id|prev-&gt;vm_file
)paren
op_logical_or
(paren
id|mpnt-&gt;vm_pte
op_ne
id|prev-&gt;vm_pte
)paren
op_logical_or
(paren
id|mpnt-&gt;vm_ops
op_ne
id|prev-&gt;vm_ops
)paren
op_logical_or
(paren
id|mpnt-&gt;vm_flags
op_ne
id|prev-&gt;vm_flags
)paren
op_logical_or
(paren
id|prev-&gt;vm_end
op_ne
id|mpnt-&gt;vm_start
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we have a file or it&squot;s a shared memory area&n;&t;&t; * the offsets must be contiguous..&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mpnt-&gt;vm_file
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_SHM
)paren
)paren
(brace
r_int
r_int
id|off
op_assign
id|prev-&gt;vm_offset
op_plus
id|prev-&gt;vm_end
op_minus
id|prev-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ne
id|mpnt-&gt;vm_offset
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/* merge prev with mpnt and set up pointers so the new&n;&t;&t; * big segment can possibly merge with the next one.&n;&t;&t; * The old unused mpnt is freed.&n;&t;&t; */
r_if
c_cond
(paren
id|mpnt-&gt;vm_next
)paren
(brace
id|mpnt-&gt;vm_next-&gt;vm_pprev
op_assign
id|mpnt-&gt;vm_pprev
suffix:semicolon
)brace
op_star
id|mpnt-&gt;vm_pprev
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|prev-&gt;vm_end
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;close
)paren
(brace
id|mpnt-&gt;vm_offset
op_add_assign
id|mpnt-&gt;vm_end
op_minus
id|mpnt-&gt;vm_start
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_file
)paren
id|fput
c_func
(paren
id|mpnt-&gt;vm_file
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|prev
suffix:semicolon
)brace
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Kill the cache. */
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|vma_init
c_func
(paren
r_void
)paren
)paren
(brace
id|vm_area_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;vm_area_struct&quot;
comma
r_sizeof
(paren
r_struct
id|vm_area_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_area_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;vma_init: Cannot alloc vm_area_struct cache.&quot;
)paren
suffix:semicolon
)brace
id|mm_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;mm_struct&quot;
comma
r_sizeof
(paren
r_struct
id|mm_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;vma_init: Cannot alloc mm_struct cache.&quot;
)paren
suffix:semicolon
)brace
)brace
eof
