multiline_comment|/*&n; *&t;linux/mm/mmap.c&n; *&n; * Written by obz.&n; */
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
r_static
r_int
id|anon_map
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * description of effects of mapping type and prot in current implementation.&n; * this is due to the limited x86 page protection hardware.  The expected&n; * behavior is in parens:&n; *&n; * map_type&t;prot&n; *&t;&t;PROT_NONE&t;PROT_READ&t;PROT_WRITE&t;PROT_EXEC&n; * MAP_SHARED&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (yes) yes&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&t;&t;&n; * MAP_PRIVATE&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (copy) copy&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&n; */
DECL|function|do_mmap
r_int
id|do_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|off
)paren
(brace
r_int
id|mask
comma
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_logical_or
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * do simple checking here so the lower-level routines won&squot;t have&n;&t; * to. we assume access permissions have been handled by the open&n;&t; * of the memory object, so we don&squot;t do any here.&n;&t; */
r_if
c_cond
(paren
id|file
op_ne
l_int|NULL
)paren
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_case
id|MAP_SHARED
suffix:colon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MAP_PRIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|1
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * obtain the address to map to. we verify (or select) it and ensure&n;&t; * that it represents a valid section of the address space.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_FIXED
)paren
(brace
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
op_logical_or
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_struct
id|vm_area_struct
op_star
id|vmm
suffix:semicolon
multiline_comment|/* Maybe this works.. Ugly it is. */
id|addr
op_assign
id|SHM_RANGE_START
suffix:semicolon
r_while
c_loop
(paren
id|addr
op_plus
id|len
OL
id|SHM_RANGE_END
)paren
(brace
r_for
c_loop
(paren
id|vmm
op_assign
id|current-&gt;mm-&gt;mmap
suffix:semicolon
id|vmm
suffix:semicolon
id|vmm
op_assign
id|vmm-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
id|addr
op_ge
id|vmm-&gt;vm_end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_plus
id|len
op_le
id|vmm-&gt;vm_start
)paren
r_continue
suffix:semicolon
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|vmm-&gt;vm_end
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vmm
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
op_plus
id|len
op_ge
id|SHM_RANGE_END
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * determine the object being mapped and call the appropriate&n;&t; * specific mapper. the address has already been validated, but&n;&t; * not unmapped, but the maps are removed from the list.&n;&t; */
r_if
c_cond
(paren
id|file
op_logical_and
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prot
op_amp
(paren
id|PROT_READ
op_or
id|PROT_EXEC
)paren
)paren
id|mask
op_or_assign
id|PAGE_READONLY
suffix:semicolon
r_if
c_cond
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
op_eq
id|MAP_PRIVATE
)paren
id|mask
op_or_assign
id|PAGE_COPY
suffix:semicolon
r_else
id|mask
op_or_assign
id|PAGE_SHARED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
multiline_comment|/* PROT_NONE */
id|mask
op_assign
id|PAGE_PRESENT
suffix:semicolon
multiline_comment|/* none of PAGE_USER, PAGE_RW, PAGE_COW */
id|do_munmap
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Clear old maps */
r_if
c_cond
(paren
id|file
)paren
id|error
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file-&gt;f_inode
comma
id|file
comma
id|addr
comma
id|len
comma
id|mask
comma
id|off
)paren
suffix:semicolon
r_else
id|error
op_assign
id|anon_map
c_func
(paren
l_int|NULL
comma
l_int|NULL
comma
id|addr
comma
id|len
comma
id|mask
comma
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;errno
)paren
id|current-&gt;errno
op_assign
op_minus
id|error
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|sys_mmap
id|asmlinkage
r_int
id|sys_mmap
c_func
(paren
r_int
r_int
op_star
id|buffer
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
l_int|6
op_star
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|flags
op_assign
id|get_fs_long
c_func
(paren
id|buffer
op_plus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MAP_ANONYMOUS
)paren
)paren
(brace
r_int
r_int
id|fd
op_assign
id|get_fs_long
c_func
(paren
id|buffer
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
id|NR_OPEN
op_logical_or
op_logical_neg
(paren
id|file
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
r_return
id|do_mmap
c_func
(paren
id|file
comma
id|get_fs_long
c_func
(paren
id|buffer
)paren
comma
id|get_fs_long
c_func
(paren
id|buffer
op_plus
l_int|1
)paren
comma
id|get_fs_long
c_func
(paren
id|buffer
op_plus
l_int|2
)paren
comma
id|flags
comma
id|get_fs_long
c_func
(paren
id|buffer
op_plus
l_int|5
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Normal function to fix up a mapping&n; * This function is the default for when an area has no specific&n; * function.  This may be used as part of a more specific routine.&n; * This function works out what part of an area is affected and&n; * adjusts the mapping information.  Since the actual page&n; * manipulation is done in do_mmap(), none need be done here,&n; * though it would probably be more appropriate.&n; *&n; * By the time this function is called, the area struct has been&n; * removed from the process mapping list, so it needs to be&n; * reinserted if necessary.&n; *&n; * The 4 main cases are:&n; *    Unmapping the whole area&n; *    Unmapping from the start of the segment to a point in it&n; *    Unmapping from an intermediate point to the end&n; *    Unmapping between to intermediate points, making a hole.&n; *&n; * Case 4 involves the creation of 2 new areas, for each side of&n; * the hole.&n; */
DECL|function|unmap_fixup
r_void
id|unmap_fixup
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|addr
template_param
id|area-&gt;vm_end
op_logical_or
id|end
OL
id|addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unmap_fixup: area=%lx-%lx, unmap %lx-%lx!!&bslash;n&quot;
comma
id|area-&gt;vm_start
comma
id|area-&gt;vm_end
comma
id|addr
comma
id|end
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Unmapping the whole area */
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
op_logical_and
id|end
op_eq
id|area-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;close
)paren
id|area-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|area
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_inode
)paren
id|iput
c_func
(paren
id|area-&gt;vm_inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Work out to one of the ends */
r_if
c_cond
(paren
id|addr
op_ge
id|area-&gt;vm_start
op_logical_and
id|end
op_eq
id|area-&gt;vm_end
)paren
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
id|area-&gt;vm_start
op_logical_and
id|end
op_le
id|area-&gt;vm_end
)paren
(brace
id|area-&gt;vm_offset
op_add_assign
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
suffix:semicolon
id|area-&gt;vm_start
op_assign
id|end
suffix:semicolon
)brace
multiline_comment|/* Unmapping a hole */
r_if
c_cond
(paren
id|addr
OG
id|area-&gt;vm_start
op_logical_and
id|end
OL
id|area-&gt;vm_end
)paren
(brace
multiline_comment|/* Add end mapping -- leave beginning for below */
id|mpnt
op_assign
(paren
r_struct
id|vm_area_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mpnt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
op_star
id|mpnt
op_assign
op_star
id|area
suffix:semicolon
id|mpnt-&gt;vm_offset
op_add_assign
(paren
id|end
op_minus
id|area-&gt;vm_start
)paren
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_inode
)paren
id|mpnt-&gt;vm_inode-&gt;i_count
op_increment
suffix:semicolon
id|area-&gt;vm_end
op_assign
id|addr
suffix:semicolon
multiline_comment|/* Truncate area */
id|insert_vm_struct
c_func
(paren
id|current
comma
id|mpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* construct whatever mapping is needed */
id|mpnt
op_assign
(paren
r_struct
id|vm_area_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mpnt
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
op_star
id|mpnt
op_assign
op_star
id|area
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|current
comma
id|mpnt
)paren
suffix:semicolon
)brace
DECL|function|sys_mprotect
id|asmlinkage
r_int
id|sys_mprotect
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
comma
r_int
r_int
id|prot
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Not implemented yet */
)brace
DECL|function|sys_munmap
id|asmlinkage
r_int
id|sys_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_return
id|do_munmap
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Munmap is split into 2 main parts -- this part which finds&n; * what needs doing, and the areas themselves, which do the&n; * work.  This now handles partial unmappings.&n; * Jeremy Fitzhardine &lt;jeremy@sw.oz.au&gt;&n; */
DECL|function|do_munmap
r_int
id|do_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
op_star
op_star
id|npp
comma
op_star
id|free
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|addr
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_minus
id|addr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Check if this memory area is ok - put it on the temporary&n;&t; * list if so..  The checks here are pretty simple --&n;&t; * every area affected in some way (by any overlap) is put&n;&t; * on the list.  If nothing is put on, nothing is affected.&n;&t; */
id|npp
op_assign
op_amp
id|current-&gt;mm-&gt;mmap
suffix:semicolon
id|free
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|mpnt
op_assign
op_star
id|npp
suffix:semicolon
id|mpnt
op_ne
l_int|NULL
suffix:semicolon
id|mpnt
op_assign
op_star
id|npp
)paren
(brace
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
OL
id|mpnt-&gt;vm_start
op_logical_and
id|end
op_le
id|mpnt-&gt;vm_start
)paren
op_logical_or
(paren
id|addr
op_ge
id|mpnt-&gt;vm_end
op_logical_and
id|end
OG
id|mpnt-&gt;vm_end
)paren
)paren
(brace
id|npp
op_assign
op_amp
id|mpnt-&gt;vm_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|npp
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|mpnt-&gt;vm_next
op_assign
id|free
suffix:semicolon
id|free
op_assign
id|mpnt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Ok - we have the memory areas we should free on the &squot;free&squot; list,&n;&t; * so release them, and unmap the page range..&n;&t; * If the one of the segments is only being partially unmapped,&n;&t; * it will put new vm_area_struct(s) into the address space.&n;&t; */
r_while
c_loop
(paren
id|free
)paren
(brace
r_int
r_int
id|st
comma
id|end
suffix:semicolon
id|mpnt
op_assign
id|free
suffix:semicolon
id|free
op_assign
id|free-&gt;vm_next
suffix:semicolon
id|st
op_assign
id|addr
OL
id|mpnt-&gt;vm_start
ques
c_cond
id|mpnt-&gt;vm_start
suffix:colon
id|addr
suffix:semicolon
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|end
op_assign
id|end
OG
id|mpnt-&gt;vm_end
ques
c_cond
id|mpnt-&gt;vm_end
suffix:colon
id|end
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
op_logical_and
id|mpnt-&gt;vm_ops-&gt;unmap
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|unmap
c_func
(paren
id|mpnt
comma
id|st
comma
id|end
op_minus
id|st
)paren
suffix:semicolon
r_else
id|unmap_fixup
c_func
(paren
id|mpnt
comma
id|st
comma
id|end
op_minus
id|st
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
id|unmap_page_range
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is used for a general mmap of a disk file */
DECL|function|generic_mmap
r_int
id|generic_mmap
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
id|len
comma
r_int
id|prot
comma
r_int
r_int
id|off
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
r_extern
r_struct
id|vm_operations_struct
id|file_mmap
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|prot
op_amp
id|PAGE_RW
)paren
multiline_comment|/* only PAGE_COW or read-only supported right now */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|off
op_amp
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;bmap
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|inode-&gt;i_dev
comma
id|bmap
c_func
(paren
id|inode
comma
l_int|0
)paren
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_RDONLY
c_func
(paren
id|inode
)paren
)paren
(brace
id|inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_dirt
op_assign
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mpnt
op_assign
(paren
r_struct
id|vm_area_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vm_area_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|unmap_page_range
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
id|mpnt-&gt;vm_task
op_assign
id|current
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|mpnt-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|mpnt-&gt;vm_page_prot
op_assign
id|prot
suffix:semicolon
id|mpnt-&gt;vm_flags
op_assign
l_int|0
suffix:semicolon
id|mpnt-&gt;vm_share
op_assign
l_int|NULL
suffix:semicolon
id|mpnt-&gt;vm_inode
op_assign
id|inode
suffix:semicolon
id|inode-&gt;i_count
op_increment
suffix:semicolon
id|mpnt-&gt;vm_offset
op_assign
id|off
suffix:semicolon
id|mpnt-&gt;vm_ops
op_assign
op_amp
id|file_mmap
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|current
comma
id|mpnt
)paren
suffix:semicolon
id|merge_segments
c_func
(paren
id|current-&gt;mm-&gt;mmap
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert vm structure into process list&n; * This makes sure the list is sorted by start address, and&n; * some some simple overlap checking.&n; * JSGF&n; */
DECL|function|insert_vm_struct
r_void
id|insert_vm_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|t
comma
r_struct
id|vm_area_struct
op_star
id|vmp
)paren
(brace
r_struct
id|vm_area_struct
op_star
op_star
id|nxtpp
comma
op_star
id|mpnt
suffix:semicolon
id|nxtpp
op_assign
op_amp
id|t-&gt;mm-&gt;mmap
suffix:semicolon
r_for
c_loop
(paren
id|mpnt
op_assign
id|t-&gt;mm-&gt;mmap
suffix:semicolon
id|mpnt
op_ne
l_int|NULL
suffix:semicolon
id|mpnt
op_assign
id|mpnt-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_start
OG
id|vmp-&gt;vm_start
)paren
r_break
suffix:semicolon
id|nxtpp
op_assign
op_amp
id|mpnt-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vmp-&gt;vm_start
op_ge
id|mpnt-&gt;vm_start
op_logical_and
id|vmp-&gt;vm_start
OL
id|mpnt-&gt;vm_end
)paren
op_logical_or
(paren
id|vmp-&gt;vm_end
op_ge
id|mpnt-&gt;vm_start
op_logical_and
id|vmp-&gt;vm_end
OL
id|mpnt-&gt;vm_end
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;insert_vm_struct: ins area %lx-%lx in area %lx-%lx&bslash;n&quot;
comma
id|vmp-&gt;vm_start
comma
id|vmp-&gt;vm_end
comma
id|mpnt-&gt;vm_start
comma
id|vmp-&gt;vm_end
)paren
suffix:semicolon
)brace
id|vmp-&gt;vm_next
op_assign
id|mpnt
suffix:semicolon
op_star
id|nxtpp
op_assign
id|vmp
suffix:semicolon
)brace
multiline_comment|/*&n; * Merge a list of memory segments if possible.&n; * Redundant vm_area_structs are freed.&n; * This assumes that the list is ordered by address.&n; */
DECL|function|merge_segments
r_void
id|merge_segments
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
id|map_mergep_fnp
id|mergep
comma
r_void
op_star
id|mpd
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|mpnt
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
id|mpnt
comma
id|mpnt
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|mpnt
op_ne
l_int|NULL
suffix:semicolon
id|prev
op_assign
id|mpnt
comma
id|mpnt
op_assign
id|next
)paren
(brace
r_int
id|mp
suffix:semicolon
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|mergep
op_eq
l_int|NULL
)paren
(brace
r_int
r_int
id|psz
op_assign
id|prev-&gt;vm_end
op_minus
id|prev-&gt;vm_start
suffix:semicolon
id|mp
op_assign
id|prev-&gt;vm_offset
op_plus
id|psz
op_eq
id|mpnt-&gt;vm_offset
suffix:semicolon
)brace
r_else
id|mp
op_assign
(paren
op_star
id|mergep
)paren
(paren
id|prev
comma
id|mpnt
comma
id|mpd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check they are compatible.&n;&t;&t; * and the like...&n;&t;&t; * What does the share pointer mean?&n;&t;&t; */
r_if
c_cond
(paren
id|prev-&gt;vm_ops
op_ne
id|mpnt-&gt;vm_ops
op_logical_or
id|prev-&gt;vm_page_prot
op_ne
id|mpnt-&gt;vm_page_prot
op_logical_or
id|prev-&gt;vm_inode
op_ne
id|mpnt-&gt;vm_inode
op_logical_or
id|prev-&gt;vm_end
op_ne
id|mpnt-&gt;vm_start
op_logical_or
op_logical_neg
id|mp
op_logical_or
id|prev-&gt;vm_flags
op_ne
id|mpnt-&gt;vm_flags
op_logical_or
id|prev-&gt;vm_share
op_ne
id|mpnt-&gt;vm_share
op_logical_or
multiline_comment|/* ?? */
id|prev-&gt;vm_next
op_ne
id|mpnt
)paren
multiline_comment|/* !!! */
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * merge prev with mpnt and set up pointers so the new&n;&t;&t; * big segment can possibly merge with the next one.&n;&t;&t; * The old unused mpnt is freed.&n;&t;&t; */
id|prev-&gt;vm_end
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
id|prev-&gt;vm_next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|kfree_s
c_func
(paren
id|mpnt
comma
r_sizeof
(paren
op_star
id|mpnt
)paren
)paren
suffix:semicolon
id|mpnt
op_assign
id|prev
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Map memory not associated with any file into a process&n; * address space.  Adjecent memory is merged.&n; */
DECL|function|anon_map
r_static
r_int
id|anon_map
c_func
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
id|len
comma
r_int
id|mask
comma
r_int
r_int
id|off
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
r_if
c_cond
(paren
id|zeromap_page_range
c_func
(paren
id|addr
comma
id|len
comma
id|mask
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mpnt
op_assign
(paren
r_struct
id|vm_area_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vm_area_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mpnt-&gt;vm_task
op_assign
id|current
suffix:semicolon
id|mpnt-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|mpnt-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|mpnt-&gt;vm_page_prot
op_assign
id|mask
suffix:semicolon
id|mpnt-&gt;vm_flags
op_assign
l_int|0
suffix:semicolon
id|mpnt-&gt;vm_share
op_assign
l_int|NULL
suffix:semicolon
id|mpnt-&gt;vm_inode
op_assign
l_int|NULL
suffix:semicolon
id|mpnt-&gt;vm_offset
op_assign
l_int|0
suffix:semicolon
id|mpnt-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|current
comma
id|mpnt
)paren
suffix:semicolon
id|merge_segments
c_func
(paren
id|current-&gt;mm-&gt;mmap
comma
id|ignoff_mergep
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Merge, ignoring offsets */
DECL|function|ignoff_mergep
r_int
id|ignoff_mergep
c_func
(paren
r_const
r_struct
id|vm_area_struct
op_star
id|m1
comma
r_const
r_struct
id|vm_area_struct
op_star
id|m2
comma
r_void
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
id|m1-&gt;vm_inode
op_ne
id|m2-&gt;vm_inode
)paren
multiline_comment|/* Just to be sure */
r_return
l_int|0
suffix:semicolon
r_return
(paren
r_struct
id|inode
op_star
)paren
id|data
op_eq
id|m1-&gt;vm_inode
suffix:semicolon
)brace
eof
