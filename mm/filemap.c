multiline_comment|/*&n; *&t;linux/mm/filemap.c&n; *&n; * Copyright (C) 1994, 1995  Linus Torvalds&n; */
multiline_comment|/*&n; * This file handles the generic file mmap semantics used by&n; * most &quot;normal&quot; filesystems (but you don&squot;t /have/ to use this:&n; * the NFS filesystem used to do this differently, for example)&n; */
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * Shared mappings implemented 30.11.1994. It&squot;s not fully working yet,&n; * though.&n; *&n; * Shared mappings now work. 15.8.1995  Bruno.&n; */
DECL|variable|page_cache_size
r_int
r_int
id|page_cache_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|page_hash_table
r_struct
id|page
op_star
id|page_hash_table
(braket
id|PAGE_HASH_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n; * Simple routines for both non-shared and shared mappings.&n; */
DECL|macro|release_page
mdefine_line|#define release_page(page) __free_page((page))
multiline_comment|/*&n; * Invalidate the pages of an inode, removing all pages that aren&squot;t&n; * locked down (those are sure to be up-to-date anyway, so we shouldn&squot;t&n; * invalidate them).&n; */
DECL|function|invalidate_inode_pages
r_void
id|invalidate_inode_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|page
op_star
op_star
id|p
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|p
op_assign
op_amp
id|inode-&gt;i_pages
suffix:semicolon
r_while
c_loop
(paren
(paren
id|page
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|p
op_assign
op_amp
id|page-&gt;next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|inode-&gt;i_nrpages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|p
op_assign
id|page-&gt;next
)paren
op_ne
l_int|NULL
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|prev
op_assign
id|page-&gt;prev
suffix:semicolon
id|page-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|page-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|remove_page_from_hash_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;inode
op_assign
l_int|NULL
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Truncate the page cache at a set offset, removing the pages&n; * that are beyond that offset (and zeroing out partial pages).&n; */
DECL|function|truncate_inode_pages
r_void
id|truncate_inode_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|start
)paren
(brace
r_struct
id|page
op_star
op_star
id|p
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|repeat
suffix:colon
id|p
op_assign
op_amp
id|inode-&gt;i_pages
suffix:semicolon
r_while
c_loop
(paren
(paren
id|page
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|offset
op_assign
id|page-&gt;offset
suffix:semicolon
multiline_comment|/* page wholly truncated - free it */
r_if
c_cond
(paren
id|offset
op_ge
id|start
)paren
(brace
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|inode-&gt;i_nrpages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|p
op_assign
id|page-&gt;next
)paren
op_ne
l_int|NULL
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|prev
op_assign
id|page-&gt;prev
suffix:semicolon
id|page-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|page-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|remove_page_from_hash_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;inode
op_assign
l_int|NULL
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|page-&gt;next
suffix:semicolon
id|offset
op_assign
id|start
op_minus
id|offset
suffix:semicolon
multiline_comment|/* partial truncate, clear end of page */
r_if
c_cond
(paren
id|offset
OL
id|PAGE_SIZE
)paren
(brace
r_int
r_int
id|address
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|offset
op_plus
id|address
)paren
comma
l_int|0
comma
id|PAGE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|address
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Remove a page from the page cache and free it.&n; */
DECL|function|remove_inode_page
r_void
id|remove_inode_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|remove_page_from_hash_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_page_from_inode_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether we can free this page.&n; */
DECL|function|shrink_one_page
r_static
r_inline
r_int
id|shrink_one_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
comma
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|gfp_mask
op_amp
id|__GFP_DMA
)paren
op_logical_and
op_logical_neg
id|PageDMA
c_func
(paren
id|page
)paren
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* First of all, regenerate the page&squot;s referenced bit&n;         * from any buffers in the page&n;&t; */
id|bh
op_assign
id|page-&gt;buffers
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_touched
c_func
(paren
id|tmp
)paren
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_Touched
comma
op_amp
id|tmp-&gt;b_state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_referenced
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
multiline_comment|/* Refuse to swap out all buffer pages */
r_if
c_cond
(paren
id|buffer_under_min
c_func
(paren
)paren
)paren
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* We can&squot;t throw away shared pages, but we do mark&n;&t;   them as referenced.  This relies on the fact that&n;&t;   no page is currently in both the page cache and the&n;&t;   buffer cache; we&squot;d have to modify the following&n;&t;   test to allow for that case. */
r_switch
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* is it a swap-cache or page-cache page? */
r_if
c_cond
(paren
id|page-&gt;inode
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PG_referenced
comma
op_amp
id|page-&gt;flags
)paren
)paren
(brace
id|touch_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|age_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;age
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|pgcache_under_min
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* It&squot;s not a cache page, so we don&squot;t do aging.&n;&t;&t; * If it has been referenced recently, don&squot;t free it */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PG_referenced
comma
op_amp
id|page-&gt;flags
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* is it a buffer cache page? */
r_if
c_cond
(paren
id|bh
op_logical_and
id|try_to_free_buffer
c_func
(paren
id|bh
comma
op_amp
id|bh
comma
l_int|6
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* more than one user: we can&squot;t throw it away */
id|set_bit
c_func
(paren
id|PG_referenced
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|0
suffix:colon
multiline_comment|/* nothing */
)brace
id|next
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shrink_mmap
r_int
id|shrink_mmap
c_func
(paren
r_int
id|priority
comma
r_int
id|gfp_mask
)paren
(brace
r_static
r_int
r_int
id|clock
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|limit
op_assign
id|num_physpages
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|count_max
comma
id|count_min
suffix:semicolon
id|count_max
op_assign
(paren
id|limit
op_lshift
l_int|2
)paren
op_rshift
(paren
id|priority
op_rshift
l_int|1
)paren
suffix:semicolon
id|count_min
op_assign
(paren
id|limit
op_lshift
l_int|2
)paren
op_rshift
(paren
id|priority
)paren
suffix:semicolon
id|page
op_assign
id|mem_map
op_plus
id|clock
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|PageSkip
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* next_hash is overloaded for PageSkip */
id|page
op_assign
id|page-&gt;next_hash
suffix:semicolon
id|clock
op_assign
id|page-&gt;map_nr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shrink_one_page
c_func
(paren
id|page
comma
id|gfp_mask
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|count_max
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;inode
op_logical_or
id|page-&gt;buffers
)paren
id|count_min
op_decrement
suffix:semicolon
id|page
op_increment
suffix:semicolon
id|clock
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|clock
op_ge
id|max_mapnr
)paren
(brace
id|clock
op_assign
l_int|0
suffix:semicolon
id|page
op_assign
id|mem_map
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count_max
OG
l_int|0
op_logical_and
id|count_min
OG
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from try_to_swap_out() when we try to get rid of some&n; * pages..  If we&squot;re unmapping the last occurrence of this page, we also&n; * free it from the page hash-queues etc, as we don&squot;t want to keep it&n; * in-core unnecessarily.&n; */
DECL|function|page_unuse
r_int
r_int
id|page_unuse
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|2
)paren
r_return
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;inode
)paren
r_return
id|count
suffix:semicolon
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|panic
(paren
l_string|&quot;Doing a normal page_unuse of a swap cache page&quot;
)paren
suffix:semicolon
id|remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Update a page cache copy, when we&squot;re doing a &quot;write()&quot; system call&n; * See also &quot;update_vm_cache()&quot;.&n; */
DECL|function|update_vm_cache
r_void
id|update_vm_cache
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|pos
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|offset
comma
id|len
suffix:semicolon
id|offset
op_assign
(paren
id|pos
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
id|pos
op_assign
id|pos
op_amp
id|PAGE_MASK
suffix:semicolon
id|len
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
r_do
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
id|page
op_assign
id|find_page
c_func
(paren
id|inode
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|offset
op_plus
id|page_address
c_func
(paren
id|page
)paren
)paren
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|release_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|count
op_sub_assign
id|len
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|len
op_assign
id|PAGE_SIZE
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|pos
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
)brace
DECL|function|add_to_page_cache
r_static
r_inline
r_void
id|add_to_page_cache
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|offset
comma
r_struct
id|page
op_star
op_star
id|hash
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
id|page-&gt;flags
op_and_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|PG_uptodate
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_error
)paren
)paren
suffix:semicolon
id|page-&gt;offset
op_assign
id|offset
suffix:semicolon
id|add_page_to_inode_queue
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
id|__add_page_to_hash_queue
c_func
(paren
id|page
comma
id|hash
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to read ahead in the file. &quot;page_cache&quot; is a potentially free page&n; * that we could use for the cache (if it is 0 we can try to create one,&n; * this is all overlapped with the IO on the previous page finishing anyway)&n; */
DECL|function|try_to_read_ahead
r_static
r_int
r_int
id|try_to_read_ahead
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|page_cache
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|page
op_star
op_star
id|hash
suffix:semicolon
id|offset
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_switch
c_cond
(paren
id|page_cache
)paren
(brace
r_case
l_int|0
suffix:colon
id|page_cache
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_cache
)paren
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|offset
op_ge
id|inode-&gt;i_size
)paren
r_break
suffix:semicolon
id|hash
op_assign
id|page_hash
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
id|page
op_assign
id|__find_page
c_func
(paren
id|inode
comma
id|offset
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Ok, add the new page to the hash-queues...&n;&t;&t;&t; */
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|page_cache
)paren
suffix:semicolon
id|add_to_page_cache
c_func
(paren
id|page
comma
id|inode
comma
id|offset
comma
id|hash
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_referenced
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|inode-&gt;i_op
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
suffix:semicolon
id|page_cache
op_assign
l_int|0
suffix:semicolon
)brace
id|release_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|page_cache
suffix:semicolon
)brace
multiline_comment|/* &n; * Wait for IO to complete on a locked page.&n; *&n; * This must be called with the caller &quot;holding&quot; the page,&n; * ie with increased &quot;page-&gt;count&quot; so that the page won&squot;t&n; * go away during the wait..&n; */
DECL|function|__wait_on_page
r_void
id|__wait_on_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|wait_queue
id|wait
suffix:semicolon
id|wait.task
op_assign
id|tsk
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
macro_line|#if 0
mdefine_line|#define PROFILE_READAHEAD
mdefine_line|#define DEBUG_READAHEAD
macro_line|#endif
multiline_comment|/*&n; * Read-ahead profiling information&n; * --------------------------------&n; * Every PROFILE_MAXREADCOUNT, the following information is written &n; * to the syslog:&n; *   Percentage of asynchronous read-ahead.&n; *   Average of read-ahead fields context value.&n; * If DEBUG_READAHEAD is defined, a snapshot of these fields is written &n; * to the syslog.&n; */
macro_line|#ifdef PROFILE_READAHEAD
DECL|macro|PROFILE_MAXREADCOUNT
mdefine_line|#define PROFILE_MAXREADCOUNT 1000
DECL|variable|total_reada
r_static
r_int
r_int
id|total_reada
suffix:semicolon
DECL|variable|total_async
r_static
r_int
r_int
id|total_async
suffix:semicolon
DECL|variable|total_ramax
r_static
r_int
r_int
id|total_ramax
suffix:semicolon
DECL|variable|total_ralen
r_static
r_int
r_int
id|total_ralen
suffix:semicolon
DECL|variable|total_rawin
r_static
r_int
r_int
id|total_rawin
suffix:semicolon
DECL|function|profile_readahead
r_static
r_void
id|profile_readahead
c_func
(paren
r_int
id|async
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
op_increment
id|total_reada
suffix:semicolon
r_if
c_cond
(paren
id|async
)paren
op_increment
id|total_async
suffix:semicolon
id|total_ramax
op_add_assign
id|filp-&gt;f_ramax
suffix:semicolon
id|total_ralen
op_add_assign
id|filp-&gt;f_ralen
suffix:semicolon
id|total_rawin
op_add_assign
id|filp-&gt;f_rawin
suffix:semicolon
r_if
c_cond
(paren
id|total_reada
OG
id|PROFILE_MAXREADCOUNT
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|total_reada
OG
id|PROFILE_MAXREADCOUNT
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Readahead average:  max=%ld, len=%ld, win=%ld, async=%ld%%&bslash;n&quot;
comma
id|total_ramax
op_div
id|total_reada
comma
id|total_ralen
op_div
id|total_reada
comma
id|total_rawin
op_div
id|total_reada
comma
(paren
id|total_async
op_star
l_int|100
)paren
op_div
id|total_reada
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_READAHEAD
id|printk
c_func
(paren
l_string|&quot;Readahead snapshot: max=%ld, len=%ld, win=%ld, raend=%ld&bslash;n&quot;
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
comma
id|filp-&gt;f_raend
)paren
suffix:semicolon
macro_line|#endif
id|total_reada
op_assign
l_int|0
suffix:semicolon
id|total_async
op_assign
l_int|0
suffix:semicolon
id|total_ramax
op_assign
l_int|0
suffix:semicolon
id|total_ralen
op_assign
l_int|0
suffix:semicolon
id|total_rawin
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif  /* defined PROFILE_READAHEAD */
multiline_comment|/*&n; * Read-ahead context:&n; * -------------------&n; * The read ahead context fields of the &quot;struct file&quot; are the following:&n; * - f_raend : position of the first byte after the last page we tried to&n; *             read ahead.&n; * - f_ramax : current read-ahead maximum size.&n; * - f_ralen : length of the current IO read block we tried to read-ahead.&n; * - f_rawin : length of the current read-ahead window.&n; *             if last read-ahead was synchronous then&n; *                  f_rawin = f_ralen&n; *             otherwise (was asynchronous)&n; *                  f_rawin = previous value of f_ralen + f_ralen&n; *&n; * Read-ahead limits:&n; * ------------------&n; * MIN_READAHEAD   : minimum read-ahead size when read-ahead.&n; * MAX_READAHEAD   : maximum read-ahead size when read-ahead.&n; *&n; * Synchronous read-ahead benefits:&n; * --------------------------------&n; * Using reasonable IO xfer length from peripheral devices increase system &n; * performances.&n; * Reasonable means, in this context, not too large but not too small.&n; * The actual maximum value is:&n; *&t;MAX_READAHEAD + PAGE_SIZE = 76k is CONFIG_READA_SMALL is undefined&n; *      and 32K if defined (4K page size assumed).&n; *&n; * Asynchronous read-ahead benefits:&n; * ---------------------------------&n; * Overlapping next read request and user process execution increase system &n; * performance.&n; *&n; * Read-ahead risks:&n; * -----------------&n; * We have to guess which further data are needed by the user process.&n; * If these data are often not really needed, it&squot;s bad for system &n; * performances.&n; * However, we know that files are often accessed sequentially by &n; * application programs and it seems that it is possible to have some good &n; * strategy in that guessing.&n; * We only try to read-ahead files that seems to be read sequentially.&n; *&n; * Asynchronous read-ahead risks:&n; * ------------------------------&n; * In order to maximize overlapping, we must start some asynchronous read &n; * request from the device, as soon as possible.&n; * We must be very careful about:&n; * - The number of effective pending IO read requests.&n; *   ONE seems to be the only reasonable value.&n; * - The total memory pool usage for the file access stream.&n; *   This maximum memory usage is implicitly 2 IO read chunks:&n; *   2*(MAX_READAHEAD + PAGE_SIZE) = 156K if CONFIG_READA_SMALL is undefined,&n; *   64k if defined (4K page size assumed).&n; */
DECL|function|get_max_readahead
r_static
r_inline
r_int
id|get_max_readahead
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_dev
op_logical_or
op_logical_neg
id|max_readahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)braket
)paren
r_return
id|MAX_READAHEAD
suffix:semicolon
r_return
id|max_readahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)braket
suffix:semicolon
)brace
DECL|function|generic_file_readahead
r_static
r_inline
r_int
r_int
id|generic_file_readahead
c_func
(paren
r_int
id|reada_ok
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|ppos
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|page_cache
)paren
(brace
r_int
r_int
id|max_ahead
comma
id|ahead
suffix:semicolon
r_int
r_int
id|raend
suffix:semicolon
r_int
id|max_readahead
op_assign
id|get_max_readahead
c_func
(paren
id|inode
)paren
suffix:semicolon
id|raend
op_assign
id|filp-&gt;f_raend
op_amp
id|PAGE_MASK
suffix:semicolon
id|max_ahead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The current page is locked.&n; * If the current position is inside the previous read IO request, do not&n; * try to reread previously read ahead pages.&n; * Otherwise decide or not to read ahead some pages synchronously.&n; * If we are not going to read ahead, set the read ahead context for this &n; * page only.&n; */
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_ralen
op_logical_or
id|ppos
op_ge
id|raend
op_logical_or
id|ppos
op_plus
id|filp-&gt;f_ralen
OL
id|raend
)paren
(brace
id|raend
op_assign
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|raend
OL
id|inode-&gt;i_size
)paren
id|max_ahead
op_assign
id|filp-&gt;f_ramax
suffix:semicolon
id|filp-&gt;f_rawin
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_ralen
op_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_ahead
)paren
(brace
id|filp-&gt;f_raend
op_assign
id|ppos
op_plus
id|filp-&gt;f_ralen
suffix:semicolon
id|filp-&gt;f_rawin
op_add_assign
id|filp-&gt;f_ralen
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The current page is not locked.&n; * If we were reading ahead and,&n; * if the current max read ahead size is not zero and,&n; * if the current position is inside the last read-ahead IO request,&n; *   it is the moment to try to read ahead asynchronously.&n; * We will later force unplug device in order to force asynchronous read IO.&n; */
r_else
r_if
c_cond
(paren
id|reada_ok
op_logical_and
id|filp-&gt;f_ramax
op_logical_and
id|raend
op_ge
id|PAGE_SIZE
op_logical_and
id|ppos
op_le
id|raend
op_logical_and
id|ppos
op_plus
id|filp-&gt;f_ralen
op_ge
id|raend
)paren
(brace
multiline_comment|/*&n; * Add ONE page to max_ahead in order to try to have about the same IO max size&n; * as synchronous read-ahead (MAX_READAHEAD + 1)*PAGE_SIZE.&n; * Compute the position of the last page we have tried to read in order to &n; * begin to read ahead just at the next page.&n; */
id|raend
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|raend
OL
id|inode-&gt;i_size
)paren
id|max_ahead
op_assign
id|filp-&gt;f_ramax
op_plus
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|max_ahead
)paren
(brace
id|filp-&gt;f_rawin
op_assign
id|filp-&gt;f_ralen
suffix:semicolon
id|filp-&gt;f_ralen
op_assign
l_int|0
suffix:semicolon
id|reada_ok
op_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Try to read ahead pages.&n; * We hope that ll_rw_blk() plug/unplug, coalescence, requests sort and the&n; * scheduler, will work enough for us to avoid too bad actuals IO requests.&n; */
id|ahead
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ahead
OL
id|max_ahead
)paren
(brace
id|ahead
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|page_cache
op_assign
id|try_to_read_ahead
c_func
(paren
id|filp
comma
id|raend
op_plus
id|ahead
comma
id|page_cache
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If we tried to read ahead some pages,&n; * If we tried to read ahead asynchronously,&n; *   Try to force unplug of the device in order to start an asynchronous&n; *   read IO request.&n; * Update the read-ahead context.&n; * Store the length of the current read-ahead window.&n; * Double the current max read ahead size.&n; *   That heuristic avoid to do some large IO for files that are not really&n; *   accessed sequentially.&n; */
r_if
c_cond
(paren
id|ahead
)paren
(brace
r_if
c_cond
(paren
id|reada_ok
op_eq
l_int|2
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
)brace
id|filp-&gt;f_ralen
op_add_assign
id|ahead
suffix:semicolon
id|filp-&gt;f_rawin
op_add_assign
id|filp-&gt;f_ralen
suffix:semicolon
id|filp-&gt;f_raend
op_assign
id|raend
op_plus
id|ahead
op_plus
id|PAGE_SIZE
suffix:semicolon
id|filp-&gt;f_ramax
op_add_assign
id|filp-&gt;f_ramax
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_ramax
OG
id|max_readahead
)paren
id|filp-&gt;f_ramax
op_assign
id|max_readahead
suffix:semicolon
macro_line|#ifdef PROFILE_READAHEAD
id|profile_readahead
c_func
(paren
(paren
id|reada_ok
op_eq
l_int|2
)paren
comma
id|filp
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|page_cache
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;descriptor&quot; for what we&squot;re up to with a read.&n; * This allows us to use the same read code yet&n; * have multiple different users of the data that&n; * we read from a file.&n; *&n; * The simplest case just copies the data to user&n; * mode.&n; */
r_typedef
r_struct
(brace
DECL|member|written
r_int
id|written
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|buf
r_char
op_star
id|buf
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
DECL|typedef|read_descriptor_t
)brace
id|read_descriptor_t
suffix:semicolon
DECL|typedef|read_actor_t
r_typedef
r_int
(paren
op_star
id|read_actor_t
)paren
(paren
id|read_descriptor_t
op_star
comma
r_const
r_char
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * This is a generic file read routine, and uses the&n; * inode-&gt;i_op-&gt;readpage() function for the actual low-level&n; * stuff.&n; *&n; * This is really ugly. But the goto&squot;s actually try to clarify some&n; * of the logic when it comes to error handling etc.&n; */
DECL|function|do_generic_file_read
r_static
r_void
id|do_generic_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|loff_t
op_star
id|ppos
comma
id|read_descriptor_t
op_star
id|desc
comma
id|read_actor_t
id|actor
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|pos
comma
id|pgpos
comma
id|page_cache
suffix:semicolon
r_int
id|reada_ok
suffix:semicolon
r_int
id|max_readahead
op_assign
id|get_max_readahead
c_func
(paren
id|inode
)paren
suffix:semicolon
id|page_cache
op_assign
l_int|0
suffix:semicolon
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
id|pgpos
op_assign
id|pos
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/*&n; * If the current position is outside the previous read-ahead window, &n; * we reset the current read-ahead context and set read ahead max to zero&n; * (will be set to just needed value later),&n; * otherwise, we assume that the file accesses are sequential enough to&n; * continue read-ahead.&n; */
r_if
c_cond
(paren
id|pgpos
OG
id|filp-&gt;f_raend
op_logical_or
id|pgpos
op_plus
id|filp-&gt;f_rawin
OL
id|filp-&gt;f_raend
)paren
(brace
id|reada_ok
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_raend
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_ralen
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_ramax
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_rawin
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|reada_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust the current value of read-ahead max.&n; * If the read operation stay in the first half page, force no readahead.&n; * Otherwise try to increase read ahead max just enough to do the read request.&n; * Then, at least MIN_READAHEAD if read ahead is ok,&n; * and at most MAX_READAHEAD in all cases.&n; */
r_if
c_cond
(paren
id|pos
op_plus
id|desc-&gt;count
op_le
(paren
id|PAGE_SIZE
op_rshift
l_int|1
)paren
)paren
(brace
id|filp-&gt;f_ramax
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|needed
suffix:semicolon
id|needed
op_assign
(paren
(paren
id|pos
op_plus
id|desc-&gt;count
)paren
op_amp
id|PAGE_MASK
)paren
op_minus
id|pgpos
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_ramax
OL
id|needed
)paren
id|filp-&gt;f_ramax
op_assign
id|needed
suffix:semicolon
r_if
c_cond
(paren
id|reada_ok
op_logical_and
id|filp-&gt;f_ramax
OL
id|MIN_READAHEAD
)paren
id|filp-&gt;f_ramax
op_assign
id|MIN_READAHEAD
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_ramax
OG
id|max_readahead
)paren
id|filp-&gt;f_ramax
op_assign
id|max_readahead
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|inode-&gt;i_size
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to find the data in the page cache..&n;&t;&t; */
id|hash
op_assign
id|page_hash
c_func
(paren
id|inode
comma
id|pos
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|page
op_assign
id|__find_page
c_func
(paren
id|inode
comma
id|pos
op_amp
id|PAGE_MASK
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_cached_page
suffix:semicolon
id|found_page
suffix:colon
multiline_comment|/*&n; * Try to read ahead only if the current page is filled or being filled.&n; * Otherwise, if we were reading ahead, decrease max read ahead size to&n; * the minimum value.&n; * In this context, that seems to may happen only on some read error or if &n; * the page has been rewritten.&n; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
op_logical_or
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|page_cache
op_assign
id|generic_file_readahead
c_func
(paren
id|reada_ok
comma
id|filp
comma
id|inode
comma
id|pos
op_amp
id|PAGE_MASK
comma
id|page
comma
id|page_cache
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reada_ok
op_logical_and
id|filp-&gt;f_ramax
OG
id|MIN_READAHEAD
)paren
id|filp-&gt;f_ramax
op_assign
id|MIN_READAHEAD
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_read_error
suffix:semicolon
id|success
suffix:colon
multiline_comment|/*&n;&t;&t; * Ok, we have the page, it&squot;s up-to-date and ok,&n;&t;&t; * so now we can finally copy it to user space...&n;&t;&t; */
(brace
r_int
r_int
id|offset
comma
id|nr
suffix:semicolon
id|offset
op_assign
id|pos
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|nr
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|inode-&gt;i_size
op_minus
id|pos
)paren
id|nr
op_assign
id|inode-&gt;i_size
op_minus
id|pos
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The actor routine returns how many bytes were actually used..&n;&t;&t; * NOTE! This may not be the same as how much of a user buffer&n;&t;&t; * we filled up (we may be padding etc), so we can only update&n;&t;&t; * &quot;pos&quot; here (the actor routine has to update the user buffer&n;&t;&t; * pointers and the remaining count).&n;&t;&t; */
id|nr
op_assign
id|actor
c_func
(paren
id|desc
comma
(paren
r_const
r_char
op_star
)paren
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
)paren
comma
id|nr
)paren
suffix:semicolon
id|pos
op_add_assign
id|nr
suffix:semicolon
id|release_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_logical_and
id|desc-&gt;count
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
id|no_cached_page
suffix:colon
multiline_comment|/*&n;&t;&t; * Ok, it wasn&squot;t cached, so we need to create a new&n;&t;&t; * page..&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page_cache
)paren
(brace
id|page_cache
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * That could have slept, so go around to the&n;&t;&t;&t; * very beginning..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|page_cache
)paren
r_continue
suffix:semicolon
id|desc-&gt;error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Ok, add the new page to the hash-queues...&n;&t;&t; */
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|page_cache
)paren
suffix:semicolon
id|page_cache
op_assign
l_int|0
suffix:semicolon
id|add_to_page_cache
c_func
(paren
id|page
comma
id|inode
comma
id|pos
op_amp
id|PAGE_MASK
comma
id|hash
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Error handling is tricky. If we get a read error,&n;&t;&t; * the cached page stays in the cache (but uptodate=0),&n;&t;&t; * and the next process that accesses it will try to&n;&t;&t; * re-read it. This is needed for NFS etc, where the&n;&t;&t; * identity of the reader can decide if we can read the&n;&t;&t; * page or not..&n;&t;&t; */
multiline_comment|/*&n; * We have to read the page.&n; * If we were reading ahead, we had previously tried to read this page,&n; * That means that the page has probably been removed from the cache before &n; * the application process needs it, or has been rewritten.&n; * Decrease max readahead size to the minimum value in that situation.&n; */
r_if
c_cond
(paren
id|reada_ok
op_logical_and
id|filp-&gt;f_ramax
OG
id|MIN_READAHEAD
)paren
id|filp-&gt;f_ramax
op_assign
id|MIN_READAHEAD
suffix:semicolon
(brace
r_int
id|error
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|readpage
c_func
(paren
id|filp
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_goto
id|found_page
suffix:semicolon
id|desc-&gt;error
op_assign
id|error
suffix:semicolon
id|release_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|page_read_error
suffix:colon
multiline_comment|/*&n;&t;&t; * We found the page, but it wasn&squot;t up-to-date.&n;&t;&t; * Try to re-read it _once_. We do this synchronously,&n;&t;&t; * because this happens only if there were errors.&n;&t;&t; */
(brace
r_int
id|error
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|readpage
c_func
(paren
id|filp
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Some unspecified error occurred.. */
)brace
id|desc-&gt;error
op_assign
id|error
suffix:semicolon
id|release_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|ppos
op_assign
id|pos
suffix:semicolon
id|filp-&gt;f_reada
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|page_cache
)paren
id|free_page
c_func
(paren
id|page_cache
)paren
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|file_read_actor
r_static
r_int
id|file_read_actor
c_func
(paren
id|read_descriptor_t
op_star
id|desc
comma
r_const
r_char
op_star
id|area
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|left
suffix:semicolon
r_int
r_int
id|count
op_assign
id|desc-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
id|left
op_assign
id|__copy_to_user
c_func
(paren
id|desc-&gt;buf
comma
id|area
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
(brace
id|size
op_sub_assign
id|left
suffix:semicolon
id|desc-&gt;error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|desc-&gt;count
op_assign
id|count
op_minus
id|size
suffix:semicolon
id|desc-&gt;written
op_add_assign
id|size
suffix:semicolon
id|desc-&gt;buf
op_add_assign
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the &quot;read()&quot; routine for all filesystems&n; * that can use the page cache directly.&n; */
DECL|function|generic_file_read
id|ssize_t
id|generic_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
id|buf
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_generic_file_read
c_func
(paren
id|filp
comma
id|ppos
comma
op_amp
id|desc
comma
id|file_read_actor
)paren
suffix:semicolon
id|retval
op_assign
id|desc.written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|desc.error
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|file_send_actor
r_static
r_int
id|file_send_actor
c_func
(paren
id|read_descriptor_t
op_star
id|desc
comma
r_const
r_char
op_star
id|area
comma
r_int
r_int
id|size
)paren
(brace
id|ssize_t
id|written
suffix:semicolon
r_int
r_int
id|count
op_assign
id|desc-&gt;count
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
(paren
r_struct
id|file
op_star
)paren
id|desc-&gt;buf
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|written
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|file
comma
id|area
comma
id|size
comma
op_amp
id|file-&gt;f_pos
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OL
l_int|0
)paren
(brace
id|desc-&gt;error
op_assign
id|written
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
)brace
id|desc-&gt;count
op_assign
id|count
op_minus
id|written
suffix:semicolon
id|desc-&gt;written
op_add_assign
id|written
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
DECL|function|sys_sendfile
id|asmlinkage
id|ssize_t
id|sys_sendfile
c_func
(paren
r_int
id|out_fd
comma
r_int
id|in_fd
comma
id|off_t
op_star
id|offset
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|retval
suffix:semicolon
r_struct
id|file
op_star
id|in_file
comma
op_star
id|out_file
suffix:semicolon
r_struct
id|inode
op_star
id|in_inode
comma
op_star
id|out_inode
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get input file, and verify that it is ok..&n;&t; */
id|retval
op_assign
op_minus
id|EBADF
suffix:semicolon
id|in_file
op_assign
id|fget
c_func
(paren
id|in_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_file
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|in_file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_goto
id|fput_in
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|in_inode
op_assign
id|in_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_inode
)paren
r_goto
id|fput_in
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_inode-&gt;i_op
op_logical_or
op_logical_neg
id|in_inode-&gt;i_op-&gt;readpage
)paren
r_goto
id|fput_in
suffix:semicolon
id|retval
op_assign
id|locks_verify_area
c_func
(paren
id|FLOCK_VERIFY_READ
comma
id|in_inode
comma
id|in_file
comma
id|in_file-&gt;f_pos
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|fput_in
suffix:semicolon
multiline_comment|/*&n;&t; * Get output file, and verify that it is ok..&n;&t; */
id|retval
op_assign
op_minus
id|EBADF
suffix:semicolon
id|out_file
op_assign
id|fget
c_func
(paren
id|out_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out_file
)paren
r_goto
id|fput_in
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|out_file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
id|fput_out
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out_file-&gt;f_op
op_logical_or
op_logical_neg
id|out_file-&gt;f_op-&gt;write
)paren
r_goto
id|fput_out
suffix:semicolon
id|out_inode
op_assign
id|out_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out_inode
)paren
r_goto
id|fput_out
suffix:semicolon
id|retval
op_assign
id|locks_verify_area
c_func
(paren
id|FLOCK_VERIFY_WRITE
comma
id|out_inode
comma
id|out_file
comma
id|out_file-&gt;f_pos
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|fput_out
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
id|loff_t
id|pos
op_assign
l_int|0
comma
op_star
id|ppos
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|ppos
op_assign
op_amp
id|in_file-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|pos
comma
id|offset
)paren
)paren
r_goto
id|fput_out
suffix:semicolon
id|ppos
op_assign
op_amp
id|pos
suffix:semicolon
)brace
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
(paren
r_char
op_star
)paren
id|out_file
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_generic_file_read
c_func
(paren
id|in_file
comma
id|ppos
comma
op_amp
id|desc
comma
id|file_send_actor
)paren
suffix:semicolon
id|retval
op_assign
id|desc.written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|desc.error
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
id|put_user
c_func
(paren
id|pos
comma
id|offset
)paren
suffix:semicolon
)brace
id|fput_out
suffix:colon
id|fput
c_func
(paren
id|out_file
)paren
suffix:semicolon
id|fput_in
suffix:colon
id|fput
c_func
(paren
id|in_file
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Semantics for shared and private memory areas are different past the end&n; * of the file. A shared mapping past the last page of the file is an error&n; * and results in a SIGBUS, while a private mapping just maps in a zero page.&n; *&n; * The goto&squot;s are kind of ugly, but this streamlines the normal case of having&n; * it in the page cache, and handles the special cases reasonably without&n; * having a lot of duplicated code.&n; *&n; * WSH 06/04/97: fixed a memory leak and moved the allocation of new_page&n; * ahead of the wait if we&squot;re sure to need it.&n; */
DECL|function|filemap_nopage
r_static
r_int
r_int
id|filemap_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|address
comma
r_int
id|no_share
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|area-&gt;vm_file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|hash
suffix:semicolon
r_int
r_int
id|old_page
comma
id|new_page
suffix:semicolon
id|new_page
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
(paren
id|address
op_amp
id|PAGE_MASK
)paren
op_minus
id|area-&gt;vm_start
op_plus
id|area-&gt;vm_offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|inode-&gt;i_size
op_logical_and
(paren
id|area-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
op_logical_and
id|area-&gt;vm_mm
op_eq
id|current-&gt;mm
)paren
r_goto
id|no_page
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have something in the page cache already?&n;&t; */
id|hash
op_assign
id|page_hash
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
id|page
op_assign
id|__find_page
c_func
(paren
id|inode
comma
id|offset
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_cached_page
suffix:semicolon
id|found_page
suffix:colon
multiline_comment|/*&n;&t; * Ok, found a page in the page cache, now we need to check&n;&t; * that it&squot;s up-to-date.  First check whether we&squot;ll need an&n;&t; * extra page -- better to overlap the allocation with the I/O.&n;&t; */
r_if
c_cond
(paren
id|no_share
op_logical_and
op_logical_neg
id|new_page
)paren
(brace
id|new_page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page
)paren
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_locked_wait
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_read_error
suffix:semicolon
id|success
suffix:colon
multiline_comment|/*&n;&t; * Found the page, need to check sharing and possibly&n;&t; * copy it over to another page..&n;&t; */
id|old_page
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|no_share
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ok, we can share the cached page directly.. Get rid&n;&t;&t; * of any potential extra pages.&n;&t;&t; */
r_if
c_cond
(paren
id|new_page
)paren
id|free_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|old_page
)paren
suffix:semicolon
r_return
id|old_page
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No sharing ... copy to the new page.&n;&t; */
id|copy_page
c_func
(paren
id|new_page
comma
id|old_page
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|release_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|new_page
suffix:semicolon
id|no_cached_page
suffix:colon
id|new_page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page
)paren
r_goto
id|no_page
suffix:semicolon
multiline_comment|/*&n;&t; * During getting the above page we might have slept,&n;&t; * so we need to re-check the situation with the page&n;&t; * cache.. The page we just got may be useful if we&n;&t; * can&squot;t share, so don&squot;t get rid of it here.&n;&t; */
id|page
op_assign
id|find_page
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|found_page
suffix:semicolon
multiline_comment|/*&n;&t; * Now, create a new page-cache page from the page we got&n;&t; */
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|new_page
op_assign
l_int|0
suffix:semicolon
id|add_to_page_cache
c_func
(paren
id|page
comma
id|inode
comma
id|offset
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
op_ne
l_int|0
)paren
r_goto
id|failure
suffix:semicolon
multiline_comment|/*&n;&t; * Do a very limited read-ahead if appropriate&n;&t; */
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|new_page
op_assign
id|try_to_read_ahead
c_func
(paren
id|file
comma
id|offset
op_plus
id|PAGE_SIZE
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|found_page
suffix:semicolon
id|page_locked_wait
suffix:colon
id|__wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
id|page_read_error
suffix:colon
multiline_comment|/*&n;&t; * Umm, take care of errors if the page isn&squot;t up-to-date.&n;&t; * Try to re-read it _once_. We do this synchronously,&n;&t; * because there really aren&squot;t any performance issues here&n;&t; * and we need to check for errors.&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
op_ne
l_int|0
)paren
r_goto
id|failure
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageError
c_func
(paren
id|page
)paren
)paren
r_goto
id|failure
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
multiline_comment|/*&n;&t; * Things didn&squot;t work out. Return zero to tell the&n;&t; * mm layer so, possibly freeing the page cache page first.&n;&t; */
id|failure
suffix:colon
id|release_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_page
)paren
id|free_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|no_page
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Tries to write a shared mapped page to its backing store. May return -EIO&n; * if the disk is full.&n; */
DECL|function|do_write_page
r_static
r_inline
r_int
id|do_write_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|loff_t
id|loff
op_assign
id|offset
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
id|size
op_assign
id|offset
op_plus
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* refuse to extend file size.. */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|inode-&gt;i_size
)paren
id|size
op_assign
id|inode-&gt;i_size
suffix:semicolon
multiline_comment|/* Ho humm.. We should have tested for this earlier */
r_if
c_cond
(paren
id|size
OL
id|offset
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|size
op_sub_assign
id|offset
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
id|file-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|file
comma
(paren
r_const
r_char
op_star
)paren
id|page
comma
id|size
comma
op_amp
id|loff
)paren
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|filemap_write_page
r_static
r_int
id|filemap_write_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|page
)paren
(brace
r_int
id|result
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
dot
id|buffers
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
multiline_comment|/* whee.. just mark the buffer heads dirty */
r_struct
id|buffer_head
op_star
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t;&t; * WSH: There&squot;s a race here: mark_buffer_dirty()&n;&t;&t;&t; * could block, and the buffers aren&squot;t pinned down.&n;&t;&t;&t; */
id|mark_buffer_dirty
c_func
(paren
id|tmp
comma
l_int|0
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op-&gt;write
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t; * If a task terminates while we&squot;re swapping the page, the vma and&n;&t; * and file could be released ... increment the count to be safe.&n;&t; */
id|file-&gt;f_count
op_increment
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|result
op_assign
id|do_write_page
c_func
(paren
id|inode
comma
id|file
comma
(paren
r_const
r_char
op_star
)paren
id|page
comma
id|offset
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Swapping to a shared file: while we&squot;re busy writing out the page&n; * (and the page still exists in memory), we save the page information&n; * in the page table, so that &quot;filemap_swapin()&quot; can re-use the page&n; * immediately if it is called while we&squot;re busy swapping it out..&n; *&n; * Once we&squot;ve written it all out, we mark the page entry &quot;empty&quot;, which&n; * will result in a normal page-in (instead of a swap-in) from the now&n; * up-to-date disk file.&n; */
DECL|function|filemap_swapout
r_int
id|filemap_swapout
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|offset
comma
id|pte_t
op_star
id|page_table
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|page
op_assign
id|pte_page
c_func
(paren
op_star
id|page_table
)paren
suffix:semicolon
r_int
r_int
id|entry
op_assign
id|SWP_ENTRY
c_func
(paren
id|SHM_SWP_TYPE
comma
id|MAP_NR
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|flush_cache_page
c_func
(paren
id|vma
comma
(paren
id|offset
op_plus
id|vma-&gt;vm_start
op_minus
id|vma-&gt;vm_offset
)paren
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|page_table
comma
id|__pte
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|vma
comma
(paren
id|offset
op_plus
id|vma-&gt;vm_start
op_minus
id|vma-&gt;vm_offset
)paren
)paren
suffix:semicolon
id|error
op_assign
id|filemap_write_page
c_func
(paren
id|vma
comma
id|offset
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|page_table
)paren
op_eq
id|entry
)paren
id|pte_clear
c_func
(paren
id|page_table
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * filemap_swapin() is called only if we have something in the page&n; * tables that is non-zero (but not present), which we know to be the&n; * page index of a page that is busy being swapped out (see above).&n; * So we just use it directly..&n; */
DECL|function|filemap_swapin
r_static
id|pte_t
id|filemap_swapin
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|entry
)paren
(brace
r_int
r_int
id|page
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mem_map
(braket
id|page
)braket
dot
id|count
)paren
suffix:semicolon
id|page
op_assign
(paren
id|page
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|PAGE_OFFSET
suffix:semicolon
r_return
id|mk_pte
c_func
(paren
id|page
comma
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
)brace
DECL|function|filemap_sync_pte
r_static
r_inline
r_int
id|filemap_sync_pte
c_func
(paren
id|pte_t
op_star
id|ptep
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
r_int
id|flags
)paren
(brace
id|pte_t
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MS_INVALIDATE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|pte
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_dirty
c_func
(paren
id|pte
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|pte_page
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|ptep
comma
id|pte_mkclean
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|page
op_assign
id|pte_page
c_func
(paren
id|pte
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
dot
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|pte
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|pte_clear
c_func
(paren
id|ptep
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
id|swap_free
c_func
(paren
id|pte_val
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|page
op_assign
id|pte_page
c_func
(paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_dirty
c_func
(paren
id|pte
)paren
op_logical_or
id|flags
op_eq
id|MS_INVALIDATE
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|error
op_assign
id|filemap_write_page
c_func
(paren
id|vma
comma
id|address
op_minus
id|vma-&gt;vm_start
op_plus
id|vma-&gt;vm_offset
comma
id|page
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|filemap_sync_pte_range
r_static
r_inline
r_int
id|filemap_sync_pte_range
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|flags
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;filemap_sync_pte_range: bad pmd (%08lx)&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|offset
op_add_assign
id|address
op_amp
id|PMD_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|error
op_or_assign
id|filemap_sync_pte
c_func
(paren
id|pte
comma
id|vma
comma
id|address
op_plus
id|offset
comma
id|flags
)paren
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|filemap_sync_pmd_range
r_static
r_inline
r_int
id|filemap_sync_pmd_range
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|offset
comma
id|end
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;filemap_sync_pmd_range: bad pgd (%08lx)&bslash;n&quot;
comma
id|pgd_val
c_func
(paren
op_star
id|pgd
)paren
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|pgd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
id|offset
op_assign
id|address
op_amp
id|PGDIR_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|error
op_or_assign
id|filemap_sync_pte_range
c_func
(paren
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|vma
comma
id|offset
comma
id|flags
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
OL
id|end
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|filemap_sync
r_static
r_int
id|filemap_sync
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
id|pgd_t
op_star
id|dir
suffix:semicolon
r_int
r_int
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|dir
op_assign
id|pgd_offset
c_func
(paren
id|vma-&gt;vm_mm
comma
id|address
)paren
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|end
op_minus
id|size
comma
id|end
)paren
suffix:semicolon
r_while
c_loop
(paren
id|address
OL
id|end
)paren
(brace
id|error
op_or_assign
id|filemap_sync_pmd_range
c_func
(paren
id|dir
comma
id|address
comma
id|end
op_minus
id|address
comma
id|vma
comma
id|flags
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|dir
op_increment
suffix:semicolon
)brace
id|flush_tlb_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|end
op_minus
id|size
comma
id|end
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This handles (potentially partial) area unmaps..&n; */
DECL|function|filemap_unmap
r_static
r_void
id|filemap_unmap
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
id|len
)paren
(brace
id|filemap_sync
c_func
(paren
id|vma
comma
id|start
comma
id|len
comma
id|MS_ASYNC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shared mappings need to be able to do the right thing at&n; * close/unmap/sync. They will also use the private file as&n; * backing-store for swapping..&n; */
DECL|variable|file_shared_mmap
r_static
r_struct
id|vm_operations_struct
id|file_shared_mmap
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* no special open */
l_int|NULL
comma
multiline_comment|/* no special close */
id|filemap_unmap
comma
multiline_comment|/* unmap - we need to sync the pages */
l_int|NULL
comma
multiline_comment|/* no special protect */
id|filemap_sync
comma
multiline_comment|/* sync */
l_int|NULL
comma
multiline_comment|/* advise */
id|filemap_nopage
comma
multiline_comment|/* nopage */
l_int|NULL
comma
multiline_comment|/* wppage */
id|filemap_swapout
comma
multiline_comment|/* swapout */
id|filemap_swapin
comma
multiline_comment|/* swapin */
)brace
suffix:semicolon
multiline_comment|/*&n; * Private mappings just need to be able to load in the map.&n; *&n; * (This is actually used for shared mappings as well, if we&n; * know they can&squot;t ever get write permissions..)&n; */
DECL|variable|file_private_mmap
r_static
r_struct
id|vm_operations_struct
id|file_private_mmap
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* open */
l_int|NULL
comma
multiline_comment|/* close */
l_int|NULL
comma
multiline_comment|/* unmap */
l_int|NULL
comma
multiline_comment|/* protect */
l_int|NULL
comma
multiline_comment|/* sync */
l_int|NULL
comma
multiline_comment|/* advise */
id|filemap_nopage
comma
multiline_comment|/* nopage */
l_int|NULL
comma
multiline_comment|/* wppage */
l_int|NULL
comma
multiline_comment|/* swapout */
l_int|NULL
comma
multiline_comment|/* swapin */
)brace
suffix:semicolon
multiline_comment|/* This is used for a general mmap of a disk file */
DECL|function|generic_file_mmap
r_int
id|generic_file_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_operations_struct
op_star
id|ops
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
op_logical_and
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_MAYWRITE
)paren
)paren
(brace
id|ops
op_assign
op_amp
id|file_shared_mmap
suffix:semicolon
multiline_comment|/* share_page() can only guarantee proper page sharing if&n;&t;&t; * the offsets are all page aligned. */
r_if
c_cond
(paren
id|vma-&gt;vm_offset
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|ops
op_assign
op_amp
id|file_private_mmap
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_offset
op_amp
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;readpage
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|file-&gt;f_count
op_increment
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
id|ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The msync() system call.&n; */
DECL|function|msync_interval
r_static
r_int
id|msync_interval
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_file
op_logical_and
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;sync
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|sync
c_func
(paren
id|vma
comma
id|start
comma
id|end
op_minus
id|start
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|flags
op_amp
id|MS_SYNC
)paren
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|error
op_assign
id|file_fsync
c_func
(paren
id|file
comma
id|dentry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_msync
id|asmlinkage
r_int
id|sys_msync
c_func
(paren
r_int
r_int
id|start
comma
r_int
id|len
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
id|unmapped_error
comma
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_amp
op_complement
id|PAGE_MASK
)paren
r_goto
id|out
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
op_complement
id|PAGE_MASK
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|start
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|MS_ASYNC
op_or
id|MS_INVALIDATE
op_or
id|MS_SYNC
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|start
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If the interval [start,end) covers some unmapped address ranges,&n;&t; * just ignore them, but return -EFAULT at the end.&n;&t; */
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|start
)paren
suffix:semicolon
id|unmapped_error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Still start &lt; end. */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Here start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|start
OL
id|vma-&gt;vm_start
)paren
(brace
id|unmapped_error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|end
op_le
id|vma-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|start
OL
id|end
)paren
(brace
id|error
op_assign
id|msync_interval
c_func
(paren
id|vma
comma
id|start
comma
id|end
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|unmapped_error
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end &lt; end. */
id|error
op_assign
id|msync_interval
c_func
(paren
id|vma
comma
id|start
comma
id|vma-&gt;vm_end
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_end
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to a file through the page cache. This is mainly for the&n; * benefit of NFS and possibly other network-based file systems.&n; *&n; * We currently put everything into the page cache prior to writing it.&n; * This is not a problem when writing full pages. With partial pages,&n; * however, we first have to read the data into the cache, then&n; * dirty the page, and finally schedule it for writing. Alternatively, we&n; * could write-through just the portion of data that would go into that&n; * page, but that would kill performance for applications that write data&n; * line by line, and it&squot;s prone to race conditions.&n; *&n; * Note that this routine doesn&squot;t try to keep track of dirty pages. Each&n; * file system has to do this all by itself, unfortunately.&n; *&t;&t;&t;&t;&t;&t;&t;okir@monad.swb.de&n; */
id|ssize_t
DECL|function|generic_file_write
id|generic_file_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|hash
suffix:semicolon
r_int
r_int
id|page_cache
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pgpos
comma
id|offset
suffix:semicolon
r_int
r_int
id|bytes
comma
id|written
suffix:semicolon
r_int
r_int
id|pos
suffix:semicolon
r_int
id|status
comma
id|sync
comma
id|didread
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;updatepage
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|sync
op_assign
id|file-&gt;f_flags
op_amp
id|O_SYNC
suffix:semicolon
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
id|pos
op_assign
id|inode-&gt;i_size
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try to find the page in the cache. If it isn&squot;t there,&n;&t;&t; * allocate a free page.&n;&t;&t; */
id|offset
op_assign
(paren
id|pos
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
id|pgpos
op_assign
id|pos
op_amp
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytes
op_assign
id|PAGE_SIZE
op_minus
id|offset
)paren
OG
id|count
)paren
id|bytes
op_assign
id|count
suffix:semicolon
id|hash
op_assign
id|page_hash
c_func
(paren
id|inode
comma
id|pgpos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|__find_page
c_func
(paren
id|inode
comma
id|pgpos
comma
op_star
id|hash
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|page_cache
)paren
(brace
id|page_cache
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_cache
)paren
r_continue
suffix:semicolon
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|page_cache
)paren
suffix:semicolon
id|add_to_page_cache
c_func
(paren
id|page
comma
id|inode
comma
id|pgpos
comma
id|hash
)paren
suffix:semicolon
id|page_cache
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Note: setting of the PG_locked bit is handled&n;&t;&t; * below the i_op-&gt;xxx interface.&n;&t;&t; */
id|didread
op_assign
l_int|0
suffix:semicolon
id|page_wait
suffix:colon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|do_update_page
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The page is not up-to-date ... if we&squot;re writing less&n;&t;&t; * than a full page of data, we may have to read it first.&n;&t;&t; * But if the page is past the current end of file, we must&n;&t;&t; * clear it before updating.&n;&t;&t; */
r_if
c_cond
(paren
id|bytes
OL
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|pgpos
OL
id|inode-&gt;i_size
)paren
(brace
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|didread
op_ge
l_int|2
)paren
r_goto
id|done_with_page
suffix:semicolon
id|status
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_goto
id|done_with_page
suffix:semicolon
id|didread
op_increment
suffix:semicolon
r_goto
id|page_wait
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must clear for partial writes */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * N.B. We should defer setting PG_uptodate at least until&n;&t;&t; * the data is copied. A failure in i_op-&gt;updatepage() could&n;&t;&t; * leave the page with garbage data.&n;&t;&t; */
id|set_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|do_update_page
suffix:colon
multiline_comment|/* All right, the page is there.  Now update it. */
id|status
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|updatepage
c_func
(paren
id|file
comma
id|page
comma
id|buf
comma
id|offset
comma
id|bytes
comma
id|sync
)paren
suffix:semicolon
id|done_with_page
suffix:colon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_break
suffix:semicolon
id|written
op_add_assign
id|status
suffix:semicolon
id|count
op_sub_assign
id|status
suffix:semicolon
id|pos
op_add_assign
id|status
suffix:semicolon
id|buf
op_add_assign
id|status
suffix:semicolon
)brace
op_star
id|ppos
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|page_cache
)paren
id|free_page
c_func
(paren
id|page_cache
)paren
suffix:semicolon
r_return
id|written
ques
c_cond
id|written
suffix:colon
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Support routines for directory cacheing using the page cache.&n; */
multiline_comment|/*&n; * Finds the page at the specified offset, installing a new page&n; * if requested.  The count is incremented and the page is locked.&n; *&n; * Note: we don&squot;t have to worry about races here, as the caller&n; * is holding the inode semaphore.&n; */
DECL|function|get_cached_page
r_int
r_int
id|get_cached_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|offset
comma
r_int
r_new
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|page
op_star
op_star
id|hash
suffix:semicolon
r_int
r_int
id|page_cache
op_assign
l_int|0
suffix:semicolon
id|hash
op_assign
id|page_hash
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
id|page
op_assign
id|__find_page
c_func
(paren
id|inode
comma
id|offset
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_goto
id|out
suffix:semicolon
id|page_cache
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_cache
)paren
r_goto
id|out
suffix:semicolon
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|page_cache
)paren
suffix:semicolon
id|add_to_page_cache
c_func
(paren
id|page
comma
id|inode
comma
id|offset
comma
id|hash
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
op_ne
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;get_cached_page: page count=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;get_cached_page: page already locked!&bslash;n&quot;
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|page_cache
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|page_cache
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlock and free a page.&n; */
DECL|function|put_cached_page
r_void
id|put_cached_page
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;put_cached_page: page not locked!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
op_ne
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;put_cached_page: page count=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|page-&gt;count
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|page-&gt;wait
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
eof
