multiline_comment|/*&n; *&t;linux/mm/filemap.c&n; *&n; * Copyright (C) 1994-1999  Linus Torvalds&n; */
multiline_comment|/*&n; * This file handles the generic file mmap semantics used by&n; * most &quot;normal&quot; filesystems (but you don&squot;t /have/ to use this:&n; * the NFS filesystem used to do this differently, for example)&n; */
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mman.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
multiline_comment|/*&n; * Shared mappings implemented 30.11.1994. It&squot;s not fully working yet,&n; * though.&n; *&n; * Shared mappings now work. 15.8.1995  Bruno.&n; *&n; * finished &squot;unifying&squot; the page and buffer cache and SMP-threaded the&n; * page-cache, 21.05.1999, Ingo Molnar &lt;mingo@redhat.com&gt;&n; *&n; * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli &lt;andrea@suse.de&gt;&n; */
DECL|variable|page_cache_size
id|atomic_t
id|page_cache_size
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|page_hash_bits
r_int
r_int
id|page_hash_bits
suffix:semicolon
DECL|variable|page_hash_table
r_struct
id|page
op_star
op_star
id|page_hash_table
suffix:semicolon
DECL|variable|pagecache_lock
id|spinlock_t
id|pagecache_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * NOTE: to avoid deadlocking you must never acquire the pagecache_lock with&n; *       the pagemap_lru_lock held.&n; */
DECL|variable|pagemap_lru_lock
id|spinlock_t
id|pagemap_lru_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|CLUSTER_PAGES
mdefine_line|#define CLUSTER_PAGES&t;&t;(1 &lt;&lt; page_cluster)
DECL|macro|CLUSTER_OFFSET
mdefine_line|#define CLUSTER_OFFSET(x)&t;(((x) &gt;&gt; page_cluster) &lt;&lt; page_cluster)
DECL|function|add_page_to_hash_queue
r_static
r_void
id|add_page_to_hash_queue
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|page
op_star
op_star
id|p
)paren
(brace
r_struct
id|page
op_star
id|next
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_assign
id|page
suffix:semicolon
id|page-&gt;next_hash
op_assign
id|next
suffix:semicolon
id|page-&gt;pprev_hash
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;pprev_hash
op_assign
op_amp
id|page-&gt;next_hash
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;buffers
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|page_cache_size
)paren
suffix:semicolon
)brace
DECL|function|add_page_to_inode_queue
r_static
r_inline
r_void
id|add_page_to_inode_queue
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|mapping-&gt;clean_pages
suffix:semicolon
id|mapping-&gt;nrpages
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
id|head
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
id|mapping
suffix:semicolon
)brace
DECL|function|remove_page_from_inode_queue
r_static
r_inline
r_void
id|remove_page_from_inode_queue
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|mapping-&gt;nrpages
op_decrement
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_page_from_hash_queue
r_static
r_inline
r_void
id|remove_page_from_hash_queue
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|page
op_star
id|next
op_assign
id|page-&gt;next_hash
suffix:semicolon
r_struct
id|page
op_star
op_star
id|pprev
op_assign
id|page-&gt;pprev_hash
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;pprev_hash
op_assign
id|pprev
suffix:semicolon
op_star
id|pprev
op_assign
id|next
suffix:semicolon
id|page-&gt;pprev_hash
op_assign
l_int|NULL
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|page_cache_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a page from the page cache and free it. Caller has to make&n; * sure the page is locked and that nobody else uses it - or that usage&n; * is safe.&n; */
DECL|function|__remove_inode_page
r_void
id|__remove_inode_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|remove_page_from_inode_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_page_from_hash_queue
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_inode_page
r_void
id|remove_inode_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|__remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
DECL|function|sync_page
r_static
r_inline
r_int
id|sync_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping
op_logical_and
id|mapping-&gt;a_ops
op_logical_and
id|mapping-&gt;a_ops-&gt;sync_page
)paren
r_return
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|sync_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a page to the dirty page list.&n; */
DECL|function|__set_page_dirty
r_void
id|__set_page_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|mapping-&gt;dirty_pages
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|mark_inode_dirty_pages
c_func
(paren
id|mapping-&gt;host
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * invalidate_inode_pages - Invalidate all the unlocked pages of one inode&n; * @inode: the inode which pages we want to invalidate&n; *&n; * This function only removes the unlocked pages, if you want to&n; * remove all the pages of one inode, you must call truncate_inode_pages.&n; */
DECL|function|invalidate_inode_pages
r_void
id|invalidate_inode_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|list_head
op_star
id|head
comma
op_star
id|curr
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|head
op_assign
op_amp
id|inode-&gt;i_mapping-&gt;clean_pages
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|curr
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
id|head
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
multiline_comment|/* We cannot invalidate something in use.. */
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* ..or dirty.. */
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* ..or locked */
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
id|__lru_cache_del
c_func
(paren
id|page
)paren
suffix:semicolon
id|__remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
DECL|function|truncate_partial_page
r_static
r_inline
r_void
id|truncate_partial_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|partial
)paren
(brace
id|memclear_highpage_flush
c_func
(paren
id|page
comma
id|partial
comma
id|PAGE_CACHE_SIZE
op_minus
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;buffers
)paren
id|block_flushpage
c_func
(paren
id|page
comma
id|partial
)paren
suffix:semicolon
)brace
DECL|function|truncate_complete_page
r_static
r_inline
r_void
id|truncate_complete_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
multiline_comment|/* Leave it on the LRU if it gets converted into anonymous buffers */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
op_logical_or
id|block_flushpage
c_func
(paren
id|page
comma
l_int|0
)paren
)paren
id|lru_cache_del
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We remove the page from the page cache _after_ we have&n;&t; * destroyed all buffer-cache references to it. Otherwise some&n;&t; * other process might think this inode page is not in the&n;&t; * page cache and creates a buffer-cache alias to it causing&n;&t; * all sorts of fun problems ...  &n;&t; */
id|ClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_static
r_int
id|FASTCALL
c_func
(paren
id|truncate_list_pages
c_func
(paren
r_struct
id|list_head
op_star
comma
r_int
r_int
comma
r_int
op_star
)paren
)paren
suffix:semicolon
DECL|function|truncate_list_pages
r_static
r_int
id|truncate_list_pages
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_int
r_int
id|start
comma
r_int
op_star
id|partial
)paren
(brace
r_struct
id|list_head
op_star
id|curr
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|curr
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
id|head
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
id|page
op_assign
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
id|offset
op_assign
id|page-&gt;index
suffix:semicolon
multiline_comment|/* Is one of the pages to truncate? */
r_if
c_cond
(paren
(paren
id|offset
op_ge
id|start
)paren
op_logical_or
(paren
op_star
id|partial
op_logical_and
(paren
id|offset
op_plus
l_int|1
)paren
op_eq
id|start
)paren
)paren
(brace
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
(brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|partial
op_logical_and
(paren
id|offset
op_plus
l_int|1
)paren
op_eq
id|start
)paren
(brace
id|truncate_partial_page
c_func
(paren
id|page
comma
op_star
id|partial
)paren
suffix:semicolon
op_star
id|partial
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|truncate_complete_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * truncate_inode_pages - truncate *all* the pages from an offset&n; * @mapping: mapping to truncate&n; * @lstart: offset from with to truncate&n; *&n; * Truncate the page cache at a set offset, removing the pages&n; * that are beyond that offset (and zeroing out partial pages).&n; * If any page is locked we wait for it to become unlocked.&n; */
DECL|function|truncate_inode_pages
r_void
id|truncate_inode_pages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
id|lstart
)paren
(brace
r_int
r_int
id|start
op_assign
(paren
id|lstart
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|partial
op_assign
id|lstart
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|repeat
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|truncate_list_pages
c_func
(paren
op_amp
id|mapping-&gt;clean_pages
comma
id|start
comma
op_amp
id|partial
)paren
)paren
r_goto
id|repeat
suffix:semicolon
r_if
c_cond
(paren
id|truncate_list_pages
c_func
(paren
op_amp
id|mapping-&gt;dirty_pages
comma
id|start
comma
op_amp
id|partial
)paren
)paren
r_goto
id|repeat
suffix:semicolon
r_if
c_cond
(paren
id|truncate_list_pages
c_func
(paren
op_amp
id|mapping-&gt;locked_pages
comma
id|start
comma
op_amp
id|partial
)paren
)paren
r_goto
id|repeat
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
DECL|function|__find_page_nolock
r_static
r_inline
r_struct
id|page
op_star
id|__find_page_nolock
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_goto
id|inside
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|page
op_assign
id|page-&gt;next_hash
suffix:semicolon
id|inside
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
id|mapping
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_eq
id|offset
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Touching the page may move it to the active list.&n;&t; * If we end up with too few inactive pages, we wake&n;&t; * up kswapd.&n;&t; */
id|age_page_up
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inactive_shortage
c_func
(paren
)paren
OG
id|inactive_target
op_div
l_int|2
op_logical_and
id|free_shortage
c_func
(paren
)paren
)paren
id|wakeup_kswapd
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|not_found
suffix:colon
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * By the time this is called, the page is locked and&n; * we don&squot;t have to worry about any races any more.&n; *&n; * Start the IO..&n; */
DECL|function|writeout_one_page
r_static
r_int
id|writeout_one_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
id|jiffies
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|waitfor_one_page
r_static
r_int
id|waitfor_one_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_req
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_buffer_fdatasync
r_static
r_int
id|do_buffer_fdatasync
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|page
op_star
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|curr
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|curr
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|curr
op_ne
id|head
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
OL
id|start
)paren
r_continue
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The buffers could have been free&squot;d while we waited for the page lock */
r_if
c_cond
(paren
id|page-&gt;buffers
)paren
id|retval
op_or_assign
id|fn
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|curr
op_assign
id|page-&gt;list.next
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Two-stage data sync: first start the IO, then go back and&n; * collect the information..&n; */
DECL|function|generic_buffer_fdatasync
r_int
id|generic_buffer_fdatasync
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|start_idx
comma
r_int
r_int
id|end_idx
)paren
(brace
r_int
id|retval
suffix:semicolon
multiline_comment|/* writeout dirty buffers on pages from both clean and dirty lists */
id|retval
op_assign
id|do_buffer_fdatasync
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;dirty_pages
comma
id|start_idx
comma
id|end_idx
comma
id|writeout_one_page
)paren
suffix:semicolon
id|retval
op_or_assign
id|do_buffer_fdatasync
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;clean_pages
comma
id|start_idx
comma
id|end_idx
comma
id|writeout_one_page
)paren
suffix:semicolon
id|retval
op_or_assign
id|do_buffer_fdatasync
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;locked_pages
comma
id|start_idx
comma
id|end_idx
comma
id|writeout_one_page
)paren
suffix:semicolon
multiline_comment|/* now wait for locked buffers on pages from both clean and dirty lists */
id|retval
op_or_assign
id|do_buffer_fdatasync
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;dirty_pages
comma
id|start_idx
comma
id|end_idx
comma
id|writeout_one_page
)paren
suffix:semicolon
id|retval
op_or_assign
id|do_buffer_fdatasync
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;clean_pages
comma
id|start_idx
comma
id|end_idx
comma
id|waitfor_one_page
)paren
suffix:semicolon
id|retval
op_or_assign
id|do_buffer_fdatasync
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;locked_pages
comma
id|start_idx
comma
id|end_idx
comma
id|waitfor_one_page
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; *      filemap_fdatasync - walk the list of dirty pages of the given address space&n; *     &t;and writepage() all of them.&n; * &n; *      @mapping: address space structure to write&n; *&n; */
DECL|function|filemap_fdatasync
r_void
id|filemap_fdatasync
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_int
(paren
op_star
id|writepage
)paren
(paren
r_struct
id|page
op_star
)paren
op_assign
id|mapping-&gt;a_ops-&gt;writepage
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;dirty_pages
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|list_entry
c_func
(paren
id|mapping-&gt;dirty_pages.next
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|mapping-&gt;locked_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|ClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|writepage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *      filemap_fdatawait - walk the list of locked pages of the given address space&n; *     &t;and wait for all of them.&n; * &n; *      @mapping: address space structure to wait for&n; *&n; */
DECL|function|filemap_fdatawait
r_void
id|filemap_fdatawait
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;locked_pages
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|list_entry
c_func
(paren
id|mapping-&gt;locked_pages.next
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|mapping-&gt;clean_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|___wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a page to the inode page cache.&n; *&n; * The caller must have locked the page and &n; * set all the page flags correctly..&n; */
DECL|function|add_to_page_cache_locked
r_void
id|add_to_page_cache_locked
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|page-&gt;index
op_assign
id|index
suffix:semicolon
id|add_page_to_inode_queue
c_func
(paren
id|mapping
comma
id|page
)paren
suffix:semicolon
id|add_page_to_hash_queue
c_func
(paren
id|page
comma
id|page_hash
c_func
(paren
id|mapping
comma
id|index
)paren
)paren
suffix:semicolon
id|lru_cache_add
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This adds a page to the page cache, starting out as locked,&n; * owned by us, but unreferenced, not uptodate and with no errors.&n; */
DECL|function|__add_to_page_cache
r_static
r_inline
r_void
id|__add_to_page_cache
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
comma
r_struct
id|page
op_star
op_star
id|hash
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|flags
op_assign
id|page-&gt;flags
op_amp
op_complement
(paren
(paren
l_int|1
op_lshift
id|PG_uptodate
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_error
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_dirty
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_referenced
)paren
op_or
(paren
l_int|1
op_lshift
id|PG_arch_1
)paren
)paren
suffix:semicolon
id|page-&gt;flags
op_assign
id|flags
op_or
(paren
l_int|1
op_lshift
id|PG_locked
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;index
op_assign
id|offset
suffix:semicolon
id|add_page_to_inode_queue
c_func
(paren
id|mapping
comma
id|page
)paren
suffix:semicolon
id|add_page_to_hash_queue
c_func
(paren
id|page
comma
id|hash
)paren
suffix:semicolon
id|lru_cache_add
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|add_to_page_cache
r_void
id|add_to_page_cache
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|__add_to_page_cache
c_func
(paren
id|page
comma
id|mapping
comma
id|offset
comma
id|page_hash
c_func
(paren
id|mapping
comma
id|offset
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
DECL|function|add_to_page_cache_unique
r_static
r_int
id|add_to_page_cache_unique
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
comma
r_struct
id|page
op_star
op_star
id|hash
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|page
op_star
id|alias
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|alias
op_assign
id|__find_page_nolock
c_func
(paren
id|mapping
comma
id|offset
comma
op_star
id|hash
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alias
)paren
(brace
id|__add_to_page_cache
c_func
(paren
id|page
comma
id|mapping
comma
id|offset
comma
id|hash
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This adds the requested page to the page cache if it isn&squot;t already there,&n; * and schedules an I/O to read in its contents from disk.&n; */
DECL|function|page_cache_read
r_static
r_inline
r_int
id|page_cache_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
op_star
id|hash
op_assign
id|page_hash
c_func
(paren
id|mapping
comma
id|offset
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|page
op_assign
id|__find_page_nolock
c_func
(paren
id|mapping
comma
id|offset
comma
op_star
id|hash
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_return
l_int|0
suffix:semicolon
id|page
op_assign
id|page_cache_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|add_to_page_cache_unique
c_func
(paren
id|page
comma
id|mapping
comma
id|offset
comma
id|hash
)paren
)paren
(brace
r_int
id|error
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We arrive here in the unlikely event that someone &n;&t; * raced with us and added our page to the cache first.&n;&t; */
id|page_cache_free
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in an entire cluster at once.  A cluster is usually a 64k-&n; * aligned block that includes the page requested in &quot;offset.&quot;&n; */
DECL|function|read_cluster_nonblocking
r_static
r_int
id|read_cluster_nonblocking
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|filesize
)paren
(brace
r_int
r_int
id|pages
op_assign
id|CLUSTER_PAGES
suffix:semicolon
id|offset
op_assign
id|CLUSTER_OFFSET
c_func
(paren
id|offset
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pages
op_decrement
OG
l_int|0
)paren
op_logical_and
(paren
id|offset
OL
id|filesize
)paren
)paren
(brace
r_int
id|error
op_assign
id|page_cache_read
c_func
(paren
id|file
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
id|offset
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Wait for a page to get unlocked.&n; *&n; * This must be called with the caller &quot;holding&quot; the page,&n; * ie with increased &quot;page-&gt;count&quot; so that the page won&squot;t&n; * go away during the wait..&n; */
DECL|function|___wait_on_page
r_void
id|___wait_on_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_do
(brace
id|sync_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
r_break
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a lock on the page, assuming we need to sleep&n; * to get it..&n; */
DECL|function|__lock_page
r_static
r_void
id|__lock_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|sync_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
r_break
suffix:semicolon
)brace
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get an exclusive lock on the page, optimistically&n; * assuming it&squot;s not locked..&n; */
DECL|function|lock_page
r_void
id|lock_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
id|__lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * a rather lightweight function, finding and getting a reference to a&n; * hashed page atomically, waiting for it if it&squot;s locked.&n; */
DECL|function|__find_get_page
r_struct
id|page
op_star
id|__find_get_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
comma
r_struct
id|page
op_star
op_star
id|hash
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * We scan the hash list read-only. Addition to and removal from&n;&t; * the hash-list needs a held write-lock.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|page
op_assign
id|__find_page_nolock
c_func
(paren
id|mapping
comma
id|offset
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the lock to a page atomically.&n; */
DECL|function|__find_lock_page
r_struct
id|page
op_star
id|__find_lock_page
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
comma
r_struct
id|page
op_star
op_star
id|hash
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * We scan the hash list read-only. Addition to and removal from&n;&t; * the hash-list needs a held write-lock.&n;&t; */
id|repeat
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|page
op_assign
id|__find_page_nolock
c_func
(paren
id|mapping
comma
id|offset
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Is the page still hashed? Ok, good.. */
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
r_return
id|page
suffix:semicolon
multiline_comment|/* Nope: we raced. Release and try again.. */
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#if 0
mdefine_line|#define PROFILE_READAHEAD
mdefine_line|#define DEBUG_READAHEAD
macro_line|#endif
multiline_comment|/*&n; * We combine this with read-ahead to deactivate pages when we&n; * think there&squot;s sequential IO going on. Note that this is&n; * harmless since we don&squot;t actually evict the pages from memory&n; * but just move them to the inactive list.&n; *&n; * TODO:&n; * - make the readahead code smarter&n; * - move readahead to the VMA level so we can do the same&n; *   trick with mmap()&n; *&n; * Rik van Riel, 2000&n; */
DECL|function|drop_behind
r_static
r_void
id|drop_behind
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|index
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
op_star
id|hash
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
multiline_comment|/* Nothing to drop-behind if we&squot;re on the first page. */
r_if
c_cond
(paren
op_logical_neg
id|index
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
id|file-&gt;f_rawin
)paren
id|start
op_assign
id|index
op_minus
id|file-&gt;f_rawin
suffix:semicolon
r_else
id|start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Go backwards from index-1 and drop all pages in the&n;&t; * readahead window. Since the readahead window may have&n;&t; * been increased since the last time we were called, we&n;&t; * stop when the page isn&squot;t there.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|index
op_ge
id|start
)paren
(brace
id|hash
op_assign
id|page_hash
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
id|page
op_assign
id|__find_page_nolock
c_func
(paren
id|mapping
comma
id|index
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|deactivate_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read-ahead profiling information&n; * --------------------------------&n; * Every PROFILE_MAXREADCOUNT, the following information is written &n; * to the syslog:&n; *   Percentage of asynchronous read-ahead.&n; *   Average of read-ahead fields context value.&n; * If DEBUG_READAHEAD is defined, a snapshot of these fields is written &n; * to the syslog.&n; */
macro_line|#ifdef PROFILE_READAHEAD
DECL|macro|PROFILE_MAXREADCOUNT
mdefine_line|#define PROFILE_MAXREADCOUNT 1000
DECL|variable|total_reada
r_static
r_int
r_int
id|total_reada
suffix:semicolon
DECL|variable|total_async
r_static
r_int
r_int
id|total_async
suffix:semicolon
DECL|variable|total_ramax
r_static
r_int
r_int
id|total_ramax
suffix:semicolon
DECL|variable|total_ralen
r_static
r_int
r_int
id|total_ralen
suffix:semicolon
DECL|variable|total_rawin
r_static
r_int
r_int
id|total_rawin
suffix:semicolon
DECL|function|profile_readahead
r_static
r_void
id|profile_readahead
c_func
(paren
r_int
id|async
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
op_increment
id|total_reada
suffix:semicolon
r_if
c_cond
(paren
id|async
)paren
op_increment
id|total_async
suffix:semicolon
id|total_ramax
op_add_assign
id|filp-&gt;f_ramax
suffix:semicolon
id|total_ralen
op_add_assign
id|filp-&gt;f_ralen
suffix:semicolon
id|total_rawin
op_add_assign
id|filp-&gt;f_rawin
suffix:semicolon
r_if
c_cond
(paren
id|total_reada
OG
id|PROFILE_MAXREADCOUNT
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|total_reada
OG
id|PROFILE_MAXREADCOUNT
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Readahead average:  max=%ld, len=%ld, win=%ld, async=%ld%%&bslash;n&quot;
comma
id|total_ramax
op_div
id|total_reada
comma
id|total_ralen
op_div
id|total_reada
comma
id|total_rawin
op_div
id|total_reada
comma
(paren
id|total_async
op_star
l_int|100
)paren
op_div
id|total_reada
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_READAHEAD
id|printk
c_func
(paren
l_string|&quot;Readahead snapshot: max=%ld, len=%ld, win=%ld, raend=%Ld&bslash;n&quot;
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
comma
id|filp-&gt;f_raend
)paren
suffix:semicolon
macro_line|#endif
id|total_reada
op_assign
l_int|0
suffix:semicolon
id|total_async
op_assign
l_int|0
suffix:semicolon
id|total_ramax
op_assign
l_int|0
suffix:semicolon
id|total_ralen
op_assign
l_int|0
suffix:semicolon
id|total_rawin
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif  /* defined PROFILE_READAHEAD */
multiline_comment|/*&n; * Read-ahead context:&n; * -------------------&n; * The read ahead context fields of the &quot;struct file&quot; are the following:&n; * - f_raend : position of the first byte after the last page we tried to&n; *&t;       read ahead.&n; * - f_ramax : current read-ahead maximum size.&n; * - f_ralen : length of the current IO read block we tried to read-ahead.&n; * - f_rawin : length of the current read-ahead window.&n; *&t;&t;if last read-ahead was synchronous then&n; *&t;&t;&t;f_rawin = f_ralen&n; *&t;&t;otherwise (was asynchronous)&n; *&t;&t;&t;f_rawin = previous value of f_ralen + f_ralen&n; *&n; * Read-ahead limits:&n; * ------------------&n; * MIN_READAHEAD   : minimum read-ahead size when read-ahead.&n; * MAX_READAHEAD   : maximum read-ahead size when read-ahead.&n; *&n; * Synchronous read-ahead benefits:&n; * --------------------------------&n; * Using reasonable IO xfer length from peripheral devices increase system &n; * performances.&n; * Reasonable means, in this context, not too large but not too small.&n; * The actual maximum value is:&n; *&t;MAX_READAHEAD + PAGE_CACHE_SIZE = 76k is CONFIG_READA_SMALL is undefined&n; *      and 32K if defined (4K page size assumed).&n; *&n; * Asynchronous read-ahead benefits:&n; * ---------------------------------&n; * Overlapping next read request and user process execution increase system &n; * performance.&n; *&n; * Read-ahead risks:&n; * -----------------&n; * We have to guess which further data are needed by the user process.&n; * If these data are often not really needed, it&squot;s bad for system &n; * performances.&n; * However, we know that files are often accessed sequentially by &n; * application programs and it seems that it is possible to have some good &n; * strategy in that guessing.&n; * We only try to read-ahead files that seems to be read sequentially.&n; *&n; * Asynchronous read-ahead risks:&n; * ------------------------------&n; * In order to maximize overlapping, we must start some asynchronous read &n; * request from the device, as soon as possible.&n; * We must be very careful about:&n; * - The number of effective pending IO read requests.&n; *   ONE seems to be the only reasonable value.&n; * - The total memory pool usage for the file access stream.&n; *   This maximum memory usage is implicitly 2 IO read chunks:&n; *   2*(MAX_READAHEAD + PAGE_CACHE_SIZE) = 156K if CONFIG_READA_SMALL is undefined,&n; *   64k if defined (4K page size assumed).&n; */
DECL|function|get_max_readahead
r_static
r_inline
r_int
id|get_max_readahead
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_dev
op_logical_or
op_logical_neg
id|max_readahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)braket
)paren
r_return
id|MAX_READAHEAD
suffix:semicolon
r_return
id|max_readahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)braket
suffix:semicolon
)brace
DECL|function|generic_file_readahead
r_static
r_void
id|generic_file_readahead
c_func
(paren
r_int
id|reada_ok
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
r_int
id|index
op_assign
id|page-&gt;index
suffix:semicolon
r_int
r_int
id|max_ahead
comma
id|ahead
suffix:semicolon
r_int
r_int
id|raend
suffix:semicolon
r_int
id|max_readahead
op_assign
id|get_max_readahead
c_func
(paren
id|inode
)paren
suffix:semicolon
id|raend
op_assign
id|filp-&gt;f_raend
suffix:semicolon
id|max_ahead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The current page is locked.&n; * If the current position is inside the previous read IO request, do not&n; * try to reread previously read ahead pages.&n; * Otherwise decide or not to read ahead some pages synchronously.&n; * If we are not going to read ahead, set the read ahead context for this &n; * page only.&n; */
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_ralen
op_logical_or
id|index
op_ge
id|raend
op_logical_or
id|index
op_plus
id|filp-&gt;f_rawin
OL
id|raend
)paren
(brace
id|raend
op_assign
id|index
suffix:semicolon
r_if
c_cond
(paren
id|raend
OL
id|end_index
)paren
id|max_ahead
op_assign
id|filp-&gt;f_ramax
suffix:semicolon
id|filp-&gt;f_rawin
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_ralen
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_ahead
)paren
(brace
id|filp-&gt;f_raend
op_assign
id|index
op_plus
id|filp-&gt;f_ralen
suffix:semicolon
id|filp-&gt;f_rawin
op_add_assign
id|filp-&gt;f_ralen
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * The current page is not locked.&n; * If we were reading ahead and,&n; * if the current max read ahead size is not zero and,&n; * if the current position is inside the last read-ahead IO request,&n; *   it is the moment to try to read ahead asynchronously.&n; * We will later force unplug device in order to force asynchronous read IO.&n; */
r_else
r_if
c_cond
(paren
id|reada_ok
op_logical_and
id|filp-&gt;f_ramax
op_logical_and
id|raend
op_ge
l_int|1
op_logical_and
id|index
op_le
id|raend
op_logical_and
id|index
op_plus
id|filp-&gt;f_ralen
op_ge
id|raend
)paren
(brace
multiline_comment|/*&n; * Add ONE page to max_ahead in order to try to have about the same IO max size&n; * as synchronous read-ahead (MAX_READAHEAD + 1)*PAGE_CACHE_SIZE.&n; * Compute the position of the last page we have tried to read in order to &n; * begin to read ahead just at the next page.&n; */
id|raend
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|raend
OL
id|end_index
)paren
id|max_ahead
op_assign
id|filp-&gt;f_ramax
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|max_ahead
)paren
(brace
id|filp-&gt;f_rawin
op_assign
id|filp-&gt;f_ralen
suffix:semicolon
id|filp-&gt;f_ralen
op_assign
l_int|0
suffix:semicolon
id|reada_ok
op_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Try to read ahead pages.&n; * We hope that ll_rw_blk() plug/unplug, coalescence, requests sort and the&n; * scheduler, will work enough for us to avoid too bad actuals IO requests.&n; */
id|ahead
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ahead
OL
id|max_ahead
)paren
(brace
id|ahead
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raend
op_plus
id|ahead
)paren
op_ge
id|end_index
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|page_cache_read
c_func
(paren
id|filp
comma
id|raend
op_plus
id|ahead
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n; * If we tried to read ahead some pages,&n; * If we tried to read ahead asynchronously,&n; *   Try to force unplug of the device in order to start an asynchronous&n; *   read IO request.&n; * Update the read-ahead context.&n; * Store the length of the current read-ahead window.&n; * Double the current max read ahead size.&n; *   That heuristic avoid to do some large IO for files that are not really&n; *   accessed sequentially.&n; */
r_if
c_cond
(paren
id|ahead
)paren
(brace
r_if
c_cond
(paren
id|reada_ok
op_eq
l_int|2
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
)brace
id|filp-&gt;f_ralen
op_add_assign
id|ahead
suffix:semicolon
id|filp-&gt;f_rawin
op_add_assign
id|filp-&gt;f_ralen
suffix:semicolon
id|filp-&gt;f_raend
op_assign
id|raend
op_plus
id|ahead
op_plus
l_int|1
suffix:semicolon
id|filp-&gt;f_ramax
op_add_assign
id|filp-&gt;f_ramax
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_ramax
OG
id|max_readahead
)paren
id|filp-&gt;f_ramax
op_assign
id|max_readahead
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move the pages that have already been passed&n;&t;&t; * to the inactive list.&n;&t;&t; */
id|drop_behind
c_func
(paren
id|filp
comma
id|index
)paren
suffix:semicolon
macro_line|#ifdef PROFILE_READAHEAD
id|profile_readahead
c_func
(paren
(paren
id|reada_ok
op_eq
l_int|2
)paren
comma
id|filp
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a generic file read routine, and uses the&n; * inode-&gt;i_op-&gt;readpage() function for the actual low-level&n; * stuff.&n; *&n; * This is really ugly. But the goto&squot;s actually try to clarify some&n; * of the logic when it comes to error handling etc.&n; */
DECL|function|do_generic_file_read
r_void
id|do_generic_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|loff_t
op_star
id|ppos
comma
id|read_descriptor_t
op_star
id|desc
comma
id|read_actor_t
id|actor
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_int
r_int
id|index
comma
id|offset
suffix:semicolon
r_struct
id|page
op_star
id|cached_page
suffix:semicolon
r_int
id|reada_ok
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|max_readahead
op_assign
id|get_max_readahead
c_func
(paren
id|inode
)paren
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
id|index
op_assign
op_star
id|ppos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_assign
op_star
id|ppos
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/*&n; * If the current position is outside the previous read-ahead window, &n; * we reset the current read-ahead context and set read ahead max to zero&n; * (will be set to just needed value later),&n; * otherwise, we assume that the file accesses are sequential enough to&n; * continue read-ahead.&n; */
r_if
c_cond
(paren
id|index
OG
id|filp-&gt;f_raend
op_logical_or
id|index
op_plus
id|filp-&gt;f_rawin
OL
id|filp-&gt;f_raend
)paren
(brace
id|reada_ok
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_raend
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_ralen
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_ramax
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_rawin
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|reada_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust the current value of read-ahead max.&n; * If the read operation stay in the first half page, force no readahead.&n; * Otherwise try to increase read ahead max just enough to do the read request.&n; * Then, at least MIN_READAHEAD if read ahead is ok,&n; * and at most MAX_READAHEAD in all cases.&n; */
r_if
c_cond
(paren
op_logical_neg
id|index
op_logical_and
id|offset
op_plus
id|desc-&gt;count
op_le
(paren
id|PAGE_CACHE_SIZE
op_rshift
l_int|1
)paren
)paren
(brace
id|filp-&gt;f_ramax
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|needed
suffix:semicolon
id|needed
op_assign
(paren
(paren
id|offset
op_plus
id|desc-&gt;count
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_ramax
OL
id|needed
)paren
id|filp-&gt;f_ramax
op_assign
id|needed
suffix:semicolon
r_if
c_cond
(paren
id|reada_ok
op_logical_and
id|filp-&gt;f_ramax
OL
id|MIN_READAHEAD
)paren
id|filp-&gt;f_ramax
op_assign
id|MIN_READAHEAD
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_ramax
OG
id|max_readahead
)paren
id|filp-&gt;f_ramax
op_assign
id|max_readahead
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|hash
suffix:semicolon
r_int
r_int
id|end_index
comma
id|nr
suffix:semicolon
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
id|end_index
)paren
r_break
suffix:semicolon
id|nr
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|end_index
)paren
(brace
id|nr
op_assign
id|inode-&gt;i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_le
id|offset
)paren
r_break
suffix:semicolon
)brace
id|nr
op_assign
id|nr
op_minus
id|offset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to find the data in the page cache..&n;&t;&t; */
id|hash
op_assign
id|page_hash
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|page
op_assign
id|__find_page_nolock
c_func
(paren
id|mapping
comma
id|index
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_cached_page
suffix:semicolon
id|found_page
suffix:colon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_not_up_to_date
suffix:semicolon
id|generic_file_readahead
c_func
(paren
id|reada_ok
comma
id|filp
comma
id|inode
comma
id|page
)paren
suffix:semicolon
id|page_ok
suffix:colon
multiline_comment|/* If users can be writing to this page using arbitrary&n;&t;&t; * virtual addresses, take care about potential aliasing&n;&t;&t; * before reading the page on the kernel side.&n;&t;&t; */
r_if
c_cond
(paren
id|mapping-&gt;i_mmap_shared
op_ne
l_int|NULL
)paren
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ok, we have the page, and it&squot;s up-to-date, so&n;&t;&t; * now we can copy it to user space...&n;&t;&t; *&n;&t;&t; * The actor routine returns how many bytes were actually used..&n;&t;&t; * NOTE! This may not be the same as how much of a user buffer&n;&t;&t; * we filled up (we may be padding etc), so we can only update&n;&t;&t; * &quot;pos&quot; here (the actor routine has to update the user buffer&n;&t;&t; * pointers and the remaining count).&n;&t;&t; */
id|nr
op_assign
id|actor
c_func
(paren
id|desc
comma
id|page
comma
id|offset
comma
id|nr
)paren
suffix:semicolon
id|offset
op_add_assign
id|nr
suffix:semicolon
id|index
op_add_assign
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_logical_and
id|desc-&gt;count
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n; * Ok, the page was not immediately readable, so let&squot;s try to read ahead while we&squot;re at it..&n; */
id|page_not_up_to_date
suffix:colon
id|generic_file_readahead
c_func
(paren
id|reada_ok
comma
id|filp
comma
id|inode
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_ok
suffix:semicolon
multiline_comment|/* Get exclusive access to the page ... */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Did it get unhashed before we got the lock? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Did somebody else fill it already? */
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|page_ok
suffix:semicolon
)brace
id|readpage
suffix:colon
multiline_comment|/* ... and start the actual read. The read will unlock the page. */
id|error
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|filp
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_ok
suffix:semicolon
multiline_comment|/* Again, try some read-ahead while waiting for the page to finish.. */
id|generic_file_readahead
c_func
(paren
id|reada_ok
comma
id|filp
comma
id|inode
comma
id|page
)paren
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_ok
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* UHHUH! A synchronous read error occurred. Report it */
id|desc-&gt;error
op_assign
id|error
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
id|no_cached_page
suffix:colon
multiline_comment|/*&n;&t;&t; * Ok, it wasn&squot;t cached, so we need to create a new&n;&t;&t; * page..&n;&t;&t; *&n;&t;&t; * We get here with the page cache lock held.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|cached_page
op_assign
id|page_cache_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
(brace
id|desc-&gt;error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Somebody may have added the page while we&n;&t;&t;&t; * dropped the page cache lock. Check for that.&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|page
op_assign
id|__find_page_nolock
c_func
(paren
id|mapping
comma
id|index
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|found_page
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Ok, add the new page to the hash-queues...&n;&t;&t; */
id|page
op_assign
id|cached_page
suffix:semicolon
id|__add_to_page_cache
c_func
(paren
id|page
comma
id|mapping
comma
id|index
comma
id|hash
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|readpage
suffix:semicolon
)brace
op_star
id|ppos
op_assign
(paren
(paren
id|loff_t
)paren
id|index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|offset
suffix:semicolon
id|filp-&gt;f_reada
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_free
c_func
(paren
id|cached_page
)paren
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|file_read_actor
r_static
r_int
id|file_read_actor
c_func
(paren
id|read_descriptor_t
op_star
id|desc
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
r_int
r_int
id|left
comma
id|count
op_assign
id|desc-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|left
op_assign
id|__copy_to_user
c_func
(paren
id|desc-&gt;buf
comma
id|kaddr
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
(brace
id|size
op_sub_assign
id|left
suffix:semicolon
id|desc-&gt;error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|desc-&gt;count
op_assign
id|count
op_minus
id|size
suffix:semicolon
id|desc-&gt;written
op_add_assign
id|size
suffix:semicolon
id|desc-&gt;buf
op_add_assign
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the &quot;read()&quot; routine for all filesystems&n; * that can use the page cache directly.&n; */
DECL|function|generic_file_read
id|ssize_t
id|generic_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
id|buf
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_generic_file_read
c_func
(paren
id|filp
comma
id|ppos
comma
op_amp
id|desc
comma
id|file_read_actor
)paren
suffix:semicolon
id|retval
op_assign
id|desc.written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|desc.error
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|file_send_actor
r_static
r_int
id|file_send_actor
c_func
(paren
id|read_descriptor_t
op_star
id|desc
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
id|ssize_t
id|written
suffix:semicolon
r_int
r_int
id|count
op_assign
id|desc-&gt;count
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
(paren
r_struct
id|file
op_star
)paren
id|desc-&gt;buf
suffix:semicolon
id|mm_segment_t
id|old_fs
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|written
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|file
comma
id|kaddr
op_plus
id|offset
comma
id|size
comma
op_amp
id|file-&gt;f_pos
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OL
l_int|0
)paren
(brace
id|desc-&gt;error
op_assign
id|written
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
)brace
id|desc-&gt;count
op_assign
id|count
op_minus
id|written
suffix:semicolon
id|desc-&gt;written
op_add_assign
id|written
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
DECL|function|sys_sendfile
id|asmlinkage
id|ssize_t
id|sys_sendfile
c_func
(paren
r_int
id|out_fd
comma
r_int
id|in_fd
comma
id|off_t
op_star
id|offset
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|retval
suffix:semicolon
r_struct
id|file
op_star
id|in_file
comma
op_star
id|out_file
suffix:semicolon
r_struct
id|inode
op_star
id|in_inode
comma
op_star
id|out_inode
suffix:semicolon
multiline_comment|/*&n;&t; * Get input file, and verify that it is ok..&n;&t; */
id|retval
op_assign
op_minus
id|EBADF
suffix:semicolon
id|in_file
op_assign
id|fget
c_func
(paren
id|in_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_file
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|in_file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_goto
id|fput_in
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|in_inode
op_assign
id|in_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_inode
)paren
r_goto
id|fput_in
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_inode-&gt;i_mapping-&gt;a_ops-&gt;readpage
)paren
r_goto
id|fput_in
suffix:semicolon
id|retval
op_assign
id|locks_verify_area
c_func
(paren
id|FLOCK_VERIFY_READ
comma
id|in_inode
comma
id|in_file
comma
id|in_file-&gt;f_pos
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|fput_in
suffix:semicolon
multiline_comment|/*&n;&t; * Get output file, and verify that it is ok..&n;&t; */
id|retval
op_assign
op_minus
id|EBADF
suffix:semicolon
id|out_file
op_assign
id|fget
c_func
(paren
id|out_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out_file
)paren
r_goto
id|fput_in
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|out_file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
id|fput_out
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out_file-&gt;f_op
op_logical_or
op_logical_neg
id|out_file-&gt;f_op-&gt;write
)paren
r_goto
id|fput_out
suffix:semicolon
id|out_inode
op_assign
id|out_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|retval
op_assign
id|locks_verify_area
c_func
(paren
id|FLOCK_VERIFY_WRITE
comma
id|out_inode
comma
id|out_file
comma
id|out_file-&gt;f_pos
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|fput_out
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
id|loff_t
id|pos
op_assign
l_int|0
comma
op_star
id|ppos
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|ppos
op_assign
op_amp
id|in_file-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|pos
comma
id|offset
)paren
)paren
r_goto
id|fput_out
suffix:semicolon
id|ppos
op_assign
op_amp
id|pos
suffix:semicolon
)brace
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
(paren
r_char
op_star
)paren
id|out_file
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_generic_file_read
c_func
(paren
id|in_file
comma
id|ppos
comma
op_amp
id|desc
comma
id|file_send_actor
)paren
suffix:semicolon
id|retval
op_assign
id|desc.written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|desc.error
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
id|put_user
c_func
(paren
id|pos
comma
id|offset
)paren
suffix:semicolon
)brace
id|fput_out
suffix:colon
id|fput
c_func
(paren
id|out_file
)paren
suffix:semicolon
id|fput_in
suffix:colon
id|fput
c_func
(paren
id|in_file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Read-ahead and flush behind for MADV_SEQUENTIAL areas.  Since we are&n; * sure this is sequential access, we don&squot;t need a flexible read-ahead&n; * window size -- we can always use a large fixed size window.&n; */
DECL|function|nopage_sequential_readahead
r_static
r_void
id|nopage_sequential_readahead
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|filesize
)paren
(brace
r_int
r_int
id|ra_window
suffix:semicolon
id|ra_window
op_assign
id|get_max_readahead
c_func
(paren
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
id|ra_window
op_assign
id|CLUSTER_OFFSET
c_func
(paren
id|ra_window
op_plus
id|CLUSTER_PAGES
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* vm_raend is zero if we haven&squot;t read ahead in this area yet.  */
r_if
c_cond
(paren
id|vma-&gt;vm_raend
op_eq
l_int|0
)paren
id|vma-&gt;vm_raend
op_assign
id|vma-&gt;vm_pgoff
op_plus
id|ra_window
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;ve just faulted the page half-way through our window,&n;&t; * then schedule reads for the next window, and release the&n;&t; * pages in the previous window.&n;&t; */
r_if
c_cond
(paren
(paren
id|pgoff
op_plus
(paren
id|ra_window
op_rshift
l_int|1
)paren
)paren
op_eq
id|vma-&gt;vm_raend
)paren
(brace
r_int
r_int
id|start
op_assign
id|vma-&gt;vm_pgoff
op_plus
id|vma-&gt;vm_raend
suffix:semicolon
r_int
r_int
id|end
op_assign
id|start
op_plus
id|ra_window
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
(paren
(paren
id|vma-&gt;vm_end
op_rshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_pgoff
)paren
)paren
id|end
op_assign
(paren
id|vma-&gt;vm_end
op_rshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_pgoff
suffix:semicolon
r_if
c_cond
(paren
id|start
OG
id|end
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|start
OL
id|end
)paren
op_logical_and
(paren
id|start
OL
id|filesize
)paren
)paren
(brace
r_if
c_cond
(paren
id|read_cluster_nonblocking
c_func
(paren
id|vma-&gt;vm_file
comma
id|start
comma
id|filesize
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|start
op_add_assign
id|CLUSTER_PAGES
suffix:semicolon
)brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
multiline_comment|/* if we&squot;re far enough past the beginning of this area,&n;&t;&t;   recycle pages that are in the previous window. */
r_if
c_cond
(paren
id|vma-&gt;vm_raend
OG
(paren
id|vma-&gt;vm_pgoff
op_plus
id|ra_window
op_plus
id|ra_window
)paren
)paren
(brace
r_int
r_int
id|window
op_assign
id|ra_window
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|end
op_assign
id|vma-&gt;vm_start
op_plus
(paren
id|vma-&gt;vm_raend
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|end
op_sub_assign
id|window
op_plus
id|window
suffix:semicolon
id|filemap_sync
c_func
(paren
id|vma
comma
id|end
op_minus
id|window
comma
id|window
comma
id|MS_INVALIDATE
)paren
suffix:semicolon
)brace
id|vma-&gt;vm_raend
op_add_assign
id|ra_window
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * filemap_nopage() is invoked via the vma operations vector for a&n; * mapped memory region to read in file data during a page fault.&n; *&n; * The goto&squot;s are kind of ugly, but this streamlines the normal case of having&n; * it in the page cache, and handles the special cases reasonably without&n; * having a lot of duplicated code.&n; */
DECL|function|filemap_nopage
r_struct
id|page
op_star
id|filemap_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|address
comma
r_int
id|no_share
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|area-&gt;vm_file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|hash
comma
op_star
id|old_page
suffix:semicolon
r_int
r_int
id|size
comma
id|pgoff
suffix:semicolon
id|pgoff
op_assign
(paren
(paren
id|address
op_minus
id|area-&gt;vm_start
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|area-&gt;vm_pgoff
suffix:semicolon
id|retry_all
suffix:colon
multiline_comment|/*&n;&t; * An external ptracer can access pages that normally aren&squot;t&n;&t; * accessible..&n;&t; */
id|size
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pgoff
op_ge
id|size
)paren
op_logical_and
(paren
id|area-&gt;vm_mm
op_eq
id|current-&gt;mm
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have something in the page cache already?&n;&t; */
id|hash
op_assign
id|page_hash
c_func
(paren
id|mapping
comma
id|pgoff
)paren
suffix:semicolon
id|retry_find
suffix:colon
id|page
op_assign
id|__find_get_page
c_func
(paren
id|mapping
comma
id|pgoff
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_cached_page
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, found a page in the page cache, now we need to check&n;&t; * that it&squot;s up-to-date.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_not_uptodate
suffix:semicolon
id|success
suffix:colon
multiline_comment|/*&n;&t; * Try read-ahead for sequential areas.&n;&t; */
r_if
c_cond
(paren
id|VM_SequentialReadHint
c_func
(paren
id|area
)paren
)paren
id|nopage_sequential_readahead
c_func
(paren
id|area
comma
id|pgoff
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Found the page and have a reference on it, need to check sharing&n;&t; * and possibly copy it over to another page..&n;&t; */
id|old_page
op_assign
id|page
suffix:semicolon
r_if
c_cond
(paren
id|no_share
)paren
(brace
r_struct
id|page
op_star
id|new_page
op_assign
id|page_cache_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_page
)paren
(brace
id|copy_user_highpage
c_func
(paren
id|new_page
comma
id|old_page
comma
id|address
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|new_page
)paren
suffix:semicolon
)brace
r_else
id|new_page
op_assign
id|NOPAGE_OOM
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|new_page
suffix:semicolon
)brace
id|flush_page_to_ram
c_func
(paren
id|old_page
)paren
suffix:semicolon
r_return
id|old_page
suffix:semicolon
id|no_cached_page
suffix:colon
multiline_comment|/*&n;&t; * If the requested offset is within our file, try to read a whole &n;&t; * cluster of pages at once.&n;&t; *&n;&t; * Otherwise, we&squot;re off the end of a privately mapped file,&n;&t; * so we need to map a zero page.&n;&t; */
r_if
c_cond
(paren
(paren
id|pgoff
OL
id|size
)paren
op_logical_and
op_logical_neg
id|VM_RandomReadHint
c_func
(paren
id|area
)paren
)paren
id|error
op_assign
id|read_cluster_nonblocking
c_func
(paren
id|file
comma
id|pgoff
comma
id|size
)paren
suffix:semicolon
r_else
id|error
op_assign
id|page_cache_read
c_func
(paren
id|file
comma
id|pgoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The page we want has now been added to the page cache.&n;&t; * In the unlikely event that someone removed it in the&n;&t; * meantime, we&squot;ll just come back here and read it again.&n;&t; */
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
r_goto
id|retry_find
suffix:semicolon
multiline_comment|/*&n;&t; * An error return from page_cache_read can result if the&n;&t; * system is low on memory, or a problem occurs while trying&n;&t; * to schedule I/O.&n;&t; */
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOMEM
)paren
r_return
id|NOPAGE_OOM
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|page_not_uptodate
suffix:colon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Did it get unhashed while we waited for it? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|retry_all
suffix:semicolon
)brace
multiline_comment|/* Did somebody else get it up-to-date? */
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
)paren
(brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Umm, take care of errors if the page isn&squot;t up-to-date.&n;&t; * Try to re-read it _once_. We do this synchronously,&n;&t; * because there really aren&squot;t any performance issues here&n;&t; * and we need to check for errors.&n;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Somebody truncated the page on us? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|retry_all
suffix:semicolon
)brace
multiline_comment|/* Somebody else successfully read it in? */
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
)paren
(brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Things didn&squot;t work out. Return zero to tell the&n;&t; * mm layer so, possibly freeing the page cache page first.&n;&t; */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Called with mm-&gt;page_table_lock held to protect against other&n; * threads/the swapper from ripping pte&squot;s out from under us.&n; */
DECL|function|filemap_sync_pte
r_static
r_inline
r_int
id|filemap_sync_pte
c_func
(paren
id|pte_t
op_star
id|ptep
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
r_int
id|flags
)paren
(brace
id|pte_t
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
op_logical_and
id|ptep_test_and_clear_dirty
c_func
(paren
id|ptep
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pte_page
c_func
(paren
id|pte
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|filemap_sync_pte_range
r_static
r_inline
r_int
id|filemap_sync_pte_range
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|flags
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pmd_ERROR
c_func
(paren
op_star
id|pmd
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|offset
op_add_assign
id|address
op_amp
id|PMD_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|error
op_or_assign
id|filemap_sync_pte
c_func
(paren
id|pte
comma
id|vma
comma
id|address
op_plus
id|offset
comma
id|flags
)paren
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|filemap_sync_pmd_range
r_static
r_inline
r_int
id|filemap_sync_pmd_range
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|flags
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|offset
comma
id|end
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pgd_ERROR
c_func
(paren
op_star
id|pgd
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|pgd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
id|offset
op_assign
id|address
op_amp
id|PGDIR_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|error
op_or_assign
id|filemap_sync_pte_range
c_func
(paren
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|vma
comma
id|offset
comma
id|flags
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|filemap_sync
r_int
id|filemap_sync
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|size
comma
r_int
r_int
id|flags
)paren
(brace
id|pgd_t
op_star
id|dir
suffix:semicolon
r_int
r_int
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Aquire the lock early; it may be possible to avoid dropping&n;&t; * and reaquiring it repeatedly.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|dir
op_assign
id|pgd_offset
c_func
(paren
id|vma-&gt;vm_mm
comma
id|address
)paren
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|end
op_minus
id|size
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|error
op_or_assign
id|filemap_sync_pmd_range
c_func
(paren
id|dir
comma
id|address
comma
id|end
op_minus
id|address
comma
id|vma
comma
id|flags
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|dir
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
id|flush_tlb_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|end
op_minus
id|size
comma
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Shared mappings need to be able to do the right thing at&n; * close/unmap/sync. They will also use the private file as&n; * backing-store for swapping..&n; */
DECL|variable|file_shared_mmap
r_static
r_struct
id|vm_operations_struct
id|file_shared_mmap
op_assign
(brace
id|nopage
suffix:colon
id|filemap_nopage
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Private mappings just need to be able to load in the map.&n; *&n; * (This is actually used for shared mappings as well, if we&n; * know they can&squot;t ever get write permissions..)&n; */
DECL|variable|file_private_mmap
r_static
r_struct
id|vm_operations_struct
id|file_private_mmap
op_assign
(brace
id|nopage
suffix:colon
id|filemap_nopage
comma
)brace
suffix:semicolon
multiline_comment|/* This is used for a general mmap of a disk file */
DECL|function|generic_file_mmap
r_int
id|generic_file_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_operations_struct
op_star
id|ops
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|ops
op_assign
op_amp
id|file_private_mmap
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
op_logical_and
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_MAYWRITE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_mapping-&gt;a_ops-&gt;writepage
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ops
op_assign
op_amp
id|file_shared_mmap
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_mapping-&gt;a_ops-&gt;readpage
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
id|ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The msync() system call.&n; */
DECL|function|msync_interval
r_static
r_int
id|msync_interval
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
id|flags
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|filemap_sync
c_func
(paren
id|vma
comma
id|start
comma
id|end
op_minus
id|start
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|flags
op_amp
id|MS_SYNC
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|filemap_fdatasync
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op
op_logical_and
id|file-&gt;f_op-&gt;fsync
)paren
id|error
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|file
comma
id|file-&gt;f_dentry
comma
l_int|1
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_msync
id|asmlinkage
r_int
id|sys_msync
c_func
(paren
r_int
r_int
id|start
comma
r_int
id|len
comma
r_int
id|flags
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
id|unmapped_error
comma
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_amp
op_complement
id|PAGE_MASK
)paren
r_goto
id|out
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
op_complement
id|PAGE_MASK
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|start
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
op_complement
(paren
id|MS_ASYNC
op_or
id|MS_INVALIDATE
op_or
id|MS_SYNC
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|start
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If the interval [start,end) covers some unmapped address ranges,&n;&t; * just ignore them, but return -EFAULT at the end.&n;&t; */
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|start
)paren
suffix:semicolon
id|unmapped_error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Still start &lt; end. */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Here start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|start
OL
id|vma-&gt;vm_start
)paren
(brace
id|unmapped_error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|end
op_le
id|vma-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|start
OL
id|end
)paren
(brace
id|error
op_assign
id|msync_interval
c_func
(paren
id|vma
comma
id|start
comma
id|end
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|unmapped_error
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end &lt; end. */
id|error
op_assign
id|msync_interval
c_func
(paren
id|vma
comma
id|start
comma
id|vma-&gt;vm_end
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_end
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|setup_read_behavior
r_static
r_inline
r_void
id|setup_read_behavior
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
id|behavior
)paren
(brace
id|VM_ClearReadHint
c_func
(paren
id|vma
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|behavior
)paren
(brace
r_case
id|MADV_SEQUENTIAL
suffix:colon
id|vma-&gt;vm_flags
op_or_assign
id|VM_SEQ_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MADV_RANDOM
suffix:colon
id|vma-&gt;vm_flags
op_or_assign
id|VM_RAND_READ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|madvise_fixup_start
r_static
r_int
id|madvise_fixup_start
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|end
comma
r_int
id|behavior
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|n
suffix:semicolon
id|n
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
op_star
id|n
op_assign
op_star
id|vma
suffix:semicolon
id|n-&gt;vm_end
op_assign
id|end
suffix:semicolon
id|setup_read_behavior
c_func
(paren
id|n
comma
id|behavior
)paren
suffix:semicolon
id|n-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|get_file
c_func
(paren
id|n-&gt;vm_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;vm_ops
op_logical_and
id|n-&gt;vm_ops-&gt;open
)paren
id|n-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|n
)paren
suffix:semicolon
id|lock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|vma-&gt;vm_pgoff
op_add_assign
(paren
id|end
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|end
suffix:semicolon
id|__insert_vm_struct
c_func
(paren
id|current-&gt;mm
comma
id|n
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|unlock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|madvise_fixup_end
r_static
r_int
id|madvise_fixup_end
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
id|behavior
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|n
suffix:semicolon
id|n
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
op_star
id|n
op_assign
op_star
id|vma
suffix:semicolon
id|n-&gt;vm_start
op_assign
id|start
suffix:semicolon
id|n-&gt;vm_pgoff
op_add_assign
(paren
id|n-&gt;vm_start
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|setup_read_behavior
c_func
(paren
id|n
comma
id|behavior
)paren
suffix:semicolon
id|n-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|get_file
c_func
(paren
id|n-&gt;vm_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;vm_ops
op_logical_and
id|n-&gt;vm_ops-&gt;open
)paren
id|n-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|n
)paren
suffix:semicolon
id|lock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|start
suffix:semicolon
id|__insert_vm_struct
c_func
(paren
id|current-&gt;mm
comma
id|n
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|unlock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|madvise_fixup_middle
r_static
r_int
id|madvise_fixup_middle
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
id|behavior
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|left
comma
op_star
id|right
suffix:semicolon
id|left
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|left
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|right
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|right
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|left
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
op_star
id|left
op_assign
op_star
id|vma
suffix:semicolon
op_star
id|right
op_assign
op_star
id|vma
suffix:semicolon
id|left-&gt;vm_end
op_assign
id|start
suffix:semicolon
id|right-&gt;vm_start
op_assign
id|end
suffix:semicolon
id|right-&gt;vm_pgoff
op_add_assign
(paren
id|right-&gt;vm_start
op_minus
id|left-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|left-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|right-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|atomic_add
c_func
(paren
l_int|2
comma
op_amp
id|vma-&gt;vm_file-&gt;f_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;open
)paren
(brace
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|left
)paren
suffix:semicolon
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|right
)paren
suffix:semicolon
)brace
id|lock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|vma-&gt;vm_pgoff
op_add_assign
(paren
id|start
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|start
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|end
suffix:semicolon
id|setup_read_behavior
c_func
(paren
id|vma
comma
id|behavior
)paren
suffix:semicolon
id|vma-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|__insert_vm_struct
c_func
(paren
id|current-&gt;mm
comma
id|left
)paren
suffix:semicolon
id|__insert_vm_struct
c_func
(paren
id|current-&gt;mm
comma
id|right
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|unlock_vma_mappings
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We can potentially split a vm area into separate&n; * areas, each area with its own behavior.&n; */
DECL|function|madvise_behavior
r_static
r_int
id|madvise_behavior
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
id|behavior
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This caps the number of vma&squot;s this process can own */
r_if
c_cond
(paren
id|vma-&gt;vm_mm-&gt;map_count
OG
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|start
op_eq
id|vma-&gt;vm_start
)paren
(brace
r_if
c_cond
(paren
id|end
op_eq
id|vma-&gt;vm_end
)paren
(brace
id|setup_read_behavior
c_func
(paren
id|vma
comma
id|behavior
)paren
suffix:semicolon
id|vma-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|error
op_assign
id|madvise_fixup_start
c_func
(paren
id|vma
comma
id|end
comma
id|behavior
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|end
op_eq
id|vma-&gt;vm_end
)paren
id|error
op_assign
id|madvise_fixup_end
c_func
(paren
id|vma
comma
id|start
comma
id|behavior
)paren
suffix:semicolon
r_else
id|error
op_assign
id|madvise_fixup_middle
c_func
(paren
id|vma
comma
id|start
comma
id|end
comma
id|behavior
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Schedule all required I/O operations, then run the disk queue&n; * to make sure they are started.  Do not wait for completion.&n; */
DECL|function|madvise_willneed
r_static
r_int
id|madvise_willneed
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
r_int
id|size
comma
id|rlim_rss
suffix:semicolon
multiline_comment|/* Doesn&squot;t work if there&squot;s no mapped file. */
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_file
)paren
r_return
id|error
suffix:semicolon
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
id|size
op_assign
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|start
op_assign
(paren
(paren
id|start
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_pgoff
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|vma-&gt;vm_end
)paren
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
id|end
op_assign
(paren
(paren
id|end
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_pgoff
suffix:semicolon
multiline_comment|/* Make sure this doesn&squot;t exceed the process&squot;s max rss. */
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
id|rlim_rss
op_assign
id|current-&gt;rlim
ques
c_cond
id|current-&gt;rlim
(braket
id|RLIMIT_RSS
)braket
dot
id|rlim_cur
suffix:colon
id|LONG_MAX
suffix:semicolon
multiline_comment|/* default: see resource.h */
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_mm-&gt;rss
op_plus
(paren
id|end
op_minus
id|start
)paren
)paren
OG
id|rlim_rss
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* round to cluster boundaries if this isn&squot;t a &quot;random&quot; area. */
r_if
c_cond
(paren
op_logical_neg
id|VM_RandomReadHint
c_func
(paren
id|vma
)paren
)paren
(brace
id|start
op_assign
id|CLUSTER_OFFSET
c_func
(paren
id|start
)paren
suffix:semicolon
id|end
op_assign
id|CLUSTER_OFFSET
c_func
(paren
id|end
op_plus
id|CLUSTER_PAGES
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|start
OL
id|end
)paren
op_logical_and
(paren
id|start
OL
id|size
)paren
)paren
(brace
id|error
op_assign
id|read_cluster_nonblocking
c_func
(paren
id|file
comma
id|start
comma
id|size
)paren
suffix:semicolon
id|start
op_add_assign
id|CLUSTER_PAGES
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
id|start
OL
id|end
)paren
op_logical_and
(paren
id|start
OL
id|size
)paren
)paren
(brace
id|error
op_assign
id|page_cache_read
c_func
(paren
id|file
comma
id|start
)paren
suffix:semicolon
id|start
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Don&squot;t wait for someone else to push these requests. */
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Application no longer needs these pages.  If the pages are dirty,&n; * it&squot;s OK to just throw them away.  The app will be more careful about&n; * data it wants to keep.  Be sure to free swap resources too.  The&n; * zap_page_range call sets things up for refill_inactive to actually free&n; * these pages later if no one else has touched them in the meantime,&n; * although we could add these pages to a global reuse list for&n; * refill_inactive to pick up before reclaiming other pages.&n; *&n; * NB: This interface discards data rather than pushes it out to swap,&n; * as some implementations do.  This has performance implications for&n; * applications like large transactional databases which want to discard&n; * pages in anonymous maps after committing to backing store the data&n; * that was kept in them.  There is no reason to write this data out to&n; * the swap area if the application is discarding it.&n; *&n; * An interface that causes the system to free clean pages and flush&n; * dirty pages is already available as msync(MS_INVALIDATE).&n; */
DECL|function|madvise_dontneed
r_static
r_int
id|madvise_dontneed
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|flush_cache_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|zap_page_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|start
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
id|flush_tlb_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|madvise_vma
r_static
r_int
id|madvise_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
id|behavior
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|behavior
)paren
(brace
r_case
id|MADV_NORMAL
suffix:colon
r_case
id|MADV_SEQUENTIAL
suffix:colon
r_case
id|MADV_RANDOM
suffix:colon
id|error
op_assign
id|madvise_behavior
c_func
(paren
id|vma
comma
id|start
comma
id|end
comma
id|behavior
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MADV_WILLNEED
suffix:colon
id|error
op_assign
id|madvise_willneed
c_func
(paren
id|vma
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MADV_DONTNEED
suffix:colon
id|error
op_assign
id|madvise_dontneed
c_func
(paren
id|vma
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The madvise(2) system call.&n; *&n; * Applications can use madvise() to advise the kernel how it should&n; * handle paging I/O in this VM area.  The idea is to help the kernel&n; * use appropriate read-ahead and caching techniques.  The information&n; * provided is advisory only, and can be safely disregarded by the&n; * kernel without affecting the correct operation of the application.&n; *&n; * behavior values:&n; *  MADV_NORMAL - the default behavior is to read clusters.  This&n; *&t;&t;results in some read-ahead and read-behind.&n; *  MADV_RANDOM - the system should read the minimum amount of data&n; *&t;&t;on any access, since it is unlikely that the appli-&n; *&t;&t;cation will need more than what it asks for.&n; *  MADV_SEQUENTIAL - pages in the given range will probably be accessed&n; *&t;&t;once, so they can be aggressively read ahead, and&n; *&t;&t;can be freed soon after they are accessed.&n; *  MADV_WILLNEED - the application is notifying the system to read&n; *&t;&t;some pages ahead.&n; *  MADV_DONTNEED - the application is finished with the given range,&n; *&t;&t;so the kernel can free resources associated with it.&n; *&n; * return values:&n; *  zero    - success&n; *  -EINVAL - start + len &lt; 0, start is not page-aligned,&n; *&t;&t;&quot;behavior&quot; is not a valid value, or application&n; *&t;&t;is attempting to release locked or shared pages.&n; *  -ENOMEM - addresses in the specified range are not currently&n; *&t;&t;mapped, or are outside the AS of the process.&n; *  -EIO    - an I/O error occurred while paging in data.&n; *  -EBADF  - map exists, but area maps something that isn&squot;t a file.&n; *  -EAGAIN - a kernel resource was temporarily unavailable.&n; */
DECL|function|sys_madvise
id|asmlinkage
r_int
id|sys_madvise
c_func
(paren
r_int
r_int
id|start
comma
r_int
id|len
comma
r_int
id|behavior
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
id|unmapped_error
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_amp
op_complement
id|PAGE_MASK
)paren
r_goto
id|out
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
op_complement
id|PAGE_MASK
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|start
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|start
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If the interval [start,end) covers some unmapped address&n;&t; * ranges, just ignore them, but return -ENOMEM at the end.&n;&t; */
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Still start &lt; end. */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Here start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|start
OL
id|vma-&gt;vm_start
)paren
(brace
id|unmapped_error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|end
op_le
id|vma-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|start
OL
id|end
)paren
(brace
id|error
op_assign
id|madvise_vma
c_func
(paren
id|vma
comma
id|start
comma
id|end
comma
id|behavior
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|unmapped_error
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end &lt; end. */
id|error
op_assign
id|madvise_vma
c_func
(paren
id|vma
comma
id|start
comma
id|vma-&gt;vm_end
comma
id|behavior
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_end
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Later we can get more picky about what &quot;in core&quot; means precisely.&n; * For now, simply check to see if the page is in the page cache,&n; * and is up to date; i.e. that no page-in operation would be required&n; * at this time if an application were to map and access this page.&n; */
DECL|function|mincore_page
r_static
r_int
r_char
id|mincore_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|pgoff
)paren
(brace
r_int
r_char
id|present
op_assign
l_int|0
suffix:semicolon
r_struct
id|address_space
op_star
id|as
op_assign
op_amp
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_data
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|hash
op_assign
id|page_hash
c_func
(paren
id|as
comma
id|pgoff
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|page
op_assign
id|__find_page_nolock
c_func
(paren
id|as
comma
id|pgoff
comma
op_star
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
)paren
op_logical_and
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
)paren
id|present
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_return
id|present
suffix:semicolon
)brace
DECL|function|mincore_vma
r_static
r_int
id|mincore_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_char
op_star
id|vec
)paren
(brace
r_int
id|error
comma
id|i
comma
id|remaining
suffix:semicolon
r_int
r_char
op_star
id|tmp
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_file
)paren
r_return
id|error
suffix:semicolon
id|start
op_assign
(paren
(paren
id|start
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_pgoff
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|vma-&gt;vm_end
)paren
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
id|end
op_assign
(paren
(paren
id|end
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
id|vma-&gt;vm_pgoff
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|tmp
op_assign
(paren
r_int
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* (end - start) is # of pages, and also # of bytes in &quot;vec */
id|remaining
op_assign
(paren
id|end
op_minus
id|start
)paren
comma
id|error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|remaining
OG
l_int|0
suffix:semicolon
id|remaining
op_sub_assign
id|PAGE_SIZE
comma
id|i
op_increment
)paren
(brace
r_int
id|j
op_assign
l_int|0
suffix:semicolon
r_int
id|thispiece
op_assign
(paren
id|remaining
OL
id|PAGE_SIZE
)paren
ques
c_cond
id|remaining
suffix:colon
id|PAGE_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|thispiece
)paren
id|tmp
(braket
id|j
op_increment
)braket
op_assign
id|mincore_page
c_func
(paren
id|vma
comma
id|start
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|vec
op_plus
id|PAGE_SIZE
op_star
id|i
comma
id|tmp
comma
id|thispiece
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|tmp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The mincore(2) system call.&n; *&n; * mincore() returns the memory residency status of the pages in the&n; * current process&squot;s address space specified by [addr, addr + len).&n; * The status is returned in a vector of bytes.  The least significant&n; * bit of each byte is 1 if the referenced page is in memory, otherwise&n; * it is zero.&n; *&n; * Because the status of a page can change after mincore() checks it&n; * but before it returns to the application, the returned vector may&n; * contain stale information.  Only locked pages are guaranteed to&n; * remain in memory.&n; *&n; * return values:&n; *  zero    - success&n; *  -EFAULT - vec points to an illegal address&n; *  -EINVAL - addr is not a multiple of PAGE_CACHE_SIZE,&n; *&t;&t;or len has a nonpositive value&n; *  -ENOMEM - Addresses in the range [addr, addr + len] are&n; *&t;&t;invalid for the address space of this process, or&n; *&t;&t;specify one or more pages which are not currently&n; *&t;&t;mapped&n; *  -EAGAIN - A kernel resource was temporarily unavailable.&n; */
DECL|function|sys_mincore
id|asmlinkage
r_int
id|sys_mincore
c_func
(paren
r_int
r_int
id|start
comma
r_int
id|len
comma
r_int
r_char
op_star
id|vec
)paren
(brace
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
id|unmapped_error
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_amp
op_complement
id|PAGE_CACHE_MASK
)paren
r_goto
id|out
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
op_complement
id|PAGE_CACHE_MASK
)paren
op_amp
id|PAGE_CACHE_MASK
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|start
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|start
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If the interval [start,end) covers some unmapped address&n;&t; * ranges, just ignore them, but return -ENOMEM at the end.&n;&t; */
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Still start &lt; end. */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Here start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|start
OL
id|vma-&gt;vm_start
)paren
(brace
id|unmapped_error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end. */
r_if
c_cond
(paren
id|end
op_le
id|vma-&gt;vm_end
)paren
(brace
r_if
c_cond
(paren
id|start
OL
id|end
)paren
(brace
id|error
op_assign
id|mincore_vma
c_func
(paren
id|vma
comma
id|start
comma
id|end
comma
op_amp
id|vec
(braket
id|index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|unmapped_error
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Here vma-&gt;vm_start &lt;= start &lt; vma-&gt;vm_end &lt; end. */
id|error
op_assign
id|mincore_vma
c_func
(paren
id|vma
comma
id|start
comma
id|vma-&gt;vm_end
comma
op_amp
id|vec
(braket
id|index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|index
op_add_assign
(paren
id|vma-&gt;vm_end
op_minus
id|start
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_end
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_static
r_inline
DECL|function|__read_cache_page
r_struct
id|page
op_star
id|__read_cache_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
comma
r_int
(paren
op_star
id|filler
)paren
(paren
r_void
op_star
comma
r_struct
id|page
op_star
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|page
op_star
op_star
id|hash
op_assign
id|page_hash
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
id|repeat
suffix:colon
id|page
op_assign
id|__find_get_page
c_func
(paren
id|mapping
comma
id|index
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
(brace
id|cached_page
op_assign
id|page_cache_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|page
op_assign
id|cached_page
suffix:semicolon
r_if
c_cond
(paren
id|add_to_page_cache_unique
c_func
(paren
id|page
comma
id|mapping
comma
id|index
comma
id|hash
)paren
)paren
r_goto
id|repeat
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|filler
c_func
(paren
id|data
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_free
c_func
(paren
id|cached_page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * Read into the page cache. If a page already exists,&n; * and Page_Uptodate() is not set, try to fill the page.&n; */
DECL|function|read_cache_page
r_struct
id|page
op_star
id|read_cache_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
comma
r_int
(paren
op_star
id|filler
)paren
(paren
r_void
op_star
comma
r_struct
id|page
op_star
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|err
suffix:semicolon
id|retry
suffix:colon
id|page
op_assign
id|__read_cache_page
c_func
(paren
id|mapping
comma
id|index
comma
id|filler
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
op_logical_or
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|filler
c_func
(paren
id|data
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|page
suffix:semicolon
)brace
DECL|function|__grab_cache_page
r_static
r_inline
r_struct
id|page
op_star
id|__grab_cache_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
comma
r_struct
id|page
op_star
op_star
id|cached_page
)paren
(brace
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|hash
op_assign
id|page_hash
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
id|repeat
suffix:colon
id|page
op_assign
id|__find_lock_page
c_func
(paren
id|mapping
comma
id|index
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|cached_page
)paren
(brace
op_star
id|cached_page
op_assign
id|page_cache_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|cached_page
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|page
op_assign
op_star
id|cached_page
suffix:semicolon
r_if
c_cond
(paren
id|add_to_page_cache_unique
c_func
(paren
id|page
comma
id|mapping
comma
id|index
comma
id|hash
)paren
)paren
r_goto
id|repeat
suffix:semicolon
op_star
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns locked page at given index in given cache, creating it if needed.&n; */
DECL|function|grab_cache_page
r_struct
id|page
op_star
id|grab_cache_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
)paren
(brace
r_struct
id|page
op_star
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|__grab_cache_page
c_func
(paren
id|mapping
comma
id|index
comma
op_amp
id|cached_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_free
c_func
(paren
id|cached_page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|function|remove_suid
r_static
r_inline
r_void
id|remove_suid
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
r_int
id|mode
suffix:semicolon
multiline_comment|/* set S_IGID if S_IXGRP is set, and always set S_ISUID */
id|mode
op_assign
(paren
id|inode-&gt;i_mode
op_amp
id|S_IXGRP
)paren
op_star
(paren
id|S_ISGID
op_div
id|S_IXGRP
)paren
op_or
id|S_ISUID
suffix:semicolon
multiline_comment|/* was any of the uid bits set? */
id|mode
op_and_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FSETID
)paren
)paren
(brace
id|inode-&gt;i_mode
op_and_assign
op_complement
id|mode
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Write to a file through the page cache. &n; *&n; * We currently put everything into the page cache prior to writing it.&n; * This is not a problem when writing full pages. With partial pages,&n; * however, we first have to read the data into the cache, then&n; * dirty the page, and finally schedule it for writing. Alternatively, we&n; * could write-through just the portion of data that would go into that&n; * page, but that would kill performance for applications that write data&n; * line by line, and it&squot;s prone to race conditions.&n; *&n; * Note that this routine doesn&squot;t try to keep track of dirty pages. Each&n; * file system has to do this all by itself, unfortunately.&n; *&t;&t;&t;&t;&t;&t;&t;okir@monad.swb.de&n; */
id|ssize_t
DECL|function|generic_file_write
id|generic_file_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_int
r_int
id|limit
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_FSIZE
)braket
dot
id|rlim_cur
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|cached_page
suffix:semicolon
r_int
r_int
id|written
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|err
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|file-&gt;f_error
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|file-&gt;f_error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|written
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
id|pos
op_assign
id|inode-&gt;i_size
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether we&squot;ve reached the file size limit.&n;&t; */
id|err
op_assign
op_minus
id|EFBIG
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
id|RLIM_INFINITY
)paren
(brace
r_if
c_cond
(paren
id|pos
op_ge
id|limit
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
id|limit
op_minus
id|pos
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
id|count
op_assign
id|limit
op_minus
id|pos
suffix:semicolon
)brace
)brace
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|remove_suid
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty_sync
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
(brace
r_int
r_int
id|bytes
comma
id|index
comma
id|offset
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|deactivate
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to find the page in the cache. If it isn&squot;t there,&n;&t;&t; * allocate a free page.&n;&t;&t; */
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Within page */
id|index
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|bytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|count
)paren
(brace
id|bytes
op_assign
id|count
suffix:semicolon
id|deactivate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Bring in the user page that we will copy from _first_.&n;&t;&t; * Otherwise there&squot;s a nasty deadlock on copying from the&n;&t;&t; * same page as we&squot;re writing to, without it being marked&n;&t;&t; * up-to-date.&n;&t;&t; */
(brace
r_volatile
r_int
r_char
id|dummy
suffix:semicolon
id|__get_user
c_func
(paren
id|dummy
comma
id|buf
)paren
suffix:semicolon
id|__get_user
c_func
(paren
id|dummy
comma
id|buf
op_plus
id|bytes
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* we&squot;ll assign it later anyway */
id|page
op_assign
id|__grab_cache_page
c_func
(paren
id|mapping
comma
id|index
comma
op_amp
id|cached_page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
multiline_comment|/* We have exclusive IO access to the page.. */
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|status
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|prepare_write
c_func
(paren
id|file
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|unlock
suffix:semicolon
id|kaddr
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|status
op_assign
id|copy_from_user
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|buf
comma
id|bytes
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|fail_write
suffix:semicolon
id|status
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|commit_write
c_func
(paren
id|file
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|status
op_assign
id|bytes
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ge
l_int|0
)paren
(brace
id|written
op_add_assign
id|status
suffix:semicolon
id|count
op_sub_assign
id|status
suffix:semicolon
id|pos
op_add_assign
id|status
suffix:semicolon
id|buf
op_add_assign
id|status
suffix:semicolon
)brace
id|unlock
suffix:colon
multiline_comment|/* Mark it unlocked again and drop the page.. */
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deactivate
)paren
id|deactivate_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
op_star
id|ppos
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_free
c_func
(paren
id|cached_page
)paren
suffix:semicolon
multiline_comment|/* For now, when the user asks for O_SYNC, we&squot;ll actually&n;&t; * provide O_DSYNC. */
r_if
c_cond
(paren
(paren
id|status
op_ge
l_int|0
)paren
op_logical_and
(paren
id|file-&gt;f_flags
op_amp
id|O_SYNC
)paren
)paren
id|status
op_assign
id|generic_osync_inode
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 means datasync */
id|err
op_assign
id|written
ques
c_cond
id|written
suffix:colon
id|status
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|fail_write
suffix:colon
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
DECL|function|page_cache_init
r_void
id|__init
id|page_cache_init
c_func
(paren
r_int
r_int
id|mempages
)paren
(brace
r_int
r_int
id|htable_size
comma
id|order
suffix:semicolon
id|htable_size
op_assign
id|mempages
suffix:semicolon
id|htable_size
op_mul_assign
r_sizeof
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
OL
id|htable_size
suffix:semicolon
id|order
op_increment
)paren
(brace
suffix:semicolon
)brace
r_do
(brace
r_int
r_int
id|tmp
op_assign
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_div
r_sizeof
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
id|page_hash_bits
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_rshift_assign
l_int|1UL
)paren
op_ne
l_int|0UL
)paren
(brace
id|page_hash_bits
op_increment
suffix:semicolon
)brace
id|page_hash_table
op_assign
(paren
r_struct
id|page
op_star
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|page_hash_table
op_eq
l_int|NULL
op_logical_and
op_decrement
id|order
OG
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Page-cache hash table entries: %d (order: %ld, %ld bytes)&bslash;n&quot;
comma
(paren
l_int|1
op_lshift
id|page_hash_bits
)paren
comma
id|order
comma
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_hash_table
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate page hash table&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|page_hash_table
comma
l_int|0
comma
id|PAGE_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
)paren
suffix:semicolon
)brace
eof
