multiline_comment|/*&n; *  linux/mm/vmscan.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  Swap reorganised 29.12.95, Stephen Tweedie.&n; *  kswapd added: 7.1.96  sct&n; *  Removed kswapd_ctl limits, and swap out as many pages as needed&n; *  to bring the system back to freepages.high: 2.4.97, Rik van Riel.&n; *  Version: $Id: vmscan.c,v 1.5 1998/02/23 22:14:28 sct Exp $&n; *  Zone aware kswapd started 02/00, Kanoj Sarcar (kanoj@sgi.com).&n; *  Multiqueue VM started 5.8.00, Rik van Riel.&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
multiline_comment|/*&n; * The swap-out functions return 1 if they successfully&n; * threw something out, and we got a free page. It returns&n; * zero if it couldn&squot;t do anything, and any other value&n; * indicates it decreased rss, but the page was shared.&n; *&n; * NOTE! If it sleeps, it *must* return 1 to make sure we&n; * don&squot;t continue with the swap-out. Otherwise we may be&n; * using a process that no longer actually exists (it might&n; * have died while we slept).&n; */
DECL|function|try_to_swap_out
r_static
r_int
id|try_to_swap_out
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|page_table
comma
r_int
id|gfp_mask
)paren
(brace
id|pte_t
id|pte
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|onlist
suffix:semicolon
id|pte
op_assign
op_star
id|page_table
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|pte
)paren
)paren
r_goto
id|out_failed
suffix:semicolon
id|page
op_assign
id|pte_page
c_func
(paren
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|VALID_PAGE
c_func
(paren
id|page
)paren
)paren
op_logical_or
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_goto
id|out_failed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm-&gt;swap_cnt
)paren
r_return
l_int|1
suffix:semicolon
id|mm-&gt;swap_cnt
op_decrement
suffix:semicolon
id|onlist
op_assign
id|PageActive
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t look at this pte if it&squot;s been accessed recently. */
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|page_table
)paren
)paren
(brace
id|age_page_up
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out_failed
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|onlist
)paren
multiline_comment|/* The page is still mapped, so it can&squot;t be freeable... */
id|age_page_down_ageonly
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the page is in active use by us, or if the page&n;&t; * is in active use by others, don&squot;t unmap it or&n;&t; * (worse) start unneeded IO.&n;&t; */
r_if
c_cond
(paren
id|page-&gt;age
OG
l_int|0
)paren
r_goto
id|out_failed
suffix:semicolon
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
r_goto
id|out_failed
suffix:semicolon
multiline_comment|/* From this point on, the odds are that we&squot;re going to&n;&t; * nuke this pte, so read and clear the pte.  This hook&n;&t; * is needed on CPUs which update the accessed and dirty&n;&t; * bits in hardware.&n;&t; */
id|pte
op_assign
id|ptep_get_and_clear
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is the page already in the swap cache? If so, then&n;&t; * we can just drop our reference to it without doing&n;&t; * any IO - it&squot;s already up-to-date on disk.&n;&t; *&n;&t; * Return 0, as we didn&squot;t actually free any real&n;&t; * memory, and we should just continue our scan.&n;&t; */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|entry.val
op_assign
id|page-&gt;index
suffix:semicolon
r_if
c_cond
(paren
id|pte_dirty
c_func
(paren
id|pte
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_swap_pte
suffix:colon
id|swap_duplicate
c_func
(paren
id|entry
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|page_table
comma
id|swp_entry_to_pte
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
id|drop_pte
suffix:colon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|mm-&gt;rss
op_decrement
suffix:semicolon
id|deactivate_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out_failed
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Is it a clean page? Then it must be recoverable&n;&t; * by just paging it in again, and we can just drop&n;&t; * it..&n;&t; *&n;&t; * However, this won&squot;t actually free any real&n;&t; * memory, as the page will just be in the page cache&n;&t; * somewhere, and as such we should just continue&n;&t; * our scan.&n;&t; *&n;&t; * Basically, this just makes it possible for us to do&n;&t; * some real work in the future in &quot;refill_inactive()&quot;.&n;&t; */
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_dirty
c_func
(paren
id|pte
)paren
)paren
r_goto
id|drop_pte
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, it&squot;s really dirty. That means that&n;&t; * we should either create a new swap cache&n;&t; * entry for it, or we should write it back&n;&t; * to its own backing store.&n;&t; */
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
(brace
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|drop_pte
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is a dirty, swappable page.  First of all,&n;&t; * get a suitable swap entry for it, and make sure&n;&t; * we have the swap cache set up to associate the&n;&t; * page with that swap entry.&n;&t; */
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|out_unlock_restore
suffix:semicolon
multiline_comment|/* No swap space left */
multiline_comment|/* Add it to the swap cache and mark it dirty */
id|add_to_swap_cache
c_func
(paren
id|page
comma
id|entry
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|set_swap_pte
suffix:semicolon
id|out_unlock_restore
suffix:colon
id|set_pte
c_func
(paren
id|page_table
comma
id|pte
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * A new implementation of swap_out().  We do not swap complete processes,&n; * but only a small number of blocks, before we continue with the next&n; * process.  The number of blocks actually swapped is determined on the&n; * number of page faults, that this process actually had in the last time,&n; * so we won&squot;t swap heavily used processes all the time ...&n; *&n; * Note: the priority argument is a hint on much CPU to waste with the&n; *       swap block search, not a hint, of how much blocks to swap with&n; *       each process.&n; *&n; * (C) 1993 Kai Petzke, wpp@marie.physik.tu-berlin.de&n; */
DECL|function|swap_out_pmd
r_static
r_inline
r_int
id|swap_out_pmd
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pmd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|end
comma
r_int
id|gfp_mask
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|pmd_end
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pmd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|pmd_end
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|pmd_end
)paren
id|end
op_assign
id|pmd_end
suffix:semicolon
r_do
(brace
r_int
id|result
suffix:semicolon
id|mm-&gt;swap_address
op_assign
id|address
op_plus
id|PAGE_SIZE
suffix:semicolon
id|result
op_assign
id|try_to_swap_out
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|pte
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swap_out_pgd
r_static
r_inline
r_int
id|swap_out_pgd
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|end
comma
r_int
id|gfp_mask
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|pgd_end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pgd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|pgd_end
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
r_if
c_cond
(paren
id|pgd_end
op_logical_and
(paren
id|end
OG
id|pgd_end
)paren
)paren
id|end
op_assign
id|pgd_end
suffix:semicolon
r_do
(brace
r_int
id|result
op_assign
id|swap_out_pmd
c_func
(paren
id|mm
comma
id|vma
comma
id|pmd
comma
id|address
comma
id|end
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swap_out_vma
r_static
r_int
id|swap_out_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|gfp_mask
)paren
(brace
id|pgd_t
op_star
id|pgdir
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
multiline_comment|/* Don&squot;t swap out areas which are locked down */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_LOCKED
op_or
id|VM_RESERVED
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|pgdir
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
r_int
id|result
op_assign
id|swap_out_pgd
c_func
(paren
id|mm
comma
id|vma
comma
id|pgdir
comma
id|address
comma
id|end
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|pgdir
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swap_out_mm
r_static
r_int
id|swap_out_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
multiline_comment|/*&n;&t; * Go through process&squot; page directory.&n;&t; */
multiline_comment|/*&n;&t; * Find the proper vm-area after freezing the vma chain &n;&t; * and ptes.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|address
op_assign
id|mm-&gt;swap_address
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|address
OL
id|vma-&gt;vm_start
)paren
id|address
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|result
op_assign
id|swap_out_vma
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|out_unlock
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_break
suffix:semicolon
id|address
op_assign
id|vma-&gt;vm_start
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset to 0 when we reach the end of address space */
id|mm-&gt;swap_address
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;swap_cnt
op_assign
l_int|0
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Select the task with maximal swap_cnt and try to swap out a page.&n; * N.B. This function returns only 0 or 1.  Return values != 1 from&n; * the lower level routines result in continued processing.&n; */
DECL|macro|SWAP_SHIFT
mdefine_line|#define SWAP_SHIFT 5
DECL|macro|SWAP_MIN
mdefine_line|#define SWAP_MIN 8
DECL|function|swap_out
r_static
r_int
id|swap_out
c_func
(paren
r_int
r_int
id|priority
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
id|__ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * We make one or two passes through the task list, indexed by &n;&t; * assign = {0, 1}:&n;&t; *   Pass 1: select the swappable task with maximal RSS that has&n;&t; *         not yet been swapped out. &n;&t; *   Pass 2: re-assign rss swap_cnt values, then select as above.&n;&t; *&n;&t; * With this approach, there&squot;s no need to remember the last task&n;&t; * swapped out.  If the swap-out fails, we clear swap_cnt so the &n;&t; * task won&squot;t be selected again until all others have been tried.&n;&t; *&n;&t; * Think of swap_cnt as a &quot;shadow rss&quot; - it tells us which process&n;&t; * we want to page out (always try largest first).&n;&t; */
id|counter
op_assign
(paren
id|nr_threads
op_lshift
id|SWAP_SHIFT
)paren
op_rshift
id|priority
suffix:semicolon
r_if
c_cond
(paren
id|counter
OL
l_int|1
)paren
id|counter
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|counter
op_ge
l_int|0
suffix:semicolon
id|counter
op_decrement
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
r_int
id|max_cnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|mm_struct
op_star
id|best
op_assign
l_int|NULL
suffix:semicolon
r_int
id|assign
op_assign
l_int|0
suffix:semicolon
r_int
id|found_task
op_assign
l_int|0
suffix:semicolon
id|select
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|p
op_assign
id|init_mm.mmlist.next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
op_amp
id|init_mm.mmlist
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|mm_struct
comma
id|mmlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;rss
op_le
l_int|0
)paren
r_continue
suffix:semicolon
id|found_task
op_increment
suffix:semicolon
multiline_comment|/* Refresh swap_cnt? */
r_if
c_cond
(paren
id|assign
op_eq
l_int|1
)paren
(brace
id|mm-&gt;swap_cnt
op_assign
(paren
id|mm-&gt;rss
op_rshift
id|SWAP_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;swap_cnt
OL
id|SWAP_MIN
)paren
id|mm-&gt;swap_cnt
op_assign
id|SWAP_MIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mm-&gt;swap_cnt
OG
id|max_cnt
)paren
(brace
id|max_cnt
op_assign
id|mm-&gt;swap_cnt
suffix:semicolon
id|best
op_assign
id|mm
suffix:semicolon
)brace
)brace
multiline_comment|/* Make sure it doesn&squot;t disappear */
r_if
c_cond
(paren
id|best
)paren
id|atomic_inc
c_func
(paren
op_amp
id|best-&gt;mm_users
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We have dropped the tasklist_lock, but we&n;&t;&t; * know that &quot;mm&quot; still exists: we are running&n;&t;&t; * with the big kernel lock, and exit_mm()&n;&t;&t; * cannot race with us.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|best
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|assign
op_logical_and
id|found_task
OG
l_int|0
)paren
(brace
id|assign
op_assign
l_int|1
suffix:semicolon
r_goto
id|select
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|__ret
op_assign
id|swap_out_mm
c_func
(paren
id|best
comma
id|gfp_mask
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|best
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|__ret
suffix:semicolon
)brace
multiline_comment|/**&n; * reclaim_page -&t;reclaims one page from the inactive_clean list&n; * @zone: reclaim a page from this zone&n; *&n; * The pages on the inactive_clean can be instantly reclaimed.&n; * The tests look impressive, but most of the time we&squot;ll grab&n; * the first page of the list and exit successfully.&n; */
DECL|function|reclaim_page
r_struct
id|page
op_star
id|reclaim_page
c_func
(paren
id|zone_t
op_star
id|zone
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|page_lru
suffix:semicolon
r_int
id|maxscan
suffix:semicolon
multiline_comment|/*&n;&t; * We only need the pagemap_lru_lock if we don&squot;t reclaim the page,&n;&t; * but we have to grab the pagecache_lock before the pagemap_lru_lock&n;&t; * to avoid deadlocks and most of the time we&squot;ll succeed anyway.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|maxscan
op_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
r_while
c_loop
(paren
(paren
id|page_lru
op_assign
id|zone-&gt;inactive_clean_list.prev
)paren
op_ne
op_amp
id|zone-&gt;inactive_clean_list
op_logical_and
id|maxscan
op_decrement
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_lru
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
multiline_comment|/* Wrong page on list?! (list corruption, should not happen) */
r_if
c_cond
(paren
op_logical_neg
id|PageInactiveClean
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: reclaim_page, wrong page on list.&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|page-&gt;zone-&gt;inactive_clean_pages
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Page is or was in use?  Move it to the active list. */
r_if
c_cond
(paren
id|PageTestandClearReferenced
c_func
(paren
id|page
)paren
op_logical_or
id|page-&gt;age
OG
l_int|0
op_logical_or
(paren
op_logical_neg
id|page-&gt;buffers
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
OG
l_int|1
)paren
)paren
(brace
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* The page is dirty, or locked, move to inactive_dirty list. */
r_if
c_cond
(paren
id|page-&gt;buffers
op_logical_or
id|PageDirty
c_func
(paren
id|page
)paren
op_logical_or
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* OK, remove the page from the caches. */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|__delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|found_page
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
(brace
id|__remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|found_page
suffix:semicolon
)brace
multiline_comment|/* We should never ever get here. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VM: reclaim_page, found unknown page&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|zone-&gt;inactive_clean_pages
op_decrement
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset page pointer, maybe we encountered an unfreeable page. */
id|page
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|found_page
suffix:colon
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;age
op_assign
id|PAGE_AGE_START
suffix:semicolon
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;VM: reclaim_page, found page with count %d!&bslash;n&quot;
comma
id|page_count
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|memory_pressure
op_increment
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * page_launder - clean dirty inactive pages, move to inactive_clean list&n; * @gfp_mask: what operations we are allowed to do&n; * @sync: should we wait synchronously for the cleaning of pages&n; *&n; * When this function is called, we are most likely low on free +&n; * inactive_clean pages. Since we want to refill those pages as&n; * soon as possible, we&squot;ll make two loops over the inactive list,&n; * one to move the already cleaned pages to the inactive_clean lists&n; * and one to (often asynchronously) clean the dirty inactive pages.&n; *&n; * In situations where kswapd cannot keep up, user processes will&n; * end up calling this function. Since the user process needs to&n; * have a page before it can continue with its allocation, we&squot;ll&n; * do synchronous page flushing in that case.&n; *&n; * This code is heavily inspired by the FreeBSD source code. Thanks&n; * go out to Matthew Dillon.&n; */
DECL|macro|MAX_LAUNDER
mdefine_line|#define MAX_LAUNDER &t;&t;(4 * (1 &lt;&lt; page_cluster))
DECL|function|page_launder
r_int
id|page_launder
c_func
(paren
r_int
id|gfp_mask
comma
r_int
id|sync
)paren
(brace
r_int
id|launder_loop
comma
id|maxscan
comma
id|cleaned_pages
comma
id|maxlaunder
suffix:semicolon
r_int
id|can_get_io_locks
suffix:semicolon
r_struct
id|list_head
op_star
id|page_lru
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * We can only grab the IO locks (eg. for flushing dirty&n;&t; * buffers to disk) if __GFP_IO is set.&n;&t; */
id|can_get_io_locks
op_assign
id|gfp_mask
op_amp
id|__GFP_IO
suffix:semicolon
id|launder_loop
op_assign
l_int|0
suffix:semicolon
id|maxlaunder
op_assign
l_int|0
suffix:semicolon
id|cleaned_pages
op_assign
l_int|0
suffix:semicolon
id|dirty_page_rescan
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|maxscan
op_assign
id|nr_inactive_dirty_pages
suffix:semicolon
r_while
c_loop
(paren
(paren
id|page_lru
op_assign
id|inactive_dirty_list.prev
)paren
op_ne
op_amp
id|inactive_dirty_list
op_logical_and
id|maxscan
op_decrement
OG
l_int|0
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_lru
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
multiline_comment|/* Wrong page on list?! (list corruption, should not happen) */
r_if
c_cond
(paren
op_logical_neg
id|PageInactiveDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: page_launder, wrong page on list.&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|nr_inactive_dirty_pages
op_decrement
suffix:semicolon
id|page-&gt;zone-&gt;inactive_dirty_pages
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Page is or was in use?  Move it to the active list. */
r_if
c_cond
(paren
id|PageTestandClearReferenced
c_func
(paren
id|page
)paren
op_logical_or
id|page-&gt;age
OG
l_int|0
op_logical_or
(paren
op_logical_neg
id|page-&gt;buffers
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
OG
l_int|1
)paren
op_logical_or
id|page_ramdisk
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The page is locked. IO in progress?&n;&t;&t; * Move it to the back of the list.&n;&t;&t; */
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
(brace
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|page_lru
comma
op_amp
id|inactive_dirty_list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Dirty swap-cache page? Write it out if&n;&t;&t; * last copy..&n;&t;&t; */
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
r_int
(paren
op_star
id|writepage
)paren
(paren
r_struct
id|page
op_star
)paren
op_assign
id|page-&gt;mapping-&gt;a_ops-&gt;writepage
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|writepage
)paren
r_goto
id|page_active
suffix:semicolon
multiline_comment|/* First time through? Move it to the back of the list */
r_if
c_cond
(paren
op_logical_neg
id|launder_loop
)paren
(brace
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|page_lru
comma
op_amp
id|inactive_dirty_list
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* OK, do a physical asynchronous write to swap.  */
id|ClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|result
op_assign
id|writepage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* And re-start the thing.. */
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* writepage refused to do anything */
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|page_active
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the page has buffers, try to free the buffer mappings&n;&t;&t; * associated with this page. If we succeed we either free&n;&t;&t; * the page (in case it was a buffercache only page) or we&n;&t;&t; * move the page to the inactive_clean list.&n;&t;&t; *&n;&t;&t; * On the first round, we should free all previously cleaned&n;&t;&t; * buffer pages&n;&t;&t; */
r_if
c_cond
(paren
id|page-&gt;buffers
)paren
(brace
r_int
id|wait
comma
id|clearedbuf
suffix:semicolon
r_int
id|freed_page
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since we might be doing disk IO, we have to&n;&t;&t;&t; * drop the spinlock and take an extra reference&n;&t;&t;&t; * on the page so it doesn&squot;t go away from under us.&n;&t;&t;&t; */
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
multiline_comment|/* Will we do (asynchronous) IO? */
r_if
c_cond
(paren
id|launder_loop
op_logical_and
id|maxlaunder
op_eq
l_int|0
op_logical_and
id|sync
)paren
id|wait
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Synchrounous IO */
r_else
r_if
c_cond
(paren
id|launder_loop
op_logical_and
id|maxlaunder
op_decrement
OG
l_int|0
)paren
id|wait
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Async IO */
r_else
id|wait
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No IO */
multiline_comment|/* Try to free the page buffers. */
id|clearedbuf
op_assign
id|try_to_free_buffers
c_func
(paren
id|page
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Re-take the spinlock. Note that we cannot&n;&t;&t;&t; * unlock the page yet since we&squot;re still&n;&t;&t;&t; * accessing the page_struct here...&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
multiline_comment|/* The buffers were not freed. */
r_if
c_cond
(paren
op_logical_neg
id|clearedbuf
)paren
(brace
id|add_page_to_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The page was only in the buffer cache. */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|buffermem_pages
)paren
suffix:semicolon
id|freed_page
op_assign
l_int|1
suffix:semicolon
id|cleaned_pages
op_increment
suffix:semicolon
multiline_comment|/* The page has more users besides the cache and us. */
)brace
r_else
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
OG
l_int|2
)paren
(brace
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* OK, we &quot;created&quot; a freeable page. */
)brace
r_else
multiline_comment|/* page-&gt;mapping &amp;&amp; page_count(page) == 2 */
(brace
id|add_page_to_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|cleaned_pages
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Unlock the page and drop the extra reference.&n;&t;&t;&t; * We can only do it here because we ar accessing&n;&t;&t;&t; * the page struct above.&n;&t;&t;&t; */
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * If we&squot;re freeing buffer cache pages, stop when&n;&t;&t;&t; * we&squot;ve got enough free memory.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|freed_page
op_logical_and
op_logical_neg
id|free_shortage
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_and
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If a page had an extra reference in&n;&t;&t;&t; * deactivate_page(), we will find it here.&n;&t;&t;&t; * Now the page is really freeable, so we&n;&t;&t;&t; * move it to the inactive_clean list.&n;&t;&t;&t; */
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|cleaned_pages
op_increment
suffix:semicolon
)brace
r_else
(brace
id|page_active
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * OK, we don&squot;t know what to do with the page.&n;&t;&t;&t; * It&squot;s no use keeping it here, so we move it to&n;&t;&t;&t; * the active list.&n;&t;&t;&t; */
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t have enough free pages, we loop back once&n;&t; * to queue the dirty pages for writeout. When we were called&n;&t; * by a user process (that /needs/ a free page) and we didn&squot;t&n;&t; * free anything yet, we wait synchronously on the writeout of&n;&t; * MAX_SYNC_LAUNDER pages.&n;&t; *&n;&t; * We also wake up bdflush, since bdflush should, under most&n;&t; * loads, flush out the dirty pages before we have to wait on&n;&t; * IO.&n;&t; */
r_if
c_cond
(paren
id|can_get_io_locks
op_logical_and
op_logical_neg
id|launder_loop
op_logical_and
id|free_shortage
c_func
(paren
)paren
)paren
(brace
id|launder_loop
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If we cleaned pages, never do synchronous IO. */
r_if
c_cond
(paren
id|cleaned_pages
)paren
id|sync
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We only do a few &quot;out of order&quot; flushes. */
id|maxlaunder
op_assign
id|MAX_LAUNDER
suffix:semicolon
multiline_comment|/* Kflushd takes care of the rest. */
id|wakeup_bdflush
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|dirty_page_rescan
suffix:semicolon
)brace
multiline_comment|/* Return the number of pages moved to the inactive_clean list. */
r_return
id|cleaned_pages
suffix:semicolon
)brace
multiline_comment|/**&n; * refill_inactive_scan - scan the active list and find pages to deactivate&n; * @priority: the priority at which to scan&n; * @oneshot: exit after deactivating one page&n; *&n; * This function will scan a portion of the active list to find&n; * unused pages, those pages will then be moved to the inactive list.&n; */
DECL|function|refill_inactive_scan
r_int
id|refill_inactive_scan
c_func
(paren
r_int
r_int
id|priority
comma
r_int
id|oneshot
)paren
(brace
r_struct
id|list_head
op_star
id|page_lru
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|maxscan
comma
id|page_active
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Take the lock while messing with the list... */
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|maxscan
op_assign
id|nr_active_pages
op_rshift
id|priority
suffix:semicolon
r_while
c_loop
(paren
id|maxscan
op_decrement
OG
l_int|0
op_logical_and
(paren
id|page_lru
op_assign
id|active_list.prev
)paren
op_ne
op_amp
id|active_list
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_lru
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
multiline_comment|/* Wrong page on list?! (list corruption, should not happen) */
r_if
c_cond
(paren
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: refill_inactive, wrong page on list.&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|nr_active_pages
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Do aging on the pages. */
r_if
c_cond
(paren
id|PageTestandClearReferenced
c_func
(paren
id|page
)paren
)paren
(brace
id|age_page_up_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_active
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|age_page_down_ageonly
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since we don&squot;t hold a reference on the page&n;&t;&t;&t; * ourselves, we have to do our test a bit more&n;&t;&t;&t; * strict then deactivate_page(). This is needed&n;&t;&t;&t; * since otherwise the system could hang shuffling&n;&t;&t;&t; * unfreeable pages from the active list to the&n;&t;&t;&t; * inactive_dirty list and back again...&n;&t;&t;&t; *&n;&t;&t;&t; * SUBTLE: we can have buffer pages with count 1.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|page-&gt;age
op_eq
l_int|0
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
op_le
(paren
id|page-&gt;buffers
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
)paren
(brace
id|deactivate_page_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_active
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|page_active
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If the page is still on the active list, move it&n;&t;&t; * to the other end of the list. Otherwise it was&n;&t;&t; * deactivated by age_page_down and we exit successfully.&n;&t;&t; */
r_if
c_cond
(paren
id|page_active
op_logical_or
id|PageActive
c_func
(paren
id|page
)paren
)paren
(brace
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|page_lru
comma
op_amp
id|active_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|oneshot
)paren
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if there are zones with a severe shortage of free pages,&n; * or if all zones have a minor shortage.&n; */
DECL|function|free_shortage
r_int
id|free_shortage
c_func
(paren
r_void
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_int
id|freeable
op_assign
id|nr_free_pages
c_func
(paren
)paren
op_plus
id|nr_inactive_clean_pages
c_func
(paren
)paren
suffix:semicolon
r_int
id|freetarget
op_assign
id|freepages.high
op_plus
id|inactive_target
op_div
l_int|3
suffix:semicolon
multiline_comment|/* Are we low on free pages globally? */
r_if
c_cond
(paren
id|freeable
OL
id|freetarget
)paren
r_return
id|freetarget
op_minus
id|freeable
suffix:semicolon
multiline_comment|/* If not, are we very low on any particular zone? */
r_do
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|zone_t
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;size
op_logical_and
(paren
id|zone-&gt;inactive_clean_pages
op_plus
id|zone-&gt;free_pages
OL
id|zone-&gt;pages_min
op_plus
l_int|1
)paren
)paren
(brace
multiline_comment|/* + 1 to have overlap with alloc_pages() !! */
id|sum
op_add_assign
id|zone-&gt;pages_min
op_plus
l_int|1
suffix:semicolon
id|sum
op_sub_assign
id|zone-&gt;free_pages
suffix:semicolon
id|sum
op_sub_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
)brace
)brace
id|pgdat
op_assign
id|pgdat-&gt;node_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgdat
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n; * How many inactive pages are we short?&n; */
DECL|function|inactive_shortage
r_int
id|inactive_shortage
c_func
(paren
r_void
)paren
(brace
r_int
id|shortage
op_assign
l_int|0
suffix:semicolon
id|shortage
op_add_assign
id|freepages.high
suffix:semicolon
id|shortage
op_add_assign
id|inactive_target
suffix:semicolon
id|shortage
op_sub_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|shortage
op_sub_assign
id|nr_inactive_clean_pages
c_func
(paren
)paren
suffix:semicolon
id|shortage
op_sub_assign
id|nr_inactive_dirty_pages
suffix:semicolon
r_if
c_cond
(paren
id|shortage
OG
l_int|0
)paren
r_return
id|shortage
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We need to make the locks finer granularity, but right&n; * now we need this so that we can do page allocations&n; * without holding the kernel lock etc.&n; *&n; * We want to try to free &quot;count&quot; pages, and we want to &n; * cluster them so that we get good swap-out behaviour.&n; *&n; * OTOH, if we&squot;re a user process (and not kswapd), we&n; * really care about latency. In that case we don&squot;t try&n; * to free too many pages.&n; */
DECL|function|refill_inactive
r_static
r_int
id|refill_inactive
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
id|user
)paren
(brace
r_int
id|priority
comma
id|count
comma
id|start_count
comma
id|made_progress
suffix:semicolon
id|count
op_assign
id|inactive_shortage
c_func
(paren
)paren
op_plus
id|free_shortage
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user
)paren
id|count
op_assign
(paren
l_int|1
op_lshift
id|page_cluster
)paren
suffix:semicolon
id|start_count
op_assign
id|count
suffix:semicolon
multiline_comment|/* Always trim SLAB caches when memory gets low. */
id|kmem_cache_reap
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
id|priority
op_assign
l_int|6
suffix:semicolon
r_do
(brace
id|made_progress
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
(brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|refill_inactive_scan
c_func
(paren
id|priority
comma
l_int|1
)paren
)paren
(brace
id|made_progress
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|count
op_le
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * don&squot;t be too light against the d/i cache since&n;&t;   &t; * refill_inactive() almost never fail when there&squot;s&n;&t;   &t; * really plenty of memory free. &n;&t;&t; */
id|shrink_dcache_memory
c_func
(paren
id|priority
comma
id|gfp_mask
)paren
suffix:semicolon
id|shrink_icache_memory
c_func
(paren
id|priority
comma
id|gfp_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Then, try to page stuff out..&n;&t;&t; */
r_while
c_loop
(paren
id|swap_out
c_func
(paren
id|priority
comma
id|gfp_mask
)paren
)paren
(brace
id|made_progress
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|count
op_le
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we either have enough free memory, or if&n;&t;&t; * page_launder() will be able to make enough&n;&t;&t; * free memory, then stop.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|inactive_shortage
c_func
(paren
)paren
op_logical_or
op_logical_neg
id|free_shortage
c_func
(paren
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only switch to a lower &quot;priority&quot; if we&n;&t;&t; * didn&squot;t make any useful progress in the&n;&t;&t; * last loop.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|made_progress
)paren
id|priority
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|priority
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Always end on a refill_inactive.., may sleep... */
r_while
c_loop
(paren
id|refill_inactive_scan
c_func
(paren
l_int|0
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|count
op_le
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
id|done
suffix:colon
r_return
(paren
id|count
OL
id|start_count
)paren
suffix:semicolon
)brace
DECL|function|do_try_to_free_pages
r_static
r_int
id|do_try_to_free_pages
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
id|user
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re low on free pages, move pages from the&n;&t; * inactive_dirty list to the inactive_clean list.&n;&t; *&n;&t; * Usually bdflush will have pre-cleaned the pages&n;&t; * before we get around to moving them to the other&n;&t; * list, so this is a relatively cheap operation.&n;&t; */
r_if
c_cond
(paren
id|free_shortage
c_func
(paren
)paren
op_logical_or
id|nr_inactive_dirty_pages
OG
id|nr_free_pages
c_func
(paren
)paren
op_plus
id|nr_inactive_clean_pages
c_func
(paren
)paren
)paren
id|ret
op_add_assign
id|page_launder
c_func
(paren
id|gfp_mask
comma
id|user
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If needed, we move pages from the active list&n;&t; * to the inactive list. We also &quot;eat&quot; pages from&n;&t; * the inode and dentry cache whenever we do this.&n;&t; */
r_if
c_cond
(paren
id|free_shortage
c_func
(paren
)paren
op_logical_or
id|inactive_shortage
c_func
(paren
)paren
)paren
(brace
id|shrink_dcache_memory
c_func
(paren
l_int|6
comma
id|gfp_mask
)paren
suffix:semicolon
id|shrink_icache_memory
c_func
(paren
l_int|6
comma
id|gfp_mask
)paren
suffix:semicolon
id|ret
op_add_assign
id|refill_inactive
c_func
(paren
id|gfp_mask
comma
id|user
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Reclaim unused slab cache memory.&n;&t;&t; */
id|kmem_cache_reap
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|kswapd_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|kswapd_wait
)paren
suffix:semicolon
DECL|variable|kswapd_done
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|kswapd_done
)paren
suffix:semicolon
DECL|variable|kswapd_task
r_struct
id|task_struct
op_star
id|kswapd_task
suffix:semicolon
multiline_comment|/*&n; * The background pageout daemon, started as a kernel thread&n; * from the init process. &n; *&n; * This basically trickles out pages so that we have _some_&n; * free memory available even if there is no other activity&n; * that frees anything up. This is needed for things like routing&n; * etc, where we otherwise might have all activity going on in&n; * asynchronous contexts that cannot page things out.&n; *&n; * If there are applications that are active memory-allocators&n; * (most normal use), this basically shouldn&squot;t matter.&n; */
DECL|function|kswapd
r_int
id|kswapd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|tsk-&gt;session
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;kswapd&quot;
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
id|kswapd_task
op_assign
id|tsk
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the memory management that we&squot;re a &quot;memory allocator&quot;,&n;&t; * and that if we need more memory we should get access to it&n;&t; * regardless (see &quot;__alloc_pages()&quot;). &quot;kswapd&quot; should&n;&t; * never get caught in the normal page freeing logic.&n;&t; *&n;&t; * (Kswapd normally doesn&squot;t need memory anyway, but sometimes&n;&t; * you need a small amount of memory in order to be able to&n;&t; * page out something else, and this flag essentially protects&n;&t; * us from recursively trying to free more memory as we&squot;re&n;&t; * trying to free the first piece of memory in the first place).&n;&t; */
id|tsk-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
multiline_comment|/*&n;&t; * Kswapd main loop.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_static
r_int
id|recalc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If needed, try to free some memory. */
r_if
c_cond
(paren
id|inactive_shortage
c_func
(paren
)paren
op_logical_or
id|free_shortage
c_func
(paren
)paren
)paren
(brace
r_int
id|wait
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do we need to do some synchronous flushing? */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|kswapd_done
)paren
)paren
id|wait
op_assign
l_int|1
suffix:semicolon
id|do_try_to_free_pages
c_func
(paren
id|GFP_KSWAPD
comma
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Do some (very minimal) background scanning. This&n;&t;&t; * will scan all pages on the active list once&n;&t;&t; * every minute. This clears old referenced bits&n;&t;&t; * and moves unused pages to the inactive list.&n;&t;&t; */
id|refill_inactive_scan
c_func
(paren
l_int|6
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Once a second, recalculate some VM stats. */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|recalc
op_plus
id|HZ
)paren
)paren
(brace
id|recalc
op_assign
id|jiffies
suffix:semicolon
id|recalculate_vm_stats
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wake up everybody waiting for free memory&n;&t;&t; * and unplug the disk queue.&n;&t;&t; */
id|wake_up_all
c_func
(paren
op_amp
id|kswapd_done
)paren
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * We go to sleep if either the free page shortage&n;&t;&t; * or the inactive page shortage is gone. We do this&n;&t;&t; * because:&n;&t;&t; * 1) we need no more free pages   or&n;&t;&t; * 2) the inactive pages need to be flushed to disk,&n;&t;&t; *    it wouldn&squot;t help to eat CPU time now ...&n;&t;&t; *&n;&t;&t; * We go to sleep for one second, but if it&squot;s needed&n;&t;&t; * we&squot;ll be woken up earlier...&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|free_shortage
c_func
(paren
)paren
op_logical_or
op_logical_neg
id|inactive_shortage
c_func
(paren
)paren
)paren
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|kswapd_wait
comma
id|HZ
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we couldn&squot;t free enough memory, we see if it was&n;&t;&t; * due to the system just not having enough memory.&n;&t;&t; * If that is the case, the only solution is to kill&n;&t;&t; * a process (the alternative is enternal deadlock).&n;&t;&t; *&n;&t;&t; * If there still is enough memory around, we just loop&n;&t;&t; * and try free some more memory...&n;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|out_of_memory
c_func
(paren
)paren
)paren
(brace
id|oom_kill
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|wakeup_kswapd
r_void
id|wakeup_kswapd
c_func
(paren
r_int
id|block
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
op_eq
id|kswapd_task
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
(brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|kswapd_wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|kswapd_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Kswapd could wake us up before we get a chance&n;&t; * to sleep, so we have to be very careful here to&n;&t; * prevent SMP races...&n;&t; */
id|__set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|kswapd_done
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|kswapd_wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|kswapd_wait
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|kswapd_done
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by non-kswapd processes when they want more&n; * memory but are unable to sleep on kswapd because&n; * they might be holding some IO locks ...&n; */
DECL|function|try_to_free_pages
r_int
id|try_to_free_pages
c_func
(paren
r_int
r_int
id|gfp_mask
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
id|ret
op_assign
id|do_try_to_free_pages
c_func
(paren
id|gfp_mask
comma
l_int|1
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_MEMALLOC
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|kreclaimd_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|kreclaimd_wait
)paren
suffix:semicolon
multiline_comment|/*&n; * Kreclaimd will move pages from the inactive_clean list to the&n; * free list, in order to keep atomic allocations possible under&n; * all circumstances. Even when kswapd is blocked on IO.&n; */
DECL|function|kreclaimd
r_int
id|kreclaimd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
id|tsk-&gt;session
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;kreclaimd&quot;
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * We sleep until someone wakes us up from&n;&t;&t; * page_alloc.c::__alloc_pages().&n;&t;&t; */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|kreclaimd_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move some pages from the inactive_clean lists to&n;&t;&t; * the free lists, if it is needed.&n;&t;&t; */
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
r_do
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|zone_t
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;size
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|zone-&gt;free_pages
OL
id|zone-&gt;pages_low
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|reclaim_page
c_func
(paren
id|zone
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|pgdat
op_assign
id|pgdat-&gt;node_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgdat
)paren
suffix:semicolon
)brace
)brace
DECL|function|kswapd_init
r_static
r_int
id|__init
id|kswapd_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Starting kswapd v1.8&bslash;n&quot;
)paren
suffix:semicolon
id|swap_setup
c_func
(paren
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|kswapd
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGNAL
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|kreclaimd
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGNAL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|kswapd_init
)paren
eof
